{
    "python": {
        "javascript": [
            "/**\n * @param {Array<number>} numbers\n * @param {number} threshold\n * @returns {boolean}\n */\nexport const hasCloseElements = (numbers, threshold) => {\n    for (let i = 0; i < numbers.length; i++) {\n        for (let j = i + 1; j < numbers.length; j++) {\n            if (Math.abs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n",
            "/**\n * @param {string} parenString\n * @returns {Array<string>}\n */\nexport const separateParenGroups = (parenString) => {\n    let groups = [];\n    let stk = [];\n    let currentGroup = \"\";\n    let parens = parenString.replace(\" \", \"\");\n    for (let ch of parens) {\n        if (ch === \"(\") {\n            stk.push(ch);\n            currentGroup += ch;\n        } else if (ch === \")\") {\n            stk.pop();\n            currentGroup += ch;\n            if (!stk.length) {\n                groups.push(currentGroup);\n                currentGroup = \"\";\n            }\n        }\n    }\n    return groups;\n}\n",
            "/**\n * @param {number} num\n * @returns {number}\n */\nexport const truncateNumber = (num) => {\n    return num - Math.floor(num);\n}\n",
            "/**\n * @param {Array<number>} operations\n * @returns {boolean}\n */\nexport const belowZero = (operations) => {\n    let balance = 0;\n    for (let op of operations) {\n        balance += op;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n};\n",
            "/**\n * @param {Array<number>} numbers\n * @returns {number}\n */\nexport const meanAbsoluteDeviation = (numbers) => {\n    const mean = numbers.reduce((acc, num) => acc + num, 0) / numbers.length;\n    const deviation = numbers.reduce((acc, num) => acc + Math.abs(num - mean), 0);\n    return deviation / numbers.length;\n}\n",
            "/**\n * @param {Array<number>} numbers\n * @param {number} delimiter\n * @returns {Array<number>}\n */\nexport const intersperse = (numbers, delimiter) => {\n    let result = [];\n    for (let i = 0; i < numbers.length; i++) {\n        if (i !== 0) {\n            result.push(delimiter);\n        }\n        result.push(numbers[i]);\n    }\n    return result;\n}\n",
            "/**\n * @param {string} parenString\n * @returns {Array<number>}\n */\nexport const parseNestedParens = (parenString) => {\n    const result = [];\n    const parenGroups = parenString.split(' ');\n    for (const group of parenGroups) {\n        let maxDepth = 0;\n        let depth = 0;\n        for (const ch of group) {\n            if (ch === '(') {\n                depth += 1;\n                maxDepth = Math.max(maxDepth, depth);\n            } else if (ch === ')') {\n                depth -= 1;\n            }\n        }\n        result.push(maxDepth);\n    }\n    return result;\n}\n",
            "/**\n * @param {Array<string>} strs\n * @param {string} substring\n * @returns {Array<string>}\n */\nexport const filterBySubstring = (strs, substring) => {\n    return strs.filter(s => s.includes(substring));\n}\n",
            "/**\n * @param {Array<number>} numbers\n * @returns {Array<number>}\n */\nexport const sumProduct = (numbers) => {\n    const n_sum = numbers.reduce((acc, num) => acc + num, 0);\n    const n_product = numbers.reduce((acc, num) => acc * num, 1);\n    return [n_sum, n_product];\n}\n",
            "/**\n * @param {Array<number>} numbers\n * @returns {Array<number>}\n */\nexport const rollingMax = (numbers) => {\n    let maxSoFar = -Infinity;\n    const result = [];\n    for (const num of numbers) {\n        maxSoFar = Math.max(maxSoFar, num);\n        result.push(maxSoFar);\n    }\n    return result;\n}\n",
            "/**\n * @param {string} s\n * @returns {boolean}\n */\nconst isPalindrome = (s) => {\n    return s === s.split('').reverse().join('');\n}\n\n/**\n * @param {string} s\n * @returns {string}\n */\nexport const makePalindrome = (s) => {\n    if (isPalindrome(s)) {\n        return s;\n    }\n    for (let i = 0; i < s.length; i++) {\n        if (isPalindrome(s.substring(i))) {\n            return s + s.substring(0, i).split('').reverse().join('');\n        }\n    }\n    return \"\";\n}\n",
            "/**\n * @param {string} a\n * @param {string} b\n * @returns {string}\n */\nexport const stringXor = (a, b) => {\n    return Array.from(a).map((x, i) => x === b[i] ? '0' : '1').join('');\n}\n",
            "/**\n * @param {Array<string>} strs\n * @returns {?string}\n */\nexport const longest = (strs) => {\n    if (!strs || strs.length === 0) {\n        return null;\n    }\n    let longest_s = strs[0];\n    for (let s of strs) {\n        if (s.length > longest_s.length) {\n            longest_s = s;\n        }\n    }\n    return longest_s;\n}\n",
            "/**\n * @param {number} a\n * @param {number} b\n * @returns {number}\n */\nexport const greatestCommonDivisor = (a, b) => {\n    if (b === 0) {\n        return a;\n    } else {\n        return greatestCommonDivisor(b, a % b);\n    }\n};\n",
            "/**\n * @param {string} s\n * @returns {Array<string>}\n */\nexport const allPrefixes = (s) => {\n    let prefixes = [];\n    for (let i = 0; i < s.length; i++) {\n        prefixes.push(s.substring(0, i + 1));\n    }\n    return prefixes;\n}\n",
            "/**\n * @param {number} n\n * @returns {string}\n */\nexport const stringSequence = (n) => {\n    return Array.from({ length: n + 1 }, (_, i) => i).join(' ');\n}\n",
            "/**\n * @param {string} s\n * @returns {number}\n */\nexport const countDistinctCharacters = (s) => {\n    return new Set(s.toLowerCase()).size;\n}\n",
            "/**\n * @param {string} musicString\n * @returns {Array<number>}\n */\nexport const parseMusic = (musicString) => {\n    const durations = {\"o\": 4, \"o|\": 2, \".|\": 1};\n    const notes = musicString.split(\" \");\n    return notes.map(note => durations[note]);\n}\n",
            "/**\n * @param {string} s\n * @param {string} substring\n * @returns {number}\n */\nexport const howManyTimes = (s, substring) => {\n    let times = 0;\n    for (let i = 0; i <= s.length - substring.length; i++) {\n        if (s.substring(i, i + substring.length) === substring) {\n            times += 1;\n        }\n    }\n    return times;\n}\n",
            "/**\n * @param {string} numbers\n * @returns {string}\n */\nexport const sortNumbers = (numbers) => {\n    const numDict = {\n        \"zero\": 0,\n        \"one\": 1,\n        \"two\": 2,\n        \"three\": 3,\n        \"four\": 4,\n        \"five\": 5,\n        \"six\": 6,\n        \"seven\": 7,\n        \"eight\": 8,\n        \"nine\": 9,\n    };\n    const numList = numbers.split(\" \").filter(x => x in numDict);\n    numList.sort((a, b) => numDict[a] - numDict[b]);\n    return numList.join(\" \");\n}\n",
            "/**\n * @param {Array<number>} numbers\n * @returns {Array<number>}\n */\nexport const findClosestElements = (numbers) => {\n    let sortedNumbers = [...numbers].sort((a, b) => a - b);\n    let minDiff = Infinity;\n    let closestPair = [];\n    for (let i = 1; i < sortedNumbers.length; i++) {\n        let diff = sortedNumbers[i] - sortedNumbers[i - 1];\n        if (diff < minDiff) {\n            minDiff = diff;\n            closestPair = [sortedNumbers[i - 1], sortedNumbers[i]];\n        }\n    }\n    return closestPair;\n}\n",
            "/**\n * @param {Array<number>} numbers\n * @returns {Array<number>}\n */\nexport const rescaleToUnit = (numbers) => {\n    const minNum = Math.min(...numbers);\n    const maxNum = Math.max(...numbers);\n    if (minNum === maxNum) {\n        return new Array(numbers.length).fill(0.0);\n    } else {\n        return numbers.map(num => (num - minNum) / (maxNum - minNum));\n    }\n}\n",
            "/**\n * @param {Array<*>} values\n * @returns {Array<number>}\n */\nexport const filterIntegers = (values) => {\n    return values.filter(x => typeof x === 'number' && Number.isInteger(x));\n}\n",
            "/**\n * @param {string} s\n * @returns {number}\n */\nexport const strLength = (s) => {\n    return s.length;\n}\n",
            "/**\n * @param {number} n\n * @returns {number}\n */\nexport const largestDivisor = (n) => {\n    for (let i = 2; i < n; i++) {\n        if (n % i === 0) {\n            return Math.floor(n / i);\n        }\n    }\n    return 1;\n};\n",
            "/**\n * @param {number} n\n * @returns {Array<number>}\n */\nexport const factorize = (n) => {\n    const factors = [];\n    let divisor = 2;\n    while (divisor <= n) {\n        if (n % divisor === 0) {\n            factors.push(divisor);\n            n /= divisor;\n        } else {\n            divisor += 1;\n        }\n    }\n    return factors;\n}\n",
            "/**\n * @param {Array<number>} numbers\n * @returns {Array<number>}\n */\nexport const removeDuplicates = (numbers) => {\n    const counts = {};\n    for (const num of numbers) {\n        counts[num] = (counts[num] || 0) + 1;\n    }\n    const res = [];\n    for (const num of numbers) {\n        if (counts[num] === 1) {\n            res.push(num);\n        }\n    }\n    return res;\n}\n",
            "/**\n * @param {string} s\n * @returns {string}\n */\nexport const flipCase = (s) => {\n    let flipped = [];\n    for (let ch of s) {\n        if (!/[a-zA-Z]/.test(ch)) {\n            flipped.push(ch);\n        } else if (ch === ch.toLowerCase()) {\n            flipped.push(ch.toUpperCase());\n        } else {\n            flipped.push(ch.toLowerCase());\n        }\n    }\n    return flipped.join('');\n}\n",
            "/**\n * @param {Array<string>} strs\n * @returns {string}\n */\nexport const concatenate = (strs) => {\n    return strs.join(\"\");\n}\n",
            "/**\n * @param {Array<string>} strs\n * @param {string} prefixStr\n * @returns {Array<string>}\n */\nexport const filterByPrefix = (strs, prefixStr) => {\n    return strs.filter(s => s.startsWith(prefixStr));\n}\n",
            "/**\n * @param {Array<number>} l\n * @returns {Array<number>}\n */\nexport const getPositive = (l) => {\n    return l.filter(num => num > 0);\n}\n",
            "export const isPrime = (n) => {\n    if (n < 2) {\n        return false;\n    }\n    for (let i = 2; i <= Math.floor(Math.sqrt(n)); i++) {\n        if (n % i === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n",
            "/**\n * @param {Array<number>} xs\n * @param {number} x\n * @returns {number}\n */\nexport const poly = (xs, x) => {\n    let res = 0.0;\n    for (let i = 0; i < xs.length; i++) {\n        res += xs[i] * Math.pow(x, i);\n    }\n    return res;\n}\n\n/**\n * @param {Array<number>} xs\n * @returns {number}\n */\nexport const findZero = (xs) => {\n    let x1 = 1.0, x2 = -1.0;\n    while (poly(xs, x1) * poly(xs, x2) > 0) {\n        x1 *= 2;\n        x2 *= 2;\n    }\n    while (Math.abs(x1 - x2) > 1e-10) {\n        let mid = (x1 + x2) / 2;\n        if (poly(xs, mid) === 0) {\n            return mid;\n        } else if (poly(xs, mid) * poly(xs, x1) < 0) {\n            x2 = mid;\n        } else {\n            x1 = mid;\n        }\n    }\n    return (x1 + x2) / 2;\n}\n",
            "/**\n * @param {Array<number>} l\n * @returns {Array<number>}\n */\nexport const sortThird = (l) => {\n    const sortedThird = l.filter((_, index) => index % 3 === 0).sort((a, b) => a - b);\n    return l.map((value, index) => index % 3 === 0 ? sortedThird[index / 3] : value);\n}\n",
            "/**\n * @param {Array<number>} l\n * @returns {Array<number>}\n */\nexport const listUnique = (l) => {\n    return Array.from(new Set(l)).sort((a, b) => a - b);\n}\n",
            "/**\n * @param {Array<number>} l\n * @returns {number}\n */\nexport const maxElement = (l) => {\n    if (!l || l.length === 0) {\n        return 0;\n    }\n    return Math.max(...l);\n}\n",
            "export const fizzBuzz = (n) => {\n    let cnt = 0;\n    for (let i = 0; i < n; i++) {\n        if (i % 11 === 0 || i % 13 === 0) {\n            cnt += (i.toString().split('7').length - 1);\n        }\n    }\n    return cnt;\n}\n",
            "/**\n * @param {Array<number>} l\n * @returns {Array<number>}\n */\nexport const sortEven = (l) => {\n    const sortedEven = [...l].filter((_, index) => index % 2 === 0).sort((a, b) => a - b);\n    return l.map((value, index) => index % 2 === 0 ? sortedEven.shift() : value);\n}\n",
            "/**\n * @param {string} s\n * @returns {string}\n */\nexport const encodeCyclic = (s) => {\n    let result = [];\n    for (let i = 0; i < s.length; i += 3) {\n        if (i + 3 > s.length) {\n            result.push(s.slice(i));\n        } else {\n            result.push(s.slice(i + 1, i + 3));\n            result.push(s[i]);\n        }\n    }\n    return result.join('');\n}\n\n/**\n * @param {string} s\n * @returns {string}\n */\nexport const decodeCyclic = (s) => {\n    return encodeCyclic(encodeCyclic(s));\n}\n",
            "/**\n * @param {number} n\n * @returns {number}\n */\nexport const primeFib = (n) => {\n    const isPrime = (num) => {\n        if (num < 2) return false;\n        for (let i = 2; i <= Math.floor(Math.sqrt(num)); i++) {\n            if (num % i === 0) return false;\n        }\n        return true;\n    };\n\n    let f = [0, 1];\n    let cnt = 0;\n    while (cnt < n) {\n        f = [f[1], f[0] + f[1]];\n        if (isPrime(f[1])) {\n            cnt += 1;\n        }\n    }\n    return f[1];\n}\n",
            "/**\n * @param {Array<number>} l\n * @returns {boolean}\n */\nexport const triplesSumToZero = (l) => {\n    for (let i = 0; i < l.length; i++) {\n        for (let j = i + 1; j < l.length; j++) {\n            for (let k = j + 1; k < l.length; k++) {\n                if (l[i] + l[j] + l[k] === 0) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n",
            "/**\n * @param {number} n\n * @returns {number}\n */\nexport const carRaceCollision = (n) => {\n    return n ** 2;\n};\n",
            "/**\n * @param {Array<number>} l\n * @returns {Array<number>}\n */\nexport const incrList = (l) => {\n    return l.map(i => i + 1);\n}\n",
            "/**\n * @param {Array<number>} l\n * @returns {boolean}\n */\nexport const pairsSumToZero = (l) => {\n    const seen = new Set();\n    for (const num of l) {\n        if (seen.has(-num)) {\n            return true;\n        }\n        seen.add(num);\n    }\n    return false;\n}\n",
            "/**\n * @param {number} x\n * @param {number} bas\n * @returns {string}\n */\nexport const changeBase = (x, bas) => {\n    if (x === 0) {\n        return \"0\";\n    }\n    let digits = [];\n    while (x > 0) {\n        digits.push((x % bas).toString());\n        x = Math.floor(x / bas);\n    }\n    return digits.reverse().join('');\n}\n",
            "/**\n * @param {number} a\n * @param {number} h\n * @returns {number}\n */\nexport const triangleArea = (a, h) => {\n    return a * h / 2;\n};\n",
            "/**\n * @param {number} n\n * @returns {number}\n */\nexport const fib4 = (n) => {\n    let fib = [0, 0, 2, 0];\n    for (let i = 4; i <= n; i++) {\n        fib[i % 4] = fib.reduce((acc, val) => acc + val, 0);\n    }\n    return fib[n % 4];\n}\n",
            "/**\n * @param {Array<number>} l\n * @returns {number}\n */\nexport const median = (l) => {\n    const sl = l.slice().sort((a, b) => a - b);\n    if (sl.length % 2 !== 0) {\n        return sl[Math.floor(sl.length / 2)];\n    } else {\n        return (sl[sl.length / 2] + sl[sl.length / 2 - 1]) / 2;\n    }\n}\n",
            "/**\n * @param {string} txt\n * @returns {boolean}\n */\nexport const isPalindrome = (txt) => {\n    return txt === txt.split('').reverse().join('');\n}\n",
            "/**\n * @param {number} n\n * @param {number} p\n * @returns {number}\n */\nexport const modp = (n, p) => {\n    let ret = 1;\n    for (let i = 0; i < n; i++) {\n        ret = (ret * 2) % p;\n    }\n    return ret;\n}\n",
            "/**\n * @param {string} s\n * @returns {string}\n */\nexport const encodeShift = (s) => {\n    let result = '';\n    for (let ch of s) {\n        result += String.fromCharCode(((ch.charCodeAt(0) - 97 + 5) % 26) + 97);\n    }\n    return result;\n}\n\n/**\n * @param {string} s\n * @returns {string}\n */\nexport const decodeShift = (s) => {\n    let result = '';\n    for (let ch of s) {\n        result += String.fromCharCode(((ch.charCodeAt(0) - 97 + 21) % 26) + 97);\n    }\n    return result;\n}\n",
            "/**\n * @param {string} txt\n * @returns {string}\n */\nexport const removeVowels = (txt) => {\n    const vowels = \"aeiouAEIOU\";\n    return Array.from(txt).filter(char => !vowels.includes(char)).join('');\n}\n",
            "/**\n * @param {Array<number>} l\n * @param {number} t\n * @returns {boolean}\n */\nexport const belowThreshold = (l, t) => {\n    return l.every(x => x < t);\n}\n",
            "/**\n * @param {number} x\n * @param {number} y\n * @returns {number}\n */\nexport const add = (x, y) => {\n    return x + y;\n}\n",
            "/**\n * @param {string} s0\n * @param {string} s1\n * @returns {boolean}\n */\nexport const sameChars = (s0, s1) => {\n    return new Set(s0) == new Set(s1);\n}\n",
            "/**\n * @param {number} n\n * @returns {number}\n */\nexport const fib = (n) => {\n    if (n <= 1) {\n        return n;\n    } else {\n        return fib(n - 1) + fib(n - 2);\n    }\n}\n",
            "/**\n * @param {string} brackets\n * @returns {boolean}\n */\nexport const correctBracketing = (brackets) => {\n    let depth = 0;\n    for (let b of brackets) {\n        if (b === \"<\") {\n            depth += 1;\n        } else if (b === \">\") {\n            depth -= 1;\n        }\n        if (depth < 0) {\n            return false;\n        }\n    }\n    return depth === 0;\n}\n",
            "/**\n * @param {Array<number>} l\n * @returns {boolean}\n */\nexport const monotonic = (l) => {\n    let diff = [];\n    for (let i = 0; i < l.length - 1; i++) {\n        diff.push(l[i + 1] - l[i]);\n    }\n    return diff.every(x => x <= 0) || diff.every(x => x >= 0);\n}\n",
            "/**\n * @param {Array<number>} l1\n * @param {Array<number>} l2\n * @returns {Array<number>}\n */\nexport const common = (l1, l2) => {\n    return [...new Set(l1)].filter(item => new Set(l2).has(item)).sort((a, b) => a - b);\n}\n",
            "/**\n * @param {number} n\n * @returns {number}\n */\nexport const largestPrimeFactor = (n) => {\n    let i = 2;\n    while (i * i <= n) {\n        if (n % i) {\n            i += 1;\n        } else {\n            n //= i;\n        }\n    }\n    return n;\n}\n",
            "/**\n * @param {number} n\n * @returns {number}\n */\nexport const sumToN = (n) => {\n    return ((n + 1) * n) / 2;\n}\n",
            "/**\n * @param {string} brackets\n * @returns {boolean}\n */\nexport const correctBracketing = (brackets) => {\n    let depth = 0;\n    for (let b of brackets) {\n        if (b === \"(\") {\n            depth += 1;\n        } else if (b === \")\") {\n            depth -= 1;\n        }\n        if (depth < 0) {\n            return false;\n        }\n    }\n    return depth === 0;\n}\n",
            "/**\n * @param {Array<number>} xs\n * @returns {Array<number>}\n */\nexport const derivative = (xs) => {\n    return xs.map((x, i) => x * i).slice(1);\n}\n",
            "/**\n * @param {number} n\n * @returns {number}\n */\nexport const fibfib = (n) => {\n    if (n <= 1) return 0;\n    let a = 0, b = 0, c = 1;\n    while (n > 2) {\n        [a, b, c] = [b, c, a + b + c];\n        n -= 1;\n    }\n    return c;\n}\n",
            "/**\n * @param {string} s\n * @returns {number}\n */\nexport const vowelsCount = (s) => {\n    const vowels = \"aeiou\";\n    let cnt = 0;\n    for (let i = 0; i < s.length; i++) {\n        if (vowels.includes(s[i].toLowerCase()) || (i === s.length - 1 && s[i].toLowerCase() === \"y\")) {\n            cnt += 1;\n        }\n    }\n    return cnt;\n};\n",
            "/**\n * @param {number} x\n * @param {number} shift\n * @returns {string}\n */\nexport const circularShift = (x, shift) => {\n    const x_str = x.toString();\n    if (shift > x_str.length) {\n        return x_str.split('').reverse().join('');\n    } else {\n        return x_str.slice(-shift) + x_str.slice(0, -shift);\n    }\n}\n",
            "```js\n/**\n * @param {string} s\n * @returns {number}\n */\nexport const digitSum = (s) => {\n    return Array.from(s).reduce((acc, c) => {\n        return acc + (c >= 'A' && c <= 'Z' ? c.charCodeAt(0) : 0);\n    }, 0);\n};\n```",
            "/**\n * @param {string} s\n * @param {number} n\n * @returns {number}\n */\nexport const fruitDistribution = (s, n) => {\n    const words = s.split(' ');\n    const apples = parseInt(words[words.indexOf(\"apples\") - 1]);\n    const oranges = parseInt(words[words.indexOf(\"oranges\") - 1]);\n    return n - apples - oranges;\n}\n",
            "/**\n * @param {Array<number>} arr\n * @returns {Array<number>}\n */\nexport const pluck = (arr) => {\n    const evens = arr.filter(n => n % 2 === 0);\n    if (evens.length === 0) {\n        return [];\n    }\n    const minEven = Math.min(...evens);\n    return [minEven, arr.indexOf(minEven)];\n}\n",
            "/**\n * @param {Array<number>} lst\n * @returns {number}\n */\nexport const search = (lst) => {\n    const freqs = {};\n    for (let n of lst) {\n        freqs[n] = (freqs[n] || 0) + 1;\n    }\n    const goodVals = Object.keys(freqs).filter(k => freqs[k] >= parseInt(k, 10));\n    return goodVals.length > 0 ? Math.max(...goodVals.map(Number)) : -1;\n}\n",
            "/**\n * @param {Array<number>} lst\n * @returns {Array<number>}\n */\nexport const strangeSortList = (lst) => {\n    const sl = lst.slice().sort((a, b) => a - b);\n    const result = [];\n    let left = 0;\n    let right = sl.length - 1;\n    while (left <= right) {\n        result.push(sl[left]);\n        left += 1;\n        if (left <= right) {\n            result.push(sl[right]);\n            right -= 1;\n        }\n    }\n    return result;\n}\n",
            "/**\n * @param {number} a\n * @param {number} b\n * @param {number} c\n * @returns {number}\n */\nexport const triangleArea = (a, b, c) => {\n    if (a + b > c && a + c > b && b + c > a) {\n        const s = (a + b + c) / 2.0;\n        return Math.sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        return -1.0;\n    }\n}\n",
            "export const willItFly = (q, w) => {\n    if (q.length === 0) {\n        return false;\n    }\n    const isPalin = q.every((value, index) => value === q[q.length - index - 1]);\n    const total = q.reduce((acc, curr) => acc + curr, 0);\n    return isPalin && total <= w;\n}\n",
            "/**\n * @param {Array<number>} arr\n * @returns {number}\n */\nexport const smallestChange = (arr) => {\n    let ans = 0;\n    for (let i = 0; i < Math.floor(arr.length / 2); i++) {\n        if (arr[i] !== arr[arr.length - i - 1]) {\n            ans += 1;\n        }\n    }\n    return ans;\n}\n",
            "/**\n * @param {Array<string>} lst1\n * @param {Array<string>} lst2\n * @returns {Array<string>}\n */\nexport const totalMatch = (lst1, lst2) => {\n    const cnt1 = lst1.reduce((acc, s) => acc + s.length, 0);\n    const cnt2 = lst2.reduce((acc, s) => acc + s.length, 0);\n    return cnt1 <= cnt2 ? lst1 : lst2;\n}\n",
            "/**\n * @param {number} a\n * @returns {boolean}\n */\nexport const isMultiplyPrime = (a) => {\n    const isPrime = (n) => {\n        if (n < 2) return false;\n        for (let i = 2; i <= Math.floor(Math.sqrt(n)); i++) {\n            if (n % i === 0) return false;\n        }\n        return true;\n    };\n\n    let cnt = 0;\n    for (let i = 2; i <= a; i++) {\n        if (isPrime(i)) {\n            while (a % i === 0) {\n                cnt += 1;\n                a /= i;\n            }\n        }\n    }\n    return cnt === 3;\n}\n",
            "/**\n * @param {number} x\n * @param {number} n\n * @returns {boolean}\n */\nexport const isSimplePower = (x, n) => {\n    if (n < 2) {\n        return x === n;\n    }\n    let tmp = 1;\n    while (tmp < x) {\n        tmp *= n;\n    }\n    return tmp === x;\n}\n",
            "/**\n * @param {number} a\n * @returns {boolean}\n */\nexport const isCube = (a) => {\n    a = Math.abs(a);\n    const root = Math.round(Math.pow(a, 1.0 / 3.0));\n    return root * root * root === a;\n}\n",
            "/**\n * @param {string} num\n * @returns {number}\n */\nexport const hexKey = (num) => {\n    return [...num].filter(x => \"2357BD\".includes(x)).length;\n}\n",
            "```js\n/**\n * @param {number} dec\n * @returns {string}\n */\nexport const decimalToBinary = (dec) => {\n    return `db${(dec >>> 0).toString(2)}db`;\n}\n```",
            "/**\n * @param {string} s\n * @returns {boolean}\n */\nexport const isHappy = (s) => {\n    if (s.length < 3) {\n        return false;\n    }\n    for (let i = 0; i < s.length - 2; i++) {\n        if (s[i] === s[i + 1] || s[i] === s[i + 2] || s[i + 1] === s[i + 2]) {\n            return false;\n        }\n    }\n    return true;\n}\n",
            "```\n/**\n * @param {Array<number>} grades\n * @returns {Array<string>}\n */\nexport const numericalLetterGrade = (grades) => {\n    let result = [];\n    for (let g of grades) {\n        if (g === 4.0) {\n            result.push(\"A+\");\n        } else if (g > 3.7) {\n            result.push(\"A\");\n        } else if (g > 3.3) {\n            result.push(\"A-\");\n        } else if (g > 3.0) {\n            result.push(\"B+\");\n        } else if (g > 2.7) {\n            result.push(\"B\");\n        } else if (g > 2.3) {\n            result.push(\"B-\");\n        } else if (g > 2.0) {\n            result.push(\"C+\");\n        } else if (g > 1.7) {\n            result.push(\"C\");\n        } else if (g > 1.3) {\n            result.push(\"C-\");\n        } else if (g > 1.0) {\n            result.push(\"D+\");\n        } else if (g > 0.7) {\n            result.push(\"D\");\n        } else if (g > 0.0) {\n            result.push(\"D-\");\n        } else {\n            result.push(\"E\");\n        }\n    }\n    return result;\n}\n```",
            "export const primeLength = (s) => {\n    const length = s.length;\n    if (length < 2) {\n        return false;\n    }\n    for (let i = 2; i <= Math.floor(Math.sqrt(length)); i++) {\n        if (length % i === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n",
            "/**\n * @param {number} n\n * @returns {number}\n */\nexport const startsOneEnds = (n) => {\n    if (n === 1) {\n        return 1;\n    }\n    return 2 * 9 * Math.pow(10, n - 2);\n}\n",
            "export const solve = (n) => {\n    const digitsSum = String(n).split('').reduce((sum, digit) => sum + parseInt(digit, 10), 0);\n    return digitsSum.toString(2);\n}\n",
            "export const add = (lst) => {\n    return lst.reduce((acc, x, i) => {\n        if (i % 2 === 1 && x % 2 === 0) {\n            acc += x;\n        }\n        return acc;\n    }, 0);\n}\n",
            "/**\n * @param {string} s\n * @returns {string}\n */\nexport const antiShuffle = (s) => {\n    return s.split(\" \").map(word => {\n        return word.split(\"\").sort().join(\"\");\n    }).join(\" \");\n}\n",
            "/**\n * @param {Array<Array<number>>} lst\n * @param {number} x\n * @returns {Array<Array<number>>}\n */\nexport const getRow = (lst, x) => {\n    const coords = [];\n    for (let i = 0; i < lst.length; i++) {\n        for (let j = 0; j < lst[i].length; j++) {\n            if (lst[i][j] === x) {\n                coords.push([i, j]);\n            }\n        }\n    }\n    return coords.sort((a, b) => a[0] - b[0] || b[1] - a[1]);\n}\n",
            "/**\n * @param {Array<number>} arr\n * @returns {Array<number>}\n */\nexport const sortArray = (arr) => {\n    if (arr.length === 0) {\n        return [];\n    }\n    if ((arr[0] + arr[arr.length - 1]) % 2 === 0) {\n        return arr.sort((a, b) => b - a);\n    } else {\n        return arr.sort((a, b) => a - b);\n    }\n}\n",
            "/**\n * @param {string} s\n * @returns {string}\n */\nexport const encrypt = (s) => {\n    let result = '';\n    for (let ch of s) {\n        let shifted = ch.charCodeAt(0) + 4;\n        if (shifted > 'z'.charCodeAt(0)) {\n            shifted -= 26;\n        }\n        result += String.fromCharCode(shifted);\n    }\n    return result;\n}\n",
            "/**\n * @param {Array<number>} lst\n * @returns {?number}\n */\nexport const nextSmallest = (lst) => {\n    const sl = [...new Set(lst)].sort((a, b) => a - b);\n    if (sl.length < 2) {\n        return null;\n    }\n    return sl[1];\n};\n",
            "/**\n * @param {string} s\n * @returns {number}\n */\nexport const isBored = (s) => {\n    const sentences = s.split(/[\\.\\!\\?]\\s*/);\n    return sentences.filter(sentence => sentence.length >= 2 && sentence.startsWith(\"I \")).length;\n}\n",
            "/**\n * @param {*} x\n * @param {*} y\n * @param {*} z\n * @returns {boolean}\n */\nexport const anyInt = (x, y, z) => {\n    if (typeof x === 'number' && typeof y === 'number' && typeof z === 'number') {\n        if ((x + y === z) || (x + z === y) || (y + z === x)) {\n            return true;\n        }\n    }\n    return false;\n}\n",
            "/**\n * @param {string} message\n * @returns {string}\n */\nexport const encode = (message) => {\n    const vowels = \"aeiouAEIOU\";\n    let result = [];\n    for (let ch of message) {\n        if (ch.match(/[a-zA-Z]/)) {\n            let ch1 = ch === ch.toLowerCase() ? ch.toUpperCase() : ch.toLowerCase();\n            if (vowels.includes(ch1)) {\n                ch1 = String.fromCharCode(ch1.charCodeAt(0) + 2);\n            }\n            result.push(ch1);\n        } else {\n            result.push(ch);\n        }\n    }\n    return result.join(\"\");\n}\n",
            "/**\n * @param {Array<number>} lst\n * @returns {number}\n */\nexport const skjkasdkd = (lst) => {\n    const is_prime = (n) => {\n        if (n < 2) return false;\n        for (let i = 2; i <= Math.sqrt(n); i++) {\n            if (n % i === 0) return false;\n        }\n        return true;\n    };\n\n    const primes = lst.filter(is_prime);\n    if (primes.length === 0) return 0;\n\n    const largest = Math.max(...primes).toString();\n    return largest.split('').reduce((sum, digit) => sum + parseInt(digit), 0);\n}\n",
            "/**\n * @param {Map<string, string>} d\n * @returns {boolean}\n */\nexport const checkDictCase = (d) => {\n    if (d.size === 0) {\n        return false;\n    }\n    let allLower = true;\n    let allUpper = true;\n    for (const key of d.keys()) {\n        if (!key.isLowerCase()) {\n            allLower = false;\n        }\n        if (!key.toUpperCase() === key) {\n            allUpper = false;\n        }\n        if (!allLower && !allUpper) {\n            return false;\n        }\n    }\n    return allLower || allUpper;\n}\n",
            "/**\n * @param {number} n\n * @returns {Array<number>}\n */\nexport const countUpTo = (n) => {\n    const primes = [];\n    for (let num = 2; num < n; num++) {\n        if (primes.every(p => num % p !== 0)) {\n            primes.push(num);\n        }\n    }\n    return primes;\n}\n",
            "/**\n * @param {number} a\n * @param {number} b\n * @returns {number}\n */\nexport const multiply = (a, b) => {\n    return (Math.abs(a) % 10) * (Math.abs(b) % 10);\n}\n",
            "/**\n * @param {string} s\n * @returns {number}\n */\nexport const countUpper = (s) => {\n    const vowels = \"AEIOU\";\n    let count = 0;\n    for (let i = 0; i < s.length; i++) {\n        if (i % 2 === 0 && vowels.includes(s[i])) {\n            count++;\n        }\n    }\n    return count;\n}\n",
            "/**\n * @param {string} value\n * @returns {number}\n */\nexport const closestInteger = (value) => {\n    const num = parseFloat(value);\n    if (num >= 0) {\n        return Math.floor(num + 0.5);\n    } else {\n        return Math.ceil(num - 0.5);\n    }\n};\n",
            "/**\n * @param {number} n\n * @returns {Array<number>}\n */\nexport const makeAPile = (n) => {\n    return Array.from({ length: n }, (_, i) => n + 2 * i);\n}\n",
            "/**\n * @param {string} s\n * @returns {Array<string>}\n */\nexport const wordsString = (s) => {\n    return s.split(/[,\\s]+/).filter(w => w.length > 0);\n}\n",
            "/**\n * @param {number} x\n * @param {number} y\n * @returns {number}\n */\nexport const chooseNum = (x, y) => {\n    if (x > y) {\n        return -1;\n    }\n    if (y % 2 === 0) {\n        return y;\n    }\n    return x !== y ? y - 1 : -1;\n}\n",
            "/**\n * @param {number} n\n * @param {number} m\n * @returns {?string}\n */\nexport const roundedAvg = (n, m) => {\n    if (n > m) {\n        return null;\n    }\n    const r_avg = Math.round((m + n) / 2.0);\n    return r_avg.toString(2);\n};\n",
            "/**\n * @param {Array<number>} x\n * @returns {Array<number>}\n */\nexport const uniqueDigits = (x) => {\n    const allDigitsOdd = (s) => {\n        for (let digit of s) {\n            if (parseInt(digit) % 2 === 0) {\n                return false;\n            }\n        }\n        return true;\n    };\n\n    return x.filter(num => allDigitsOdd(num.toString())).sort((a, b) => a - b);\n}\n",
            "/**\n * @param {Array<number>} arr\n * @returns {Array<string>}\n */\nexport const byLength = (arr) => {\n    const digitNames = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"];\n    const sortedArr = arr.filter(x => x >= 1 && x <= 9).sort((a, b) => b - a);\n    return sortedArr.map(x => digitNames[x - 1]);\n}\n",
            "export const f = (n) => {\n    const nums = Array.from({ length: n }, (_, i) => i + 1);\n    return nums.map(i => (i % 2 !== 0 ? nums.slice(0, i).reduce((x, y) => x + y, 0) : nums.slice(0, i).reduce((x, y) => x * y, 1)));\n}\n",
            "/**\n * @param {number} n\n * @returns {Array<number>}\n */\nexport const evenOddPalindrome = (n) => {\n    const cnt = [0, 0];\n    for (let i = 1; i <= n; i++) {\n        const txt = i.toString();\n        if (txt === txt.split('').reverse().join('')) {\n            cnt[i % 2] += 1;\n        }\n    }\n    return cnt;\n}\n",
            "/**\n * \n * @param {number} n \n * @returns {number}\n */\nconst digitsSum = (n) => {\n    let nStr = n.toString();\n    if (n >= 0) {\n        return nStr.split('').reduce((sum, digit) => sum + parseInt(digit), 0);\n    } else {\n        return parseInt(nStr.slice(0, 2)) * 2 + digitsSum(Math.abs(n));\n    }\n};\n\n/**\n * @param {Array<number>} arr\n * @returns {number}\n */\nexport const countNums = (arr) => {\n    return arr.filter(n => digitsSum(n) > 0).length;\n};\n",
            "/**\n * @param {Array<number>} arr\n * @returns {boolean}\n */\nexport const moveOneBall = (arr) => {\n    if (arr.length === 0) {\n        return true;\n    }\n    const sortedArr = [...arr].sort((a, b) => a - b);\n    for (let i = 0; i < arr.length; i++) {\n        if (\n            JSON.stringify(arr.slice(i)) === JSON.stringify(sortedArr.slice(0, arr.length - i)) &&\n            JSON.stringify(arr.slice(0, i)) === JSON.stringify(sortedArr.slice(arr.length - i))\n        ) {\n            return true;\n        }\n    }\n    return false;\n}\n",
            "/**\n * @param {Array<number>} lst1\n * @param {Array<number>} lst2\n * @returns {string}\n */\nexport const canExchange = (lst1, lst2) => {\n    const odd_cnt = lst1.filter(num => num % 2 !== 0).length;\n    const even_cnt = lst2.filter(num => num % 2 === 0).length;\n    return even_cnt >= odd_cnt ? \"YES\" : \"NO\";\n}\n",
            "export const histogram = (test) => {\n    let freq = new Map();\n    let words = test.split(\" \").filter(w => w.length > 0);\n    for (let w of words) {\n        freq.set(w, (freq.get(w) || 0) + 1);\n    }\n    let result = new Map();\n    if (freq.size > 0) {\n        let max_freq = Math.max(...freq.values());\n        for (let [k, v] of freq.entries()) {\n            if (v === max_freq) {\n                result.set(k, v);\n            }\n        }\n    }\n    return result;\n}\n",
            "/**\n * @param {string} s\n * @param {string} c\n * @returns {Array<string>}\n */\nexport const reverseDelete = (s, c) => {\n    const isPalindrome = (str) => {\n        return str === str.split('').reverse().join('');\n    };\n\n    const s1 = [...s].filter(ch => !c.includes(ch)).join('');\n    return [s1, isPalindrome(s1) ? \"yes\" : \"no\"];\n};\n",
            "export const oddCount = (lst) => {\n    let result = [];\n    for (let num of lst) {\n        let n = Array.from(num).reduce((acc, d) => acc + (d.charCodeAt(0) % 2 === 1 ? 1 : 0), 0);\n        let rs = \"the number of odd elements in the string i of the input.\";\n        result.push(rs.replace(\"i\", String(n)));\n    }\n    return result;\n}\n",
            "/**\n * @param {Array<number>} nums\n * @returns {number}\n */\nexport const minSubArraySum = (nums) => {\n    let min_sum = 0;\n    let cur_sum = 0;\n    for (let n of nums) {\n        cur_sum = Math.min(cur_sum + n, 0);\n        min_sum = Math.min(cur_sum, min_sum);\n    }\n    if (min_sum === 0) {\n        min_sum = Math.min(...nums);\n    }\n    return min_sum;\n}\n",
            "/**\n * @param {Array<Array<number>>} grid\n * @param {number} capacity\n * @returns {number}\n */\nexport const maxFill = (grid, capacity) => {\n    return grid.reduce((total, arr) => {\n        return total + Math.ceil(arr.reduce((sum, num) => sum + num, 0) / capacity);\n    }, 0);\n}\n",
            "/**\n * @param {Array<number>} arr\n * @returns {Array<number>}\n */\nexport const sortArray = (arr) => {\n    return arr.sort((a, b) => {\n        const countOnes = (num) => num.toString(2).split(\"1\").length - 1;\n        const onesA = countOnes(a);\n        const onesB = countOnes(b);\n        \n        if (onesA === onesB) {\n            return a - b;\n        }\n        \n        return onesA - onesB;\n    });\n}\n",
            "/**\n * @param {string} s\n * @param {number} n\n * @returns {Array<string>}\n */\nexport const selectWords = (s, n) => {\n    const consonants = \"bcdfghjklmnpqrstvwxyz\";\n    const words = s.split(\" \").filter(w => w.length > 0);\n    return words.filter(w => \n        Array.from(w).filter(c => consonants.includes(c.toLowerCase())).length === n\n    );\n}\n",
            "/**\n * @param {string} word\n * @returns {string}\n */\nexport const getClosestVowel = (word) => {\n    const vowels = \"aeiouAEIOU\";\n    for (let i = word.length - 2; i > 0; i--) {\n        if (vowels.includes(word[i]) && !vowels.includes(word[i - 1]) && !vowels.includes(word[i + 1])) {\n            return word[i];\n        }\n    }\n    return \"\";\n}\n",
            "/**\n * @param {Array<string>} lst\n * @returns {string}\n */\nexport const matchParens = (lst) => {\n    const check = (s) => {\n        let depth = 0;\n        for (let ch of s) {\n            if (ch === \"(\") {\n                depth += 1;\n            } else {\n                depth -= 1;\n            }\n            if (depth < 0) {\n                return false;\n            }\n        }\n        return depth === 0;\n    };\n\n    const s1 = lst[0] + lst[1];\n    const s2 = lst[1] + lst[0];\n    return check(s1) || check(s2) ? \"Yes\" : \"No\";\n}\n",
            "/**\n * @param {Array<number>} arr\n * @param {number} k\n * @returns {Array<number>}\n */\nexport const maximum = (arr, k) => {\n    if (k === 0) {\n        return [];\n    }\n    return arr.sort((a, b) => a - b).slice(-k);\n}\n",
            "/**\n * @param {Array<number>} lst\n * @returns {number}\n */\nexport const solution = (lst) => {\n    return lst.reduce((acc, x, i) => {\n        if (i % 2 === 0 && x % 2 !== 0) {\n            acc += x;\n        }\n        return acc;\n    }, 0);\n}\n",
            "/**\n * @param {Array<number>} arr\n * @param {number} k\n * @returns {number}\n */\nexport const addElements = (arr, k) => {\n    return arr.slice(0, k).reduce((sum, n) => {\n        return sum + (n.toString().length <= 2 ? n : 0);\n    }, 0);\n}\n",
            "/**\n * @param {number} n\n * @returns {Array<number>}\n */\nexport const getOddCollatz = (n) => {\n    let collatz = [1];\n    while (n !== 1) {\n        if (n % 2 !== 0) {\n            collatz.push(n);\n            n = 3 * n + 1;\n        } else {\n            n = Math.floor(n / 2);\n        }\n    }\n    return collatz.sort((a, b) => a - b);\n}\n",
            "/**\n * @param {string} date\n * @returns {boolean}\n */\nexport const validDate = (date) => {\n    if (date.length !== 10 || date[2] !== \"-\" || date[5] !== \"-\") {\n        return false;\n    }\n    const m = parseInt(date.substring(0, 2), 10);\n    const d = parseInt(date.substring(3, 5), 10);\n    if ([1, 3, 5, 7, 8, 10, 12].includes(m) && d >= 1 && d <= 31) {\n        return true;\n    }\n    if ([4, 6, 9, 11].includes(m) && d >= 1 && d <= 30) {\n        return true;\n    }\n    if (m === 2 && d >= 1 && d <= 29) {\n        return true;\n    }\n    return false;\n}\n",
            "/**\n * @param {string} txt\n * @returns {Array<string>}\n */\nexport const splitWords = (txt) => {\n    if (txt.includes(\" \")) {\n        return txt.split(\" \");\n    } else if (txt.includes(\",\")) {\n        return txt.split(\",\");\n    } else {\n        const count = [...txt].filter(c => c >= 'a' && c <= 'z' && c.charCodeAt(0) % 2 === 0).length;\n        return [count.toString()];\n    }\n}\n",
            "/**\n * @param {Array<number>} lst\n * @returns {boolean}\n */\nexport const isSorted = (lst) => {\n    if (!lst.every((_, i) => i === 0 || lst[i - 1] <= lst[i])) {\n        return false;\n    }\n    const freq = {};\n    for (const num of lst) {\n        freq[num] = (freq[num] || 0) + 1;\n    }\n    return Math.max(...Object.values(freq)) <= 2;\n}\n",
            "/**\n * @param {Array<number>} interval1\n * @param {Array<number>} interval2\n * @returns {string}\n */\nexport const intersection = (interval1, interval2) => {\n    const isPrime = (n) => {\n        if (n < 2) return false;\n        for (let i = 2; i <= Math.floor(Math.sqrt(n)); i++) {\n            if (n % i === 0) return false;\n        }\n        return true;\n    };\n\n    let l = Math.max(interval1[0], interval2[0]);\n    let r = Math.min(interval1[1], interval2[1]);\n    let length = r - l;\n    return length > 0 && isPrime(length) ? \"YES\" : \"NO\";\n}\n",
            "/**\n * @param {Array<number>} arr\n * @returns {?number}\n */\nexport const prodSigns = (arr) => {\n    if (!arr.length) {\n        return null;\n    }\n    if (arr.includes(0)) {\n        return 0;\n    }\n    let sign = arr.filter(n => n < 0).length % 2 === 1 ? -1 : 1;\n    return sign * arr.map(Math.abs).reduce((acc, curr) => acc + curr, 0);\n}\n",
            "/**\n * @param {Array<Array<number>>} grid\n * @param {number} k\n * @returns {Array<number>}\n */\nexport const minPath = (grid, k) => {\n    const n = grid.length;\n    let min_val = n * n + 1;\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < n; j++) {\n            if (grid[i][j] === 1) {\n                const temp = [];\n                if (i !== 0) {\n                    temp.push(grid[i - 1][j]);\n                }\n                if (j !== 0) {\n                    temp.push(grid[i][j - 1]);\n                }\n                if (i !== n - 1) {\n                    temp.push(grid[i + 1][j]);\n                }\n                if (j !== n - 1) {\n                    temp.push(grid[i][j + 1]);\n                }\n                min_val = Math.min(min_val, ...temp);\n            }\n        }\n    }\n    const result = [];\n    for (let i = 0; i < k; i++) {\n        result.push(i % 2 === 0 ? 1 : min_val);\n    }\n    return result;\n}\n",
            "/**\n * @param {number} n\n * @returns {Array<number>}\n */\nexport const tri = (n) => {\n    if (n === 0) return [1];\n    let seq = [1, 3];\n    for (let i = 2; i <= n; i++) {\n        if (i % 2 === 0) {\n            seq.push(i / 2 + 1);\n        } else {\n            seq.push(seq[i - 1] + seq[i - 2] + (i + 3) / 2);\n        }\n    }\n    return seq;\n}\n",
            "/**\n * @param {number} n\n * @returns {number}\n */\nexport const digits = (n) => {\n    const odds = Array.from(String(n), Number).filter(d => d % 2 === 1);\n    return odds.length > 0 ? odds.reduce((x, y) => x * y, 1) : 0;\n}\n",
            "/**\n * @param {string} s\n * @returns {boolean}\n */\nexport const isNested = (s) => {\n    let openIdx = [];\n    let closeIdx = [];\n    \n    for (let i = 0; i < s.length; i++) {\n        let ch = s[i];\n        if (ch === '[') {\n            openIdx.push(i);\n        } else if (ch === ']') {\n            closeIdx.push(i);\n        }\n    }\n    \n    closeIdx.reverse();\n    let cnt = 0;\n    let i = 0;\n    let l = closeIdx.length;\n    \n    for (let idx of openIdx) {\n        if (i < l && idx < closeIdx[i]) {\n            cnt += 1;\n            i += 1;\n        }\n    }\n    \n    return cnt >= 2;\n}\n",
            "/**\n * @param {Array<number>} lst\n * @returns {number}\n */\nexport const sumSquares = (lst) => {\n    return lst.reduce((acc, n) => acc + Math.pow(Math.ceil(n), 2), 0);\n}\n",
            "/**\n * @param {string} txt\n * @returns {boolean}\n */\nexport const checkIfLastCharIsALetter = (txt) => {\n    if (!txt) {\n        return false;\n    }\n    const last = txt.slice(txt.lastIndexOf(' ') + 1);\n    return last.length === 1 && /[a-zA-Z]/.test(last[0]);\n}\n",
            "/**\n * @param {Array<number>} arr\n * @returns {number}\n */\nexport const canArrange = (arr) => {\n    if (arr.length <= 1) {\n        return -1;\n    }\n    const idx = [];\n    for (let i = 1; i < arr.length; i++) {\n        if (arr[i] < arr[i - 1]) {\n            idx.push(i);\n        }\n    }\n    return idx.length > 0 ? Math.max(...idx) : -1;\n}\n",
            "/**\n * @param {Array<number>} lst\n * @returns {Array<?number>}\n */\nexport const largestSmallestIntegers = (lst) => {\n    const neg = lst.filter(i => i < 0);\n    const pos = lst.filter(i => i > 0);\n    const maxNeg = neg.length > 0 ? Math.max(...neg) : null;\n    const minPos = pos.length > 0 ? Math.min(...pos) : null;\n    return [maxNeg, minPos];\n}\n",
            "/**\n * @param {*} a\n * @param {*} b\n * @returns {?number}\n */\nexport const compareOne = (a, b) => {\n    const anyToReal = (o) => {\n        if (typeof o === 'string') {\n            return parseFloat(o.replace(',', '.'));\n        } else if (typeof o === 'number') {\n            return o;\n        }\n        throw new Error(\"Type Error\");\n    };\n\n    let a1 = anyToReal(a);\n    let b1 = anyToReal(b);\n\n    if (a1 === b1) {\n        return null;\n    } else if (a1 > b1) {\n        return a1;\n    } else {\n        return b1;\n    }\n};\n",
            "/**\n * @param {number} n\n * @returns {boolean}\n */\nexport const isEqualToSumEven = (n) => {\n    return n % 2 === 0 && n >= 8;\n}\n",
            "/**\n * @param {number} n\n * @returns {number}\n */\nexport const specialFactorial = (n) => {\n    let fact = 1;\n    let result = 1;\n    for (let i = 1; i <= n; i++) {\n        fact *= i;\n        result *= fact;\n    }\n    return result;\n};\n",
            "/**\n * @param {string} txt\n * @returns {string}\n */\nexport const fixSpaces = (txt) => {\n    return txt.replace(/\\s{3,}/g, \"-\").replace(/ /g, \"_\");\n}\n",
            "/**\n * @param {string} fileName\n * @returns {string}\n */\nexport const fileNameCheck = (fileName) => {\n    const suf = [\"txt\", \"exe\", \"dll\"];\n    const lst = fileName.split(\".\");\n    if (lst.length !== 2 || !suf.includes(lst[1]) || lst[0].length === 0 || !/^[a-zA-Z]/.test(lst[0]) || (lst[0].match(/\\d/g) || []).length > 3) {\n        return \"No\";\n    }\n    return \"Yes\";\n}\n",
            "/**\n * @param {Array<number>} lst\n * @returns {number}\n */\nexport const sumSquares = (lst) => {\n    let result = 0;\n    for (let i = 0; i < lst.length; i++) {\n        if (i % 3 === 0) {\n            result += Math.pow(lst[i], 2);\n        } else if (i % 4 === 0) {\n            result += Math.pow(lst[i], 3);\n        } else {\n            result += lst[i];\n        }\n    }\n    return result;\n}\n",
            "import { floor, sqrt } from 'mathjs';\n\n/**\n * @param {number} n\n * @returns {boolean}\n */\nconst is_prime = (n) => {\n    if (n < 2) {\n        return false;\n    }\n    for (let i = 2; i <= floor(sqrt(n)); i++) {\n        if (n % i === 0) {\n            return false;\n        }\n    }\n    return true;\n};\n\n/**\n * @param {string} sentence\n * @returns {string}\n */\nexport const wordsInSentence = (sentence) => {\n    const words = sentence.split(\" \");\n    return words.filter((w) => is_prime(w.length)).join(\" \");\n};\n",
            "/**\n * @param {string} x\n * @param {string} n\n * @returns {boolean}\n */\nexport const simplify = (x, n) => {\n    const xs = x.split(\"/\");\n    const ns = n.split(\"/\");\n    const num = parseInt(xs[0]) * parseInt(ns[0]);\n    const den = parseInt(xs[1]) * parseInt(ns[1]);\n    return num % den === 0;\n}\n",
            "/**\n * @param {number} n\n * @returns {number}\n */\nconst digitsSum = (n) => {\n    const nStr = Math.abs(n).toString();\n    return [...nStr].reduce((sum, d) => sum + parseInt(d, 10), 0);\n};\n\n/**\n * @param {Array<number>} nums\n * @returns {Array<number>}\n */\nexport const orderByPoints = (nums) => {\n    return nums.slice().sort((a, b) => digitsSum(a) - digitsSum(b));\n};\n",
            "/**\n * @param {Array<number>} nums\n * @returns {number}\n */\nexport const specialFilter = (nums) => {\n    const odds = \"13579\";\n    return nums.filter(n => n > 10 && n % 2 === 1 && odds.includes(n.toString()[0])).length;\n}\n",
            "/**\n * @param {number} n\n * @returns {number}\n */\nexport const getMaxTriples = (n) => {\n    let c = [0, 0, 0];\n    for (let i = 1; i <= n; i++) {\n        let a = i * i - i + 1;\n        c[a % 3] += 1;\n    }\n    return c[0] * c[1] * c[2] + (c[0] * (c[0] - 1) * (c[0] - 2) + c[1] * (c[1] - 1) * (c[1] - 2) + c[2] * (c[2] - 1) * (c[2] - 2)) // 6;\n}\n",
            "/**\n * @param {string} planet1\n * @param {string} planet2\n * @returns {Array<string>}\n */\nexport const bf = (planet1, planet2) => {\n    const names = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"];\n    if (!names.includes(planet1) || !names.includes(planet2)) {\n        return [];\n    }\n    let l = names.indexOf(planet1);\n    let r = names.indexOf(planet2);\n    if (l > r) {\n        [l, r] = [r, l];\n    }\n    if (l === r) {\n        return [];\n    }\n    return names.slice(l + 1, r);\n}\n",
            "/**\n * @param {Array<string>} lst\n * @returns {Array<string>}\n */\nexport const sortedListSum = (lst) => {\n    return lst.filter(s => s.length % 2 === 0)\n              .sort((a, b) => {\n                  if (a.length === b.length) {\n                      return a.localeCompare(b);\n                  }\n                  return a.length - b.length;\n              });\n}\n",
            "/**\n * @param {number} n\n * @param {number} x\n * @param {number} y\n * @returns {number}\n */\nexport const xOrY = (n, x, y) => {\n    if (n < 2) {\n        return y;\n    }\n    for (let i = 2; i <= Math.floor(Math.sqrt(n)); i++) {\n        if (n % i === 0) {\n            return y;\n        }\n    }\n    return x;\n}\n",
            "/**\n * @param {Array<number>} lst\n * @returns {number}\n */\nexport const doubleTheDifference = (lst) => {\n    return lst.filter(n => n >= 0 && n % 2 === 1).map(n => n * n).reduce((acc, curr) => acc + curr, 0);\n}\n",
            "/**\n * @param {Array<number>} game\n * @param {Array<number>} guess\n * @returns {Array<number>}\n */\nexport const compare = (game, guess) => {\n    return game.map((x, i) => Math.abs(x - guess[i]));\n}\n",
            "/**\n * @param {string} className\n * @param {Array<string>} extensions\n * @returns {string}\n */\nexport const strongestExtension = (className, extensions) => {\n    let max_s = -Infinity;\n    let max_ext = \"\";\n    for (let ext of extensions) {\n        let upper = [...ext].filter(c => c >= 'A' && c <= 'Z').length;\n        let lower = [...ext].filter(c => c >= 'a' && c <= 'z').length;\n        let s = upper - lower;\n        if (s > max_s) {\n            max_s = s;\n            max_ext = ext;\n        }\n    }\n    return `${className}.${max_ext}`;\n}\n",
            "/**\n * @param {string} a\n * @param {string} b\n * @returns {boolean}\n */\nexport const cycpatternCheck = (a, b) => {\n    if (a.length < b.length) {\n        return false;\n    }\n    for (let i = 0; i < b.length; i++) {\n        if ((b.substring(i) + b.substring(0, i)).includes(a)) {\n            return true;\n        }\n    }\n    return false;\n}\n",
            "/**\n * @param {number} num\n * @returns {Array<number>}\n */\nexport const evenOddCount = (num) => {\n    const ds = Math.abs(num).toString();\n    let even = 0;\n    for (let d of ds) {\n        if (parseInt(d) % 2 === 0) {\n            even++;\n        }\n    }\n    return [even, ds.length - even];\n}\n",
            "/**\n * @param {number} num\n * @returns {string}\n */\nexport const intToMiniRoman = (num) => {\n    const values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    const numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    const res = [];\n    for (let i = 0; i < values.length; i++) {\n        while (num >= values[i]) {\n            res.push(numerals[i]);\n            num -= values[i];\n        }\n    }\n    return res.join('');\n}\n",
            "/**\n * @param {number} a\n * @param {number} b\n * @param {number} c\n * @returns {boolean}\n */\nexport const rightAngleTriangle = (a, b, c) => {\n    const s = [a, b, c].sort((x, y) => x - y);\n    return s[0] * s[0] + s[1] * s[1] === s[2] * s[2];\n}\n",
            "/**\n * @param {Array<string>} words\n * @returns {string}\n */\nexport const findMax = (words) => {\n    let max_cnt = 0;\n    let max_w = \"\";\n    for (let w of words) {\n        let cnt = new Set(w).size;\n        if (cnt > max_cnt) {\n            max_cnt = cnt;\n            max_w = w;\n        } else if (cnt === max_cnt) {\n            max_w = min(max_w, w);\n        }\n    }\n    return max_w;\n}\n",
            "/**\n * @param {number} num\n * @param {number} need\n * @param {number} remaining\n * @returns {Array<number>}\n */\nexport const eat = (num, need, remaining) => {\n    if (need <= remaining) {\n        return [num + need, remaining - need];\n    } else {\n        return [num + remaining, 0];\n    }\n}\n",
            "/**\n * @param {Array<string>} operators\n * @param {Array<number>} operands\n * @returns {number}\n */\nexport const doAlgebra = (operators, operands) => {\n    let ops = [...operators];\n    let nums = [...operands];\n    let i = len(ops) - 1;\n    while (i >= 0) {\n        if (ops[i] === \"**\") {\n            nums[i] = Math.pow(nums[i], nums[i + 1]);\n            nums.splice(i + 1, 1);\n            ops.splice(i, 1);\n        }\n        i -= 1;\n    }\n    i = 0;\n    while (i < len(ops)) {\n        if (ops[i] === \"*\") {\n            nums[i] = nums[i] * nums[i + 1];\n            nums.splice(i + 1, 1);\n            ops.splice(i, 1);\n            i -= 1;\n        } else if (ops[i] === \"//\") {\n            nums[i] = Math.floor(nums[i] / nums[i + 1]);\n            nums.splice(i + 1, 1);\n            ops.splice(i, 1);\n            i -= 1;\n        }\n        i += 1;\n    }\n    i = 0;\n    while (i < len(ops)) {\n        if (ops[i] === \"+\") {\n            nums[i] = nums[i] + nums[i + 1];\n            nums.splice(i + 1, 1);\n            ops.splice(i, 1);\n            i -= 1;\n        } else if (ops[i] === \"-\") {\n            nums[i] = nums[i] - nums[i + 1];\n            nums.splice(i + 1, 1);\n            ops.splice(i, 1);\n            i -= 1;\n        }\n        i += 1;\n    }\n    return nums[0];\n}\n",
            "/**\n * @param {string} s\n * @returns {string}\n */\nexport const solve = (s) => {\n    if (!/[a-zA-Z]/.test(s)) {\n        return s.split('').reverse().join('');\n    }\n    let result = [];\n    for (let ch of s) {\n        if (!/[a-zA-Z]/.test(ch)) {\n            result.push(ch);\n        } else if (ch === ch.toUpperCase()) {\n            result.push(ch.toLowerCase());\n        } else if (ch === ch.toLowerCase()) {\n            result.push(ch.toUpperCase());\n        }\n    }\n    return result.join('');\n}\n",
            "/**\n * @param {string} txt\n * @returns {?string}\n */\nexport const stringToMd5 = (txt) => {\n    if (!txt) {\n        return null;\n    }\n    const md5Hash = CryptoJS.MD5(txt).toString();\n    return md5Hash;\n}\n",
            "/**\n * @param {number} a\n * @param {number} b\n * @returns {Array<number>}\n */\nexport const generateIntegers = (a, b) => {\n    const lower = Math.max(2, Math.min(a, b));\n    const upper = Math.min(8, Math.max(a, b));\n    const result = [];\n    for (let i = lower; i <= upper; i++) {\n        if (i % 2 === 0) {\n            result.push(i);\n        }\n    }\n    return result;\n}\n"
        ]
    }
}