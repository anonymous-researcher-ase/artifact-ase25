{
    "python": {
        "ruby": [
            "# @param numbers [Array<Float>]\n# @param threshold [Float]\n# @return [Boolean]\ndef has_close_elements(numbers, threshold)\n    numbers.each_with_index do |num1, i|\n        (i + 1...numbers.length).each do |j|\n            return true if (num1 - numbers[j]).abs < threshold\n        end\n    end\n    false\nend\n",
            "# @param paren_string [String]\n# @returns {Array<String>}\ndef separate_paren_groups(paren_string)\n    groups = []\n    stk = []\n    current_group = \"\"\n    parens = paren_string.gsub(\" \", \"\")\n    parens.each_char do |ch|\n        if ch == \"(\"\n            stk.push(ch)\n            current_group << ch\n        elsif ch == \")\"\n            stk.pop\n            current_group << ch\n            if stk.empty?\n                groups.push(current_group)\n                current_group = \"\"\n            end\n        end\n    end\n    groups\nend\n",
            "# @param num [Float]\n# @returns {Float}\ndef truncate_number(num)\n    num - num.floor\nend\n",
            "def below_zero(operations)\n    balance = 0\n    operations.each do |op|\n        balance += op\n        return true if balance < 0\n    end\n    false\nend\n",
            "def mean_absolute_deviation(numbers)\n    mean = numbers.sum / numbers.size.to_f\n    deviation = numbers.map { |x| (x - mean).abs }.sum\n    return deviation / numbers.size.to_f\nend\n",
            "# @param numbers [Array<Integer>]\n# @param delimiter [Integer]\n# @return [Array<Integer>]\ndef intersperse(numbers, delimiter)\n    result = []\n    numbers.each_with_index do |number, i|\n        if i != 0\n            result << delimiter\n        end\n        result << number\n    end\n    result\nend\n",
            "def parse_nested_parens(paren_string)\n    result = []\n    paren_groups = paren_string.split\n    paren_groups.each do |group|\n        max_depth = 0\n        depth = 0\n        group.each_char do |ch|\n            if ch == \"(\"\n                depth += 1\n                max_depth = [max_depth, depth].max\n            elsif ch == \")\"\n                depth -= 1\n            end\n        end\n        result << max_depth\n    end\n    result\nend\n",
            "def filter_by_substring(strs, substring)\n  strs.select { |s| s.include?(substring) }\nend\n",
            "def sum_product(numbers)\n  n_sum = numbers.sum\n  n_product = numbers.reduce(1) { |x, y| x * y }\n  [n_sum, n_product]\nend\n",
            "# @param numbers [Array<Integer>]\n# @returns {Array<Integer>}\ndef rolling_max(numbers)\n    max_so_far = -Float::INFINITY\n    result = []\n    numbers.each do |num|\n        max_so_far = [max_so_far, num].max\n        result << max_so_far\n    end\n    result\nend\n",
            "# @param s [String]\n# @return [String]\ndef make_palindrome(s)\n    return s if s == s.reverse\n    (0...s.length).each do |i|\n        return s + s[0...i].reverse if s[i..-1] == s[i..-1].reverse\n    end\n    \"\"\nend\n",
            "# @param a [String]\n# @param b [String]\n# @returns {String}\ndef string_xor(a, b)\n    \"\".join([\"0\" if x == y else \"1\" for x, y in zip(a, b)])\nend\n",
            "# @param strs [Array<String>]\n# @returns {String, nil}\ndef longest(strs)\n    return nil if strs.empty?\n    longest_s = strs[0]\n    strs.each do |s|\n        longest_s = s if s.length > longest_s.length\n    end\n    longest_s\nend\n",
            "# @param a [Integer]\n# @param b [Integer]\n# @returns {Integer}\ndef greatest_common_divisor(a, b)\n    if b == 0\n        return a\n    else\n        return greatest_common_divisor(b, a % b)\n    end\nend\n",
            "def all_prefixes(s)\n    prefixes = []\n    (0...s.length).each do |i|\n        prefixes << s[0..i]\n    end\n    prefixes\nend\n",
            "def string_sequence(n)\n    (0..n).map(&:to_s).join(\" \")\nend\n",
            "def count_distinct_characters(s)\n    s.downcase.chars.uniq.size\nend\n",
            "Durations = {\"o\" => 4, \"o|\" => 2, \".|\" => 1}\n\ndef parse_music(music_string)\n    notes = music_string.split\n    notes.map { |note| Durations[note] }\nend\n",
            "# @param s [String]\n# @param substring [String]\n# @returns {Integer}\ndef how_many_times(s, substring)\n    times = 0\n    (0..s.length - substring.length).each do |i|\n        if s[i, substring.length] == substring\n            times += 1\n        end\n    end\n    return times\nend\n",
            "def sort_numbers(numbers)\n  num_dict = {\n    \"zero\" => 0,\n    \"one\" => 1,\n    \"two\" => 2,\n    \"three\" => 3,\n    \"four\" => 4,\n    \"five\" => 5,\n    \"six\" => 6,\n    \"seven\" => 7,\n    \"eight\" => 8,\n    \"nine\" => 9\n  }\n  num_list = numbers.split(\" \").reject { |x| !num_dict.key?(x) }\n  sorted_list = num_list.sort_by { |x| num_dict[x] }\n  sorted_list.join(\" \")\nend\n",
            "# @param numbers [Array<Float>]\n# @returns {Array<Float>}\ndef find_closest_elements(numbers)\n    sorted_numbers = numbers.sort\n    min_diff = Float::INFINITY\n    closest_pair = []\n    \n    (1...sorted_numbers.length).each do |i|\n        diff = sorted_numbers[i] - sorted_numbers[i - 1]\n        if diff < min_diff\n            min_diff = diff\n            closest_pair = [sorted_numbers[i - 1], sorted_numbers[i]]\n        end\n    end\n    \n    closest_pair\nend\n",
            "def rescale_to_unit(numbers)\n    min_num = numbers.min\n    max_num = numbers.max\n    if min_num == max_num\n        Array.new(numbers.length, 0.0)\n    else\n        numbers.map { |num| (num - min_num) / (max_num - min_num) }\n    end\nend\n",
            "# @param values [Array<Object>]\n# @returns {Array<Integer>}\ndef filter_integers(values)\n  values.select { |x| x.is_a?(Integer) }\nend\n",
            "def str_length(s)\n  s.length\nend\n",
            "def largest_divisor(n)\n  (2...n).each do |i|\n    return n / i if n % i == 0\n  end\n  return 1\nend\n",
            "# @param n [Integer]\n# @return {Array<Integer>}\ndef factorize(n)\n    factors = []\n    divisor = 2\n    while divisor <= n\n        if n % divisor == 0\n            factors << divisor\n            n /= divisor\n        else\n            divisor += 1\n        end\n    end\n    factors\nend\n",
            "# @param numbers [Array<Integer>]\n# @return [Array<Integer>]\ndef remove_duplicates(numbers)\n    counts = Hash.new(0)\n    numbers.each do |num|\n        counts[num] += 1\n    end\n    res = numbers.select { |num| counts[num] == 1 }\n    res\nend\n",
            "# @param s [String]\n# @returns {String}\ndef flip_case(s)\n  flipped = []\n  s.each_char do |ch|\n    if !ch =~ /[a-zA-Z]/\n      flipped << ch\n    elsif ch.downcase == ch\n      flipped << ch.upcase\n    else\n      flipped << ch.downcase\n    end\n  end\n  flipped.join\nend\n",
            "# @param strs [Array<String>]\n# @return [String]\ndef concatenate(strs)\n    strs.join(\"\")\nend\n",
            "def filter_by_prefix(strs, prefix_str)\n    strs.select { |s| s.start_with?(prefix_str) }\nend\n",
            "def get_positive(l)\n  l.select { |num| num > 0 }\nend\n",
            "# @param n [Integer]\n# @returns {Boolean}\ndef is_prime(n)\n    return false if n < 2\n    (2..Math.sqrt(n)).each do |i|\n        return false if n % i == 0\n    end\n    true\nend\n",
            "# @param xs [Array<Integer>]\n# @param x [Float]\n# @returns {Float}\ndef poly(xs, x)\n    res = 0.0\n    xs.each_with_index do |coeff, i|\n        res += coeff * x**i\n    end\n    res\nend\n\n# @param xs [Array<Integer>]\n# @returns {Float}\ndef find_zero(xs)\n    x1, x2 = 1.0, -1.0\n    while poly(xs, x1) * poly(xs, x2) > 0\n        x1 *= 2\n        x2 *= 2\n    end\n    while (x1 - x2).abs > 1e-10\n        mid = (x1 + x2) / 2.0\n        if poly(xs, mid) == 0\n            return mid\n        elsif poly(xs, mid) * poly(xs, x1) < 0\n            x2 = mid\n        else\n            x1 = mid\n        end\n    end\n    (x1 + x2) / 2.0\nend\n",
            "def sort_third(l)\n    sorted_third = l.select.with_index { |_, i| i % 3 == 0 }.sort\n    l.map.with_index { |x, i| i % 3 == 0 ? sorted_third[i / 3] : x }\nend\n",
            "def list_unique(l)\n    l.uniq.sort\nend\n",
            "def max_element(l)\n    return 0 if l.empty?\n    l.max\nend\n",
            "def fizz_buzz(n)\n    cnt = 0\n    for i in 0...n\n        if i % 11 == 0 || i % 13 == 0\n            cnt += i.to_s.count(\"7\")\n        end\n    end\n    return cnt\nend\n",
            "def sort_even(l)\n  sorted_even = l.select.with_index { |_, i| i.even? }.sort\n  l.map.with_index { |x, i| i.even? ? sorted_even[i / 2] : x }\nend\n",
            "# @param s [String]\n# @return [String]\ndef encode_cyclic(s)\n    result = []\n    (0...s.length).step(3) do |i|\n        if i + 3 > s.length\n            result << s[i..-1]\n        else\n            result << s[i+1, 2]\n            result << s[i, 1]\n        end\n    end\n    result.join(\"\")\nend\n\n# @param s [String]\n# @return [String]\ndef decode_cyclic(s)\n    encode_cyclic(encode_cyclic(s))\nend\n",
            "def prime_fib(n)\n  f = [0, 1]\n  cnt = 0\n  while cnt < n\n    f = [f[1], f[0] + f[1]]\n    if f[1].prime?\n      cnt += 1\n    end\n  end\n  return f[1]\nend\n",
            "def triples_sum_to_zero(l)\n  (0...l.length).each do |i|\n    ((i + 1)...l.length).each do |j|\n      ((j + 1)...l.length).each do |k|\n        return true if l[i] + l[j] + l[k] == 0\n      end\n    end\n  end\n  false\nend\n",
            "# @param n [Integer]\n# @returns {Integer}\ndef car_race_collision(n)\n  n ** 2\nend\n",
            "def incr_list(l)\n    l.map { |i| i + 1 }\nend\n",
            "def pairs_sum_to_zero(l)\n  seen = Set.new\n  l.each do |num|\n    return true if seen.include?(-num)\n    seen.add(num)\n  end\n  false\nend\n",
            "# @param x [Integer]\n# @param bas [Integer]\n# @return [String]\ndef change_base(x, bas)\n    return \"0\" if x == 0\n    digits = []\n    while x > 0\n        digits << (x % bas).to_s\n        x /= bas\n    end\n    digits.reverse.join\nend\n",
            "# @param a [Integer]\n# @param h [Integer]\n# @returns {Float}\ndef triangle_area(a, h)\n    a.to_f * h / 2\nend\n",
            "# @param n [Integer]\n# @return [Integer]\ndef fib4(n)\n  fib = [0, 0, 2, 0]\n  for i in 4..n\n    fib[i % 4] = fib.sum\n  end\n  fib[n % 4]\nend\n",
            "# @param l [Array<Float>]\n# @returns {Float}\ndef median(l)\n    sl = l.sort\n    if l.length % 2 != 0\n        return sl[l.length / 2]\n    else\n        return (sl[l.length / 2] + sl[l.length / 2 - 1]) / 2.0\n    end\nend\n",
            "# @param txt [String]\n# @returns {Boolean}\ndef is_palindrome(txt)\n    txt == txt.reverse\nend\n",
            "# @param n [Integer]\n# @param p [Integer]\n# @returns {Integer}\ndef modp(n, p)\n    ret = 1\n    n.times do\n        ret = (ret * 2) % p\n    end\n    ret\nend\n",
            "def encode_shift(s)\n    result = s.chars.map { |ch| ((ch.ord - 97 + 5) % 26 + 97).chr }\n    return result.join\nend\n\ndef decode_shift(s)\n    result = s.chars.map { |ch| ((ch.ord - 97 + 21) % 26 + 97).chr }\n    return result.join\nend\n",
            "# @param txt [String]\n# @return [String]\ndef remove_vowels(txt)\n    vowels = \"aeiouAEIOU\"\n    txt.chars.select { |char| !vowels.include?(char) }.join\nend\n",
            "# @param l [Array<Integer>]\n# @param t [Integer]\n# @returns {Boolean}\ndef below_threshold(l, t)\n  l.all? { |x| x < t }\nend\n",
            "# @param x [Integer]\n# @param y [Integer]\n# @return [Integer]\ndef add(x, y)\n    x + y\nend\n",
            "# @param s0 [String]\n# @param s1 [String]\n# @returns {Boolean}\ndef same_chars(s0, s1)\n    s0.chars.to_set == s1.chars.to_set\nend\n",
            "# @param n [Integer]\n# @returns {Integer}\ndef fib(n)\n    if n <= 1\n        return n\n    else\n        return fib(n - 1) + fib(n - 2)\n    end\nend\n",
            "# @param brackets [String]\n# @returns {Boolean}\ndef correct_bracketing(brackets)\n  depth = 0\n  brackets.each_char do |b|\n    if b == \"<\"\n      depth += 1\n    elsif b == \">\"\n      depth -= 1\n    end\n    return false if depth < 0\n  end\n  depth == 0\nend\n",
            "def monotonic(l)\n    diff = l.each_cons(2).map { |x, y| y - x }\n    diff.all? { |x| x <= 0 } || diff.all? { |x| x >= 0 }\nend\n",
            "def common(l1, l2)\n  (l1 & l2).uniq.sort\nend\n",
            "def largest_prime_factor(n)\n    i = 2\n    while i * i <= n\n        if n % i != 0\n            i += 1\n        else\n            n /= i\n        end\n    end\n    n\nend\n",
            "# @param n [Integer]\n# @return [Integer]\ndef sum_to_n(n)\n  (0..n).sum\nend\n",
            "# @param brackets [String]\n# @returns {Boolean}\ndef correct_bracketing(brackets)\n    depth = 0\n    brackets.each_char do |b|\n        if b == \"(\"\n            depth += 1\n        elsif b == \")\"\n            depth -= 1\n        end\n        return false if depth < 0\n    end\n    depth == 0\nend\n",
            "# @param xs [Array<Integer>]\n# @returns {Array<Integer>}\ndef derivative(xs)\n    (1...xs.length).map { |i| xs[i] * i }\nend\n",
            "```\ndef fibfib(n)\n  if n <= 1\n    return 0\n  end\n  a, b, c = 0, 0, 1\n  while n > 2\n    a, b, c = b, c, a + b + c\n    n -= 1\n  end\n  return c\nend\n```",
            "def vowels_count(s)\n    vowels = \"aeiou\"\n    cnt = 0\n    for i in 0...s.length\n        if s[i].downcase.in?(vowels) || (i == s.length - 1 && s[i].downcase == \"y\")\n            cnt += 1\n        end\n    end\n    cnt\nend\n",
            "# @param x [Integer]\n# @param shift [Integer]\n# @returns {String}\ndef circular_shift(x, shift)\n    x_str = x.to_s\n    if shift > x_str.length\n        return x_str.reverse\n    else\n        return x_str[-shift..-1] + x_str[0...-shift]\n    end\nend\n",
            "def digit_sum(s)\n  s.chars.select { |c| c =~ /[A-Z]/ }.map { |c| c.ord }.sum\nend\n",
            "def fruit_distribution(s, n)\n  words = s.split(' ')\n  apples = words[words.index(\"apples\") - 1].to_i\n  oranges = words[words.index(\"oranges\") - 1].to_i\n  n - apples - oranges\nend\n",
            "def pluck(arr)\n  evens = arr.select { |n| n.even? }\n  return [] if evens.empty?\n  \n  min_even = evens.min\n  [min_even, arr.index(min_even)]\nend\n",
            "def search(lst)\n    freqs = Hash.new(0)\n    lst.each do |n|\n        freqs[n] += 1\n    end\n    good_vals = freqs.select { |k, v| v >= k }.keys\n    return good_vals.max || -1\nend\n",
            "# @param lst [Array<Integer>]\n# @returns {Array<Integer>}\ndef strange_sort_list(lst)\n    sl = lst.sort\n    result = []\n    left, right = 0, sl.length - 1\n    while left <= right\n        result << sl[left]\n        left += 1\n        if left <= right\n            result << sl[right]\n            right -= 1\n        end\n    end\n    result\nend\n",
            "def triangle_area(a, b, c)\n    if a + b > c && a + c > b && b + c > a\n        s = (a + b + c) / 2.0\n        Math.sqrt(s * (s - a) * (s - b) * (s - c))\n    else\n        -1.0\n    end\nend\n",
            "# @param q [Array<Integer>]\n# @param w [Integer]\n# @returns {Boolean}\ndef will_it_fly(q, w)\n    return false if q.empty?\n    is_palin = q.all? { |e| e == q[-q.index(e)-1] }\n    total = q.sum\n    is_palin && total <= w\nend\n",
            "def smallest_change(arr)\n    ans = 0\n    (arr.length / 2).times do |i|\n        if arr[i] != arr[arr.length - i - 1]\n            ans += 1\n        end\n    end\n    ans\nend\n",
            "def total_match(lst1, lst2)\n    cnt1 = lst1.sum(&:length)\n    cnt2 = lst2.sum(&:length)\n    cnt1 <= cnt2 ? lst1 : lst2\nend\n",
            "def is_prime(n)\n  return false if n < 2\n  (2..Math.sqrt(n)).each do |i|\n    return false if n % i == 0\n  end\n  true\nend\n\n# @param a [Integer]\n# @returns {Boolean}\ndef is_multiply_prime(a)\n  cnt = 0\n  (2..a).each do |i|\n    if is_prime(i)\n      while a % i == 0\n        cnt += 1\n        a /= i\n      end\n    end\n  end\n  cnt == 3\nend\n",
            "def is_simple_power(x, n)\n  if n < 2\n    return x == n\n  end\n  tmp = 1\n  while tmp < x\n    tmp *= n\n  end\n  tmp == x\nend\n",
            "# @param a [Integer]\n# @returns {Boolean}\ndef is_cube(a)\n    a = a.abs\n    root = (a ** (1.0 / 3.0)).round\n    return root * root * root == a\nend\n",
            "# @param num [String]\n# @returns {Integer}\ndef hex_key(num)\n    num.count(\"2357BD\")\nend\n",
            "def decimal_to_binary(dec)\n  binary = dec.to_s(2)\n  \"db#{binary}db\"\nend\n",
            "# @param s [String]\n# @return [Boolean]\ndef is_happy(s)\n    return false if s.length < 3\n    (0...s.length - 2).each do |i|\n        return false if s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]\n    end\n    true\nend\n",
            "def numerical_letter_grade(grades)\n    result = []\n    grades.each do |g|\n        if g == 4.0\n            result << \"A+\"\n        elsif g > 3.7\n            result << \"A\"\n        elsif g > 3.3\n            result << \"A-\"\n        elsif g > 3.0\n            result << \"B+\"\n        elsif g > 2.7\n            result << \"B\"\n        elsif g > 2.3\n            result << \"B-\"\n        elsif g > 2.0\n            result << \"C+\"\n        elsif g > 1.7\n            result << \"C\"\n        elsif g > 1.3\n            result << \"C-\"\n        elsif g > 1.0\n            result << \"D+\"\n        elsif g > 0.7\n            result << \"D\"\n        elsif g > 0.0\n            result << \"D-\"\n        else\n            result << \"E\"\n        end\n    end\n    result\nend\n",
            "# @param s [String]\n# @returns {Boolean}\ndef prime_length(s)\n    length = s.length\n    return false if length < 2\n    (2..Integer.sqrt(length)).each do |i|\n        return false if length % i == 0\n    end\n    true\nend\n",
            "# @param n [Integer]\n# @returns {Integer}\ndef starts_one_ends(n)\n    if n == 1\n        return 1\n    end\n    return 2 * 9 * (10 ** (n - 2))\nend\n",
            "def solve(n)\n    digits_sum = n.to_s.chars.map(&:to_i).sum\n    digits_sum.to_s(2)\nend\n",
            "def add(lst)\n  lst.select.with_index { |x, i| i.odd? && x.even? }.sum\nend\n",
            "# @param s [String]\n# @returns {String}\ndef anti_shuffle(s)\n    words = s.split(\" \").map do |word|\n        word.chars.sort.join\n    end\n    words.join(\" \")\nend\n",
            "def get_row(lst, x)\n    coords = []\n    lst.each_with_index do |row, i|\n        row.each_with_index do |value, j|\n            coords << [i, j] if value == x\n        end\n    end\n    coords.sort_by { |a, b| [a, -b] }\nend\n",
            "# @param arr [Array<Integer>]\n# @return [Array<Integer>]\ndef sort_array(arr)\n    return [] if arr.empty?\n    return arr.sort.reverse if (arr.first + arr.last) % 2 == 0\n    arr.sort\nend\n",
            "# @param s [String]\n# @returns [String]\ndef encrypt(s)\n    result = []\n    s.each_char do |ch|\n        shifted = ch.ord + 4\n        if shifted > 'z'.ord\n            shifted -= 26\n        end\n        result << shifted.chr\n    end\n    result.join(\"\")\nend\n",
            "def next_smallest(lst)\n    sl = lst.uniq.sort\n    if sl.length < 2\n        return nil\n    end\n    sl[1]\nend\n",
            "# @param s [String]\n# @returns {Integer}\ndef is_bored(s)\n    sentences = s.split(/(?<=[.!?])\\s*/)\n    sentences.count { |sentence| sentence.start_with?(\"I \") && sentence.length >= 2 }\nend\n",
            "# @param x [Object]\n# @param y [Object]\n# @param z [Object]\n# @returns {Boolean}\ndef any_int(x, y, z)\n  if x.is_a?(Integer) && y.is_a?(Integer) && z.is_a?(Integer)\n    return true if (x + y == z) || (x + z == y) || (y + z == x)\n  end\n  false\nend\n",
            "# @param message [String]\n# @returns {String}\ndef encode(message)\n    vowels = \"aeiouAEIOU\"\n    result = []\n    message.each_char do |ch|\n        if ch =~ /[a-zA-Z]/\n            ch1 = ch.downcase == ch ? ch.upcase : ch.downcase\n            if vowels.include?(ch1)\n                ch1 = (ch1.ord + 2).chr\n            end\n            result << ch1\n        else\n            result << ch\n        end\n    end\n    result.join(\"\")\nend\n",
            "def skjkasdkd(lst)\n  primes = lst.select { |n| n >= 2 && (2..Math.sqrt(n)).all? { |i| n % i != 0 } }\n  return 0 if primes.empty?\n  largest = primes.max.to_s\n  largest.sum(&:to_i)\nend\n",
            "# @param d [Hash{String => String}]\n# @returns {Boolean}\ndef check_dict_case(d)\n    return false if d.empty?\n    all_lower = d.keys.all? { |c| c.islower? }\n    all_upper = d.keys.all? { |c| c.isupper? }\n    all_lower || all_upper\nend\n",
            "# @param n [Integer]\n# @returns {Array<Integer>}\ndef count_up_to(n)\n    primes = []\n    (2...n).each do |num|\n        if primes.all? { |p| num % p != 0 }\n            primes << num\n        end\n    end\n    primes\nend\n",
            "def multiply(a, b)\n    (a.abs % 10) * (b.abs % 10)\nend\n",
            "def count_upper(s)\n  vowels = \"AEIOU\"\n  s.chars.each_with_index.count { |c, i| i.even? && vowels.include?(c) }\nend\n",
            "# @param value [String]\n# @returns {Integer}\ndef closest_integer(value)\n    num = Float(value)\n    if num >= 0\n        return (num + 0.5).to_i\n    else\n        return (num - 0.5).to_i\n    end\nend\n",
            "# @param n [Integer]\n# @returns {Array<Integer>}\ndef make_a_pile(n)\n  (0...n).map { |i| n + 2 * i }\nend\n",
            "def words_string(s)\n  s.split(/[, ]+/).reject(&:empty?)\nend\n",
            "# @param x [Integer]\n# @param y [Integer]\n# @returns {Integer}\ndef choose_num(x, y)\n  return -1 if x > y\n  return y if y.even?\n  return y - 1 if x != y\n  -1\nend\n",
            "# @param n [Integer]\n# @param m [Integer]\n# @return [String, nil]\ndef rounded_avg(n, m)\n    return nil if n > m\n    r_avg = ((m + n) / 2.0).round\n    r_avg.to_s(2)\nend\n",
            "def all_digits_odd(s)\n  s.chars.all? { |digit| digit.ord % 2 != 0 }\nend\n\n# @param x [Array<Integer>]\n# @returns {Array<Integer>}\ndef unique_digits(x)\n  x.select { |num| all_digits_odd(num.to_s) }.sort\nend\n",
            "digit_names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n\ndef by_length(arr)\n    sorted_arr = arr.select { |x| 1 <= x && x <= 9 }.sort.reverse\n    sorted_arr.map { |x| digit_names[x-1] }\nend\n",
            "def f(n)\n  nums = (1..n).to_a\n  nums.map.with_index(1) do |_, i|\n    if i.odd?\n      nums.first(i).sum\n    else\n      nums.first(i).reduce(:*)\n    end\n  end\nend\n",
            "def even_odd_palindrome(n)\n    cnt = [0, 0]\n    (1..n).each do |i|\n        if i.to_s == i.to_s.reverse\n            cnt[i % 2] += 1\n        end\n    end\n    cnt\nend\n",
            "# @param arr [Array<Integer>]\n# @returns {Integer}\ndef count_nums(arr)\n    arr.count { |n| digits_sum(n) > 0 }\nend\n\ndef digits_sum(n)\n    n_str = n.to_s\n    if n >= 0\n        n_str.chars.map(&:to_i).sum\n    else\n        (n_str[0, 2].to_i * 2) + digits_sum(n.abs)\n    end\nend\n",
            "# @param arr [Array<Integer>]\n# @returns {Boolean}\ndef move_one_ball(arr)\n    return true if arr.empty?\n    \n    sorted_arr = arr.sort\n    \n    (0...arr.length).each do |i|\n        return true if arr[i..-1] == sorted_arr[0..-i-1] && arr[0...i] == sorted_arr[-i-1..-1]\n    end\n    \n    false\nend\n",
            "def can_exchange(lst1, lst2)\n    odd_cnt = lst1.count { |num| num % 2 != 0 }\n    even_cnt = lst2.count { |num| num % 2 == 0 }\n    even_cnt >= odd_cnt ? \"YES\" : \"NO\"\nend\n",
            "# @param test [String]\n# @returns {Hash{String => Integer}}\ndef histogram(test)\n    freq = {}\n    words = test.split(\" \").reject { |w| w.empty? }\n    words.each do |w|\n        freq[w] = (freq[w] || 0) + 1\n    end\n    result = {}\n    if !freq.empty?\n        max_freq = freq.values.max\n        freq.each do |k, v|\n            if v == max_freq\n                result[k] = v\n            end\n        end\n    end\n    result\nend\n",
            "def reverse_delete(s, c)\n  s1 = s.chars.reject { |ch| c.include?(ch) }.join\n  [s1, s1.reverse == s1 ? \"yes\" : \"no\"]\nend\n",
            "# @param lst [Array<String>]\n# @returns {Array<String>}\ndef odd_count(lst)\n    result = []\n    lst.each do |num|\n        n = num.chars.count { |d| d.ord % 2 == 1 }\n        rs = \"the number of odd elements in the string i of the input.\"\n        result << rs.gsub(\"i\", n.to_s)\n    end\n    result\nend\n",
            "# @param nums [Array<Integer>]\n# @returns {Integer}\ndef min_sub_array_sum(nums)\n    min_sum = 0\n    cur_sum = 0\n    nums.each do |n|\n        cur_sum = [cur_sum + n, 0].min\n        min_sum = [cur_sum, min_sum].min\n    end\n    if min_sum == 0\n        min_sum = nums.min\n    end\n    min_sum\nend\n",
            "def max_fill(grid, capacity)\n    grid.sum { |arr| (arr.sum.to_f / capacity).ceil }\nend\n",
            "def count_ones(num)\n  num.to_s(2).count(\"1\")\nend\n\ndef sort_array(arr)\n  arr.sort_by { |x| [count_ones(x), x] }\nend\n",
            "def select_words(s, n)\n  consonants = \"bcdfghjklmnpqrstvwxyz\"\n  words = s.split(\" \").select { |w| w.length > 0 }\n  words.select { |w| w.downcase.chars.count { |c| consonants.include?(c) } == n }\nend\n",
            "# @param word [String]\n# @returns {String}\ndef get_closest_vowel(word)\n    vowels = \"aeiouAEIOU\"\n    (word.length - 2).downto(1) do |i|\n        if vowels.include?(word[i]) && !vowels.include?(word[i - 1]) && !vowels.include?(word[i + 1])\n            return word[i]\n        end\n    end\n    \"\"\nend\n",
            "# @param lst [Array<String>]\n# @returns {String}\ndef match_parens(lst)\n    def check(s)\n        depth = 0\n        s.each_char do |ch|\n            if ch == \"(\"\n                depth += 1\n            else\n                depth -= 1\n            end\n            return false if depth < 0\n        end\n        return depth == 0\n    end\n\n    s1 = lst[0] + lst[1]\n    s2 = lst[1] + lst[0]\n    \"Yes\" if check(s1) || check(s2)\nend\n",
            "def maximum(arr, k)\n    if k == 0\n        return []\n    end\n    arr.sort.last(k)\nend\n",
            "# @param lst [Array<Integer>]\n# @returns {Integer}\ndef solution(lst)\n  lst.each_with_index.select { |x, i| i.even? && x.odd? }.map(&:first).sum\nend\n",
            "def add_elements(arr, k)\n  arr[0...k].select { |n| n.to_s.length <= 2 }.sum\nend\n",
            "def get_odd_collatz(n)\n    collatz = [1]\n    while n != 1\n        if n % 2 != 0\n            collatz << n\n            n = 3 * n + 1\n        else\n            n = n / 2\n        end\n    end\n    collatz.sort\nend\n",
            "def valid_date(date)\n    return false unless date.length == 10 && date[2] == '-' && date[5] == '-'\n    m = date[0, 2].to_i\n    d = date[3, 2].to_i\n    return true if [1, 3, 5, 7, 8, 10, 12].include?(m) && d >= 1 && d <= 31\n    return true if [4, 6, 9, 11].include?(m) && d >= 1 && d <= 30\n    return true if m == 2 && d >= 1 && d <= 29\n    false\nend\n",
            "# @param txt [String]\n# @returns {Array<String>}\ndef split_words(txt)\n    if txt.include?(\" \")\n        txt.split(\" \")\n    elsif txt.include?(\",\")\n        txt.split(\",\")\n    else\n        count = txt.chars.count { |c| c =~ /[a-z]/ && c.ord % 2 == 0 }\n        [count.to_s]\n    end\nend\n",
            "def is_sorted(lst)\n    return false unless lst.all? { |i| i == lst.first || lst[i] >= lst[i - 1] }\n    freq = Hash.new(0)\n    lst.each { |i| freq[i] += 1 }\n    freq.values.max <= 2\nend\n",
            "def prime?(n)\n  return false if n < 2\n  (2..Math.sqrt(n)).each do |i|\n    return false if n % i == 0\n  end\n  true\nend\n\n# @param interval1 [Array<Integer>]\n# @param interval2 [Array<Integer>]\n# @returns {String}\ndef intersection(interval1, interval2)\n  l = [interval1[0], interval2[0]].max\n  r = [interval1[1], interval2[1]].min\n  length = r - l\n  \"YES\" if length > 0 && prime?(length) else \"NO\"\nend\n",
            "def prod_signs(arr)\n    return nil if arr.empty?\n    return 0 if arr.include?(0)\n    sign = arr.count { |n| n < 0 } % 2 == 1 ? -1 : 1\n    sign * arr.sum(&:abs)\nend\n",
            "def min_path(grid, k)\n  n = grid.length\n  min_val = n * n + 1\n  (0...n).each do |i|\n    (0...n).each do |j|\n      if grid[i][j] == 1\n        temp = []\n        temp << grid[i - 1][j] if i != 0\n        temp << grid[i][j - 1] if j != 0\n        temp << grid[i + 1][j] if i != n - 1\n        temp << grid[i][j + 1] if j != n - 1\n        min_val = [min_val, *temp].min\n      end\n    end\n  end\n  result = []\n  (0...k).each do |i|\n    result << (i % 2 == 0 ? 1 : min_val)\n  end\n  result\nend\n",
            "def tri(n)\n    if n == 0\n        return [1]\n    end\n    seq = [1, 3]\n    for i in 2..n do\n        if i % 2 == 0\n            seq.push(i / 2.0 + 1)\n        else\n            seq.push(seq[i - 1] + seq[i - 2] + (i + 3) / 2.0)\n        end\n    end\n    return seq\nend\n",
            "def digits(n)\n  odds = n.to_s.chars.map(&:to_i).select { |d| d.odd? }\n  odds.any? ? odds.reduce(:*) : 0\nend\n",
            "# @param s [String]\n# @returns {Boolean}\ndef is_nested(s)\n    open_idx = []\n    close_idx = []\n    \n    s.each_char.with_index do |ch, i|\n        if ch == '['\n            open_idx << i\n        elsif ch == ']'\n            close_idx << i\n        end\n    end\n    \n    close_idx.reverse!\n    cnt = 0\n    l = close_idx.length\n    i = 0\n    \n    open_idx.each do |idx|\n        if i < l && idx < close_idx[i]\n            cnt += 1\n            i += 1\n        end\n    end\n    \n    cnt >= 2\nend\n",
            "def sum_squares(lst)\n    lst.map { |n| (n.ceil ** 2) }.sum\nend\n",
            "# @param txt [String]\n# @returns {Boolean}\ndef check_if_last_char_is_a_letter(txt)\n    return false if txt.empty?\n    last = txt[txt.rindex(' ') + 1..-1] || ''\n    return last.length == 1 && last =~ /[a-zA-Z]/\nend\n",
            "def can_arrange(arr)\n    return -1 if arr.length <= 1\n    idx = (1...arr.length).select { |i| arr[i] < arr[i - 1] }\n    idx.empty? ? -1 : idx.max\nend\n",
            "def largest_smallest_integers(lst)\n    neg = lst.select { |i| i < 0 }\n    pos = lst.select { |i| i > 0 }\n    max_neg = (neg.any? ? neg.max : nil)\n    min_pos = (pos.any? ? pos.min : nil)\n    [max_neg, min_pos]\nend\n",
            "# @param a [Object]\n# @param b [Object]\n# @returns {Float, nil}\ndef compare_one(a, b)\n    def any_to_real(o)\n        if o.is_a?(String)\n            Float(o.gsub(',', '.'))\n        elsif o.is_a?(Integer)\n            o.to_f\n        elsif o.is_a?(Float)\n            o\n        else\n            raise RuntimeError.new(\"Type Error\")\n        end\n    end\n\n    a1 = any_to_real(a)\n    b1 = any_to_real(b)\n    if a1 == b1\n        nil\n    elsif a1 > b1\n        a1\n    else\n        b1\n    end\nend\n",
            "# @param n [Integer]\n# @returns {Boolean}\ndef is_equal_to_sum_even(n)\n    n % 2 == 0 && n >= 8\nend\n",
            "# @param n [Integer]\n# @returns {Integer}\ndef special_factorial(n)\n  fact = 1\n  result = 1\n  (1..n).each do |i|\n    fact *= i\n    result *= fact\n  end\n  result\nend\n",
            "def fix_spaces(txt)\n  txt.gsub(/\\s{3,}/, '-').gsub(' ', '_')\nend\n",
            "def file_name_check(file_name)\n    suf = [\"txt\", \"exe\", \"dll\"]\n    lst = file_name.split(\".\")\n    if len(lst) != 2 || !suf.include?(lst[1]) || lst[0].empty? || !lst[0][0].match?(/\\A[a-zA-Z]/) || (lst[0] =~ /\\d/).count > 3\n        return \"No\"\n    end\n    return \"Yes\"\nend\n",
            "def sum_squares(lst)\n    result = 0\n    for i in 0...lst.length\n        if i % 3 == 0\n            result += lst[i]**2\n        elsif i % 4 == 0\n            result += lst[i]**3\n        else\n            result += lst[i]\n        end\n    end\n    return result\nend\n",
            "def is_prime(n)\n  return false if n < 2\n  (2..Math.sqrt(n)).each do |i|\n    return false if n % i == 0\n  end\n  true\nend\n\n# @param sentence [String]\n# @returns {String}\ndef words_in_sentence(sentence)\n  words = sentence.split(\" \")\n  filtered_words = words.select { |w| is_prime(w.length) }\n  filtered_words.join(\" \")\nend\n",
            "# @param x [String]\n# @param n [String]\n# @returns {Boolean}\ndef simplify(x, n)\n    xs = x.split(\"/\")\n    ns = n.split(\"/\")\n    num = xs[0].to_i * ns[0].to_i\n    den = xs[1].to_i * ns[1].to_i\n    num % den == 0\nend\n",
            "def digits_sum(n)\n  n_str = n.to_s\n  if n >= 0\n    return n_str.chars.map(&:to_i).sum\n  else\n    two_digit_part = n_str[0..1].to_i\n    return two_digit_part * 2 + digits_sum(n.abs)\n  end\nend\n\n# @param nums [Array<Integer>]\n# @returns {Array<Integer>}\ndef order_by_points(nums)\n  nums.sort_by { |num| digits_sum(num) }\nend\n",
            "def special_filter(nums)\n  odds = \"13579\"\n  nums.count { |n| n > 10 && n.odd? && odds.include?(n.to_s[0]) }\nend\n",
            "# @param n [Integer]\n# @returns {Integer}\ndef get_max_triples(n)\n    c = [0, 0, 0]\n    (1..n).each do |i|\n        a = i * i - i + 1\n        c[a % 3] += 1\n    end\n    return c[0] * c[1] * c[2] + ((c[0] * (c[0] - 1) * (c[0] - 2) + c[1] * (c[1] - 1) * (c[1] - 2) + c[2] * (c[2] - 1) * (c[2] - 2)) / 6)\nend\n",
            "# @param planet1 [String]\n# @param planet2 [String]\n# @returns {Array<String>}\ndef bf(planet1, planet2)\n    names = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    return [] unless names.include?(planet1) && names.include?(planet2)\n    \n    l = names.index(planet1)\n    r = names.index(planet2)\n    \n    l, r = r, l if l > r\n    return [] if l == r\n    \n    names[l + 1...r]\nend\n",
            "def sorted_list_sum(lst)\n    result = lst.select { |s| s.length.even? }\n    result.sort_by { |x| [x.length, x] }\nend\n",
            "# @param n [Integer]\n# @param x [Integer]\n# @param y [Integer]\n# @returns {Integer}\ndef x_or_y(n, x, y)\n  return y if n < 2\n  (2..Math.sqrt(n).floor).each do |i|\n    return y if n % i == 0\n  end\n  x\nend\n",
            "# @param lst [Array<Float>]\n# @returns {Integer}\ndef double_the_difference(lst)\n    lst.select { |n| n >= 0 && n.to_i.even? }.map { |n| (n * n).to_i }.sum\nend\n",
            "# @param game [Array<Integer>]\n# @param guess [Array<Integer>]\n# @returns {Array<Integer>}\ndef compare(game, guess)\n  game.zip(guess).map { |x, y| (x - y).abs }\nend\n",
            "# @param class_name [String]\n# @param extensions [Array<String>]\n# @return [String]\ndef strongest_extension(class_name, extensions)\n    max_s = -Float::INFINITY\n    max_ext = \"\"\n    extensions.each do |ext|\n        upper = ext.count { |c| c =~ /[A-Z]/ }\n        lower = ext.count { |c| c =~ /[a-z]/ }\n        s = upper - lower\n        if s > max_s\n            max_s = s\n            max_ext = ext\n        end\n    end\n    \"#{class_name}.#{max_ext}\"\nend\n",
            "def cycpattern_check(a, b)\n  return false if a.length < b.length\n  (0...b.length).each do |i|\n    return true if \"#{b[i..]}#{b[0...i]}\" == a\n  end\n  false\nend\n",
            "def even_odd_count(num)\n    ds = num.abs.to_s\n    even = ds.chars.count { |d| d.ord % 2 == 0 }\n    [even, ds.length - even]\nend\n",
            "# @param num [Integer]\n# @returns {String}\ndef int_to_mini_roman(num)\n    values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    res = []\n    (0...values.length).each do |i|\n        while num >= values[i]\n            res << numerals[i]\n            num -= values[i]\n        end\n    end\n    res.join(\"\")\nend\n",
            "# @param a [Integer]\n# @param b [Integer]\n# @param c [Integer]\n# @return [Boolean]\ndef right_angle_triangle(a, b, c)\n    s = [a, b, c].sort\n    s[0] * s[0] + s[1] * s[1] == s[2] * s[2]\nend\n",
            "# @param words [Array<String>]\n# @returns String\ndef find_max(words)\n    max_cnt = 0\n    max_w = \"\"\n    words.each do |w|\n        cnt = w.chars.uniq.length\n        if cnt > max_cnt\n            max_cnt = cnt\n            max_w = w\n        elsif cnt == max_cnt\n            max_w = [max_w, w].min\n        end\n    end\n    max_w\nend\n",
            "# @param num [Integer]\n# @param need [Integer]\n# @param remaining [Integer]\n# @returns {Array<Integer>}\ndef eat(num, need, remaining)\n  if need <= remaining\n    [num + need, remaining - need]\n  else\n    [num + remaining, 0]\n  end\nend\n",
            "def do_algebra(operators, operands)\n  ops = operators.dup\n  nums = operands.dup\n  i = ops.length - 1\n  while i >= 0\n    if ops[i] == \"**\"\n      nums[i] = nums[i].pow(nums[i + 1])\n      nums.delete_at(i + 1)\n      ops.delete_at(i)\n    end\n    i -= 1\n  end\n  i = 0\n  while i < ops.length\n    if ops[i] == \"*\"\n      nums[i] = nums[i] * nums[i + 1]\n      nums.delete_at(i + 1)\n      ops.delete_at(i)\n      i -= 1\n    elsif ops[i] == \"//\"\n      nums[i] = nums[i] / nums[i + 1]\n      nums.delete_at(i + 1)\n      ops.delete_at(i)\n      i -= 1\n    end\n    i += 1\n  end\n  i = 0\n  while i < ops.length\n    if ops[i] == \"+\"\n      nums[i] = nums[i] + nums[i + 1]\n      nums.delete_at(i + 1)\n      ops.delete_at(i)\n      i -= 1\n    elsif ops[i] == \"-\"\n      nums[i] = nums[i] - nums[i + 1]\n      nums.delete_at(i + 1)\n      ops.delete_at(i)\n      i -= 1\n    end\n    i += 1\n  end\n  return nums[0]\nend\n",
            "# @param s [String]\n# @returns {String}\ndef solve(s)\n  if !s.chars.any? { |ch| ch =~ /[a-zA-Z]/ }\n    return s.reverse\n  end\n\n  result = []\n  s.each_char do |ch|\n    if !ch.match?(/[a-zA-Z]/)\n      result << ch\n    elsif ch =~ /[A-Z]/\n      result << ch.downcase\n    elsif ch =~ /[a-z]/\n      result << ch.upcase\n    end\n  end\n\n  result.join\nend\n",
            "def string_to_md5(txt)\n    return nil if txt.empty?\n    md5_hash = Digest::MD5.new\n    txt_bytes = txt.force_encoding('UTF-8')\n    md5_hash.update(txt_bytes)\n    md5_encoded = md5_hash.hexdigest\n    md5_encoded\nend\n",
            "# @param a [Integer]\n# @param b [Integer]\n# @returns {Array<Integer>}\ndef generate_integers(a, b)\n  lower = [2, [a, b].min].max\n  upper = [8, [a, b].max].min\n  (lower..upper).select { |i| i.even? }\nend\n"
        ]
    }
}