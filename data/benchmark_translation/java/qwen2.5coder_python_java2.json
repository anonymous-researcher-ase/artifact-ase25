{
    "python": {
        "go": [
            "```go\nfunc HasCloseElements(numbers []float64, threshold float64) bool {\n    for i := 0; i < len(numbers); i++ {\n        for j := i + 1; j < len(numbers); j++ {\n            if math.Abs(numbers[i]-numbers[j]) < threshold {\n                return true\n            }\n        }\n    }\n    return false\n}\n```",
            "```go\nfunc SeparateParenGroups(parenString string) []string {\n    groups := []string{}\n    stk := []rune{}\n    currentGroup := \"\"\n    parens := strings.ReplaceAll(parenString, \" \", \"\")\n    for _, ch := range parens {\n        if ch == '(' {\n            stk = append(stk, ch)\n            currentGroup += string(ch)\n        } else if ch == ')' {\n            stk = stk[:len(stk)-1]\n            currentGroup += string(ch)\n            if len(stk) == 0 {\n                groups = append(groups, currentGroup)\n                currentGroup = \"\"\n            }\n        }\n    }\n    return groups\n}\n```",
            "```go\nfunc TruncateNumber(num float64) float64 {\n    return num - math.Floor(num)\n}\n```",
            "```go\nfunc BelowZero(operations []int) bool {\n    balance := 0\n    for _, op := range operations {\n        balance += op\n        if balance < 0 {\n            return true\n        }\n    }\n    return false\n}\n```",
            "```go\nfunc MeanAbsoluteDeviation(numbers []float64) float64 {\n    sum := 0.0\n    for _, num := range numbers {\n        sum += num\n    }\n    mean := sum / float64(len(numbers))\n    \n    deviationSum := 0.0\n    for _, num := range numbers {\n        deviationSum += math.Abs(num - mean)\n    }\n    \n    return deviationSum / float64(len(numbers))\n}\n```",
            "```go\nfunc Intersperse(numbers []int, delimiter int) []int {\n    result := []int{}\n    for i, num := range numbers {\n        if i != 0 {\n            result = append(result, delimiter)\n        }\n        result = append(result, num)\n    }\n    return result\n}\n```",
            "```go\nfunc ParseNestedParens(parenString string) []int {\n    result := []int{}\n    parenGroups := strings.Split(parenString, \" \")\n    for _, group := range parenGroups {\n        maxDepth := 0\n        depth := 0\n        for _, ch := range group {\n            if ch == '(' {\n                depth += 1\n                if depth > maxDepth {\n                    maxDepth = depth\n                }\n            } else if ch == ')' {\n                depth -= 1\n            }\n        }\n        result = append(result, maxDepth)\n    }\n    return result\n}\n```",
            "```go\nfunc FilterBySubstring(strs []string, substring string) []string {\n    var result []string\n    for _, s := range strs {\n        if strings.Contains(s, substring) {\n            result = append(result, s)\n        }\n    }\n    return result\n}\n```",
            "```go\nfunc SumProduct(numbers []int) []int {\n    n_sum := 0\n    n_product := 1\n    for _, number := range numbers {\n        n_sum += number\n        n_product *= number\n    }\n    return []int{n_sum, n_product}\n}\n```",
            "```go\nfunc RollingMax(numbers []int) []int {\n    maxSoFar := math.MinInt\n    result := []int{}\n    for _, num := range numbers {\n        if num > maxSoFar {\n            maxSoFar = num\n        }\n        result = append(result, maxSoFar)\n    }\n    return result\n}\n```",
            "```go\nfunc MakePalindrome(s string) string {\n    if isPalindrome(s) {\n        return s\n    }\n    for i := 0; i < len(s); i++ {\n        if isPalindrome(s[i:]) {\n            prefix := []rune(s[:i])\n            for left, right := 0, len(prefix)-1; left < right; left, right = left+1, right-1 {\n                prefix[left], prefix[right] = prefix[right], prefix[left]\n            }\n            return s + string(prefix)\n        }\n    }\n    return \"\"\n}\n\nfunc isPalindrome(s string) bool {\n    left := 0\n    right := len(s) - 1\n    for left < right {\n        if s[left] != s[right] {\n            return false\n        }\n        left++\n        right--\n    }\n    return true\n}\n```",
            "```go\nfunc StringXor(a string, b string) string {\n    result := \"\"\n    minLength := len(a)\n    if len(b) < minLength {\n        minLength = len(b)\n    }\n    for i := 0; i < minLength; i++ {\n        x := a[i]\n        y := b[i]\n        if x == y {\n            result += \"0\"\n        } else {\n            result += \"1\"\n        }\n    }\n    return result\n}\n```",
            "```go\nfunc Longest(strs []string) *string {\n    if len(strs) == 0 {\n        return nil\n    }\n    longest_s := strs[0]\n    for _, s := range strs {\n        if len(s) > len(longest_s) {\n            longest_s = s\n        }\n    }\n    return &longest_s\n}\n```",
            "```go\nfunc GreatestCommonDivisor(a int, b int) int {\n    if b == 0 {\n        return a\n    } else {\n        return GreatestCommonDivisor(b, a % b)\n    }\n}\n```",
            "```go\nfunc AllPrefixes(s string) []string {\n    prefixes := make([]string, 0)\n    for i := 0; i < len(s); i++ {\n        prefixes = append(prefixes, s[:i+1])\n    }\n    return prefixes\n}\n```",
            "```go\nfunc StringSequence(n int) string {\n    var result strings.Builder\n    for i := 0; i <= n; i++ {\n        result.WriteString(fmt.Sprintf(\"%d\", i))\n        if i < n {\n            result.WriteString(\" \")\n        }\n    }\n    return result.String()\n}\n```",
            "```go\nfunc CountDistinctCharacters(s string) int {\n    charMap := make(map[rune]bool)\n    for _, char := range s {\n        charMap[char] = true\n    }\n    return len(charMap)\n}\n```",
            "```go\nfunc ParseMusic(musicString string) []int {\n    durations := map[string]int{\"o\": 4, \"o|\": 2, \".|\": 1}\n    notes := strings.Split(musicString, \" \")\n    var result []int\n    for _, note := range notes {\n        if duration, exists := durations[note]; exists {\n            result = append(result, duration)\n        }\n    }\n    return result\n}\n```",
            "```go\nfunc HowManyTimes(s string, substring string) int {\n    times := 0\n    subLength := len(substring)\n    for i := 0; i <= len(s)-subLength; i++ {\n        if s[i:i+subLength] == substring {\n            times++\n        }\n    }\n    return times\n}\n```",
            "```go\nfunc SortNumbers(numbers string) string {\n    numDict := map[string]int{\n        \"zero\": 0,\n        \"one\": 1,\n        \"two\": 2,\n        \"three\": 3,\n        \"four\": 4,\n        \"five\": 5,\n        \"six\": 6,\n        \"seven\": 7,\n        \"eight\": 8,\n        \"nine\": 9,\n    }\n\n    numList := strings.Fields(numbers)\n    validNums := []string{}\n    for _, num := range numList {\n        if _, found := numDict[num]; found {\n            validNums = append(validNums, num)\n        }\n    }\n\n    sort.Slice(validNums, func(i, j int) bool {\n        return numDict[validNums[i]] < numDict[validNums[j]]\n    })\n\n    return strings.Join(validNums, \" \")\n}\n```",
            "```go\nfunc FindClosestElements(numbers []float64) []float64 {\n    sortedNumbers := make([]float64, len(numbers))\n    copy(sortedNumbers, numbers)\n    sort.Float64s(sortedNumbers)\n    minDiff := math.MaxFloat64\n    closestPair := make([]float64, 2)\n    for i := 1; i < len(sortedNumbers); i++ {\n        diff := sortedNumbers[i] - sortedNumbers[i-1]\n        if diff < minDiff {\n            minDiff = diff\n            closestPair[0] = sortedNumbers[i-1]\n            closestPair[1] = sortedNumbers[i]\n        }\n    }\n    return closestPair\n}\n```",
            "```go\nfunc RescaleToUnit(numbers []float64) []float64 {\n    if len(numbers) == 0 {\n        return nil\n    }\n    \n    minNum := numbers[0]\n    maxNum := numbers[0]\n    \n    for _, num := range numbers {\n        if num < minNum {\n            minNum = num\n        }\n        if num > maxNum {\n            maxNum = num\n        }\n    }\n    \n    if minNum == maxNum {\n        result := make([]float64, len(numbers))\n        for i := range result {\n            result[i] = 0.0\n        }\n        return result\n    } else {\n        result := make([]float64, len(numbers))\n        for i, num := range numbers {\n            result[i] = (num - minNum) / (maxNum - minNum)\n        }\n        return result\n    }\n}\n```",
            "```go\nfunc FilterIntegers(values []interface{}) []int {\n    var result []int\n    for _, value := range values {\n        if intValue, ok := value.(int); ok {\n            result = append(result, intValue)\n        }\n    }\n    return result\n}\n```",
            "```go\nfunc StrLength(s string) int {\n    return len(s)\n}\n```",
            "```go\nfunc LargestDivisor(n int) int {\n    for i := 2; i < n; i++ {\n        if n%i == 0 {\n            return n / i\n        }\n    }\n    return 1\n}\n```",
            "```go\nfunc Factorize(n int) []int {\n    factors := []int{}\n    divisor := 2\n    for divisor <= n {\n        if n%divisor == 0 {\n            factors = append(factors, divisor)\n            n /= divisor\n        } else {\n            divisor++\n        }\n    }\n    return factors\n}\n```",
            "```go\nfunc RemoveDuplicates(numbers []int) []int {\n    counts := make(map[int]int)\n    for _, num := range numbers {\n        counts[num]++\n    }\n    var res []int\n    for _, num := range numbers {\n        if counts[num] == 1 {\n            res = append(res, num)\n        }\n    }\n    return res\n}\n```",
            "```go\nfunc FlipCase(s string) string {\n    var flipped []rune\n    for _, ch := range s {\n        if !unicode.IsLetter(ch) {\n            flipped = append(flipped, ch)\n        } else if unicode.IsLower(ch) {\n            flipped = append(flipped, unicode.ToUpper(ch))\n        } else if unicode.IsUpper(ch) {\n            flipped = append(flipped, unicode.ToLower(ch))\n        }\n    }\n    return string(flipped)\n}\n```",
            "```go\nfunc Concatenate(strs []string) string {\n    var result strings.Builder\n    for _, str := range strs {\n        result.WriteString(str)\n    }\n    return result.String()\n}\n```",
            "```go\nfunc FilterByPrefix(strs []string, prefixStr string) []string {\n    var filtered []string\n    for _, s := range strs {\n        if strings.HasPrefix(s, prefixStr) {\n            filtered = append(filtered, s)\n        }\n    }\n    return filtered\n}\n```",
            "```go\nfunc GetPositive(l []int) []int {\n    var result []int\n    for _, num := range l {\n        if num > 0 {\n            result = append(result, num)\n        }\n    }\n    return result\n}\n```",
            "```go\nfunc IsPrime(n int) bool {\n    if n < 2 {\n        return false\n    }\n    for i := 2; i <= int(math.Sqrt(float64(n))); i++ {\n        if n%i == 0 {\n            return false\n        }\n    }\n    return true\n}\n```",
            "```go\nfunc Poly(xs []int, x float64) float64 {\n    res := 0.0\n    for i := 0; i < len(xs); i++ {\n        res += float64(xs[i]) * math.Pow(x, float64(i))\n    }\n    return res\n}\n\nfunc FindZero(xs []int) float64 {\n    x1, x2 := 1.0, -1.0\n    for Poly(xs, x1)*Poly(xs, x2) > 0 {\n        x1 *= 2\n        x2 *= 2\n    }\n    for math.Abs(x1-x2) > 1e-10 {\n        mid := (x1 + x2) / 2\n        if Poly(xs, mid) == 0 {\n            return mid\n        } else if Poly(xs, mid)*Poly(xs, x1) < 0 {\n            x2 = mid\n        } else {\n            x1 = mid\n        }\n    }\n    return (x1 + x2) / 2\n}\n```",
            "```go\nfunc SortThird(l []int) []int {\n    sortedThird := make([]int, len(l)/3+1)\n    index := 0\n    for i := 0; i < len(l); i += 3 {\n        sortedThird[index] = l[i]\n        index++\n    }\n    sort.Ints(sortedThird)\n\n    result := make([]int, len(l))\n    j := 0\n    for i := range l {\n        if i%3 == 0 {\n            result[i] = sortedThird[j]\n            j++\n        } else {\n            result[i] = l[i]\n        }\n    }\n    return result\n}\n```",
            "```go\nfunc ListUnique(l []int) []int {\n    uniqueMap := make(map[int]bool)\n    for _, value := range l {\n        uniqueMap[value] = true\n    }\n    \n    var resultList []int\n    for key, _ := range uniqueMap {\n        resultList = append(resultList, key)\n    }\n    \n    sort.Ints(resultList)\n    return resultList\n}\n```",
            "```go\nfunc MaxElement(l []int) int {\n    if len(l) == 0 {\n        return 0\n    }\n    max := l[0]\n    for _, value := range l {\n        if value > max {\n            max = value\n        }\n    }\n    return max\n}\n```",
            "```go\nfunc FizzBuzz(n int) int {\n    cnt := 0\n    for i := 0; i < n; i++ {\n        if i%11 == 0 || i%13 == 0 {\n            str := fmt.Sprintf(\"%d\", i)\n            for _, c := range str {\n                if c == '7' {\n                    cnt++\n                }\n            }\n        }\n    }\n    return cnt\n}\n```",
            "```go\nfunc SortEven(l []int) []int {\n    evenIndices := make([]int, 0)\n    for i := 0; i < len(l); i += 2 {\n        evenIndices = append(evenIndices, l[i])\n    }\n    sortedEvens := make([]int, len(evenIndices))\n    copy(sortedEvens, evenIndices)\n    sort.Ints(sortedEvens)\n    \n    result := make([]int, len(l))\n    for i := range l {\n        if i%2 == 0 {\n            result[i] = sortedEvens[i/2]\n        } else {\n            result[i] = l[i]\n        }\n    }\n    return result\n}\n```",
            "```go\nfunc EncodeCyclic(s string) string {\n    var result []byte\n    for i := 0; i < len(s); i += 3 {\n        if i+3 > len(s) {\n            result = append(result, s[i:]...)\n        } else {\n            result = append(result, s[i+1:i+3]...)\n            result = append(result, s[i])\n        }\n    }\n    return string(result)\n}\n\nfunc DecodeCyclic(s string) string {\n    return EncodeCyclic(EncodeCyclic(s))\n}\n```",
            "```go\nfunc PrimeFib(n int) int {\n    if n < 2 {\n        return -1\n    }\n    f := []int{0, 1}\n    cnt := 0\n    for cnt < n {\n        f = append(f[1:], f[0]+f[1])\n        if isPrime(f[len(f)-1]) {\n            cnt++\n        }\n    }\n    return f[len(f)-1]\n}\n\nfunc isPrime(num int) bool {\n    if num < 2 {\n        return false\n    }\n    for i := 2; i*i <= num; i++ {\n        if num%i == 0 {\n            return false\n        }\n    }\n    return true\n}\n```",
            "```go\nfunc TriplesSumToZero(l []int) bool {\n    for i := 0; i < len(l); i++ {\n        for j := i + 1; j < len(l); j++ {\n            for k := j + 1; k < len(l); k++ {\n                if l[i] + l[j] + l[k] == 0 {\n                    return true\n                }\n            }\n        }\n    }\n    return false\n}\n```",
            "```go\nfunc CarRaceCollision(n int) int {\n    return n * n\n}\n```",
            "```go\nfunc IncrList(l []int) []int {\n    result := make([]int, len(l))\n    for i, v := range l {\n        result[i] = v + 1\n    }\n    return result\n}\n```",
            "```go\nfunc PairsSumToZero(l []int) bool {\n    seen := make(map[int]bool)\n    for _, num := range l {\n        if seen[-num] {\n            return true\n        }\n        seen[num] = true\n    }\n    return false\n}\n```",
            "```go\nfunc ChangeBase(x int, bas int) string {\n    if x == 0 {\n        return \"0\"\n    }\n    digits := []byte{}\n    for x > 0 {\n        digits = append(digits, byte('0'+x%bas))\n        x /= bas\n    }\n    for i, j := 0, len(digits)-1; i < j; i, j = i+1, j-1 {\n        digits[i], digits[j] = digits[j], digits[i]\n    }\n    return string(digits)\n}\n```",
            "```go\nfunc TriangleArea(a int, h int) float64 {\n    return float64(a) * float64(h) / 2\n}\n```",
            "```go\nfunc Fib4(n int) int {\n    fib := []int{0, 0, 2, 0}\n    for i := 4; i <= n; i++ {\n        fib[i%4] = fib[0] + fib[1] + fib[2] + fib[3]\n    }\n    return fib[n%4]\n}\n```",
            "```go\nfunc Median(l []float64) float64 {\n    sl := make([]float64, len(l))\n    copy(sl, l)\n    sort.Float64s(sl)\n    n := len(l)\n    if n%2 != 0 {\n        return sl[n/2]\n    } else {\n        return (sl[n/2] + sl[n/2-1]) / 2\n    }\n}\n```",
            "```go\nfunc IsPalindrome(txt string) bool {\n    n := len(txt)\n    for i := 0; i < n/2; i++ {\n        if txt[i] != txt[n-1-i] {\n            return false\n        }\n    }\n    return true\n}\n```",
            "```go\nfunc Modp(n int, p int) int {\n    ret := 1\n    for i := 0; i < n; i++ {\n        ret = (ret * 2) % p\n    }\n    return ret\n}\n```",
            "```go\nfunc EncodeShift(s string) string {\n\tresult := []rune{}\n\tfor _, ch := range s {\n\t\tresult = append(result, 'a'+(ch-'a'+5)%26)\n\t}\n\treturn string(result)\n}\n\nfunc DecodeShift(s string) string {\n\tresult := []rune{}\n\tfor _, ch := range s {\n\t\tresult = append(result, 'a'+(ch-'a'+21)%26)\n\t}\n\treturn string(result)\n}\n```",
            "```go\nfunc RemoveVowels(txt string) string {\n    vowels := \"aeiouAEIOU\"\n    result := []rune{}\n    for _, c := range txt {\n        if !strings.ContainsRune(vowels, c) {\n            result = append(result, c)\n        }\n    }\n    return string(result)\n}\n```",
            "```go\nfunc BelowThreshold(l []int, t int) bool {\n    for _, x := range l {\n        if x >= t {\n            return false\n        }\n    }\n    return true\n}\n```",
            "```go\nfunc Add(x int, y int) int {\n    return x + y\n}\n```",
            "```go\nfunc sameChars(s0 string, s1 string) bool {\n    charSet := make(map[rune]bool)\n    for _, c := range s0 {\n        charSet[c] = true\n    }\n    for _, c := range s1 {\n        if !charSet[c] {\n            return false\n        }\n        delete(charSet, c)\n    }\n    return len(charSet) == 0\n}\n```",
            "```go\nfunc Fib(n int) int {\n    if n <= 1 {\n        return n\n    } else {\n        return Fib(n - 1) + Fib(n - 2)\n    }\n}\n```",
            "```go\nfunc CorrectBracketing(brackets string) bool {\n    depth := 0\n    for _, b := range brackets {\n        if b == '<' {\n            depth += 1\n        } else if b == '>' {\n            depth -= 1\n        }\n        if depth < 0 {\n            return false\n        }\n    }\n    return depth == 0\n}\n```",
            "```go\nfunc Monotonic(l []int) bool {\n    if len(l) <= 1 {\n        return true\n    }\n\n    n := len(l)\n    nonDecreasing := true\n    nonIncreasing := true\n\n    for i := 0; i < n-1; i++ {\n        if l[i] > l[i+1] {\n            nonDecreasing = false\n        }\n        if l[i] < l[i+1] {\n            nonIncreasing = false\n        }\n    }\n\n    return nonDecreasing || nonIncreasing\n}\n```",
            "```go\nfunc Common(l1 []int, l2 []int) []int {\n    set1 := make(map[int]struct{})\n    for _, v := range l1 {\n        set1[v] = struct{}{}\n    }\n    set2 := make(map[int]struct{})\n    for _, v := range l2 {\n        set2[v] = struct{}{}\n    }\n    var result []int\n    for k := range set1 {\n        if _, found := set2[k]; found {\n            result = append(result, k)\n        }\n    }\n    sort.Ints(result)\n    return result\n}\n```",
            "```go\nfunc LargestPrimeFactor(n int) int {\n    i := 2\n    for i*i <= n {\n        if n%i != 0 {\n            i += 1\n        } else {\n            n /= i\n        }\n    }\n    return n\n}\n```",
            "```go\nfunc SumToN(n int) int {\n    sum := 0\n    for i := 1; i <= n; i++ {\n        sum += i\n    }\n    return sum\n}\n```",
            "```go\nfunc CorrectBracketing(brackets string) bool {\n    depth := 0\n    for _, b := range brackets {\n        if b == '(' {\n            depth += 1\n        } else if b == ')' {\n            depth -= 1\n        }\n        if depth < 0 {\n            return false\n        }\n    }\n    return depth == 0\n}\n```",
            "```go\nfunc Derivative(xs []int) []int {\n    result := []int{}\n    for i := 1; i < len(xs); i++ {\n        result = append(result, xs[i]*i)\n    }\n    return result\n}\n```",
            "```go\nfunc Fibfib(n int) int {\n    if n <= 1 {\n        return 0 \n    }\n    a, b, c := 0, 0, 1\n    for n > 2 {\n        a, b, c = b, c, a + b + c\n        n -= 1\n    }\n    return c\n}\n```",
            "```go\nfunc VowelsCount(s string) int {\n    vowels := \"aeiou\"\n    cnt := 0\n    for i := range s {\n        if strings.ContainsRune(vowels, unicode.ToLower(rune(s[i]))) ||\n           (i == len(s)-1 && unicode.ToLower(rune(s[i])) == 'y') {\n            cnt++\n        }\n    }\n    return cnt\n}\n```",
            "```go\nfunc CircularShift(x int, shift int) string {\n    x_str := []rune(strconv.Itoa(x))\n    if shift > len(x_str) {\n        return reverseString(string(x_str))\n    } else {\n        return string(x_str[len(x_str)-shift:]) + string(x_str[:len(x_str)-shift])\n    }\n}\n\nfunc reverseString(s string) string {\n    runes := []rune(s)\n    for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\n        runes[i], runes[j] = runes[j], runes[i]\n    }\n    return string(runes)\n}\n```",
            "```go\nfunc DigitSum(s string) int {\n    sum := 0\n    for _, c := range s {\n        if unicode.IsUpper(c) {\n            sum += int(c)\n        }\n    }\n    return sum\n}\n```",
            "```go\nfunc FruitDistribution(s string, n int) int {\n    words := strings.Split(s, \" \")\n    indexApples := slices.Index(words, \"apples\")\n    apples := strconv.Atoi(words[indexApples - 1])\n    indexOranges := slices.Index(words, \"oranges\")\n    oranges := strconv.Atoi(words[indexOranges - 1])\n    return n - apples - oranges\n}\n```",
            "```go\nfunc Pluck(arr []int) []int {\n    var evens []int\n    for _, n := range arr {\n        if n%2 == 0 {\n            evens = append(evens, n)\n        }\n    }\n    if len(evens) == 0 {\n        return []int{}\n    }\n    minEven := evens[0]\n    for _, n := range evens {\n        if n < minEven {\n            minEven = n\n        }\n    }\n    index := -1\n    for i, n := range arr {\n        if n == minEven {\n            index = i\n            break\n        }\n    }\n    return []int{minEven, index}\n}\n```",
            "```go\nfunc Search(lst []int) int {\n    freqs := make(map[int]int)\n    for _, n := range lst {\n        freqs[n]++\n    }\n    var goodVals []int\n    for k, v := range freqs {\n        if v >= k {\n            goodVals = append(goodVals, k)\n        }\n    }\n    if len(goodVals) == 0 {\n        return -1\n    }\n    maxVal := goodVals[0]\n    for _, val := range goodVals {\n        if val > maxVal {\n            maxVal = val\n        }\n    }\n    return maxVal\n}\n```",
            "```go\nfunc StrangeSortList(lst []int) []int {\n    sl := make([]int, len(lst))\n    copy(sl, lst)\n    sort.Ints(sl)\n    result := make([]int, 0, len(lst))\n    left, right := 0, len(sl)-1\n    for left <= right {\n        result = append(result, sl[left])\n        left++\n        if left <= right {\n            result = append(result, sl[right])\n            right--\n        }\n    }\n    return result\n}\n```",
            "```go\nfunc TriangleArea(a int, b int, c int) float64 {\n    if a+b > c && a+c > b && b+c > a {\n        s := float64(a+b+c) / 2.0\n        return math.Sqrt(s * (s - float64(a)) * (s - float64(b)) * (s - float64(c)))\n    } else {\n        return -1.0\n    }\n}\n```",
            "```go\nfunc WillItFly(q []int, w int) bool {\n    if len(q) == 0 {\n        return false\n    }\n    isPali := true\n    for i := 0; i < len(q)/2; i++ {\n        if q[i] != q[len(q)-i-1] {\n            isPali = false\n            break\n        }\n    }\n    total := 0\n    for _, v := range q {\n        total += v\n    }\n    return isPali && total <= w\n}\n```",
            "```go\nfunc SmallestChange(arr []int) int {\n    ans := 0\n    for i := 0; i < len(arr)/2; i++ {\n        if arr[i] != arr[len(arr)-i-1] {\n            ans += 1\n        }\n    }\n    return ans\n}\n```",
            "```go\nfunc TotalMatch(lst1 []string, lst2 []string) []string {\n    cnt1 := 0\n    for _, str := range lst1 {\n        cnt1 += len(str)\n    }\n    cnt2 := 0\n    for _, str := range lst2 {\n        cnt2 += len(str)\n    }\n    if cnt1 <= cnt2 {\n        return lst1\n    }\n    return lst2\n}\n```",
            "```go\nfunc IsMultiplyPrime(a int) bool {\n    cnt := 0\n    for i := 2; i <= a; i++ {\n        if IsPrime(i) {\n            for a%i == 0 {\n                cnt++\n                a /= i\n            }\n        }\n    }\n    return cnt == 3\n}\n\nfunc IsPrime(n int) bool {\n    if n < 2 {\n        return false\n    }\n    for i := 2; i*i <= n; i++ {\n        if n%i == 0 {\n            return false\n        }\n    }\n    return true\n}\n```",
            "```go\nfunc IsSimplePower(x int, n int) bool {\n    if n < 2 {\n        return x == n\n    }\n    tmp := 1\n    for tmp < x {\n        tmp *= n\n    }\n    return tmp == x\n}\n```",
            "```go\nfunc IsCube(a int) bool {\n    a = int(math.Abs(float64(a)))\n    root := int(math.Round(math.Cbrt(float64(a))))\n    return root*root*root == a\n}\n```",
            "```go\nfunc HexKey(num string) int {\n    count := 0\n    for _, x := range num {\n        if \"2357BD\".ContainsRune(x) {\n            count++\n        }\n    }\n    return count\n}\n```",
            "```go\nfunc DecimalToBinary(dec int) string {\n    binary := strconv.FormatInt(int64(dec), 2)\n    return \"db\" + binary + \"db\"\n}\n```",
            "```go\nfunc IsHappy(s string) bool {\n    if len(s) < 3 {\n        return false\n    }\n    for i := 0; i < len(s)-2; i++ {\n        if s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2] {\n            return false\n        }\n    }\n    return true\n}\n```",
            "```go\nfunc NumericalLetterGrade(grades []float64) []string {\n    result := []string{}\n    for _, g := range grades {\n        if g == 4.0 {\n            result = append(result, \"A+\")\n        } else if g > 3.7 {\n            result = append(result, \"A\")\n        } else if g > 3.3 {\n            result = append(result, \"A-\")\n        } else if g > 3.0 {\n            result = append(result, \"B+\")\n        } else if g > 2.7 {\n            result = append(result, \"B\")\n        } else if g > 2.3 {\n            result = append(result, \"B-\")\n        } else if g > 2.0 {\n            result = append(result, \"C+\")\n        } else if g > 1.7 {\n            result = append(result, \"C\")\n        } else if g > 1.3 {\n            result = append(result, \"C-\")\n        } else if g > 1.0 {\n            result = append(result, \"D+\")\n        } else if g > 0.7 {\n            result = append(result, \"D\")\n        } else if g > 0.0 {\n            result = append(result, \"D-\")\n        } else {\n            result = append(result, \"E\")\n        }\n    }\n    return result\n}\n```",
            "```go\nfunc PrimeLength(s string) bool {\n    length := len(s)\n    if length < 2 {\n        return false\n    }\n    for i := 2; i <= int(math.Sqrt(float64(length))); i++ {\n        if length%i == 0 {\n            return false\n        }\n    }\n    return true\n}\n```",
            "```go\nfunc StartsOneEnds(n int) int {\n    if n == 1 {\n        return 1\n    }\n    return 2 * 9 * int(math.Pow(10, float64(n-2)))\n}\n```",
            "```go\nfunc Solve(n int) string {\n    digitsSum := 0\n    for n > 0 {\n        digitsSum += n % 10\n        n /= 10\n    }\n    return fmt.Sprintf(\"%b\", digitsSum)\n}\n```",
            "```go\nfunc Add(lst []int) int {\n    sum := 0\n    for i := 1; i < len(lst); i += 2 {\n        x := lst[i]\n        if x%2 == 0 {\n            sum += x\n        }\n    }\n    return sum\n}\n```",
            "```go\nfunc AntiShuffle(s string) string {\n    result := \"\"\n    words := strings.Split(s, \" \")\n    \n    for _, word := range words {\n        chars := []rune(word)\n        sort.Slice(chars, func(i, j int) bool {\n            return chars[i] < chars[j]\n        })\n        result += string(chars) + \" \"\n    }\n    \n    return strings.TrimSpace(result)\n}\n```",
            "```go\nfunc GetRow(lst [][]int, x int) [][]int {\n    coords := [][]int{}\n    for i, row := range lst {\n        for j, val := range row {\n            if val == x {\n                coord := []int{i, j}\n                coords = append(coords, coord)\n            }\n        }\n    }\n    sort.Slice(coords, func(i, j int) bool {\n        if coords[i][0] == coords[j][0] {\n            return coords[i][1] > coords[j][1]\n        }\n        return coords[i][0] < coords[j][0]\n    })\n    return coords\n}\n```",
            "```go\nfunc SortArray(arr []int) []int {\n    if len(arr) == 0 {\n        return arr\n    }\n    if (arr[0] + arr[len(arr)-1])%2 == 0 {\n        sort.Sort(sort.Reverse(sort.IntSlice(arr)))\n        return arr\n    } else {\n        sort.Ints(arr)\n        return arr\n    }\n}\n```",
            "```go\nfunc Encrypt(s string) string {\n    result := []byte{}\n    for _, ch := range s {\n        shifted := ch + 4\n        if shifted > 'z' {\n            shifted -= 26\n        }\n        result = append(result, byte(shifted))\n    }\n    return string(result)\n}\n```",
            "```go\nfunc NextSmallest(lst []int) *int {\n    set := make(map[int]struct{})\n    var sl []int\n\n    for _, num := range lst {\n        if _, found := set[num]; !found {\n            set[num] = struct{}{}\n            sl = append(sl, num)\n        }\n    }\n\n    sort.Ints(sl)\n\n    if len(sl) < 2 {\n        return nil\n    }\n\n    return new(int)\n}\n```",
            "```go\nfunc IsBored(s string) int {\n    sentences := strings.FieldsFunc(s, func(r rune) bool {\n        return r == '.' || r == '!' || r == '?'\n    })\n    count := 0\n    for _, sentence := range sentences {\n        if len(sentence) >= 2 && sentence[:2] == \"I \" {\n            count++\n        }\n    }\n    return count\n}\n```",
            "```go\nfunc AnyInt(x interface{}, y interface{}, z interface{}) bool {\n\tif intX, ok1 := x.(int); ok1 {\n\t\tif intY, ok2 := y.(int); ok2 {\n\t\t\tif intZ, ok3 := z.(int); ok3 {\n\t\t\t\treturn (intX+intY == intZ) || (intX+intZ == intY) || (intY+intZ == intX)\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}\n```",
            "```go\nfunc Encode(message string) string {\n\tvowels := \"aeiouAEIOU\"\n\tvar result []rune\n\tfor _, ch := range message {\n\t\tif unicode.IsLetter(ch) {\n\t\t\tch1 := ch\n\t\t\tif unicode.IsLower(ch) {\n\t\t\t\tch1 = unicode.ToUpper(ch)\n\t\t\t} else {\n\t\t\t\tch1 = unicode.ToLower(ch)\n\t\t\t}\n\t\t\tif strings.ContainsRune(vowels, ch1) {\n\t\t\t\tch1 += 2\n\t\t\t}\n\t\t\tresult = append(result, ch1)\n\t\t} else {\n\t\t\tresult = append(result, ch)\n\t\t}\n\t}\n\treturn string(result)\n}\n```",
            "```go\nfunc Skjkasdkd(lst []int) int {\n    primes := make([]int, 0)\n    for _, n := range lst {\n        if isPrime(n) {\n            primes = append(primes, n)\n        }\n    }\n    if len(primes) == 0 {\n        return 0\n    }\n    largest := fmt.Sprintf(\"%d\", max(primes))\n    sum := 0\n    for _, digit := range largest {\n        sum += int(digit - '0')\n    }\n    return sum\n}\n\nfunc isPrime(n int) bool {\n    if n < 2 {\n        return false\n    }\n    for i := 2; i <= int(math.Sqrt(float64(n))); i++ {\n        if n%i == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc max(nums []int) int {\n    maxVal := nums[0]\n    for _, num := range nums {\n        if num > maxVal {\n            maxVal = num\n        }\n    }\n    return maxVal\n}\n```",
            "```go\nfunc CheckDictCase(d map[string]string) bool {\n    if len(d) == 0 {\n        return false\n    }\n    allLower := true\n    allUpper := true\n    for k := range d {\n        for _, c := range k {\n            if !unicode.IsLower(c) {\n                allLower = false\n            }\n            if !unicode.IsUpper(c) {\n                allUpper = false\n            }\n        }\n    }\n    return allLower || allUpper\n}\n```",
            "```go\nfunc CountUpTo(n int) []int {\n    primes := []int{}\n    for num := 2; num < n; num++ {\n        isPrime := true\n        for _, p := range primes {\n            if num%p == 0 {\n                isPrime = false\n                break\n            }\n        }\n        if isPrime {\n            primes = append(primes, num)\n        }\n    }\n    return primes\n}\n```",
            "```go\nfunc Multiply(a int, b int) int {\n    return (abs(a) % 10) * (abs(b) % 10)\n}\n\nfunc abs(x int) int {\n    if x < 0 {\n        return -x\n    }\n    return x\n}\n```",
            "```go\nfunc CountUpper(s string) int {\n    vowels := \"AEIOU\"\n    count := 0\n    for i := 0; i < len(s); i++ {\n        c := s[i]\n        if i%2 == 0 && strings.IndexRune(vowels, rune(c)) != -1 {\n            count++\n        }\n    }\n    return count\n}\n```",
            "```go\nfunc ClosestInteger(value string) int {\n    num, _ := strconv.ParseFloat(value, 64)\n    if num >= 0 {\n        return int(num + 0.5)\n    } else {\n        return int(num - 0.5)\n    }\n}\n```",
            "```go\nfunc MakeAPile(n int) []int {\n    pile := make([]int, n)\n    for i := 0; i < n; i++ {\n        pile[i] = n + 2*i\n    }\n    return pile\n}\n```",
            "```go\nfunc WordsString(s string) []string {\n    re := regexp.MustCompile(`[, ]+`)\n    return re.Split(strings.TrimSpace(s), -1)\n}\n```",
            "```go\nfunc ChooseNum(x int, y int) int {\n    if x > y {\n        return -1\n    }\n    if y % 2 == 0 {\n        return y\n    }\n    return y - 1\n}\n```",
            "```go\nfunc RoundedAvg(n int, m int) *string {\n    if n > m {\n        return nil\n    }\n    rAvg := int((float64(m) + float64(n)) / 2.0 + 0.5)\n    binaryString := strconv.FormatInt(int64(rAvg), 2)\n    return &binaryString\n}\n```",
            "```go\nfunc UniqueDigits(x []int) []int {\n    result := make([]int, 0)\n    for _, num := range x {\n        if allDigitsOdd(num) {\n            result = append(result, num)\n        }\n    }\n    sort.Ints(result)\n    return result\n}\n\nfunc allDigitsOdd(n int) bool {\n    for n > 0 {\n        digit := n % 10\n        if digit%2 == 0 {\n            return false\n        }\n        n /= 10\n    }\n    return true\n}\n```",
            "```go\nfunc ByLength(arr []int) []string {\n    digitNames := []string{\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"}\n    var sortedArr []int\n    for _, x := range arr {\n        if x >= 1 && x <= 9 {\n            sortedArr = append(sortedArr, x)\n        }\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(sortedArr)))\n    result := make([]string, len(sortedArr))\n    for i, x := range sortedArr {\n        result[i] = digitNames[x-1]\n    }\n    return result\n}\n```",
            "```go\nfunc F(n int) []int {\n    nums := make([]int, n)\n    for i := range nums {\n        nums[i] = i + 1\n    }\n    result := make([]int, n)\n    for i := 0; i < n; i++ {\n        if i%2 != 0 {\n            sum := 0\n            for j := 0; j <= i; j++ {\n                sum += nums[j]\n            }\n            result[i] = sum\n        } else {\n            product := 1\n            for j := 0; j <= i; j++ {\n                product *= nums[j]\n            }\n            result[i] = product\n        }\n    }\n    return result\n}\n```",
            "```go\nfunc EvenOddPalindrome(n int) []int {\n    cnt := [2]int{0, 0}\n    for i := 1; i <= n; i++ {\n        if isPalindrome(fmt.Sprintf(\"%d\", i)) {\n            cnt[i%2]++\n        }\n    }\n    return cnt[:]\n}\n\nfunc isPalindrome(txt string) bool {\n    for i := 0; i < len(txt)/2; i++ {\n        if txt[i] != txt[len(txt)-1-i] {\n            return false\n        }\n    }\n    return true\n}\n```",
            "```go\nfunc DigitsSum(n int) int {\n    nStr := strconv.Itoa(n)\n    if n >= 0 {\n        sum := 0\n        for _, d := range nStr {\n            digit, _ := strconv.Atoi(string(d))\n            sum += digit\n        }\n        return sum\n    } else {\n        firstTwo, _ := strconv.Atoi(nStr[:2])\n        return firstTwo*2 + DigitsSum(abs(n))\n    }\n}\n\nfunc CountNums(arr []int) int {\n    count := 0\n    for _, n := range arr {\n        if DigitsSum(n) > 0 {\n            count++\n        }\n    }\n    return count\n}\n\nfunc abs(x int) int {\n    if x < 0 {\n        return -x\n    }\n    return x\n}\n```",
            "```go\nfunc MoveOneBall(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    sortedArr := make([]int, len(arr))\n    copy(sortedArr, arr)\n    sort.Ints(sortedArr)\n    for i := 0; i < len(arr); i++ {\n        if equalSubSlices(arr[i:], sortedArr[:len(arr)-i]) && equalSubSlices(arr[:i], sortedArr[len(arr)-i:]) {\n            return true\n        }\n    }\n    return false\n}\n\nfunc equalSubSlices(a, b []int) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    for i := range a {\n        if a[i] != b[i] {\n            return false\n        }\n    }\n    return true\n}\n```",
            "```go\nfunc CanExchange(lst1 []int, lst2 []int) string {\n    odd_cnt := 0\n    for _, num := range lst1 {\n        if num%2 != 0 {\n            odd_cnt++\n        }\n    }\n\n    even_cnt := 0\n    for _, num := range lst2 {\n        if num%2 == 0 {\n            even_cnt++\n        }\n    }\n\n    if even_cnt >= odd_cnt {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n```",
            "```go\nfunc Histogram(test string) map[string]int {\n    freq := make(map[string]int)\n    words := strings.Fields(test)\n    for _, w := range words {\n        if len(w) > 0 {\n            freq[w]++\n        }\n    }\n    result := make(map[string]int)\n    maxFreq := 0\n    for _, v := range freq {\n        if v > maxFreq {\n            maxFreq = v\n        }\n    }\n    for k, v := range freq {\n        if v == maxFreq {\n            result[k] = v\n        }\n    }\n    return result\n}\n```",
            "```go\nfunc ReverseDelete(s string, c string) []string {\n    resultString := \"\"\n    for _, ch := range s {\n        if !strings.ContainsRune(c, ch) {\n            resultString += string(ch)\n        }\n    }\n    palindromeCheck := reverse(resultString)\n    resultList := make([]string, 2)\n    resultList[0] = resultString\n    if resultString == palindromeCheck {\n        resultList[1] = \"yes\"\n    } else {\n        resultList[1] = \"no\"\n    }\n    return resultList\n}\n\nfunc reverse(s string) string {\n    runes := []rune(s)\n    for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\n        runes[i], runes[j] = runes[j], runes[i]\n    }\n    return string(runes)\n}\n```",
            "```go\nfunc OddCount(lst []string) []string {\n    result := []string{}\n    for _, num := range lst {\n        n := 0\n        for _, d := range num {\n            if d%2 == 1 {\n                n++\n            }\n        }\n        rs := \"the number of odd elements in the string i of the input.\"\n        result = append(result, strings.ReplaceAll(rs, \"i\", fmt.Sprintf(\"%d\", n)))\n    }\n    return result\n}\n```",
            "```go\nfunc MinSubArraySum(nums []int) int {\n    min_sum := 0\n    cur_sum := 0\n    for _, n := range nums {\n        if cur_sum+n < 0 {\n            cur_sum += n\n        } else {\n            cur_sum = 0\n        }\n        if cur_sum < min_sum {\n            min_sum = cur_sum\n        }\n    }\n    if min_sum == 0 {\n        min_sum = nums[0]\n        for _, n := range nums[1:] {\n            if n < min_sum {\n                min_sum = n\n            }\n        }\n    }\n    return min_sum\n}\n```",
            "```go\nfunc MaxFill(grid [][]int, capacity int) int {\n    total := 0\n    for _, arr := range grid {\n        sum := 0\n        for _, num := range arr {\n            sum += num\n        }\n        total += int(math.Ceil(float64(sum) / float64(capacity)))\n    }\n    return total\n}\n```",
            "```go\nfunc countOnes(num int) int {\n    count := 0\n    for num > 0 {\n        count += num & 1\n        num >>= 1\n    }\n    return count\n}\n\nfunc SortArray(arr []int) []int {\n    sort.SliceStable(arr, func(i, j int) bool {\n        if countOnes(arr[i]) == countOnes(arr[j]) {\n            return arr[i] < arr[j]\n        }\n        return countOnes(arr[i]) < countOnes(arr[j])\n    })\n    return arr\n}\n```",
            "```go\nfunc SelectWords(s string, n int) []string {\n    consonants := \"bcdfghjklmnpqrstvwxyz\"\n    words := strings.Fields(s)\n    var result []string\n    for _, w := range words {\n        vowelCount := 0\n        for _, c := range strings.ToLower(w) {\n            if strings.ContainsRune(consonants, c) {\n                vowelCount++\n            }\n        }\n        if vowelCount == n {\n            result = append(result, w)\n        }\n    }\n    return result\n}\n```",
            "```go\nfunc GetClosestVowel(word string) string {\n\tvowels := \"aeiouAEIOU\"\n\tfor i := len(word) - 2; i > 0; i-- {\n\t\tif strings.ContainsRune(vowels, rune(word[i])) && !strings.ContainsRune(vowels, rune(word[i-1])) && !strings.ContainsRune(vowels, rune(word[i+1])) {\n\t\t\treturn string(word[i])\n\t\t}\n\t}\n\treturn \"\"\n}\n```",
            "```go\nfunc MatchParens(lst []string) string {\n    s1 := lst[0] + lst[1]\n    s2 := lst[1] + lst[0]\n    if check(s1) || check(s2) {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc check(s string) bool {\n    depth := 0\n    for _, ch := range s {\n        if ch == '(' {\n            depth += 1\n        } else {\n            depth -= 1\n        }\n        if depth < 0 {\n            return false\n        }\n    }\n    return depth == 0\n}\n```",
            "```go\nfunc Maximum(arr []int, k int) []int {\n        if k == 0 {\n                return []int{}\n        }\n        sort.Ints(arr)\n        n := len(arr)\n        return arr[n-k:]\n}\n```",
            "```go\nfunc Solution(lst []int) int {\n    sum := 0\n    for i := 0; i < len(lst); i++ {\n        if i%2 == 0 && lst[i]%2 != 0 {\n            sum += lst[i]\n        }\n    }\n    return sum\n}\n```",
            "```go\nfunc AddElements(arr []int, k int) int {\n    sum := 0\n    for i := 0; i < min(k, len(arr)); i++ {\n        if len(fmt.Sprintf(\"%d\", arr[i])) <= 2 {\n            sum += arr[i]\n        }\n    }\n    return sum\n}\n\nfunc min(a, b int) int {\n    if a < b {\n        return a\n    }\n    return b\n}\n```",
            "```go\nfunc GetOddCollatz(n int) []int {\n    collatz := []int{1}\n    for n != 1 {\n        if n%2 != 0 {\n            collatz = append(collatz, n)\n            n = 3*n + 1\n        } else {\n            n /= 2\n        }\n    }\n    return sortInts(collatz)\n}\n\nfunc sortInts(a []int) []int {\n    sort.Slice(a, func(i, j int) bool { return a[i] < a[j] })\n    return a\n}\n```",
            "```go\nfunc ValidDate(date string) bool {\n    if len(date) != 10 || date[2] != '-' || date[5] != '-' {\n        return false\n    }\n    m, _ := strconv.Atoi(date[:2])\n    d, _ := strconv.Atoi(date[3:5])\n    if (m == 1 || m == 3 || m == 5 || m == 7 || m == 8 || m == 10 || m == 12) && d >= 1 && d <= 31 {\n        return true\n    }\n    if (m == 4 || m == 6 || m == 9 || m == 11) && d >= 1 && d <= 30 {\n        return true\n    }\n    if m == 2 && d >= 1 && d <= 29 {\n        return true\n    }\n    return false\n}\n```",
            "```go\nfunc SplitWords(txt string) []string {\n    if strings.Contains(txt, \" \") {\n        return strings.Split(txt, \" \")\n    } else if strings.Contains(txt, \",\") {\n        return strings.Split(txt, \",\")\n    } else {\n        var count int\n        for _, c := range txt {\n            if unicode.IsLower(c) && int(c)%2 == 0 {\n                count++\n            }\n        }\n        return []string{strconv.Itoa(count)}\n    }\n}\n```",
            "```go\nfunc IsSorted(lst []int) bool {\n    if len(lst) < 2 {\n        return true\n    }\n    for i := 1; i < len(lst); i++ {\n        if lst[i-1] > lst[i] {\n            return false\n        }\n    }\n    freq := make(map[int]int)\n    for _, num := range lst {\n        freq[num]++\n    }\n    maxFreq := 0\n    for _, count := range freq {\n        if count > maxFreq {\n            maxFreq = count\n        }\n    }\n    return maxFreq <= 2\n}\n```",
            "```go\nfunc Intersection(interval1 []int, interval2 []int) string {\n\tl := max(interval1[0], interval2[0])\n\tr := min(interval1[1], interval2[1])\n\tlength := r - l\n\tif isPrime(length) && length > 0 {\n\t\treturn \"YES\"\n\t}\n\treturn \"NO\"\n}\n\nfunc isPrime(n int) bool {\n\tif n < 2 {\n\t\treturn false\n\t}\n\tfor i := 2; i <= int(math.Sqrt(float64(n))); i++ {\n\t\tif n%i == 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n```",
            "```go\nfunc ProdSigns(arr []int) *int {\n    if len(arr) == 0 {\n        return nil\n    }\n    for _, n := range arr {\n        if n == 0 {\n            result := 0\n            return &result\n        }\n    }\n    var countNegatives int\n    for _, n := range arr {\n        if n < 0 {\n            countNegatives++\n        }\n    }\n    sign := 1\n    if countNegatives%2 == 1 {\n        sign = -1\n    }\n    sumAbsValues := 0\n    for _, n := range arr {\n        sumAbsValues += abs(n)\n    }\n    result := sign * sumAbsValues\n    return &result\n}\n\nfunc abs(x int) int {\n    if x < 0 {\n        return -x\n    }\n    return x\n}\n```",
            "```go\nfunc MinPath(grid [][]int, k int) []int {\n    n := len(grid)\n    minVal := n*n + 1\n    for i := 0; i < n; i++ {\n        for j := 0; j < n; j++ {\n            if grid[i][j] == 1 {\n                temp := []int{}\n                if i != 0 {\n                    temp = append(temp, grid[i-1][j])\n                }\n                if j != 0 {\n                    temp = append(temp, grid[i][j-1])\n                }\n                if i != n-1 {\n                    temp = append(temp, grid[i+1][j])\n                }\n                if j != n-1 {\n                    temp = append(temp, grid[i][j+1])\n                }\n                for _, val := range temp {\n                    if val < minVal {\n                        minVal = val\n                    }\n                }\n            }\n        }\n    }\n    result := make([]int, k)\n    for i := 0; i < k; i++ {\n        if i%2 == 0 {\n            result[i] = 1\n        } else {\n            result[i] = minVal\n        }\n    }\n    return result\n}\n```",
            "```go\nfunc Tri(n int) []int {\n    if n == 0 {\n        return []int{1}\n    }\n    seq := []int{1, 3}\n    for i := 2; i <= n; i++ {\n        if i%2 == 0 {\n            seq = append(seq, i/2+1)\n        } else {\n            nextValue := seq[i-1] + seq[i-2] + (i+3)/2\n            seq = append(seq, nextValue)\n        }\n    }\n    return seq\n}\n```",
            "```go\nfunc Digits(n int) int {\n    numStr := fmt.Sprintf(\"%d\", n)\n    product := 1\n    hasOddDigit := false\n    \n    for _, c := range numStr {\n        digit := int(c - '0')\n        if digit%2 == 1 {\n            product *= digit\n            hasOddDigit = true\n        }\n    }\n    \n    if hasOddDigit {\n        return product\n    }\n    return 0\n}\n```",
            "```go\nfunc IsNested(s string) bool {\n    openIdx := []int{}\n    closeIdx := []int{}\n    for i := 0; i < len(s); i++ {\n        ch := s[i]\n        if ch == '[' {\n            openIdx = append(openIdx, i)\n        } else if ch == ']' {\n            closeIdx = append(closeIdx, i)\n        }\n    }\n    l := len(closeIdx)\n    for j := 0; j < l/2; j++ {\n        closeIdx[j], closeIdx[l-1-j] = closeIdx[l-1-j], closeIdx[j]\n    }\n    cnt := 0\n    i := 0\n    for _, idx := range openIdx {\n        if i < len(closeIdx) && idx < closeIdx[i] {\n            cnt++\n            i++\n        }\n    }\n    return cnt >= 2\n}\n```",
            "```go\nfunc SumSquares(lst []float64) int {\n    sum := 0\n    for _, n := range lst {\n        ceilN := math.Ceil(n)\n        sum += int(ceilN * ceilN)\n    }\n    return sum\n}\n```",
            "```go\nfunc CheckIfLastCharIsALetter(txt string) bool {\n    if txt == \"\" {\n        return false\n    }\n    lastSpaceIndex := strings.LastIndex(txt, \" \")\n    lastPart := txt[lastSpaceIndex+1:]\n    return len(lastPart) == 1 && unicode.IsLetter(rune(lastPart[0]))\n}\n```",
            "```go\nfunc CanArrange(arr []int) int {\n    if len(arr) <= 1 {\n        return -1\n    }\n    idx := -1\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < arr[i-1] {\n            idx = i\n        }\n    }\n    return idx\n}\n```",
            "```go\nfunc LargestSmallestIntegers(lst []int) []*int {\n    var neg []int\n    var pos []int\n    \n    for _, i := range lst {\n        if i < 0 {\n            neg = append(neg, i)\n        } else if i > 0 {\n            pos = append(pos, i)\n        }\n    }\n    \n    var maxNeg *int\n    if len(neg) > 0 {\n        maxNeg = new(int)\n        *maxNeg = neg[0]\n        for _, n := range neg {\n            if n > *maxNeg {\n                *maxNeg = n\n            }\n        }\n    }\n    \n    var minPos *int\n    if len(pos) > 0 {\n        minPos = new(int)\n        *minPos = pos[0]\n        for _, p := range pos {\n            if p < *minPos {\n                *minPos = p\n            }\n        }\n    }\n    \n    return []*int{maxNeg, minPos}\n}\n```",
            "```go\nfunc CompareOne(a interface{}, b interface{}) *float64 {\n    a1 := anyToReal(a)\n    b1 := anyToReal(b)\n    if a1 == b1 {\n        return nil\n    } else if a1 > b1 {\n        return &a1\n    } else {\n        return &b1\n    }\n}\n\nfunc anyToReal(o interface{}) float64 {\n    switch v := o.(type) {\n    case string:\n        f, _ := strconv.ParseFloat(strings.Replace(v, \",\", \".\", -1), 64)\n        return f\n    case int:\n        return float64(v)\n    case float64:\n        return v\n    default:\n        panic(\"Type Error\")\n    }\n}\n```",
            "```go\nfunc IsEqualToSumEven(n int) bool {\n    return n%2 == 0 && n >= 8\n}\n```",
            "```go\nfunc SpecialFactorial(n int) int {\n    fact := 1\n    result := 1\n    for i := 1; i <= n; i++ {\n        fact *= i\n        result *= fact\n    }\n    return result\n}\n```",
            "```go\nfunc FixSpaces(txt string) string {\n    return strings.ReplaceAll(strings.ReplaceAll(txt, \"   \", \"-\"), \" \", \"_\")\n}\n```",
            "```go\nfunc FileNameCheck(fileName string) string {\n    suf := []string{\"txt\", \"exe\", \"dll\"}\n    lst := strings.Split(fileName, \".\")\n    \n    if len(lst) != 2 || !slices.Contains(suf, lst[1]) || lst[0] == \"\" || !unicode.IsLetter(rune(lst[0][0])) || countDigits(lst[0]) > 3 {\n        return \"No\"\n    }\n    \n    return \"Yes\"\n}\n\nfunc countDigits(s string) int {\n    count := 0\n    for _, char := range s {\n        if unicode.IsDigit(char) {\n            count++\n        }\n    }\n    return count\n}\n```",
            "```go\nfunc SumSquares(lst []int) int {\n    result := 0\n    for i := 0; i < len(lst); i++ {\n        if i % 3 == 0 {\n            result += lst[i] * lst[i]\n        } else if i % 4 == 0 {\n            result += lst[i] * lst[i] * lst[i]\n        } else {\n            result += lst[i]\n        }\n    }\n    return result\n}\n```",
            "```go\nfunc WordsInSentence(sentence string) string {\n    words := strings.Split(sentence, \" \")\n    var result []string\n    for _, w := range words {\n        if isPrime(len(w)) {\n            result = append(result, w)\n        }\n    }\n    return strings.Join(result, \" \")\n}\n\nfunc isPrime(n int) bool {\n    if n < 2 {\n        return false\n    }\n    for i := 2; i <= int(math.Sqrt(float64(n))); i++ {\n        if n%i == 0 {\n            return false\n        }\n    }\n    return true\n}\n```",
            "```go\nfunc Simplify(x string, n string) bool {\n    xs := strings.Split(x, \"/\")\n    ns := strings.Split(n, \"/\")\n    num, _ := strconv.Atoi(xs[0])\n    den, _ := strconv.Atoi(ns[0]) * strconv.Atoi(xs[1]) * strconv.Atoi(ns[1])\n    return num % den == 0\n}\n```",
            "```go\nfunc digitsSum(n int) int {\n    if n >= 0 {\n        sum := 0\n        for n > 0 {\n            sum += n % 10\n            n /= 10\n        }\n        return sum\n    } else {\n        negativePart := ((n / 100) * -2)\n        positivePart := digitsSum(abs(n))\n        return negativePart + positivePart\n    }\n}\n\nfunc OrderByPoints(nums []int) []int {\n    sort.Slice(nums, func(i, j int) bool {\n        return digitsSum(nums[i]) < digitsSum(nums[j])\n    })\n    return nums\n}\n```",
            "```go\nfunc SpecialFilter(nums []int) int {\n    odds := \"13579\"\n    count := 0\n    for _, n := range nums {\n        if n > 10 && n%2 == 1 && strings.ContainsRune(odds, rune(n/100%10+'0')) {\n            count++\n        }\n    }\n    return count\n}\n```",
            "```go\nfunc GetMaxTriples(n int) int {\n    c := [3]int{0, 0, 0}\n    for i := 1; i <= n; i++ {\n        a := i*i - i + 1\n        c[a%3]++\n    }\n    return c[0]*c[1]*c[2] + (c[0]*(c[0]-1)*(c[0]-2) + c[1]*(c[1]-1)*(c[1]-2) + c[2]*(c[2]-1)*(c[2]-2)) / 6\n}\n```",
            "```go\nfunc Bf(planet1 string, planet2 string) []string {\n    names := []string{\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    l := -1\n    r := -1\n    \n    for i, name := range names {\n        if name == planet1 {\n            l = i\n        }\n        if name == planet2 {\n            r = i\n        }\n    }\n    \n    if l == -1 || r == -1 || l == r {\n        return []string{}\n    }\n    \n    if l > r {\n        l, r = r, l\n    }\n    \n    return names[l+1 : r]\n}\n```",
            "```go\nfunc SortedListSum(lst []string) []string {\n    result := []string{}\n    for _, s := range lst {\n        if len(s)%2 == 0 {\n            result = append(result, s)\n        }\n    }\n    sort.Slice(result, func(i, j int) bool {\n        if len(result[i]) != len(result[j]) {\n            return len(result[i]) < len(result[j])\n        }\n        return result[i] < result[j]\n    })\n    return result\n}\n```",
            "```go\nfunc XOrY(n int, x int, y int) int {\n    if n < 2 {\n        return y\n    }\n    for i := 2; i <= int(math.Sqrt(float64(n))); i++ {\n        if n%i == 0 {\n            return y\n        }\n    }\n    return x\n}\n```",
            "```go\nfunc DoubleTheDifference(lst []float64) int {\n    sum := 0.0\n    for _, n := range lst {\n        if n >= 0 && n == math.Floor(n) && int(n)%2 == 1 {\n            sum += n * n\n        }\n    }\n    return int(sum)\n}\n```",
            "```go\nfunc Compare(game []int, guess []int) []int {\n    result := make([]int, len(game))\n    for i := range game {\n        result[i] = abs(game[i] - guess[i])\n    }\n    return result\n}\n\nfunc abs(x int) int {\n    if x < 0 {\n        return -x\n    }\n    return x\n}\n```",
            "```go\nfunc StrongestExtension(className string, extensions []string) string {\n    max_s := math.MinInt32\n    var max_ext string\n    for _, ext := range extensions {\n        upper := 0\n        lower := 0\n        for _, c := range ext {\n            if unicode.IsUpper(c) {\n                upper++\n            } else if unicode.IsLower(c) {\n                lower++\n            }\n        }\n        s := upper - lower\n        if s > max_s {\n            max_s = s\n            max_ext = ext\n        }\n    }\n    return className + \".\" + max_ext\n}\n```",
            "```go\nfunc CycpatternCheck(a string, b string) bool {\n    if len(a) < len(b) {\n        return false\n    }\n    for i := 0; i < len(b); i++ {\n        rotatedB := b[i:] + b[:i]\n        if strings.Contains(a, rotatedB) {\n            return true\n        }\n    }\n    return false\n}\n```",
            "```go\nfunc EvenOddCount(num int) []int {\n    ds := num\n    if ds < 0 {\n        ds = -ds\n    }\n    even := 0\n    for ds > 0 {\n        d := ds % 10\n        if d%2 == 0 {\n            even++\n        }\n        ds /= 10\n    }\n    return []int{even, len(fmt.Sprintf(\"%d\", num)) - even}\n}\n```",
            "```go\nfunc IntToMiniRoman(num int) string {\n    values := []int{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}\n    numerals := []string{\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"}\n    var res strings.Builder\n    for i := 0; i < len(values); i++ {\n        for num >= values[i] {\n            res.WriteString(numerals[i])\n            num -= values[i]\n        }\n    }\n    return res.String()\n}\n```",
            "```go\nfunc RightAngleTriangle(a int, b int, c int) bool {\n    s := []int{a, b, c}\n    if s[0] > s[2] {\n        s[0], s[2] = s[2], s[0]\n    }\n    if s[1] > s[2] {\n        s[1], s[2] = s[2], s[1]\n    }\n    return s[0]*s[0]+s[1]*s[1] == s[2]*s[2]\n}\n```",
            "```go\nfunc FindMax(words []string) string {\n    maxCnt := 0\n    maxW := \"\"\n    for _, w := range words {\n        uniqueChars := make(map[rune]bool)\n        for _, c := range w {\n            uniqueChars[c] = true\n        }\n        cnt := len(uniqueChars)\n        if cnt > maxCnt {\n            maxCnt = cnt\n            maxW = w\n        } else if cnt == maxCnt {\n            if w < maxW {\n                maxW = w\n            }\n        }\n    }\n    return maxW\n}\n```",
            "```go\nfunc Eat(num int, need int, remaining int) []int {\n    if need <= remaining {\n        return []int{num + need, remaining - need}\n    } else {\n        return []int{num + remaining, 0}\n    }\n}\n```",
            "```go\nfunc DoAlgebra(operators []string, operands []int) int {\n    ops := make([]string, len(operators))\n    nums := make([]int, len(operands))\n    copy(ops, operators)\n    copy(nums, operands)\n    i := len(ops) - 1\n    for i >= 0 {\n        if ops[i] == \"**\" {\n            nums[i] = int(math.Pow(float64(nums[i]), float64(nums[i+1])))\n            nums = append(nums[:i+1], nums[i+2:]...)\n            ops = append(ops[:i], ops[i+1:]...)\n        }\n        i--\n    }\n    i = 0\n    for i < len(ops) {\n        if ops[i] == \"*\" {\n            nums[i] *= nums[i+1]\n            nums = append(nums[:i+1], nums[i+2:]...)\n            ops = append(ops[:i], ops[i+1:]...)\n            i--\n        } else if ops[i] == \"//\" {\n            nums[i] /= nums[i+1]\n            nums = append(nums[:i+1], nums[i+2:]...)\n            ops = append(ops[:i], ops[i+1:]...)\n            i--\n        }\n        i++\n    }\n    i = 0\n    for i < len(ops) {\n        if ops[i] == \"+\" {\n            nums[i] += nums[i+1]\n            nums = append(nums[:i+1], nums[i+2:]...)\n            ops = append(ops[:i], ops[i+1:]...)\n            i--\n        } else if ops[i] == \"-\" {\n            nums[i] -= nums[i+1]\n            nums = append(nums[:i+1], nums[i+2:]...)\n            ops = append(ops[:i], ops[i+1:]...)\n            i--\n        }\n        i++\n    }\n    return nums[0]\n}\n```",
            "```go\nfunc Solve(s string) string {\n    hasLetter := false\n    for _, ch := range s {\n        if unicode.IsLetter(ch) {\n            hasLetter = true\n            break\n        }\n    }\n    if !hasLetter {\n       \trunes := []rune(s)\n\t\tfor i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\n\t\t\trunes[i], runes[j] = runes[j], runes[i]\n\t\t}\n        return string(runes)\n    }\n    var result []rune\n    for _, ch := range s {\n        if !unicode.IsLetter(ch) {\n            result = append(result, ch)\n        } else if unicode.IsUpper(ch) {\n            result = append(result, unicode.ToLower(ch))\n        } else if unicode.IsLower(ch) {\n            result = append(result, unicode.ToUpper(ch))\n        }\n    }\n    return string(result)\n}\n```",
            "```go\nfunc StringToMd5(txt string) *string {\n    if txt == \"\" {\n        return nil\n    }\n    md5Hash := md5.New()\n    txtBytes := []byte(txt)\n    md5Hash.Write(txtBytes)\n    md5Encoded := hex.EncodeToString(md5Hash.Sum(nil))\n    return &md5Encoded\n}\n```",
            "```go\nfunc GenerateIntegers(a int, b int) []int {\n    lower := max(2, min(a, b))\n    upper := min(8, max(a, b))\n    var result []int\n    for i := lower; i <= upper; i++ {\n        if i%2 == 0 {\n            result = append(result, i)\n        }\n    }\n    return result\n}\n\nfunc min(x int, y int) int {\n    if x < y {\n        return x\n    }\n    return y\n}\n\nfunc max(x int, y int) int {\n    if x > y {\n        return x\n    }\n    return y\n}\n```"
        ],
        "ruby": [
            "```ruby\ndef has_close_elements(numbers, threshold)\n    (0...numbers.size).each do |i|\n        ((i + 1)...numbers.size).each do |j|\n            return true if (numbers[i] - numbers[j]).abs < threshold\n        end\n    end\n    false\nend\n```",
            "```ruby\n# @param paren_string [String]\n# @returns {Array<String>}\ndef separate_paren_groups(paren_string)\n    groups = []\n    stk = []\n    current_group = \"\"\n    parens = paren_string.gsub(\" \", \"\")\n    parens.each_char do |ch|\n        if ch == \"(\"\n            stk.push(ch)\n            current_group += ch\n        elsif ch == \")\"\n            stk.pop\n            current_group += ch\n            if stk.empty?\n                groups.push(current_group)\n                current_group = \"\"\n            end\n        end\n    end\n    groups\nend\n```",
            "```ruby\n# @param num [Float]\n# @return {Float}\ndef truncate_number(num)\n    num - num.floor\nend\n```",
            "```ruby\n# @param operations [Array<Integer>]\n# @returns {Boolean}\ndef below_zero(operations)\n  balance = 0\n  operations.each do |op|\n    balance += op\n    return true if balance < 0\n  end\n  false\nend\n```",
            "```ruby\ndef mean_absolute_deviation(numbers)\n    sum = 0.0\n    numbers.each do |num|\n        sum += num\n    end\n    mean = sum / numbers.size\n    \n    deviation_sum = 0.0\n    numbers.each do |num|\n        deviation_sum += (num - mean).abs\n    end\n    \n    return deviation_sum / numbers.size\nend\n```",
            "```ruby\ndef intersperse(numbers, delimiter)\n    result = []\n    numbers.each_with_index do |num, index|\n        result << delimiter if index > 0\n        result << num\n    end\n    result\nend\n```",
            "```ruby\ndef parse_nested_parens(paren_string)\n    result = []\n    paren_groups = paren_string.split(\" \")\n    paren_groups.each do |group|\n        max_depth = 0\n        depth = 0\n        group.each_char do |ch|\n            if ch == '('\n                depth += 1\n                max_depth = [max_depth, depth].max\n            elsif ch == ')'\n                depth -= 1\n            end\n        end\n        result << max_depth\n    end\n    result\nend\n```",
            "```ruby\ndef filter_by_substring(strs, substring)\n    strs.select { |s| s.include?(substring) }\nend\n```",
            "```ruby\ndef sum_product(numbers)\n  n_sum = numbers.sum\n  n_product = numbers.reduce(1) { |x, y| x * y }\n  [n_sum, n_product]\nend\n```",
            "```ruby\n# @param numbers [Array<Integer>]\n# @returns {Array<Integer>}\ndef rolling_max(numbers)\n    max_so_far = -Float::INFINITY\n    result = []\n    numbers.each do |num|\n        max_so_far = [max_so_far, num].max\n        result << max_so_far\n    end\n    result\nend\n```",
            "```ruby\ndef make_palindrome(s)\n    if is_palindrome?(s)\n        return s\n    end\n    for i in 0...s.length\n        if is_palindrome?(s[i..-1])\n            prefix = s[0, i].reverse\n            return s + prefix\n        end\n    end\n    return \"\"\nend\n\ndef is_palindrome?(s)\n    left = 0\n    right = s.length - 1\n    while left < right\n        if s[left] != s[right]\n            return false\n        end\n        left += 1\n        right -= 1\n    end\n    return true\nend\n```",
            "```ruby\n# @param a [String]\n# @param b [String]\n# @returns {String}\ndef string_xor(a, b)\n    result = \"\"\n    (0...[a.length, b.length].min).each do |i|\n        x = a[i]\n        y = b[i]\n        result += (x == y) ? \"0\" : \"1\"\n    end\n    result\nend\n```",
            "```ruby\n# @param strs [Array<String>]\n# @returns {String, nil}\ndef longest(strs)\n    return nil if strs.empty?\n    longest_s = strs[0]\n    strs.each do |s|\n        longest_s = s if s.length > longest_s.length\n    end\n    longest_s\nend\n```",
            "```ruby\ndef greatest_common_divisor(a, b)\n    if b == 0\n        return a\n    else\n        return greatest_common_divisor(b, a % b)\n    end\nend\n```",
            "```ruby\ndef all_prefixes(s)\n    prefixes = []\n    (0...s.length).each do |i|\n        prefixes << s[0..i]\n    end\n    prefixes\nend\n```",
            "```ruby\n# @param n [Integer]\n# @returns {String}\ndef string_sequence(n)\n    result = \"\"\n    for i in 0..n do\n        result += i.to_s\n        result += \" \" if i < n\n    end\n    result\nend\n```",
            "```ruby\ndef count_distinct_characters(s)\n    s.downcase.chars.uniq.count\nend\n```",
            "```ruby\ndef parse_music(music_string)\n    durations = {\"o\" => 4, \"o|\" => 2, \".|\" => 1}\n    notes = music_string.split\n    notes.map { |note| durations[note] }\nend\n```",
            "```ruby\ndef how_many_times(s, substring)\n    times = 0\n    (0..s.length - substring.length).each do |i|\n        if s[i, substring.length] == substring\n            times += 1\n        end\n    end\n    times\nend\n```",
            "```ruby\ndef sort_numbers(numbers)\n    num_dict = {\n        \"zero\" => 0,\n        \"one\" => 1,\n        \"two\" => 2,\n        \"three\" => 3,\n        \"four\" => 4,\n        \"five\" => 5,\n        \"six\" => 6,\n        \"seven\" => 7,\n        \"eight\" => 8,\n        \"nine\" => 9\n    }\n\n    num_list = numbers.split(\" \").select { |num| num_dict.key?(num) }\n    num_list.sort_by! { |num| num_dict[num] }\n\n    num_list.join(\" \")\nend\n```",
            "```ruby\ndef find_closest_elements(numbers)\n  sorted_numbers = numbers.sort\n  min_diff = Float::INFINITY\n  closest_pair = []\n  \n  (1...sorted_numbers.length).each do |i|\n    diff = sorted_numbers[i] - sorted_numbers[i - 1]\n    if diff < min_diff\n      min_diff = diff\n      closest_pair = [sorted_numbers[i - 1], sorted_numbers[i]]\n    end\n  end\n  \n  closest_pair\nend\n```",
            "```ruby\ndef rescale_to_unit(numbers)\n    min_num = numbers.min\n    max_num = numbers.max\n    if min_num == max_num\n        return Array.new(numbers.size, 0.0)\n    else\n        result = []\n        numbers.each do |num|\n            result << (num - min_num) / (max_num - min_num)\n        end\n        return result\n    end\nend\n```",
            "```ruby\n# @param values [Array<Object>]\n# @return {Array<Integer>}\ndef filter_integers(values)\n    values.select { |x| x.is_a?(Integer) }\nend\n```",
            "```ruby\n# @param s [String]\n# @returns {Integer}\ndef str_length(s)\n    s.length\nend\n```",
            "```ruby\ndef largest_divisor(n)\n    (2...n).each do |i|\n        if n % i == 0\n            return n / i\n        end\n    end\n    return 1\nend\n```",
            "```ruby\ndef factorize(n)\n    factors = []\n    divisor = 2\n    while divisor <= n\n        if n % divisor == 0\n            factors << divisor\n            n /= divisor\n        else\n            divisor += 1\n        end\n    end\n    factors\nend\n```",
            "```ruby\n# @param numbers [Array<Integer>]\n# @returns {Array<Integer>}\ndef remove_duplicates(numbers)\n    counts = Hash.new(0)\n    numbers.each do |num|\n        counts[num] += 1\n    end\n    res = []\n    numbers.each do |num|\n        if counts[num] == 1\n            res << num\n        end\n    end\n    res\nend\n```",
            "```ruby\n# @param s [String]\n# @returns {String}\ndef flip_case(s)\n    flipped = \"\"\n    s.each_char do |ch|\n        if !ch.match?(/[a-zA-Z]/)\n            flipped << ch\n        elsif ch == ch.downcase\n            flipped << ch.upcase\n        else\n            flipped << ch.downcase\n        end\n    end\n    flipped\nend\n```",
            "```ruby\ndef concatenate(strs)\n  result = \"\"\n  strs.each do |str|\n    result << str\n  end\n  result\nend\n```",
            "```ruby\ndef filter_by_prefix(strs, prefix_str)\n    strs.select { |s| s.start_with?(prefix_str) }\nend\n```",
            "```ruby\ndef get_positive(l)\n    l.select { |num| num > 0 }\nend\n```",
            "```ruby\n# @param n [Integer]\n# @returns {Boolean}\ndef is_prime(n)\n    return false if n < 2\n    (2..Math.sqrt(n)).each do |i|\n        return false if n % i == 0\n    end\n    true\nend\n```",
            "```ruby\ndef poly(xs, x)\n    res = 0.0\n    (0...xs.size).each do |i|\n        res += xs[i] * x**i\n    end\n    res\nend\n\n# @param xs [Array<Integer>]\n# @returns {Float}\ndef find_zero(xs)\n    x1, x2 = 1.0, -1.0\n    while poly(xs, x1) * poly(xs, x2) > 0\n        x1 *= 2\n        x2 *= 2\n    end\n    while (x1 - x2).abs > 1e-10\n        mid = (x1 + x2) / 2.0\n        if poly(xs, mid).abs < 1e-10\n            return mid\n        elsif poly(xs, mid) * poly(xs, x1) < 0\n            x2 = mid\n        else\n            x1 = mid\n        end\n    end\n    (x1 + x2) / 2.0\nend\n```",
            "```ruby\ndef sort_third(l)\n  sorted_third = l.select.with_index { |_, i| i % 3 == 0 }.sort\n  l.map.with_index { |e, i| i % 3 == 0 ? sorted_third[i / 3] : e }\nend\n```",
            "```ruby\ndef list_unique(l)\n    set = l.uniq\n    sorted_list = set.sort\n    sorted_list\nend\n```",
            "```ruby\ndef max_element(l)\n    return 0 if l.empty?\n    l.max\nend\n```",
            "```ruby\ndef fizz_buzz(n)\n    cnt = 0\n    (0...n).each do |i|\n        if i % 11 == 0 || i % 13 == 0\n            str = i.to_s\n            str.each_char do |c|\n                cnt += 1 if c == '7'\n            end\n        end\n    end\n    cnt\nend\n```",
            "```ruby\ndef sort_even(l)\n  sorted_even = l.select.with_index { |_, index| index.even? }.sort\n  l.map.with_index { |value, index| index.even? ? sorted_even[index / 2] : value }\nend\n```",
            "```ruby\n# @param s [String]\n# @return [String]\ndef encode_cyclic(s)\n    result = []\n    (0...s.length).step(3) do |i|\n        if i + 3 > s.length\n            result << s[i..-1]\n        else\n            result << s[i+1, 2] + s[i]\n        end\n    end\n    result.join\nend\n\n# @param s [String]\n# @return [String]\ndef decode_cyclic(s)\n    encode_cyclic(encode_cyclic(s))\nend\n```",
            "```ruby\ndef prime_fib(n)\n    f = [0, 1]\n    cnt = 0\n    while cnt < n\n        f = [f[1], f[0] + f[1]]\n        if is_prime(f[1])\n            cnt += 1\n        end\n    end\n    f[1]\nend\n\ndef is_prime(n)\n    return false if n < 2\n    (2..Math.sqrt(n)).each do |i|\n        return false if n % i == 0\n    end\n    true\nend\n```",
            "```ruby\ndef triples_sum_to_zero(l)\n    (0...l.size).each do |i|\n        ((i + 1)...l.size).each do |j|\n            ((j + 1)...l.size).each do |k|\n                return true if l[i] + l[j] + l[k] == 0\n            end\n        end\n    end\n    false\nend\n```",
            "```ruby\n# @param n [Integer]\n# @return [Integer]\ndef car_race_collision(n)\n    n * n\nend\n```\n",
            "```ruby\ndef incr_list(l)\n  result = []\n  l.each do |i|\n    result << i + 1\n  end\n  result\nend\n```",
            "```ruby\ndef pairs_sum_to_zero(l)\n    seen = Set.new\n    l.each do |num|\n        return true if seen.include?(-num)\n        seen.add(num)\n    end\n    false\nend\n```",
            "```ruby\n# @param x [Integer]\n# @param bas [Integer]\n# @returns {String}\ndef change_base(x, bas)\n    if x == 0\n        return \"0\"\n    end\n    digits = []\n    while x > 0\n        digits << (x % bas)\n        x /= bas\n    end\n    digits.reverse.join.to_s\nend\n```",
            "```ruby\n# @param a [Integer]\n# @param h [Integer]\n# @returns {Float}\ndef triangle_area(a, h)\n    (a.to_f * h) / 2\nend\n```",
            "```ruby\ndef fib4(n)\n    fib = [0, 0, 2, 0]\n    for i in 4..n\n        fib[i % 4] = fib[0] + fib[1] + fib[2] + fib[3]\n    end\n    return fib[n % 4]\nend\n```",
            "```ruby\n# @param l [Array<Float>]\n# @returns {Float}\ndef median(l)\n    sl = l.sort\n    if sl.length.odd?\n        return sl[sl.length / 2]\n    else\n        return (sl[sl.length / 2] + sl[sl.length / 2 - 1]) / 2.0\n    end\nend\n```",
            "```ruby\n# @param txt [String]\n# @returns {Boolean}\ndef is_palindrome(txt)\n    n = txt.length\n    (0...n/2).each do |i|\n        return false if txt[i] != txt[n - 1 - i]\n    end\n    true\nend\n```",
            "```ruby\n# @param n [Integer]\n# @param p [Integer]\n# @return [Integer]\ndef modp(n, p)\n    ret = 1\n    n.times do |i|\n        ret = (ret * 2) % p\n    end\n    ret\nend\n```",
            "```ruby\ndef encode_shift(s)\n    result = \"\"\n    s.each_char do |ch|\n        result << ((ch.ord - 'a'.ord + 5) % 26 + 'a'.ord).chr\n    end\n    return result\nend\n\ndef decode_shift(s)\n    result = \"\"\n    s.each_char do |ch|\n        result << ((ch.ord - 'a'.ord + 21) % 26 + 'a'.ord).chr\n    end\n    return result\nend\n```",
            "```ruby\ndef remove_vowels(txt)\n    vowels = \"aeiouAEIOU\"\n    result = \"\"\n    txt.chars.each do |c|\n        result << c unless vowels.include?(c)\n    end\n    result\nend\n```",
            "```ruby\ndef below_threshold(l, t)\n  l.all? { |x| x < t }\nend\n```",
            "```ruby\n# @param x [Integer]\n# @param y [Integer]\n# @returns {Integer}\ndef add(x, y)\n    x + y\nend\n```",
            "```ruby\ndef same_chars(s0, s1)\n    s0.chars.to_set == s1.chars.to_set\nend\n```",
            "```ruby\ndef fib(n)\n  if n <= 1\n    n\n  else\n    fib(n - 1) + fib(n - 2)\n  end\nend\n```",
            "```ruby\n# @param brackets [String]\n# @returns {Boolean}\ndef correct_bracketing(brackets)\n    depth = 0\n    brackets.each_char do |b|\n        if b == '<'\n            depth += 1\n        elsif b == '>'\n            depth -= 1\n        end\n        return false if depth < 0\n    end\n    depth == 0\nend\n```",
            "```ruby\n# @param l [Array<Integer>]\n# @returns {Boolean}\ndef monotonic(l)\n    return true if l.size <= 1\n\n    non_decreasing = true\n    non_increasing = true\n\n    (0...l.size - 1).each do |i|\n        non_decreasing = false if l[i] > l[i + 1]\n        non_increasing = false if l[i] < l[i + 1]\n    end\n\n    non_decreasing || non_increasing\nend\n```",
            "```ruby\ndef common(l1, l2)\n    set1 = l1.to_set\n    set2 = l2.to_set\n    set1 &= set2\n    result = set1.to_a.sort\n    result\nend\n```",
            "```ruby\n# @param n [Integer]\n# @returns {Integer}\ndef largest_prime_factor(n)\n    i = 2\n    while i * i <= n\n        if n % i != 0\n            i += 1\n        else\n            n /= i\n        end\n    end\n    return n\nend\n```",
            "```ruby\ndef sum_to_n(n)\n    sum = 0\n    (1..n).each do |i|\n        sum += i\n    end\n    sum\nend\n```",
            "```ruby\ndef correct_bracketing(brackets)\n    depth = 0\n    brackets.each_char do |b|\n        if b == '('\n            depth += 1\n        elsif b == ')'\n            depth -= 1\n        end\n        return false if depth < 0\n    end\n    depth == 0\nend\n```",
            "```ruby\ndef derivative(xs)\n    result = []\n    (1...xs.size).each do |i|\n        result << xs[i] * i\n    end\n    result\nend\n```",
            "```ruby\n# @param n [Integer]\n# @return [Integer]\ndef fibfib(n)\n    if n <= 1\n        return 0 \n    end\n    a, b, c = 0, 0, 1\n    while n > 2\n        a, b, c = b, c, a + b + c\n        n -= 1\n    end\n    c\nend\n```",
            "```ruby\n# @param s [String]\n# @returns {Integer}\ndef vowels_count(s)\n    cnt = 0\n    ['a', 'e', 'i', 'o', 'u'].each do |vowel|\n        cnt += s.downcase.count(vowel)\n    end\n    cnt += 1 if s[-1].downcase == 'y'\n    cnt\nend\n```",
            "```ruby\n# @param x [Integer]\n# @param shift [Integer]\n# @returns {String}\ndef circular_shift(x, shift)\n    x_str = x.to_s\n    if shift > x_str.length\n        x_str.reverse\n    else\n        x_str[-shift..-1] + x_str[0...-shift]\n    end\nend\n```",
            "```ruby\n# @param s [String]\n# @returns {Integer}\ndef digit_sum(s)\n    sum = 0\n    s.each_char do |c|\n        if c >= 'A' && c <= 'Z'\n            sum += c.ord\n        end\n    end\n    return sum\nend\n```",
            "```ruby\n# @param s [String]\n# @param n [Integer]\n# @returns {Integer}\ndef fruit_distribution(s, n)\n    words = s.split(' ')\n    apples = words[words.index(\"apples\") - 1].to_i\n    oranges = words[words.index(\"oranges\") - 1].to_i\n    return n - apples - oranges\nend\n```",
            "```ruby\n# @param arr [Array<Integer>]\n# @return [Array<Integer>]\ndef pluck(arr)\n    evens = arr.select { |n| n.even? }\n    return [] if evens.empty?\n    min_even = evens.min\n    [min_even, arr.index(min_even)]\nend\n```",
            "```ruby\ndef search(lst)\n    freqs = Hash.new(0)\n    lst.each { |n| freqs[n] += 1 }\n    good_vals = []\n    freqs.each do |key, value|\n        if value >= key\n            good_vals << key\n        end\n    end\n    good_vals.empty? ? -1 : good_vals.max\nend\n```",
            "```ruby\ndef strange_sort_list(lst)\n    sl = lst.sort\n    result = []\n    left, right = 0, sl.size - 1\n    while left <= right\n        result << sl[left]\n        left += 1\n        if left <= right\n            result << sl[right]\n            right -= 1\n        end\n    end\n    result\nend\n```",
            "```ruby\ndef triangle_area(a, b, c)\n  if a + b > c && a + c > b && b + c > a\n    s = (a + b + c) / 2.0\n    Math.sqrt(s * (s - a) * (s - b) * (s - c))\n  else\n    -1.0\n  end\nend\n```",
            "```ruby\n# @param q [Array<Integer>]\n# @param w [Integer]\n# @returns {Boolean}\ndef will_it_fly(q, w)\n    return false if q.empty?\n    is_palin = q.all? { |e| e == q[q.size - 1 - q.index(e)] }\n    total = q.sum\n    is_palin && total <= w\nend\n```",
            "```ruby\ndef smallest_change(arr)\n    ans = 0\n    (arr.size / 2).times do |i|\n        ans += 1 unless arr[i] == arr[arr.size - i - 1]\n    end\n    ans\nend\n```",
            "```ruby\ndef total_match(lst1, lst2)\n    cnt1 = lst1.map(&:length).sum\n    cnt2 = lst2.map(&:length).sum\n    cnt1 <= cnt2 ? lst1 : lst2\nend\n```",
            "```ruby\ndef is_prime(n)\n    return false if n < 2\n    (2..Math.sqrt(n).floor).each do |i|\n        return false if n % i == 0\n    end\n    true\nend\n\n# @param a [Integer]\n# @returns {Boolean}\ndef is_multiply_prime(a)\n    cnt = 0\n    (2..a).each do |i|\n        if is_prime(i)\n            while a % i == 0\n                cnt += 1\n                a /= i.to_f\n            end\n        end\n    end\n    cnt == 3\nend\n```",
            "```ruby\ndef is_simple_power(x, n)\n  return x == n if n < 2\n  tmp = 1\n  while tmp < x\n    tmp *= n\n  end\n  tmp == x\nend\n```",
            "```ruby\n# @param a [Integer]\n# @returns {Boolean}\ndef is_cube(a)\n    a = a.abs\n    root = Math.cbrt(a).round\n    return root * root * root == a\nend\n```",
            "```ruby\ndef hex_key(num)\n    count = 0\n    num.each_char do |x|\n        if \"2357BD\".include?(x)\n            count += 1\n        end\n    end\n    count\nend\n```",
            "```ruby\ndef decimal_to_binary(dec)\n    binary = dec.to_s(2)\n    \"db#{binary}db\"\nend\n```",
            "```ruby\ndef is_happy(s)\n    return false if s.length < 3\n    (0...s.length - 2).each do |i|\n        return false if s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]\n    end\n    true\nend\n```",
            "```ruby\n# @param grades [Array<Float>]\n# @returns {Array<String>}\ndef numerical_letter_grade(grades)\n    result = []\n    grades.each do |g|\n        if g == 4.0\n            result << \"A+\"\n        elsif g > 3.7\n            result << \"A\"\n        elsif g > 3.3\n            result << \"A-\"\n        elsif g > 3.0\n            result << \"B+\"\n        elsif g > 2.7\n            result << \"B\"\n        elsif g > 2.3\n            result << \"B-\"\n        elsif g > 2.0\n            result << \"C+\"\n        elsif g > 1.7\n            result << \"C\"\n        elsif g > 1.3\n            result << \"C-\"\n        elsif g > 1.0\n            result << \"D+\"\n        elsif g > 0.7\n            result << \"D\"\n        elsif g > 0.0\n            result << \"D-\"\n        else\n            result << \"E\"\n        end\n    end\n    result\nend\n```",
            "```ruby\ndef prime_length(s)\n    length = s.length\n    return false if length < 2\n    (2..Math.sqrt(length).to_i).each do |i|\n        return false if length % i == 0\n    end\n    true\nend\n```",
            "```ruby\n# @param n [Integer]\n# @returns {Integer}\ndef starts_one_ends(n)\n    if n == 1\n        return 1\n    end\n    return 2 * 9 * (10 ** (n - 2))\nend\n```",
            "```ruby\ndef solve(n)\n    digits_sum = 0\n    while n > 0\n        digits_sum += n % 10\n        n /= 10\n    end\n    digits_sum.to_s(2)\nend\n```",
            "```ruby\ndef add(lst)\n  sum = 0\n  (1...lst.size).step(2) do |i|\n    x = lst[i]\n    sum += x if x.even?\n  end\n  sum\nend\n```",
            "```ruby\n# @param s [String]\n# @returns {String}\ndef anti_shuffle(s)\n    result = []\n    words = s.split(\" \")\n    \n    words.each do |word|\n        chars = word.chars.sort.join\n        result << chars\n    end\n    \n    result.join(\" \").strip\nend\n```",
            "```ruby\n# @param lst [Array<Array<Integer>>]\n# @param x [Integer]\n# @returns {Array<Array<Integer>>}\ndef get_row(lst, x)\n    coords = []\n    lst.each_with_index do |row, i|\n        row.each_with_index do |val, j|\n            if val == x\n                coord = [i, j]\n                coords << coord\n            end\n        end\n    end\n    coords.sort_by! { |a| [-a[0], a[1]] }\n    coords\nend\n```",
            "```ruby\ndef sort_array(arr)\n  return [] if arr.empty?\n  if (arr.first + arr.last) % 2 == 0\n    arr.sort.reverse\n  else\n    arr.sort\n  end\nend\n```",
            "```ruby\n# @param s [String]\n# @returns {String}\ndef encrypt(s)\n    result = \"\"\n    s.each_char do |ch|\n        shifted = ch.ord + 4\n        if shifted > 'z'.ord\n            shifted -= 26\n        end\n        result << shifted.chr\n    end\n    result\nend\n```",
            "```ruby\n# @param lst [Array<Integer>]\n# @returns {Integer, nil}\ndef next_smallest(lst)\n    set = lst.uniq\n    sl = set.sort\n    return nil if sl.size < 2\n    sl[1]\nend\n```",
            "```ruby\n# @param s [String]\n# @returns {Integer}\ndef is_bored(s)\n    sentences = s.split(/[.!?]\\s*/)\n    count = 0\n    sentences.each do |sentence|\n        if sentence.length >= 2 && sentence.start_with?(\"I \")\n            count += 1\n        end\n    end\n    count\nend\n```",
            "```ruby\ndef any_int(x, y, z)\n  if x.is_a?(Integer) && y.is_a?(Integer) && z.is_a?(Integer)\n    int_x = x.to_i\n    int_y = y.to_i\n    int_z = z.to_i\n    return true if (int_x + int_y == int_z) || (int_x + int_z == int_y) || (int_y + int_z == int_x)\n  end\n  false\nend\n```",
            "```ruby\ndef encode(message)\n    vowels = \"aeiouAEIOU\"\n    result = \"\"\n    message.each_char do |ch|\n        if ch =~ /[a-zA-Z]/\n            ch1 = ch.downcase == ch ? ch.upcase : ch.downcase\n            ch1 = (vowels.include?(ch1) ? (ch1.ord + 2).chr : ch1)\n            result << ch1\n        else\n            result << ch\n        end\n    end\n    result\nend\n```",
            "```ruby\ndef skjkasdkd(lst)\n    primes = []\n    lst.each do |n|\n        if is_prime(n)\n            primes << n\n        end\n    end\n    return 0 if primes.empty?\n    \n    largest = primes.max.to_s\n    sum = 0\n    largest.chars.each do |digit|\n        sum += digit.to_i\n    end\n    sum\nend\n\ndef is_prime(n)\n    return false if n < 2\n    (2..Math.sqrt(n)).each do |i|\n        return false if n % i == 0\n    end\n    true\nend\n```",
            "```ruby\ndef check_dict_case(d)\n  return false if d.empty?\n  d.keys.all? { |c| c.islower? } || d.keys.all? { |c| c.isupper? }\nend\n```",
            "```ruby\ndef count_up_to(n)\n    primes = []\n    for num in 2...n do\n        is_prime = true\n        for p in primes\n            if num % p == 0\n                is_prime = false\n                break\n            end\n        end\n        primes << num if is_prime\n    end\n    primes\nend\n```",
            "```ruby\ndef multiply(a, b)\n    (a.abs % 10) * (b.abs % 10)\nend\n```",
            "```ruby\ndef count_upper(s)\n    vowels = \"AEIOU\"\n    count = 0\n    (0...s.length).each do |i|\n        c = s[i]\n        if i.even? && vowels.include?(c)\n            count += 1\n        end\n    end\n    count\nend\n```",
            "```ruby\n# @param value [String]\n# @returns {Integer}\ndef closest_integer(value)\n    num = value.to_f\n    if num >= 0\n        return (num + 0.5).floor\n    else\n        return (num - 0.5).ceil\n    end\nend\n```",
            "```ruby\n# @param n [Integer]\n# @returns {Array<Integer>}\ndef make_a_pile(n)\n    pile = []\n    (0...n).each do |i|\n        pile << (n + 2 * i)\n    end\n    pile\nend\n```",
            "```ruby\ndef words_string(s)\n  s.split(/[, ]+/).reject(&:empty?)\nend\n```",
            "```ruby\ndef choose_num(x, y)\n  return -1 if x > y\n  return y if y.even?\n  return y - 1 unless x == y\n  -1\nend\n```",
            "```ruby\ndef rounded_avg(n, m)\n  return nil if n > m\n  rAvg = ((m + n) / 2.0).round\n  rAvg.to_s(2)\nend\n```",
            "```ruby\ndef all_digits_odd?(number)\n  number.to_s.chars.all? do |digit|\n    (digit.to_i % 2).odd?\n  end\nend\n\ndef unique_digits(x)\n  x.select { |num| all_digits_odd?(num) }.sort\nend\n```",
            "```ruby\ndef by_length(arr)\n    digit_names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n    sorted_arr = arr.select { |x| x >= 1 && x <= 9 }.sort.reverse\n    sorted_arr.map { |x| digit_names[x - 1] }\nend\n```",
            "```ruby\n# @param n [Integer]\n# @returns {Array<Integer>}\ndef f(n)\n  nums = (1..n).to_a\n  nums.map do |i|\n    if i.odd?\n      nums.take(i).sum\n    else\n      nums.take(i).reduce(1, :*)\n    end\n  end\nend\n```",
            "```ruby\ndef even_odd_palindrome(n)\n    cnt = [0, 0]\n    (1..n).each do |i|\n        if i.to_s == i.to_s.reverse\n            cnt[i % 2] += 1\n        end\n    end\n    cnt\nend\n```",
            "```ruby\ndef digits_sum(n)\n  n_str = n.to_s\n  if n >= 0\n    n_str.chars.map(&:to_i).sum\n  else\n    (n_str[0..1].to_i * 2) + digits_sum(-n)\n  end\nend\n\n# @param arr [Array<Integer>]\n# @returns {Integer}\ndef count_nums(arr)\n  arr.count { |n| digits_sum(n) > 0 }\nend\n```",
            "```ruby\n# @param arr [Array<Integer>]\n# @returns {Boolean}\ndef move_one_ball(arr)\n    return true if arr.empty?\n\n    sorted_arr = arr.sort\n    (0...arr.size).each do |i|\n        return true if arr[i..-1] == sorted_arr[0..(arr.size - i)] && arr[0...i] == sorted_arr[(arr.size - i)..-1]\n    end\n\n    false\nend\n```",
            "```ruby\ndef can_exchange(lst1, lst2)\n    odd_cnt = lst1.count { |num| num % 2 != 0 }\n    even_cnt = lst2.count { |num| num % 2 == 0 }\n    \n    even_cnt >= odd_cnt ? \"YES\" : \"NO\"\nend\n```",
            "```ruby\ndef histogram(test)\n  freq = {}\n  words = test.split(\" \").reject(&:empty?)\n  words.each do |w|\n    freq[w] = (freq[w] || 0) + 1\n  end\n  \n  result = {}\n  if freq.size > 0\n    max_freq = freq.values.max\n    freq.each do |k, v|\n      result[k] = v if v == max_freq\n    end\n  end\n  \n  result\nend\n```",
            "```ruby\ndef reverse_delete(s, c)\n    result_string = s.chars.reject { |ch| c.include?(ch) }.join\n    palindrome_check = result_string.reverse\n    [result_string, palindrome_check == result_string ? \"yes\" : \"no\"]\nend\n```",
            "```ruby\ndef odd_count(lst)\n    result = []\n    lst.each do |num|\n        n = 0\n        num.each_char do |d|\n            n += 1 if d.to_i % 2 == 1\n        end\n        rs = \"the number of odd elements in the string i of the input.\"\n        result << rs.gsub(\"i\", n.to_s)\n    end\n    result\nend\n```",
            "```ruby\ndef min_sub_array_sum(nums)\n  min_sum = 0\n  cur_sum = 0\n  nums.each do |n|\n    cur_sum = [cur_sum + n, 0].min\n    min_sum = [cur_sum, min_sum].min\n  end\n  if min_sum == 0\n    min_sum = nums.min\n  end\n  min_sum\nend\n```",
            "```ruby\ndef max_fill(grid, capacity)\n    total = 0\n    grid.each do |arr|\n        sum = 0\n        arr.each do |num|\n            sum += num\n        end\n        total += (sum.to_f / capacity).ceil\n    end\n    total\nend\n```",
            "```ruby\ndef sort_array(arr)\n  arr.sort_by { |x| [x.to_s(2).count(\"1\"), x] }\nend\n```",
            "```ruby\ndef select_words(s, n)\n    consonants = \"bcdfghjklmnpqrstvwxyz\"\n    words = s.split(\" \").reject { |w| w.empty? }\n    words.select { |w| w.downcase.chars.count { |c| consonants.include?(c) } == n }\nend\n```",
            "```ruby\ndef get_closest_vowel(word)\n    vowels = \"aeiouAEIOU\"\n    (word.length - 2).downto(1) do |i|\n        if vowels.include?(word[i]) && !vowels.include?(word[i - 1]) && !vowels.include?(word[i + 1])\n            return word[i].to_s\n        end\n    end\n    \"\"\nend\n```",
            "```ruby\n# @param lst [Array<String>]\n# @returns {String}\ndef match_parens(lst)\n    s1 = lst[0] + lst[1]\n    s2 = lst[1] + lst[0]\n    return (check(s1) || check(s2)) ? \"Yes\" : \"No\"\nend\n\ndef check(s)\n    depth = 0\n    s.each_char do |ch|\n        depth += 1 if ch == '('\n        depth -= 1 if ch == ')'\n        return false if depth < 0\n    end\n    depth == 0\nend\n```",
            "```ruby\ndef maximum(arr, k)\n    if k == 0\n        return []\n    end\n    arr.sort.last(k)\nend\n```",
            "```ruby\ndef solution(lst)\n    sum = 0\n    lst.each_with_index do |value, index|\n        if index.even? && value.odd?\n            sum += value\n        end\n    end\n    sum\nend\n```",
            "```ruby\n# @param arr [Array<Integer>]\n# @param k [Integer]\n# @returns {Integer}\ndef add_elements(arr, k)\n    sum = 0\n    (0...[k, arr.size].min).each do |i|\n        if arr[i].to_s.length <= 2\n            sum += arr[i]\n        end\n    end\n    sum\nend\n```",
            "```ruby\n# @param n [Integer]\n# @returns {Array<Integer>}\ndef get_odd_collatz(n)\n    collatz = [1]\n    while n != 1\n        if n % 2 != 0\n            collatz.push(n)\n            n = 3 * n + 1\n        else\n            n = n / 2\n        end\n    end\n    return collatz.sort\nend\n```",
            "```ruby\ndef valid_date(date)\n    return false if date.length != 10 || date[2] != '-' || date[5] != '-'\n    \n    m = date[0, 2].to_i\n    d = date[3, 2].to_i\n    \n    return true if (m == 1 || m == 3 || m == 5 || m == 7 || m == 8 || m == 10 || m == 12) && 1 <= d && d <= 31\n    return true if (m == 4 || m == 6 || m == 9 || m == 11) && 1 <= d && d <= 30\n    return true if m == 2 && 1 <= d && d <= 29\n    \n    false\nend\n```",
            "```ruby\ndef split_words(txt)\n  if txt.include?(\" \")\n    txt.split(\" \")\n  elsif txt.include?(\",\")\n    txt.split(\",\")\n  else\n    [\"#{txt.chars.count { |c| c.ord.even? && c.downcase == c } }\"]\n  end\nend\n```",
            "```ruby\ndef is_sorted(lst)\n    return true if lst.size < 2\n    (1...lst.size).each do |i|\n        return false if lst[i - 1] > lst[i]\n    end\n    freq = Hash.new(0)\n    lst.each { |num| freq[num] += 1 }\n    max_freq = freq.values.max\n    return max_freq <= 2\nend\n```",
            "```ruby\ndef intersection(interval1, interval2)\n    l = [interval1[0], interval2[0]].max\n    r = [interval1[1], interval2[1]].min\n    length = r - l\n    is_prime(length) && length > 0 ? \"YES\" : \"NO\"\nend\n\ndef is_prime(n)\n    return false if n < 2\n    (2..Math.sqrt(n)).each do |i|\n        return false if n % i == 0\n    end\n    true\nend\n```",
            "```ruby\ndef prod_signs(arr)\n    return nil if arr.empty?\n    return 0 if arr.include?(0)\n    sign = arr.count { |n| n < 0 }.odd? ? -1 : 1\n    sign * arr.sum(&:abs)\nend\n```",
            "```ruby\ndef min_path(grid, k)\n    n = grid.length\n    min_val = n * n + 1\n    (0...n).each do |i|\n        (0...n).each do |j|\n            if grid[i][j] == 1\n                temp = []\n                temp << grid[i - 1][j] unless i == 0\n                temp << grid[i][j - 1] unless j == 0\n                temp << grid[i + 1][j] unless i == n - 1\n                temp << grid[i][j + 1] unless j == n - 1\n                min_val = temp.min\n            end\n        end\n    end\n    result = []\n    (0...k).each do |i|\n        result << (i % 2 == 0 ? 1 : min_val)\n    end\n    result\nend\n```",
            "```ruby\ndef tri(n)\n  return [1] if n == 0\n  seq = [1, 3]\n  for i in 2..n\n    if i.even?\n      seq << (i / 2 + 1)\n    else\n      next_value = seq[i - 1] + seq[i - 2] + (i + 3) / 2\n      seq << next_value\n    end\n  end\n  seq\nend\n```",
            "```ruby\n# @param n [Integer]\n# @returns {Integer}\ndef digits(n)\n    num_str = n.to_s\n    product = 1\n    has_odd_digit = false\n    \n    num_str.each_char do |c|\n        digit = c.to_i\n        if digit % 2 == 1\n            product *= digit\n            has_odd_digit = true\n        end\n    end\n    \n    return has_odd_digit ? product : 0\nend\n```",
            "```ruby\ndef is_nested(s)\n    open_idx = []\n    close_idx = []\n    \n    (0...s.length).each do |i|\n        ch = s[i]\n        if ch == '['\n            open_idx << i\n        elsif ch == ']'\n            close_idx << i\n        end\n    end\n    \n    close_idx.reverse!\n    cnt = 0\n    i = 0\n    l = close_idx.size\n    \n    open_idx.each do |idx|\n        if i < l && idx < close_idx[i]\n            cnt += 1\n            i += 1\n        end\n    end\n    \n    cnt >= 2\nend\n```",
            "```ruby\ndef sum_squares(lst)\n    lst.map { |n| (n.ceil)**2 }.sum\nend\n```",
            "```ruby\n# @param txt [String]\n# @returns {Boolean}\ndef check_if_last_char_is_a_letter(txt)\n    return false if txt.nil? || txt.empty?\n    last_space_index = txt.rindex(' ')\n    last_part = txt[last_space_index + 1..-1] if last_space_index\n    last_part && last_part.length == 1 && last_part =~ /[a-zA-Z]/\nend\n```",
            "```ruby\ndef can_arrange(arr)\n    return -1 if arr.size <= 1\n    idx = -1\n    (1...arr.size).each do |i|\n        idx = i if arr[i] < arr[i - 1]\n    end\n    idx\nend\n```",
            "```ruby\ndef largest_smallest_integers(lst)\n    neg = lst.select { |i| i < 0 }\n    pos = lst.select { |i| i > 0 }\n    \n    max_neg = neg.empty? ? nil : neg.max\n    min_pos = pos.empty? ? nil : pos.min\n    \n    [max_neg, min_pos]\nend\n```",
            "```ruby\ndef compare_one(a, b)\n  a1 = any_to_real(a)\n  b1 = any_to_real(b)\n  if a1 == b1\n    nil\n  elsif a1 > b1\n    a1\n  else\n    b1\n  end\nend\n\nprivate\n\ndef any_to_real(o)\n  case o\n  when String\n    o.gsub(',', '.').to_f\n  when Integer\n    o.to_f\n  when Float\n    o\n  else\n    raise RuntimeError, \"Type Error\"\n  end\nend\n```",
            "```ruby\ndef is_equal_to_sum_even(n)\n  n % 2 == 0 && n >= 8\nend\n```",
            "```ruby\n# @param n [Integer]\n# @returns [Integer]\ndef special_factorial(n)\n    fact = 1\n    result = 1\n    (1..n).each do |i|\n        fact *= i\n        result *= fact\n    end\n    result\nend\n```",
            "```ruby\ndef fix_spaces(txt)\n  txt.gsub(/\\s{3,}/, '-').gsub(/ /, '_')\nend\n```",
            "```ruby\ndef file_name_check(file_name)\n    suf = [\"txt\", \"exe\", \"dll\"]\n    lst = file_name.split(\".\")\n\n    if !(lst.length == 2) || !suf.include?(lst[1]) || lst[0].empty? || !('a'..'z').include?(lst[0][0].downcase) || lst[0].count(\"0-9\") > 3\n        return \"No\"\n    end\n\n    return \"Yes\"\nend\n```",
            "```ruby\n# @param lst [Array<Integer>]\n# @returns {Integer}\ndef sum_squares(lst)\n    result = 0\n    lst.each_with_index do |value, index|\n        if index % 3 == 0\n            result += value**2\n        elsif index % 4 == 0\n            result += value**3\n        else\n            result += value\n        end\n    end\n    result\nend\n```",
            "```ruby\ndef is_prime(n)\n  return false if n < 2\n  (2..Math.sqrt(n)).each do |i|\n    return false if n % i == 0\n  end\n  true\nend\n\ndef words_in_sentence(sentence)\n  words = sentence.split(\" \")\n  result = []\n  words.each do |w|\n    if is_prime(w.length)\n      result << w\n    end\n  end\n  result.join(\" \")\nend\n```",
            "```ruby\ndef simplify(x, n)\n    xs = x.split(\"/\")\n    ns = n.split(\"/\")\n    num = Integer(xs[0]) * Integer(ns[0])\n    den = Integer(xs[1]) * Integer(ns[1])\n    num % den == 0\nend\n```",
            "```ruby\ndef digits_sum(n)\n  n_str = n.to_s\n  if n >= 0\n    n_str.chars.map(&:to_i).sum\n  else\n    (n_str[0, 2].to_i * 2) + digits_sum(n.abs)\n  end\nend\n\n# @param nums [Array<Integer>]\n# @returns {Array<Integer>}\ndef order_by_points(nums)\n  nums.sort_by(&digits_sum)\nend\n```",
            "```ruby\n# @param nums [Array<Integer>]\n# @return [Integer]\ndef special_filter(nums)\n    odds = \"13579\"\n    count = 0\n    nums.each do |n|\n        if n > 10 && n.odd? && odds.include?(n.to_s[0])\n            count += 1\n        end\n    end\n    count\nend\n```",
            "```ruby\ndef get_max_triples(n)\n    c = [0, 0, 0]\n    (1..n).each do |i|\n        a = i * i - i + 1\n        c[a % 3] += 1\n    end\n    return c[0] * c[1] * c[2] + (c[0] * (c[0] - 1) * (c[0] - 2) + c[1] * (c[1] - 1) * (c[1] - 2) + c[2] * (c[2] - 1) * (c[2] - 2)) / 6\nend\n```",
            "```ruby\ndef bf(planet1, planet2)\n    names = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    return [] unless names.include?(planet1) && names.include?(planet2)\n    \n    l = names.index(planet1)\n    r = names.index(planet2)\n    l, r = r, l if l > r\n    \n    return [] if l == r\n    \n    names[l + 1...r]\nend\n```",
            "```ruby\ndef sorted_list_sum(lst)\n    result = []\n    lst.each do |s|\n        if s.length % 2 == 0\n            result << s\n        end\n    end\n    result.sort_by! { |x| [x.length, x] }\n    return result\nend\n```",
            "```ruby\ndef x_or_y(n, x, y)\n    if n < 2\n        return y\n    end\n    i = 2\n    while i <= Math.sqrt(n)\n        if n % i == 0\n            return y\n        end\n        i += 1\n    end\n    return x\nend\n```",
            "```ruby\ndef double_the_difference(lst)\n  lst.select { |n| n >= 0 && n.to_i % 2 == 1 }\n     .map { |n| n * n }\n     .sum.to_i\nend\n```",
            "```ruby\n# @param game [Array<Integer>]\n# @param guess [Array<Integer>]\n# @returns {Array<Integer>}\ndef compare(game, guess)\n    game.zip(guess).map { |x, y| (x - y).abs }\nend\n```",
            "```ruby\ndef strongest_extension(class_name, extensions)\n    max_s = -Float::INFINITY\n    max_ext = \"\"\n    extensions.each do |ext|\n        upper = 0\n        lower = 0\n        ext.each_char do |c|\n            if c =~ /[A-Z]/\n                upper += 1\n            elsif c =~ /[a-z]/\n                lower += 1\n            end\n        end\n        s = upper - lower\n        if s > max_s\n            max_s = s\n            max_ext = ext\n        end\n    end\n    \"#{class_name}.#{max_ext}\"\nend\n```",
            "```ruby\n# @param a [String]\n# @param b [String]\n# @returns {Boolean}\ndef cycpattern_check(a, b)\n    return false if a.length < b.length\n    (0...b.length).each do |i|\n        rotated_b = b[i..-1] + b[0...i]\n        return true if a.include?(rotated_b)\n    end\n    false\nend\n```",
            "```ruby\ndef even_odd_count(num)\n    ds = num.abs.to_s\n    even = ds.chars.count { |d| d.ord % 2 == 0 }\n    [even, ds.length - even]\nend\n```",
            "```ruby\ndef int_to_mini_roman(num)\n    values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    res = \"\"\n    values.each_with_index do |value, i|\n        while num >= value\n            res << numerals[i]\n            num -= value\n        end\n    end\n    res\nend\n```",
            "```ruby\ndef right_angle_triangle(a, b, c)\n    s = [a, b, c].sort\n    s[0] * s[0] + s[1] * s[1] == s[2] * s[2]\nend\n```",
            "```ruby\ndef find_max(words)\n    max_cnt = 0\n    max_w = \"\"\n    words.each do |w|\n        unique_chars = w.chars.uniq.size\n        if unique_chars > max_cnt\n            max_cnt = unique_chars\n            max_w = w\n        elsif unique_chars == max_cnt\n            max_w = [max_w, w].min\n        end\n    end\n    max_w\nend\n```",
            "```ruby\ndef eat(num, need, remaining)\n  if need <= remaining\n    [num + need, remaining - need]\n  else\n    [num + remaining, 0]\n  end\nend\n```",
            "```ruby\ndef do_algebra(operators, operands)\n    ops = operators.dup\n    nums = operands.dup\n    i = ops.size - 1\n    while i >= 0\n        if ops[i] == \"**\"\n            nums[i] = nums[i]**nums[i + 1]\n            nums.delete_at(i + 1)\n            ops.delete_at(i)\n        end\n        i -= 1\n    end\n    i = 0\n    while i < ops.size\n        if ops[i] == \"*\"\n            nums[i] *= nums[i + 1]\n            nums.delete_at(i + 1)\n            ops.delete_at(i)\n            i -= 1\n        elsif ops[i] == \"//\"\n            nums[i] /= nums[i + 1]\n            nums.delete_at(i + 1)\n            ops.delete_at(i)\n            i -= 1\n        end\n        i += 1\n    end\n    i = 0\n    while i < ops.size\n        if ops[i] == \"+\"\n            nums[i] += nums[i + 1]\n            nums.delete_at(i + 1)\n            ops.delete_at(i)\n            i -= 1\n        elsif ops[i] == \"-\"\n            nums[i] -= nums[i + 1]\n            nums.delete_at(i + 1)\n            ops.delete_at(i)\n            i -= 1\n        end\n        i += 1\n    end\n    nums[0]\nend\n```",
            "```ruby\ndef solve(s)\n  if s !~ /[a-zA-Z]/\n    return s.reverse\n  end\n\n  result = ''\n  s.each_char do |ch|\n    if ch !~ /[a-zA-Z]/\n      result << ch\n    elsif ch == ch.upcase\n      result << ch.downcase\n    elsif ch == ch.downcase\n      result << ch.upcase\n    end\n  end\n\n  result\nend\n```",
            "```ruby\nrequire 'digest'\n\n# @param txt [String]\n# @returns {String, nil}\ndef string_to_md5(txt)\n    return nil if txt.empty?\n    md5_hash = Digest::MD5.hexdigest(txt)\n    md5_hash\nend\n```",
            "```ruby\ndef generate_integers(a, b)\n    lower = [2, [a, b].min].max\n    upper = [8, [a, b].max].min\n    result = []\n    (lower..upper).each do |i|\n        if i.even?\n            result << i\n        end\n    end\n    result\nend\n```"
        ],
        "swift": [
            "```swift\nfunc hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {\n    for i in 0..<numbers.count {\n        for j in (i + 1)..<numbers.count {\n            if abs(numbers[i] - numbers[j]) < threshold {\n                return true\n            }\n        }\n    }\n    return false\n}\n```",
            "```swift\nfunc separateParenGroups(_ parenString: String) -> [String] {\n    var groups = [String]()\n    var stk = [Character]()\n    var currentGroup = \"\"\n    let parens = parenString.filter { !$0.isWhitespace }\n    \n    for ch in parens {\n        if ch == \"(\" {\n            stk.append(ch)\n            currentGroup += String(ch)\n        } else if ch == \")\" {\n            stk.removeLast()\n            currentGroup += String(ch)\n            if stk.isEmpty {\n                groups.append(currentGroup)\n                currentGroup = \"\"\n            }\n        }\n    }\n    \n    return groups\n}\n```",
            "```swift\nfunc truncateNumber(_ num: Double) -> Double {\n    return num - floor(num)\n}\n```",
            "```swift\nfunc belowZero(_ operations: [Int]) -> Bool {\n    var balance = 0\n    for op in operations {\n        balance += op\n        if balance < 0 {\n            return true\n        }\n    }\n    return false\n}\n```",
            "```swift\nfunc meanAbsoluteDeviation(_ numbers: [Double]) -> Double {\n    let sum = numbers.reduce(0, +)\n    let mean = sum / Double(numbers.count)\n    \n    let deviationSum = numbers.reduce(0) { $0 + abs($1 - mean) }\n    \n    return deviationSum / Double(numbers.count)\n}\n```",
            "```swift\nfunc intersperse(_ numbers: [Int], _ delimiter: Int) -> [Int] {\n    var result = [Int]()\n    for (i, number) in numbers.enumerated() {\n        if i != 0 {\n            result.append(delimiter)\n        }\n        result.append(number)\n    }\n    return result\n}\n```",
            "```swift\nfunc parseNestedParens(_ parenString: String) -> [Int] {\n    var result = [Int]()\n    let parenGroups = parenString.split(separator: \" \")\n    for group in parenGroups {\n        var maxDepth = 0\n        var depth = 0\n        for ch in group {\n            if ch == \"(\" {\n                depth += 1\n                maxDepth = max(maxDepth, depth)\n            } else if ch == \")\" {\n                depth -= 1\n            }\n        }\n        result.append(maxDepth)\n    }\n    return result\n}\n```",
            "```swift\nfunc filterBySubstring(_ strs: [String], _ substring: String) -> [String] {\n    var result = [String]()\n    for s in strs {\n        if s.contains(substring) {\n            result.append(s)\n        }\n    }\n    return result\n}\n```",
            "```swift\nfunc sumProduct(_ numbers: [Int]) -> [Int] {\n    let n_sum = numbers.reduce(0, +)\n    let n_product = numbers.reduce(1, *)\n    return [n_sum, n_product]\n}\n```",
            "```swift\nfunc rollingMax(_ numbers: [Int]) -> [Int] {\n    var maxSoFar = Int.min\n    var result: [Int] = []\n    for num in numbers {\n        maxSoFar = max(maxSoFar, num)\n        result.append(maxSoFar)\n    }\n    return result\n}\n```",
            "```swift\nfunc makePalindrome(_ s: String) -> String {\n    if isPalindrome(s) {\n        return s\n    }\n    for i in 0..<s.count {\n        let index = s.index(s.startIndex, offsetBy: i)\n        let substring = String(s[index...])\n        if isPalindrome(substring) {\n            let prefix = String(s[s.startIndex..<index])\n            let reversedPrefix = String(prefix.reversed())\n            return s + reversedPrefix\n        }\n    }\n    return \"\"\n}\n\nprivate func isPalindrome(_ s: String) -> Bool {\n    var left = s.startIndex\n    var right = s.index(before: s.endIndex)\n    while left < right {\n        if s[left] != s[right] {\n            return false\n        }\n        left = s.index(after: left)\n        right = s.index(before: right)\n    }\n    return true\n}\n```",
            "```swift\nfunc stringXor(_ a: String, _ b: String) -> String {\n    var result = \"\"\n    let maxLength = min(a.count, b.count)\n    var indexA = a.startIndex\n    var indexB = b.startIndex\n    \n    for _ in 0..<maxLength {\n        let charA = a[indexA]\n        let charB = b[indexB]\n        result += (charA == charB) ? \"0\" : \"1\"\n        \n        indexA = a.index(after: indexA)\n        indexB = b.index(after: indexB)\n    }\n    \n    return result\n}\n```",
            "```swift\nfunc longest(_ strs: [String]) -> String? {\n    guard !strs.isEmpty else { return nil }\n    var longest_s = strs[0]\n    for s in strs {\n        if s.count > longest_s.count {\n            longest_s = s\n        }\n    }\n    return longest_s\n}\n```",
            "```swift\nfunc greatestCommonDivisor(_ a: Int, _ b: Int) -> Int {\n    if b == 0 {\n        return a\n    } else {\n        return greatestCommonDivisor(b, a % b)\n    }\n}\n```",
            "```swift\nfunc allPrefixes(_ s: String) -> [String] {\n    var prefixes = [String]()\n    for i in 0..<s.count {\n        let index = s.index(s.startIndex, offsetBy: i)\n        let prefix = String(s[...index])\n        prefixes.append(prefix)\n    }\n    return prefixes\n}\n```",
            "```swift\nfunc stringSequence(_ n: Int) -> String {\n    var result = \"\"\n    for i in 0...n {\n        result += \"\\(i)\"\n        if i < n {\n            result += \" \"\n        }\n    }\n    return result\n}\n```",
            "```swift\nfunc countDistinctCharacters(_ s: String) -> Int {\n    return Set(s.lowercased()).count\n}\n```",
            "```swift\nfunc parseMusic(_ musicString: String) -> [Int] {\n    let durations: [String: Int] = [\"o\": 4, \"o|\": 2, \".|\": 1]\n    let notes = musicString.split(separator: \" \")\n    return notes.compactMap { durations[String($0)] }\n}\n```",
            "```swift\nfunc howManyTimes(_ s: String, _ substring: String) -> Int {\n    var times = 0\n    for i in 0...(s.count - substring.count) {\n        if s.hasPrefix(substring, startIndex: s.index(s.startIndex, offsetBy: i)) {\n            times += 1\n        }\n    }\n    return times\n}\n```",
            "```swift\nfunc sortNumbers(_ numbers: String) -> String {\n    let numDict: [String: Int] = [\n        \"zero\": 0, \"one\": 1, \"two\": 2, \"three\": 3, \"four\": 4,\n        \"five\": 5, \"six\": 6, \"seven\": 7, \"eight\": 8, \"nine\": 9\n    ]\n\n    let numList = numbers.split(separator: \" \")\n        .compactMap { numDict[$0] }\n        .sorted()\n        .map { String($0) }\n\n    return numList.joined(separator: \" \")\n}\n```",
            "```swift\nfunc findClosestElements(_ numbers: [Double]) -> [Double] {\n    let sortedNumbers = numbers.sorted()\n    var minDiff = Double.infinity\n    var closestPair: [Double] = []\n    for i in 1..<sortedNumbers.count {\n        let diff = sortedNumbers[i] - sortedNumbers[i - 1]\n        if diff < minDiff {\n            minDiff = diff\n            closestPair = [sortedNumbers[i - 1], sortedNumbers[i]]\n        }\n    }\n    return closestPair\n}\n```",
            "```swift\nfunc rescaleToUnit(_ numbers: [Double]) -> [Double] {\n    guard let minNum = numbers.min(), let maxNum = numbers.max() else {\n        return []\n    }\n    \n    if minNum == maxNum {\n        return Array(repeating: 0.0, count: numbers.count)\n    } else {\n        return numbers.map { (num) -> Double in\n            return (num - minNum) / (maxNum - minNum)\n        }\n    }\n}\n```",
            "```swift\nfunc filterIntegers(_ values: [Any]) -> [Int] {\n    return values.compactMap { $0 as? Int }\n}\n```",
            "```swift\nfunc strLength(_ s: String) -> Int {\n    return s.count\n}\n```",
            "```swift\nfunc largestDivisor(_ n: Int) -> Int {\n    for i in 2..<n {\n        if n % i == 0 {\n            return n / i\n        }\n    }\n    return 1\n}\n```",
            "```swift\nfunc factorize(_ n: Int) -> [Int] {\n    var factors = [Int]()\n    var divisor = 2\n    while divisor <= n {\n        if n % divisor == 0 {\n            factors.append(divisor)\n            var newN = n / divisor\n            n = newN\n        } else {\n            divisor += 1\n        }\n    }\n    return factors\n}\n```",
            "```swift\nfunc removeDuplicates(_ numbers: [Int]) -> [Int] {\n    var counts = [Int: Int]()\n    for num in numbers {\n        counts[num, default: 0] += 1\n    }\n    var res = [Int]()\n    for num in numbers {\n        if counts[num] == 1 {\n            res.append(num)\n        }\n    }\n    return res\n}\n```",
            "```swift\nfunc flipCase(_ s: String) -> String {\n    var flipped = \"\"\n    for ch in s {\n        if !ch.isLetter {\n            flipped.append(ch)\n        } else if ch.isLowercase {\n            flipped.append(ch.uppercased())\n        } else if ch.isUppercase {\n            flipped.append(ch.lowercased())\n        }\n    }\n    return flipped\n}\n```",
            "```swift\nfunc concatenate(_ strs: [String]) -> String {\n    var result = \"\"\n    for str in strs {\n        result.append(str)\n    }\n    return result\n}\n```",
            "```swift\nfunc filterByPrefix(_ strs: [String], _ prefixStr: String) -> [String] {\n    return strs.filter { $0.hasPrefix(prefixStr) }\n}\n```",
            "```swift\nfunc getPositive(_ l: [Int]) -> [Int] {\n    return l.filter { $0 > 0 }\n}\n```",
            "```swift\nfunc isPrime(_ n: Int) -> Bool {\n    if n < 2 {\n        return false\n    }\n    for i in 2...Int(sqrt(Double(n))) {\n        if n % i == 0 {\n            return false\n        }\n    }\n    return true\n}\n```",
            "```swift\nfunc poly(_ xs: [Int], _ x: Double) -> Double {\n    var res = 0.0\n    for i in 0..<xs.count {\n        res += Double(xs[i]) * pow(x, Double(i))\n    }\n    return res\n}\n\nfunc findZero(_ xs: [Int]) -> Double {\n    var x1 = 1.0, x2 = -1.0\n    while poly(xs, x1) * poly(xs, x2) > 0 {\n        x1 *= 2\n        x2 *= 2\n    }\n    while abs(x1 - x2) > 1e-10 {\n        let mid = (x1 + x2) / 2\n        if poly(xs, mid) == 0 {\n            return mid\n        } else if poly(xs, mid) * poly(xs, x1) < 0 {\n            x2 = mid\n        } else {\n            x1 = mid\n        }\n    }\n    return (x1 + x2) / 2\n}\n```",
            "```swift\nfunc sortThird(_ l: [Int]) -> [Int] {\n    let sortedThird = Array(l.enumerated().compactMap { i, _ in i % 3 == 0 ? l[i] : nil }).sorted()\n    return l.enumerated().map { i, value in i % 3 == 0 ? sortedThird[i / 3] : value }\n}\n```",
            "```swift\nfunc listUnique(_ l: [Int]) -> [Int] {\n    let set = Set(l)\n    var sortedList = Array(set)\n    sortedList.sort()\n    return sortedList\n}\n```",
            "```swift\nfunc maxElement(_ l: [Int]) -> Int {\n    if l.isEmpty {\n        return 0\n    }\n    return l.max() ?? 0\n}\n```",
            "```swift\nfunc fizzBuzz(_ n: Int) -> Int {\n    var cnt = 0\n    for i in 0..<n {\n        if i % 11 == 0 || i % 13 == 0 {\n            let str = String(i)\n            for c in str {\n                if c == \"7\" {\n                    cnt += 1\n                }\n            }\n        }\n    }\n    return cnt\n}\n```",
            "```swift\nfunc sortEven(_ l: [Int]) -> [Int] {\n    let sortedEven = Array(l.enumerated().filter { $0.offset % 2 == 0 }.map { $0.element }).sorted()\n    return (0..<l.count).map { i in i % 2 == 0 ? sortedEven[i / 2] : l[i] }\n}\n```",
            "```swift\nfunc encodeCyclic(_ s: String) -> String {\n    var result = \"\"\n    let chars = Array(s)\n    for i in stride(from: 0, to: chars.count, by: 3) {\n        if i + 3 > chars.count {\n            result += s.substring(from: Index(chars.startIndex, offsetBy: i))\n        } else {\n            result += String(chars[i+1...i+2])\n            result.append(chars[i])\n        }\n    }\n    return result\n}\n\nfunc decodeCyclic(_ s: String) -> String {\n    return encodeCyclic(encodeCyclic(s))\n}\n```",
            "```swift\nfunc primeFib(_ n: Int) -> Int {\n    var f = [0, 1]\n    var cnt = 0\n    while cnt < n {\n        f = [f[1], f[0] + f[1]]\n        if isPrime(f[1]) {\n            cnt += 1\n        }\n    }\n    return f[1]\n}\n\nfunc isPrime(_ n: Int) -> Bool {\n    if n < 2 {\n        return false\n    }\n    for i in 2...Int(sqrt(Double(n))) {\n        if n % i == 0 {\n            return false\n        }\n    }\n    return true\n}\n```",
            "```swift\nfunc triplesSumToZero(_ l: [Int]) -> Bool {\n    for i in 0..<l.count {\n        for j in (i + 1)..<l.count {\n            for k in (j + 1)..<l.count {\n                if l[i] + l[j] + l[k] == 0 {\n                    return true\n                }\n            }\n        }\n    }\n    return false\n}\n```",
            "```swift\nfunc carRaceCollision(_ n: Int) -> Int {\n    return n * n\n}\n```",
            "```swift\nfunc incrList(_ l: [Int]) -> [Int] {\n    var result = [Int]()\n    for i in l {\n        result.append(i + 1)\n    }\n    return result\n}\n```",
            "```swift\nfunc pairsSumToZero(_ l: [Int]) -> Bool {\n    var seen = Set<Int>()\n    for num in l {\n        if seen.contains(-num) {\n            return true\n        }\n        seen.insert(num)\n    }\n    return false\n}\n```",
            "```swift\nfunc changeBase(_ x: Int, _ bas: Int) -> String {\n    if x == 0 {\n        return \"0\"\n    }\n    var digits = \"\"\n    var number = x\n    while number > 0 {\n        let remainder = number % bas\n        digits.append(String(remainder))\n        number /= bas\n    }\n    return String(digits.reversed())\n}\n```",
            "```swift\nfunc triangleArea(_ a: Int, _ h: Int) -> Double {\n    return Double(a) * Double(h) / 2.0\n}\n```",
            "```swift\nfunc fib4(_ n: Int) -> Int {\n    var fib = [0, 0, 2, 0]\n    for i in 4...n {\n        fib[i % 4] = fib[0] + fib[1] + fib[2] + fib[3]\n    }\n    return fib[n % 4]\n}\n```",
            "```swift\nfunc median(_ l: [Double]) -> Double {\n    let sl = l.sorted()\n    if sl.count % 2 != 0 {\n        return sl[sl.count / 2]\n    } else {\n        return (sl[sl.count / 2] + sl[sl.count / 2 - 1]) / 2.0\n    }\n}\n```",
            "```swift\nfunc isPalindrome(_ txt: String) -> Bool {\n    let n = txt.count\n    for i in 0..<n / 2 {\n        let index1 = txt.index(txt.startIndex, offsetBy: i)\n        let index2 = txt.index(txt.endIndex, offsetBy: -i - 1)\n        if txt[index1] != txt[index2] {\n            return false\n        }\n    }\n    return true\n}\n```",
            "```swift\nfunc modp(_ n: Int, _ p: Int) -> Int {\n    var ret = 1\n    for i in 0..<n {\n        ret = (ret * 2) % p\n    }\n    return ret\n}\n```",
            "```swift\nfunc encodeShift(_ s: String) -> String {\n    var result = \"\"\n    for ch in s {\n        let shiftedChar = Character(UnicodeScalar(((ch.asciiValue! - UInt8(\"a\".unicodeScalars.first!.value) + 5) % 26) + UInt8(\"a\".unicodeScalars.first!.value))!)\n        result.append(shiftedChar)\n    }\n    return result\n}\n\nfunc decodeShift(_ s: String) -> String {\n    var result = \"\"\n    for ch in s {\n        let shiftedChar = Character(UnicodeScalar(((ch.asciiValue! - UInt8(\"a\".unicodeScalars.first!.value) + 21) % 26) + UInt8(\"a\".unicodeScalars.first!.value))!)\n        result.append(shiftedChar)\n    }\n    return result\n}\n```",
            "```swift\nfunc removeVowels(_ txt: String) -> String {\n    let vowels = \"aeiouAEIOU\"\n    var result = \"\"\n    for c in txt {\n        if !vowels.contains(c) {\n            result.append(c)\n        }\n    }\n    return result\n}\n```",
            "```swift\nfunc belowThreshold(_ l: [Int], _ t: Int) -> Bool {\n    for x in l {\n        if x >= t {\n            return false\n        }\n    }\n    return true\n}\n```",
            "func add(_ x: Int, _ y: Int) -> Int {\n    return x + y\n}",
            "```swift\nfunc sameChars(_ s0: String, _ s1: String) -> Bool {\n    return Set(s0).elementsEqual(Set(s1))\n}\n```",
            "```swift\nfunc fib(_ n: Int) -> Int {\n    if n <= 1 {\n        return n\n    } else {\n        return fib(n - 1) + fib(n - 2)\n    }\n}\n```",
            "```swift\nfunc correctBracketing(_ brackets: String) -> Bool {\n    var depth = 0\n    for b in brackets {\n        if b == \"<\" {\n            depth += 1\n        } else if b == \">\" {\n            depth -= 1\n        }\n        if depth < 0 {\n            return false\n        }\n    }\n    return depth == 0\n}\n```",
            "```swift\nfunc monotonic(_ l: [Int]) -> Bool {\n    if l.count <= 1 { return true }\n\n    let n = l.count\n    var nonDecreasing = true\n    var nonIncreasing = true\n\n    for i in 0..<n - 1 {\n        if l[i] > l[i + 1] {\n            nonDecreasing = false\n        }\n        if l[i] < l[i + 1] {\n            nonIncreasing = false\n        }\n    }\n\n    return nonDecreasing || nonIncreasing\n}\n```",
            "```swift\nfunc common(_ l1: [Int], _ l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n    let intersection = set1.intersection(set2)\n    var result = Array(intersection)\n    result.sort()\n    return result\n}\n```",
            "```swift\nfunc largestPrimeFactor(_ n: Int) -> Int {\n    var i = 2\n    while i * i <= n {\n        if n % i != 0 {\n            i += 1\n        } else {\n            n /= i\n        }\n    }\n    return n\n}\n```",
            "```swift\nfunc sumToN(_ n: Int) -> Int {\n    var sum = 0\n    for i in 1...n {\n        sum += i\n    }\n    return sum\n}\n```",
            "```swift\nfunc correctBracketing(_ brackets: String) -> Bool {\n    var depth = 0\n    for b in brackets {\n        if b == \"(\" {\n            depth += 1\n        } else if b == \")\" {\n            depth -= 1\n        }\n        if depth < 0 {\n            return false\n        }\n    }\n    return depth == 0\n}\n```",
            "```swift\nfunc derivative(_ xs: [Int]) -> [Int] {\n    var result = [Int]()\n    for i in 1..<xs.count {\n        result.append(xs[i] * i)\n    }\n    return result\n}\n```",
            "```swift\nfunc fibfib(_ n: Int) -> Int {\n    if n <= 1 {\n        return 0 \n    }\n    var a = 0, b = 0, c = 1\n    while n > 2 {\n        let tempA = b\n        let tempB = c\n        c = a + b + c\n        a = tempA\n        b = tempB\n        n -= 1\n    }\n    return c\n}\n```",
            "```swift\nfunc vowelsCount(_ s: String) -> Int {\n    let vowels = \"aeiou\"\n    var cnt = 0\n    for char in s.lowercased() {\n        if vowels.contains(char) || (char == \"y\" && s.lowercased().last == char) {\n            cnt += 1\n        }\n    }\n    return cnt\n}\n```",
            "```swift\nfunc circularShift(_ x: Int, _ shift: Int) -> String {\n    let x_str = String(x)\n    if shift > x_str.count {\n        return String(x_str.reversed())\n    } else {\n        let index = x_str.index(x_str.startIndex, offsetBy: x_str.count - shift)\n        let firstPart = x_str[index...]\n        let secondPart = x_str[x_str.startIndex..<index]\n        return String(firstPart) + String(secondPart)\n    }\n}\n```",
            "```swift\nfunc digitSum(_ s: String) -> Int {\n    var sum = 0\n    for char in s {\n        if char.isUppercase {\n            sum += Int(char.asciiValue ?? 0)\n        }\n    }\n    return sum\n}\n```",
            "```swift\nfunc fruitDistribution(_ s: String, _ n: Int) -> Int {\n    let words = s.split(separator: \" \")\n    guard let applesIndex = words.firstIndex(of: \"apples\"),\n          let orangesIndex = words.firstIndex(of: \"oranges\") else { return 0 }\n    let apples = Int(words[applesIndex - 1]) ?? 0\n    let oranges = Int(words[orangesIndex - 1]) ?? 0\n    return n - apples - oranges\n}\n```",
            "```swift\nfunc pluck(_ arr: [Int]) -> [Int] {\n    let evens = arr.filter { $0 % 2 == 0 }\n    guard let minEven = evens.min() else {\n        return []\n    }\n    if let index = arr.firstIndex(of: minEven) {\n        return [minEven, index]\n    }\n    return []\n}\n```",
            "```swift\nfunc search(_ lst: [Int]) -> Int {\n    var freqs = [Int: Int]()\n    for n in lst {\n        freqs[n, default: 0] += 1\n    }\n    var goodVals = [Int]()\n    for (key, value) in freqs {\n        if value >= key {\n            goodVals.append(key)\n        }\n    }\n    return !goodVals.isEmpty ? goodVals.max()! : -1\n}\n```",
            "```swift\nfunc strangeSortList(_ lst: [Int]) -> [Int] {\n    var sl = lst.sorted()\n    var result: [Int] = []\n    var left = 0, right = sl.count - 1\n    while left <= right {\n        result.append(sl[left])\n        left += 1\n        if left <= right {\n            result.append(sl[right])\n            right -= 1\n        }\n    }\n    return result\n}\n```",
            "```swift\nfunc triangleArea(_ a: Int, _ b: Int, _ c: Int) -> Double {\n    if a + b > c && a + c > b && b + c > a {\n        let s = Double(a + b + c) / 2.0\n        return sqrt(s * (s - Double(a)) * (s - Double(b)) * (s - Double(c)))\n    } else {\n        return -1.0\n    }\n}\n```",
            "```swift\nfunc willItFly(_ q: [Int], _ w: Int) -> Bool {\n    if q.isEmpty {\n        return false\n    }\n    let isPalin = q.enumerated().allSatisfy { (index, element) in element == q[q.count - index - 1] }\n    let total = q.reduce(0, +)\n    return isPalin && total <= w\n}\n```",
            "```swift\nfunc smallestChange(_ arr: [Int]) -> Int {\n    var ans = 0\n    for i in 0..<arr.count / 2 {\n        if arr[i] != arr[arr.count - i - 1] {\n            ans += 1\n        }\n    }\n    return ans\n}\n```",
            "```swift\nfunc totalMatch(_ lst1: [String], _ lst2: [String]) -> [String] {\n    let cnt1 = lst1.reduce(0, { $0 + $1.count })\n    let cnt2 = lst2.reduce(0, { $0 + $1.count })\n    return cnt1 <= cnt2 ? lst1 : lst2\n}\n```",
            "```swift\nfunc isMultiplyPrime(_ a: Int) -> Bool {\n    var cnt = 0\n    var n = a\n    for i in 2...Int(sqrt(Double(n))) {\n        if n % i == 0 {\n            while n % i == 0 {\n                cnt += 1\n                n /= i\n            }\n        }\n    }\n    return cnt == 3\n}\n```",
            "```swift\nfunc isSimplePower(_ x: Int, _ n: Int) -> Bool {\n    if n < 2 {\n        return x == n\n    }\n    var tmp = 1\n    while tmp < x {\n        tmp *= n\n    }\n    return tmp == x\n}\n```",
            "```swift\nfunc isCube(_ a: Int) -> Bool {\n    let absA = abs(a)\n    let root = Int(round(pow(Double(absA), 1.0/3.0)))\n    return root * root * root == absA\n}\n```",
            "```swift\nfunc hexKey(_ num: String) -> Int {\n    let count = num.filter { \"2357BD\".contains($0) }.count\n    return count\n}\n```",
            "```swift\nfunc decimalToBinary(_ dec: Int) -> String {\n    let binary = String(dec, radix: 2)\n    return \"db\" + binary + \"db\"\n}\n```",
            "```swift\nfunc isHappy(_ s: String) -> Bool {\n    if s.count < 3 {\n        return false\n    }\n    for i in 0..<(s.count - 2) {\n        let char1 = s[s.index(s.startIndex, offsetBy: i)]\n        let char2 = s[s.index(s.startIndex, offsetBy: i + 1)]\n        let char3 = s[s.index(s.startIndex, offsetBy: i + 2)]\n        \n        if char1 == char2 || char1 == char3 || char2 == char3 {\n            return false\n        }\n    }\n    return true\n}\n```",
            "```swift\nfunc numericalLetterGrade(_ grades: [Double]) -> [String] {\n    var result = [String]()\n    for g in grades {\n        if g == 4.0 {\n            result.append(\"A+\")\n        } else if g > 3.7 {\n            result.append(\"A\")\n        } else if g > 3.3 {\n            result.append(\"A-\")\n        } else if g > 3.0 {\n            result.append(\"B+\")\n        } else if g > 2.7 {\n            result.append(\"B\")\n        } else if g > 2.3 {\n            result.append(\"B-\")\n        } else if g > 2.0 {\n            result.append(\"C+\")\n        } else if g > 1.7 {\n            result.append(\"C\")\n        } else if g > 1.3 {\n            result.append(\"C-\")\n        } else if g > 1.0 {\n            result.append(\"D+\")\n        } else if g > 0.7 {\n            result.append(\"D\")\n        } else if g > 0.0 {\n            result.append(\"D-\")\n        } else {\n            result.append(\"E\")\n        }\n    }\n    return result\n}\n```",
            "```swift\nfunc primeLength(_ s: String) -> Bool {\n    let length = s.count\n    if length < 2 {\n        return false\n    }\n    for i in 2...Int(sqrt(Double(length))) {\n        if length % i == 0 {\n            return false\n        }\n    }\n    return true\n}\n```",
            "```swift\nfunc startsOneEnds(_ n: Int) -> Int {\n    if n == 1 {\n        return 1\n    }\n    return 2 * 9 * Int(pow(10.0, Double(n - 2)))\n}\n```",
            "```swift\nfunc solve(_ n: Int) -> String {\n    var digitsSum = 0\n    var number = n\n    while number > 0 {\n        digitsSum += number % 10\n        number /= 10\n    }\n    return String(digitsSum, radix: 2)\n}\n```",
            "```swift\nfunc add(_ lst: [Int]) -> Int {\n    var sum = 0\n    for i in stride(from: 1, to: lst.count, by: 2) {\n        let x = lst[i]\n        if x % 2 == 0 {\n            sum += x\n        }\n    }\n    return sum\n}\n```",
            "```swift\nfunc antiShuffle(_ s: String) -> String {\n    var result = \"\"\n    let words = s.split(separator: \" \")\n    \n    for word in words {\n        let charsArray = Array(word)\n        let sortedChars = charsArray.sorted()\n        result += String(sortedChars) + \" \"\n    }\n    \n    return result.trimmingCharacters(in: .whitespaces)\n}\n```",
            "```swift\nfunc getRow(_ lst: [[Int]], _ x: Int) -> [[Int]] {\n    var coords = [[Int]]()\n    for i in 0..<lst.count {\n        for j in 0..<lst[i].count {\n            if lst[i][j] == x {\n                let coord = [i, j]\n                coords.append(coord)\n            }\n        }\n    }\n    coords.sort { (a, b) -> Bool in\n        if a[0] == b[0] {\n            return a[1] > b[1]\n        }\n        return a[0] < b[0]\n    }\n    return coords\n}\n```",
            "```swift\nfunc sortArray(_ arr: [Int]) -> [Int] {\n    if arr.isEmpty {\n        return []\n    }\n    if (arr.first! + arr.last!) % 2 == 0 {\n        return arr.sorted(by: >)\n    } else {\n        return arr.sorted()\n    }\n}\n```",
            "```swift\nfunc encrypt(_ s: String) -> String {\n    var result = \"\"\n    for ch in s {\n        let shifted = UnicodeScalar(ch.asciiValue! + 4)\n        if shifted.value > 122 { // 'z'.asciiValue!\n            let newChar = Character(UnicodeScalar(shifted.value - 26)!)\n            result.append(newChar)\n        } else {\n            let newChar = Character(shifted)\n            result.append(newChar)\n        }\n    }\n    return result\n}\n```",
            "```swift\nfunc nextSmallest(_ lst: [Int]) -> Int? {\n    let set = Set(lst)\n    var sl = Array(set)\n    sl.sort()\n    if sl.count < 2 {\n        return nil\n    }\n    return sl[1]\n}\n```",
            "```swift\nfunc isBored(_ s: String) -> Int {\n    let sentences = s.split { \".!?\".contains($0) }\n    var count = 0\n    for sentence in sentences {\n        if sentence.count >= 2 && String(sentence.prefix(2)) == \"I \" {\n            count += 1\n        }\n    }\n    return count\n}\n```",
            "```swift\nfunc anyInt(_ x: Any, _ y: Any, _ z: Any) -> Bool {\n    if let intX = x as? Int, let intY = y as? Int, let intZ = z as? Int {\n        if (intX + intY == intZ) || (intX + intZ == intY) || (intY + intZ == intX) {\n            return true\n        }\n    }\n    return false\n}\n```",
            "```swift\nfunc encode(_ message: String) -> String {\n    let vowels = \"aeiouAEIOU\"\n    var result = \"\"\n    \n    for ch in message {\n        if ch.isLetter {\n            let ch1 = ch.isLowercase ? ch.uppercased() : ch.lowercased()\n            let characterToCheck = Character(ch1)\n            if vowels.contains(characterToCheck) {\n                let asciiValue = UInt32(ch1.asciiValue!) + 2\n                if let newChar = UnicodeScalar(asciiValue)?.description.first {\n                    result.append(newChar)\n                }\n            } else {\n                result.append(ch1)\n            }\n        } else {\n            result.append(ch)\n        }\n    }\n    \n    return result\n}\n```",
            "```swift\nfunc skjkasdkd(_ lst: [Int]) -> Int {\n    var primes = [Int]()\n    for n in lst {\n        if isPrime(n) {\n            primes.append(n)\n        }\n    }\n    if primes.isEmpty {\n        return 0\n    }\n    let largest = String(primes.max()!)\n    var sum = 0\n    for digit in largest {\n        sum += Int(String(digit))!\n    }\n    return sum\n}\n\nprivate func isPrime(_ n: Int) -> Bool {\n    if n < 2 {\n        return false\n    }\n    for i in 2...Int(sqrt(Double(n))) {\n        if n % i == 0 {\n            return false\n        }\n    }\n    return true\n}\n```",
            "```swift\nfunc checkDictCase(_ d: [String:String]) -> Bool {\n    if d.isEmpty {\n        return false\n    }\n    let allLowercase = d.keys.allSatisfy { $0.isLowercase }\n    let allUppercase = d.keys.allSatisfy { $0.isUppercase }\n    return allLowercase || allUppercase\n}\n```",
            "```swift\nfunc countUpTo(_ n: Int) -> [Int] {\n    var primes = [Int]()\n    for num in 2..<n {\n        var isPrime = true\n        for p in primes {\n            if num % p == 0 {\n                isPrime = false\n                break\n            }\n        }\n        if isPrime {\n            primes.append(num)\n        }\n    }\n    return primes\n}\n```",
            "```swift\nfunc multiply(_ a: Int, _ b: Int) -> Int {\n    return (abs(a) % 10) * (abs(b) % 10)\n}\n```",
            "```swift\nfunc countUpper(_ s: String) -> Int {\n    let vowels = \"AEIOU\"\n    var count = 0\n    for (i, c) in s.enumerated() {\n        if i % 2 == 0 && vowels.contains(c) {\n            count += 1\n        }\n    }\n    return count\n}\n```",
            "```swift\nfunc closestInteger(_ value: String) -> Int {\n    let num = Double(value)!\n    if num >= 0 {\n        return Int(num + 0.5)\n    } else {\n        return Int(num - 0.5)\n    }\n}\n```",
            "```swift\nfunc makeAPile(_ n: Int) -> [Int] {\n    var pile = [Int]()\n    for i in 0..<n {\n        pile.append(n + 2 * i)\n    }\n    return pile\n}\n```",
            "```swift\nfunc wordsString(_ s: String) -> [String] {\n    return s.split(separator: \", \").compactMap { $0.isEmpty ? nil : String($0) }\n}\n```",
            "```swift\nfunc chooseNum(_ x: Int, _ y: Int) -> Int {\n    if x > y {\n        return -1\n    }\n    if y % 2 == 0 {\n        return y\n    }\n    return (x != y) ? y - 1 : -1\n}\n```",
            "```swift\nfunc roundedAvg(_ n: Int, _ m: Int) -> String? {\n    if n > m {\n        return nil\n    }\n    let rAvg = (m + n) / 2.0 + 0.5\n    return String(Int(rAvg), radix: 2)\n}\n```",
            "```swift\nfunc uniqueDigits(_ x: [Int]) -> [Int] {\n    return x.filter { num in\n        allDigitsOdd(String(num))\n    }.sorted()\n}\n\nprivate func allDigitsOdd(_ s: String) -> Bool {\n    for digitChar in s {\n        if let digit = Int(String(digitChar)), digit % 2 == 0 {\n            return false\n        }\n    }\n    return true\n}\n```",
            "```swift\nfunc byLength(_ arr: [Int]) -> [String] {\n    let digitNames = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n    let sortedArr = arr.filter { $0 >= 1 && $0 <= 9 }.sorted(by: >)\n    return sortedArr.map { digitNames[$0 - 1] }\n}\n```",
            "```swift\nfunc f(_ n: Int) -> [Int] {\n    let nums = Array(1...n)\n    return (0..<nums.count).map { i in\n        if (i + 1) % 2 != 0 {\n            return nums.prefix(i + 1).reduce(0, +)\n        } else {\n            return nums.prefix(i + 1).reduce(1, *)\n        }\n    }\n}\n```",
            "```swift\nfunc evenOddPalindrome(_ n: Int) -> [Int] {\n    var cnt = [0, 0]\n    for i in 1...n {\n        let txt = String(i)\n        if txt == String(txt.reversed()) {\n            cnt[i % 2] += 1\n        }\n    }\n    return cnt\n}\n```",
            "```swift\nfunc digitsSum(_ n: Int) -> Int {\n    let nStr = String(n)\n    if n >= 0 {\n        return nStr.reduce(0) { $0 + Int(String($1))! }\n    } else {\n        return Int(nStr.prefix(2))! * 2 + digitsSum(abs(n))\n    }\n}\n\nfunc countNums(_ arr: [Int]) -> Int {\n    return arr.filter { digitsSum($0) > 0 }.count\n}\n```",
            "```swift\nfunc moveOneBall(_ arr: [Int]) -> Bool {\n    if arr.isEmpty {\n        return true\n    }\n    let sortedArr = arr.sorted()\n    for i in 0..<arr.count {\n        if arr[i...] == sortedArr.prefix(arr.count - i) && arr[0..<i] == sortedArr.suffix(i) {\n            return true\n        }\n    }\n    return false\n}\n```",
            "```swift\nfunc canExchange(_ lst1: [Int], _ lst2: [Int]) -> String {\n    let odd_cnt = lst1.filter { $0 % 2 != 0 }.count\n    let even_cnt = lst2.filter { $0 % 2 == 0 }.count\n    \n    return even_cnt >= odd_cnt ? \"YES\" : \"NO\"\n}\n```",
            "```swift\nfunc histogram(_ test: String) -> [String: Int] {\n    var freq = [String: Int]()\n    let words = test.split(separator: \" \").compactMap { String($0) }\n    for w in words {\n        freq[w, default: 0] += 1\n    }\n    var result = [String: Int]()\n    if let maxFreq = freq.values.max() {\n        for (k, v) in freq where v == maxFreq {\n            result[k] = v\n        }\n    }\n    return result\n}\n```",
            "```swift\nfunc reverseDelete(_ s: String, _ c: String) -> [String] {\n    let filteredString = s.filter { !c.contains($0) }\n    let reversedString = String(filteredString.reversed())\n    var resultList: [String] = []\n    resultList.append(filteredString)\n    resultList.append(reversedString == filteredString ? \"yes\" : \"no\")\n    return resultList\n}\n```",
            "```swift\nfunc oddCount(_ lst: [String]) -> [String] {\n    var result = [String]()\n    for num in lst {\n        var n = 0\n        for d in num {\n            if Int(String(d))! % 2 == 1 {\n                n += 1\n            }\n        }\n        let rs = \"the number of odd elements in the string i of the input.\"\n        result.append(rs.replacingOccurrences(of: \"i\", with: String(n)))\n    }\n    return result\n}\n```",
            "```swift\nfunc minSubArraySum(_ nums: [Int]) -> Int {\n    var min_sum = 0\n    var cur_sum = 0\n    for n in nums {\n        cur_sum = min(cur_sum + n, 0)\n        min_sum = min(cur_sum, min_sum)\n    }\n    if min_sum == 0 {\n        min_sum = nums.min() ?? 0\n    }\n    return min_sum\n}\n```",
            "```swift\nfunc maxFill(_ grid: [[Int]], _ capacity: Int) -> Int {\n    var total = 0\n    for arr in grid {\n        let sum = arr.reduce(0, +)\n        total += Int(ceil(Double(sum) / Double(capacity)))\n    }\n    return total\n}\n```",
            "```swift\nfunc countOnes(_ num: Int) -> Int {\n    return String(num, radix: 2).filter { $0 == \"1\" }.count\n}\n\nfunc sortArray(_ arr: [Int]) -> [Int] {\n    return arr.sorted { (a, b) -> Bool in\n        let onesA = countOnes(a)\n        let onesB = countOnes(b)\n        if onesA == onesB {\n            return a < b\n        }\n        return onesA < onesB\n    }\n}\n```",
            "```swift\nfunc selectWords(_ s: String, _ n: Int) -> [String] {\n    let consonants = \"bcdfghjklmnpqrstvwxyz\"\n    let words = s.split(separator: \" \").map { String($0) }\n    return words.filter { word in\n        word.lowercased().filter { consonants.contains($0) }.count == n\n    }\n}\n```",
            "```swift\nfunc getClosestVowel(_ word: String) -> String {\n    let vowels = \"aeiouAEIOU\"\n    for i in stride(from: word.count - 2, to: 0, by: -1) {\n        if let char = word.unicodeScalars.first(where: { $0.index == word.index(word.startIndex, offsetBy: i) }) {\n            if vowels.contains(Character(char)) {\n                if !vowels.contains(Character(word[word.index(word.startIndex, offsetBy: i - 1)])) && \n                   !vowels.contains(Character(word[word.index(word.startIndex, offsetBy: i + 1)])) {\n                    return String<Character>(charactersIn: word[word.index(word.startIndex, offsetBy: i)])\n                }\n            }\n        }\n    }\n    return \"\"\n}\n```",
            "```swift\nfunc matchParens(_ lst: [String]) -> String {\n    let s1 = lst[0] + lst[1]\n    let s2 = lst[1] + lst[0]\n    return check(s1) || check(s2) ? \"Yes\" : \"No\"\n}\n\nprivate func check(_ s: String) -> Bool {\n    var depth = 0\n    for ch in s {\n        if ch == \"(\" {\n            depth += 1\n        } else {\n            depth -= 1\n        }\n        if depth < 0 {\n            return false\n        }\n    }\n    return depth == 0\n}\n```",
            "```swift\nfunc maximum(_ arr: [Int], _ k: Int) -> [Int] {\n    if k == 0 {\n        return []\n    }\n    return arr.sorted(reversed: true).prefix(k)\n}\n```",
            "```swift\nfunc solution(_ lst: [Int]) -> Int {\n    var sum = 0\n    for i in 0..<lst.count {\n        if i % 2 == 0 && lst[i] % 2 != 0 {\n            sum += lst[i]\n        }\n    }\n    return sum\n}\n```",
            "```swift\nfunc addElements(_ arr: [Int], _ k: Int) -> Int {\n    var sum = 0\n    for i in 0..<min(k, arr.count) {\n        if String(arr[i]).count <= 2 {\n            sum += arr[i]\n        }\n    }\n    return sum\n}\n```",
            "```swift\nfunc getOddCollatz(_ n: Int) -> [Int] {\n    var collatz = [1]\n    var current = n\n    while current != 1 {\n        if current % 2 != 0 {\n            collatz.append(current)\n            current = 3 * current + 1\n        } else {\n            current /= 2\n        }\n    }\n    return collatz.sorted()\n}\n```",
            "```swift\nfunc validDate(_ date: String) -> Bool {\n    if date.length != 10 || date[2] != \"-\" || date[5] != \"-\" {\n        return false\n    }\n    let m = Int(String(date.prefix(2)))!\n    let d = Int(String(date.dropFirst(3).prefix(2)))!\n    if (m == 1 || m == 3 || m == 5 || m == 7 || m == 8 || m == 10 || m == 12) && d >= 1 && d <= 31 {\n        return true\n    }\n    if (m == 4 || m == 6 || m == 9 || m == 11) && d >= 1 && d <= 30 {\n        return true\n    }\n    if m == 2 && d >= 1 && d <= 29 {\n        return true\n    }\n    return false\n}\n```",
            "```swift\nfunc splitWords(_ txt: String) -> [String] {\n    if txt.contains(\" \") {\n        return txt.split(separator: \" \").map { String($0) }\n    } else if txt.contains(\",\") {\n        return txt.split(separator: \",\").map { String($0) }\n    } else {\n        let count = txt.filter { $0.isLowercase && ($0.unicodeScalars.first?.value ?? 0) % 2 == 0 }.count\n        return [String(count)]\n    }\n}\n```",
            "```swift\nfunc isSorted(_ lst: [Int]) -> Bool {\n    if lst.count < 2 { return true }\n    for i in 1..<lst.count {\n        if lst[i - 1] > lst[i] { return false }\n    }\n    var freq = [Int: Int]()\n    for num in lst {\n        freq[num, default: 0] += 1\n    }\n    let maxFreq = freq.values.max() ?? 0\n    return maxFreq <= 2\n}\n```",
            "```swift\nfunc intersection(_ interval1: [Int], _ interval2: [Int]) -> String {\n    let l = max(interval1[0], interval2[0])\n    let r = min(interval1[1], interval2[1])\n    let length = r - l\n    return isPrime(length) && length > 0 ? \"YES\" : \"NO\"\n}\n\nprivate func isPrime(_ n: Int) -> Bool {\n    if n < 2 {\n        return false\n    }\n    for i in 2...Int(sqrt(Double(n))) {\n        if n % i == 0 {\n            return false\n        }\n    }\n    return true\n}\n```",
            "```swift\nfunc prodSigns(_ arr: [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    if arr.contains(0) {\n        return 0\n    }\n    let sign = arr.filter { $0 < 0 }.count % 2 == 1 ? -1 : 1\n    return sign * abs(arr.reduce(0, +))\n}\n```",
            "```swift\nfunc minPath(_ grid: [[Int]], _ k: Int) -> [Int] {\n    let n = grid.count\n    var min_val = n * n + 1\n    for i in 0..<n {\n        for j in 0..<n {\n            if grid[i][j] == 1 {\n                var temp = [Int]()\n                if i != 0 {\n                    temp.append(grid[i - 1][j])\n                }\n                if j != 0 {\n                    temp.append(grid[i][j - 1])\n                }\n                if i != n - 1 {\n                    temp.append(grid[i + 1][j])\n                }\n                if j != n - 1 {\n                    temp.append(grid[i][j + 1])\n                }\n                min_val = temp.min() ?? min_val\n            }\n        }\n    }\n    var result = [Int]()\n    for i in 0..<k {\n        result.append(i % 2 == 0 ? 1 : min_val)\n    }\n    return result\n}\n```",
            "```swift\nfunc tri(_ n: Int) -> [Int] {\n    if n == 0 {\n        return [1]\n    }\n    var seq = [1, 3]\n    for i in 2...n {\n        if i % 2 == 0 {\n            seq.append(i / 2 + 1)\n        } else {\n            let nextValue = seq[i - 1] + seq[i - 2] + (i + 3) / 2\n            seq.append(nextValue)\n        }\n    }\n    return seq\n}\n```",
            "```swift\nfunc digits(_ n: Int) -> Int {\n    let numStr = String(n)\n    var product = 1\n    var hasOddDigit = false\n    \n    for c in numStr {\n        if let digit = c.wholeNumberValue, digit % 2 == 1 {\n            product *= digit\n            hasOddDigit = true\n        }\n    }\n    \n    return hasOddDigit ? product : 0\n}\n```",
            "```swift\nfunc isNested(_ s: String) -> Bool {\n    var openIdx = [Int]()\n    var closeIdx = [Int]()\n    \n    for (i, ch) in s.enumerated() {\n        if ch == \"[\" {\n            openIdx.append(i)\n        } else if ch == \"]\" {\n            closeIdx.append(i)\n        }\n    }\n    \n    closeIdx.reverse()\n    var cnt = 0\n    var i = 0\n    let l = closeIdx.count\n    \n    for idx in openIdx {\n        if i < l && idx < closeIdx[i] {\n            cnt += 1\n            i += 1\n        }\n    }\n    \n    return cnt >= 2\n}\n```",
            "```swift\nfunc sumSquares(_ lst: [Double]) -> Int {\n    return lst.map { ceil($0) * ceil($0) }.reduce(0, +)\n}\n```",
            "```swift\nfunc checkIfLastCharIsALetter(_ txt: String) -> Bool {\n    if txt.isEmpty {\n        return false\n    }\n    let lastSpaceIndex = txt.lastIndex(of: \" \") ?? txt.startIndex\n    let lastPart = txt[lastSpaceIndex..<txt.endIndex]\n    return lastPart.count == 1 && lastPart.unicodeScalars.allSatisfy { $0.isLetter }\n}\n```",
            "```swift\nfunc canArrange(_ arr: [Int]) -> Int {\n    if arr.count <= 1 {\n        return -1\n    }\n    var idx = -1\n    for i in 1..<arr.count {\n        if arr[i] < arr[i - 1] {\n            idx = i\n        }\n    }\n    return idx\n}\n```",
            "```swift\nfunc largestSmallestIntegers(_ lst: [Int]) -> [Int?] {\n    var neg = [Int]()\n    var pos = [Int]()\n    \n    for i in lst {\n        if i < 0 {\n            neg.append(i)\n        } else if i > 0 {\n            pos.append(i)\n        }\n    }\n    \n    let maxNeg: Int? = neg.isEmpty ? nil : neg.max()\n    let minPos: Int? = pos.isEmpty ? nil : pos.min()\n    \n    return [maxNeg, minPos]\n}\n```",
            "```swift\nfunc compareOne(_ a: Any, _ b: Any) -> Double? {\n    let a1 = anyToReal(a)\n    let b1 = anyToReal(b)\n    \n    if a1 == b1 {\n        return nil\n    } else if a1 > b1 {\n        return a1\n    } else {\n        return b1\n    }\n}\n\nprivate func anyToReal(_ o: Any) -> Double {\n    if let str = o as? String, let value = Double(str.replacingOccurrences(of: \",\", with: \".\")) {\n        return value\n    } else if let intValue = o as? Int {\n        return Double(intValue)\n    } else if let doubleValue = o as? Double {\n        return doubleValue\n    } else {\n        fatalError(\"Type Error\")\n    }\n}\n```",
            "```swift\nfunc isEqualToSumEven(_ n: Int) -> Bool {\n    return n % 2 == 0 && n >= 8\n}\n```",
            "```swift\nfunc specialFactorial(_ n: Int) -> Int {\n    var fact = 1\n    var result = 1\n    for i in 1...n {\n        fact *= i\n        result *= fact\n    }\n    return result\n}\n```",
            "```swift\nfunc fixSpaces(_ txt: String) -> String {\n    let trimmedTxt = txt.replacingOccurrences(of: \"\\\\s{3,}\", with: \"-\", options: .regularExpression)\n    return trimmedTxt.replacingOccurrences(of: \" \", with: \"_\")\n}\n```",
            "```swift\nfunc fileNameCheck(_ fileName: String) -> String {\n    let suf = [\"txt\", \"exe\", \"dll\"]\n    let lst = fileName.split(separator: \".\")\n    \n    if lst.count != 2 || !suf.contains(String(lst[1])) || lst[0].isEmpty || !lst[0].first!.isLetter || lst[0].filter { $0.isNumber }.count > 3 {\n        return \"No\"\n    }\n    \n    return \"Yes\"\n}\n```",
            "```swift\nfunc sumSquares(_ lst: [Int]) -> Int {\n    var result = 0\n    for i in 0..<lst.count {\n        if i % 3 == 0 {\n            result += Int(pow(Double(lst[i]), 2))\n        } else if i % 4 == 0 {\n            result += Int(pow(Double(lst[i]), 3))\n        } else {\n            result += lst[i]\n        }\n    }\n    return result\n}\n```",
            "```swift\nfunc wordsInSentence(_ sentence: String) -> String {\n    func isPrime(_ n: Int) -> Bool {\n        if n < 2 {\n            return false\n        }\n        for i in 2...Int(sqrt(Double(n))) {\n            if n % i == 0 {\n                return false\n            }\n        }\n        return true\n    }\n    \n    let words = sentence.split(separator: \" \")\n    var result: [String] = []\n    for word in words {\n        if isPrime(word.count) {\n            result.append(String(word))\n        }\n    }\n    return result.joined(separator: \" \")\n}\n```",
            "```swift\nfunc simplify(_ x: String, _ n: String) -> Bool {\n    let xs = x.split(separator: \"/\")\n    let ns = n.split(separator: \"/\")\n    let num = Int(xs[0])! * Int(ns[0])!\n    let den = Int(xs[1])! * Int(ns[1])!\n    return num % den == 0\n}\n```",
            "```swift\nfunc digitsSum(_ n: Int) -> Int {\n    let nStr = String(n)\n    if n >= 0 {\n        return nStr.compactMap { $0.wholeNumberValue }.reduce(0, +)\n    } else {\n        return (Int(String(nStr.prefix(2))) ?? 0) * 2 + digitsSum(abs(n))\n    }\n}\n\nfunc orderByPoints(_ nums: [Int]) -> [Int] {\n    return nums.sorted(by: { digitsSum($0) < digitsSum($1) })\n}\n```",
            "```swift\nfunc specialFilter(_ nums: [Int]) -> Int {\n    let odds = \"13579\"\n    var count = 0\n    for n in nums {\n        if n > 10 && n % 2 == 1, let firstChar = String(n).first, odds.contains(firstChar) {\n            count += 1\n        }\n    }\n    return count\n}\n```",
            "```swift\nfunc getMaxTriples(_ n: Int) -> Int {\n    var c = [0, 0, 0]\n    for i in 1...n {\n        let a = i * i - i + 1\n        c[a % 3] += 1\n    }\n    return c[0] * c[1] * c[2] + (c[0] * (c[0] - 1) * (c[0] - 2) + c[1] * (c[1] - 1) * (c[1] - 2) + c[2] * (c[2] - 1) * (c[2] - 2)) / 6\n}\n```",
            "```swift\nfunc bf(_ planet1: String, _ planet2: String) -> [String] {\n    let names = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    guard let l = names.firstIndex(of: planet1), let r = names.firstIndex(of: planet2) else {\n        return []\n    }\n    if l > r {\n        let temp = l\n        let _l = r\n        let _r = temp\n        return names[_l + 1..._r].compactMap { $0 }\n    }\n    if l == r {\n        return []\n    }\n    return Array(names[l + 1..<r])\n}\n```",
            "```swift\nfunc sortedListSum(_ lst: [String]) -> [String] {\n    var result = lst.filter { $0.count % 2 == 0 }\n    result.sort { \n        if $0.count != $1.count {\n            return $0.count < $1.count\n        } else {\n            return $0 < $1\n        }\n    }\n    return result\n}\n```",
            "```swift\nfunc xOrY(_ n: Int, _ x: Int, _ y: Int) -> Int {\n    if n < 2 {\n        return y\n    }\n    for i in 2...Int(sqrt(Double(n))) {\n        if n % i == 0 {\n            return y\n        }\n    }\n    return x\n}\n```",
            "```swift\nfunc doubleTheDifference(_ lst: [Double]) -> Int {\n    return Int(lst.filter { $0 >= 0 && floor($0) % 2 == 1 }\n                 .map { $0 * $0 }\n                 .reduce(0, +))\n}\n```",
            "```swift\nfunc compare(_ game: [Int], _ guess: [Int]) -> [Int] {\n    return zip(game, guess).map { abs($0 - $1) }\n}\n```",
            "```swift\nfunc strongestExtension(_ className: String, _ extensions: [String]) -> String {\n    var max_s = Int.min\n    var max_ext = \"\"\n    \n    for ext in extensions {\n        var upper = 0, lower = 0\n        for c in ext {\n            if CharacterSet.uppercaseLetters.contains(c) {\n                upper += 1\n            } else if CharacterSet.lowercaseLetters.contains(c) {\n                lower += 1\n            }\n        }\n        \n        let s = upper - lower\n        if s > max_s {\n            max_s = s\n            max_ext = ext\n        }\n    }\n    \n    return \"\\(className).\\(max_ext)\"\n}\n```",
            "```swift\nfunc cycpatternCheck(_ a: String, _ b: String) -> Bool {\n    if a.count < b.count {\n        return false\n    }\n    for i in 0..<b.count {\n        let index = b.index(b.startIndex, offsetBy: i)\n        let rotatedB = b.substring(from: index) + b.substring(to: index)\n        if a.contains(rotatedB) {\n            return true\n        }\n    }\n    return false\n}\n```",
            "```swift\nfunc evenOddCount(_ num: Int) -> [Int] {\n    let ds = String(abs(num))\n    let even = ds.filter { $0.wholeNumberValue! % 2 == 0 }.count\n    return [even, ds.count - even]\n}\n```",
            "```swift\nfunc intToMiniRoman(_ num: Int) -> String {\n    let values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    let numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    var res = \"\"\n    for i in 0..<values.count {\n        while num >= values[i] {\n            res.append(numerals[i])\n            num -= values[i]\n        }\n    }\n    return res\n}\n```",
            "```swift\nfunc rightAngleTriangle(_ a: Int, _ b: Int, _ c: Int) -> Bool {\n    let s = [a, b, c].sorted()\n    return s[0] * s[0] + s[1] * s[1] == s[2] * s[2]\n}\n```",
            "```swift\nfunc findMax(_ words: [String]) -> String {\n    var maxCnt = 0\n    var maxW = \"\"\n    for w in words {\n        let uniqueChars = Set(w)\n        let cnt = uniqueChars.count\n        if cnt > maxCnt {\n            maxCnt = cnt\n            maxW = w\n        } else if cnt == maxCnt {\n            maxW = min(maxW, w)\n        }\n    }\n    return maxW\n}\n\nfunc min(_ a: String, _ b: String) -> String {\n    return a < b ? a : b\n}\n```",
            "```swift\nfunc eat(_ num: Int, _ need: Int, _ remaining: Int) -> [Int] {\n    if need <= remaining {\n        return [num + need, remaining - need]\n    } else {\n        return [num + remaining, 0]\n    }\n}\n```",
            "```swift\nfunc doAlgebra(_ operators: [String], _ operands: [Int]) -> Int {\n    var ops = operators\n    var nums = operands\n    var i = ops.count - 1\n    while i >= 0 {\n        if ops[i] == \"**\" {\n            nums[i] = Int(pow(Double(nums[i]), Double(nums[i + 1])))\n            nums.remove(at: i + 1)\n            ops.remove(at: i)\n        }\n        i -= 1\n    }\n    i = 0\n    while i < ops.count {\n        if ops[i] == \"*\" {\n            nums[i] *= nums[i + 1]\n            nums.remove(at: i + 1)\n            ops.remove(at: i)\n            i -= 1\n        } else if ops[i] == \"//\" {\n            nums[i] /= nums[i + 1]\n            nums.remove(at: i + 1)\n            ops.remove(at: i)\n            i -= 1\n        }\n        i += 1\n    }\n    i = 0\n    while i < ops.count {\n        if ops[i] == \"+\" {\n            nums[i] += nums[i + 1]\n            nums.remove(at: i + 1)\n            ops.remove(at: i)\n            i -= 1\n        } else if ops[i] == \"-\" {\n            nums[i] -= nums[i + 1]\n            nums.remove(at: i + 1)\n            ops.remove(at: i)\n            i -= 1\n        }\n        i += 1\n    }\n    return nums[0]\n}\n```",
            "```swift\nfunc solve(_ s: String) -> String {\n    if s.allSatisfy({ !$0.isLetter }) {\n        return String(s.reversed())\n    }\n    var result = \"\"\n    for ch in s {\n        if !ch.isLetter {\n            result.append(ch)\n        } else if ch.isUppercase {\n            result.append(ch.lowercased())\n        } else if ch.isLowercase {\n            result.append(ch.uppercased())\n        }\n    }\n    return result\n}\n```",
            "```swift\nfunc stringToMd5(_ txt: String) -> String? {\n    guard !txt.isEmpty else { return nil }\n    \n    let txtData = txt.data(using: .utf8)!\n    var md5Hash = Data(count: Int(CC_MD5_DIGEST_LENGTH))\n    \n    _ = md5Hash.withUnsafeMutableBytes { (digestBytes: UnsafeMutableRawBufferPointer) in\n        txtData.withUnsafeBytes { (dataBytes: UnsafeRawBufferPointer) in\n            CC_MD5(dataBytes.baseAddress, CC_LONG(txtData.count), digestBytes.bindMemory(to: UInt8.self).baseAddress)\n        }\n    }\n    \n    return md5Hash.map { String(format: \"%02hhx\", $0) }.joined()\n}\n```",
            "```swift\nfunc generateIntegers(_ a: Int, _ b: Int) -> [Int] {\n    let lower = max(2, min(a, b))\n    let upper = min(8, max(a, b))\n    var result: [Int] = []\n    for i in lower...upper {\n        if i % 2 == 0 {\n            result.append(i)\n        }\n    }\n    return result\n}\n```"
        ],
        "rust": [
            "```rust\npub fn has_close_elements(numbers: &Vec<f64>, threshold: f64) -> bool {\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            if (numbers[i] - numbers[j]).abs() < threshold {\n                return true;\n            }\n        }\n    }\n    false\n}\n```",
            "```rust\npub fn separate_paren_groups(paren_string: &String) -> Vec<String> {\n    let mut groups = Vec::new();\n    let mut stk = Vec::new();\n    let mut current_group = String::new();\n    let parens: Vec<char> = paren_string.chars().filter(|c| !c.is_whitespace()).collect();\n\n    for ch in parens {\n        if ch == '(' {\n            stk.push(ch);\n            current_group.push(ch);\n        } else if ch == ')' {\n            stk.pop();\n            current_group.push(ch);\n            if stk.is_empty() {\n                groups.push(current_group.clone());\n                current_group.clear();\n            }\n        }\n    }\n\n    groups\n}\n```",
            "```rust\npub fn truncate_number(num: f64) -> f64 {\n    num - num.floor()\n}\n```",
            "```rust\npub fn below_zero(operations: &Vec<i32>) -> bool {\n    let mut balance = 0;\n    for op in operations.iter() {\n        balance += *op;\n        if balance < 0 {\n            return true;\n        }\n    }\n    false\n}\n```",
            "```rust\npub fn mean_absolute_deviation(numbers: &Vec<f64>) -> f64 {\n    let sum: f64 = numbers.iter().sum();\n    let mean = sum / numbers.len() as f64;\n    \n    let deviation_sum: f64 = numbers.iter().map(|&num| (num - mean).abs()).sum();\n    \n    deviation_sum / numbers.len() as f64\n}\n```",
            "```rust\npub fn intersperse(numbers: &Vec<i32>, delimiter: i32) -> Vec<i32> {\n    let mut result = Vec::new();\n    for (i, &number) in numbers.iter().enumerate() {\n        if i != 0 {\n            result.push(delimiter);\n        }\n        result.push(number);\n    }\n    result\n}\n```",
            "```rust\npub fn parse_nested_parens(paren_string: &String) -> Vec<i32> {\n    let mut result = Vec::new();\n    for group in paren_string.split_ascii_whitespace() {\n        let mut max_depth = 0;\n        let mut depth = 0;\n        for ch in group.chars() {\n            if ch == '(' {\n                depth += 1;\n                max_depth = max_depth.max(depth);\n            } else if ch == ')' {\n                depth -= 1;\n            }\n        }\n        result.push(max_depth);\n    }\n    result\n}\n```",
            "```rust\npub fn filter_by_substring(strs: &Vec<String>, substring: &String) -> Vec<String> {\n    let mut result = Vec::new();\n    for s in strs {\n        if s.contains(substring) {\n            result.push(s.clone());\n        }\n    }\n    result\n}\n```",
            "```rust\npub fn sum_product(numbers: &Vec<i32>) -> Vec<i32> {\n    let n_sum = numbers.iter().sum();\n    let n_product = numbers.iter().fold(1, |x, y| x * y);\n    vec![n_sum, n_product]\n}\n```",
            "```rust\npub fn rolling_max(numbers: &Vec<i32>) -> Vec<i32> {\n    let mut max_so_far = i32::MIN;\n    let mut result = Vec::new();\n    for &num in numbers.iter() {\n        max_so_far = max_so_far.max(num);\n        result.push(max_so_far);\n    }\n    result\n}\n```",
            "```rust\npub fn make_palindrome(s: &String) -> String {\n    if is_palindrome(s) {\n        return s.clone();\n    }\n    for i in 0..s.len() {\n        if is_palindrome(&s[i..]) {\n            let prefix = &s[0..i];\n            let mut reversed_prefix = prefix.chars().rev().collect::<String>();\n            let mut result = s.clone();\n            result.push_str(&reversed_prefix);\n            return result;\n        }\n    }\n    String::new()\n}\n\nfn is_palindrome(s: &str) -> bool {\n    let chars: Vec<char> = s.chars().collect();\n    let mut left = 0;\n    let mut right = chars.len() - 1;\n    while left < right {\n        if chars[left] != chars[right] {\n            return false;\n        }\n        left += 1;\n        right -= 1;\n    }\n    true\n}\n```",
            "```rust\npub fn string_xor(a: &String, b: &String) -> String {\n    let mut result = String::new();\n    for (x, y) in a.chars().zip(b.chars()).take_while(|(_, _)| true) {\n        if x == y {\n            result.push('0');\n        } else {\n            result.push('1');\n        }\n    }\n    result\n}\n```",
            "```rust\npub fn longest(strs: &Vec<String>) -> Option<String> {\n    if strs.is_empty() {\n        return None;\n    }\n    let mut longest_s = strs[0].clone();\n    for s in strs {\n        if s.len() > longest_s.len() {\n            longest_s = s.clone();\n        }\n    }\n    Some(longest_s)\n}\n```",
            "```rust\npub fn greatest_common_divisor(mut a: i32, mut b: i32) -> i32 {\n    while b != 0 {\n        let temp = b;\n        b = a % b;\n        a = temp;\n    }\n    a\n}\n```",
            "```rust\npub fn all_prefixes(s: &String) -> Vec<String> {\n    let mut prefixes = Vec::new();\n    for i in 0..s.len() {\n        prefixes.push(s[0..=i].to_string());\n    }\n    prefixes\n}\n```",
            "```rust\npub fn string_sequence(n: i32) -> String {\n    let mut result = String::new();\n    for i in 0..=n {\n        result.push_str(&i.to_string());\n        if i < n {\n            result.push(' ');\n        }\n    }\n    result\n}\n```",
            "```rust\npub fn count_distinct_characters(s: &String) -> i32 {\n    s.to_lowercase()\n        .chars()\n        .collect::<std::collections::HashSet<_>>()\n        .len() as i32\n}\n```",
            "```rust\npub fn parse_music(music_string: &String) -> Vec<i32> {\n    let durations = vec![(\"o\", 4), (\"o|\", 2), (\".|\", 1)].into_iter().collect::<std::collections::HashMap<_, _>>();\n    music_string.split_whitespace()\n               .map(|note| *durations.get(note).unwrap_or(&0))\n               .collect()\n}\n```",
            "```rust\npub fn how_many_times(s: &String, substring: &String) -> i32 {\n    let mut times = 0;\n    for i in 0..=s.len() - substring.len() {\n        if &s[i..i + substring.len()] == substring {\n            times += 1;\n        }\n    }\n    times\n}\n```",
            "```rust\nuse std::collections::HashMap;\nuse std::cmp::Ordering;\n\npub fn sort_numbers(numbers: &String) -> String {\n    let mut num_dict = HashMap::new();\n    num_dict.insert(\"zero\", 0);\n    num_dict.insert(\"one\", 1);\n    num_dict.insert(\"two\", 2);\n    num_dict.insert(\"three\", 3);\n    num_dict.insert(\"four\", 4);\n    num_dict.insert(\"five\", 5);\n    num_dict.insert(\"six\", 6);\n    num_dict.insert(\"seven\", 7);\n    num_dict.insert(\"eight\", 8);\n    num_dict.insert(\"nine\", 9);\n\n    let mut num_list: Vec<&str> = numbers.split_whitespace()\n        .filter(|&num| num_dict.contains_key(num))\n        .collect();\n\n    num_list.sort_by(|a, b| {\n        num_dict.get(a).cmp(&num_dict.get(b))\n    });\n\n    num_list.join(\" \")\n}\n```",
            "```rust\npub fn find_closest_elements(numbers: &Vec<f64>) -> Vec<f64> {\n    let mut sorted_numbers = numbers.clone();\n    sorted_numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());\n    let mut min_diff = f64::INFINITY;\n    let mut closest_pair = Vec::new();\n    for i in 1..sorted_numbers.len() {\n        let diff = sorted_numbers[i] - sorted_numbers[i - 1];\n        if diff < min_diff {\n            min_diff = diff;\n            closest_pair = vec![sorted_numbers[i - 1], sorted_numbers[i]];\n        }\n    }\n    closest_pair\n}\n```",
            "Here's the implementation of the `rescale_to_unit` function in Rust:\n\n```rust\npub fn rescale_to_unit(numbers: &Vec<f64>) -> Vec<f64> {\n    if numbers.is_empty() {\n        return vec![];\n    }\n\n    let min_num = *numbers.iter().fold(&f64::INFINITY, |a, b| a.min(b));\n    let max_num = *numbers.iter().fold(&f64::NEG_INFINITY, |a, b| a.max(b));\n\n    if min_num == max_num {\n        return vec![0.0; numbers.len()];\n    } else {\n        numbers\n            .iter()\n            .map(|&num| (num - min_num) / (max_num - min_num))\n            .collect()\n    }\n}\n```",
            "```rust\nuse std::any::Any;\n\npub fn filter_integers(values: &Vec<Box<dyn Any>>) -> Vec<i32> {\n    values.iter()\n          .filter(|x| x.is::<i32>())\n          .map(|x| *x.downcast_ref::<i32>().unwrap())\n          .collect()\n}\n```",
            "```rust\npub fn str_length(s: &String) -> i32 {\n    s.len() as i32\n}\n```",
            "```rust\npub fn largest_divisor(n: i32) -> i32 {\n    for i in 2..n {\n        if n % i == 0 {\n            return n / i;\n        }\n    }\n    1\n}\n```",
            "```rust\npub fn factorize(n: i32) -> Vec<i32> {\n    let mut factors = Vec::new();\n    let mut divisor = 2;\n    let mut number = n;\n    while divisor <= number {\n        if number % divisor == 0 {\n            factors.push(divisor);\n            number /= divisor;\n        } else {\n            divisor += 1;\n        }\n    }\n    factors\n}\n```",
            "```rust\npub fn remove_duplicates(numbers: &Vec<i32>) -> Vec<i32> {\n    use std::collections::HashMap;\n    \n    let mut counts = HashMap::new();\n    for &num in numbers {\n        *counts.entry(num).or_insert(0) += 1;\n    }\n    \n    let mut res = Vec::new();\n    for &num in numbers {\n        if *counts.get(&num).unwrap() == 1 {\n            res.push(num);\n        }\n    }\n    \n    res\n}\n```",
            "```rust\npub fn flip_case(s: &String) -> String {\n    let mut flipped = String::new();\n    for ch in s.chars() {\n        if !ch.is_alphabetic() {\n            flipped.push(ch);\n        } else if ch.is_lowercase() {\n            flipped.push(ch.to_ascii_uppercase());\n        } else if ch.is_uppercase() {\n            flipped.push(ch.to_ascii_lowercase());\n        }\n    }\n    flipped\n}\n```",
            "```rust\npub fn concatenate(strs: &Vec<String>) -> String {\n    let mut result = String::new();\n    for str in strs {\n        result.push_str(str);\n    }\n    result\n}\n```",
            "```rust\npub fn filter_by_prefix(strs: &Vec<String>, prefix_str: &String) -> Vec<String> {\n    strs.iter()\n        .filter(|s| s.starts_with(prefix_str))\n        .cloned()\n        .collect()\n}\n```",
            "```rust\npub fn get_positive(l: &Vec<i32>) -> Vec<i32> {\n    l.iter().filter(|&&num| num > 0).cloned().collect()\n}\n```",
            "```rust\npub fn is_prime(n: i32) -> bool {\n    if n < 2 {\n        return false;\n    }\n    for i in 2..=((n as f64).sqrt() as i32) {\n        if n % i == 0 {\n            return false;\n        }\n    }\n    true\n}\n```",
            "```rust\npub fn poly(xs: &Vec<i32>, x: f64) -> f64 {\n    let mut res = 0.0;\n    for (i, &coeff) in xs.iter().enumerate() {\n        res += coeff as f64 * x.powi(i as i32);\n    }\n    res\n}\n\npub fn find_zero(xs: &Vec<i32>) -> f64 {\n    let mut x1 = 1.0;\n    let mut x2 = -1.0;\n    while poly(xs, x1) * poly(xs, x2) > 0.0 {\n        x1 *= 2.0;\n        x2 *= 2.0;\n    }\n    while (x1 - x2).abs() > 1e-10 {\n        let mid = (x1 + x2) / 2.0;\n        if poly(xs, mid).abs() < 1e-10 {\n            return mid;\n        } else if poly(xs, mid) * poly(xs, x1) < 0.0 {\n            x2 = mid;\n        } else {\n            x1 = mid;\n        }\n    }\n    (x1 + x2) / 2.0\n}\n```",
            "```rust\npub fn sort_third(l: &Vec<i32>) -> Vec<i32> {\n    let mut result = vec![0; l.len()];\n    let third_elements: Vec<_> = l.iter().enumerate()\n        .filter_map(|(i, &val)| if i % 3 == 0 { Some(val) } else { None })\n        .collect();\n    let mut sorted_third = third_elements.clone();\n    sorted_third.sort_unstable();\n\n    for (i, &val) in l.iter().enumerate() {\n        if i % 3 == 0 {\n            result[i] = sorted_third[i / 3];\n        } else {\n            result[i] = val;\n        }\n    }\n\n    result\n}\n```",
            "```rust\npub fn list_unique(l: &Vec<i32>) -> Vec<i32> {\n    let mut set = l.iter().cloned().collect::<std::collections::HashSet<_>>();\n    let mut sorted_list: Vec<i32> = set.drain().collect();\n    sorted_list.sort();\n    sorted_list\n}\n```",
            "```rust\npub fn max_element(l: &Vec<i32>) -> i32 {\n    if l.is_empty() {\n        0\n    } else {\n        *l.iter().max().unwrap()\n    }\n}\n```",
            "```rust\npub fn fizz_buzz(n: i32) -> i32 {\n    let mut cnt = 0;\n    for i in 0..n {\n        if i % 11 == 0 || i % 13 == 0 {\n            let str_i = i.to_string();\n            for c in str_i.chars() {\n                if c == '7' {\n                    cnt += 1;\n                }\n            }\n        }\n    }\n    cnt\n}\n```",
            "```rust\npub fn sort_even(l: &Vec<i32>) -> Vec<i32> {\n    let mut sorted_even = l.iter().enumerate()\n        .filter(|&(i, _)| i % 2 == 0)\n        .map(|(_, &x)| x)\n        .collect::<Vec<i32>>();\n    sorted_even.sort_unstable();\n    \n    l.iter().enumerate()\n        .map(|(i, &x)| if i % 2 == 0 { sorted_even[i / 2] } else { x })\n        .collect()\n}\n```",
            "```rust\npub fn encode_cyclic(s: &String) -> String {\n    let mut result = String::new();\n    for i in (0..s.len()).step_by(3) {\n        if i + 3 > s.len() {\n            result.push_str(&s[i..]);\n        } else {\n            result.push_str(&s[i + 1..i + 3]);\n            result.push(s.chars().nth(i).unwrap());\n        }\n    }\n    result\n}\n\npub fn decode_cyclic(s: &String) -> String {\n    encode_cyclic(&encode_cyclic(s))\n}\n```",
            "```rust\nfn is_prime(n: i32) -> bool {\n    if n < 2 {\n        return false;\n    }\n    for i in 2..=((n as f64).sqrt() as i32) {\n        if n % i == 0 {\n            return false;\n        }\n    }\n    true\n}\n\npub fn prime_fib(n: i32) -> i32 {\n    let mut f = vec![0, 1];\n    let mut cnt = 0;\n    while cnt < n {\n        f[0] = f[1];\n        f[1] += f[0];\n        if is_prime(f[1]) {\n            cnt += 1;\n        }\n    }\n    f[1]\n}\n```",
            "```rust\npub fn triples_sum_to_zero(l: &Vec<i32>) -> bool {\n    for i in 0..l.len() {\n        for j in i + 1..l.len() {\n            for k in j + 1..l.len() {\n                if l[i] + l[j] + l[k] == 0 {\n                    return true;\n                }\n            }\n        }\n    }\n    false\n}\n```",
            "```rust\npub fn car_race_collision(n: i32) -> i32 {\n    n * n\n}\n```",
            "```rust\npub fn incr_list(l: &Vec<i32>) -> Vec<i32> {\n    let mut result = Vec::new();\n    for i in l {\n        result.push(i + 1);\n    }\n    result\n}\n```",
            "```rust\nuse std::collections::HashSet;\n\npub fn pairs_sum_to_zero(l: &Vec<i32>) -> bool {\n    let mut seen = HashSet::new();\n    for &num in l.iter() {\n        if seen.contains(&-num) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    false\n}\n```",
            "```rust\npub fn change_base(mut x: i32, bas: i32) -> String {\n    if x == 0 {\n        return \"0\".to_string();\n    }\n    let mut digits = Vec::new();\n    while x > 0 {\n        digits.push((x % bas) as u8 + b'0');\n        x /= bas;\n    }\n    digits.reverse();\n    String::from_utf8(digits).unwrap()\n}\n```",
            "```rust\npub fn triangle_area(a: i32, h: i32) -> f64 {\n    (a * h) as f64 / 2.0\n}\n```",
            "```rust\npub fn fib4(n: i32) -> i32 {\n    let mut fib = [0, 0, 2, 0];\n    for i in 4..=n {\n        fib[(i % 4) as usize] = fib[0] + fib[1] + fib[2] + fib[3];\n    }\n    fib[(n % 4) as usize]\n}\n```",
            "```rust\npub fn median(l: &Vec<f64>) -> f64 {\n    let mut sl = l.clone();\n    sl.sort_by(|a, b| a.partial_cmp(b).unwrap());\n    if l.len() % 2 != 0 {\n        sl[l.len() / 2]\n    } else {\n        (sl[l.len() / 2] + sl[l.len() / 2 - 1]) / 2.0\n    }\n}\n```",
            "```rust\npub fn is_palindrome(txt: &String) -> bool {\n    let n = txt.len();\n    for i in 0..n / 2 {\n        if txt.chars().nth(i).unwrap() != txt.chars().nth(n - 1 - i).unwrap() {\n            return false;\n        }\n    }\n    true\n}\n```",
            "```rust\npub fn modp(n: i32, p: i32) -> i32 {\n    let mut ret = 1;\n    for _ in 0..n {\n        ret = (ret * 2) % p;\n    }\n    ret\n}\n```",
            "```rust\npub fn encode_shift(s: &String) -> String {\n    let mut result = String::new();\n    for ch in s.chars() {\n        result.push(((ch as u8 - b'a' + 5) % 26 + b'a') as char);\n    }\n    result\n}\n\npub fn decode_shift(s: &String) -> String {\n    let mut result = String::new();\n    for ch in s.chars() {\n        result.push(((ch as u8 - b'a' + 21) % 26 + b'a') as char);\n    }\n    result\n}\n```",
            "```rust\npub fn remove_vowels(txt: &String) -> String {\n    let vowels = \"aeiouAEIOU\";\n    let mut result = String::new();\n    for c in txt.chars() {\n        if !vowels.contains(c) {\n            result.push(c);\n        }\n    }\n    result\n}\n```",
            "```rust\npub fn below_threshold(l: &Vec<i32>, t: i32) -> bool {\n    for &x in l.iter() {\n        if x >= t {\n            return false;\n        }\n    }\n    true\n}\n```",
            "```rust\npub fn add(x: i32, y: i32) -> i32 {\n    x + y\n}\n```",
            "```rust\nfn to_char_vec(s: &str) -> Vec<char> {\n    s.chars().collect()\n}\n\npub fn same_chars(s0: &String, s1: &String) -> bool {\n    let set0: std::collections::HashSet<char> = to_char_vec(s0).into_iter().collect();\n    let set1: std::collections::HashSet<char> = to_char_vec(s1).into_iter().collect();\n    set0 == set1\n}\n```",
            "```rust\npub fn fib(n: i32) -> i32 {\n    if n <= 1 {\n        n\n    } else {\n        fib(n - 1) + fib(n - 2)\n    }\n}\n```",
            "```rust\npub fn correct_bracketing(brackets: &str) -> bool {\n    let mut depth = 0;\n    for b in brackets.chars() {\n        if b == '<' {\n            depth += 1;\n        } else if b == '>' {\n            depth -= 1;\n        }\n        if depth < 0 {\n            return false;\n        }\n    }\n    depth == 0\n}\n```",
            "```rust\npub fn monotonic(l: &Vec<i32>) -> bool {\n    if l.len() <= 1 {\n        return true;\n    }\n\n    let n = l.len();\n    let mut non_decreasing = true;\n    let mut non_increasing = true;\n\n    for i in 0..n - 1 {\n        if l[i] > l[i + 1] {\n            non_decreasing = false;\n        }\n        if l[i] < l[i + 1] {\n            non_increasing = false;\n        }\n    }\n\n    non_decreasing || non_increasing\n}\n```",
            "```rust\npub fn common(l1: &Vec<i32>, l2: &Vec<i32>) -> Vec<i32> {\n    let set1: std::collections::HashSet<i32> = l1.iter().cloned().collect();\n    let set2: std::collections::HashSet<i32> = l2.iter().cloned().collect();\n    let common_elements: Vec<i32> = set1.intersection(&set2).cloned().collect();\n    let mut result = common_elements;\n    result.sort_unstable();\n    result\n}\n```",
            "```rust\npub fn largest_prime_factor(mut n: i32) -> i32 {\n    let mut i = 2;\n    while i * i <= n {\n        if n % i != 0 {\n            i += 1;\n        } else {\n            n /= i;\n        }\n    }\n    n\n}\n```",
            "```rust\npub fn sum_to_n(n: i32) -> i32 {\n    let mut sum = 0;\n    for i in 1..=n {\n        sum += i;\n    }\n    sum\n}\n```",
            "```rust\npub fn correct_bracketing(brackets: &String) -> bool {\n    let mut depth = 0;\n    for b in brackets.chars() {\n        if b == '(' {\n            depth += 1;\n        } else if b == ')' {\n            depth -= 1;\n        }\n        if depth < 0 {\n            return false;\n        }\n    }\n    depth == 0\n}\n```",
            "```rust\npub fn derivative(xs: &Vec<i32>) -> Vec<i32> {\n    let mut result = Vec::new();\n    for i in 1..xs.len() {\n        result.push(xs[i] * i as i32);\n    }\n    result\n}\n```",
            "```rust\npub fn fibfib(n: i32) -> i32 {\n    if n <= 1 {\n        return 0;\n    }\n    let mut a = 0;\n    let mut b = 0;\n    let mut c = 1;\n    let mut m = n - 2;\n    while m > 0 {\n        let temp = a + b + c;\n        a = b;\n        b = c;\n        c = temp;\n        m -= 1;\n    }\n    return c;\n}\n```",
            "```rust\npub fn vowels_count(s: &String) -> i32 {\n    let vowels = \"aeiou\";\n    let mut cnt = 0;\n    for c in s.chars() {\n        let lower_c = c.to_lowercase().next().unwrap();\n        if vowels.contains(lower_c)\n            || (c == 'y' || c == 'Y') && s.len() - 1 == (s.chars().count() - 1) {\n                cnt += 1;\n        }\n    }\n    cnt\n}\n```",
            "```rust\npub fn circular_shift(x: i32, shift: i32) -> String {\n    let x_str = x.to_string();\n    if shift > x_str.len() as i32 {\n        x_str.chars().rev().collect()\n    } else {\n        let shift = shift as usize;\n        let n = x_str.len();\n        format!(\"{}{}\", &x_str[n - shift..], &x_str[..n - shift])\n    }\n}\n```",
            "```rust\npub fn digit_sum(s: &String) -> i32 {\n    let mut sum = 0;\n    for c in s.chars() {\n        if c.is_ascii_uppercase() {\n            sum += c as i32;\n        }\n    }\n    sum\n}\n```",
            "```rust\npub fn fruit_distribution(s: &str, n: i32) -> i32 {\n    let words: Vec<&str> = s.split_whitespace().collect();\n    let apples_index = words.iter().position(|&word| word == \"apples\").unwrap() - 1;\n    let oranges_index = words.iter().position(|&word| word == \"oranges\").unwrap() - 1;\n    let apples = words[apples_index].parse::<i32>().unwrap();\n    let oranges = words[oranges_index].parse::<i32>().unwrap();\n    n - apples - oranges\n}\n```",
            "```rust\npub fn pluck(arr: &Vec<i32>) -> Vec<i32> {\n    let mut evens: Vec<i32> = arr.iter().filter(|&&n| n % 2 == 0).cloned().collect();\n    if evens.is_empty() {\n        return vec![];\n    }\n    let min_even = evens.iter().min().unwrap();\n    let index = arr.iter().position(|&n| n == *min_even).unwrap();\n    vec![*min_even, index as i32]\n}\n```",
            "```rust\nuse std::collections::HashMap;\n\npub fn search(lst: &Vec<i32>) -> i32 {\n    let mut freqs = HashMap::new();\n    for &n in lst.iter() {\n        *freqs.entry(n).or_insert(0) += 1;\n    }\n    let mut good_vals = Vec::new();\n    for (&key, &value) in freqs.iter() {\n        if value >= key {\n            good_vals.push(key);\n        }\n    }\n    *good_vals.iter().max().unwrap_or(&-1)\n}\n```",
            "```rust\npub fn strange_sort_list(lst: &Vec<i32>) -> Vec<i32> {\n    let mut sl = lst.clone();\n    sl.sort_unstable();\n    let mut result = Vec::new();\n    let (mut left, mut right) = (0, sl.len() - 1);\n    while left <= right {\n        result.push(sl[left]);\n        left += 1;\n        if left <= right {\n            result.push(sl[right]);\n            right -= 1;\n        }\n    }\n    result\n}\n```",
            "```rust\npub fn triangle_area(a: i32, b: i32, c: i32) -> f64 {\n    if a + b > c && a + c > b && b + c > a {\n        let s = (a + b + c) as f64 / 2.0;\n        (s * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt()\n    } else {\n        -1.0\n    }\n}\n```",
            "```rust\npub fn will_it_fly(q: &Vec<i32>, w: i32) -> bool {\n    if q.is_empty() {\n        return false;\n    }\n    let is_palin = (0..q.len()).all(|i| q[i] == q[q.len() - i - 1]);\n    let total: i32 = q.iter().sum();\n    is_palin && total <= w\n}\n```",
            "```rust\npub fn smallest_change(arr: &Vec<i32>) -> i32 {\n    let mut ans = 0;\n    for i in 0..arr.len() / 2 {\n        if arr[i] != arr[arr.len() - i - 1] {\n            ans += 1;\n        }\n    }\n    ans\n}\n```",
            "```rust\npub fn total_match(lst1: &Vec<String>, lst2: &Vec<String>) -> Vec<String> {\n    let cnt1 = lst1.iter().map(|s| s.len()).sum::<usize>();\n    let cnt2 = lst2.iter().map(|s| s.len()).sum::<usize>();\n    if cnt1 <= cnt2 { lst1.clone() } else { lst2.clone() }\n}\n```",
            "```rust\npub fn is_multiply_prime(mut a: i32) -> bool {\n    let mut cnt = 0;\n    for i in 2..=((a as f64).sqrt() as i32) {\n        if a % i == 0 {\n            while a % i == 0 {\n                cnt += 1;\n                a /= i;\n            }\n        }\n    }\n    if a > 1 {\n        cnt += 1;\n    }\n    cnt == 3\n}\n```",
            "```rust\npub fn is_simple_power(x: i32, n: i32) -> bool {\n    if n < 2 {\n        return x == n;\n    }\n    let mut tmp = 1;\n    while tmp < x {\n        tmp *= n;\n    }\n    tmp == x\n}\n```",
            "```rust\npub fn is_cube(a: i32) -> bool {\n    let a = a.abs();\n    let root = ((a as f64).cbrt().round()) as i32;\n    root * root * root == a\n}\n```",
            "```rust\npub fn hex_key(num: &String) -> i32 {\n    let mut count = 0;\n    for x in num.chars() {\n        if \"2357BD\".contains(x) {\n            count += 1;\n        }\n    }\n    count\n}\n```",
            "```rust\npub fn decimal_to_binary(dec: i32) -> String {\n    format!(\"db{}db\", format!(\"{:b}\", dec))\n}\n```",
            "pub fn is_happy(s: &String) -> bool {\n    if s.len() < 3 {\n        return false;\n    }\n    for i in 0..s.len() - 2 {\n        let bytes = s.as_bytes();\n        if bytes[i] == bytes[i + 1] || bytes[i] == bytes[i + 2] || bytes[i + 1] == bytes[i + 2] {\n            return false;\n        }\n    }\n    true\n}",
            "```rust\npub fn numerical_letter_grade(grades: &Vec<f64>) -> Vec<String> {\n    let mut result = Vec::new();\n    for &g in grades {\n        if g == 4.0 {\n            result.push(\"A+\".to_string());\n        } else if g > 3.7 {\n            result.push(\"A\".to_string());\n        } else if g > 3.3 {\n            result.push(\"A-\".to_string());\n        } else if g > 3.0 {\n            result.push(\"B+\".to_string());\n        } else if g > 2.7 {\n            result.push(\"B\".to_string());\n        } else if g > 2.3 {\n            result.push(\"B-\".to_string());\n        } else if g > 2.0 {\n            result.push(\"C+\".to_string());\n        } else if g > 1.7 {\n            result.push(\"C\".to_string());\n        } else if g > 1.3 {\n            result.push(\"C-\".to_string());\n        } else if g > 1.0 {\n            result.push(\"D+\".to_string());\n        } else if g > 0.7 {\n            result.push(\"D\".to_string());\n        } else if g > 0.0 {\n            result.push(\"D-\".to_string());\n        } else {\n            result.push(\"E\".to_string());\n        }\n    }\n    result\n}\n```",
            "```rust\npub fn prime_length(s: &String) -> bool {\n    let length = s.len();\n    if length < 2 {\n        return false;\n    }\n    for i in 2..=(length as f64).sqrt() as usize {\n        if length % i == 0 {\n            return false;\n        }\n    }\n    true\n}\n```",
            "```rust\npub fn starts_one_ends(n: i32) -> i32 {\n    if n == 1 {\n        return 1;\n    }\n    return 2 * 9 * 10_i32.pow((n - 2) as u32);\n}\n```",
            "```rust\nfn solve(n: i32) -> String {\n    let mut digits_sum = 0;\n    let mut num = n;\n    while num > 0 {\n        digits_sum += num % 10;\n        num /= 10;\n    }\n    format!(\"{:b}\", digits_sum)\n}\n```",
            "```rust\npub fn add(lst: &Vec<i32>) -> i32 {\n    let mut sum = 0;\n    for (i, &x) in lst.iter().enumerate() {\n        if i % 2 == 1 && x % 2 == 0 {\n            sum += x;\n        }\n    }\n    sum\n}\n```",
            "```rust\npub fn anti_shuffle(s: &String) -> String {\n    s.split_whitespace()\n        .map(|word| {\n            let mut chars: Vec<char> = word.chars().collect();\n            chars.sort_unstable();\n            chars.into_iter().collect::<String>()\n        })\n        .collect::<Vec<String>>()\n        .join(\" \")\n}\n```",
            "```rust\npub fn get_row(lst: &Vec<Vec<i32>>, x: i32) -> Vec<Vec<i32>> {\n    let mut coords = Vec::new();\n    for (i, row) in lst.iter().enumerate() {\n        for (j, &val) in row.iter().enumerate() {\n            if val == x {\n                let coord = vec![i as i32, j as i32];\n                coords.push(coord);\n            }\n        }\n    }\n    coords.sort_by(|a, b| a[0].cmp(&b[0]).then_with(|| b[1].cmp(&a[1])));\n    coords\n}\n```",
            "```rust\npub fn sort_array(arr: &Vec<i32>) -> Vec<i32> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let sum = arr[0] + arr[arr.len() - 1];\n    if sum % 2 == 0 {\n        let mut sorted_arr = arr.clone();\n        sorted_arr.sort_by(|a, b| b.cmp(a));\n        sorted_arr\n    } else {\n        let mut sorted_arr = arr.clone();\n        sorted_arr.sort();\n        sorted_arr\n    }\n}\n```",
            "```rust\npub fn encrypt(s: &String) -> String {\n    let mut result = String::new();\n    for ch in s.chars() {\n        if ch.is_ascii_alphabetic() && ch.is_ascii_lowercase() {\n            let shifted = ((ch as u8 - b'a' + 4) % 26) + b'a';\n            result.push(shifted as char);\n        } else {\n            result.push(ch);\n        }\n    }\n    result\n}\n```",
            "```rust\npub fn next_smallest(lst: &Vec<i32>) -> Option<i32> {\n    let mut set = lst.iter().collect::<std::collections::HashSet<_>>();\n    let mut sl: Vec<i32> = set.into_iter().collect();\n    sl.sort_unstable();\n    if sl.len() < 2 {\n        None\n    } else {\n        Some(sl[1])\n    }\n}\n```",
            "```rust\npub fn is_bored(s: &String) -> i32 {\n    let sentences = s.split(&['.', '!', '?'][..]).map(|s| s.trim()).filter(|&s| !s.is_empty());\n    let mut count = 0;\n    for sentence in sentences {\n        if sentence.len() >= 2 && sentence.starts_with(\"I \") {\n            count += 1;\n        }\n    }\n    count\n}\n```",
            "```rust\npub fn any_int(x: &Box<dyn std::any::Any>, y: &Box<dyn std::any::Any>, z: &Box<dyn std::any::Any>) -> bool {\n    if let (Some(&int_x), Some(&int_y), Some(&int_z)) = (\n        x.downcast_ref::<i32>(),\n        y.downcast_ref::<i32>(),\n        z.downcast_ref::<i32>(),\n    ) {\n        return int_x + int_y == int_z || int_x + int_z == int_y || int_y + int_z == int_x;\n    }\n    false\n}\n```",
            "```rust\npub fn encode(message: &String) -> String {\n    let vowels = \"aeiouAEIOU\";\n    let mut result = String::new();\n    for ch in message.chars() {\n        if ch.is_alphabetic() {\n            let ch1 = if ch.is_lowercase() { ch.to_ascii_uppercase() } else { ch.to_ascii_lowercase() };\n            if vowels.contains(ch1) {\n                if let Some(vowel_index) = vowels.find(ch1) {\n                    let next_char = std::char::from_u32((ch1 as u32 + 2).min(0x7F)).unwrap();\n                    result.push(next_char);\n                }\n            } else {\n                result.push(ch1);\n            }\n        } else {\n            result.push(ch);\n        }\n    }\n    result\n}\n```",
            "```rust\npub fn skjkasdkd(lst: &Vec<i32>) -> i32 {\n    let mut primes = Vec::new();\n    for &n in lst.iter() {\n        if is_prime(n) {\n            primes.push(n);\n        }\n    }\n    if primes.is_empty() {\n        return 0;\n    }\n    let largest = *primes.iter().max().unwrap();\n    let sum: i32 = largest.to_string().chars().map(|digit| digit.to_digit(10).unwrap() as i32).sum();\n    sum\n}\n\nfn is_prime(n: i32) -> bool {\n    if n < 2 {\n        return false;\n    }\n    for i in 2..=((n as f64).sqrt() as i32) {\n        if n % i == 0 {\n            return false;\n        }\n    }\n    true\n}\n```",
            "```rust\nuse std::collections::HashMap;\n\npub fn check_dict_case(d: &HashMap<String, String>) -> bool {\n    if d.is_empty() {\n        return false;\n    }\n    let all_lower = d.keys().all(|k| k.chars().all(char::is_lowercase));\n    let all_upper = d.keys().all(|k| k.chars().all(char::is_uppercase));\n    all_lower || all_upper\n}\n```",
            "```rust\npub fn count_up_to(n: i32) -> Vec<i32> {\n    let mut primes = Vec::new();\n    for num in 2..n {\n        let mut is_prime = true;\n        for &p in &primes {\n            if num % p == 0 {\n                is_prime = false;\n                break;\n            }\n        }\n        if is_prime {\n            primes.push(num);\n        }\n    }\n    primes\n}\n```",
            "```rust\npub fn multiply(a: i32, b: i32) -> i32 {\n    (a.abs() % 10) * (b.abs() % 10)\n}\n```",
            "```rust\npub fn count_upper(s: &String) -> i32 {\n    let vowels = \"AEIOU\";\n    let mut count = 0;\n    for (i, c) in s.chars().enumerate() {\n        if i % 2 == 0 && vowels.contains(c) {\n            count += 1;\n        }\n    }\n    count\n}\n```",
            "```rust\npub fn closest_integer(value: &String) -> i32 {\n    let num: f64 = value.parse().unwrap();\n    if num >= 0.0 {\n        (num + 0.5) as i32\n    } else {\n        (num - 0.5) as i32\n    }\n}\n```",
            "```rust\npub fn make_a_pile(n: i32) -> Vec<i32> {\n    let mut pile = Vec::new();\n    for i in 0..n {\n        pile.push(n + 2 * i);\n    }\n    pile\n}\n```",
            "```rust\npub fn words_string(s: &String) -> Vec<String> {\n    s.split(|c: char| c == ',' || c == ' ')\n        .filter_map(|w| if w.len() > 0 { Some(w.to_string()) } else { None })\n        .collect()\n}\n```",
            "```rust\npub fn choose_num(x: i32, y: i32) -> i32 {\n    if x > y {\n        -1\n    } else if y % 2 == 0 {\n        y\n    } else if x != y {\n        y - 1\n    } else {\n        -1\n    }\n}\n```",
            "```rust\npub fn rounded_avg(n: i32, m: i32) -> Option<String> {\n    if n > m {\n        return None;\n    }\n    let rAvg = ((m + n) as f64 / 2.0 + 0.5) as i32;\n    Some(format!(\"{:b}\", rAvg))\n}\n```",
            "```rust\nfn all_digits_odd(s: &str) -> bool {\n    for c in s.chars() {\n        if let Some(digit) = c.to_digit(10) {\n            if digit % 2 == 0 {\n                return false;\n            }\n        }\n    }\n    true\n}\n\npub fn unique_digits(x: &Vec<i32>) -> Vec<i32> {\n    x.iter()\n        .filter(|&&num| all_digits_odd(&num.to_string()))\n        .cloned()\n        .collect::<Vec<_>>()\n}\n```",
            "```rust\npub fn by_length(arr: &Vec<i32>) -> Vec<String> {\n    let digit_names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"];\n    arr.iter()\n        .filter(|&&x| x >= 1 && x <= 9)\n        .sorted_by(|a, b| b.cmp(a))\n        .map(|&x| digit_names[(x - 1) as usize].to_string())\n        .collect()\n}\n```",
            "```rust\nuse std::iter;\n\npub fn f(n: i32) -> Vec<i32> {\n    let nums: Vec<i32> = (1..=n).collect();\n    nums.iter().map(|&i| {\n        if i % 2 != 0 {\n            nums.iter().take(i as usize).sum()\n        } else {\n            nums.iter().take(i as usize).product()\n        }\n    }).collect()\n}\n```",
            "```rust\nfn is_palindrome(txt: &str) -> bool {\n    txt.chars().eq(txt.chars().rev())\n}\n\npub fn even_odd_palindrome(n: i32) -> Vec<i32> {\n    let mut cnt = vec![0, 0];\n    for i in 1..=n {\n        if is_palindrome(&i.to_string()) {\n            cnt[(i % 2) as usize] += 1;\n        }\n    }\n    cnt\n}\n```",
            "```rust\nfn digits_sum(n: i32) -> i32 {\n    let n_str = n.to_string();\n    if n >= 0 {\n        n_str.chars().map(|c| c.to_digit(10).unwrap() as i32).sum()\n    } else {\n        (n_str[0..2].parse::<i32>().unwrap()) * 2 + digits_sum(n.abs())\n    }\n}\n\npub fn count_nums(arr: &Vec<i32>) -> i32 {\n    arr.iter().filter(|&&n| digits_sum(n) > 0).count() as i32\n}\n```",
            "```rust\npub fn move_one_ball(arr: &Vec<i32>) -> bool {\n    if arr.is_empty() {\n        return true;\n    }\n    let mut sorted_arr = arr.clone();\n    sorted_arr.sort();\n    for i in 0..arr.len() {\n        if arr[i..] == sorted_arr[sorted_arr.len() - arr.len() + i..] &&\n           arr[..i] == sorted_arr[arr.len() - i..] {\n            return true;\n        }\n    }\n    false\n}\n```",
            "```rust\npub fn can_exchange(lst1: &Vec<i32>, lst2: &Vec<i32>) -> String {\n    let odd_cnt = lst1.iter().filter(|&&num| num % 2 != 0).count();\n    let even_cnt = lst2.iter().filter(|&&num| num % 2 == 0).count();\n    \n    if even_cnt >= odd_cnt {\n        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n    }\n}\n```",
            "```rust\nuse std::collections::HashMap;\n\npub fn histogram(test: &String) -> HashMap<String, i32> {\n    let mut freq = HashMap::new();\n    let words: Vec<&str> = test.split_whitespace().filter(|w| !w.is_empty()).collect();\n    for w in words {\n        *freq.entry(w.to_string()).or_insert(0) += 1;\n    }\n    let mut result = HashMap::new();\n    if let Some(&max_freq) = freq.values().max() {\n        for (k, &v) in &freq {\n            if v == max_freq {\n                result.insert(k.clone(), v);\n            }\n        }\n    }\n    result\n}\n```",
            "```rust\npub fn reverse_delete(s: &String, c: &String) -> Vec<String> {\n    let mut s1 = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch.to_string()) {\n            s1.push(ch);\n        }\n    }\n    let result_string = s1.clone();\n    let palindrome_check = result_string.chars().rev().collect::<String>();\n    let mut resultList = Vec::new();\n    resultList.push(result_string);\n    resultList.push(if palindrome_check == s1 { \"yes\".to_string() } else { \"no\".to_string() });\n    resultList\n}\n```",
            "```rust\npub fn odd_count(lst: &Vec<String>) -> Vec<String> {\n    let mut result = Vec::new();\n    for num in lst.iter() {\n        let n = num.chars().filter(|&d| d.to_digit(10).unwrap_or(0) % 2 == 1).count();\n        let rs = \"the number of odd elements in the string i of the input.\";\n        result.push(rs.replace(\"i\", &n.to_string()));\n    }\n    result\n}\n```",
            "```rust\nimpl Global {\n    pub fn min_sub_array_sum(nums: &Vec<i32>) -> i32 {\n        let mut min_sum = 0;\n        let mut cur_sum = 0;\n        for &n in nums.iter() {\n            cur_sum = std::cmp::min(cur_sum + n, 0);\n            min_sum = std::cmp::min(cur_sum, min_sum);\n        }\n        if min_sum == 0 {\n            min_sum = *nums.iter().min().unwrap();\n        }\n        min_sum\n    }\n}\n```",
            "```rust\npub fn max_fill(grid: &Vec<Vec<i32>>, capacity: i32) -> i32 {\n    let mut total = 0;\n    for arr in grid {\n        let sum: i32 = arr.iter().sum();\n        total += (sum as f64 / capacity as f64).ceil() as i32;\n    }\n    total\n}\n```",
            "```rust\nfn count_ones(num: i32) -> usize {\n    num.count_ones() as usize\n}\n\npub fn sort_array(arr: &Vec<i32>) -> Vec<i32> {\n    let mut arr = arr.clone();\n    arr.sort_by_key(|&x| (count_ones(x), x));\n    arr\n}\n```",
            "```rust\npub fn select_words(s: &str, n: i32) -> Vec<String> {\n    let consonants = \"bcdfghjklmnpqrstvwxyz\";\n    s.split_whitespace()\n     .filter(|&w| !w.is_empty())\n     .filter(|&w| w.chars().filter(|c| consonants.contains(c.to_ascii_lowercase())).count() as i32 == n)\n     .map(String::from)\n     .collect()\n}\n```",
            "```rust\npub fn get_closest_vowel(word: &String) -> String {\n    let vowels = \"aeiouAEIOU\";\n    for (i, c) in word.char_indices().rev() {\n        if i > 0 && i < word.len() - 1 {\n            if vowels.contains(c)\n                && !vowels.contains(&word.chars().nth(i - 1).unwrap())\n                && !vowels.contains(&word.chars().nth(i + 1).unwrap())\n            {\n                return c.to_string();\n            }\n        }\n    }\n    String::new()\n}\n```",
            "```rust\npub fn match_parens(lst: &Vec<String>) -> String {\n    let s1 = lst[0].clone() + &lst[1];\n    let s2 = lst[1].clone() + &lst[0];\n    if check(&s1) || check(&s2) {\n        \"Yes\".to_string()\n    } else {\n        \"No\".to_string()\n    }\n}\n\nfn check(s: &str) -> bool {\n    let mut depth = 0;\n    for ch in s.chars() {\n        match ch {\n            '(' => depth += 1,\n            ')' => depth -= 1,\n            _ => {}\n        }\n        if depth < 0 {\n            return false;\n        }\n    }\n    depth == 0\n}\n```",
            "```rust\npub fn maximum(arr: &Vec<i32>, k: i32) -> Vec<i32> {\n    if k == 0 {\n        return vec![];\n    }\n    let mut sorted_arr = arr.clone();\n    sorted_arr.sort_unstable();\n    sorted_arr.split_off(arr.len() as usize - k as usize)\n}\n```",
            "```rust\npub fn solution(lst: &Vec<i32>) -> i32 {\n    let mut sum = 0;\n    for (i, &x) in lst.iter().enumerate() {\n        if i % 2 == 0 && x % 2 != 0 {\n            sum += x;\n        }\n    }\n    sum\n}\n```",
            "```rust\npub fn add_elements(arr: &Vec<i32>, k: i32) -> i32 {\n    let mut sum = 0;\n    for i in 0..(k.min(arr.len() as i32)) {\n        if arr[i as usize].to_string().len() <= 2 {\n            sum += arr[i as usize];\n        }\n    }\n    sum\n}\n```",
            "```rust\npub fn get_odd_collatz(mut n: i32) -> Vec<i32> {\n    let mut collatz = vec![1];\n    while n != 1 {\n        if n % 2 != 0 {\n            collatz.push(n);\n            n = 3 * n + 1;\n        } else {\n            n /= 2;\n        }\n    }\n    collatz.sort();\n    collatz\n}\n```",
            "```rust\npub fn valid_date(date: &str) -> bool {\n    if date.len() != 10 || date.chars().nth(2).unwrap() != '-' || date.chars().nth(5).unwrap() != '-' {\n        return false;\n    }\n    let m = date[0..2].parse::<i32>().unwrap();\n    let d = date[3..5].parse::<i32>().unwrap();\n    if (m == 1 || m == 3 || m == 5 || m == 7 || m == 8 || m == 10 || m == 12) && d >= 1 && d <= 31 {\n        return true;\n    }\n    if (m == 4 || m == 6 || m == 9 || m == 11) && d >= 1 && d <= 30 {\n        return true;\n    }\n    if m == 2 && d >= 1 && d <= 29 {\n        return true;\n    }\n    false\n}\n```",
            "```rust\npub fn split_words(txt: &String) -> Vec<String> {\n    if txt.contains(\" \") {\n        txt.split_whitespace().map(|s| s.to_string()).collect()\n    } else if txt.contains(\",\") {\n        txt.split(\",\").map(|s| s.to_string()).collect()\n    } else {\n        let count = txt.chars().filter(|&c| c.is_lowercase() && (c as u8) % 2 == 0).count();\n        vec![count.to_string()]\n    }\n}\n```",
            "```rust\nuse std::collections::HashMap;\n\npub fn is_sorted(lst: &Vec<i32>) -> bool {\n    if lst.len() < 2 {\n        return true;\n    }\n    for i in 1..lst.len() {\n        if lst[i - 1] > lst[i] {\n            return false;\n        }\n    }\n    let mut freq = HashMap::new();\n    for &num in lst {\n        *freq.entry(num).or_insert(0) += 1;\n    }\n    let max_freq = freq.values().max().unwrap_or(&0);\n    *max_freq <= 2\n}\n```",
            "```rust\nfn is_prime(n: i32) -> bool {\n    if n < 2 {\n        return false;\n    }\n    for i in 2..=((n as f64).sqrt() as i32) {\n        if n % i == 0 {\n            return false;\n        }\n    }\n    true\n}\n\npub fn intersection(interval1: &Vec<i32>, interval2: &Vec<i32>) -> String {\n    let l = i32::max(interval1[0], interval2[0]);\n    let r = i32::min(interval1[1], interval2[1]);\n    let length = r - l;\n    if is_prime(length) && length > 0 {\n        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n    }\n}\n```",
            "```rust\npub fn prod_signs(arr: &Vec<i32>) -> Option<i32> {\n    if arr.is_empty() {\n        return None;\n    }\n    if arr.contains(&0) {\n        return Some(0);\n    }\n    let sign = if arr.iter().filter(|&&n| n < 0).count() % 2 == 1 { -1 } else { 1 };\n    Some(sign * arr.iter().map(|&n| n.abs()).sum())\n}\n```",
            "```rust\npub fn min_path(grid: &Vec<Vec<i32>>, k: i32) -> Vec<i32> {\n    let n = grid.len();\n    let mut min_val = n * n + 1;\n    for i in 0..n {\n        for j in 0..n {\n            if grid[i][j] == 1 {\n                let mut temp = vec![];\n                if i != 0 {\n                    temp.push(grid[i - 1][j]);\n                }\n                if j != 0 {\n                    temp.push(grid[i][j - 1]);\n                }\n                if i != n - 1 {\n                    temp.push(grid[i + 1][j]);\n                }\n                if j != n - 1 {\n                    temp.push(grid[i][j + 1]);\n                }\n                min_val = *temp.iter().min().unwrap_or(&n as &i32);\n            }\n        }\n    }\n    let mut result = vec![];\n    for i in 0..k {\n        if i % 2 == 0 {\n            result.push(1);\n        } else {\n            result.push(min_val);\n        }\n    }\n    result\n}\n```",
            "```rust\npub fn tri(n: i32) -> Vec<i32> {\n    if n == 0 {\n        return vec![1];\n    }\n    let mut seq = vec![1, 3];\n    for i in 2..=n {\n        if i % 2 == 0 {\n            seq.push(i / 2 + 1);\n        } else {\n            let next_value = seq[(i - 1) as usize] + seq[(i - 2) as usize] + (i + 3) / 2;\n            seq.push(next_value);\n        }\n    }\n    seq\n}\n```",
            "```rust\npub fn digits(n: i32) -> i32 {\n    let num_str = n.to_string();\n    let mut product = 1;\n    let mut has_odd_digit = false;\n    \n    for c in num_str.chars() {\n        if let Some(digit) = c.to_digit(10) {\n            if digit % 2 == 1 {\n                product *= digit as i32;\n                has_odd_digit = true;\n            }\n        }\n    }\n    \n    if has_odd_digit { product } else { 0 }\n}\n```",
            "```rust\nfn is_nested(s: &String) -> bool {\n    let mut open_idx = Vec::new();\n    let mut close_idx = Vec::new();\n\n    for (i, ch) in s.chars().enumerate() {\n        if ch == '[' {\n            open_idx.push(i);\n        } else if ch == ']' {\n            close_idx.push(i);\n        }\n    }\n\n    close_idx.reverse();\n    let mut cnt = 0;\n    let mut i = 0;\n    let l = close_idx.len();\n\n    for &idx in &open_idx {\n        if i < l && idx < close_idx[i] {\n            cnt += 1;\n            i += 1;\n        }\n    }\n\n    cnt >= 2\n}\n```",
            "```rust\npub fn sum_squares(lst: &Vec<f64>) -> i32 {\n    lst.iter()\n        .map(|&n| ((n.ceil()) as i32).pow(2))\n        .sum()\n}\n```",
            "```rust\npub fn check_if_last_char_is_a_letter(txt: &String) -> bool {\n    if txt.is_empty() || txt.trim_end().is_empty() {\n        return false;\n    }\n    let last_space_index = txt.rfind(' ');\n    match last_space_index {\n        Some(index) => {\n            let last_part = &txt[index + 1..];\n            last_part.len() == 1 && last_part.chars().next().unwrap_or_default().is_alphabetic()\n        },\n        None => false,\n    }\n}\n```",
            "```rust\npub fn can_arrange(arr: &Vec<i32>) -> i32 {\n    if arr.len() <= 1 {\n        return -1;\n    }\n    let mut idx = -1;\n    for i in 1..arr.len() {\n        if arr[i] < arr[i - 1] {\n            idx = i as i32;\n        }\n    }\n    idx\n}\n```",
            "```rust\npub fn largest_smallest_integers(lst: &Vec<i32>) -> Vec<Option<i32>> {\n    let mut neg = vec![];\n    let mut pos = vec![];\n    \n    for &i in lst {\n        if i < 0 {\n            neg.push(i);\n        } else if i > 0 {\n            pos.push(i);\n        }\n    }\n    \n    let max_neg = if neg.is_empty() { None } else { Some(*neg.iter().max().unwrap()) };\n    let min_pos = if pos.is_empty() { None } else { Some(*pos.iter().min().unwrap()) };\n    \n    vec![max_neg, min_pos]\n}\n```",
            "```rust\npub fn compare_one(a: &Box<dyn Any>, b: &Box<dyn Any>) -> Option<f64> {\n    let a1 = any_to_real(a);\n    let b1 = any_to_real(b);\n    if a1 == b1 {\n        None\n    } else if a1 > b1 {\n        Some(a1)\n    } else {\n        Some(b1)\n    }\n}\n\nfn any_to_real(o: &Box<dyn Any>) -> f64 {\n    if let Some(s) = o.downcast_ref::<String>() {\n        s.replace(',', \".\").parse::<f64>().unwrap()\n    } else if let Some(i) = o.downcast_ref::<i32>() {\n        (*i) as f64\n    } else if let Some(d) = o.downcast_ref::<f64>() {\n        *d\n    } else {\n        panic!(\"Type Error\");\n    }\n}\n```",
            "```rust\npub fn is_equal_to_sum_even(n: i32) -> bool {\n    n % 2 == 0 && n >= 8\n}\n```",
            "```rust\npub fn special_factorial(n: i32) -> i32 {\n    let mut fact = 1;\n    let mut result = 1;\n    for i in 1..=n {\n        fact *= i;\n        result *= fact;\n    }\n    result\n}\n```",
            "```rust\npub fn fix_spaces(txt: &String) -> String {\n    txt.replace(r\"\\s{3,}\", \"-\")\n      .replace(\" \", \"_\")\n}\n```",
            "```rust\nfn file_name_check(file_name: &str) -> &'static str {\n    let suf = [\"txt\", \"exe\", \"dll\"];\n    let lst: Vec<&str> = file_name.split('.').collect();\n\n    if lst.len() != 2 || !suf.iter().any(|&ext| ext == lst[1]) || lst[0].is_empty() || !lst[0].chars().next().unwrap_or('0').is_alphabetic() || lst[0].chars().filter(char::is_digit).count() > 3 {\n        return \"No\";\n    }\n    \n    \"Yes\"\n}\n```",
            "```rust\npub fn sum_squares(lst: &Vec<i32>) -> i32 {\n    let mut result = 0;\n    for (i, &x) in lst.iter().enumerate() {\n        if i % 3 == 0 {\n            result += x.pow(2);\n        } else if i % 4 == 0 {\n            result += x.pow(3);\n        } else {\n            result += x;\n        }\n    }\n    result\n}\n```",
            "```rust\npub fn words_in_sentence(sentence: &String) -> String {\n    let words = sentence.split_whitespace();\n    let mut result = Vec::new();\n\n    for word in words {\n        if is_prime(word.len()) {\n            result.push(word);\n        }\n    }\n\n    result.join(\" \")\n}\n\nfn is_prime(n: usize) -> bool {\n    if n < 2 {\n        return false;\n    }\n    for i in 2..=((n as f64).sqrt() as usize) {\n        if n % i == 0 {\n            return false;\n        }\n    }\n    true\n}\n```",
            "```rust\npub fn simplify(x: &String, n: &String) -> bool {\n    let xs: Vec<&str> = x.split('/').collect();\n    let ns: Vec<&str> = n.split('/').collect();\n    let num: i32 = xs[0].parse().unwrap() * ns[0].parse().unwrap();\n    let den: i32 = xs[1].parse().unwrap() * ns[1].parse().unwrap();\n    num % den == 0\n}\n```",
            "```rust\nfn digits_sum(n: i32) -> i32 {\n    let n_str = n.abs().to_string();\n    n_str.chars().map(|c| c.to_digit(10).unwrap() as i32).sum()\n}\n\npub fn order_by_points(nums: &Vec<i32>) -> Vec<i32> {\n    let mut nums_clone = nums.clone();\n    nums_clone.sort_by_key(digits_sum);\n    nums_clone\n}\n```",
            "```rust\npub fn special_filter(nums: &Vec<i32>) -> i32 {\n    let odds = \"13579\";\n    let mut count = 0;\n    for &n in nums {\n        if n > 10 && n % 2 == 1 && odds.contains(&n.to_string().chars().nth(0).unwrap()) {\n            count += 1;\n        }\n    }\n    count\n}\n```",
            "```rust\nfn get_max_triples(n: i32) -> i32 {\n    let mut c = [0, 0, 0];\n    for i in 1..=n {\n        let a = i * i - i + 1;\n        c[(a % 3) as usize] += 1;\n    }\n    c[0] * c[1] * c[2] + (c[0] * (c[0] - 1) * (c[0] - 2) + c[1] * (c[1] - 1) * (c[1] - 2) + c[2] * (c[2] - 1) * (c[2] - 2)) / 6\n}\n```",
            "```rust\npub fn bf(planet1: &String, planet2: &String) -> Vec<String> {\n    let names = vec![\n        \"Mercury\".to_string(),\n        \"Venus\".to_string(),\n        \"Earth\".to_string(),\n        \"Mars\".to_string(),\n        \"Jupiter\".to_string(),\n        \"Saturn\".to_string(),\n        \"Uranus\".to_string(),\n        \"Neptune\".to_string(),\n    ];\n    if !names.contains(planet1) || !names.contains(planet2) {\n        return Vec::new();\n    }\n    let l = names.iter().position(|&s| &s == planet1).unwrap();\n    let r = names.iter().position(|&s| &s == planet2).unwrap();\n    if l > r {\n        let temp = l;\n        l = r;\n        r = temp;\n    }\n    if l == r {\n        return Vec::new();\n    }\n    names.into_iter().skip(l + 1).take(r - l - 1).collect()\n}\n```",
            "```rust\npub fn sorted_list_sum(lst: &Vec<String>) -> Vec<String> {\n    let mut result: Vec<String> = lst.iter().filter(|&&s| s.len() % 2 == 0).cloned().collect();\n    result.sort_by(|x, y| x.len().cmp(&y.len()).then_with(|| x.cmp(y)));\n    result\n}\n```",
            "```rust\npub fn x_or_y(n: i32, x: i32, y: i32) -> i32 {\n    if n < 2 {\n        return y;\n    }\n    for i in 2..=((n as f64).sqrt() as i32) {\n        if n % i == 0 {\n            return y;\n        }\n    }\n    x\n}\n```",
            "```rust\npub fn double_the_difference(lst: &Vec<f64>) -> i32 {\n    lst.iter()\n        .filter(|&&n| n >= 0.0 && n.fract() == 0.5)\n        .map(|&n| (n * n) as f64)\n        .sum::<f64>() as i32\n}\n```",
            "```rust\npub fn compare(game: &Vec<i32>, guess: &Vec<i32>) -> Vec<i32> {\n    game.iter().zip(guess.iter()).map(|(&x, &y)| (x - y).abs()).collect()\n}\n```",
            "```rust\npub fn strongest_extension(class_name: &String, extensions: &Vec<String>) -> String {\n    let mut max_s = i32::MIN;\n    let mut max_ext = \"\";\n\n    for ext in extensions {\n        let mut upper = 0;\n        let mut lower = 0;\n\n        for c in ext.chars() {\n            if c.is_uppercase() {\n                upper += 1;\n            } else if c.is_lowercase() {\n                lower += 1;\n            }\n        }\n\n        let s = upper - lower;\n        if s > max_s {\n            max_s = s;\n            max_ext = ext;\n        }\n    }\n\n    format!(\"{}.{}\", class_name, max_ext)\n}\n```",
            "```rust\npub fn cycpattern_check(a: &String, b: &String) -> bool {\n    if a.len() < b.len() {\n        return false;\n    }\n    for i in 0..b.len() {\n        let rotated_b = format!(\"{}{}\", &b[i..], &b[..i]);\n        if a.contains(&rotated_b) {\n            return true;\n        }\n    }\n    false\n}\n```",
            "```rust\npub fn even_odd_count(num: i32) -> Vec<i32> {\n    let ds = num.abs().to_string();\n    let even = ds.chars().filter(|c| c.to_digit(10).unwrap() % 2 == 0).count() as i32;\n    vec![even, (ds.len() as i32) - even]\n}\n```",
            "```rust\npub fn int_to_mini_roman(num: i32) -> String {\n    let values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    let numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    let mut res = String::new();\n    let mut num = num;\n    for i in 0..values.len() {\n        while num >= values[i] {\n            res.push_str(numerals[i]);\n            num -= values[i];\n        }\n    }\n    res\n}\n```",
            "```rust\npub fn right_angle_triangle(mut a: i32, mut b: i32, mut c: i32) -> bool {\n    let mut s = [a, b, c];\n    s.sort();\n    s[0] * s[0] + s[1] * s[1] == s[2] * s[2]\n}\n```",
            "```rust\nuse std::collections::HashSet;\n\npub fn find_max(words: &Vec<String>) -> String {\n    let mut max_cnt = 0;\n    let mut max_w = \"\".to_string();\n    for w in words.iter() {\n        let unique_chars: HashSet<char> = w.chars().collect();\n        let cnt = unique_chars.len();\n        if cnt > max_cnt {\n            max_cnt = cnt;\n            max_w = w.clone();\n        } else if cnt == max_cnt {\n            max_w = min(&max_w, w);\n        }\n    }\n    max_w\n}\n\nfn min(a: &String, b: &String) -> String {\n    if a < b {\n        a.clone()\n    } else {\n        b.clone()\n    }\n}\n```",
            "```rust\npub fn eat(num: i32, need: i32, remaining: i32) -> Vec<i32> {\n    if need <= remaining {\n        vec![num + need, remaining - need]\n    } else {\n        vec![num + remaining, 0]\n    }\n}\n```",
            "```rust\npub fn do_algebra(operators: &Vec<String>, operands: &Vec<i32>) -> i32 {\n    let mut ops = operators.clone();\n    let mut nums = operands.clone();\n    let mut i = ops.len() - 1;\n    while i >= 0 {\n        if *ops.get(i).unwrap() == \"**\" {\n            let power = i32::pow(*nums.get(i).unwrap(), *nums.get(i + 1).unwrap());\n            nums[i] = power;\n            nums.remove(i + 1);\n            ops.remove(i);\n        }\n        i -= 1;\n    }\n    i = 0;\n    while i < ops.len() {\n        if *ops.get(i).unwrap() == \"*\" {\n            nums[i] *= nums[i + 1];\n            nums.remove(i + 1);\n            ops.remove(i);\n            i -= 1;\n        } else if *ops.get(i).unwrap() == \"//\" {\n            nums[i] /= nums[i + 1];\n            nums.remove(i + 1);\n            ops.remove(i);\n            i -= 1;\n        }\n        i += 1;\n    }\n    i = 0;\n    while i < ops.len() {\n        if *ops.get(i).unwrap() == \"+\" {\n            nums[i] += nums[i + 1];\n            nums.remove(i + 1);\n            ops.remove(i);\n            i -= 1;\n        } else if *ops.get(i).unwrap() == \"-\" {\n            nums[i] -= nums[i + 1];\n            nums.remove(i + 1);\n            ops.remove(i);\n            i -= 1;\n        }\n        i += 1;\n    }\n    nums[0]\n}\n```",
            "```rust\npub fn solve(s: &String) -> String {\n    if !s.chars().any(|c| c.is_alphabetic()) {\n        return s.chars().rev().collect();\n    }\n    let mut result = String::new();\n    for ch in s.chars() {\n        if !ch.is_alphabetic() {\n            result.push(ch);\n        } else if ch.is_uppercase() {\n            result.push(ch.to_lowercase().next().unwrap());\n        } else if ch.is_lowercase() {\n            result.push(ch.to_uppercase().next().unwrap());\n        }\n    }\n    result\n}\n```",
            "```rust\npub fn string_to_md5(txt: &String) -> Option<String> {\n    if txt.is_empty() {\n        return None;\n    }\n    let mut md5_hash = md5::Md5::new();\n    md5_hash.update(txt.as_bytes());\n    let md5_encoded = format!(\"{:x}\", md5_hash.finalize());\n    Some(md5_encoded)\n}\n```",
            "```rust\npub fn generate_integers(a: i32, b: i32) -> Vec<i32> {\n    let lower = std::cmp::max(2, std::cmp::min(a, b));\n    let upper = std::cmp::min(8, std::cmp::max(a, b));\n    let mut result = Vec::new();\n    for i in lower..=upper {\n        if i % 2 == 0 {\n            result.push(i);\n        }\n    }\n    result\n}\n```"
        ],
        "php": [
            "```php\n/**\n * @param {array<float>} $numbers\n * @param {float} $threshold\n * @returns {bool}\n */\nfunction hasCloseElements ($numbers, $threshold) {\n    for ($i = 0; $i < count($numbers); $i++) {\n        for ($j = $i + 1; $j < count($numbers); $j++) {\n            if (abs($numbers[$i] - $numbers[$j]) < $threshold) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```",
            "```php\n/**\n * @param {string} $parenString\n * @returns {array<string>}\n */\nfunction separateParenGroups($parenString) {\n    $groups = [];\n    $stk = [];\n    $currentGroup = \"\";\n    $parens = str_replace(\" \", \"\", $parenString);\n    for ($i = 0; $i < strlen($parens); $i++) {\n        $ch = $parens[$i];\n        if ($ch == \"(\") {\n            array_push($stk, $ch);\n            $currentGroup .= $ch;\n        } elseif ($ch == \")\") {\n            array_pop($stk);\n            $currentGroup .= $ch;\n            if (empty($stk)) {\n                $groups[] = $currentGroup;\n                $currentGroup = \"\";\n            }\n        }\n    }\n    return $groups;\n}\n```",
            "```php\n/**\n * @param {float} $num\n * @returns {float}\n */\nfunction truncateNumber($num) {\n    return $num - floor($num);\n}\n```",
            "```php\n/**\n * @param {array<int>} $operations\n * @returns {bool}\n */\nfunction belowZero ($operations) {\n    $balance = 0;\n    foreach ($operations as $op) {\n        $balance += $op;\n        if ($balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n```",
            "```php\n/**\n * @param {array<float>} $numbers\n * @returns {float}\n */\nfunction meanAbsoluteDeviation($numbers) {\n    $sum = 0;\n    foreach ($numbers as $num) {\n        $sum += $num;\n    }\n    $mean = $sum / count($numbers);\n    \n    $deviationSum = 0;\n    foreach ($numbers as $num) {\n        $deviationSum += abs($num - $mean);\n    }\n    \n    return $deviationSum / count($numbers);\n}\n```",
            "```php\n/**\n * @param {array<int>} $numbers\n * @param {int} $delimiter\n * @returns {array<int>}\n */\nfunction intersperse($numbers, $delimiter) {\n    $result = [];\n    for ($i = 0; $i < count($numbers); $i++) {\n        if ($i != 0) {\n            $result[] = $delimiter;\n        }\n        $result[] = $numbers[$i];\n    }\n    return $result;\n}\n```",
            "```php\n/**\n * @param {string} $parenString\n * @returns {array<int>}\n */\nfunction parseNestedParens($parenString) {\n    $result = [];\n    $parenGroups = explode(\" \", $parenString);\n    foreach ($parenGroups as $group) {\n        $maxDepth = 0;\n        $depth = 0;\n        for ($i = 0; $i < strlen($group); $i++) {\n            $ch = $group[$i];\n            if ($ch == '(') {\n                $depth += 1;\n                $maxDepth = max($maxDepth, $depth);\n            } elseif ($ch == ')') {\n                $depth -= 1;\n            }\n        }\n        array_push($result, $maxDepth);\n    }\n    return $result;\n}\n```",
            "```php\nfunction filterBySubstring ($strs, $substring) {\n    $result = [];\n    foreach ($strs as $s) {\n        if (strpos($s, $substring) !== false) {\n            $result[] = $s;\n        }\n    }\n    return $result;\n}\n```",
            "```php\n/**\n * @param {array<int>} $numbers\n * @returns {array<int>}\n */\nfunction sumProduct($numbers) {\n    $n_sum = array_sum($numbers);\n    $n_product = array_reduce($numbers, function ($carry, $item) {\n        return $carry * $item;\n    }, 1);\n    return [$n_sum, $n_product];\n}\n```",
            "```php\n/**\n * @param {array<int>} $numbers\n * @returns {array<int>}\n */\nfunction rollingMax ($numbers) {\n    $maxSoFar = PHP_INT_MIN;\n    $result = [];\n    foreach ($numbers as $num) {\n        $maxSoFar = max($maxSoFar, $num);\n        $result[] = $maxSoFar;\n    }\n    return $result;\n}\n```",
            "```php\n/**\n * @param {string} $s\n * @returns {string}\n */\nfunction makePalindrome($s) {\n    if (isPalindrome($s)) {\n        return $s;\n    }\n    for ($i = 0; $i < strlen($s); $i++) {\n        if (isPalindrome(substr($s, $i))) {\n            $prefix = substr($s, 0, $i);\n            return $s . strrev($prefix);\n        }\n    }\n    return \"\";\n}\n\n/**\n * @param {string} $s\n * @returns {bool}\n */\nfunction isPalindrome($s) {\n    $left = 0;\n    $right = strlen($s) - 1;\n    while ($left < $right) {\n        if ($s[$left] != $s[$right]) {\n            return false;\n        }\n        $left++;\n        $right--;\n    }\n    return true;\n}\n```",
            "```php\n/**\n * @param {string} $a\n * @param {string} $b\n * @returns {string}\n */\nfunction stringXor($a, $b) {\n    $result = '';\n    for ($i = 0; $i < strlen($a) && $i < strlen($b); $i++) {\n        $x = $a[$i];\n        $y = $b[$i];\n        $result .= ($x == $y) ? '0' : '1';\n    }\n    return $result;\n}\n```",
            "```php\n/**\n * @param {array<string>} $strs\n * @returns {string | null}\n */\nfunction longest ($strs) {\n    if (empty($strs)) {\n        return null;\n    }\n    $longest_s = $strs[0];\n    foreach ($strs as $s) {\n        if (strlen($s) > strlen($longest_s)) {\n            $longest_s = $s;\n        }\n    }\n    return $longest_s;\n}\n```",
            "```php\n/**\n * @param {int} $a\n * @param {int} $b\n * @returns {int}\n */\nfunction greatestCommonDivisor($a, $b) {\n    if ($b == 0) {\n        return $a;\n    } else {\n        return greatestCommonDivisor($b, $a % $b);\n    }\n}\n```",
            "```php\n/**\n * @param {string} $s\n * @returns {array<string>}\n */\nfunction allPrefixes($s) {\n    $prefixes = [];\n    for ($i = 0; $i < strlen($s); $i++) {\n        $prefixes[] = substr($s, 0, $i + 1);\n    }\n    return $prefixes;\n}\n```",
            "```php\n/**\n * @param {int} $n\n * @returns {string}\n */\nfunction stringSequence ($n) {\n    $result = \"\";\n    for ($i = 0; $i <= $n; $i++) {\n        $result .= $i;\n        if ($i < $n) {\n            $result .= \" \";\n        }\n    }\n    return $result;\n}\n```",
            "```php\n/**\n * @param {string} $s\n * @returns {int}\n */\nfunction countDistinctCharacters ($s) {\n    return count(array_unique(str_split(strtolower($s))));\n}\n```",
            "```php\n/**\n * @param {string} $musicString\n * @returns {array<int>}\n */\nfunction parseMusic ($musicString) {\n    $durations = [\"o\" => 4, \"o|\" => 2, \".|\" => 1];\n    $notes = explode(\" \", $musicString);\n    $result = [];\n    foreach ($notes as $note) {\n        if (array_key_exists($note, $durations)) {\n            $result[] = $durations[$note];\n        }\n    }\n    return $result;\n}\n```",
            "```php\n/**\n * @param {string} $s\n * @param {string} $substring\n * @returns {int}\n */\nfunction howManyTimes($s, $substring) {\n    $times = 0;\n    for ($i = 0; $i <= strlen($s) - strlen($substring); $i++) {\n        if (substr($s, $i, strlen($substring)) === $substring) {\n            $times++;\n        }\n    }\n    return $times;\n}\n```",
            "```php\n/**\n * @param {string} $numbers\n * @returns {string}\n */\nfunction sortNumbers($numbers) {\n    $numDict = [\n        \"zero\" => 0,\n        \"one\" => 1,\n        \"two\" => 2,\n        \"three\" => 3,\n        \"four\" => 4,\n        \"five\" => 5,\n        \"six\" => 6,\n        \"seven\" => 7,\n        \"eight\" => 8,\n        \"nine\" => 9\n    ];\n\n    $numList = array_filter(explode(' ', $numbers), function($num) use ($numDict) {\n        return array_key_exists($num, $numDict);\n    });\n\n    usort($numList, function($a, $b) use ($numDict) {\n        return $numDict[$a] - $numDict[$b];\n    });\n\n    return implode(' ', $numList);\n}\n```",
            "```php\nfunction findClosestElements($numbers) {\n    sort($numbers);\n    $min_diff = PHP_FLOAT_MAX;\n    $closest_pair = [];\n    for ($i = 1; $i < count($numbers); $i++) {\n        $diff = $numbers[$i] - $numbers[$i - 1];\n        if ($diff < $min_diff) {\n            $min_diff = $diff;\n            $closest_pair = [$numbers[$i - 1], $numbers[$i]];\n        }\n    }\n    return $closest_pair;\n}\n```",
            "```php\n/**\n * @param {array<float>} $numbers\n * @returns {array<float>}\n */\nfunction rescaleToUnit ($numbers) {\n    $minNum = min($numbers);\n    $maxNum = max($numbers);\n    if ($minNum == $maxNum) {\n        return array_fill(0, count($numbers), 0.0);\n    } else {\n        $result = [];\n        foreach ($numbers as $num) {\n            $result[] = ($num - $minNum) / ($maxNum - $minNum);\n        }\n        return $result;\n    }\n}\n```",
            "```php\n/**\n * @param {array<mixed>} $values\n * @returns {array<int>}\n */\nfunction filterIntegers($values) {\n    return array_filter($values, function($x) {\n        return is_int($x);\n    });\n}\n```",
            "```php\n/**\n * @param {string} $s\n * @returns {int}\n */\nfunction strLength($s) {\n    return strlen($s);\n}\n```",
            "```\n/**\n * @param {int} $n\n * @returns {int}\n */\nfunction largestDivisor($n) {\n    for ($i = 2; $i < $n; $i++) {\n        if ($n % $i == 0) {\n            return $n / $i;\n        }\n    }\n    return 1;\n}\n```",
            "```php\n/**\n * @param {int} $n\n * @returns {array<int>}\n */\nfunction factorize($n) {\n    $factors = [];\n    $divisor = 2;\n    while ($divisor <= $n) {\n        if ($n % $divisor == 0) {\n            $factors[] = $divisor;\n            $n /= $divisor;\n        } else {\n            $divisor++;\n        }\n    }\n    return $factors;\n}\n```",
            "```php\n/**\n * @param {array<int>} $numbers\n * @returns {array<int>}\n */\nfunction removeDuplicates ($numbers) {\n    $counts = array();\n    foreach ($numbers as $num) {\n        if (isset($counts[$num])) {\n            $counts[$num]++;\n        } else {\n            $counts[$num] = 1;\n        }\n    }\n    $res = array();\n    foreach ($numbers as $num) {\n        if ($counts[$num] == 1) {\n            $res[] = $num;\n        }\n    }\n    return $res;\n}\n```",
            "```php\n/**\n * @param {string} $s\n * @returns {string}\n */\nfunction flipCase ($s) {\n    $flipped = '';\n    for ($i = 0; $i < strlen($s); $i++) {\n        $ch = $s[$i];\n        if (!ctype_alpha($ch)) {\n            $flipped .= $ch;\n        } elseif (ctype_lower($ch)) {\n            $flipped .= strtoupper($ch);\n        } elseif (ctype_upper($ch)) {\n            $flipped .= strtolower($ch);\n        }\n    }\n    return $flipped;\n}\n```",
            "```php\n/**\n * @param {array<string>} $strs\n * @returns {string}\n */\nfunction concatenate ($strs) {\n    $result = \"\";\n    foreach ($strs as $str) {\n        $result .= $str;\n    }\n    return $result;\n}\n```",
            "```php\n/**\n * @param {array<string>} $strs\n * @param {string} $prefixStr\n * @returns {array<string>}\n */\nfunction filterByPrefix ($strs, $prefixStr) {\n    return array_filter($strs, function($s) use ($prefixStr) {\n        return strpos($s, $prefixStr) === 0;\n    });\n}\n```",
            "```php\n/**\n * @param {array<int>} $l\n * @returns {array<int>}\n */\nfunction getPositive ($l) {\n    return array_filter($l, function($num) {\n        return $num > 0;\n    });\n}\n```",
            "```php\n/**\n * @param {int} $n\n * @returns {bool}\n */\nfunction isPrime($n) {\n    if ($n < 2) {\n        return false;\n    }\n    for ($i = 2; $i <= sqrt($n); $i++) {\n        if ($n % $i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```",
            "```php\n/**\n * @param {array<int>} $xs\n * @param {float} $x\n * @returns {float}\n */\nfunction poly ($xs, $x) {\n    $res = 0.0;\n    for ($i = 0; $i < count($xs); $i++) {\n        $res += $xs[$i] * pow($x, $i);\n    }\n    return $res;\n}\n\n/**\n * @param {array<int>} $xs\n * @returns {float}\n */\nfunction findZero ($xs) {\n    $x1 = 1.0;\n    $x2 = -1.0;\n    while (poly($xs, $x1) * poly($xs, $x2) > 0) {\n        $x1 *= 2;\n        $x2 *= 2;\n    }\n    while (abs($x1 - $x2) > 1e-10) {\n        $mid = ($x1 + $x2) / 2;\n        if (poly($xs, $mid) == 0) {\n            return $mid;\n        } else if (poly($xs, $mid) * poly($xs, $x1) < 0) {\n            $x2 = $mid;\n        } else {\n            $x1 = $mid;\n        }\n    }\n    return ($x1 + $x2) / 2;\n}\n```",
            "```php\n/**\n * @param {array<int>} $l\n * @returns {array<int>}\n */\nfunction sortThird ($l) {\n    $sorted_third = array_slice($l, 0, null, 3);\n    sort($sorted_third);\n    $result = [];\n    for ($i = 0; $i < count($l); $i++) {\n        if ($i % 3 == 0) {\n            $result[] = $sorted_third[$i / 3];\n        } else {\n            $result[] = $l[$i];\n        }\n    }\n    return $result;\n}\n```",
            "```php\n/**\n * @param {array<int>} $l\n * @returns {array<int>}\n */\nfunction listUnique ($l) {\n    $set = array_unique($l);\n    sort($set);\n    return $set;\n}\n```",
            "```php\n/**\n * @param {array<int>} $l\n * @returns {int}\n */\nfunction maxElement ($l) {\n    if (empty($l)) {\n        return 0;\n    }\n    return max($l);\n}\n```",
            "```php\nfunction fizzBuzz($n) {\n    $cnt = 0;\n    for ($i = 0; $i < $n; $i++) {\n        if ($i % 11 == 0 || $i % 13 == 0) {\n            $str = strval($i);\n            for ($j = 0; $j < strlen($str); $j++) {\n                if ($str[$j] == '7') {\n                    $cnt++;\n                }\n            }\n        }\n    }\n    return $cnt;\n}\n```",
            "```php\n/**\n * @param array<int> $l\n * @return array<int>\n */\nfunction sortEven($l) {\n    $sorted_even = array_values(array_filter($l, function($value, $key) {\n        return $key % 2 == 0;\n    }));\n    sort($sorted_even);\n    \n    $result = [];\n    foreach ($l as $i => $value) {\n        if ($i % 2 == 0) {\n            array_push($result, array_shift($sorted_even));\n        } else {\n            array_push($result, $value);\n        }\n    }\n    return $result;\n}\n```",
            "```php\n/**\n * @param {string} $s\n * @returns {string}\n */\nfunction encodeCyclic ($s) {\n    $result = '';\n    for ($i = 0; $i < strlen($s); $i += 3) {\n        if ($i + 3 > strlen($s)) {\n            $result .= substr($s, $i);\n        } else {\n            $result .= substr($s, $i + 1, 2) . $s[$i];\n        }\n    }\n    return $result;\n}\n\n/**\n * @param {string} $s\n * @returns {string}\n */\nfunction decodeCyclic ($s) {\n    return encodeCyclic(encodeCyclic($s));\n}\n```",
            "```php\n/**\n * @param {int} $n\n * @returns {int}\n */\nfunction primeFib($n) {\n    if ($n < 2) {\n        return false;\n    }\n    for ($i = 2; $i <= sqrt($n); $i++) {\n        if ($n % $i == 0) {\n            return false;\n        }\n    }\n    return true;\n\n    $f = array(0, 1);\n    $cnt = 0;\n    while ($cnt < $n) {\n        $f = array($f[1], $f[0] + $f[1]);\n        if (primeFib($f[1])) {\n            $cnt += 1;\n        }\n    }\n    return $f[1];\n}\n```",
            "```php\n/**\n * @param {array<int>} $l\n * @returns {bool}\n */\nfunction triplesSumToZero ($l) {\n    for ($i = 0; $i < count($l); $i++) {\n        for ($j = $i + 1; $j < count($l); $j++) {\n            for ($k = $j + 1; $k < count($l); $k++) {\n                if ($l[$i] + $l[$j] + $l[$k] == 0) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```",
            "```php\n/**\n * @param {int} $n\n * @returns {int}\n */\nfunction carRaceCollision($n) {\n    return $n * $n;\n}\n```",
            "```\n/**\n * @param {array<int>} $l\n * @returns {array<int>}\n */\nfunction incrList($l) {\n    $result = [];\n    foreach ($l as $i) {\n        $result[] = $i + 1;\n    }\n    return $result;\n}\n```",
            "```php\n/**\n * @param {array<int>} $l\n * @returns {bool}\n */\nfunction pairsSumToZero($l) {\n    $seen = [];\n    foreach ($l as $num) {\n        if (in_array(-$num, $seen)) {\n            return true;\n        }\n        $seen[] = $num;\n    }\n    return false;\n}\n```",
            "```php\n/**\n * @param {int} $x\n * @param {int} $bas\n * @returns {string}\n */\nfunction changeBase($x, $bas) {\n    if ($x == 0) {\n        return \"0\";\n    }\n    $digits = '';\n    while ($x > 0) {\n        $digits .= $x % $bas;\n        $x = intdiv($x, $bas);\n    }\n    return strrev($digits);\n}\n```",
            "```php\n/**\n * @param {int} $a\n * @param {int} $h\n * @returns {float}\n */\nfunction triangleArea($a, $h) {\n    return (double) ($a * $h) / 2;\n}\n```",
            "```php\n/**\n * @param {int} $n\n * @returns {int}\n */\nfunction fib4 ($n) {\n    $fib = [0, 0, 2, 0];\n    for ($i = 4; $i <= $n; $i++) {\n        $fib[$i % 4] = $fib[0] + $fib[1] + $fib[2] + $fib[3];\n    }\n    return $fib[$n % 4];\n}\n```",
            "```php\n/**\n * @param {array<float>} $l\n * @returns {float}\n */\nfunction median ($l) {\n    sort($l);\n    $length = count($l);\n    if ($length % 2 != 0) {\n        return $l[floor($length / 2)];\n    } else {\n        return ($l[$length / 2] + $l[$length / 2 - 1]) / 2;\n    }\n}\n```",
            "```php\n/**\n * @param {string} $txt\n * @returns {bool}\n */\nfunction isPalindrome ($txt) {\n    $n = strlen($txt);\n    for ($i = 0; $i < $n / 2; $i++) {\n        if ($txt[$i] !== $txt[$n - 1 - $i]) {\n            return false;\n        }\n    }\n    return true;\n}\n```",
            "```php\n/**\n * @param {int} $n\n * @param {int} $p\n * @returns {int}\n */\nfunction modp($n, $p) {\n    $ret = 1;\n    for ($i = 0; $i < $n; $i++) {\n        $ret = ($ret * 2) % $p;\n    }\n    return $ret;\n}\n```",
            "```php\n/**\n * @param {string} $s\n * @returns {string}\n */\nfunction encodeShift($s) {\n    $result = '';\n    for ($i = 0; $i < strlen($s); $i++) {\n        $ch = $s[$i];\n        $result .= chr(((ord($ch) - ord('a') + 5) % 26) + ord('a'));\n    }\n    return $result;\n}\n\n/**\n * @param {string} $s\n * @returns {string}\n */\nfunction decodeShift($s) {\n    $result = '';\n    for ($i = 0; $i < strlen($s); $i++) {\n        $ch = $s[$i];\n        $result .= chr(((ord($ch) - ord('a') + 21) % 26) + ord('a'));\n    }\n    return $result;\n}\n```",
            "```php\n/**\n * @param {string} $txt\n * @returns {string}\n */\nfunction removeVowels ($txt) {\n    $vowels = \"aeiouAEIOU\";\n    $result = \"\";\n    for ($i = 0; $i < strlen($txt); $i++) {\n        if (strpos($vowels, $txt[$i]) === false) {\n            $result .= $txt[$i];\n        }\n    }\n    return $result;\n}\n```",
            "```php\n/**\n * @param {array<int>} $l\n * @param {int} $t\n * @returns {bool}\n */\nfunction belowThreshold ($l, $t) {\n    foreach ($l as $x) {\n        if ($x >= $t) {\n            return false;\n        }\n    }\n    return true;\n}\n```",
            "```php\n/**\n * @param {int} $x\n * @param {int} $y\n * @returns {int}\n */\nfunction add ($x, $y) {\n    return $x + $y;\n}\n```",
            "```php\n/**\n * @param {string} $s0\n * @param {string} $s1\n * @returns {bool}\n */\nfunction sameChars ($s0, $s1) {\n    return array_unique(str_split($s0)) === array_unique(str_split($s1));\n}\n```",
            "```php\n/**\n * @param {int} $n\n * @returns {int}\n */\nfunction fib($n) {\n    if ($n <= 1) {\n        return $n;\n    } else {\n        return fib($n - 1) + fib($n - 2);\n    }\n}\n```",
            "```php\n/**\n * @param {string} $brackets\n * @returns {bool}\n */\nfunction correctBracketing($brackets) {\n    $depth = 0;\n    for ($i = 0; $i < strlen($brackets); $i++) {\n        if ($brackets[$i] === '<') {\n            $depth += 1;\n        } elseif ($brackets[$i] === '>') {\n            $depth -= 1;\n        }\n        if ($depth < 0) {\n            return false;\n        }\n    }\n    return $depth === 0;\n}\n```",
            "```php\n/**\n * @param {array<int>} $l\n * @returns {bool}\n */\nfunction monotonic($l) {\n    if (count($l) <= 1) return true;\n\n    $n = count($l);\n    $nonDecreasing = true;\n    $nonIncreasing = true;\n\n    for ($i = 0; $i < $n - 1; $i++) {\n        if ($l[$i] > $l[$i + 1]) {\n            $nonDecreasing = false;\n        }\n        if ($l[$i] < $l[$i + 1]) {\n            $nonIncreasing = false;\n        }\n    }\n\n    return $nonDecreasing || $nonIncreasing;\n}\n```",
            "```php\n/**\n * @param {array<int>} $l1\n * @param {array<int>} $l2\n * @returns {array<int>}\n */\nfunction common ($l1, $l2) {\n    $set1 = array_unique($l1);\n    $set2 = array_unique($l2);\n    $result = array_intersect($set1, $set2);\n    sort($result);\n    return $result;\n}\n```",
            "```php\n/**\n * @param {int} $n\n * @returns {int}\n */\nfunction largestPrimeFactor ($n) {\n    $i = 2;\n    while ($i * $i <= $n) {\n        if ($n % $i != 0) {\n            $i += 1;\n        } else {\n            $n /= $i;\n        }\n    }\n    return $n;\n}\n```",
            "```php\n/**\n * @param {int} $n\n * @returns {int}\n */\nfunction sumToN($n) {\n    $sum = 0;\n    for ($i = 1; $i <= $n; $i++) {\n        $sum += $i;\n    }\n    return $sum;\n}\n```",
            "```php\n/**\n * @param {string} $brackets\n * @returns {bool}\n */\nfunction correctBracketing($brackets) {\n    $depth = 0;\n    for ($i = 0; $i < strlen($brackets); $i++) {\n        $b = $brackets[$i];\n        if ($b == '(') {\n            $depth += 1;\n        } else if ($b == ')') {\n            $depth -= 1;\n        }\n        if ($depth < 0) {\n            return false;\n        }\n    }\n    return $depth == 0;\n}\n```",
            "```php\n/**\n * @param {array<int>} $xs\n * @returns {array<int>}\n */\nfunction derivative ($xs) {\n    $result = [];\n    for ($i = 1; $i < count($xs); $i++) {\n        $result[] = $xs[$i] * $i;\n    }\n    return $result;\n}\n```",
            "```php\n/**\n * @param {int} $n\n * @returns {int}\n */\nfunction fibfib($n) {\n    if ($n <= 1) {\n        return 0;\n    }\n    $a = 0;\n    $b = 0;\n    $c = 1;\n    while ($n > 2) {\n        $a = $b;\n        $b = $c;\n        $c = $a + $b + $c;\n        $n -= 1;\n    }\n    return $c;\n}\n```",
            "```php\nfunction vowelsCount($s) {\n    $vowels = \"aeiou\";\n    $cnt = 0;\n    for ($i = 0; $i < strlen($s); $i++) {\n        if (strpos($vowels, strtolower($s[$i])) !== false || \n            ($i == strlen($s) - 1 && strtolower($s[$i]) == 'y')) {\n            $cnt++;\n        }\n    }\n    return $cnt;\n}\n```",
            "```php\n/**\n * @param {int} $x\n * @param {int} $shift\n * @returns {string}\n */\nfunction circularShift($x, $shift) {\n    $x_str = (string)$x;\n    if ($shift > strlen($x_str)) {\n        return strrev($x_str);\n    } else {\n        return substr($x_str, -$shift) . substr($x_str, 0, -$shift);\n    }\n}\n```",
            "```php\n/**\n * @param {string} $s\n * @returns {int}\n */\nfunction digitSum($s) {\n    $sum = 0;\n    for ($i = 0; $i < strlen($s); $i++) {\n        $c = $s[$i];\n        if (ctype_upper($c)) {\n            $sum += ord($c);\n        }\n    }\n    return $sum;\n}\n```",
            "```php\n/**\n * @param {string} $s\n * @param {int} $n\n * @returns {int}\n */\nfunction fruitDistribution ($s, $n) {\n    $words = explode(' ', $s);\n    $applesIndex = array_search(\"apples\", $words) - 1;\n    $orangesIndex = array_search(\"oranges\", $words) - 1;\n    $apples = (int)$words[$applesIndex];\n    $oranges = (int)$words[$orangesIndex];\n    return $n - $apples - $oranges;\n}\n```",
            "```php\n/**\n * @param {array<int>} $arr\n * @returns {array<int>}\n */\nfunction pluck ($arr) {\n    $evens = array();\n    foreach ($arr as $n) {\n        if ($n % 2 == 0) {\n            $evens[] = $n;\n        }\n    }\n    if (empty($evens)) {\n        return array();\n    }\n    $minEven = min($evens);\n    $index = array_search($minEven, $arr);\n    return array($minEven, $index);\n}\n```",
            "```php\nfunction search ($lst) {\n    $freqs = array();\n    foreach ($lst as $n) {\n        if (array_key_exists($n, $freqs)) {\n            $freqs[$n]++;\n        } else {\n            $freqs[$n] = 1;\n        }\n    }\n    $goodVals = array();\n    foreach ($freqs as $key => $value) {\n        if ($value >= $key) {\n            $goodVals[] = $key;\n        }\n    }\n    return !empty($goodVals) ? max($goodVals) : -1;\n}\n```",
            "```php\n/**\n * @param {array<int>} $lst\n * @returns {array<int>}\n */\nfunction strangeSortList ($lst) {\n    $sl = $lst;\n    sort($sl);\n    $result = array();\n    $left = 0;\n    $right = count($sl) - 1;\n    while ($left <= $right) {\n        $result[] = $sl[$left];\n        $left += 1;\n        if ($left <= $right) {\n            $result[] = $sl[$right];\n            $right -= 1;\n        }\n    }\n    return $result;\n}\n```",
            "```php\n/**\n * @param {int} $a\n * @param {int} $b\n * @param {int} $c\n * @returns {float}\n */\nfunction triangleArea ($a, $b, $c) {\n    if ($a + $b > $c && $a + $c > $b && $b + $c > $a) {\n        $s = ($a + $b + $c) / 2.0;\n        return sqrt($s * ($s - $a) * ($s - $b) * ($s - $c));\n    } else {\n        return -1.0;\n    }\n}\n```",
            "```php\n/**\n * @param {array<int>} $q\n * @param {int} $w\n * @returns {bool}\n */\nfunction willItFly ($q, $w) {\n    if (count($q) === 0) {\n        return false;\n    }\n    $is_palin = true;\n    for ($i = 0; $i < count($q); $i++) {\n        if ($q[$i] !== $q[count($q) - $i - 1]) {\n            $is_palin = false;\n            break;\n        }\n    }\n    $total = array_sum($q);\n    return $is_palin && $total <= $w;\n}\n```",
            "```php\n/**\n * @param {array<int>} $arr\n * @returns {int}\n */\nfunction smallestChange ($arr) {\n    $ans = 0;\n    for ($i = 0; $i < count($arr) / 2; $i++) {\n        if ($arr[$i] !== $arr[count($arr) - $i - 1]) {\n            $ans += 1;\n        }\n    }\n    return $ans;\n}\n```",
            "```php\n/**\n * @param {array<string>} $lst1\n * @param {array<string>} $lst2\n * @returns {array<string>}\n */\nfunction totalMatch($lst1, $lst2) {\n    $cnt1 = array_sum(array_map('strlen', $lst1));\n    $cnt2 = array_sum(array_map('strlen', $lst2));\n    return $cnt1 <= $cnt2 ? $lst1 : $lst2;\n}\n```",
            "```php\nfunction is_prime($n) {\n    if ($n < 2) {\n        return false;\n    }\n    for ($i = 2; $i <= sqrt($n); $i++) {\n        if ($n % $i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n * @param {int} $a\n * @returns {bool}\n */\nfunction isMultiplyPrime($a) {\n    $cnt = 0;\n    for ($i = 2; $i <= $a; $i++) {\n        if (is_prime($i)) {\n            while ($a % $i == 0) {\n                $cnt++;\n                $a /= $i;\n            }\n        }\n    }\n    return $cnt == 3;\n}\n```",
            "```php\n/**\n * @param {int} $x\n * @param {int} $n\n * @returns {bool}\n */\nfunction isSimplePower ($x, $n) {\n    if ($n < 2) {\n        return $x == $n;\n    }\n    $tmp = 1;\n    while ($tmp < $x) {\n        $tmp *= $n;\n    }\n    return $tmp == $x;\n}\n```",
            "```php\n/**\n * @param {int} $a\n * @returns {bool}\n */\nfunction isCube ($a) {\n    $a = abs($a);\n    $root = (int) round(cbrt($a));\n    return $root * $root * $root == $a;\n}\n```",
            "```php\nfunction hexKey ($num) {\n    $count = 0;\n    for ($i = 0; $i < strlen($num); $i++) {\n        if (strpos(\"2357BD\", $num[$i]) !== false) {\n            $count++;\n        }\n    }\n    return $count;\n}\n```",
            "```php\n/**\n * @param {int} $dec\n * @returns {string}\n */\nfunction decimalToBinary ($dec) {\n    $binary = decbin($dec);\n    return \"db\" . $binary . \"db\";\n}\n```",
            "```php\n/**\n * @param {string} $s\n * @returns {bool}\n */\nfunction isHappy ($s) {\n    if (strlen($s) < 3) {\n        return false;\n    }\n    for ($i = 0; $i < strlen($s) - 2; $i++) {\n        if ($s[$i] == $s[$i + 1] || $s[$i] == $s[$i + 2] || $s[$i + 1] == $s[$i + 2]) {\n            return false;\n        }\n    }\n    return true;\n}\n```",
            "```php\nfunction numericalLetterGrade ($grades) {\n    $result = [];\n    foreach ($grades as $g) {\n        if ($g == 4.0) {\n            $result[] = \"A+\";\n        } else if ($g > 3.7) {\n            $result[] = \"A\";\n        } else if ($g > 3.3) {\n            $result[] = \"A-\";\n        } else if ($g > 3.0) {\n            $result[] = \"B+\";\n        } else if ($g > 2.7) {\n            $result[] = \"B\";\n        } else if ($g > 2.3) {\n            $result[] = \"B-\";\n        } else if ($g > 2.0) {\n            $result[] = \"C+\";\n        } else if ($g > 1.7) {\n            $result[] = \"C\";\n        } else if ($g > 1.3) {\n            $result[] = \"C-\";\n        } else if ($g > 1.0) {\n            $result[] = \"D+\";\n        } else if ($g > 0.7) {\n            $result[] = \"D\";\n        } else if ($g > 0.0) {\n            $result[] = \"D-\";\n        } else {\n            $result[] = \"E\";\n        }\n    }\n    return $result;\n}\n```",
            "```php\n/**\n * @param {string} $s\n * @returns {bool}\n */\nfunction primeLength($s) {\n    $length = strlen($s);\n    if ($length < 2) {\n        return false;\n    }\n    for ($i = 2; $i <= sqrt($length); $i++) {\n        if ($length % $i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```",
            "```php\n/**\n * @param {int} $n\n * @returns {int}\n */\nfunction startsOneEnds ($n) {\n    if ($n == 1) {\n        return 1;\n    }\n    return 2 * 9 * pow(10, $n - 2);\n}\n```",
            "```php\n/**\n * @param {int} $n\n * @returns {string}\n */\nfunction solve ($n) {\n    $digitsSum = 0;\n    while ($n > 0) {\n        $digitsSum += $n % 10;\n        $n = intdiv($n, 10);\n    }\n    return decbin($digitsSum);\n}\n```",
            "```php\n/**\n * @param {array<int>} $lst\n * @returns {int}\n */\nfunction add ($lst) {\n    $sum = 0;\n    for ($i = 1; $i < count($lst); $i += 2) {\n        $x = $lst[$i];\n        if ($x % 2 == 0) {\n            $sum += $x;\n        }\n    }\n    return $sum;\n}\n```",
            "```php\n/**\n * @param {string} $s\n * @returns {string}\n */\nfunction antiShuffle ($s) {\n    $result = '';\n    $words = explode(\" \", $s);\n    \n    foreach ($words as $word) {\n        $chars = str_split($word);\n        sort($chars);\n        $result .= implode(\"\", $chars) . \" \";\n    }\n    \n    return trim($result);\n}\n```",
            "```php\n/**\n * @param {array<array<int>>} $lst\n * @param {int} $x\n * @returns {array<array<int>>}\n */\nfunction getRow ($lst, $x) {\n    $coords = [];\n    for ($i = 0; $i < count($lst); $i++) {\n        for ($j = 0; $j < count($lst[$i]); $j++) {\n            if ($lst[$i][$j] == $x) {\n                $coord = [$i, $j];\n                $coords[] = $coord;\n            }\n        }\n    }\n    usort($coords, function ($a, $b) {\n        if ($a[0] === $b[0]) {\n            return -$a[1] <=> -$b[1];\n        }\n        return $a[0] <=> $b[0];\n    });\n    return $coords;\n}\n```",
            "```php\n/**\n * @param {array<int>} $arr\n * @returns {array<int>}\n */\nfunction sortArray($arr) {\n    if (count($arr) == 0) {\n        return [];\n    }\n    if (($arr[0] + end($arr)) % 2 == 0) {\n        rsort($arr);\n    } else {\n        sort($arr);\n    }\n    return $arr;\n}\n```",
            "```php\n/**\n * @param {string} $s\n * @returns {string}\n */\nfunction encrypt($s) {\n    $result = '';\n    for ($i = 0; $i < strlen($s); $i++) {\n        $ch = ord($s[$i]);\n        $shifted = $ch + 4;\n        if ($shifted > ord('z')) {\n            $shifted -= 26;\n        }\n        $result .= chr($shifted);\n    }\n    return $result;\n}\n```",
            "```php\n/**\n * @param {array<int>} $lst\n * @returns {int | null}\n */\nfunction nextSmallest ($lst) {\n    $set = array_unique($lst);\n    sort($set);\n    if (count($set) < 2) {\n        return null;\n    }\n    return $set[1];\n}\n```",
            "```php\n/**\n * @param {string} $s\n * @returns {int}\n */\nfunction isBored($s) {\n    $sentences = preg_split('/[.!?]\\s*/', $s);\n    $count = 0;\n    foreach ($sentences as $sentence) {\n        if (strlen($sentence) >= 2 && strpos($sentence, \"I \") === 0) {\n            $count++;\n        }\n    }\n    return $count;\n}\n```",
            "```php\n/**\n * @param {mixed} $x\n * @param {mixed} $y\n * @param {mixed} $z\n * @returns {bool}\n */\nfunction anyInt ($x, $y, $z) {\n    if (is_int($x) && is_int($y) && is_int($z)) {\n        if (($x + $y == $z) || ($x + $z == $y) || ($y + $z == $x)) {\n            return true;\n        }\n    }\n    return false;\n}\n```",
            "```php\n/**\n * @param {string} $message\n * @returns {string}\n */\nfunction encode($message) {\n    $vowels = \"aeiouAEIOU\";\n    $result = \"\";\n    for ($i = 0; $i < strlen($message); $i++) {\n        $ch = $message[$i];\n        if (ctype_alpha($ch)) {\n            $ch1 = ctype_lower($ch) ? strtoupper($ch) : strtolower($ch);\n            if (strpos($vowels, $ch1) !== false) {\n                $ch1 = chr(ord($ch1) + 2);\n            }\n            $result .= $ch1;\n        } else {\n            $result .= $ch;\n        }\n    }\n    return $result;\n}\n```",
            "```php\n/**\n * @param {array<int>} $lst\n * @returns {int}\n */\nfunction skjkasdkd ($lst) {\n    $primes = [];\n    foreach ($lst as $n) {\n        if (isPrime($n)) {\n            $primes[] = $n;\n        }\n    }\n    if (empty($primes)) {\n        return 0;\n    }\n    $largest = strval(max($primes));\n    $sum = 0;\n    for ($i = 0; $i < strlen($largest); $i++) {\n        $sum += intval($largest[$i]);\n    }\n    return $sum;\n}\n\nfunction isPrime($n) {\n    if ($n < 2) {\n        return false;\n    }\n    for ($i = 2; $i <= sqrt($n); $i++) {\n        if ($n % $i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```",
            "```php\n/**\n * @param {array<string, string>} $d\n * @returns {bool}\n */\nfunction checkDictCase ($d) {\n    if (empty($d)) {\n        return false;\n    }\n    $allLower = true;\n    $allUpper = true;\n    foreach (array_keys($d) as $key) {\n        if (!ctype_lower($key)) {\n            $allLower = false;\n        }\n        if (!ctype_upper($key)) {\n            $allUpper = false;\n        }\n    }\n    return $allLower || $allUpper;\n}\n```",
            "```php\n/**\n * @param {int} $n\n * @returns {array<int>}\n */\nfunction countUpTo ($n) {\n    $primes = array();\n    for ($num = 2; $num < $n; $num++) {\n        $isPrime = true;\n        foreach ($primes as $p) {\n            if ($num % $p == 0) {\n                $isPrime = false;\n                break;\n            }\n        }\n        if ($isPrime) {\n            array_push($primes, $num);\n        }\n    }\n    return $primes;\n}\n```",
            "```php\n/**\n * @param {int} $a\n * @param {int} $b\n * @returns {int}\n */\nfunction multiply($a, $b) {\n    return (abs($a) % 10) * (abs($b) % 10);\n}\n```",
            "```php\n/**\n * @param {string} $s\n * @returns {int}\n */\nfunction countUpper ($s) {\n    $vowels = \"AEIOU\";\n    $count = 0;\n    for ($i = 0; $i < strlen($s); $i++) {\n        $c = $s[$i];\n        if ($i % 2 == 0 && strpos($vowels, $c) !== false) {\n            $count++;\n        }\n    }\n    return $count;\n}\n```",
            "```php\nfunction closestInteger ($value) {\n    $num = doubleval($value);\n    if ($num >= 0) {\n        return (int)($num + 0.5);\n    } else {\n        return (int)($num - 0.5);\n    }\n}\n```",
            "```php\n/**\n * @param {int} $n\n * @returns {array<int>}\n */\nfunction makeAPile($n) {\n    $pile = [];\n    for ($i = 0; $i < $n; $i++) {\n        $pile[] = $n + 2 * $i;\n    }\n    return $pile;\n}\n```",
            "```php\n/**\n * @param {string} $s\n * @returns {array<string>}\n */\nfunction wordsString ($s) {\n    return array_filter(preg_split('/[, ]+/', trim($s)), function($w) {\n        return strlen($w) > 0;\n    });\n}\n```",
            "```php\n/**\n * @param {int} $x\n * @param {int} $y\n * @returns {int}\n */\nfunction chooseNum($x, $y) {\n    if ($x > $y) {\n        return -1;\n    }\n    if ($y % 2 == 0) {\n        return $y;\n    }\n    return $y - 1;\n}\n```",
            "```php\n/**\n * @param {int} $n\n * @param {int} $m\n * @returns {string | null}\n */\nfunction roundedAvg ($n, $m) {\n    if ($n > $m) {\n        return null;\n    }\n    $rAvg = (int) (($m + $n) / 2.0 + 0.5);\n    return decbin($rAvg);\n}\n```",
            "```php\n/**\n * @param {array<int>} $x\n * @returns {array<int>}\n */\nfunction uniqueDigits ($x) {\n    return array_filter($x, function($num) {\n        return allDigitsOdd((string)$num);\n    });\n    usort($x, function($a, $b) {\n        return (int)$a - (int)$b;\n    });\n    return array_values($x); // Re-index the array\n}\n\nfunction allDigitsOdd ($s) {\n    for ($i = 0; $i < strlen($s); $i++) {\n        if (($s[$i] - '0') % 2 == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```",
            "```php\n/**\n * @param {array<int>} $arr\n * @returns {array<string>}\n */\nfunction byLength($arr) {\n    $digitNames = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"];\n    $sortedArr = array_filter($arr, function($x) {\n        return $x >= 1 && $x <= 9;\n    });\n    rsort($sortedArr);\n    return array_map(function($x) use ($digitNames) {\n        return $digitNames[$x - 1];\n    }, $sortedArr);\n}\n```",
            "```php\n/**\n * @param {int} $n\n * @returns {array<int>}\n */\nfunction f ($n) {\n    $nums = range(1, $n);\n    $result = array();\n    foreach ($nums as $i) {\n        if ($i % 2 != 0) {\n            $result[] = array_sum(array_slice($nums, 0, $i));\n        } else {\n            $product = 1;\n            foreach (array_slice($nums, 0, $i) as $num) {\n                $product *= $num;\n            }\n            $result[] = $product;\n        }\n    }\n    return $result;\n}\n```",
            "```php\n/**\n * @param {int} $n\n * @returns {array<int>}\n */\nfunction evenOddPalindrome($n) {\n    function is_palindrome($txt) {\n        return $txt === strrev($txt);\n    }\n\n    $cnt = [0, 0];\n    for ($i = 1; $i <= $n; $i++) {\n        if (is_palindrome(strval($i))) {\n            $cnt[$i % 2] += 1;\n        }\n    }\n    return $cnt;\n}\n```",
            "```php\nfunction digitsSum($n) {\n    $nStr = strval($n);\n    if ($n >= 0) {\n        return array_sum(str_split($nStr));\n    } else {\n        return intval(substr($nStr, 0, 2)) * 2 + digitsSum(abs($n));\n    }\n}\n\n/**\n * @param {array<int>} $arr\n * @returns {int}\n */\nfunction countNums($arr) {\n    return count(array_filter($arr, function($n) {\n        return digitsSum($n) > 0;\n    }));\n}\n```",
            "```php\n/**\n * @param {array<int>} $arr\n * @returns {bool}\n */\nfunction moveOneBall($arr) {\n    if (count($arr) == 0) {\n        return true;\n    }\n    $sortedArr = $arr;\n    sort($sortedArr);\n    for ($i = 0; $i < count($arr); $i++) {\n        if (array_slice($arr, $i) === array_slice($sortedArr, 0, count($arr) - $i) &&\n            array_slice($arr, 0, $i) === array_slice($sortedArr, count($arr) - $i)) {\n            return true;\n        }\n    }\n    return false;\n}\n```",
            "```php\n/**\n * @param {array<int>} $lst1\n * @param {array<int>} $lst2\n * @returns {string}\n */\nfunction canExchange($lst1, $lst2) {\n    $odd_cnt = 0;\n    foreach ($lst1 as $num) {\n        if ($num % 2 != 0) {\n            $odd_cnt++;\n        }\n    }\n    \n    $even_cnt = 0;\n    foreach ($lst2 as $num) {\n        if ($num % 2 == 0) {\n            $even_cnt++;\n        }\n    }\n    \n    return $even_cnt >= $odd_cnt ? \"YES\" : \"NO\";\n}\n```",
            "```php\n/**\n * @param {string} $test\n * @returns {array<string, int>}\n */\nfunction histogram($test) {\n    $freq = [];\n    $words = explode(\" \", $test);\n    foreach ($words as $w) {\n        if (trim($w) !== '') {\n            if (!isset($freq[$w])) {\n                $freq[$w] = 0;\n            }\n            $freq[$w]++;\n        }\n    }\n    $result = [];\n    if (count($freq) > 0) {\n        $max_freq = max($freq);\n        foreach ($freq as $k => $v) {\n            if ($v == $max_freq) {\n                $result[$k] = $v;\n            }\n        }\n    }\n    return $result;\n}\n```",
            "```php\n/**\n * @param {string} $s\n * @param {string} $c\n * @returns {array<string>}\n */\nfunction reverseDelete($s, $c) {\n    $resultString = '';\n    for ($i = 0; $i < strlen($s); $i++) {\n        if (strpos($c, $s[$i]) === false) {\n            $resultString .= $s[$i];\n        }\n    }\n    $palindromeCheck = strrev($resultString);\n    $resultList = [];\n    $resultList[] = $resultString;\n    $resultList[] = ($palindromeCheck === $resultString) ? \"yes\" : \"no\";\n    return $resultList;\n}\n```",
            "```php\n/**\n * @param {array<string>} $lst\n * @returns {array<string>}\n */\nfunction oddCount($lst) {\n    $result = [];\n    foreach ($lst as $num) {\n        $n = 0;\n        for ($i = 0; $i < strlen($num); $i++) {\n            if ((int)$num[$i] % 2 == 1) {\n                $n++;\n            }\n        }\n        $rs = \"the number of odd elements in the string x of the input.\";\n        $result[] = str_replace(\"x\", (string)$n, $rs);\n    }\n    return $result;\n}\n```",
            "```php\nfunction minSubArraySum ($nums) {\n    $min_sum = 0;\n    $cur_sum = 0;\n    foreach ($nums as $n) {\n        $cur_sum = min($cur_sum + $n, 0);\n        $min_sum = min($cur_sum, $min_sum);\n    }\n    if ($min_sum == 0) {\n        $min_sum = min($nums);\n    }\n    return $min_sum;\n}\n```",
            "```php\nfunction maxFill ($grid, $capacity) {\n    $total = 0;\n    foreach ($grid as $arr) {\n        $sum = 0;\n        foreach ($arr as $num) {\n            $sum += $num;\n        }\n        $total += ceil((double)$sum / $capacity);\n    }\n    return $total;\n}\n```",
            "```php\n/**\n * @param {array<int>} $arr\n * @returns {array<int>}\n */\nfunction sortArray ($arr) {\n    usort($arr, function($a, $b) {\n        $countA = substr_count(decbin($a), '1');\n        $countB = substr_count(decbin($b), '1');\n        if ($countA == $countB) {\n            return $a - $b;\n        }\n        return $countA - $countB;\n    });\n    return $arr;\n}\n```",
            "```php\n/**\n * @param {string} $s\n * @param {int} $n\n * @returns {array<string>}\n */\nfunction selectWords ($s, $n) {\n    $consonants = array('b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z');\n    $words = array_filter(explode(\" \", $s), function($w) { return strlen($w) > 0; });\n    return array_filter($words, function($w) use ($consonants, $n) {\n        $count = 0;\n        for ($i = 0; $i < strlen($w); $i++) {\n            if (in_array(strtolower($w[$i]), $consonants)) {\n                $count++;\n            }\n        }\n        return $count == $n;\n    });\n}\n```",
            "```php\n/**\n * @param string $word\n * @return string\n */\nfunction getClosestVowel($word) {\n    $vowels = \"aeiouAEIOU\";\n    for ($i = strlen($word) - 2; $i > 0; $i--) {\n        if (strpos($vowels, $word[$i]) !== false && strpos($vowels, $word[$i - 1]) === false && strpos($vowels, $word[$i + 1]) === false) {\n            return $word[$i];\n        }\n    }\n    return \"\";\n}\n```",
            "```php\n/**\n * @param {array<string>} $lst\n * @returns {string}\n */\nfunction matchParens ($lst) {\n    $s1 = $lst[0] . $lst[1];\n    $s2 = $lst[1] . $lst[0];\n    return (check($s1) || check($s2)) ? \"Yes\" : \"No\";\n}\n\nfunction check($s) {\n    $depth = 0;\n    for ($i = 0; $i < strlen($s); $i++) {\n        $ch = $s[$i];\n        if ($ch == '(') {\n            $depth += 1;\n        } else {\n            $depth -= 1;\n        }\n        if ($depth < 0) {\n            return false;\n        }\n    }\n    return $depth == 0;\n}\n```",
            "```php\n/**\n * @param {array<int>} $arr\n * @param {int} $k\n * @returns {array<int>}\n */\nfunction maximum ($arr, $k) {\n    if ($k == 0) {\n        return [];\n    }\n    rsort($arr);\n    return array_slice($arr, 0, $k);\n}\n```",
            "```php\n/**\n * @param {array<int>} $lst\n * @returns {int}\n */\nfunction solution ($lst) {\n    $sum = 0;\n    for ($i = 0; $i < count($lst); $i++) {\n        if ($i % 2 == 0 && $lst[$i] % 2 != 0) {\n            $sum += $lst[$i];\n        }\n    }\n    return $sum;\n}\n```",
            "```php\n/**\n * @param {array<int>} $arr\n * @param {int} $k\n * @returns {int}\n */\nfunction addElements ($arr, $k) {\n    $sum = 0;\n    for ($i = 0; $i < min($k, count($arr)); $i++) {\n        if (strlen((string)$arr[$i]) <= 2) {\n            $sum += $arr[$i];\n        }\n    }\n    return $sum;\n}\n```",
            "```php\n/**\n * @param {int} $n\n * @returns {array<int>}\n */\nfunction getOddCollatz ($n) {\n    $collatz = [1];\n    while ($n != 1) {\n        if ($n % 2 != 0) {\n            $collatz[] = $n;\n            $n = 3 * $n + 1;\n        } else {\n            $n = intdiv($n, 2);\n        }\n    }\n    sort($collatz);\n    return $collatz;\n}\n```",
            "```php\n/**\n * @param {string} $date\n * @returns {bool}\n */\nfunction validDate($date) {\n    if (strlen($date) != 10 || $date[2] != '-' || $date[5] != '-') {\n        return false;\n    }\n    $m = intval(substr($date, 0, 2));\n    $d = intval(substr($date, 3, 2));\n    if (($m == 1 || $m == 3 || $m == 5 || $m == 7 || $m == 8 || $m == 10 || $m == 12) && $d >= 1 && $d <= 31) {\n        return true;\n    }\n    if (($m == 4 || $m == 6 || $m == 9 || $m == 11) && $d >= 1 && $d <= 30) {\n        return true;\n    }\n    if ($m == 2 && $d >= 1 && $d <= 29) {\n        return true;\n    }\n    return false;\n}\n```",
            "```php\n/**\n * @param {string} $txt\n * @returns {array<string>}\n */\nfunction splitWords ($txt) {\n    if (strpos($txt, ' ') !== false) {\n        return explode(' ', $txt);\n    } elseif (strpos($txt, ',') !== false) {\n        return explode(',', $txt);\n    } else {\n        $count = 0;\n        for ($i = 0; $i < strlen($txt); $i++) {\n            $c = $txt[$i];\n            if (ctype_lower($c) && ord($c) % 2 == 0) {\n                $count++;\n            }\n        }\n        return [(string)$count];\n    }\n}\n```",
            "```php\n/**\n * @param {array<int>} $lst\n * @returns {bool}\n */\nfunction isSorted ($lst) {\n    if (count($lst) < 2) return true;\n    for ($i = 1; $i < count($lst); $i++) {\n        if ($lst[$i - 1] > $lst[$i]) return false;\n    }\n    $freq = array_count_values($lst);\n    $maxFreq = max($freq);\n    return $maxFreq <= 2;\n}\n```",
            "```php\n/**\n * @param {array<int>} $interval1\n * @param {array<int>} $interval2\n * @returns {string}\n */\nfunction intersection ($interval1, $interval2) {\n    $l = max($interval1[0], $interval2[0]);\n    $r = min($interval1[1], $interval2[1]);\n    $length = $r - $l;\n    return isPrime($length) && $length > 0 ? \"YES\" : \"NO\";\n}\n\nfunction isPrime($n) {\n    if ($n < 2) {\n        return false;\n    }\n    for ($i = 2; $i <= sqrt($n); $i++) {\n        if ($n % $i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```",
            "```php\n/**\n * @param {array<int>} $arr\n * @returns {int | null}\n */\nfunction prodSigns($arr) {\n    if (empty($arr)) {\n        return null;\n    }\n    if (in_array(0, $arr)) {\n        return 0;\n    }\n    $negativeCount = count(array_filter($arr, function($n) {\n        return $n < 0;\n    }));\n    $sign = ($negativeCount % 2 === 1) ? -1 : 1;\n    return $sign * array_sum(array_map('abs', $arr));\n}\n```",
            "```php\n/**\n * @param {array<array<int>>} $grid\n * @param {int} $k\n * @returns {array<int>}\n */\nfunction minPath ($grid, $k) {\n    $n = count($grid);\n    $min_val = $n * $n + 1;\n    for ($i = 0; $i < $n; $i++) {\n        for ($j = 0; $j < $n; $j++) {\n            if ($grid[$i][$j] == 1) {\n                $temp = [];\n                if ($i != 0) {\n                    $temp[] = $grid[$i - 1][$j];\n                }\n                if ($j != 0) {\n                    $temp[] = $grid[$i][$j - 1];\n                }\n                if ($i != $n - 1) {\n                    $temp[] = $grid[$i + 1][$j];\n                }\n                if ($j != $n - 1) {\n                    $temp[] = $grid[$i][$j + 1];\n                }\n                $min_val = min($temp);\n            }\n        }\n    }\n    $result = [];\n    for ($i = 0; $i < $k; $i++) {\n        $result[] = $i % 2 == 0 ? 1 : $min_val;\n    }\n    return $result;\n}\n```",
            "```php\n/**\n * @param {int} $n\n * @returns {array<int>}\n */\nfunction tri ($n) {\n    if ($n == 0) {\n        return [1];\n    }\n    $seq = [1, 3];\n    for ($i = 2; $i <= $n; $i++) {\n        if ($i % 2 == 0) {\n            array_push($seq, $i / 2 + 1);\n        } else {\n            $nextValue = $seq[$i - 1] + $seq[$i - 2] + ($i + 3) / 2;\n            array_push($seq, $nextValue);\n        }\n    }\n    return $seq;\n}\n```",
            "```php\n/**\n * @param {int} $n\n * @returns {int}\n */\nfunction digits ($n) {\n    $numStr = strval($n);\n    $product = 1;\n    $hasOddDigit = false;\n    \n    for ($i = 0; $i < strlen($numStr); $i++) {\n        $digit = intval($numStr[$i]);\n        if ($digit % 2 == 1) {\n            $product *= $digit;\n            $hasOddDigit = true;\n        }\n    }\n    \n    return $hasOddDigit ? $product : 0;\n}\n```",
            "```php\n/**\n * @param {string} $s\n * @returns {bool}\n */\nfunction isNested ($s) {\n    $openIdx = [];\n    $closeIdx = [];\n    \n    for ($i = 0; $i < strlen($s); $i++) {\n        $ch = $s[$i];\n        if ($ch == '[') {\n            array_push($openIdx, $i);\n        } else if ($ch == ']') {\n            array_push($closeIdx, $i);\n        }\n    }\n    \n    $closeIdx = array_reverse($closeIdx);\n    $cnt = 0;\n    $i = 0;\n    $l = count($closeIdx);\n    \n    foreach ($openIdx as $idx) {\n        if ($i < $l && $idx < $closeIdx[$i]) {\n            $cnt++;\n            $i++;\n        }\n    }\n    \n    return $cnt >= 2;\n}\n```",
            "```php\n/**\n * @param {array<float>} $lst\n * @returns {int}\n */\nfunction sumSquares ($lst) {\n    return array_sum(array_map(function($n) {\n        return pow(ceil($n), 2);\n    }, $lst));\n}\n```",
            "```javascript\n/**\n * @param {string} $txt\n * @returns {bool}\n */\nfunction checkIfLastCharIsALetter($txt) {\n    if ($txt === null || strlen($txt) === 0) {\n        return false;\n    }\n    $lastSpaceIndex = strrpos($txt, ' ');\n    if ($lastSpaceIndex === false) {\n        $lastPart = $txt;\n    } else {\n        $lastPart = substr($txt, $lastSpaceIndex + 1);\n    }\n    return strlen($lastPart) === 1 && ctype_alpha($lastPart[0]);\n}\n```",
            "```php\n/**\n * @param {array<int>} $arr\n * @returns {int}\n */\nfunction canArrange ($arr) {\n    if (count($arr) <= 1) {\n        return -1;\n    }\n    $idx = -1;\n    for ($i = 1; $i < count($arr); $i++) {\n        if ($arr[$i] < $arr[$i - 1]) {\n            $idx = $i;\n        }\n    }\n    return $idx;\n}\n```",
            "```php\n/**\n * @param {array<int>} $lst\n * @returns {array<int | null>}\n */\nfunction largestSmallestIntegers ($lst) {\n    $neg = [];\n    $pos = [];\n    \n    foreach ($lst as $i) {\n        if ($i < 0) {\n            $neg[] = $i;\n        } else if ($i > 0) {\n            $pos[] = $i;\n        }\n    }\n    \n    $maxNeg = !empty($neg) ? max($neg) : null;\n    $minPos = !empty($pos) ? min($pos) : null;\n    \n    return [$maxNeg, $minPos];\n}\n```",
            "```php\n/**\n * @param {mixed} $a\n * @param {mixed} $b\n * @returns {float | null}\n */\nfunction compareOne($a, $b) {\n    $a1 = anyToReal($a);\n    $b1 = anyToReal($b);\n    if ($a1 == $b1) {\n        return null;\n    } elseif ($a1 > $b1) {\n        return $a1;\n    } else {\n        return $b1;\n    }\n}\n\nfunction anyToReal($o) {\n    if (is_string($o)) {\n        return floatval(str_replace(',', '.', $o));\n    } elseif (is_int($o)) {\n        return (float)$o;\n    } elseif (is_float($o)) {\n        return $o;\n    } else {\n        throw new RuntimeException(\"Type Error\");\n    }\n}\n```",
            "```php\n/**\n * @param {int} $n\n * @returns {bool}\n */\nfunction isEqualToSumEven($n) {\n    return $n % 2 == 0 && $n >= 8;\n}\n```",
            "```php\n/**\n * @param {int} $n\n * @returns {int}\n */\nfunction specialFactorial ($n) {\n    $fact = 1;\n    $result = 1;\n    for ($i = 1; $i <= $n; $i++) {\n        $fact *= $i;\n        $result *= $fact;\n    }\n    return $result;\n}\n```",
            "```php\n/**\n * @param {string} $txt\n * @returns {string}\n */\nfunction fixSpaces ($txt) {\n    return preg_replace('/\\s{3,}/', '-', str_replace(' ', '_', $txt));\n}\n```",
            "```php\n/**\n * @param {string} $fileName\n * @returns {string}\n */\nfunction fileNameCheck($fileName) {\n    $suf = [\"txt\", \"exe\", \"dll\"];\n    $lst = explode('.', $fileName);\n\n    if (count($lst) != 2 || !in_array($lst[1], $suf) || empty($lst[0]) || !ctype_alpha($lst[0][0]) || preg_match_all('/\\d/', $lst[0]) > 3) {\n        return \"No\";\n    }\n\n    return \"Yes\";\n}\n```",
            "```php\n/**\n * @param {array<int>} $lst\n * @returns {int}\n */\nfunction sumSquares ($lst) {\n    $result = 0;\n    for ($i = 0; $i < count($lst); $i++) {\n        if ($i % 3 == 0) {\n            $result += pow($lst[$i], 2);\n        } elseif ($i % 4 == 0) {\n            $result += pow($lst[$i], 3);\n        } else {\n            $result += $lst[$i];\n        }\n    }\n    return $result;\n}\n```",
            "```php\nfunction isPrime($n) {\n    if ($n < 2) {\n        return false;\n    }\n    for ($i = 2; $i <= sqrt($n); $i++) {\n        if ($n % $i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n * @param {string} $sentence\n * @returns {string}\n */\nfunction wordsInSentence ($sentence) {\n    $words = explode(\" \", $sentence);\n    $result = [];\n    foreach ($words as $w) {\n        if (isPrime(strlen($w))) {\n            $result[] = $w;\n        }\n    }\n    return implode(\" \", $result);\n}\n```",
            "```php\n/**\n * @param {string} $x\n * @param {string} $n\n * @returns {bool}\n */\nfunction simplify($x, $n) {\n    $xs = explode(\"/\", $x);\n    $ns = explode(\"/\", $n);\n    $num = (int)$xs[0] * (int)$ns[0];\n    $den = (int)$xs[1] * (int)$ns[1];\n    return $num % $den == 0;\n}\n```",
            "```php\n/**\n * @param {array<int>} $nums\n * @returns {array<int>}\n */\nfunction orderByPoints($nums) {\n    usort($nums, function($a, $b) {\n        return compareByDigitsSum($a, $b);\n    });\n    return $nums;\n}\n\n/**\n * Helper function to calculate the sum of digits of a number.\n * @param {int} $n\n * @returns {int}\n */\nfunction digitsSum($n) {\n    $n_str = strval(abs($n));\n    $sum = 0;\n    for ($i = 0; $i < strlen($n_str); $i++) {\n        $sum += intval($n_str[$i]);\n    }\n    if ($n < 0 && strlen($n_str) > 1) {\n        $sum += intval($n_str[0]) * 2;\n    }\n    return $sum;\n}\n\n/**\n * Helper function to compare two numbers based on their digits sum.\n * @param {int} $a\n * @param {int} $b\n * @returns {int}\n */\nfunction compareByDigitsSum($a, $b) {\n    $digitsSumA = digitsSum($a);\n    $digitsSumB = digitsSum($b);\n    if ($digitsSumA == $digitsSumB) {\n        return 0;\n    }\n    return ($digitsSumA < $digitsSumB) ? -1 : 1;\n}\n```",
            "```php\n/**\n * @param {array<int>} $nums\n * @returns {int}\n */\nfunction specialFilter ($nums) {\n    $odds = \"13579\";\n    $count = 0;\n    foreach ($nums as $n) {\n        if ($n > 10 && $n % 2 == 1 && strpos($odds, strval($n)[0]) !== false) {\n            $count++;\n        }\n    }\n    return $count;\n}\n```",
            "```php\n/**\n * @param {int} $n\n * @returns {int}\n */\nfunction getMaxTriples ($n) {\n    $c = [0, 0, 0];\n    for ($i = 1; $i <= $n; $i++) {\n        $a = $i * $i - $i + 1;\n        $c[$a % 3]++;\n    }\n    return $c[0] * $c[1] * $c[2] + \n           ($c[0] * ($c[0] - 1) * ($c[0] - 2) + \n            $c[1] * ($c[1] - 1) * ($c[1] - 2) + \n            $c[2] * ($c[2] - 1) * ($c[2] - 2)) / 6;\n}\n```",
            "```php\n/**\n * @param {string} $planet1\n * @param {string} $planet2\n * @returns {array<string>}\n */\nfunction bf($planet1, $planet2) {\n    $names = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"];\n    if (!in_array($planet1, $names) || !in_array($planet2, $names)) {\n        return [];\n    }\n    $l = array_search($planet1, $names);\n    $r = array_search($planet2, $names);\n    if ($l > $r) {\n        $temp = $l;\n        $l = $r;\n        $r = $temp;\n    }\n    if ($l == $r) {\n        return [];\n    }\n    return array_slice($names, $l + 1, $r - $l - 1);\n}\n```",
            "```php\nfunction sortedListSum($lst) {\n    $result = [];\n    foreach ($lst as $s) {\n        if (strlen($s) % 2 == 0) {\n            $result[] = $s;\n        }\n    }\n    usort($result, function($x, $y) {\n        return strlen($x) != strlen($y) ? strlen($x) - strlen($y) : strcmp($x, $y);\n    });\n    return $result;\n}\n```",
            "```php\n/**\n * @param {int} $n\n * @param {int} $x\n * @param {int} $y\n * @returns {int}\n */\nfunction xOrY ($n, $x, $y) {\n    if ($n < 2) {\n        return $y;\n    }\n    for ($i = 2; $i <= sqrt($n); $i++) {\n        if ($n % $i == 0) {\n            return $y;\n        }\n    }\n    return $x;\n}\n```",
            "```php\n/**\n * @param {array<float>} $lst\n * @returns {int}\n */\nfunction doubleTheDifference ($lst) {\n    return (int) array_sum(array_map(function($n) {\n        return $n * $n;\n    }, array_filter($lst, function($n) {\n        return $n >= 0 && $n % 2 == 1;\n    })));\n}\n```",
            "```php\n/**\n * @param {array<int>} $game\n * @param {array<int>} $guess\n * @returns {array<int>}\n */\nfunction compare ($game, $guess) {\n    $result = [];\n    for ($i = 0; $i < count($game); $i++) {\n        $result[] = abs($game[$i] - $guess[$i]);\n    }\n    return $result;\n}\n```",
            "```php\n/**\n * @param {string} $className\n * @param {array<string>} $extensions\n * @returns {string}\n */\nfunction strongestExtension ($className, $extensions) {\n    $max_s = PHP_INT_MIN;\n    $max_ext = \"\";\n    foreach ($extensions as $ext) {\n        $upper = 0;\n        $lower = 0;\n        for ($i = 0; $i < strlen($ext); $i++) {\n            $c = $ext[$i];\n            if (ctype_upper($c)) $upper++;\n            else if (ctype_lower($c)) $lower++;\n        }\n        $s = $upper - $lower;\n        if ($s > $max_s) {\n            $max_s = $s;\n            $max_ext = $ext;\n        }\n    }\n    return $className . \".\" . $max_ext;\n}\n```",
            "```php\n/**\n * @param {string} $a\n * @param {string} $b\n * @returns {bool}\n */\nfunction cycpatternCheck ($a, $b) {\n    if (strlen($a) < strlen($b)) {\n        return false;\n    }\n    for ($i = 0; $i < strlen($b); $i++) {\n        $rotatedB = substr($b, $i) . substr($b, 0, $i);\n        if (strpos($a, $rotatedB) !== false) {\n            return true;\n        }\n    }\n    return false;\n}\n```",
            "```php\n/**\n * @param {int} $num\n * @returns {array<int>}\n */\nfunction evenOddCount ($num) {\n    $ds = strval(abs($num));\n    $even = 0;\n    for ($i = 0; $i < strlen($ds); $i++) {\n        if (intval($ds[$i]) % 2 == 0) {\n            $even++;\n        }\n    }\n    return [$even, strlen($ds) - $even];\n}\n```",
            "```php\n/**\n * @param {int} $num\n * @returns {string}\n */\nfunction intToMiniRoman ($num) {\n    $values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    $numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    $res = \"\";\n    for ($i = 0; $i < count($values); $i++) {\n        while ($num >= $values[$i]) {\n            $res .= $numerals[$i];\n            $num -= $values[$i];\n        }\n    }\n    return $res;\n}\n```",
            "```php\n/**\n * @param {int} $a\n * @param {int} $b\n * @param {int} $c\n * @returns {bool}\n */\nfunction rightAngleTriangle ($a, $b, $c) {\n    $s = [$a, $b, $c];\n    sort($s);\n    return $s[0] * $s[0] + $s[1] * $s[1] == $s[2] * $s[2];\n}\n```",
            "```php\n/**\n * @param {array<string>} $words\n * @returns {string}\n */\nfunction findMax ($words) {\n    $maxCnt = 0;\n    $maxW = \"\";\n    foreach ($words as $w) {\n        $uniqueChars = array_unique(str_split($w));\n        $cnt = count($uniqueChars);\n        if ($cnt > $maxCnt) {\n            $maxCnt = $cnt;\n            $maxW = $w;\n        } elseif ($cnt == $maxCnt) {\n            $maxW = strcmp($maxW, $w) < 0 ? $maxW : $w;\n        }\n    }\n    return $maxW;\n}\n```",
            "```php\n/**\n * @param int $num\n * @param int $need\n * @param int $remaining\n * @return array<int>\n */\nfunction eat($num, $need, $remaining) {\n    if ($need <= $remaining) {\n        return [$num + $need, $remaining - $need];\n    } else {\n        return [$num + $remaining, 0];\n    }\n}\n```",
            "```php\nfunction doAlgebra ($operators, $operands) {\n    $ops = array_merge($operators);\n    $nums = array_merge($operands);\n    $i = count($ops) - 1;\n    while ($i >= 0) {\n        if ($ops[$i] === \"**\") {\n            $nums[$i] = pow($nums[$i], $nums[$i + 1]);\n            array_splice($nums, $i + 1, 1);\n            array_splice($ops, $i, 1);\n        }\n        $i--;\n    }\n    $i = 0;\n    while ($i < count($ops)) {\n        if ($ops[$i] === \"*\") {\n            $nums[$i] *= $nums[$i + 1];\n            array_splice($nums, $i + 1, 1);\n            array_splice($ops, $i, 1);\n            $i--;\n        } elseif ($ops[$i] === \"//\") {\n            $nums[$i] = intdiv($nums[$i], $nums[$i + 1]);\n            array_splice($nums, $i + 1, 1);\n            array_splice($ops, $i, 1);\n            $i--;\n        }\n        $i++;\n    }\n    $i = 0;\n    while ($i < count($ops)) {\n        if ($ops[$i] === \"+\") {\n            $nums[$i] += $nums[$i + 1];\n            array_splice($nums, $i + 1, 1);\n            array_splice($ops, $i, 1);\n            $i--;\n        } elseif ($ops[$i] === \"-\") {\n            $nums[$i] -= $nums[$i + 1];\n            array_splice($nums, $i + 1, 1);\n            array_splice($ops, $i, 1);\n            $i--;\n        }\n        $i++;\n    }\n    return $nums[0];\n}\n```",
            "```php\n/**\n * @param {string} $s\n * @returns {string}\n */\nfunction solve($s) {\n    if (!preg_match('/[a-zA-Z]/', $s)) {\n        return strrev($s);\n    }\n    $result = '';\n    for ($i = 0; $i < strlen($s); $i++) {\n        $ch = $s[$i];\n        if (!ctype_alpha($ch)) {\n            $result .= $ch;\n        } elseif (ctype_upper($ch)) {\n            $result .= strtolower($ch);\n        } elseif (ctype_lower($ch)) {\n            $result .= strtoupper($ch);\n        }\n    }\n    return $result;\n}\n```",
            "```php\n/**\n * @param {string} $txt\n * @returns {string | null}\n */\nfunction stringToMd5($txt) {\n    if (!$txt) {\n        return null;\n    }\n    $md5_hash = md5($txt);\n    return $md5_hash;\n}\n```",
            "```php\nfunction generateIntegers($a, $b) {\n    $lower = max(2, min($a, $b));\n    $upper = min(8, max($a, $b));\n    $result = array();\n    for ($i = $lower; $i <= $upper; $i++) {\n        if ($i % 2 == 0) {\n            $result[] = $i;\n        }\n    }\n    return $result;\n}\n```"
        ],
        "dart": [
            "```dart\nbool hasCloseElements(List<double> numbers, double threshold) {\n    for (int i = 0; i < numbers.length; i++) {\n        for (int j = i + 1; j < numbers.length; j++) {\n            if ((numbers[i] - numbers[j]).abs() < threshold) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```",
            "```dart\nList<String> separateParenGroups(String parenString) {\n    List<String> groups = [];\n    List<String> stk = [];\n    String currentGroup = \"\";\n    String parens = parenString.replaceAll(\" \", \"\");\n    \n    for (var ch in parens.runes.map((rune) => String.fromCharCode(rune))) {\n        if (ch == \"(\") {\n            stk.add(ch);\n            currentGroup += ch;\n        } else if (ch == \")\") {\n            stk.removeLast();\n            currentGroup += ch;\n            if (stk.isEmpty) {\n                groups.add(currentGroup);\n                currentGroup = \"\";\n            }\n        }\n    }\n    \n    return groups;\n}\n```",
            "```dart\ndouble truncateNumber(double num) {\n    return num - num.floor();\n}\n```",
            "```dart\nbool belowZero(List<int> operations) {\n  int balance = 0;\n  for (int op in operations) {\n    balance += op;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}\n```",
            "```dart\ndouble meanAbsoluteDeviation(List<double> numbers) {\n    double sum = 0;\n    for (double num in numbers) {\n        sum += num;\n    }\n    double mean = sum / numbers.length;\n    \n    double deviationSum = 0;\n    for (double num in numbers) {\n        deviationSum += (num - mean).abs();\n    }\n    \n    return deviationSum / numbers.length;\n}\n```",
            "```dart\nList<int> intersperse(List<int> numbers, int delimiter) {\n    List<int> result = [];\n    for (int i = 0; i < numbers.length; i++) {\n        if (i != 0) {\n            result.add(delimiter);\n        }\n        result.add(numbers[i]);\n    }\n    return result;\n}\n```",
            "```dart\nList<int> parseNestedParens(String parenString) {\n    List<int> result = [];\n    List<String> parenGroups = parenString.split(' ');\n    for (String group in parenGroups) {\n        int maxDepth = 0;\n        int depth = 0;\n        for (int i = 0; i < group.length; i++) {\n            String ch = group[i];\n            if (ch == '(') {\n                depth += 1;\n                maxDepth = depth > maxDepth ? depth : maxDepth;\n            } else if (ch == ')') {\n                depth -= 1;\n            }\n        }\n        result.add(maxDepth);\n    }\n    return result;\n}\n```",
            "```dart\nList<String> filterBySubstring(List<String> strs, String substring) {\n    List<String> result = [];\n    for (String s in strs) {\n        if (s.contains(substring)) {\n            result.add(s);\n        }\n    }\n    return result;\n}\n```",
            "```dart\nList<int> sumProduct(List<int> numbers) {\n  int n_sum = numbers.reduce((x, y) => x + y);\n  int n_product = numbers.fold(1, (x, y) => x * y);\n  return [n_sum, n_product];\n}\n```",
            "```dart\nList<int> rollingMax(List<int> numbers) {\n    int maxSoFar = -2147483648; // Integer.MIN_VALUE in Java\n    List<int> result = [];\n    for (int num in numbers) {\n        maxSoFar = max(maxSoFar, num);\n        result.add(maxSoFar);\n    }\n    return result;\n}\n```",
            "```dart\nString makePalindrome(String s) {\n    if (isPalindrome(s)) {\n        return s;\n    }\n    for (int i = 0; i < s.length; i++) {\n        if (isPalindrome(s.substring(i))) {\n            String prefix = s.substring(0, i);\n            String reversedPrefix = String.fromCharCodes(prefix.codeUnits.reversed.toList());\n            return s + reversedPrefix;\n        }\n    }\n    return \"\";\n}\n\nbool isPalindrome(String s) {\n    int left = 0;\n    int right = s.length - 1;\n    while (left < right) {\n        if (s[left] != s[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n```",
            "```dart\nString stringXor(String a, String b) {\n    StringBuffer result = StringBuffer();\n    for (int i = 0; i < a.length && i < b.length; i++) {\n        char x = a[i];\n        char y = b[i];\n        result.write((x == y) ? \"0\" : \"1\");\n    }\n    return result.toString();\n}\n```",
            "```dart\nString? longest(List<String> strs) {\n    if (strs.isEmpty) {\n        return null;\n    }\n    String longest_s = strs[0];\n    for (String s in strs) {\n        if (s.length > longest_s.length) {\n            longest_s = s;\n        }\n    }\n    return longest_s;\n}\n```",
            "```dart\nint greatestCommonDivisor(int a, int b) {\n    if (b == 0) {\n        return a;\n    } else {\n        return greatestCommonDivisor(b, a % b);\n    }\n}\n```",
            "```dart\nList<String> allPrefixes(String s) {\n    List<String> prefixes = [];\n    for (int i = 0; i < s.length; i++) {\n        prefixes.add(s.substring(0, i + 1));\n    }\n    return prefixes;\n}\n```",
            "```dart\nString stringSequence(int n) {\n    StringBuffer result = StringBuffer();\n    for (int i = 0; i <= n; i++) {\n        result.write(i);\n        if (i < n) {\n            result.write(\" \");\n        }\n    }\n    return result.toString();\n}\n```",
            "```dart\nint countDistinctCharacters(String s) {\n    return s.toLowerCase().split('').toSet().length;\n}\n```",
            "```dart\nList<int> parseMusic(String musicString) {\n  Map<String, int> durations = {\"o\": 4, \"o|\": 2, \".|\": 1};\n  List<String> notes = musicString.split(\" \");\n  return notes.map((note) => durations[note]!).toList();\n}\n```",
            "```dart\nint howManyTimes(String s, String substring) {\n    int times = 0;\n    for (int i = 0; i <= s.length - substring.length; i++) {\n        if (s.substring(i, i + substring.length) == substring) {\n            times++;\n        }\n    }\n    return times;\n}\n```",
            "```dart\nString sortNumbers(String numbers) {\n  Map<String, int> numDict = {\n    'zero': 0,\n    'one': 1,\n    'two': 2,\n    'three': 3,\n    'four': 4,\n    'five': 5,\n    'six': 6,\n    'seven': 7,\n    'eight': 8,\n    'nine': 9\n  };\n\n  List<String> numList = numbers.split(' ').where((num) => numDict.containsKey(num)).toList();\n\n  numList.sort((a, b) => numDict[a]!.compareTo(numDict[b]!));\n\n  return numList.join(' ');\n}\n```",
            "```dart\nList<double> findClosestElements(List<double> numbers) {\n    List<double> sortedNumbers = List.from(numbers)..sort();\n    double minDiff = double.infinity;\n    List<double> closestPair = [];\n    for (int i = 1; i < sortedNumbers.length; i++) {\n        double diff = sortedNumbers[i] - sortedNumbers[i - 1];\n        if (diff < minDiff) {\n            minDiff = diff;\n            closestPair = [sortedNumbers[i - 1], sortedNumbers[i]];\n        }\n    }\n    return closestPair;\n}\n```",
            "```dart\nList<double> rescaleToUnit(List<double> numbers) {\n    double minNum = numbers.reduce((a, b) => a < b ? a : b);\n    double maxNum = numbers.reduce((a, b) => a > b ? a : b);\n    if (minNum == maxNum) {\n        return List.filled(numbers.length, 0.0);\n    } else {\n        List<double> result = [];\n        for (double num in numbers) {\n            result.add((num - minNum) / (maxNum - minNum));\n        }\n        return result;\n    }\n}\n```",
            "```dart\nList<int> filterIntegers(List<Object> values) {\n    return values.where((x) => x is int).map((x) => x as int).toList();\n}\n```",
            "```dart\nint strLength(String s) {\n    return s.length;\n}\n```",
            "```dart\nint largestDivisor(int n) {\n    for (int i = 2; i < n; i++) {\n        if (n % i == 0) {\n            return n ~/ i;\n        }\n    }\n    return 1;\n}\n```",
            "```dart\nList<int> factorize(int n) {\n    List<int> factors = [];\n    int divisor = 2;\n    while (divisor <= n) {\n        if (n % divisor == 0) {\n            factors.add(divisor);\n            n ~/= divisor;\n        } else {\n            divisor += 1;\n        }\n    }\n    return factors;\n}\n```",
            "```dart\nList<int> removeDuplicates(List<int> numbers) {\n    Map<int, int> counts = {};\n    for (int num in numbers) {\n        counts[num] = (counts[num] ?? 0) + 1;\n    }\n    List<int> res = [];\n    for (int num in numbers) {\n        if (counts[num] == 1) {\n            res.add(num);\n        }\n    }\n    return res;\n}\n```",
            "```dart\nString flipCase(String s) {\n    List<String> flipped = [];\n    for (int i = 0; i < s.length; i++) {\n        String ch = s[i];\n        if (!RegExp(r'[a-zA-Z]').hasMatch(ch)) {\n            flipped.add(ch);\n        } else if (ch == ch.toLowerCase()) {\n            flipped.add(ch.toUpperCase());\n        } else if (ch == ch.toUpperCase()) {\n            flipped.add(ch.toLowerCase());\n        }\n    }\n    return flipped.join('');\n}\n```",
            "```dart\nString concatenate(List<String> strs) {\n    StringBuffer result = StringBuffer();\n    for (String str in strs) {\n        result.write(str);\n    }\n    return result.toString();\n}\n```",
            "```dart\nList<String> filterByPrefix(List<String> strs, String prefixStr) {\n    return strs.where((s) => s.startsWith(prefixStr)).toList();\n}\n```",
            "```dart\nList<int> getPositive(List<int> l) {\n    return l.where((num) => num > 0).toList();\n}\n```",
            "```dart\nbool isPrime(int n) {\n    if (n < 2) {\n        return false;\n    }\n    for (int i = 2; i <= Math.sqrt(n); i++) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```",
            "```dart\ndouble poly(List<int> xs, double x) {\n    double res = 0.0;\n    for (int i = 0; i < xs.length; i++) {\n        res += xs[i] * pow(x, i);\n    }\n    return res;\n}\n\ndouble findZero(List<int> xs) {\n    double x1 = 1.0, x2 = -1.0;\n    while (poly(xs, x1) * poly(xs, x2) > 0) {\n        x1 *= 2;\n        x2 *= 2;\n    }\n    while ((x1 - x2).abs() > 1e-10) {\n        double mid = (x1 + x2) / 2;\n        if (poly(xs, mid) == 0) {\n            return mid;\n        } else if (poly(xs, mid) * poly(xs, x1) < 0) {\n            x2 = mid;\n        } else {\n            x1 = mid;\n        }\n    }\n    return (x1 + x2) / 2;\n}\n```",
            "```dart\nList<int> sortThird(List<int> l) {\n  List<int> sortedThird = List.from(l).sublist(0, l.length, 3)..sort();\n  return l.map((int x) => l.indexOf(x) % 3 == 0 ? sortedThird[l.indexOf(x) ~/ 3] : x).toList();\n}\n```",
            "```dart\nList<int> listUnique(List<int> l) {\n    Set<int> set = l.toSet();\n    List<int> sortedList = set.toList()..sort();\n    return sortedList;\n}\n```",
            "```dart\nint maxElement(List<int> l) {\n    if (l.isEmpty()) {\n        return 0;\n    }\n    return l.reduce((a, b) => a > b ? a : b);\n}\n```",
            "```dart\nint fizzBuzz(int n) {\n    int cnt = 0;\n    for (int i = 0; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            String str = i.toString();\n            for (char c in str.codeUnits) {\n                if (c == '7'.codeUnitAt(0)) {\n                    cnt++;\n                }\n            }\n        }\n    }\n    return cnt;\n}\n```",
            "```dart\nList<int> sortEven(List<int> l) {\n  List<int> sortedEven = l.where((e, i) => i % 2 == 0).toList()..sort();\n  return List<int>.generate(l.length, (i) => i % 2 == 0 ? sortedEven[i ~/ 2] : l[i]);\n}\n```",
            "```dart\nString encodeCyclic(String s) {\n  StringBuffer result = StringBuffer();\n  for (int i = 0; i < s.length; i += 3) {\n    if (i + 3 > s.length) {\n      result.write(s.substring(i));\n    } else {\n      result.write(s.substring(i + 1, i + 3));\n      result.write(s[i]);\n    }\n  }\n  return result.toString();\n}\n\nString decodeCyclic(String s) {\n  return encodeCyclic(encodeCyclic(s));\n}\n```",
            "```dart\nbool isPrime(int n) {\n  if (n < 2) return false;\n  for (int i = 2; i <= sqrt(n).toInt(); i++) {\n    if (n % i == 0) return false;\n  }\n  return true;\n}\n\nint primeFib(int n) {\n  List<int> f = [0, 1];\n  int cnt = 0;\n  while (cnt < n) {\n    f = [f[1], f[0] + f[1]];\n    if (isPrime(f[1])) {\n      cnt++;\n    }\n  }\n  return f[1];\n}\n```",
            "```dart\nbool triplesSumToZero(List<int> l) {\n    for (int i = 0; i < l.length; i++) {\n        for (int j = i + 1; j < l.length; j++) {\n            for (int k = j + 1; k < l.length; k++) {\n                if (l[i] + l[j] + l[k] == 0) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```",
            "```dart\nint carRaceCollision(int n) {\n    return n * n;\n}\n```",
            "```dart\nList<int> incrList(List<int> l) {\n    List<int> result = [];\n    for (int i in l) {\n        result.add(i + 1);\n    }\n    return result;\n}\n```",
            "```dart\nbool pairsSumToZero(List<int> l) {\n    Set<int> seen = {};\n    for (int num in l) {\n        if (seen.contains(-num)) {\n            return true;\n        }\n        seen.add(num);\n    }\n    return false;\n}\n```",
            "```dart\nString changeBase(int x, int bas) {\n    if (x == 0) {\n        return \"0\";\n    }\n    StringBuffer digits = StringBuffer();\n    while (x > 0) {\n        digits.write(x % bas);\n        x ~/= bas;\n    }\n    return digits.toString().split('').reversed.join('');\n}\n```",
            "```dart\ndouble triangleArea(int a, int h) {\n    return (a * h) / 2;\n}\n```",
            "```dart\nint fib4(int n) {\n    List<int> fib = [0, 0, 2, 0];\n    for (int i = 4; i <= n; i++) {\n        fib[i % 4] = fib[0] + fib[1] + fib[2] + fib[3];\n    }\n    return fib[n % 4];\n}\n```",
            "```dart\ndouble median(List<double> l) {\n    List<double> sl = List.from(l)..sort();\n    if (l.length % 2 != 0) {\n        return sl[l.length ~/ 2];\n    } else {\n        return (sl[l.length ~/ 2] + sl[(l.length ~/ 2) - 1]) / 2;\n    }\n}\n```",
            "```dart\nbool isPalindrome(String txt) {\n    int n = txt.length;\n    for (int i = 0; i < n / 2; i++) {\n        if (txt[i] != txt[n - 1 - i]) {\n            return false;\n        }\n    }\n    return true;\n}\n```",
            "```dart\nint modp(int n, int p) {\n    int ret = 1;\n    for (int i = 0; i < n; i++) {\n        ret = (ret * 2) % p;\n    }\n    return ret;\n}\n```",
            "```dart\nString encodeShift(String s) {\n    StringBuffer result = StringBuffer();\n    for (int i = 0; i < s.length; i++) {\n        int ch = s.codeUnitAt(i);\n        result.writeCharCode(((ch - 'a'.codeUnitAt(0) + 5) % 26) + 'a'.codeUnitAt(0));\n    }\n    return result.toString();\n}\n\nString decodeShift(String s) {\n    StringBuffer result = StringBuffer();\n    for (int i = 0; i < s.length; i++) {\n        int ch = s.codeUnitAt(i);\n        result.writeCharCode(((ch - 'a'.codeUnitAt(0) + 21) % 26) + 'a'.codeUnitAt(0));\n    }\n    return result.toString();\n}\n```",
            "```dart\nString removeVowels(String txt) {\n    String vowels = \"aeiouAEIOU\";\n    StringBuffer result = StringBuffer();\n    for (var c in txt.split(\"\")) {\n        if (!vowels.contains(c)) {\n            result.write(c);\n        }\n    }\n    return result.toString();\n}\n```",
            "```dart\nbool belowThreshold(List<int> l, int t) {\n    for (int x in l) {\n        if (x >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n```",
            "```dart\nint add(int x, int y) {\n    return x + y;\n}\n```",
            "```dart\nbool sameChars(String s0, String s1) {\n    return Set.from(s0.split('')).toList()..sort().toString() == Set.from(s1.split('')).toList()..sort().toString();\n}\n```",
            "```dart\nint fib(int n) {\n    if (n <= 1) {\n        return n;\n    } else {\n        return fib(n - 1) + fib(n - 2);\n    }\n}\n```",
            "```dart\nbool correctBracketing(String brackets) {\n    int depth = 0;\n    for (var b in brackets.codeUnits) {\n        if (b == '<'.codeUnitAt(0)) {\n            depth += 1;\n        } else if (b == '>'.codeUnitAt(0)) {\n            depth -= 1;\n        }\n        if (depth < 0) {\n            return false;\n        }\n    }\n    return depth == 0;\n}\n```",
            "```dart\nbool monotonic(List<int> l) {\n    if (l.length <= 1) return true;\n\n    int n = l.length;\n    bool nonDecreasing = true;\n    bool nonIncreasing = true;\n\n    for (int i = 0; i < n - 1; i++) {\n        if (l[i] > l[i + 1]) {\n            nonDecreasing = false;\n        }\n        if (l[i] < l[i + 1]) {\n            nonIncreasing = false;\n        }\n    }\n\n    return nonDecreasing || nonIncreasing;\n}\n```",
            "```dart\nList<int> common(List<int> l1, List<int> l2) {\n    Set<int> set1 = new Set.from(l1);\n    Set<int> set2 = new Set.from(l2);\n    set1.retainAll(set2);\n    List<int> result = new List.from(set1);\n    result.sort();\n    return result;\n}\n```",
            "```dart\nint largestPrimeFactor(int n) {\n    int i = 2;\n    while (i * i <= n) {\n        if (n % i != 0) {\n            i += 1;\n        } else {\n            n ~/= i;\n        }\n    }\n    return n;\n}\n```",
            "```dart\nint sumToN(int n) {\n    int sum = 0;\n    for (int i = 1; i <= n; i++) {\n        sum += i;\n    }\n    return sum;\n}\n```",
            "```dart\nbool correctBracketing(String brackets) {\n    int depth = 0;\n    for (var b in brackets.codeUnits) {\n        if (b == '(') {\n            depth += 1;\n        } else if (b == ')') {\n            depth -= 1;\n        }\n        if (depth < 0) {\n            return false;\n        }\n    }\n    return depth == 0;\n}\n```",
            "```dart\nList<int> derivative(List<int> xs) {\n    List<int> result = [];\n    for (int i = 1; i < xs.length; i++) {\n        result.add(xs[i] * i);\n    }\n    return result;\n}\n```",
            "```dart\nint fibfib(int n) {\n    if (n <= 1) return 0;\n    int a = 0, b = 0, c = 1;\n    while (n > 2) {\n        a = b;\n        b = c;\n        c = a + b + c;\n        n -= 1;\n    }\n    return c;\n}\n```",
            "```dart\nint vowelsCount(String s) {\n    String vowels = \"aeiou\";\n    int cnt = 0;\n    for (int i = 0; i < s.length; i++) {\n        if (vowels.contains(s[i].toLowerCase()) || \n            (i == s.length - 1 && s[i].toLowerCase() == 'y')) {\n            cnt++;\n        }\n    }\n    return cnt;\n}\n```",
            "```dart\nString circularShift(int x, int shift) {\n    String x_str = x.toString();\n    if (shift > x_str.length) {\n        return new StringBuffer(x_str).reverse().toString();\n    } else {\n        return x_str.substring(x_str.length - shift) + x_str.substring(0, x_str.length - shift);\n    }\n}\n```",
            "```dart\nint digitSum(String s) {\n    int sum = 0;\n    for (int i = 0; i < s.length; i++) {\n        String c = s[i];\n        if (c.toUpperCase() == c && !RegExp(r'\\d').hasMatch(c)) {\n            sum += c.codeUnitAt(0);\n        }\n    }\n    return sum;\n}\n```",
            "```dart\nint fruitDistribution(String s, int n) {\n    List<String> words = s.split(' ');\n    int apples = int.parse(words[words.indexOf(\"apples\") - 1]);\n    int oranges = int.parse(words[words.indexOf(\"oranges\") - 1]);\n    return n - apples - oranges;\n}\n```",
            "```dart\nList<int> pluck(List<int> arr) {\n    List<int> evens = [];\n    for (int n in arr) {\n        if (n % 2 == 0) {\n            evens.add(n);\n        }\n    }\n    if (evens.isEmpty) {\n        return const [];\n    }\n    int minEven = evens.reduce((a, b) => a < b ? a : b);\n    return [minEven, arr.indexOf(minEven)];\n}\n```",
            "```dart\nint search(List<int> lst) {\n  Map<int, int> freqs = {};\n  for (int n in lst) {\n    freqs[n] = (freqs[n] ?? 0) + 1;\n  }\n  List<int> goodVals = [];\n  for (MapEntry<int, int> entry in freqs.entries) {\n    if (entry.value >= entry.key) {\n      goodVals.add(entry.key);\n    }\n  }\n  return goodVals.isNotEmpty ? goodVals.reduce((a, b) => a > b ? a : b) : -1;\n}\n```",
            "```dart\nList<int> strangeSortList(List<int> lst) {\n    List<int> sl = List.from(lst);\n    sl.sort();\n    List<int> result = [];\n    int left = 0, right = sl.length - 1;\n    while (left <= right) {\n        result.add(sl[left]);\n        left += 1;\n        if (left <= right) {\n            result.add(sl[right]);\n            right -= 1;\n        }\n    }\n    return result;\n}\n```",
            "```dart\ndouble triangleArea(int a, int b, int c) {\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return Math.sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        return -1.0;\n    }\n}\n```",
            "```dart\nbool willItFly(List<int> q, int w) {\n    if (q.isEmpty) {\n        return false;\n    }\n    bool isPali = true;\n    for (int i = 0; i < q.length; i++) {\n        if (q[i] != q[q.length - i - 1]) {\n            isPali = false;\n            break;\n        }\n    }\n    int total = 0;\n    for (int num in q) {\n        total += num;\n    }\n    return isPali && total <= w;\n}\n```",
            "```dart\nint smallestChange(List<int> arr) {\n    int ans = 0;\n    for (int i = 0; i < arr.length ~/ 2; i++) {\n        if (!arr[i].equals(arr[arr.length - i - 1])) {\n            ans += 1;\n        }\n    }\n    return ans;\n}\n```",
            "```dart\nList<String> totalMatch(List<String> lst1, List<String> lst2) {\n  int cnt1 = lst1.map((s) => s.length).reduce((a, b) => a + b);\n  int cnt2 = lst2.map((s) => s.length).reduce((a, b) => a + b);\n  return cnt1 <= cnt2 ? lst1 : lst2;\n}\n```",
            "```dart\nbool isPrime(int n) {\n    if (n < 2) {\n        return false;\n    }\n    for (int i = 2; i <= sqrt(n).toInt(); i++) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool isMultiplyPrime(int a) {\n    int cnt = 0;\n    for (int i = 2; i <= a; i++) {\n        if (isPrime(i)) {\n            while (a % i == 0) {\n                cnt += 1;\n                a ~/= i;\n            }\n        }\n    }\n    return cnt == 3;\n}\n```",
            "```dart\nbool isSimplePower(int x, int n) {\n    if (n < 2) {\n        return x == n;\n    }\n    int tmp = 1;\n    while (tmp < x) {\n        tmp *= n;\n    }\n    return tmp == x;\n}\n```",
            "```dart\nbool isCube(int a) {\n    a = a.abs();\n    int root = (a.cbrt()).round();\n    return root * root * root == a;\n}\n```",
            "```dart\nint hexKey(String num) {\n    int count = 0;\n    for (var x in num.codeUnits) {\n        if (\"2357BD\".contains(String.fromCharCode(x))) {\n            count++;\n        }\n    }\n    return count;\n}\n```",
            "```dart\nString decimalToBinary(int dec) {\n    String binary = dec.toRadixString(2);\n    return \"db\" + binary + \"db\";\n}\n```",
            "```dart\nbool isHappy(String s) {\n    if (s.length < 3) {\n        return false;\n    }\n    for (int i = 0; i < s.length - 2; i++) {\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n    return true;\n}\n```",
            "```dart\nList<String> numericalLetterGrade(List<double> grades) {\n    List<String> result = [];\n    for (double g in grades) {\n        if (g == 4.0) {\n            result.add(\"A+\");\n        } else if (g > 3.7) {\n            result.add(\"A\");\n        } else if (g > 3.3) {\n            result.add(\"A-\");\n        } else if (g > 3.0) {\n            result.add(\"B+\");\n        } else if (g > 2.7) {\n            result.add(\"B\");\n        } else if (g > 2.3) {\n            result.add(\"B-\");\n        } else if (g > 2.0) {\n            result.add(\"C+\");\n        } else if (g > 1.7) {\n            result.add(\"C\");\n        } else if (g > 1.3) {\n            result.add(\"C-\");\n        } else if (g > 1.0) {\n            result.add(\"D+\");\n        } else if (g > 0.7) {\n            result.add(\"D\");\n        } else if (g > 0.0) {\n            result.add(\"D-\");\n        } else {\n            result.add(\"E\");\n        }\n    }\n    return result;\n}\n```",
            "```dart\nbool primeLength(String s) {\n    int length = s.length;\n    if (length < 2) {\n        return false;\n    }\n    for (int i = 2; i <= Math.sqrt(length); i++) {\n        if (length % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```",
            "```dart\nint startsOneEnds(int n) {\n    if (n == 1) {\n        return 1;\n    }\n    return 2 * 9 * (10^(n - 2)).toInt();\n}\n```",
            "```dart\nString solve(int n) {\n    int digitsSum = 0;\n    while (n > 0) {\n        digitsSum += n % 10;\n        n ~/= 10;\n    }\n    return digitsSum.toBinaryString();\n}\n```",
            "```dart\nint add(List<int> lst) {\n    int sum = 0;\n    for (int i = 1; i < lst.length; i += 2) {\n        int x = lst[i];\n        if (x % 2 == 0) {\n            sum += x;\n        }\n    }\n    return sum;\n}\n```",
            "```dart\nString antiShuffle(String s) {\n    List<String> words = s.split(\" \");\n    String result = '';\n\n    for (String word in words) {\n        List<String> chars = word.split('');\n        chars.sort();\n        result += chars.join('') + ' ';\n    }\n\n    return result.trim();\n}\n```",
            "```dart\nList<List<int>> getRow(List<List<int>> lst, int x) {\n    List<List<int>> coords = [];\n    for (int i = 0; i < lst.length; i++) {\n        for (int j = 0; j < lst[i].length; j++) {\n            if (lst[i][j] == x) {\n                List<int> coord = [i, j];\n                coords.add(coord);\n            }\n        }\n    }\n    coords.sort((a, b) => a[0] != b[0] ? a[0] - b[0] : -a[1] + b[1]);\n    return coords;\n}\n```",
            "```dart\nList<int> sortArray(List<int> arr) {\n    if (arr.isEmpty) {\n        return [];\n    }\n    if ((arr[0] + arr[arr.length - 1]) % 2 == 0) {\n        return List.from(arr)..sort((a, b) => b.compareTo(a));\n    } else {\n        return List.from(arr)..sort();\n    }\n}\n```",
            "```dart\nString encrypt(String s) {\n    StringBuffer result = StringBuffer();\n    for (int i = 0; i < s.length; i++) {\n        String ch = s[i];\n        int shifted = s.codeUnitAt(i) + 4;\n        if (shifted > 'z'.codeUnitAt(0)) {\n            shifted -= 26;\n        }\n        result.writeCharCode(shifted);\n    }\n    return result.toString();\n}\n```",
            "```dart\nint? nextSmallest(List<int> lst) {\n    Set<int> set = lst.toSet();\n    List<int> sl = set.toList()..sort();\n    if (sl.length < 2) {\n        return null;\n    }\n    return sl[1];\n}\n```",
            "```dart\nint isBored(String s) {\n    List<String> sentences = s.split(RegExp(r'[.!?]\\s*'));\n    int count = 0;\n    for (String sentence in sentences) {\n        if (sentence.length >= 2 && sentence.substring(0, 2) == \"I \") {\n            count++;\n        }\n    }\n    return count;\n}\n```",
            "```dart\nbool anyInt(Object x, Object y, Object z) {\n    if (x is int && y is int && z is int) {\n        int intX = x as int;\n        int intY = y as int;\n        int intZ = z as int;\n        if ((intX + intY == intZ) || (intX + intZ == intY) || (intY + intZ == intX)) {\n            return true;\n        }\n    }\n    return false;\n}\n```",
            "```dart\nString encode(String message) {\n    String vowels = \"aeiouAEIOU\";\n    StringBuffer result = StringBuffer();\n    for (int i = 0; i < message.length; i++) {\n        String ch = message[i];\n        if (RegExp(r'[a-zA-Z]').hasMatch(ch)) {\n            String ch1 = ch == ch.toLowerCase() ? ch.toUpperCase() : ch.toLowerCase();\n            if (vowels.indexOf(ch1) != -1) {\n                ch1 = String.fromCharCode(ch1.codeUnitAt(0) + 2);\n            }\n            result.write(ch1);\n        } else {\n            result.write(ch);\n        }\n    }\n    return result.toString();\n}\n```",
            "```dart\nint skjkasdkd(List<int> lst) {\n    List<int> primes = [];\n    for (int n in lst) {\n        if (isPrime(n)) {\n            primes.add(n);\n        }\n    }\n    if (primes.isEmpty) {\n        return 0;\n    }\n    String largest = primes.reduce((a, b) => a > b ? a : b).toString();\n    int sum = 0;\n    for (String digit in largest.split('')) {\n        sum += int.parse(digit);\n    }\n    return sum;\n}\n\nbool isPrime(int n) {\n    if (n < 2) {\n        return false;\n    }\n    for (int i = 2; i <= sqrt(n).toInt(); i++) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```",
            "```dart\nbool checkDictCase(Map<String, String> d) {\n  if (d.isEmpty) {\n    return false;\n  }\n  return d.keys.every((c) => c.isLowerCase) || d.keys.every((c) => c.isUpperCase);\n}\n```",
            "```dart\nList<int> countUpTo(int n) {\n    List<int> primes = [];\n    for (int num = 2; num < n; num++) {\n        bool isPrime = true;\n        for (int p in primes) {\n            if (num % p == 0) {\n                isPrime = false;\n                break;\n            }\n        }\n        if (isPrime) {\n            primes.add(num);\n        }\n    }\n    return primes;\n}\n```",
            "```dart\nint multiply(int a, int b) {\n    return (a.abs() % 10) * (b.abs() % 10);\n}\n```",
            "```dart\nint countUpper(String s) {\n    String vowels = \"AEIOU\";\n    int count = 0;\n    for (int i = 0; i < s.length; i++) {\n        char c = s[i];\n        if (i % 2 == 0 && vowels.indexOf(c) != -1) {\n            count++;\n        }\n    }\n    return count;\n}\n```",
            "```dart\nint closestInteger(String value) {\n    double num = double.parse(value);\n    if (num >= 0) {\n        return (num + 0.5).toInt();\n    } else {\n        return (num - 0.5).toInt();\n    }\n}\n```",
            "```dart\nList<int> makeAPile(int n) {\n    List<int> pile = [];\n    for (int i = 0; i < n; i++) {\n        pile.add(n + 2 * i);\n    }\n    return pile;\n}\n```",
            "```\nList<String> wordsString(String s) {\n    return s.split(RegExp(r\"[, ]\")).where((w) => w.isNotEmpty).toList();\n}\n```",
            "```dart\nint chooseNum(int x, int y) {\n  if (x > y) {\n    return -1;\n  }\n  if (y % 2 == 0) {\n    return y;\n  }\n  return (x != y) ? y - 1 : -1;\n}\n```",
            "```dart\nString? roundedAvg(int n, int m) {\n    if (n > m) {\n        return null;\n    }\n    int rAvg = ((m + n) / 2.0 + 0.5).toInt();\n    return rAvg.toRadixString(2);\n}\n```",
            "```dart\nList<int> uniqueDigits(List<int> x) {\n  return x.where((num) => allDigitsOdd(num.toString())).map(int.parse).toList()..sort();\n}\n\nbool allDigitsOdd(String s) {\n  for (var digit in s.codeUnits) {\n    if ((digit - '0'.codeUnitAt(0)) % 2 == 0) {\n      return false;\n    }\n  }\n  return true;\n}\n```",
            "```dart\nList<String> byLength(List<int> arr) {\n  final digitNames = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"];\n  final sortedArr = arr.where((x) => x >= 1 && x <= 9).toList()..sort((a, b) => b.compareTo(a));\n  return sortedArr.map((x) => digitNames[x - 1]).toList();\n}\n```",
            "```dart\nList<int> f(int n) {\n  List<int> nums = List.generate(n, (index) => index + 1);\n  return nums.map((i) {\n    int index = nums.indexOf(i);\n    if (index % 2 != 0) {\n      return nums.sublist(0, index + 1).reduce((x, y) => x + y);\n    } else {\n      return nums.sublist(0, index + 1).fold(1, (x, y) => x * y);\n    }\n  }).toList();\n}\n```",
            "```dart\nbool isPalindrome(String txt) {\n    return txt == txt.split('').reversed.join('');\n}\n\nList<int> evenOddPalindrome(int n) {\n    List<int> cnt = [0, 0];\n    for (int i = 1; i <= n; i++) {\n        if (isPalindrome(i.toString())) {\n            cnt[i % 2] += 1;\n        }\n    }\n    return cnt;\n}\n```",
            "```dart\nint digitsSum(int n) {\n  String nStr = n.toString();\n  if (n >= 0) {\n    return nStr.split('').map((d) => int.parse(d)).reduce((a, b) => a + b);\n  } else {\n    return int.parse(nStr.substring(0, 2)) * 2 + digitsSum(n.abs());\n  }\n}\n\nint countNums(List<int> arr) {\n  return arr.where((n) => digitsSum(n) > 0).length;\n}\n```",
            "```dart\nbool moveOneBall(List<int> arr) {\n    if (arr.isEmpty) {\n        return true;\n    }\n    List<int> sortedArr = List.from(arr)..sort();\n    for (int i = 0; i < arr.length; i++) {\n        if (arr.sublist(i).map((e) => e).toList() == sortedArr.sublist(0, arr.length - i) &&\n            arr.sublist(0, i).map((e) => e).toList() == sortedArr.sublist(arr.length - i)) {\n            return true;\n        }\n    }\n    return false;\n}\n```",
            "```dart\nString canExchange(List<int> lst1, List<int> lst2) {\n    int odd_cnt = 0;\n    for (int num in lst1) {\n        if (num % 2 != 0) {\n            odd_cnt++;\n        }\n    }\n\n    int even_cnt = 0;\n    for (int num in lst2) {\n        if (num % 2 == 0) {\n            even_cnt++;\n        }\n    }\n\n    return even_cnt >= odd_cnt ? \"YES\" : \"NO\";\n}\n```",
            "```dart\nMap<String, int> histogram(String test) {\n    Map<String, int> freq = {};\n    List<String> words = test.split(\" \").where((w) => w.isNotEmpty).toList();\n    for (String w in words) {\n        freq[w] = (freq[w] ?? 0) + 1;\n    }\n    Map<String, int> result = {};\n    if (freq.length > 0) {\n        int maxFreq = freq.values.reduce((a, b) => a > b ? a : b);\n        for (MapEntry<String, int> entry in freq.entries) {\n            if (entry.value == maxFreq) {\n                result[entry.key] = entry.value;\n            }\n        }\n    }\n    return result;\n}\n```",
            "```dart\nList<String> reverseDelete(String s, String c) {\n    StringBuffer s1 = StringBuffer();\n    for (var ch in s.codeUnits) {\n        if (!c.contains(String.fromCharCode(ch))) {\n            s1.write(String.fromCharCode(ch));\n        }\n    }\n    String resultString = s1.toString();\n    String palindromeCheck = String.fromCharCodes(resultString.runes.toList().reversed);\n    List<String> resultList = [];\n    resultList.add(resultString);\n    resultList.add(palindromeCheck == resultString ? \"yes\" : \"no\");\n    return resultList;\n}\n```",
            "```dart\nList<String> oddCount(List<String> lst) {\n    List<String> result = [];\n    for (String num in lst) {\n        int n = 0;\n        for (int i = 0; i < num.length; i++) {\n            if ((num.codeUnitAt(i)) % 2 == 1) {\n                n++;\n            }\n        }\n        String rs = \"the number of odd elements in the string i of the input.\";\n        result.add(rs.replaceAll('i', n.toString()));\n    }\n    return result;\n}\n```",
            "```dart\nint minSubArraySum(List<int> nums) {\n    int min_sum = 0;\n    int cur_sum = 0;\n    for (var n in nums) {\n        cur_sum = Math.min(cur_sum + n, 0);\n        min_sum = Math.min(cur_sum, min_sum);\n    }\n    if (min_sum == 0) {\n        min_sum = List<int>.from(nums).reduce(Math.min);\n    }\n    return min_sum;\n}\n```",
            "```dart\nint maxFill(List<List<int>> grid, int capacity) {\n    int total = 0;\n    for (List<int> arr in grid) {\n        int sum = 0;\n        for (int num in arr) {\n            sum += num;\n        }\n        total += (sum / capacity).ceil();\n    }\n    return total;\n}\n```",
            "```dart\nint countOnes(int num) {\n  return num.toRadixString(2).replaceAll('0', '').length;\n}\n\nList<int> sortArray(List<int> arr) {\n  return arr..sort((a, b) => countOnes(a) == countOnes(b) ? a - b : countOnes(a) - countOnes(b));\n}\n```",
            "```dart\nList<String> selectWords(String s, int n) {\n  String consonants = \"bcdfghjklmnpqrstvwxyz\";\n  List<String> words = s.split(\" \").where((w) => w.isNotEmpty).toList();\n  return words.where((w) => w.toLowerCase().split('').where((c) => consonants.contains(c)).length == n).toList();\n}\n```",
            "```dart\nString getClosestVowel(String word) {\n    String vowels = \"aeiouAEIOU\";\n    for (int i = word.length - 2; i > 0; i--) {\n        if (vowels.indexOf(word[i]) != -1 && vowels.indexOf(word[i - 1]) == -1 && vowels.indexOf(word[i + 1]) == -1) {\n            return String.fromCharCode(word.codeUnitAt(i));\n        }\n    }\n    return \"\";\n}\n```",
            "```dart\nString matchParens(List<String> lst) {\n    String s1 = lst[0] + lst[1];\n    String s2 = lst[1] + lst[0];\n    return (check(s1) || check(s2)) ? \"Yes\" : \"No\";\n}\n\nbool check(String s) {\n    int depth = 0;\n    for (var ch in s.codeUnits) {\n        if (ch == '(') {\n            depth += 1;\n        } else {\n            depth -= 1;\n        }\n        if (depth < 0) {\n            return false;\n        }\n    }\n    return depth == 0;\n}\n```",
            "```dart\nList<int> maximum(List<int> arr, int k) {\n    if (k == 0) {\n        return [];\n    }\n    var sortedArr = List.from(arr)..sort();\n    return sortedArr.sublist(sortedArr.length - k);\n}\n```",
            "```dart\nint solution(List<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.length; i++) {\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```",
            "```dart\nint addElements(List<int> arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < Math.min(k, arr.length); i++) {\n        if (arr[i].toString().length <= 2) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n```",
            "```dart\nList<int> getOddCollatz(int n) {\n  List<int> collatz = [1];\n  while (n != 1) {\n    if (n % 2 != 0) {\n      collatz.add(n);\n      n = 3 * n + 1;\n    } else {\n      n = n ~/ 2;\n    }\n  }\n  return collatz..sort();\n}\n```",
            "```dart\nbool validDate(String date) {\n    if (date.length != 10 || date[2] != '-' || date[5] != '-') {\n        return false;\n    }\n    int m = int.parse(date.substring(0, 2));\n    int d = int.parse(date.substring(3, 5));\n    if ((m == 1 || m == 3 || m == 5 || m == 7 || m == 8 || m == 10 || m == 12) && d >= 1 && d <= 31) {\n        return true;\n    }\n    if ((m == 4 || m == 6 || m == 9 || m == 11) && d >= 1 && d <= 30) {\n        return true;\n    }\n    if (m == 2 && d >= 1 && d <= 29) {\n        return true;\n    }\n    return false;\n}\n```",
            "```dart\nList<String> splitWords(String txt) {\n  if (txt.contains(\" \")) {\n    return txt.split(\" \");\n  } else if (txt.contains(\",\")) {\n    return txt.split(\",\");\n  } else {\n    int count = txt.where((c) => c.isLowerCase && c.codeUnitAt(0) % 2 == 0).length;\n    return [count.toString()];\n  }\n}\n```",
            "```dart\nbool isSorted(List<int> lst) {\n  if (lst.length < 2) return true;\n  for (int i = 1; i < lst.length; i++) {\n    if (lst[i - 1] > lst[i]) return false;\n  }\n  Map<int, int> freq = {};\n  for (int num in lst) {\n    freq[num] = (freq[num] ?? 0) + 1;\n  }\n  int maxFreq = freq.values.reduce((a, b) => a > b ? a : b);\n  return maxFreq <= 2;\n}\n```",
            "```dart\nString intersection(List<int> interval1, List<int> interval2) {\n    int l = Math.max(interval1[0], interval2[0]);\n    int r = Math.min(interval1[1], interval2[1]);\n    int length = r - l;\n    return isPrime(length) && length > 0 ? \"YES\" : \"NO\";\n}\n\nbool isPrime(int n) {\n    if (n < 2) {\n        return false;\n    }\n    for (int i = 2; i <= Math.sqrt(n); i++) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```",
            "```dart\nint? prodSigns(List<int> arr) {\n    if (arr.isEmpty) {\n        return null;\n    }\n    if (arr.contains(0)) {\n        return 0;\n    }\n    int sign = arr.where((n) => n < 0).length % 2 == 1 ? -1 : 1;\n    return sign * arr.map((n) => n.abs()).reduce((a, b) => a + b);\n}\n```",
            "```dart\nList<int> minPath(List<List<int>> grid, int k) {\n    int n = grid.length;\n    int minValue = n * n + 1;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (grid[i][j] == 1) {\n                List<int> temp = [];\n                if (i != 0) {\n                    temp.add(grid[i - 1][j]);\n                }\n                if (j != 0) {\n                    temp.add(grid[i][j - 1]);\n                }\n                if (i != n - 1) {\n                    temp.add(grid[i + 1][j]);\n                }\n                if (j != n - 1) {\n                    temp.add(grid[i][j + 1]);\n                }\n                minValue = temp.reduce((a, b) => a < b ? a : b);\n            }\n        }\n    }\n    List<int> result = [];\n    for (int i = 0; i < k; i++) {\n        result.add(i % 2 == 0 ? 1 : minValue);\n    }\n    return result;\n}\n```",
            "```dart\nList<int> tri(int n) {\n    if (n == 0) {\n        return [1];\n    }\n    List<int> seq = [1, 3];\n    for (int i = 2; i <= n; i++) {\n        if (i % 2 == 0) {\n            seq.add(i ~/ 2 + 1);\n        } else {\n            int nextValue = seq[i - 1] + seq[i - 2] + (i + 3) ~/ 2;\n            seq.add(nextValue);\n        }\n    }\n    return seq;\n}\n```",
            "```dart\nint digits(int n) {\n    String numStr = n.toString();\n    int product = 1;\n    bool hasOddDigit = false;\n    \n    for (var c in numStr.codeUnits) {\n        int digit = int.parse(String.fromCharCode(c));\n        if (digit % 2 == 1) {\n            product *= digit;\n            hasOddDigit = true;\n        }\n    }\n    \n    return hasOddDigit ? product : 0;\n}\n```",
            "```dart\nbool isNested(String s) {\n    List<int> openIdx = [];\n    List<int> closeIdx = [];\n    for (int i = 0; i < s.length; i++) {\n        char ch = s[i];\n        if (ch == '[') {\n            openIdx.add(i);\n        } else if (ch == ']') {\n            closeIdx.add(i);\n        }\n    }\n    closeIdx.reverse();\n    int cnt = 0;\n    int i = 0;\n    int l = closeIdx.length;\n    for (int idx in openIdx) {\n        if (i < l && idx < closeIdx[i]) {\n            cnt++;\n            i++;\n        }\n    }\n    return cnt >= 2;\n}\n```",
            "```dart\nimport 'dart:math';\n\nint sumSquares(List<double> lst) {\n    return lst.map((n) => pow(ceil(n), 2).toInt()).reduce((a, b) => a + b);\n}\n```",
            "```dart\nbool checkIfLastCharIsALetter(String txt) {\n    if (txt == null || txt.isEmpty) {\n        return false;\n    }\n    int lastSpaceIndex = txt.lastIndexOf(' ');\n    String lastPart = txt.substring(lastSpaceIndex + 1);\n    return lastPart.length == 1 && RegExp(r'[a-zA-Z]').hasMatch(lastPart);\n}\n```",
            "```dart\nint canArrange(List<int> arr) {\n    if (arr.length <= 1) {\n        return -1;\n    }\n    int idx = -1;\n    for (int i = 1; i < arr.length; i++) {\n        if (arr[i] < arr[i - 1]) {\n            idx = i;\n        }\n    }\n    return idx;\n}\n```",
            "```dart\nList<int?> largestSmallestIntegers(List<int> lst) {\n    List<int> neg = [];\n    List<int> pos = [];\n\n    for (int i in lst) {\n        if (i < 0) {\n            neg.add(i);\n        } else if (i > 0) {\n            pos.add(i);\n        }\n    }\n\n    int? maxNeg = neg.isEmpty ? null : neg.reduce((a, b) => a > b ? a : b);\n    int? minPos = pos.isEmpty ? null : pos.reduce((a, b) => a < b ? a : b);\n\n    return [maxNeg, minPos];\n}\n```",
            "```dart\ndouble? compareOne(Object a, Object b) {\n  double a1 = anyToReal(a);\n  double b1 = anyToReal(b);\n  if (a1 == b1) {\n    return null;\n  } else if (a1 > b1) {\n    return a1;\n  } else {\n    return b1;\n  }\n}\n\ndouble anyToReal(Object o) {\n  if (o is String) {\n    return double.parse(o.replaceAll(',', '.'));\n  } else if (o is int) {\n    return o.toDouble();\n  } else if (o is double) {\n    return o;\n  } else {\n    throw Exception(\"Type Error\");\n  }\n}\n```",
            "```dart\nbool isEqualToSumEven(int n) {\n    return n % 2 == 0 && n >= 8;\n}\n```",
            "```dart\nint specialFactorial(int n) {\n    int fact = 1;\n    int result = 1;\n    for (int i = 1; i <= n; i++) {\n        fact *= i;\n        result *= fact;\n    }\n    return result;\n}\n```",
            "```dart\nString fixSpaces(String txt) {\n    return txt.replaceAll(RegExp(r'\\s{3,}'), '-').replaceAll(' ', '_');\n}\n```",
            "```dart\nString fileNameCheck(String fileName) {\n  List<String> suf = [\"txt\", \"exe\", \"dll\"];\n  List<String> lst = fileName.split(\".\");\n\n  if (lst.length != 2 || !suf.any(lst[1].equals)) || lst[0].isEmpty || !RegExp(r'^[A-Za-z]').hasMatch(lst[0]) || lst[0].split('').where((c) => RegExp(r'\\d').hasMatch(c)).length > 3) {\n    return \"No\";\n  }\n\n  return \"Yes\";\n}\n```",
            "```dart\nint sumSquares(List<int> lst) {\n    int result = 0;\n    for (int i = 0; i < lst.length; i++) {\n        if (i % 3 == 0) {\n            result += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            result += lst[i] * lst[i] * lst[i];\n        } else {\n            result += lst[i];\n        }\n    }\n    return result;\n}\n```",
            "```dart\nString wordsInSentence(String sentence) {\n    List<String> words = sentence.split(\" \");\n    StringBuffer result = StringBuffer();\n    for (String w in words) {\n        if (isPrime(w.length)) {\n            if (result.length > 0) {\n                result.write(\" \");\n            }\n            result.write(w);\n        }\n    }\n    return result.toString();\n}\n\nbool isPrime(int n) {\n    if (n < 2) {\n        return false;\n    }\n    for (int i = 2; i <= Math.sqrt(n); i++) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```",
            "```dart\nbool simplify(String x, String n) {\n    List<String> xs = x.split('/');\n    List<String> ns = n.split('/');\n    int num = int.parse(xs[0]) * int.parse(ns[0]);\n    int den = int.parse(xs[1]) * int.parse(ns[1]);\n    return num % den == 0;\n}\n```",
            "```dart\nint digitsSum(int n) {\n  String nStr = n.toString();\n  if (n >= 0) {\n    return nStr.split('').map((d) => int.parse(d)).reduce((acc, i) => acc + i);\n  } else {\n    return int.parse(nStr.substring(0, 2)) * 2 + digitsSum(n.abs());\n  }\n}\n\nList<int> orderByPoints(List<int> nums) {\n  return nums.map((num) => [num, digitsSum(num)]).toList()\n      ..sort((a, b) => a[1].compareTo(b[1]))\n      .map((pair) => pair[0])\n      .toList();\n}\n```",
            "```dart\nint specialFilter(List<int> nums) {\n    String odds = \"13579\";\n    int count = 0;\n    for (int n in nums) {\n        if (n > 10 && n % 2 == 1 && odds.indexOf(n.toString()[0]) != -1) {\n            count++;\n        }\n    }\n    return count;\n}\n```",
            "```dart\nint getMaxTriples(int n) {\n    List<int> c = [0, 0, 0];\n    for (int i = 1; i <= n; i++) {\n        int a = i * i - i + 1;\n        c[a % 3]++;\n    }\n    return c[0] * c[1] * c[2] + (c[0] * (c[0] - 1) * (c[0] - 2) + c[1] * (c[1] - 1) * (c[1] - 2) + c[2] * (c[2] - 1) * (c[2] - 2)) ~/ 6;\n}\n```",
            "```dart\nList<String> bf(String planet1, String planet2) {\n    List<String> names = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"];\n    if (!names.contains(planet1) || !names.contains(planet2)) {\n        return [];\n    }\n    int l = names.indexOf(planet1);\n    int r = names.indexOf(planet2);\n    if (l > r) {\n        int temp = l;\n        l = r;\n        r = temp;\n    }\n    if (l == r) {\n        return [];\n    }\n    return names.sublist(l + 1, r);\n}\n```",
            "```dart\nList<String> sortedListSum(List<String> lst) {\n    List<String> result = [];\n    for (String s in lst) {\n        if (s.length % 2 == 0) {\n            result.add(s);\n        }\n    }\n    result.sort((x, y) => x.length != y.length ? x.length.compareTo(y.length) : x.compareTo(y));\n    return result;\n}\n```",
            "```dart\nint xOrY(int n, int x, int y) {\n    if (n < 2) {\n        return y;\n    }\n    for (int i = 2; i <= Math.sqrt(n); i++) {\n        if (n % i == 0) {\n            return y;\n        }\n    }\n    return x;\n}\n```",
            "```dart\nint doubleTheDifference(List<double> lst) {\n  return lst.where((n) => n >= 0 && n % 2 == 1)\n            .map((n) => n * n)\n            .reduce((a, b) => a + b);\n}\n```",
            "```dart\nList<int> compare(List<int> game, List<int> guess) {\n  return List<int>.generate(game.length, (i) => (game[i] - guess[i]).abs());\n}\n```",
            "```dart\nString strongestExtension(String className, List<String> extensions) {\n    int max_s = -2147483648;\n    String max_ext = \"\";\n    for (String ext in extensions) {\n        int upper = 0, lower = 0;\n        for (int i = 0; i < ext.length; i++) {\n            var c = ext[i];\n            if (c >= 'A' && c <= 'Z') {\n                upper++;\n            } else if (c >= 'a' && c <= 'z') {\n                lower++;\n            }\n        }\n        int s = upper - lower;\n        if (s > max_s) {\n            max_s = s;\n            max_ext = ext;\n        }\n    }\n    return \"$className.$max_ext\";\n}\n```",
            "```dart\nbool cycpatternCheck(String a, String b) {\n    if (a.length < b.length) {\n        return false;\n    }\n    for (int i = 0; i < b.length; i++) {\n        String rotatedB = b.substring(i) + b.substring(0, i);\n        if (a.contains(rotatedB)) {\n            return true;\n        }\n    }\n    return false;\n}\n```",
            "```dart\nList<int> evenOddCount(int num) {\n  String ds = num.abs().toString();\n  int even = ds.split('').where((d) => d.codeUnitAt(0) % 2 == 0).length;\n  return [even, ds.length - even];\n}\n```",
            "```dart\nString intToMiniRoman(int num) {\n    List<int> values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    List<String> numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    StringBuffer res = StringBuffer();\n    for (int i = 0; i < values.length; i++) {\n        while (num >= values[i]) {\n            res.write(numerals[i]);\n            num -= values[i];\n        }\n    }\n    return res.toString();\n}\n```",
            "```dart\nbool rightAngleTriangle(int a, int b, int c) {\n    List<int> s = [a, b, c];\n    s.sort();\n    return  s[0] * s[0] + s[1] * s[1] == s[2] * s[2];\n}\n```",
            "```dart\nString findMax(List<String> words) {\n    int maxCnt = 0;\n    String maxW = \"\";\n    for (String w in words) {\n        Set<Character> uniqueChars = new Set<Character>();\n        for (int i = 0; i < w.length; i++) {\n            uniqueChars.add(w[i]);\n        }\n        int cnt = uniqueChars.length;\n        if (cnt > maxCnt) {\n            maxCnt = cnt;\n            maxW = w;\n        } else if (cnt == maxCnt) {\n            maxW = min(maxW, w);\n        }\n    }\n    return maxW;\n}\n\nString min(String a, String b) {\n    return a.compareTo(b) < 0 ? a : b;\n}\n```",
            "```dart\nList<int> eat(int num, int need, int remaining) {\n    if (need <= remaining) {\n        return [num + need, remaining - need];\n    } else {\n        return [num + remaining, 0];\n    }\n}\n```",
            "```dart\nint doAlgebra(List<String> operators, List<int> operands) {\n    List<String> ops = List.from(operators);\n    List<int> nums = List.from(operands);\n    int i = ops.length - 1;\n    while (i >= 0) {\n        if (ops[i] == \"**\") {\n            nums[i] = pow(nums[i], nums[i + 1]).toInt();\n            nums.removeAt(i + 1);\n            ops.removeAt(i);\n        }\n        i--;\n    }\n    i = 0;\n    while (i < ops.length) {\n        if (ops[i] == \"*\") {\n            nums[i] = nums[i] * nums[i + 1];\n            nums.removeAt(i + 1);\n            ops.removeAt(i);\n            i--;\n        } else if (ops[i] == \"//\") {\n            nums[i] = nums[i] ~/ nums[i + 1];\n            nums.removeAt(i + 1);\n            ops.removeAt(i);\n            i--;\n        }\n        i++;\n    }\n    i = 0;\n    while (i < ops.length) {\n        if (ops[i] == \"+\") {\n            nums[i] = nums[i] + nums[i + 1];\n            nums.removeAt(i + 1);\n            ops.removeAt(i);\n            i--;\n        } else if (ops[i] == \"-\") {\n            nums[i] = nums[i] - nums[i + 1];\n            nums.removeAt(i + 1);\n            ops.removeAt(i);\n            i--;\n        }\n        i++;\n    }\n    return nums[0];\n}\n```",
            "```dart\nString solve(String s) {\n  if (!s.contains(RegExp(r'[a-zA-Z]'))) {\n    return s.split('').reversed.join('');\n  }\n  var result = StringBuffer();\n  for (var ch in s.codeUnits) {\n    var char = String.fromCharCode(ch);\n    if (!char.contains(RegExp(r'[a-zA-Z]'))) {\n      result.write(char);\n    } else if (char == char.toUpperCase()) {\n      result.write(char.toLowerCase());\n    } else if (char == char.toLowerCase()) {\n      result.write(char.toUpperCase());\n    }\n  }\n  return result.toString();\n}\n```",
            "```dart\nString? stringToMd5(String txt) {\n    if (txt.isEmpty) {\n        return null;\n    }\n    var md5 = md5.convert(txt.codeUnits);\n    return md5.toString();\n}\n```",
            "```dart\nList<int> generateIntegers(int a, int b) {\n    int lower = Math.max(2, Math.min(a, b));\n    int upper = Math.min(8, Math.max(a, b));\n    List<int> result = [];\n    for (int i = lower; i <= upper; i++) {\n        if (i % 2 == 0) {\n            result.add(i);\n        }\n    }\n    return result;\n}\n```"
        ],
        "javascript": [
            "```javascript\n/**\n * @param {Array<number>} numbers\n * @param {number} threshold\n * @returns {boolean}\n */\nexport const hasCloseElements = (numbers, threshold) => {\n    for (let i = 0; i < numbers.length; i++) {\n        for (let j = i + 1; j < numbers.length; j++) {\n            if (Math.abs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```",
            "```javascript\n/**\n * @param {string} parenString\n * @returns {Array<string>}\n */\nexport const separateParenGroups = (parenString) => {\n    let groups = [];\n    let stk = [];\n    let currentGroup = \"\";\n    let parens = parenString.replace(\" \", \"\");\n    for (let ch of parens) {\n        if (ch === \"(\") {\n            stk.push(ch);\n            currentGroup += ch;\n        } else if (ch === \")\") {\n            stk.pop();\n            currentGroup += ch;\n            if (stk.length === 0) {\n                groups.push(currentGroup);\n                currentGroup = \"\";\n            }\n        }\n    }\n    return groups;\n}\n```",
            "```javascript\n/**\n * @param {number} num\n * @returns {number}\n */\nexport const truncateNumber = (num) => {\n    return num - Math.floor(num);\n}\n```",
            "```javascript\n/**\n * @param {Array<number>} operations\n * @returns {boolean}\n */\nexport const belowZero = (operations) => {\n    let balance = 0;\n    for (let op of operations) {\n        balance += op;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n```",
            "```javascript\n/**\n * @param {Array<number>} numbers\n * @returns {number}\n */\nexport const meanAbsoluteDeviation = (numbers) => {\n    const sum = numbers.reduce((acc, num) => acc + num, 0);\n    const mean = sum / numbers.length;\n    \n    const deviationSum = numbers.reduce((acc, num) => acc + Math.abs(num - mean), 0);\n    \n    return deviationSum / numbers.length;\n}\n```",
            "```javascript\n/**\n * @param {Array<number>} numbers\n * @param {number} delimiter\n * @returns {Array<number>}\n */\nexport const intersperse = (numbers, delimiter) => {\n    let result = [];\n    for (let i = 0; i < numbers.length; i++) {\n        if (i !== 0) {\n            result.push(delimiter);\n        }\n        result.push(numbers[i]);\n    }\n    return result;\n}\n```",
            "```javascript\n/**\n * @param {string} parenString\n * @returns {Array<number>}\n */\nexport const parseNestedParens = (parenString) => {\n    const result = [];\n    const parenGroups = parenString.split(\" \");\n    for (const group of parenGroups) {\n        let maxDepth = 0;\n        let depth = 0;\n        for (const ch of group) {\n            if (ch === '(') {\n                depth += 1;\n                maxDepth = Math.max(maxDepth, depth);\n            } else if (ch === ')') {\n                depth -= 1;\n            }\n        }\n        result.push(maxDepth);\n    }\n    return result;\n}\n```",
            "```javascript\n/**\n * @param {Array<string>} strs\n * @param {string} substring\n * @returns {Array<string>}\n */\nexport const filterBySubstring = (strs, substring) => {\n    let result = [];\n    for (let s of strs) {\n        if (s.includes(substring)) {\n            result.push(s);\n        }\n    }\n    return result;\n}\n```",
            "```javascript\n/**\n * @param {Array<number>} numbers\n * @returns {Array<number>}\n */\nexport const sumProduct = (numbers) => {\n    const n_sum = numbers.reduce((acc, num) => acc + num, 0);\n    const n_product = numbers.reduce((acc, num) => acc * num, 1);\n    return [n_sum, n_product];\n}\n```",
            "```javascript\n/**\n * @param {Array<number>} numbers\n * @returns {Array<number>}\n */\nexport const rollingMax = (numbers) => {\n    let maxSoFar = -Infinity;\n    const result = [];\n    for (const num of numbers) {\n        maxSoFar = Math.max(maxSoFar, num);\n        result.push(maxSoFar);\n    }\n    return result;\n}\n```",
            "```javascript\n/**\n * @param {string} s\n * @returns {string}\n */\nexport const makePalindrome = (s) => {\n    if (isPalindrome(s)) {\n        return s;\n    }\n    for (let i = 0; i < s.length; i++) {\n        if (isPalindrome(s.substring(i))) {\n            let prefix = s.substring(0, i).split('').reverse().join('');\n            return s + prefix;\n        }\n    }\n    return \"\";\n};\n\nconst isPalindrome = (s) => {\n    let left = 0;\n    let right = s.length - 1;\n    while (left < right) {\n        if (s.charAt(left) !== s.charAt(right)) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n};\n```",
            "```javascript\n/**\n * @param {string} a\n * @param {string} b\n * @returns {string}\n */\nexport const stringXor = (a, b) => {\n    let result = '';\n    for (let i = 0; i < a.length && i < b.length; i++) {\n        const x = a.charAt(i);\n        const y = b.charAt(i);\n        result += (x === y) ? '0' : '1';\n    }\n    return result;\n}\n```",
            "```javascript\n/**\n * @param {Array<string>} strs\n * @returns {?string}\n */\nexport const longest = (strs) => {\n    if (strs.length === 0) {\n        return null;\n    }\n    let longest_s = strs[0];\n    for (let s of strs) {\n        if (s.length > longest_s.length) {\n            longest_s = s;\n        }\n    }\n    return longest_s;\n}\n```",
            "```javascript\n/** \n * @param {number} a \n * @param {number} b \n * @returns {number} \n */\nexport const greatestCommonDivisor = (a, b) => {\n    if (b == 0) {\n        return a;\n    } else {\n        return greatestCommonDivisor(b, a % b);\n    }\n}\n```",
            "```javascript\n/**\n * @param {string} s\n * @returns {Array<string>}\n */\nexport const allPrefixes = (s) => {\n    const prefixes = [];\n    for (let i = 0; i < s.length; i++) {\n        prefixes.push(s.substring(0, i + 1));\n    }\n    return prefixes;\n}\n```",
            "```javascript\n/**\n * @param {number} n\n * @returns {string}\n */\nexport const stringSequence = (n) => {\n    let result = '';\n    for (let i = 0; i <= n; i++) {\n        result += i;\n        if (i < n) {\n            result += ' ';\n        }\n    }\n    return result;\n}\n```",
            "```javascript\n/**\n * @param {string} s\n * @returns {number}\n */\nexport const countDistinctCharacters = (s) => {\n    return new Set(s.toLowerCase()).size;\n}\n```",
            "```javascript\n/**\n * @param {string} musicString\n * @returns {Array<number>}\n */\nexport const parseMusic = (musicString) => {\n    const durations = {\"o\": 4, \"o|\": 2, \".|\": 1};\n    const notes = musicString.split(\" \");\n    return notes.map(note => durations[note]);\n}\n```",
            "```javascript\nexport const howManyTimes = (s, substring) => {\n    let times = 0;\n    for (let i = 0; i <= s.length - substring.length; i++) {\n        if (s.substring(i, i + substring.length) === substring) {\n            times++;\n        }\n    }\n    return times;\n}\n```",
            "```javascript\n/**\n * @param {string} numbers\n * @returns {string}\n */\nexport const sortNumbers = (numbers) => {\n    const numDict = {\n        \"zero\": 0,\n        \"one\": 1,\n        \"two\": 2,\n        \"three\": 3,\n        \"four\": 4,\n        \"five\": 5,\n        \"six\": 6,\n        \"seven\": 7,\n        \"eight\": 8,\n        \"nine\": 9\n    };\n\n    const numList = numbers.split(\" \")\n                           .filter(num => num in numDict)\n                           .sort((a, b) => numDict[a] - numDict[b]);\n\n    return numList.join(\" \");\n}\n```",
            "```javascript\n/**\n * @param {Array<number>} numbers\n * @returns {Array<number>}\n */\nexport const findClosestElements = (numbers) => {\n    const sortedNumbers = [...numbers].sort((a, b) => a - b);\n    let minDiff = Infinity;\n    let closestPair = [];\n    for (let i = 1; i < sortedNumbers.length; i++) {\n        const diff = sortedNumbers[i] - sortedNumbers[i - 1];\n        if (diff < minDiff) {\n            minDiff = diff;\n            closestPair = [sortedNumbers[i - 1], sortedNumbers[i]];\n        }\n    }\n    return closestPair;\n}\n```",
            "```javascript\n/**\n * @param {Array<number>} numbers\n * @returns {Array<number>}\n */\nexport const rescaleToUnit = (numbers) => {\n    const minNum = Math.min(...numbers);\n    const maxNum = Math.max(...numbers);\n    if (minNum === maxNum) {\n        return new Array(numbers.length).fill(0.0);\n    } else {\n        return numbers.map(num => (num - minNum) / (maxNum - minNum));\n    }\n}\n```",
            "```javascript\n/**\n * @param {Array<*>} values\n * @returns {Array<number>}\n */\nexport const filterIntegers = (values) => {\n    return values.filter(x => typeof x === 'number' && Number.isInteger(x));\n}\n```",
            "```javascript\n/**\n * @param {string} s\n * @returns {number}\n */\nexport const strLength = (s) => {\n    return s.length;\n}\n```",
            "```javascript\n/**\n * @param {number} n\n * @returns {number}\n */\nexport const largestDivisor = (n) => {\n    for (let i = 2; i < n; i++) {\n        if (n % i === 0) {\n            return n / i;\n        }\n    }\n    return 1;\n}\n```",
            "```javascript\n/**\n * @param {number} n\n * @returns {Array<number>}\n */\nexport const factorize = (n) => {\n    let factors = [];\n    let divisor = 2;\n    while (divisor <= n) {\n        if (n % divisor === 0) {\n            factors.push(divisor);\n            n //= divisor;\n        } else {\n            divisor += 1;\n        }\n    }\n    return factors;\n}\n```",
            "```javascript\n/**\n * @param {Array<number>} numbers\n * @returns {Array<number>}\n */\nexport const removeDuplicates = (numbers) => {\n    const counts = new Map();\n    for (const num of numbers) {\n        counts.set(num, (counts.get(num) || 0) + 1);\n    }\n    const res = [];\n    for (const num of numbers) {\n        if (counts.get(num) === 1) {\n            res.push(num);\n        }\n    }\n    return res;\n}\n```",
            "```javascript\n/** \n * @param {string} s\n * @returns {string}\n */ \nexport const flipCase = (s) => {\n    let flipped = '';\n    for (let i = 0; i < s.length; i++) {\n        let ch = s[i];\n        if (!/[a-zA-Z]/.test(ch)) {\n            flipped += ch;\n        } else if (ch === ch.toLowerCase()) {\n            flipped += ch.toUpperCase();\n        } else {\n            flipped += ch.toLowerCase();\n        }\n    }\n    return flipped;\n}\n```",
            "```javascript\n/**\n * @param {Array<string>} strs\n * @returns {string}\n */\nexport const concatenate = (strs) => {\n    let result = '';\n    for (let str of strs) {\n        result += str;\n    }\n    return result;\n}\n```",
            "```javascript\n/**\n * @param {Array<string>} strs\n * @param {string} prefixStr\n * @returns {Array<string>}\n */\nexport const filterByPrefix = (strs, prefixStr) => {\n    return strs.filter(s => s.startsWith(prefixStr));\n}\n```",
            "```javascript\n/**\n * @param {Array<number>} l\n * @returns {Array<number>}\n */\nexport const getPositive = (l) => {\n    return l.filter(num => num > 0);\n}\n```",
            "```javascript\n/**\n * @param {number} n\n * @returns {boolean}\n */\nexport const isPrime = (n) => {\n    if (n < 2) {\n        return false;\n    }\n    for (let i = 2; i <= Math.sqrt(n); i++) {\n        if (n % i === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```",
            "```javascript\n/**\n * @param {Array<number>} xs\n * @param {number} x\n * @returns {number}\n */\nexport const poly = (xs, x) => {\n    let res = 0.0;\n    for (let i = 0; i < xs.length; i++) {\n        res += xs[i] * Math.pow(x, i);\n    }\n    return res;\n}\n\n/**\n * @param {Array<number>} xs\n * @returns {number}\n */\nexport const findZero = (xs) => {\n    let x1 = 1.0, x2 = -1.0;\n    while (poly(xs, x1) * poly(xs, x2) > 0) {\n        x1 *= 2;\n        x2 *= 2;\n    }\n    while (Math.abs(x1 - x2) > 1e-10) {\n        let mid = (x1 + x2) / 2;\n        if (poly(xs, mid) === 0) {\n            return mid;\n        } else if (poly(xs, mid) * poly(xs, x1) < 0) {\n            x2 = mid;\n        } else {\n            x1 = mid;\n        }\n    }\n    return (x1 + x2) / 2;\n}\n```",
            "```javascript\n/**\n * @param {Array<number>} l\n * @returns {Array<number>}\n */\nexport const sortThird = (l) => {\n    const sortedThird = [...l].filter((_, i) => i % 3 === 0).sort((a, b) => a - b);\n    return l.map((value, index) => index % 3 === 0 ? sortedThird[index / 3] : value);\n}\n```",
            "```javascript\n/**\n * @param {Array<number>} l\n * @returns {Array<number>}\n */\nexport const listUnique = (l) => {\n    const set = new Set(l);\n    const sortedList = Array.from(set).sort((a, b) => a - b);\n    return sortedList;\n}\n```",
            "```javascript\n/**\n * @param {Array<number>} l\n * @returns {number}\n */\nexport const maxElement = (l) => {\n    if (l.length === 0) {\n        return 0;\n    }\n    return Math.max(...l);\n}\n```",
            "```javascript\n/**\n * @param {number} n\n * @returns {number}\n */\nexport const fizzBuzz = (n) => {\n    let cnt = 0;\n    for (let i = 0; i < n; i++) {\n        if (i % 11 === 0 || i % 13 === 0) {\n            const str = i.toString();\n            for (const c of str) {\n                if (c === '7') {\n                    cnt++;\n                }\n            }\n        }\n    }\n    return cnt;\n};\n```",
            "```javascript\nexport const sortEven = (l) => {\n    const sortedEven = [...l.filter((_, index) => index % 2 === 0)].sort((a, b) => a - b);\n    return l.map((value, index) => index % 2 === 0 ? sortedEven.shift() : value);\n}\n```",
            "```javascript\n/**\n * @param {string} s\n * @returns {string}\n */\nexport const encodeCyclic = (s) => {\n    let result = '';\n    for (let i = 0; i < s.length; i += 3) {\n        if (i + 3 > s.length) {\n            result += s.substring(i);\n        } else {\n            result += s.substring(i + 1, i + 3) + s.charAt(i);\n        }\n    }\n    return result;\n}\n\n/**\n * @param {string} s\n * @returns {string}\n */\nexport const decodeCyclic = (s) => {\n    return encodeCyclic(encodeCyclic(s));\n}\n```",
            "```javascript\n/**\n * @param {number} n\n * @returns {number}\n */\nexport const primeFib = (n) => {\n    const isPrime = (num) => {\n        if (num < 2) return false;\n        for (let i = 2; i <= Math.floor(Math.sqrt(num)); i++) {\n            if (num % i === 0) return false;\n        }\n        return true;\n    };\n\n    let f = [0, 1];\n    let cnt = 0;\n    while (cnt < n) {\n        f = [f[1], f[0] + f[1]];\n        if (isPrime(f[1])) {\n            cnt += 1;\n        }\n    }\n    return f[1];\n}\n```",
            "```javascript\n/**\n * @param {Array<number>} l\n * @returns {boolean}\n */\nexport const triplesSumToZero = (l) => {\n    for (let i = 0; i < l.length; i++) {\n        for (let j = i + 1; j < l.length; j++) {\n            for (let k = j + 1; k < l.length; k++) {\n                if (l[i] + l[j] + l[k] === 0) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```",
            "```javascript\n/**\n * @param {number} n\n * @returns {number}\n */\nexport const carRaceCollision = (n) => {\n    return n * n;\n}\n```",
            "```javascript\nexport const incrList = (l) => {\n    let result = [];\n    for (let i of l) {\n        result.push(i + 1);\n    }\n    return result;\n}\n```",
            "```javascript\n/**\n * @param {Array<number>} l\n * @returns {boolean}\n */\nexport const pairsSumToZero = (l) => {\n    const seen = new Set();\n    for (const num of l) {\n        if (seen.has(-num)) {\n            return true;\n        }\n        seen.add(num);\n    }\n    return false;\n}\n```",
            "```javascript\n/**\n * @param {number} x\n * @param {number} bas\n * @returns {string}\n */\nexport const changeBase = (x, bas) => {\n    if (x === 0) {\n        return \"0\";\n    }\n    let digits = '';\n    while (x > 0) {\n        digits += x % bas;\n        x = Math.floor(x / bas);\n    }\n    return digits.split('').reverse().join('');\n}\n```",
            "```javascript\n/**\n * @param {number} a\n * @param {number} h\n * @returns {number}\n */\nexport const triangleArea = (a, h) => {\n    return a * h / 2;\n}\n```",
            "```javascript\n/**\n * @param {number} n\n * @returns {number}\n */\nexport const fib4 = (n) => {\n    let fib = [0, 0, 2, 0];\n    for (let i = 4; i <= n; i++) {\n        fib[i % 4] = fib[0] + fib[1] + fib[2] + fib[3];\n    }\n    return fib[n % 4];\n}\n```",
            "```javascript\n/**\n * @param {Array<number>} l\n * @returns {number}\n */\nexport const median = (l) => {\n    let sl = l.slice().sort((a, b) => a - b);\n    if (l.length % 2 !== 0) {\n        return sl[Math.floor(l.length / 2)];\n    } else {\n        return (sl[l.length / 2] + sl[l.length / 2 - 1]) / 2;\n    }\n}\n```",
            "```javascript\n/**\n * @param {string} txt\n * @returns {boolean}\n */\nexport const isPalindrome = (txt) => {\n    const n = txt.length;\n    for (let i = 0; i < n / 2; i++) {\n        if (txt.charAt(i) !== txt.charAt(n - 1 - i)) {\n            return false;\n        }\n    }\n    return true;\n}\n```",
            "```javascript\n/**\n * @param {number} n\n * @param {number} p\n * @returns {number}\n */\nexport const modp = (n, p) => {\n    let ret = 1;\n    for (let i = 0; i < n; i++) {\n        ret = (ret * 2) % p;\n    }\n    return ret;\n}\n```",
            "```javascript\n/**\n * @param {string} s\n * @returns {string}\n */\nexport const encodeShift = (s) => {\n    let result = '';\n    for (let ch of s) {\n        result += String.fromCharCode(((ch.charCodeAt(0) - 'a'.charCodeAt(0) + 5) % 26) + 'a'.charCodeAt(0));\n    }\n    return result;\n}\n\n/**\n * @param {string} s\n * @returns {string}\n */\nexport const decodeShift = (s) => {\n    let result = '';\n    for (let ch of s) {\n        result += String.fromCharCode(((ch.charCodeAt(0) - 'a'.charCodeAt(0) + 21) % 26) + 'a'.charCodeAt(0));\n    }\n    return result;\n}\n```",
            "```javascript\n/**\n * @param {string} txt\n * @returns {string}\n */\nexport const removeVowels = (txt) => {\n    const vowels = \"aeiouAEIOU\";\n    let result = '';\n    for (let c of txt) {\n        if (!vowels.includes(c)) {\n            result += c;\n        }\n    }\n    return result;\n}\n```",
            "```javascript\n/**\n * @param {Array<number>} l\n * @param {number} t\n * @returns {boolean}\n */\nexport const belowThreshold = (l, t) => {\n    for (let x of l) {\n        if (x >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n```",
            "```javascript\n/**\n * @param {number} x\n * @param {number} y\n * @returns {number}\n */\nexport const add = (x, y) => {\n    return x + y;\n}\n```",
            "```javascript\n/**\n * @param {string} s0\n * @param {string} s1\n * @returns {boolean}\n */\nexport const sameChars = (s0, s1) => {\n    const toCharacterSet = (s) => new Set(s);\n    return toCharacterSet(s0).size === toCharacterSet(s1).size &&\n           [...toCharacterSet(s0)].every(char => toCharacterSet(s1).has(char));\n}\n```",
            "```javascript\n/**\n * @param {number} n\n * @returns {number}\n */\nexport const fib = (n) => {\n    if (n <= 1) {\n        return n;\n    } else {\n        return fib(n - 1) + fib(n - 2);\n    }\n}\n```",
            "```javascript\n/**\n * @param {string} brackets\n * @returns {boolean}\n */\nexport const correctBracketing = (brackets) => {\n    let depth = 0;\n    for (let b of brackets) {\n        if (b === '<') {\n            depth += 1;\n        } else if (b === '>') {\n            depth -= 1;\n        }\n        if (depth < 0) {\n            return false;\n        }\n    }\n    return depth === 0;\n}\n```",
            "```javascript\n/**\n * @param {Array<number>} l\n * @returns {boolean}\n */\nexport const monotonic = (l) => {\n    if (l.length <= 1) return true;\n\n    let n = l.length;\n    let nonDecreasing = true;\n    let nonIncreasing = true;\n\n    for (let i = 0; i < n - 1; i++) {\n        if (l[i] > l[i + 1]) {\n            nonDecreasing = false;\n        }\n        if (l[i] < l[i + 1]) {\n            nonIncreasing = false;\n        }\n    }\n\n    return nonDecreasing || nonIncreasing;\n}\n```",
            "```javascript\n/**\n * @param {Array<number>} l1\n * @param {Array<number>} l2\n * @returns {Array<number>}\n */\nexport const common = (l1, l2) => {\n    const set1 = new Set(l1);\n    const set2 = new Set(l2);\n    const intersection = [...set1].filter(x => set2.has(x));\n    intersection.sort((a, b) => a - b);\n    return intersection;\n}\n```",
            "```javascript\n/**\n * @param {number} n\n * @returns {number}\n */\nexport const largestPrimeFactor = (n) => {\n    let i = 2;\n    while (i * i <= n) {\n        if (n % i !== 0) {\n            i += 1;\n        } else {\n            n /= i;\n        }\n    }\n    return n;\n}\n```",
            "```javascript\nexport const sumToN = (n) => {\n    let sum = 0;\n    for (let i = 1; i <= n; i++) {\n        sum += i;\n    }\n    return sum;\n}\n```",
            "```javascript\n/**\n * @param {string} brackets\n * @returns {boolean}\n */\nexport const correctBracketing = (brackets) => {\n    let depth = 0;\n    for (let b of brackets) {\n        if (b === '(') {\n            depth += 1;\n        } else if (b === ')') {\n            depth -= 1;\n        }\n        if (depth < 0) {\n            return false;\n        }\n    }\n    return depth === 0;\n}\n```",
            "```javascript\n/**\n * @param {Array<number>} xs\n * @returns {Array<number>}\n */\nexport const derivative = (xs) => {\n    const result = [];\n    for (let i = 1; i < xs.length; i++) {\n        result.push(xs[i] * i);\n    }\n    return result;\n}\n```",
            "```javascript\n/**\n * @param {number} n\n * @returns {number}\n */\nexport const fibfib = (n) => {\n    if (n <= 1) {\n        return 0;\n    }\n    let a = 0, b = 0, c = 1;\n    while (n > 2) {\n        [a, b, c] = [b, c, a + b + c];\n        n -= 1;\n    }\n    return c;\n}\n```",
            "```javascript\n/**\n * @param {string} s\n * @returns {number}\n */\nexport const vowelsCount = (s) => {\n    let vowels = \"aeiou\";\n    let cnt = 0;\n    for (let i = 0; i < s.length; i++) {\n        if (vowels.indexOf(s.charAt(i).toLowerCase()) !== -1 || \n            (i === s.length - 1 && s.charAt(i).toLowerCase() === 'y')) {\n            cnt++;\n        }\n    }\n    return cnt;\n}\n```",
            "```javascript\n/**\n * @param {number} x\n * @param {number} shift\n * @returns {string}\n */\nexport const circularShift = (x, shift) => {\n    let x_str = x.toString();\n    if (shift > x_str.length) {\n        return x_str.split('').reverse().join('');\n    } else {\n        return x_str.slice(-shift) + x_str.slice(0, x_str.length - shift);\n    }\n}\n```",
            "```javascript\n/**\n * @param {string} s\n * @returns {number}\n */\nexport const digitSum = (s) => {\n    let sum = 0;\n    for (let i = 0; i < s.length; i++) {\n        const c = s.charAt(i);\n        if (c >= 'A' && c <= 'Z') {\n            sum += c.charCodeAt(0);\n        }\n    }\n    return sum;\n}\n```",
            "```javascript\n/**\n * @param {string} s\n * @param {number} n\n * @returns {number}\n */\nexport const fruitDistribution = (s, n) => {\n    const words = s.split(' ');\n    const apples = parseInt(words[words.indexOf(\"apples\") - 1]);\n    const oranges = parseInt(words[words.indexOf(\"oranges\") - 1]);\n    return n - apples - oranges;\n}\n```",
            "```javascript\n/**\n * @param {Array<number>} arr\n * @returns {Array<number>}\n */\nexport const pluck = (arr) => {\n    let evens = [];\n    for (let n of arr) {\n        if (n % 2 === 0) {\n            evens.push(n);\n        }\n    }\n    if (evens.length === 0) {\n        return [];\n    }\n    let minEven = Math.min(...evens);\n    return [minEven, arr.indexOf(minEven)];\n}\n```",
            "```javascript\nexport const search = (lst) => {\n    let freqs = new Map();\n    for (let n of lst) {\n        freqs.set(n, (freqs.get(n) || 0) + 1);\n    }\n    let goodVals = [];\n    for (let [key, value] of freqs.entries()) {\n        if (value >= key) {\n            goodVals.push(key);\n        }\n    }\n    return goodVals.length > 0 ? Math.max(...goodVals) : -1;\n}\n```",
            "```javascript\n/**\n * @param {Array<number>} lst\n * @returns {Array<number>}\n */\nexport const strangeSortList = (lst) => {\n    let sl = [...lst].sort((a, b) => a - b);\n    let result = [];\n    let left = 0, right = sl.length - 1;\n    while (left <= right) {\n        result.push(sl[left]);\n        left += 1;\n        if (left <= right) {\n            result.push(sl[right]);\n            right -= 1;\n        }\n    }\n    return result;\n}\n```",
            "```javascript\n/**\n * @param {number} a\n * @param {number} b\n * @param {number} c\n * @returns {number}\n */\nexport const triangleArea = (a, b, c) => {\n    if (a + b > c && a + c > b && b + c > a) {\n        const s = (a + b + c) / 2.0;\n        return Math.sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        return -1.0;\n    }\n}\n```",
            "```javascript\n/**\n * @param {Array<number>} q\n * @param {number} w\n * @returns {boolean}\n */\nexport const willItFly = (q, w) => {\n    if (q.length === 0) {\n        return false;\n    }\n    const is_palin = q.every((_, i) => q[i] === q[q.length - i - 1]);\n    const total = q.reduce((acc, val) => acc + val, 0);\n    return is_palin && total <= w;\n}\n```",
            "```javascript\n/**\n * @param {Array<number>} arr\n * @returns {number}\n */\nexport const smallestChange = (arr) => {\n    let ans = 0;\n    for (let i = 0; i < arr.length / 2; i++) {\n        if (arr[i] !== arr[arr.length - i - 1]) {\n            ans += 1;\n        }\n    }\n    return ans;\n}\n```",
            "```javascript\n/**\n * @param {Array<string>} lst1\n * @param {Array<string>} lst2\n * @returns {Array<string>}\n */\nexport const totalMatch = (lst1, lst2) => {\n    const cnt1 = lst1.reduce((acc, str) => acc + str.length, 0);\n    const cnt2 = lst2.reduce((acc, str) => acc + str.length, 0);\n    return cnt1 <= cnt2 ? lst1 : lst2;\n}\n```",
            "```javascript\nexport const isMultiplyPrime = (a) => {\n    const is_prime = (n) => {\n        if (n < 2) {\n            return false;\n        }\n        for (let i = 2; i <= Math.sqrt(n); i++) {\n            if (n % i === 0) {\n                return false;\n            }\n        }\n        return true;\n    };\n\n    let cnt = 0;\n    for (let i = 2; i <= a; i++) {\n        if (is_prime(i)) {\n            while (a % i === 0) {\n                cnt += 1;\n                a /= i;\n            }\n        }\n    }\n    return cnt === 3;\n}\n```",
            "```javascript\n/**\n * @param {number} x\n * @param {number} n\n * @returns {boolean}\n */\nexport const isSimplePower = (x, n) => {\n    if (n < 2) {\n        return x === n;\n    }\n    let tmp = 1;\n    while (tmp < x) {\n        tmp *= n;\n    }\n    return tmp === x;\n}\n```",
            "```javascript\n/**\n * @param {number} a\n * @returns {boolean}\n */\nexport const isCube = (a) => {\n    a = Math.abs(a);\n    let root = Math.round(Math.cbrt(a));\n    return root * root * root === a;\n}\n```",
            "```javascript\n/**\n * @param {string} num\n * @returns {number}\n */\nexport const hexKey = (num) => {\n    let count = 0;\n    for (let x of num) {\n        if (\"2357BD\".includes(x)) {\n            count++;\n        }\n    }\n    return count;\n}\n```",
            "```javascript\n/**\n * @param {number} dec\n * @returns {string}\n */\nexport const decimalToBinary = (dec) => {\n    let binary = dec.toString(2);\n    return \"db\" + binary + \"db\";\n}\n```",
            "```javascript\n/**\n * @param {string} s\n * @returns {boolean}\n */\nexport const isHappy = (s) => {\n    if (s.length < 3) {\n        return false;\n    }\n    for (let i = 0; i < s.length - 2; i++) {\n        if (s.charAt(i) === s.charAt(i + 1) || s.charAt(i) === s.charAt(i + 2) || s.charAt(i + 1) === s.charAt(i + 2)) {\n            return false;\n        }\n    }\n    return true;\n}\n```",
            "```javascript\n/**\n * @param {Array<number>} grades\n * @returns {Array<string>}\n */\nexport const numericalLetterGrade = (grades) => {\n    const result = [];\n    for (const g of grades) {\n        if (g === 4.0) {\n            result.push(\"A+\");\n        } else if (g > 3.7) {\n            result.push(\"A\");\n        } else if (g > 3.3) {\n            result.push(\"A-\");\n        } else if (g > 3.0) {\n            result.push(\"B+\");\n        } else if (g > 2.7) {\n            result.push(\"B\");\n        } else if (g > 2.3) {\n            result.push(\"B-\");\n        } else if (g > 2.0) {\n            result.push(\"C+\");\n        } else if (g > 1.7) {\n            result.push(\"C\");\n        } else if (g > 1.3) {\n            result.push(\"C-\");\n        } else if (g > 1.0) {\n            result.push(\"D+\");\n        } else if (g > 0.7) {\n            result.push(\"D\");\n        } else if (g > 0.0) {\n            result.push(\"D-\");\n        } else {\n            result.push(\"E\");\n        }\n    }\n    return result;\n}\n```",
            "```javascript\n/**\n * @param {string} s\n * @returns {boolean}\n */\nexport const primeLength = (s) => {\n    let length = s.length;\n    if (length < 2) {\n        return false;\n    }\n    for (let i = 2; i <= Math.sqrt(length); i++) {\n        if (length % i === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```",
            "```javascript\n/**\n * @param {number} n\n * @returns {number}\n */\nexport const startsOneEnds = (n) => {\n    if (n === 1) {\n        return 1;\n    }\n    return 2 * 9 * Math.pow(10, n - 2);\n};\n```",
            "```javascript\n/**\n * @param {number} n\n * @returns {string}\n */\nexport const solve = (n) => {\n    let digitsSum = 0;\n    while (n > 0) {\n        digitsSum += n % 10;\n        n = Math.floor(n / 10);\n    }\n    return digitsSum.toString(2);\n}\n```",
            "```javascript\n/**\n * @param {Array<number>} lst\n * @returns {number}\n */\nexport const add = (lst) => {\n    let sum = 0;\n    for (let i = 1; i < lst.length; i += 2) {\n        let x = lst[i];\n        if (x % 2 === 0) {\n            sum += x;\n        }\n    }\n    return sum;\n}\n```",
            "```javascript\n/**\n * @param {string} s\n * @returns {string}\n */\nexport const antiShuffle = (s) => {\n    let result = '';\n    let words = s.split(' ');\n\n    for (let word of words) {\n        let chars = word.split('');\n        chars.sort();\n        result += chars.join('') + ' ';\n    }\n\n    return result.trim();\n}\n```",
            "```javascript\n/**\n * @param {Array<Array<number>>} lst\n * @param {number} x\n * @returns {Array<Array<number>>}\n */\nexport const getRow = (lst, x) => {\n    let coords = [];\n    for (let i = 0; i < lst.length; i++) {\n        for (let j = 0; j < lst[i].length; j++) {\n            if (lst[i][j] === x) {\n                coords.push([i, j]);\n            }\n        }\n    }\n    coords.sort((a, b) => {\n        if (a[0] !== b[0]) {\n            return a[0] - b[0];\n        } else {\n            return b[1] - a[1];\n        }\n    });\n    return coords;\n}\n```",
            "```javascript\n/**\n * @param {Array<number>} arr\n * @returns {Array<number>}\n */\nexport const sortArray = (arr) => {\n    if (arr.length === 0) {\n        return [];\n    }\n    if ((arr[0] + arr[arr.length - 1]) % 2 === 0) {\n        return arr.sort((a, b) => b - a);\n    } else {\n        return arr.sort((a, b) => a - b);\n    }\n}\n```",
            "```javascript\n/**\n * @param {string} s\n * @returns {string}\n */\nexport const encrypt = (s) => {\n    let result = '';\n    for (let i = 0; i < s.length; i++) {\n        let ch = s.charCodeAt(i);\n        let shifted = ch + 4;\n        if (shifted > 'z'.charCodeAt(0)) {\n            shifted -= 26;\n        }\n        result += String.fromCharCode(shifted);\n    }\n    return result;\n}\n```",
            "```javascript\nexport const nextSmallest = (lst) => {\n    const set = new Set(lst);\n    const sl = Array.from(set).sort((a, b) => a - b);\n    if (sl.length < 2) {\n        return null;\n    }\n    return sl[1];\n}\n```",
            "```javascript\n/**\n * @param {string} s\n * @returns {number}\n */\nexport const isBored = (s) => {\n    const sentences = s.split(/[\\.\\!\\?]\\s*/);\n    let count = 0;\n    for (const sentence of sentences) {\n        if (sentence.length >= 2 && sentence.substring(0, 2) === \"I \") {\n            count++;\n        }\n    }\n    return count;\n}\n```",
            "```javascript\n/**\n * @param {*} x\n * @param {*} y\n * @param {*} z\n * @returns {boolean}\n */\nexport const anyInt = (x, y, z) => {\n    if (Number.isInteger(x) && Number.isInteger(y) && Number.isInteger(z)) {\n        let intX = x;\n        let intY = y;\n        let intZ = z;\n        if ((intX + intY === intZ) || (intX + intZ === intY) || (intY + intZ === intX)) {\n            return true;\n        }\n    }\n    return false;\n}\n```",
            "```javascript\n/**\n * @param {string} message\n * @returns {string}\n */\nexport const encode = (message) => {\n    const vowels = \"aeiouAEIOU\";\n    let result = '';\n    for (let ch of message) {\n        if (/[a-zA-Z]/.test(ch)) {\n            let ch1 = /[a-z]/.test(ch) ? ch.toUpperCase() : ch.toLowerCase();\n            if (vowels.indexOf(ch1) !== -1) {\n                ch1 = String.fromCharCode(ch1.charCodeAt(0) + 2);\n            }\n            result += ch1;\n        } else {\n            result += ch;\n        }\n    }\n    return result;\n}\n```",
            "```javascript\n/**\n * @param {Array<number>} lst\n * @returns {number}\n */\nexport const skjkasdkd = (lst) => {\n    let primes = [];\n    for (let n of lst) {\n        if (isPrime(n)) {\n            primes.push(n);\n        }\n    }\n    if (primes.length === 0) {\n        return 0;\n    }\n    let largest = Math.max(...primes).toString();\n    let sum = 0;\n    for (let digit of largest) {\n        sum += parseInt(digit, 10);\n    }\n    return sum;\n};\n\nconst isPrime = (n) => {\n    if (n < 2) {\n        return false;\n    }\n    for (let i = 2; i <= Math.sqrt(n); i++) {\n        if (n % i === 0) {\n            return false;\n        }\n    }\n    return true;\n};\n```",
            "```javascript\n/**\n * @param {Map<string, string>} d\n * @returns {boolean}\n */\nexport const checkDictCase = (d) => {\n    if (d.size === 0) {\n        return false;\n    }\n    let allLower = true;\n    let allUpper = true;\n    for (let key of d.keys()) {\n        if (!key.isLowerCase()) {\n            allLower = false;\n        }\n        if (!key.isUpperCase()) {\n            allUpper = false;\n        }\n    }\n    return allLower || allUpper;\n}\n```",
            "```javascript\n/**\n * @param {number} n\n * @returns {Array<number>}\n */\nexport const countUpTo = (n) => {\n    let primes = [];\n    for (let num = 2; num < n; num++) {\n        let isPrime = true;\n        for (let p of primes) {\n            if (num % p === 0) {\n                isPrime = false;\n                break;\n            }\n        }\n        if (isPrime) {\n            primes.push(num);\n        }\n    }\n    return primes;\n}\n```",
            "```javascript\n/**\n * @param {number} a\n * @param {number} b\n * @returns {number}\n */\nexport const multiply = (a, b) => {\n    return Math.abs(a) % 10 * Math.abs(b) % 10;\n}\n```",
            "```javascript\n/**\n * @param {string} s\n * @returns {number}\n */\nexport const countUpper = (s) => {\n    const vowels = \"AEIOU\";\n    let count = 0;\n    for (let i = 0; i < s.length; i++) {\n        let c = s.charAt(i);\n        if (i % 2 === 0 && vowels.indexOf(c) !== -1) {\n            count++;\n        }\n    }\n    return count;\n}\n```",
            "/** \n * @param {string} value\n * @returns {number}\n */\nexport const closestInteger = (value) => {\n    const num = parseFloat(value);\n    if (num >= 0) {\n        return Math.floor(num + 0.5);\n    } else {\n        return Math.ceil(num - 0.5);\n    }\n}",
            "```javascript\n/**\n * @param {number} n\n * @returns {Array<number>}\n */\nexport const makeAPile = (n) => {\n    let pile = [];\n    for (let i = 0; i < n; i++) {\n        pile.push(n + 2 * i);\n    }\n    return pile;\n}\n```",
            "```javascript\n/**\n * @param {string} s\n * @returns {Array<string>}\n */\nexport const wordsString = (s) => {\n    return s.split(/[, ]+/).filter(w => w.length > 0);\n}\n```",
            "```javascript\n/**\n * @param {number} x\n * @param {number} y\n * @returns {number}\n */\nexport const chooseNum = (x, y) => {\n    if (x > y) {\n        return -1;\n    }\n    if (y % 2 === 0) {\n        return y;\n    }\n    return x !== y ? y - 1 : -1;\n}\n```",
            "```javascript\nexport const roundedAvg = (n, m) => {\n    if (n > m) {\n        return null;\n    }\n    let rAvg = Math.round((m + n) / 2.0);\n    return rAvg.toString(2);\n}\n```",
            "```javascript\n/**\n * @param {Array<number>} x\n * @returns {Array<number>}\n */\nexport const uniqueDigits = (x) => {\n    const allDigitsOdd = (s) => {\n        for (let digit of s) {\n            if ((parseInt(digit) - '0') % 2 === 0) {\n                return false;\n            }\n        }\n        return true;\n    };\n\n    return x.filter(num => allDigitsOdd(String(num)))\n             .sort((a, b) => a - b);\n}\n```",
            "```javascript\n/**\n * @param {Array<number>} arr\n * @returns {Array<string>}\n */\nexport const byLength = (arr) => {\n    const digitNames = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"];\n    const sortedArr = arr.filter(x => x >= 1 && x <= 9)\n                        .sort((a, b) => b - a);\n    return sortedArr.map(x => digitNames[x - 1]);\n}\n```",
            "```javascript\n/**\n * @param {number} n\n * @returns {Array<number>}\n */\nexport const f = (n) => {\n    let nums = Array.from({ length: n }, (_, i) => i + 1);\n    return nums.map((_, i) => {\n        if ((i + 1) % 2 !== 0) {\n            return nums.slice(0, i + 1).reduce((acc, num) => acc + num, 0);\n        } else {\n            return nums.slice(0, i + 1).reduce((acc, num) => acc * num, 1);\n        }\n    });\n}\n```",
            "```javascript\n/**\n * @param {number} n\n * @returns {Array<number>}\n */\nexport const evenOddPalindrome = (n) => {\n    const cnt = [0, 0];\n    for (let i = 1; i <= n; i++) {\n        const txt = i.toString();\n        if (txt === txt.split('').reverse().join('')) {\n            cnt[i % 2] += 1;\n        }\n    }\n    return cnt;\n}\n```",
            "```javascript\n/**\n * @param {number} n\n * @returns {number}\n */\nconst digitsSum = (n) => {\n    const nStr = Math.abs(n).toString();\n    return n >= 0 ? [...nStr].reduce((sum, d) => sum + parseInt(d), 0) : parseInt(nStr[0]) * 2 + digitsSum(Math.abs(n));\n};\n\n/**\n * @param {Array<number>} arr\n * @returns {number}\n */\nexport const countNums = (arr) => {\n    return arr.filter(n => digitsSum(n) > 0).length;\n};\n```",
            "```javascript\n/**\n * @param {Array<number>} arr\n * @returns {boolean}\n */\nexport const moveOneBall = (arr) => {\n    if (arr.length === 0) {\n        return true;\n    }\n    let sortedArr = [...arr].sort((a, b) => a - b);\n    for (let i = 0; i < arr.length; i++) {\n        if (\n            arr.slice(i).toString() === sortedArr.slice(0, arr.length - i).toString() &&\n            arr.slice(0, i).toString() === sortedArr.slice(arr.length - i).toString()\n        ) {\n            return true;\n        }\n    }\n    return false;\n}\n```",
            "```javascript\n/**\n * @param {Array<number>} lst1\n * @param {Array<number>} lst2\n * @returns {string}\n */\nexport const canExchange = (lst1, lst2) => {\n    let odd_cnt = 0;\n    for (let num of lst1) {\n        if (num % 2 !== 0) {\n            odd_cnt++;\n        }\n    }\n\n    let even_cnt = 0;\n    for (let num of lst2) {\n        if (num % 2 === 0) {\n            even_cnt++;\n        }\n    }\n\n    return even_cnt >= odd_cnt ? \"YES\" : \"NO\";\n}\n```",
            "```javascript\n/**\n * @param {string} test\n * @returns {Map<string, number>}\n */\nexport const histogram = (test) => {\n    const freq = new Map();\n    const words = test.split(\" \").filter(w => w.length > 0);\n    for (const w of words) {\n        freq.set(w, (freq.get(w) || 0) + 1);\n    }\n    const result = new Map();\n    if (freq.size > 0) {\n        const maxFreq = Math.max(...freq.values());\n        for (const [k, v] of freq.entries()) {\n            if (v === maxFreq) {\n                result.set(k, v);\n            }\n        }\n    }\n    return result;\n}\n```",
            "```javascript\n/**\n * @param {string} s\n * @param {string} c\n * @returns {Array<string>}\n */\nexport const reverseDelete = (s, c) => {\n    let s1 = '';\n    for (let i = 0; i < s.length; i++) {\n        if (!c.includes(s[i])) {\n            s1 += s[i];\n        }\n    }\n    let resultString = s1;\n    let palindromeCheck = s1.split('').reverse().join('');\n    return [resultString, palindromeCheck === resultString ? 'yes' : 'no'];\n}\n```",
            "```javascript\n/**\n * @param {Array<string>} lst\n * @returns {Array<string>}\n */\nexport const oddCount = (lst) => {\n    const result = [];\n    for (const num of lst) {\n        let n = 0;\n        for (const d of num) {\n            if ((d.charCodeAt(0) % 2) === 1) {\n                n++;\n            }\n        }\n        const rs = \"the number of odd elements in the string i of the input.\";\n        result.push(rs.replace(\"i\", n.toString()));\n    }\n    return result;\n}\n```",
            "```javascript\nexport const minSubArraySum = (nums) => {\n    let min_sum = 0;\n    let cur_sum = 0;\n    for (let n of nums) {\n        cur_sum = Math.min(cur_sum + n, 0);\n        min_sum = Math.min(cur_sum, min_sum);\n    }\n    if (min_sum === 0) {\n        min_sum = Math.min(...nums);\n    }\n    return min_sum;\n}\n```",
            "```javascript\n/**\n * @param {Array<Array<number>>} grid\n * @param {number} capacity\n * @returns {number}\n */\nexport const maxFill = (grid, capacity) => {\n    let total = 0;\n    for (let arr of grid) {\n        let sum = 0;\n        for (let num of arr) {\n            sum += num;\n        }\n        total += Math.ceil(sum / capacity);\n    }\n    return total;\n}\n```",
            "```javascript\n/**\n * @param {Array<number>} arr\n * @returns {Array<number>}\n */\nexport const sortArray = (arr) => {\n    const countOnes = (num) => num.toString(2).split('0').join('').length;\n    return arr.sort((a, b) => {\n        const onesA = countOnes(a);\n        const onesB = countOnes(b);\n        if (onesA === onesB) {\n            return a - b;\n        }\n        return onesA - onesB;\n    });\n}\n```",
            "```javascript\n/**\n * @param {string} s\n * @param {number} n\n * @returns {Array<string>}\n */\nexport const selectWords = (s, n) => {\n    const consonants = \"bcdfghjklmnpqrstvwxyz\";\n    const words = s.split(\" \").filter(w => w.length > 0);\n    return words.filter(w => \n        Array.from(w.toLowerCase()).filter(c => consonants.includes(c)).length === n\n    );\n}\n```",
            "```javascript\n/**\n * @param {string} word\n * @returns {string}\n */\nexport const getClosestVowel = (word) => {\n    const vowels = \"aeiouAEIOU\";\n    for (let i = word.length - 2; i > 0; i--) {\n        if (vowels.indexOf(word.charAt(i)) !== -1 && vowels.indexOf(word.charAt(i - 1)) === -1 && vowels.indexOf(word.charAt(i + 1)) === -1) {\n            return word.charAt(i);\n        }\n    }\n    return \"\";\n}\n```",
            "```javascript\n/**\n * @param {Array<string>} lst\n * @returns {string}\n */\nexport const matchParens = (lst) => {\n    const s1 = lst[0] + lst[1];\n    const s2 = lst[1] + lst[0];\n    return (check(s1) || check(s2)) ? \"Yes\" : \"No\";\n};\n\nconst check = (s) => {\n    let depth = 0;\n    for (const ch of s) {\n        if (ch === '(') {\n            depth += 1;\n        } else {\n            depth -= 1;\n        }\n        if (depth < 0) {\n            return false;\n        }\n    }\n    return depth === 0;\n};\n```",
            "```javascript\n/**\n * @param {Array<number>} arr\n * @param {number} k\n * @returns {Array<number>}\n */\nexport const maximum = (arr, k) => {\n    if (k === 0) {\n        return [];\n    }\n    return arr.sort((a, b) => a - b).slice(-k);\n}\n```",
            "```javascript\n/**\n * @param {Array<number>} lst\n * @returns {number}\n */\nexport const solution = (lst) => {\n    let sum = 0;\n    for (let i = 0; i < lst.length; i++) {\n        if (i % 2 === 0 && lst[i] % 2 !== 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```",
            "```javascript\n/**\n * @param {Array<number>} arr\n * @param {number} k\n * @returns {number}\n */\nexport const addElements = (arr, k) => {\n    let sum = 0;\n    for (let i = 0; i < Math.min(k, arr.length); i++) {\n        if (String(arr[i]).length <= 2) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n```",
            "```javascript\nexport const getOddCollatz = (n) => {\n    let collatz = [1];\n    while (n !== 1) {\n        if (n % 2 !== 0) {\n            collatz.push(n);\n            n = 3 * n + 1;\n        } else {\n            n = Math.floor(n / 2);\n        }\n    }\n    return collatz.sort((a, b) => a - b);\n}\n```",
            "```javascript\n/**\n * @param {string} date\n * @returns {boolean}\n */\nexport const validDate = (date) => {\n    if (date.length !== 10 || date.charAt(2) !== '-' || date.charAt(5) !== '-') {\n        return false;\n    }\n    const m = parseInt(date.substring(0, 2), 10);\n    const d = parseInt(date.substring(3, 5), 10);\n    if ((m === 1 || m === 3 || m === 5 || m === 7 || m === 8 || m === 10 || m === 12) && d >= 1 && d <= 31) {\n        return true;\n    }\n    if ((m === 4 || m === 6 || m === 9 || m === 11) && d >= 1 && d <= 30) {\n        return true;\n    }\n    if (m === 2 && d >= 1 && d <= 29) {\n        return true;\n    }\n    return false;\n}\n```",
            "```javascript\n/**\n * @param {string} txt\n * @returns {Array<string>}\n */\nexport const splitWords = (txt) => {\n    if (txt.includes(\" \")) {\n        return txt.split(\" \");\n    } else if (txt.includes(\",\")) {\n        return txt.split(\",\");\n    } else {\n        const count = [...txt].filter(c => c >= 'a' && c <= 'z' && (c.charCodeAt(0) % 2 === 0)).length;\n        return [count.toString()];\n    }\n};\n```",
            "```javascript\n/**\n * @param {Array<number>} lst\n * @returns {boolean}\n */\nexport const isSorted = (lst) => {\n    if (lst.length < 2) return true;\n    for (let i = 1; i < lst.length; i++) {\n        if (lst[i - 1] > lst[i]) return false;\n    }\n    const freq = {};\n    for (const num of lst) {\n        freq[num] = (freq[num] || 0) + 1;\n    }\n    const maxFreq = Math.max(...Object.values(freq));\n    return maxFreq <= 2;\n}\n```",
            "```javascript\n/**\n * @param {Array<number>} interval1\n * @param {Array<number>} interval2\n * @returns {string}\n */\nexport const intersection = (interval1, interval2) => {\n    let l = Math.max(interval1[0], interval2[0]);\n    let r = Math.min(interval1[1], interval2[1]);\n    let length = r - l;\n    return isPrime(length) && length > 0 ? \"YES\" : \"NO\";\n};\n\nconst isPrime = (n) => {\n    if (n < 2) {\n        return false;\n    }\n    for (let i = 2; i <= Math.sqrt(n); i++) {\n        if (n % i === 0) {\n            return false;\n        }\n    }\n    return true;\n};\n```",
            "```javascript\n/**\n * @param {Array<number>} arr\n * @returns {?number}\n */\nexport const prodSigns = (arr) => {\n    if (!arr.length) {\n        return null;\n    }\n    if (arr.includes(0)) {\n        return 0;\n    }\n    const sign = arr.filter(n => n < 0).length % 2 === 1 ? -1 : 1;\n    return sign * arr.reduce((sum, n) => sum + Math.abs(n), 0);\n}\n```",
            "```javascript\nexport const minPath = (grid, k) => {\n    const n = grid.length;\n    let min_val = n * n + 1;\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < n; j++) {\n            if (grid[i][j] === 1) {\n                const temp = [];\n                if (i !== 0) {\n                    temp.push(grid[i - 1][j]);\n                }\n                if (j !== 0) {\n                    temp.push(grid[i][j - 1]);\n                }\n                if (i !== n - 1) {\n                    temp.push(grid[i + 1][j]);\n                }\n                if (j !== n - 1) {\n                    temp.push(grid[i][j + 1]);\n                }\n                min_val = Math.min(...temp);\n            }\n        }\n    }\n    const result = [];\n    for (let i = 0; i < k; i++) {\n        result.push(i % 2 === 0 ? 1 : min_val);\n    }\n    return result;\n}\n```",
            "```javascript\n/**\n * @param {number} n\n * @returns {Array<number>}\n */\nexport const tri = (n) => {\n    if (n === 0) {\n        return [1];\n    }\n    let seq = [1, 3];\n    for (let i = 2; i <= n; i++) {\n        if (i % 2 === 0) {\n            seq.push(i / 2 + 1);\n        } else {\n            let nextValue = seq[i - 1] + seq[i - 2] + (i + 3) / 2;\n            seq.push(nextValue);\n        }\n    }\n    return seq;\n}\n```",
            "```javascript\n/**\n * @param {number} n\n * @returns {number}\n */\nexport const digits = (n) => {\n    const numStr = n.toString();\n    let product = 1;\n    let hasOddDigit = false;\n    \n    for (let c of numStr) {\n        let digit = parseInt(c, 10);\n        if (digit % 2 === 1) {\n            product *= digit;\n            hasOddDigit = true;\n        }\n    }\n    \n    return hasOddDigit ? product : 0;\n}\n```",
            "```javascript\n/**\n * @param {string} s\n * @returns {boolean}\n */\nexport const isNested = (s) => {\n    const openIdx = [];\n    const closeIdx = [];\n    for (let i = 0; i < s.length; i++) {\n        const ch = s.charAt(i);\n        if (ch === '[') {\n            openIdx.push(i);\n        } else if (ch === ']') {\n            closeIdx.push(i);\n        }\n    }\n    closeIdx.reverse();\n    let cnt = 0;\n    let i = 0;\n    const l = closeIdx.length;\n    for (const idx of openIdx) {\n        if (i < l && idx < closeIdx[i]) {\n            cnt++;\n            i++;\n        }\n    }\n    return cnt >= 2;\n}\n```",
            "```javascript\n/**\n * @param {Array<number>} lst\n * @returns {number}\n */\nexport const sumSquares = (lst) => {\n    return lst.map(n => Math.ceil(n)).reduce((acc, n) => acc + n * n, 0);\n}\n```",
            "```javascript\n/**\n * @param {string} txt\n * @returns {boolean}\n */\nexport const checkIfLastCharIsALetter = (txt) => {\n    if (txt === null || txt.length === 0) {\n        return false;\n    }\n    let lastSpaceIndex = txt.lastIndexOf(' ');\n    let lastPart = txt.substring(lastSpaceIndex + 1);\n    return lastPart.length === 1 && /^[a-zA-Z]$/.test(lastPart);\n}\n```",
            "```javascript\n/**\n * @param {Array<number>} arr\n * @returns {number}\n */\nexport const canArrange = (arr) => {\n    if (arr.length <= 1) {\n        return -1;\n    }\n    let idx = -1;\n    for (let i = 1; i < arr.length; i++) {\n        if (arr[i] < arr[i - 1]) {\n            idx = i;\n        }\n    }\n    return idx;\n}\n```",
            "```javascript\n/**\n * @param {Array<number>} lst\n * @returns {Array<?number>}\n */\nexport const largestSmallestIntegers = (lst) => {\n    let neg = [];\n    let pos = [];\n    \n    for (let i of lst) {\n        if (i < 0) {\n            neg.add(i);\n        } else if (i > 0) {\n            pos.push(i);\n        }\n    }\n    \n    let maxNeg = neg.length === 0 ? null : Math.max(...neg);\n    let minPos = pos.length === 0 ? null : Math.min(...pos);\n    \n    return [maxNeg, minPos];\n}\n```",
            "```javascript\n/**\n * @param {*} a\n * @param {*} b\n * @returns {?number}\n */\nexport const compareOne = (a, b) => {\n    const anyToReal = (o) => {\n        if (typeof o === 'string') {\n            return parseFloat(o.replace(',', '.'));\n        } else if (typeof o === 'number') {\n            return o;\n        } else {\n            throw new Error(\"Type Error\");\n        }\n    }\n\n    let a1 = anyToReal(a);\n    let b1 = anyToReal(b);\n\n    if (a1 === b1) {\n        return null;\n    } else if (a1 > b1) {\n        return a1;\n    } else {\n        return b1;\n    }\n}\n```",
            "```javascript\nexport const isEqualToSumEven = (n) => {\n    return n % 2 === 0 && n >= 8;\n}\n```",
            "```javascript\n/**\n * @param {number} n\n * @returns {number}\n */\nexport const specialFactorial = (n) => {\n    let fact = 1;\n    let result = 1;\n    for (let i = 1; i <= n; i++) {\n        fact *= i;\n        result *= fact;\n    }\n    return result;\n}\n```",
            "```javascript\n/**\n * @param {string} txt\n * @returns {string}\n */\nexport const fixSpaces = (txt) => {\n    return txt.replace(/\\s{3,}/g, \"-\").replace(/ /g, \"_\");\n}\n```",
            "```javascript\n/**\n * @param {string} fileName\n * @returns {string}\n */\nexport const fileNameCheck = (fileName) => {\n    const suf = [\"txt\", \"exe\", \"dll\"];\n    const lst = fileName.split('.');\n\n    if (lst.length !== 2 || !suf.includes(lst[1]) || lst[0].isEmpty() || !/[a-zA-Z]/.test(lst[0][0]) || [...lst[0]].filter(char => /\\d/.test(char)).length > 3) {\n        return \"No\";\n    }\n    \n    return \"Yes\";\n}\n```",
            "```javascript\n/**\n * @param {Array<number>} lst\n * @returns {number}\n */\nexport const sumSquares = (lst) => {\n    let result = 0;\n    for (let i = 0; i < lst.length; i++) {\n        if (i % 3 === 0) {\n            result += Math.pow(lst[i], 2);\n        } else if (i % 4 === 0) {\n            result += Math.pow(lst[i], 3);\n        } else {\n            result += lst[i];\n        }\n    }\n    return result;\n}\n```",
            "```javascript\n/**\n * @param {string} sentence\n * @returns {string}\n */\nexport const wordsInSentence = (sentence) => {\n    const isPrime = (n) => {\n        if (n < 2) {\n            return false;\n        }\n        for (let i = 2; i <= Math.sqrt(n); i++) {\n            if (n % i === 0) {\n                return false;\n            }\n        }\n        return true;\n    };\n\n    const words = sentence.split(\" \");\n    let result = [];\n    for (const w of words) {\n        if (isPrime(w.length)) {\n            result.push(w);\n        }\n    }\n    return result.join(\" \");\n};\n```",
            "```javascript\n/**\n * @param {string} x\n * @param {string} n\n * @returns {boolean}\n */\nexport const simplify = (x, n) => {\n    const xs = x.split(\"/\");\n    const ns = n.split(\"/\");\n    const num = parseInt(xs[0]) * parseInt(ns[0]);\n    const den = parseInt(xs[1]) * parseInt(ns[1]);\n    return num % den === 0;\n}\n```",
            "```javascript\n/**\n * @param {number} n\n * @returns {number}\n */\nconst digitsSum = (n) => {\n    const nStr = Math.abs(n).toString();\n    if (n >= 0) {\n        return nStr.split('').reduce((sum, d) => sum + parseInt(d, 10), 0);\n    } else {\n        return parseInt(nStr.slice(0, 2), 10) * 2 + digitsSum(-parseInt(nStr.slice(2), 10));\n    }\n}\n\n/**\n * @param {Array<number>} nums\n * @returns {Array<number>}\n */\nexport const orderByPoints = (nums) => {\n    return nums.slice().sort((a, b) => digitsSum(a) - digitsSum(b));\n}\n```",
            "```javascript\n/**\n * @param {Array<number>} nums\n * @returns {number}\n */\nexport const specialFilter = (nums) => {\n    const odds = \"13579\";\n    let count = 0;\n    for (let n of nums) {\n        if (n > 10 && n % 2 === 1 && odds.indexOf(n.toString()[0]) !== -1) {\n            count++;\n        }\n    }\n    return count;\n}\n```",
            "```javascript\n/**\n * @param {number} n\n * @returns {number}\n */\nexport const getMaxTriples = (n) => {\n    let c = [0, 0, 0];\n    for (let i = 1; i <= n; i++) {\n        let a = i * i - i + 1;\n        c[a % 3]++;\n    }\n    return c[0] * c[1] * c[2] + (c[0] * (c[0] - 1) * (c[0] - 2) + c[1] * (c[1] - 1) * (c[1] - 2) + c[2] * (c[2] - 1) * (c[2] - 2)) / 6;\n}\n```",
            "```javascript\n/**\n * @param {string} planet1\n * @param {string} planet2\n * @returns {Array<string>}\n */\nexport const bf = (planet1, planet2) => {\n    const names = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"];\n    if (!names.includes(planet1) || !names.includes(planet2)) {\n        return [];\n    }\n    let l = names.indexOf(planet1);\n    let r = names.indexOf(planet2);\n    if (l > r) {\n        [l, r] = [r, l];\n    }\n    if (l === r) {\n        return [];\n    }\n    return names.slice(l + 1, r);\n}\n```",
            "```javascript\n/**\n * @param {Array<string>} lst\n * @returns {Array<string>}\n */\nexport const sortedListSum = (lst) => {\n    const result = [];\n    for (const s of lst) {\n        if (s.length % 2 === 0) {\n            result.push(s);\n        }\n    }\n    result.sort((x, y) => x.length !== y.length ? x.length - y.length : x.localeCompare(y));\n    return result;\n}\n```",
            "```javascript\n/**\n * @param {number} n\n * @param {number} x\n * @param {number} y\n * @returns {number}\n */\nexport const xOrY = (n, x, y) => {\n    if (n < 2) {\n        return y;\n    }\n    for (let i = 2; i <= Math.sqrt(n); i++) {\n        if (n % i === 0) {\n            return y;\n        }\n    }\n    return x;\n};\n```",
            "```javascript\n/**\n * @param {Array<number>} lst\n * @returns {number}\n */\nexport const doubleTheDifference = (lst) => {\n    return lst.filter(n => n >= 0 && n % 2 === 1)\n             .map(n => n * n)\n             .reduce((acc, curr) => acc + curr, 0);\n}\n```",
            "```javascript\n/**\n * @param {Array<number>} game\n * @param {Array<number>} guess\n * @returns {Array<number>}\n */\nexport const compare = (game, guess) => {\n    return game.map((x, index) => Math.abs(x - guess[index]));\n}\n```",
            "```javascript\n/**\n * @param {string} className\n * @param {Array<string>} extensions\n * @returns {string}\n */\nexport const strongestExtension = (className, extensions) => {\n    let max_s = -Infinity;\n    let max_ext = \"\";\n    for (let ext of extensions) {\n        let upper = 0, lower = 0;\n        for (let c of ext) {\n            if (c >= 'A' && c <= 'Z') {\n                upper++;\n            } else if (c >= 'a' && c <= 'z') {\n                lower++;\n            }\n        }\n        let s = upper - lower;\n        if (s > max_s) {\n            max_s = s;\n            max_ext = ext;\n        }\n    }\n    return className + \".\" + max_ext;\n}\n```",
            "```javascript\n/**\n * @param {string} a\n * @param {string} b\n * @returns {boolean}\n */\nexport const cycpatternCheck = (a, b) => {\n    if (a.length < b.length) {\n        return false;\n    }\n    for (let i = 0; i < b.length; i++) {\n        let rotatedB = b.substring(i) + b.substring(0, i);\n        if (a.includes(rotatedB)) {\n            return true;\n        }\n    }\n    return false;\n}\n```",
            "```javascript\n/**\n * @param {number} num\n * @returns {Array<number>}\n */\nexport const evenOddCount = (num) => {\n    const ds = Math.abs(num).toString();\n    let even = 0;\n    for (let i = 0; i < ds.length; i++) {\n        if ((ds[i] & 1) === 0) {\n            even++;\n        }\n    }\n    return [even, ds.length - even];\n}\n```",
            "```javascript\n/**\n * @param {number} num\n * @returns {string}\n */\nexport const intToMiniRoman = (num) => {\n    const values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    const numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    let res = '';\n    for (let i = 0; i < values.length; i++) {\n        while (num >= values[i]) {\n            res += numerals[i];\n            num -= values[i];\n        }\n    }\n    return res;\n}\n```",
            "```javascript\nexport const rightAngleTriangle = (a, b, c) => {\n    const s = [a, b, c];\n    s.sort((x, y) => x - y);\n    return  s[0] * s[0] + s[1] * s[1] === s[2] * s[2];\n}\n```",
            "```javascript\n/**\n * @param {Array<string>} words\n * @returns {string}\n */\nexport const findMax = (words) => {\n    let maxCnt = 0;\n    let maxW = \"\";\n    for (let w of words) {\n        let uniqueChars = new Set();\n        for (let c of w) {\n            uniqueChars.add(c);\n        }\n        let cnt = uniqueChars.size;\n        if (cnt > maxCnt) {\n            maxCnt = cnt;\n            maxW = w;\n        } else if (cnt === maxCnt) {\n            maxW = min(maxW, w);\n        }\n    }\n    return maxW;\n};\n\nconst min = (a, b) => {\n    return a.localeCompare(b) < 0 ? a : b;\n};\n```",
            "```javascript\n/**\n * @param {number} num\n * @param {number} need\n * @param {number} remaining\n * @returns {Array<number>}\n */\nexport const eat = (num, need, remaining) => {\n    if (need <= remaining) {\n        return [num + need, remaining - need];\n    } else {\n        return [num + remaining, 0];\n    }\n}\n```",
            "```javascript\n/**\n * @param {Array<string>} operators\n * @param {Array<number>} operands\n * @returns {number}\n */\nexport const doAlgebra = (operators, operands) => {\n    let ops = [...operators];\n    let nums = [...operands];\n    let i = ops.length - 1;\n    while (i >= 0) {\n        if (ops[i] === \"**\") {\n            nums[i] = Math.pow(nums[i], nums[i + 1]);\n            nums.splice(i + 1, 1);\n            ops.splice(i, 1);\n        }\n        i--;\n    }\n    i = 0;\n    while (i < ops.length) {\n        if (ops[i] === \"*\") {\n            nums[i] = nums[i] * nums[i + 1];\n            nums.splice(i + 1, 1);\n            ops.splice(i, 1);\n            i--;\n        } else if (ops[i] === \"//\") {\n            nums[i] = Math.floor(nums[i] / nums[i + 1]);\n            nums.splice(i + 1, 1);\n            ops.splice(i, 1);\n            i--;\n        }\n        i++;\n    }\n    i = 0;\n    while (i < ops.length) {\n        if (ops[i] === \"+\") {\n            nums[i] = nums[i] + nums[i + 1];\n            nums.splice(i + 1, 1);\n            ops.splice(i, 1);\n            i--;\n        } else if (ops[i] === \"-\") {\n            nums[i] = nums[i] - nums[i + 1];\n            nums.splice(i + 1, 1);\n            ops.splice(i, 1);\n            i--;\n        }\n        i++;\n    }\n    return nums[0];\n}\n```",
            "```javascript\n/**\n * @param {string} s\n * @returns {string}\n */\nexport const solve = (s) => {\n    if (!/[a-zA-Z]/.test(s)) {\n        return s.split('').reverse().join('');\n    }\n    let result = '';\n    for (let ch of s) {\n        if (!/[a-zA-Z]/.test(ch)) {\n            result += ch;\n        } else if (ch === ch.toUpperCase()) {\n            result += ch.toLowerCase();\n        } else {\n            result += ch.toUpperCase();\n        }\n    }\n    return result;\n}\n```",
            "```javascript\n/**\n * @param {string} txt\n * @returns {?string}\n */\nexport const stringToMd5 = (txt) => {\n    if (!txt) {\n        return null;\n    }\n    const md5Hash = crypto.createHash('md5');\n    const txtBytes = new TextEncoder().encode(txt);\n    md5Hash.update(txtBytes);\n    const md5Encoded = md5Hash.digest('hex');\n    return md5Encoded;\n}\n```",
            "```javascript\n/**\n * @param {number} a\n * @param {number} b\n * @returns {Array<number>}\n */\nexport const generateIntegers = (a, b) => {\n    let lower = Math.max(2, Math.min(a, b));\n    let upper = Math.min(8, Math.max(a, b));\n    let result = [];\n    for (let i = lower; i <= upper; i++) {\n        if (i % 2 === 0) {\n            result.push(i);\n        }\n    }\n    return result;\n}\n```"
        ],
        "cpp": [
            "```cpp\n#include <vector>\n#include <cmath>\n\nbool hasCloseElements(const std::vector<double>& numbers, double threshold) {\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            if (std::abs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```",
            "```cpp\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> separateParenGroups(const string& paren_string) {\n    vector<string> groups;\n    string stk;\n    string current_group;\n    string parens = paren_string;\n    for (char ch : parens) {\n        if (ch == '(') {\n            stk += ch;\n            current_group += ch;\n        } else if (ch == ')') {\n            stk.pop_back();\n            current_group += ch;\n            if (stk.empty()) {\n                groups.push_back(current_group);\n                current_group = \"\";\n            }\n        }\n    }\n    return groups;\n}\n```",
            "```cpp\ndouble truncateNumber(double num) {\n    return num - std::floor(num);\n}\n```",
            "```cpp\nbool belowZero(const vector<int>& operations) {\n    int balance = 0;\n    for (int op : operations) {\n        balance += op;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n```",
            "```cpp\ndouble meanAbsoluteDeviation(const vector<double>& numbers) {\n    double sum = 0;\n    for (double num : numbers) {\n        sum += num;\n    }\n    double mean = sum / numbers.size();\n    \n    double deviationSum = 0;\n    for (double num : numbers) {\n        deviationSum += abs(num - mean);\n    }\n    \n    return deviationSum / numbers.size();\n}\n```",
            "```cpp\nvector<int> intersperse(const vector<int>& numbers, int delimiter) {\n    vector<int> result;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        if (i != 0) {\n            result.push_back(delimiter);\n        }\n        result.push_back(numbers[i]);\n    }\n    return result;\n}\n```",
            "```cpp\nvector<int> parseNestedParens(const string& paren_string) {\n    vector<int> result;\n    stringstream ss(paren_string);\n    string group;\n    while (ss >> group) {\n        int maxDepth = 0;\n        int depth = 0;\n        for (char ch : group) {\n            if (ch == '(') {\n                depth += 1;\n                maxDepth = max(maxDepth, depth);\n            } else if (ch == ')') {\n                depth -= 1;\n            }\n        }\n        result.push_back(maxDepth);\n    }\n    return result;\n}\n```",
            "```cpp\nvector<string> filterBySubstring(const vector<string>& strs, const string& substring) {\n    vector<string> result;\n    for (const string& s : strs) {\n        if (s.find(substring) != string::npos) {\n            result.push_back(s);\n        }\n    }\n    return result;\n}\n```",
            "```cpp\n#include <numeric>\n#include <vector>\n\nstd::vector<int> sumProduct(const std::vector<int>& numbers) {\n    int n_sum = std::accumulate(numbers.begin(), numbers.end(), 0);\n    int n_product = std::accumulate(numbers.begin(), numbers.end(), 1, [](int x, int y){ return x * y; });\n    return {n_sum, n_product};\n}\n```",
            "```cpp\nvector<int> rollingMax(const vector<int>& numbers) {\n    int maxSoFar = INT_MIN;\n    vector<int> result;\n    for (int num : numbers) {\n        maxSoFar = max(maxSoFar, num);\n        result.push_back(maxSoFar);\n    }\n    return result;\n}\n```",
            "```cpp\nbool isPalindrome(const std::string& s) {\n    int left = 0;\n    int right = s.length() - 1;\n    while (left < right) {\n        if (s[left] != s[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n\nstd::string makePalindrome(const std::string& s) {\n    if (isPalindrome(s)) {\n        return s;\n    }\n    for (int i = 0; i < s.length(); i++) {\n        if (isPalindrome(s.substr(i))) {\n            std::string prefix = s.substr(0, i);\n            std::reverse(prefix.begin(), prefix.end());\n            return s + prefix;\n        }\n    }\n    return \"\";\n}\n```",
            "```cpp\nstring stringXor(const string& a, const string& b) {\n    stringstream result;\n    for (size_t i = 0; i < a.length() && i < b.length(); ++i) {\n        char x = a[i];\n        char y = b[i];\n        result << ((x == y) ? '0' : '1');\n    }\n    return result.str();\n}\n```",
            "```cpp\noptional<string> longest(const vector<string>& strs) {\n    if (strs.empty()) {\n        return nullopt;\n    }\n    string longest_s = strs[0];\n    for (const string& s : strs) {\n        if (s.length() > longest_s.length()) {\n            longest_s = s;\n        }\n    }\n    return optional<string>(longest_s);\n}\n```",
            "```cpp\nint greatestCommonDivisor(int a, int b) {\n    if (b == 0) {\n        return a;\n    } else {\n        return greatestCommonDivisor(b, a % b);\n    }\n}\n```",
            "```cpp\nvector<string> allPrefixes(const string& s) {\n    vector<string> prefixes;\n    for (int i = 0; i < s.length(); i++) {\n        prefixes.push_back(s.substr(0, i + 1));\n    }\n    return prefixes;\n}\n```",
            "```cpp\nstring stringSequence(int n) {\n    std::ostringstream result;\n    for (int i = 0; i <= n; ++i) {\n        result << i;\n        if (i < n) {\n            result << \" \";\n        }\n    }\n    return result.str();\n}\n```",
            "```cpp\nint countDistinctCharacters(const string& s) {\n    unordered_set<char> distinctChars(s.begin(), s.end());\n    for (char c : distinctChars) {\n        if (isupper(c)) {\n            distinctChars.insert(tolower(c));\n        }\n    }\n    return distinctChars.size();\n}\n```",
            "```cpp\nvector<int> parseMusic(const string& music_string) {\n    map<string, int> durations = {{\"o\", 4}, {\"o|\", 2}, {\".|\", 1}};\n    vector<int> result;\n    stringstream ss(music_string);\n    string note;\n    while (ss >> note) {\n        result.push_back(durations[note]);\n    }\n    return result;\n}\n```",
            "```cpp\nint howManyTimes(const string& s, const string& substring) {\n    int times = 0;\n    for (int i = 0; i <= s.length() - substring.length(); i++) {\n        if (s.substr(i, substring.length()) == substring) {\n            times++;\n        }\n    }\n    return times;\n}\n```",
            "```cpp\n#include <unordered_map>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n\nusing namespace std;\n\nstring sortNumbers(const string& numbers) {\n    unordered_map<string, int> numDict = {\n        {\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3},\n        {\"four\", 4}, {\"five\", 5}, {\"six\", 6}, {\"seven\", 7},\n        {\"eight\", 8}, {\"nine\", 9}\n    };\n\n    vector<string> numList;\n    stringstream ss(numbers);\n    string num;\n    while (ss >> num) {\n        if (numDict.find(num) != numDict.end()) {\n            numList.push_back(num);\n        }\n    }\n\n    sort(numList.begin(), numList.end(), [&](const string& a, const string& b) {\n        return numDict[a] < numDict[b];\n    });\n\n    return accumulate(numList.begin(), numList.end(), string(), [](const string& a, const string& b) {\n        return a.empty() ? b : a + \" \" + b;\n    });\n}\n```",
            "```cpp\n#include <algorithm>\n#include <vector>\n#include <limits>\n\nusing namespace std;\n\nvector<double> findClosestElements(const vector<double>& numbers) {\n    vector<double> sorted_numbers = numbers;\n    sort(sorted_numbers.begin(), sorted_numbers.end());\n    double min_diff = numeric_limits<double>::infinity();\n    vector<double> closest_pair;\n    for (size_t i = 1; i < sorted_numbers.size(); ++i) {\n        double diff = sorted_numbers[i] - sorted_numbers[i - 1];\n        if (diff < min_diff) {\n            min_diff = diff;\n            closest_pair = {sorted_numbers[i - 1], sorted_numbers[i]};\n        }\n    }\n    return closest_pair;\n}\n```",
            "```cpp\n#include <vector>\n#include <algorithm>\n\nvector<double> rescaleToUnit(const vector<double>& numbers) {\n    if (numbers.empty()) {\n        return {};\n    }\n\n    double minNum = *min_element(numbers.begin(), numbers.end());\n    double maxNum = *max_element(numbers.begin(), numbers.end());\n\n    if (minNum == maxNum) {\n        return vector<double>(numbers.size(), 0.0);\n    } else {\n        vector<double> result;\n        for (double num : numbers) {\n            result.push_back((num - minNum) / (maxNum - minNum));\n        }\n        return result;\n    }\n}\n```",
            "```cpp\nvector<int> filterIntegers(const vector<any>& values) {\n    vector<int> result;\n    for (const auto& x : values) {\n        if (x.type() == typeid(int)) {\n            result.push_back(any_cast<int>(x));\n        }\n    }\n    return result;\n}\n```",
            "```cpp\n#include <string>\n\nint strLength(const std::string& s) {\n    return s.length();\n}\n```",
            "```cpp\nint largestDivisor(int n) {\n    for (int i = 2; i < n; i++) {\n        if (n % i == 0) {\n            return n / i;\n        }\n    }\n    return 1;\n}\n```",
            "```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    int divisor = 2;\n    while (divisor <= n) {\n        if (n % divisor == 0) {\n            factors.push_back(divisor);\n            n /= divisor;\n        } else {\n            divisor += 1;\n        }\n    }\n    return factors;\n}\n```",
            "```cpp\nvector<int> removeDuplicates(const vector<int>& numbers) {\n    map<int, int> counts;\n    for (int num : numbers) {\n        counts[num]++;\n    }\n    vector<int> res;\n    for (int num : numbers) {\n        if (counts[num] == 1) {\n            res.push_back(num);\n        }\n    }\n    return res;\n}\n```",
            "```cpp\nstring flipCase(const string& s) {\n    string flipped;\n    for (char ch : s) {\n        if (!isalpha(ch)) {\n            flipped += ch;\n        } else if (islower(ch)) {\n            flipped += toupper(ch);\n        } else if (isupper(ch)) {\n            flipped += tolower(ch);\n        }\n    }\n    return flipped;\n}\n```",
            "```cpp\nstring concatenate(const vector<string>& strs) {\n    string result;\n    for (const string& str : strs) {\n        result += str;\n    }\n    return result;\n}\n```",
            "```cpp\nvector<string> filterByPrefix(const vector<string>& strs, const string& prefix_str) {\n    vector<string> result;\n    for (const auto& s : strs) {\n        if (s.substr(0, prefix_str.size()) == prefix_str) {\n            result.push_back(s);\n        }\n    }\n    return result;\n}\n```",
            "```cpp\nvector<int> getPositive(const vector<int>& l) {\n    vector<int> result;\n    for (int num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n```",
            "```cpp\nbool isPrime(int n) {\n    if (n < 2) {\n        return false;\n    }\n    for (int i = 2; i <= std::sqrt(n); i++) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```",
            "```cpp\n#include <vector>\n#include <cmath>\n\ndouble poly(const std::vector<int>& xs, double x) {\n    double res = 0.0;\n    for (int i = 0; i < xs.size(); i++) {\n        res += xs[i] * std::pow(x, i);\n    }\n    return res;\n}\n\ndouble findZero(const std::vector<int>& xs) {\n    double x1 = 1.0, x2 = -1.0;\n    while (poly(xs, x1) * poly(xs, x2) > 0) {\n        x1 *= 2;\n        x2 *= 2;\n    }\n    while (std::abs(x1 - x2) > 1e-10) {\n        double mid = (x1 + x2) / 2;\n        if (poly(xs, mid) == 0) {\n            return mid;\n        } else if (poly(xs, mid) * poly(xs, x1) < 0) {\n            x2 = mid;\n        } else {\n            x1 = mid;\n        }\n    }\n    return (x1 + x2) / 2;\n}\n```",
            "```cpp\nvector<int> sortThird(const vector<int>& l) {\n    vector<int> sorted_third;\n    for (size_t i = 0; i < l.size(); i += 3) {\n        sorted_third.push_back(l[i]);\n    }\n    sort(sorted_third.begin(), sorted_third.end());\n\n    vector<int> result;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            result.push_back(sorted_third[i / 3]);\n        } else {\n            result.push_back(l[i]);\n        }\n    }\n    return result;\n}\n```",
            "```cpp\nvector<int> listUnique(const vector<int>& l) {\n    set<int> set(l.begin(), l.end());\n    vector<int> sortedList(set.begin(), set.end());\n    sort(sortedList.begin(), sortedList.end());\n    return sortedList;\n}\n```",
            "```cpp\nint maxElement(const vector<int>& l) {\n    if (l.empty()) {\n        return 0;\n    }\n    return *max_element(l.begin(), l.end());\n}\n```",
            "```cpp\nint fizzBuzz(int n) {\n    int cnt = 0;\n    for (int i = 0; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            std::string str = std::to_string(i);\n            for (char c : str) {\n                if (c == '7') {\n                    cnt++;\n                }\n            }\n        }\n    }\n    return cnt;\n}\n```",
            "```cpp\nvector<int> sortEven(const vector<int>& l) {\n    vector<int> sorted_even;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        sorted_even.push_back(l[i]);\n    }\n    sort(sorted_even.begin(), sorted_even.end());\n    \n    vector<int> result;\n    size_t even_index = 0;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) {\n            result.push_back(sorted_even[even_index++]);\n        } else {\n            result.push_back(l[i]);\n        }\n    }\n    return result;\n}\n```",
            "```cpp\n#include <string>\n\nstd::string encodeCyclic(const std::string& s) {\n    std::string result;\n    for (int i = 0; i < s.length(); i += 3) {\n        if (i + 3 > s.length()) {\n            result.append(s.substr(i));\n        } else {\n            result.append(s.substr(i + 1, 2));\n            result.push_back(s[i]);\n        }\n    }\n    return result;\n}\n\nstd::string decodeCyclic(const std::string& s) {\n    return encodeCyclic(encodeCyclic(s));\n}\n```",
            "```cpp\n#include <cmath>\n\nbool isPrime(int n) {\n    if (n < 2)\n        return false;\n    for (int i = 2; i <= std::sqrt(n); ++i) {\n        if (n % i == 0)\n            return false;\n    }\n    return true;\n}\n\nint primeFib(int n) {\n    int f[2] = {0, 1};\n    int cnt = 0;\n    while (cnt < n) {\n        f[2 % 2] = f[0] + f[1];\n        if (isPrime(f[2 % 2]))\n            ++cnt;\n        f[(2 % 2) ^ 1]++;\n    }\n    return f[(n - 1) & 1];\n}\n```",
            "```cpp\nbool triplesSumToZero(const vector<int>& l) {\n    for (int i = 0; i < l.size(); i++) {\n        for (int j = i + 1; j < l.size(); j++) {\n            for (int k = j + 1; k < l.size(); k++) {\n                if (l[i] + l[j] + l[k] == 0) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```",
            "```cpp\nint carRaceCollision(int n) {\n    return n * n;\n}\n```",
            "```cpp\nvector<int> incrList(const vector<int>& l) {\n    vector<int> result;\n    for (int i : l) {\n        result.push_back(i + 1);\n    }\n    return result;\n}\n```",
            "```cpp\nbool pairsSumToZero(const vector<int>& l) {\n    unordered_set<int> seen;\n    for (int num : l) {\n        if (seen.find(-num) != seen.end()) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    return false;\n}\n```",
            "```cpp\nstring changeBase(int x, int bas) {\n    if (x == 0) {\n        return \"0\";\n    }\n    string digits;\n    while (x > 0) {\n        digits += char(x % bas + '0');\n        x /= bas;\n    }\n    reverse(digits.begin(), digits.end());\n    return digits;\n}\n```",
            "```cpp\ndouble triangleArea(int a, int h) {\n    return static_cast<double>(a) * h / 2;\n}\n```",
            "```cpp\nint fib4(int n) {\n    int fib[4] = {0, 0, 2, 0};\n    for (int i = 4; i <= n; i++) {\n        fib[i % 4] = fib[0] + fib[1] + fib[2] + fib[3];\n    }\n    return fib[n % 4];\n}\n```",
            "```cpp\ndouble median(const vector<double>& l) {\n    vector<double> sl = l;\n    sort(sl.begin(), sl.end());\n    if (sl.size() % 2 != 0) {\n        return sl[sl.size() / 2];\n    } else {\n        return (sl[sl.size() / 2] + sl[sl.size() / 2 - 1]) / 2;\n    }\n}\n```",
            "```cpp\nbool isPalindrome(const std::string& txt) {\n    int n = txt.length();\n    for (int i = 0; i < n / 2; i++) {\n        if (txt[i] != txt[n - 1 - i]) {\n            return false;\n        }\n    }\n    return true;\n}\n```",
            "```cpp\nint modp(int n, int p) {\n    int ret = 1;\n    for (int i = 0; i < n; i++) {\n        ret = (ret * 2) % p;\n    }\n    return ret;\n}\n```",
            "```cpp\nstring encodeShift(const string& s) {\n    string result;\n    for (char ch : s) {\n        result += ((ch - 'a' + 5) % 26) + 'a';\n    }\n    return result;\n}\n\nstring decodeShift(const string& s) {\n    string result;\n    for (char ch : s) {\n        result += ((ch - 'a' + 21) % 26) + 'a';\n    }\n    return result;\n}\n```",
            "```cpp\nstring removeVowels(const string& txt) {\n    const string vowels = \"aeiouAEIOU\";\n    string result;\n    for (char c : txt) {\n        if (vowels.find(c) == string::npos) {\n            result += c;\n        }\n    }\n    return result;\n}\n```",
            "```cpp\nbool belowThreshold(const vector<int>& l, int t) {\n    for (int x : l) {\n        if (x >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n```",
            "```cpp\nint add(int x, int y) {\n    return x + y;\n}\n```",
            "```cpp\n#include <unordered_set>\n#include <vector>\n\nusing namespace std;\n\nbool sameChars(const string& s0, const string& s1) {\n    unordered_set<char> set0(s0.begin(), s0.end());\n    unordered_set<char> set1(s1.begin(), s1.end());\n    return set0 == set1;\n}\n```",
            "```cpp\nint fib(int n) {\n    if (n <= 1) {\n        return n;\n    } else {\n        return fib(n - 1) + fib(n - 2);\n    }\n}\n```",
            "```cpp\nbool correctBracketing(const string& brackets) {\n    int depth = 0;\n    for (char b : brackets) {\n        if (b == '<') {\n            depth += 1;\n        } else if (b == '>') {\n            depth -= 1;\n        }\n        if (depth < 0) {\n            return false;\n        }\n    }\n    return depth == 0;\n}\n```",
            "```cpp\nbool monotonic(const vector<int>& l) {\n    if (l.size() <= 1) return true;\n\n    int n = l.size();\n    bool nonDecreasing = true;\n    bool nonIncreasing = true;\n\n    for (int i = 0; i < n - 1; i++) {\n        if (l[i] > l[i + 1]) {\n            nonDecreasing = false;\n        }\n        if (l[i] < l[i + 1]) {\n            nonIncreasing = false;\n        }\n    }\n\n    return nonDecreasing || nonIncreasing;\n}\n```",
            "```cpp\nvector<int> common(const vector<int>& l1, const vector<int>& l2) {\n    unordered_set<int> set1(l1.begin(), l1.end());\n    unordered_set<int> set2(l2.begin(), l2.end());\n    vector<int> result;\n    \n    for (const int& elem : set1) {\n        if (set2.find(elem) != set2.end()) {\n            result.push_back(elem);\n        }\n    }\n    \n    sort(result.begin(), result.end());\n    return result;\n}\n```",
            "```cpp\nint largestPrimeFactor(int n) {\n    int i = 2;\n    while (i * i <= n) {\n        if (n % i != 0) {\n            i += 1;\n        } else {\n            n /= i;\n        }\n    }\n    return n;\n}\n```",
            "```cpp\nint sumToN(int n) {\n    int sum = 0;\n    for (int i = 1; i <= n; i++) {\n        sum += i;\n    }\n    return sum;\n}\n```",
            "```cpp\nbool correctBracketing(const string& brackets) {\n    int depth = 0;\n    for (char b : brackets) {\n        if (b == '(') {\n            depth += 1;\n        } else if (b == ')') {\n            depth -= 1;\n        }\n        if (depth < 0) {\n            return false;\n        }\n    }\n    return depth == 0;\n}\n```",
            "```cpp\nvector<int> derivative(const vector<int>& xs) {\n    vector<int> result;\n    for (int i = 1; i < xs.size(); i++) {\n        result.push_back(xs[i] * i);\n    }\n    return result;\n}\n```",
            "```cpp\nint fibfib(int n) {\n    if (n <= 1)\n        return 0;\n    int a = 0, b = 0, c = 1;\n    while (n > 2) {\n        a = b;\n        b = c;\n        c = a + b + c;\n        n--;\n    }\n    return c;\n}\n```",
            "```cpp\nint vowelsCount(const string& s) {\n    string vowels = \"aeiou\";\n    int cnt = 0;\n    for (int i = 0; i < s.length(); i++) {\n        if (vowels.find(tolower(s[i])) != string::npos || \n            (i == s.length() - 1 && tolower(s[i]) == 'y')) {\n            cnt++;\n        }\n    }\n    return cnt;\n}\n```",
            "```cpp\nstring circularShift(int x, int shift) {\n    string x_str = to_string(x);\n    if (shift > x_str.length()) {\n        reverse(x_str.begin(), x_str.end());\n        return x_str;\n    } else {\n        return x_str.substr(x_str.length() - shift) + x_str.substr(0, x_str.length() - shift);\n    }\n}\n```",
            "```cpp\nint digitSum(const string& s) {\n    int sum = 0;\n    for (int i = 0; i < s.length(); i++) {\n        char c = s[i];\n        if (isupper(c)) {\n            sum += static_cast<int>(c);\n        }\n    }\n    return sum;\n}\n```",
            "```cpp\n#include <sstream>\n#include <vector>\n\nint fruitDistribution(const string& s, int n) {\n    stringstream ss(s);\n    string word;\n    vector<string> words;\n    \n    while (ss >> word) {\n        words.push_back(word);\n    }\n    \n    for (size_t i = 0; i < words.size(); ++i) {\n        if (words[i] == \"apples\") {\n            return n - stoi(words[i - 1]) - stoi(words[i + 1]);\n        }\n    }\n    \n    return 0; // or handle the case where \"apples\" is not found\n}\n```",
            "```cpp\nvector<int> pluck(const vector<int>& arr) {\n    vector<int> evens;\n    for (int n : arr) {\n        if (n % 2 == 0) {\n            evens.push_back(n);\n        }\n    }\n    if (evens.empty()) {\n        return {};\n    }\n    int minEven = *std::min_element(evens.begin(), evens.end());\n    auto it = std::find(arr.begin(), arr.end(), minEven);\n    return {minEven, std::distance(arr.begin(), it)};\n}\n```",
            "```cpp\nint search(const vector<int>& lst) {\n    unordered_map<int, int> freqs;\n    for (int n : lst) {\n        freqs[n]++;\n    }\n    vector<int> goodVals;\n    for (const auto& entry : freqs) {\n        if (entry.second >= entry.first) {\n            goodVals.push_back(entry.first);\n        }\n    }\n    return !goodVals.empty() ? *max_element(goodVals.begin(), goodVals.end()) : -1;\n}\n```",
            "```cpp\nvector<int> strangeSortList(const vector<int>& lst) {\n    vector<int> sl(lst);\n    sort(sl.begin(), sl.end());\n    vector<int> result;\n    int left = 0, right = sl.size() - 1;\n    while (left <= right) {\n        result.push_back(sl[left]);\n        left += 1;\n        if (left <= right) {\n            result.push_back(sl[right]);\n            right -= 1;\n        }\n    }\n    return result;\n}\n```",
            "```cpp\ndouble triangleArea(int a, int b, int c) {\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return std::sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        return -1.0;\n    }\n}\n```",
            "```cpp\nbool willItFly(const vector<int>& q, int w) {\n    if (q.empty()) {\n        return false;\n    }\n    bool is_palin = true;\n    for (size_t i = 0; i < q.size() / 2; ++i) {\n        if (q[i] != q[q.size() - i - 1]) {\n            is_palin = false;\n            break;\n        }\n    }\n    int total = accumulate(q.begin(), q.end(), 0);\n    return is_palin && total <= w;\n}\n```",
            "```cpp\nint smallestChange(const vector<int>& arr) {\n    int ans = 0;\n    for (int i = 0; i < arr.size() / 2; i++) {\n        if (arr[i] != arr[arr.size() - i - 1]) {\n            ans += 1;\n        }\n    }\n    return ans;\n}\n```",
            "```cpp\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> totalMatch(const vector<string>& lst1, const vector<string>& lst2) {\n    int cnt1 = 0;\n    for (const auto& str : lst1) {\n        cnt1 += str.length();\n    }\n    \n    int cnt2 = 0;\n    for (const auto& str : lst2) {\n        cnt2 += str.length();\n    }\n    \n    return cnt1 <= cnt2 ? lst1 : lst2;\n}\n```",
            "```cpp\n#include <cmath>\n\nbool isPrime(int n) {\n    if (n < 2) {\n        return false;\n    }\n    for (int i = 2; i <= std::sqrt(n); ++i) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool isMultiplyPrime(int a) {\n    int cnt = 0;\n    for (int i = 2; i <= a; ++i) {\n        if (isPrime(i)) {\n            while (a % i == 0) {\n                ++cnt;\n                a /= i;\n            }\n        }\n    }\n    return cnt == 3;\n}\n```",
            "```cpp\nbool isSimplePower(int x, int n) {\n    if (n < 2) {\n        return x == n;\n    }\n    int tmp = 1;\n    while (tmp < x) {\n        tmp *= n;\n    }\n    return tmp == x;\n}\n```",
            "```cpp\nbool isCube(int a) {\n    a = std::abs(a);\n    int root = static_cast<int>(std::round(std::cbrt(a)));\n    return root * root * root == a;\n}\n```",
            "```cpp\nint hexKey(const string& num) {\n    int count = 0;\n    for (char x : num) {\n        if (\"2357BD\".find(x) != string::npos) {\n            count++;\n        }\n    }\n    return count;\n}\n```",
            "```cpp\nstring decimalToBinary(int dec) {\n    string binary = bitset<32>(dec).to_string();\n    // Remove leading zeros\n    binary = binary.substr(binary.find('1'));\n    return \"db\" + binary + \"db\";\n}\n```",
            "```cpp\nbool isHappy(const string& s) {\n    if (s.length() < 3) {\n        return false;\n    }\n    for (int i = 0; i < s.length() - 2; i++) {\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n    return true;\n}\n```",
            "```cpp\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> numericalLetterGrade(const vector<double>& grades) {\n    vector<string> result;\n    for (double g : grades) {\n        if (g == 4.0) {\n            result.push_back(\"A+\");\n        } else if (g > 3.7) {\n            result.push_back(\"A\");\n        } else if (g > 3.3) {\n            result.push_back(\"A-\");\n        } else if (g > 3.0) {\n            result.push_back(\"B+\");\n        } else if (g > 2.7) {\n            result.push_back(\"B\");\n        } else if (g > 2.3) {\n            result.push_back(\"B-\");\n        } else if (g > 2.0) {\n            result.push_back(\"C+\");\n        } else if (g > 1.7) {\n            result.push_back(\"C\");\n        } else if (g > 1.3) {\n            result.push_back(\"C-\");\n        } else if (g > 1.0) {\n            result.push_back(\"D+\");\n        } else if (g > 0.7) {\n            result.push_back(\"D\");\n        } else if (g > 0.0) {\n            result.push_back(\"D-\");\n        } else {\n            result.push_back(\"E\");\n        }\n    }\n    return result;\n}\n```",
            "```cpp\nbool primeLength(const std::string& s) {\n    int length = s.length();\n    if (length < 2) {\n        return false;\n    }\n    for (int i = 2; i <= std::sqrt(length); i++) {\n        if (length % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```",
            "```cpp\nint startsOneEnds(int n) {\n    if (n == 1) {\n        return 1;\n    }\n    return 2 * 9 * static_cast<int>(pow(10, n - 2));\n}\n```",
            "```cpp\nstring solve(int n) {\n    int digitsSum = 0;\n    while (n > 0) {\n        digitsSum += n % 10;\n        n /= 10;\n    }\n    return bitset<32>(digitsSum).to_string().substr(32 - log2(digitsSum + 1));\n}\n```",
            "```cpp\nint add(const vector<int>& lst) {\n    int sum = 0;\n    for (size_t i = 1; i < lst.size(); i += 2) {\n        int x = lst[i];\n        if (x % 2 == 0) {\n            sum += x;\n        }\n    }\n    return sum;\n}\n```",
            "```cpp\nstring antiShuffle(const string& s) {\n    stringstream result;\n    istringstream iss(s);\n    string word;\n    \n    while (iss >> word) {\n        sort(word.begin(), word.end());\n        result << word << \" \";\n    }\n    \n    return result.str().substr(0, result.tellp() - 1);\n}\n```",
            "```cpp\nvector<vector<int>> getRow(const vector<vector<int>>& lst, int x) {\n    vector<vector<int>> coords;\n    for (int i = 0; i < lst.size(); i++) {\n        for (int j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] == x) {\n                vector<int> coord = {i, j};\n                coords.push_back(coord);\n            }\n        }\n    }\n    sort(coords.begin(), coords.end(), [](const vector<int>& a, const vector<int>& b) {\n        return a[0] < b[0] || (a[0] == b[0] && -a[1] < -b[1]);\n    });\n    return coords;\n}\n```",
            "```cpp\nvector<int> sortArray(const vector<int>& arr) {\n    if (arr.empty()) {\n        return {};\n    }\n    if ((arr[0] + arr.back()) % 2 == 0) {\n        vector<int> sortedArr = arr;\n        sort(sortedArr.begin(), sortedArr.end(), greater<int>());\n        return sortedArr;\n    } else {\n        vector<int> sortedArr = arr;\n        sort(sortedArr.begin(), sortedArr.end());\n        return sortedArr;\n    }\n}\n```",
            "```cpp\nstring encrypt(const string& s) {\n    string result;\n    for (char ch : s) {\n        int shifted = ch + 4;\n        if (shifted > 'z') {\n            shifted -= 26;\n        }\n        result += static_cast<char>(shifted);\n    }\n    return result;\n}\n```",
            "```cpp\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <optional>\n\nusing namespace std;\n\noptional<int> nextSmallest(const vector<int>& lst) {\n    set<int> s(lst.begin(), lst.end());\n    if (s.size() < 2) {\n        return nullopt;\n    }\n    auto it = s.begin();\n    ++it;\n    return *it;\n}\n```",
            "```cpp\n#include <string>\nusing namespace std;\n\nint isBored(const string& s) {\n    int count = 0;\n    size_t start = 0, end = 0;\n    while ((start = s.find_first_not_of(\".!? \", start)) != string::npos) {\n        end = s.find_first_of(\".!?\", start);\n        if (end == string::npos) {\n            end = s.length();\n        }\n        string sentence = s.substr(start, end - start);\n        if (sentence.length() >= 2 && sentence.substr(0, 2) == \"I \") {\n            count++;\n        }\n        start = end + 1;\n    }\n    return count;\n}\n```",
            "```cpp\nbool anyInt(const std::any& x, const std::any& y, const std::any& z) {\n    if (x.type() == typeid(int) && y.type() == typeid(int) && z.type() == typeid(int)) {\n        int intX = std::any_cast<int>(x);\n        int intY = std::any_cast<int>(y);\n        int intZ = std::any_cast<int>(z);\n        if ((intX + intY == intZ) || (intX + intZ == intY) || (intY + intZ == intX)) {\n            return true;\n        }\n    }\n    return false;\n}\n```",
            "```cpp\n#include <string>\n\nstd::string encode(const std::string& message) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result;\n    for (char ch : message) {\n        if (isalpha(ch)) {\n            char ch1 = islower(ch) ? toupper(ch) : tolower(ch);\n            if (vowels.find(ch1) != std::string::npos) {\n                ch1 += 2;\n            }\n            result += ch1;\n        } else {\n            result += ch;\n        }\n    }\n    return result;\n}\n```",
            "```cpp\nint skjkasdkd(const vector<int>& lst) {\n    vector<int> primes;\n    for (int n : lst) {\n        if (isPrime(n)) {\n            primes.push_back(n);\n        }\n    }\n    if (primes.empty()) {\n        return 0;\n    }\n    int largest = *max_element(primes.begin(), primes.end());\n    int sum = 0;\n    while (largest > 0) {\n        sum += largest % 10;\n        largest /= 10;\n    }\n    return sum;\n}\n\nbool isPrime(int n) {\n    if (n < 2) {\n        return false;\n    }\n    for (int i = 2; i <= sqrt(n); i++) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```",
            "```cpp\n#include <string>\n#include <unordered_map>\n\nusing namespace std;\n\nbool checkDictCase(const unordered_map<string, string>& d) {\n    if (d.empty()) {\n        return false;\n    }\n    bool allLower = true;\n    bool allUpper = true;\n    for (const auto& pair : d) {\n        const string& key = pair.first;\n        for (char c : key) {\n            if (!islower(c)) {\n                allLower = false;\n            }\n            if (!isupper(c)) {\n                allUpper = false;\n            }\n        }\n    }\n    return allLower || allUpper;\n}\n```",
            "```cpp\nvector<int> countUpTo(int n) {\n    vector<int> primes;\n    for (int num = 2; num < n; num++) {\n        bool isPrime = true;\n        for (int p : primes) {\n            if (num % p == 0) {\n                isPrime = false;\n                break;\n            }\n        }\n        if (isPrime) {\n            primes.push_back(num);\n        }\n    }\n    return primes;\n}\n```",
            "```cpp\nint multiply(int a, int b) {\n    return (abs(a) % 10) * (abs(b) % 10);\n}\n```",
            "```cpp\nint countUpper(const string& s) {\n    string vowels = \"AEIOU\";\n    int count = 0;\n    for (int i = 0; i < s.length(); i++) {\n        char c = s[i];\n        if (i % 2 == 0 && vowels.find(c) != string::npos) {\n            count++;\n        }\n    }\n    return count;\n}\n```",
            "```cpp\nint closestInteger(const string& value) {\n    double num = stod(value);\n    if (num >= 0) {\n        return static_cast<int>(num + 0.5);\n    } else {\n        return static_cast<int>(num - 0.5);\n    }\n}\n```",
            "```cpp\nvector<int> makeAPile(int n) {\n    vector<int> pile;\n    for (int i = 0; i < n; ++i) {\n        pile.push_back(n + 2 * i);\n    }\n    return pile;\n}\n```",
            "```cpp\n#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nvector<string> wordsString(const string& s) {\n    stringstream ss(s);\n    string word;\n    vector<string> result;\n    while (getline(ss, word, ',')) {\n        stringstream wordStream(word);\n        string subWord;\n        while (wordStream >> subWord) {\n            result.push_back(subWord);\n        }\n    }\n    return result;\n}\n```",
            "```cpp\nint chooseNum(int x, int y) {\n    if (x > y) {\n        return -1;\n    }\n    if (y % 2 == 0) {\n        return y;\n    }\n    return y - 1;\n}\n```",
            "```cpp\n#include <string>\n#include <optional>\n\nstd::optional<std::string> roundedAvg(int n, int m) {\n    if (n > m) {\n        return std::nullopt;\n    }\n    int rAvg = static_cast<int>((m + n) / 2.0 + 0.5);\n    return std::bitset<32>(rAvg).to_string();\n}\n```",
            "```cpp\n#include <vector>\n#include <algorithm>\n\nvector<int> uniqueDigits(const vector<int>& x) {\n    auto allDigitsOdd = [](const string& s) -> bool {\n        for (char digit : s) {\n            if ((digit - '0') % 2 == 0) {\n                return false;\n            }\n        }\n        return true;\n    };\n\n    vector<int> result;\n    for (int num : x) {\n        if (allDigitsOdd(to_string(num))) {\n            result.push_back(num);\n        }\n    }\n\n    sort(result.begin(), result.end());\n    return result;\n}\n```",
            "```cpp\nvector<string> byLength(const vector<int>& arr) {\n    string digitNames[10] = {\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n    vector<int> sortedArr;\n    \n    copy_if(arr.begin(), arr.end(), back_inserter(sortedArr), [](int x) { return x >= 1 && x <= 9; });\n    sort(sortedArr.begin(), sortedArr.end(), greater<int>());\n    \n    vector<string> result;\n    for (int num : sortedArr) {\n        result.push_back(digitNames[num - 1]);\n    }\n    \n    return result;\n}\n```",
            "```cpp\nvector<int> f(int n) {\n    vector<int> nums(n);\n    iota(nums.begin(), nums.end(), 1);\n    vector<int> result;\n    for (int i = 0; i < n; ++i) {\n        if (i % 2 != 0) {\n            result.push_back(accumulate(nums.begin(), nums.begin() + i + 1, 0));\n        } else {\n            int product = 1;\n            for (int j = 0; j <= i; ++j) {\n                product *= nums[j];\n            }\n            result.push_back(product);\n        }\n    }\n    return result;\n}\n```",
            "```cpp\n#include <string>\n#include <vector>\n\nbool is_palindrome(const std::string& txt) {\n    return txt == std::string(txt.rbegin(), txt.rend());\n}\n\nstd::vector<int> evenOddPalindrome(int n) {\n    std::vector<int> cnt(2, 0);\n    for (int i = 1; i <= n; ++i) {\n        if (is_palindrome(std::to_string(i))) {\n            cnt[i % 2] += 1;\n        }\n    }\n    return cnt;\n}\n```",
            "```cpp\nint digitsSum(int n) {\n    std::string n_str = std::to_string(n);\n    if (n >= 0) {\n        return std::accumulate(n_str.begin(), n_str.end(), 0, [](int sum, char d) { return sum + (d - '0'); });\n    } else {\n        return (n_str[0] - '0') * 2 + digitsSum(std::abs(n));\n    }\n}\n\nint countNums(const std::vector<int>& arr) {\n    return std::count_if(arr.begin(), arr.end(), [](int n) { return digitsSum(n) > 0; });\n}\n```",
            "```cpp\nbool moveOneBall(const std::vector<int>& arr) {\n    if (arr.size() == 0) {\n        return true;\n    }\n    std::vector<int> sortedArr = arr;\n    std::sort(sortedArr.begin(), sortedArr.end());\n    for (int i = 0; i < arr.size(); i++) {\n        if (std::equal(arr.begin() + i, arr.end(), sortedArr.begin()) &&\n            std::equal(arr.begin(), arr.begin() + i, sortedArr.begin() + arr.size() - i)) {\n            return true;\n        }\n    }\n    return false;\n}\n```",
            "```cpp\nstring canExchange(const vector<int>& lst1, const vector<int>& lst2) {\n    int odd_cnt = 0;\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            odd_cnt++;\n        }\n    }\n    \n    int even_cnt = 0;\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            even_cnt++;\n        }\n    }\n    \n    return even_cnt >= odd_cnt ? \"YES\" : \"NO\";\n}\n```",
            "```cpp\nunordered_map<string, int> histogram(const string& test) {\n    unordered_map<string, int> freq;\n    stringstream ss(test);\n    string w;\n    while (ss >> w) {\n        if (!w.empty()) {\n            freq[w]++;\n        }\n    }\n    unordered_map<string, int> result;\n    if (!freq.empty()) {\n        int max_freq = 0;\n        for (const auto& p : freq) {\n            if (p.second > max_freq) {\n                max_freq = p.second;\n            }\n        }\n        for (const auto& p : freq) {\n            if (p.second == max_freq) {\n                result[p.first] = p.second;\n            }\n        }\n    }\n    return result;\n}\n```",
            "```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nvector<string> reverseDelete(const string& s, const string& c) {\n    string s1;\n    for (char ch : s) {\n        if (c.find(ch) == string::npos) {\n            s1 += ch;\n        }\n    }\n    string palindromeCheck = s1;\n    reverse(palindromeCheck.begin(), palindromeCheck.end());\n    vector<string> resultList;\n    resultList.push_back(s1);\n    resultList.push_back(palindromeCheck == s1 ? \"yes\" : \"no\");\n    return resultList;\n}\n```",
            "```cpp\nvector<string> oddCount(const vector<string>& lst) {\n    vector<string> result;\n    for (const string& num : lst) {\n        int n = 0;\n        for (char d : num) {\n            if ((int)d % 2 == 1) {\n                n++;\n            }\n        }\n        string rs = \"the number of odd elements in the string i of the input.\";\n        result.push_back(rs.replace(rs.find(\"i\"), 1, to_string(n)));\n    }\n    return result;\n}\n```",
            "```cpp\nint minSubArraySum(const vector<int>& nums) {\n    int min_sum = 0;\n    int cur_sum = 0;\n    for (int n : nums) {\n        cur_sum = std::min(cur_sum + n, 0);\n        min_sum = std::min(cur_sum, min_sum);\n    }\n    if (min_sum == 0) {\n        min_sum = *std::min_element(nums.begin(), nums.end());\n    }\n    return min_sum;\n}\n```",
            "```cpp\nint maxFill(const vector<vector<int>>& grid, int capacity) {\n    int total = 0;\n    for (const auto& arr : grid) {\n        int sum = 0;\n        for (int num : arr) {\n            sum += num;\n        }\n        total += ceil(static_cast<double>(sum) / capacity);\n    }\n    return total;\n}\n```",
            "```cpp\n#include <vector>\n#include <algorithm>\n\nint count_ones(int num) {\n    return __builtin_popcount(num);\n}\n\nvector<int> sortArray(const vector<int>& arr) {\n    vector<int> sortedArr = arr;\n    std::sort(sortedArr.begin(), sortedArr.end(), [](int x, int y) {\n        int cx = count_ones(x);\n        int cy = count_ones(y);\n        return (cx == cy) ? x < y : cx < cy;\n    });\n    return sortedArr;\n}\n```",
            "```cpp\nvector<string> selectWords(const string& s, int n) {\n    string consonants = \"bcdfghjklmnpqrstvwxyz\";\n    vector<string> words;\n    stringstream ss(s);\n    string word;\n    while (ss >> word) {\n        if (!word.empty()) {\n            words.push_back(word);\n        }\n    }\n    \n    vector<string> result;\n    for (const auto& w : words) {\n        int consonantCount = 0;\n        for (char c : w) {\n            char lowerC = tolower(c);\n            if (consonants.find(lowerC) != string::npos) {\n                ++consonantCount;\n            }\n        }\n        if (consonantCount == n) {\n            result.push_back(w);\n        }\n    }\n    \n    return result;\n}\n```",
            "```cpp\nstring getClosestVowel(const string& word) {\n    string vowels = \"aeiouAEIOU\";\n    for (int i = word.length() - 2; i > 0; i--) {\n        if (vowels.find(word[i]) != string::npos && vowels.find(word[i - 1]) == string::npos && vowels.find(word[i + 1]) == string::npos) {\n            return string(1, word[i]);\n        }\n    }\n    return \"\";\n}\n```",
            "```cpp\nstring matchParens(const vector<string>& lst) {\n    string s1 = lst[0] + lst[1];\n    string s2 = lst[1] + lst[0];\n    return (check(s1) || check(s2)) ? \"Yes\" : \"No\";\n}\n\nbool check(const string& s) {\n    int depth = 0;\n    for (char ch : s) {\n        if (ch == '(') {\n            depth += 1;\n        } else {\n            depth -= 1;\n        }\n        if (depth < 0) {\n            return false;\n        }\n    }\n    return depth == 0;\n}\n```",
            "```cpp\nvector<int> maximum(const vector<int>& arr, int k) {\n    if (k == 0) {\n        return {};\n    }\n    vector<int> sortedArr = arr;\n    sort(sortedArr.begin(), sortedArr.end());\n    return vector<int>(sortedArr.end() - k, sortedArr.end());\n}\n```",
            "```cpp\nint solution(const vector<int>& lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); i++) {\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```",
            "```cpp\nint addElements(const vector<int>& arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < min(k, static_cast<int>(arr.size())); i++) {\n        if (to_string(arr[i]).length() <= 2) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n```",
            "```cpp\nvector<int> getOddCollatz(int n) {\n    vector<int> collatz = {1};\n    while (n != 1) {\n        if (n % 2 != 0) {\n            collatz.push_back(n);\n            n = 3 * n + 1;\n        } else {\n            n = n / 2;\n        }\n    }\n    sort(collatz.begin(), collatz.end());\n    return collatz;\n}\n```",
            "```cpp\nbool validDate(const string& date) {\n    if (date.length() != 10 || date[2] != '-' || date[5] != '-') {\n        return false;\n    }\n    int m = stoi(date.substr(0, 2));\n    int d = stoi(date.substr(3, 2));\n    if ((m == 1 || m == 3 || m == 5 || m == 7 || m == 8 || m == 10 || m == 12) && d >= 1 && d <= 31) {\n        return true;\n    }\n    if ((m == 4 || m == 6 || m == 9 || m == 11) && d >= 1 && d <= 30) {\n        return true;\n    }\n    if (m == 2 && d >= 1 && d <= 29) {\n        return true;\n    }\n    return false;\n}\n```",
            "```cpp\nvector<string> splitWords(const string& txt) {\n    if (txt.find(\" \") != string::npos) {\n        stringstream ss(txt);\n        vector<string> result;\n        string word;\n        while (ss >> word) {\n            result.push_back(word);\n        }\n        return result;\n    } else if (txt.find(\",\") != string::npos) {\n        stringstream ss(txt);\n        vector<string> result;\n        string word;\n        while (getline(ss, word, ',')) {\n            result.push_back(word);\n        }\n        return result;\n    } else {\n        int count = 0;\n        for (char c : txt) {\n            if (islower(c) && static_cast<int>(c) % 2 == 0) {\n                count++;\n            }\n        }\n        return {to_string(count)};\n    }\n}\n```",
            "```cpp\nbool isSorted(const std::vector<int>& lst) {\n    if (lst.size() < 2) return true;\n    for (size_t i = 1; i < lst.size(); ++i) {\n        if (lst[i - 1] > lst[i]) return false;\n    }\n    std::unordered_map<int, int> freq;\n    for (int num : lst) {\n        freq[num]++;\n    }\n    int maxFreq = 0;\n    for (const auto& pair : freq) {\n        if (pair.second > maxFreq) {\n            maxFreq = pair.second;\n        }\n    }\n    return maxFreq <= 2;\n}\n```",
            "```cpp\n#include <vector>\n#include <cmath>\n\nbool isPrime(int n) {\n    if (n < 2) {\n        return false;\n    }\n    for (int i = 2; i <= std::sqrt(n); i++) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nstring intersection(const vector<int>& interval1, const vector<int>& interval2) {\n    int l = std::max(interval1[0], interval2[0]);\n    int r = std::min(interval1[1], interval2[1]);\n    int length = r - l;\n    return isPrime(length) && length > 0 ? \"YES\" : \"NO\";\n}\n```",
            "```cpp\n#include <vector>\n#include <optional>\n#include <numeric>\n\nstd::optional<int> prodSigns(const std::vector<int>& arr) {\n    if (arr.empty()) {\n        return std::nullopt;\n    }\n    if (std::find(arr.begin(), arr.end(), 0) != arr.end()) {\n        return 0;\n    }\n    int negative_count = std::count_if(arr.begin(), arr.end(), [](int n) { return n < 0; });\n    int sign = (negative_count % 2 == 1) ? -1 : 1;\n    int sum_of_abs = std::accumulate(arr.begin(), arr.end(), 0, [](int acc, int n) { return acc + std::abs(n); });\n    return sign * sum_of_abs;\n}\n```",
            "```cpp\nvector<int> minPath(const vector<vector<int>>& grid, int k) {\n    int n = grid.size();\n    int min_val = n * n + 1;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (grid[i][j] == 1) {\n                vector<int> temp;\n                if (i != 0) {\n                    temp.push_back(grid[i - 1][j]);\n                }\n                if (j != 0) {\n                    temp.push_back(grid[i][j - 1]);\n                }\n                if (i != n - 1) {\n                    temp.push_back(grid[i + 1][j]);\n                }\n                if (j != n - 1) {\n                    temp.push_back(grid[i][j + 1]);\n                }\n                min_val = *min_element(temp.begin(), temp.end());\n            }\n        }\n    }\n    vector<int> result;\n    for (int i = 0; i < k; ++i) {\n        result.push_back(i % 2 == 0 ? 1 : min_val);\n    }\n    return result;\n}\n```",
            "```cpp\nvector<int> tri(int n) {\n    if (n == 0) {\n        return vector<int>{1};\n    }\n    vector<int> seq = {1, 3};\n    for (int i = 2; i <= n; i++) {\n        if (i % 2 == 0) {\n            seq.push_back(i / 2 + 1);\n        } else {\n            int nextValue = seq[i - 1] + seq[i - 2] + (i + 3) / 2;\n            seq.push_back(nextValue);\n        }\n    }\n    return seq;\n}\n```",
            "```cpp\nint digits(int n) {\n    std::string numStr = std::to_string(n);\n    int product = 1;\n    bool hasOddDigit = false;\n    \n    for (char c : numStr) {\n        int digit = c - '0';\n        if (digit % 2 == 1) {\n            product *= digit;\n            hasOddDigit = true;\n        }\n    }\n    \n    return hasOddDigit ? product : 0;\n}\n```",
            "```cpp\nbool isNested(const string& s) {\n    vector<int> openIdx;\n    vector<int> closeIdx;\n    for (int i = 0; i < s.length(); i++) {\n        char ch = s[i];\n        if (ch == '[') {\n            openIdx.push_back(i);\n        } else if (ch == ']') {\n            closeIdx.push_back(i);\n        }\n    }\n    reverse(closeIdx.begin(), closeIdx.end());\n    int cnt = 0;\n    int i = 0;\n    int l = closeIdx.size();\n    for (int idx : openIdx) {\n        if (i < l && idx < closeIdx[i]) {\n            cnt++;\n            i++;\n        }\n    }\n    return cnt >= 2;\n}\n```",
            "```cpp\n#include <vector>\n#include <cmath>\n\nint sumSquares(const std::vector<double>& lst) {\n    int sum = 0;\n    for (double n : lst) {\n        int ceilingValue = static_cast<int>(std::ceil(n));\n        sum += ceilingValue * ceilingValue;\n    }\n    return sum;\n}\n```",
            "```cpp\nbool checkIfLastCharIsALetter(const string& txt) {\n    if (txt.empty()) {\n        return false;\n    }\n    size_t lastSpaceIndex = txt.find_last_of(' ');\n    string lastPart = txt.substr(lastSpaceIndex + 1);\n    return lastPart.length() == 1 && isalpha(lastPart[0]);\n}\n```",
            "```cpp\nint canArrange(const vector<int>& arr) {\n    if (arr.size() <= 1) {\n        return -1;\n    }\n    int idx = -1;\n    for (int i = 1; i < arr.size(); i++) {\n        if (arr[i] < arr[i - 1]) {\n            idx = i;\n        }\n    }\n    return idx;\n}\n```",
            "```cpp\nvector<optional<int>> largestSmallestIntegers(const vector<int>& lst) {\n    vector<int> neg;\n    vector<int> pos;\n    \n    for (int i : lst) {\n        if (i < 0) {\n            neg.push_back(i);\n        } else if (i > 0) {\n            pos.push_back(i);\n        }\n    }\n    \n    optional<int> maxNeg = neg.empty() ? nullopt : *max_element(neg.begin(), neg.end());\n    optional<int> minPos = pos.empty() ? nullopt : *min_element(pos.begin(), pos.end());\n    \n    return {maxNeg, minPos};\n}\n```",
            "```cpp\n#include <optional>\n#include <any>\n#include <string>\n\nstd::optional<double> anyToReal(const std::any& o) {\n    if (o.type() == typeid(std::string)) {\n        return std::stod(std::any_cast<std::string>(o).replace(comma, '.'));\n    } else if (o.type() == typeid(int)) {\n        return static_cast<double>(std::any_cast<int>(o));\n    } else if (o.type() == typeid(double)) {\n        return std::any_cast<double>(o);\n    } else {\n        throw std::runtime_error(\"Type Error\");\n    }\n}\n\nstd::optional<double> compareOne(const std::any& a, const std::any& b) {\n    double a1 = anyToReal(a).value();\n    double b1 = anyToReal(b).value();\n    if (a1 == b1) {\n        return std::nullopt;\n    } else if (a1 > b1) {\n        return a1;\n    } else {\n        return b1;\n    }\n}\n```",
            "```cpp\nbool isEqualToSumEven(int n) {\n    return n % 2 == 0 && n >= 8;\n}\n```",
            "```cpp\nint specialFactorial(int n) {\n    int fact = 1;\n    int result = 1;\n    for (int i = 1; i <= n; i++) {\n        fact *= i;\n        result *= fact;\n    }\n    return result;\n}\n```",
            "```cpp\nstring fixSpaces(const string& txt) {\n    string result;\n    int n = txt.length();\n    bool inSpaceSequence = false;\n\n    for (int i = 0; i < n; ++i) {\n        if (txt[i] == ' ') {\n            if (!inSpaceSequence) {\n                inSpaceSequence = true;\n                if (countConsecutiveSpaces(txt, i) >= 3) {\n                    result += \"-\";\n                    while (i < n && txt[i] == ' ') ++i;\n                    --i; // Adjust for the loop increment\n                } else {\n                    result += \"_\";\n                }\n            }\n        } else {\n            result += txt[i];\n            inSpaceSequence = false;\n        }\n    }\n\n    return result;\n}\n\nint countConsecutiveSpaces(const string& str, int start) {\n    int count = 0;\n    for (int i = start; i < str.length(); ++i) {\n        if (str[i] == ' ') ++count;\n        else break;\n    }\n    return count;\n}\n```",
            "```cpp\n#include <vector>\n#include <string>\n#include <cctype>\nusing namespace std;\n\nbool endsWith(vector<string>& vec, const string& str) {\n    for (const auto& suffix : vec) {\n        if (str == suffix) return true;\n    }\n    return false;\n}\n\nint countDigits(const string& str) {\n    int count = 0;\n    for (char ch : str) {\n        if (isdigit(ch)) count++;\n    }\n    return count;\n}\n\nstring fileNameCheck(const string& file_name) {\n    vector<string> suf = {\"txt\", \"exe\", \"dll\"};\n    size_t dotPos = file_name.find('.');\n    \n    if (dotPos == string::npos || dotPos == 0 || dotPos == file_name.length() - 1)\n        return \"No\";\n    \n    string extension = file_name.substr(dotPos + 1);\n    string namePart = file_name.substr(0, dotPos);\n    \n    if (!endsWith(suf, extension) || !isalpha(namePart[0]) || countDigits(namePart) > 3)\n        return \"No\";\n    \n    return \"Yes\";\n}\n```",
            "```cpp\nint sumSquares(const vector<int>& lst) {\n    int result = 0;\n    for (size_t i = 0; i < lst.size(); i++) {\n        if (i % 3 == 0) {\n            result += pow(lst[i], 2);\n        } else if (i % 4 == 0) {\n            result += pow(lst[i], 3);\n        } else {\n            result += lst[i];\n        }\n    }\n    return result;\n}\n```",
            "```cpp\n#include <sstream>\nusing namespace std;\n\nbool isPrime(int n) {\n    if (n < 2) {\n        return false;\n    }\n    for (int i = 2; i <= sqrt(n); i++) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nstring wordsInSentence(const string& sentence) {\n    stringstream ss(sentence);\n    string word;\n    string result;\n    while (ss >> word) {\n        if (isPrime(word.length())) {\n            if (!result.empty()) {\n                result += \" \";\n            }\n            result += word;\n        }\n    }\n    return result;\n}\n```",
            "```cpp\nbool simplify(const string& x, const string& n) {\n    string xs[2];\n    string ns[2];\n    size_t slashPos = x.find('/');\n    xs[0] = x.substr(0, slashPos);\n    xs[1] = x.substr(slashPos + 1);\n    slashPos = n.find('/');\n    ns[0] = n.substr(0, slashPos);\n    ns[1] = n.substr(slashPos + 1);\n    int num = stoi(xs[0]) * stoi(ns[0]);\n    int den = stoi(xs[1]) * stoi(ns[1]);\n    return num % den == 0;\n}\n```",
            "```cpp\n#include <string>\n#include <vector>\n#include <algorithm>\n\nint digitsSum(int n) {\n    std::string n_str = std::to_string(n);\n    if (n >= 0) {\n        int sum = 0;\n        for (char d : n_str) {\n            sum += d - '0';\n        }\n        return sum;\n    } else {\n        return 2 * (n_str[0] - '0' + (n_str[1] - '0')) + digitsSum(std::abs(n));\n    }\n}\n\nvector<int> orderByPoints(const vector<int>& nums) {\n    vector<int> sorted_nums = nums;\n    std::sort(sorted_nums.begin(), sorted_nums.end(), [](int a, int b) {\n        return digitsSum(a) < digitsSum(b);\n    });\n    return sorted_nums;\n}\n```",
            "```cpp\n#include <vector>\n#include <string>\n\nint specialFilter(const std::vector<int>& nums) {\n    std::string odds = \"13579\";\n    int count = 0;\n    for (int n : nums) {\n        if (n > 10 && n % 2 == 1 && odds.find(std::to_string(n)[0]) != std::string::npos) {\n            count++;\n        }\n    }\n    return count;\n}\n```",
            "```cpp\nint getMaxTriples(int n) {\n    int c[3] = {0, 0, 0};\n    for (int i = 1; i <= n; i++) {\n        int a = i * i - i + 1;\n        c[a % 3]++;\n    }\n    return c[0] * c[1] * c[2] + (c[0] * (c[0] - 1) * (c[0] - 2) + c[1] * (c[1] - 1) * (c[1] - 2) + c[2] * (c[2] - 1) * (c[2] - 2)) / 6;\n}\n```",
            "```cpp\nvector<string> bf(const string& planet1, const string& planet2) {\n    vector<string> names = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    if (find(names.begin(), names.end(), planet1) == names.end() || find(names.begin(), names.end(), planet2) == names.end()) {\n        return {};\n    }\n    int l = distance(names.begin(), find(names.begin(), names.end(), planet1));\n    int r = distance(names.begin(), find(names.begin(), names.end(), planet2));\n    if (l > r) {\n        swap(l, r);\n    }\n    if (l == r) {\n        return {};\n    }\n    return vector<string>(names.begin() + l + 1, names.begin() + r);\n}\n```",
            "```cpp\nvector<string> sortedListSum(const vector<string>& lst) {\n    vector<string> result;\n    for (const string& s : lst) {\n        if (s.length() % 2 == 0) {\n            result.push_back(s);\n        }\n    }\n    sort(result.begin(), result.end(), [](const string& x, const string& y) {\n        return x.length() != y.length() ? x.length() < y.length() : x < y;\n    });\n    return result;\n}\n```",
            "```cpp\nint xOrY(int n, int x, int y) {\n    if (n < 2) {\n        return y;\n    }\n    for (int i = 2; i <= sqrt(n); i++) {\n        if (n % i == 0) {\n            return y;\n        }\n    }\n    return x;\n}\n```",
            "```cpp\nint doubleTheDifference(const vector<double>& lst) {\n    return accumulate(lst.begin(), lst.end(), 0, [](int sum, double n) {\n        if (n >= 0 && n == floor(n) && n % 2 == 1) {\n            return sum + static_cast<int>(n * n);\n        }\n        return sum;\n    });\n}\n```",
            "```cpp\nvector<int> compare(const vector<int>& game, const vector<int>& guess) {\n    vector<int> result;\n    for (size_t i = 0; i < game.size(); ++i) {\n        result.push_back(abs(game[i] - guess[i]));\n    }\n    return result;\n}\n```",
            "```cpp\nstring strongestExtension(const string& class_name, const vector<string>& extensions) {\n    int max_s = INT_MIN;\n    string max_ext = \"\";\n    for (const string& ext : extensions) {\n        int upper = 0, lower = 0;\n        for (char c : ext) {\n            if (isupper(c)) upper++;\n            else if (islower(c)) lower++;\n        }\n        int s = upper - lower;\n        if (s > max_s) {\n            max_s = s;\n            max_ext = ext;\n        }\n    }\n    return class_name + \".\" + max_ext;\n}\n```",
            "```cpp\nbool cycpatternCheck(const string& a, const string& b) {\n    if (a.length() < b.length()) {\n        return false;\n    }\n    for (int i = 0; i < b.length(); i++) {\n        string rotatedB = b.substr(i) + b.substr(0, i);\n        if (a.find(rotatedB) != string::npos) {\n            return true;\n        }\n    }\n    return false;\n}\n```",
            "```cpp\nvector<int> evenOddCount(int num) {\n    string ds = to_string(abs(num));\n    int even = 0;\n    for (char d : ds) {\n        if ((d - '0') % 2 == 0) {\n            even++;\n        }\n    }\n    return {even, static_cast<int>(ds.length()) - even};\n}\n```",
            "```cpp\nstring intToMiniRoman(int num) {\n    int values[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    string numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    string res = \"\";\n    for (int i = 0; i < 13; i++) {\n        while (num >= values[i]) {\n            res += numerals[i];\n            num -= values[i];\n        }\n    }\n    return res;\n}\n```",
            "```cpp\nbool rightAngleTriangle(int a, int b, int c) {\n    int s[3] = {a, b, c};\n    std::sort(s, s + 3);\n    return s[0] * s[0] + s[1] * s[1] == s[2] * s[2];\n}\n```",
            "```cpp\nstring findMax(const vector<string>& words) {\n    int maxCnt = 0;\n    string maxW = \"\";\n    for (const string& w : words) {\n        set<char> uniqueChars;\n        for (char c : w) {\n            uniqueChars.insert(c);\n        }\n        int cnt = uniqueChars.size();\n        if (cnt > maxCnt) {\n            maxCnt = cnt;\n            maxW = w;\n        } else if (cnt == maxCnt) {\n            maxW = min(maxW, w);\n        }\n    }\n    return maxW;\n}\n```",
            "```cpp\nstd::vector<int> eat(int num, int need, int remaining) {\n    if (need <= remaining) {\n        return std::vector<int>({num + need, remaining - need});\n    } else {\n        return std::vector<int>({num + remaining, 0});\n    }\n}\n```",
            "```cpp\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint doAlgebra(const vector<string>& operators, const vector<int>& operands) {\n    vector<string> ops = operators;\n    vector<int> nums = operands;\n    int i = ops.size() - 1;\n    while (i >= 0) {\n        if (ops[i] == \"**\") {\n            nums[i] = static_cast<int>(pow(nums[i], nums[i + 1]));\n            nums.erase(nums.begin() + i + 1);\n            ops.erase(ops.begin() + i);\n        }\n        i--;\n    }\n    i = 0;\n    while (i < ops.size()) {\n        if (ops[i] == \"*\") {\n            nums[i] *= nums[i + 1];\n            nums.erase(nums.begin() + i + 1);\n            ops.erase(ops.begin() + i);\n            i--;\n        } else if (ops[i] == \"//\") {\n            nums[i] /= nums[i + 1];\n            nums.erase(nums.begin() + i + 1);\n            ops.erase(ops.begin() + i);\n            i--;\n        }\n        i++;\n    }\n    i = 0;\n    while (i < ops.size()) {\n        if (ops[i] == \"+\") {\n            nums[i] += nums[i + 1];\n            nums.erase(nums.begin() + i + 1);\n            ops.erase(ops.begin() + i);\n            i--;\n        } else if (ops[i] == \"-\") {\n            nums[i] -= nums[i + 1];\n            nums.erase(nums.begin() + i + 1);\n            ops.erase(ops.begin() + i);\n            i--;",
            "```cpp\nstring solve(const string& s) {\n    bool hasLetter = false;\n    for (char ch : s) {\n        if (isalpha(ch)) {\n            hasLetter = true;\n            break;\n        }\n    }\n    if (!hasLetter) {\n        return string(s.rbegin(), s.rend());\n    }\n    string result;\n    for (char ch : s) {\n        if (!isalpha(ch)) {\n            result += ch;\n        } else if (isupper(ch)) {\n            result += tolower(ch);\n        } else if (islower(ch)) {\n            result += toupper(ch);\n        }\n    }\n    return result;\n}\n```",
            "```cpp\n#include <string>\n#include <optional>\n#include <openssl/md5.h>\n\nstd::optional<std::string> stringToMd5(const std::string& txt) {\n    if (txt.empty()) {\n        return std::nullopt;\n    }\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5(reinterpret_cast<const unsigned char*>(txt.c_str()), txt.size(), digest);\n\n    char md5String[33];\n    for (int i = 0; i < 16; ++i) {\n        sprintf(&md5String[i * 2], \"%02x\", digest[i]);\n    }\n\n    return std::string(md5String);\n}\n```",
            "```cpp\nvector<int> generateIntegers(int a, int b) {\n    int lower = max(2, min(a, b));\n    int upper = min(8, max(a, b));\n    vector<int> result;\n    for (int i = lower; i <= upper; i++) {\n        if (i % 2 == 0) {\n            result.push_back(i);\n        }\n    }\n    return result;\n}\n```"
        ]
    }
}