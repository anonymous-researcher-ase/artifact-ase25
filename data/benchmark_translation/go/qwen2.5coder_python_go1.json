{
    "python": {
        "go": [
            "```go\nfunc HasCloseElements(numbers []float64, threshold float64) bool {\n    for i := 0; i < len(numbers); i++ {\n        for j := i + 1; j < len(numbers); j++ {\n            if abs(numbers[i]-numbers[j]) < threshold {\n                return true\n            }\n        }\n    }\n    return false\n}\n\nfunc abs(x float64) float64 {\n    if x < 0 {\n        return -x\n    }\n    return x\n}\n```",
            "```go\nfunc SeparateParenGroups(parenString string) []string {\n    var groups []string\n    var stk []rune\n    currentGroup := \"\"\n    parens := strings.ReplaceAll(parenString, \" \", \"\")\n    \n    for _, ch := range parens {\n        if ch == '(' {\n            stk = append(stk, ch)\n            currentGroup += string(ch)\n        } else if ch == ')' {\n            stk = stk[:len(stk)-1]\n            currentGroup += string(ch)\n            if len(stk) == 0 {\n                groups = append(groups, currentGroup)\n                currentGroup = \"\"\n            }\n        }\n    }\n    return groups\n}\n```",
            "```go\nfunc TruncateNumber(num float64) float64 {\n    return num - math.Floor(num)\n}\n```",
            "```go\nfunc BelowZero(operations []int) bool {\n    balance := 0\n    for _, op := range operations {\n        balance += op\n        if balance < 0 {\n            return true\n        }\n    }\n    return false\n}\n```",
            "```go\nfunc MeanAbsoluteDeviation(numbers []float64) float64 {\n    mean := 0.0\n    for _, number := range numbers {\n        mean += number\n    }\n    mean /= float64(len(numbers))\n\n    deviation := 0.0\n    for _, number := range numbers {\n        deviation += math.Abs(number - mean)\n    }\n    return deviation / float64(len(numbers))\n}\n```",
            "```go\nfunc Intersperse(numbers []int, delimiter int) []int {\n    result := make([]int, 0, len(numbers) + len(numbers) - 1)\n    for i := range numbers {\n        if i != 0 {\n            result = append(result, delimiter)\n        }\n        result = append(result, numbers[i])\n    }\n    return result\n}\n```",
            "```go\nfunc ParseNestedParens(parenString string) []int {\n    result := []int{}\n    parenGroups := strings.Split(parenString, \" \")\n    for _, group := range parenGroups {\n        maxDepth := 0\n        depth := 0\n        for _, ch := range group {\n            if ch == '(' {\n                depth++\n                if depth > maxDepth {\n                    maxDepth = depth\n                }\n            } else if ch == ')' {\n                depth--\n            }\n        }\n        result = append(result, maxDepth)\n    }\n    return result\n}\n```",
            "```go\nfunc FilterBySubstring(strs []string, substring string) []string {\n    var result []string\n    for _, s := range strs {\n        if strings.Contains(s, substring) {\n            result = append(result, s)\n        }\n    }\n    return result\n}\n```",
            "```go\nfunc SumProduct(numbers []int) []int {\n    n_sum := 0\n    for _, num := range numbers {\n        n_sum += num\n    }\n    \n    n_product := 1\n    for _, num := range numbers {\n        n_product *= num\n    }\n    \n    return []int{n_sum, n_product}\n}\n```",
            "```go\nfunc RollingMax(numbers []int) []int {\n    maxSoFar := math.MinInt64\n    result := make([]int, len(numbers))\n    for i, num := range numbers {\n        if num > maxSoFar {\n            maxSoFar = num\n        }\n        result[i] = maxSoFar\n    }\n    return result\n}\n```",
            "```go\nfunc is_palindrome(s string) bool {\n    for i := 0; i < len(s)/2; i++ {\n        if s[i] != s[len(s)-1-i] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc MakePalindrome(s string) string {\n    if is_palindrome(s) {\n        return s\n    }\n    for i := 0; i < len(s); i++ {\n        if is_palindrome(s[i:]) {\n            suffix := string(s[:i])\n            reversed_suffix := \"\"\n            for j := len(suffix) - 1; j >= 0; j-- {\n                reversed_suffix += string(suffix[j])\n            }\n            return s + reversed_suffix\n        }\n    }\n    return \"\"\n}\n```",
            "```go\nfunc StringXor(a string, b string) string {\n    result := \"\"\n    for i := range a {\n        if a[i] == b[i] {\n            result += \"0\"\n        } else {\n            result += \"1\"\n        }\n    }\n    return result\n}\n```",
            "```go\nfunc Longest(strs []string) *string {\n    if len(strs) == 0 {\n        return nil\n    }\n    longestS := strs[0]\n    for _, s := range strs {\n        if len(s) > len(longestS) {\n            longestS = s\n        }\n    }\n    return &longestS\n}\n```",
            "```go\nfunc GreatestCommonDivisor(a int, b int) int {\n    if b == 0 {\n        return a\n    } else {\n        return GreatestCommonDivisor(b, a % b)\n    }\n}\n```",
            "```go\nfunc AllPrefixes(s string) []string {\n    prefixes := make([]string, len(s))\n    for i := 0; i < len(s); i++ {\n        prefixes[i] = s[:i+1]\n    }\n    return prefixes\n}\n```",
            "```go\nfunc StringSequence(n int) string {\n    var result []string\n    for i := 0; i <= n; i++ {\n        result = append(result, strconv.Itoa(i))\n    }\n    return strings.Join(result, \" \")\n}\n```",
            "```go\nfunc CountDistinctCharacters(s string) int {\n    charSet := make(map[rune]bool)\n    for _, c := range s {\n        charSet[unicode.ToLower(c)] = true\n    }\n    return len(charSet)\n}\n```",
            "```go\nfunc ParseMusic(musicString string) []int {\n    durations := map[string]int{\"o\": 4, \"o|\": 2, \".|\": 1}\n    notes := strings.Split(musicString, \" \")\n    var result []int\n    for _, note := range notes {\n        if duration, ok := durations[note]; ok {\n            result = append(result, duration)\n        }\n    }\n    return result\n}\n```",
            "```go\nfunc HowManyTimes(s string, substring string) int {\n    times := 0\n    for i := 0; i <= len(s)-len(substring); i++ {\n        if s[i : i+len(substring)] == substring {\n            times++\n        }\n    }\n    return times\n}\n```",
            "```go\nfunc SortNumbers(numbers string) string {\n    numDict := map[string]int{\n        \"zero\": 0,\n        \"one\": 1,\n        \"two\": 2,\n        \"three\": 3,\n        \"four\": 4,\n        \"five\": 5,\n        \"six\": 6,\n        \"seven\": 7,\n        \"eight\": 8,\n        \"nine\": 9,\n    }\n    numSlice := strings.Fields(numbers)\n    sort.Slice(numSlice, func(i, j int) bool {\n        return numDict[numSlice[i]] < numDict[numSlice[j]]\n    })\n    return strings.Join(numSlice, \" \")\n}\n```",
            "```go\nfunc FindClosestElements(numbers []float64) []float64 {\n    sortedNumbers := make([]float64, len(numbers))\n    copy(sortedNumbers, numbers)\n    sort.Float64s(sortedNumbers)\n\n    minDiff := math.Inf(1)\n    var closestPair []float64\n\n    for i := 1; i < len(sortedNumbers); i++ {\n        diff := sortedNumbers[i] - sortedNumbers[i-1]\n        if diff < minDiff {\n            minDiff = diff\n            closestPair = []float64{sortedNumbers[i-1], sortedNumbers[i]}\n        }\n    }\n\n    return closestPair\n}\n```",
            "```go\nfunc RescaleToUnit(numbers []float64) []float64 {\n    minNum := numbers[0]\n    maxNum := numbers[0]\n    for _, num := range numbers {\n        if num < minNum {\n            minNum = num\n        }\n        if num > maxNum {\n            maxNum = num\n        }\n    }\n    if minNum == maxNum {\n        result := make([]float64, len(numbers))\n        for i := range result {\n            result[i] = 0.0\n        }\n        return result\n    } else {\n        result := make([]float64, len(numbers))\n        for i, num := range numbers {\n            result[i] = (num - minNum) / (maxNum - minNum)\n        }\n        return result\n    }\n}\n```",
            "```go\nfunc FilterIntegers(values []interface{}) []int {\n    var result []int\n    for _, value := range values {\n        if intValue, ok := value.(int); ok {\n            result = append(result, intValue)\n        }\n    }\n    return result\n}\n```",
            "```go\nfunc StrLength(s string) int {\n    return len(s)\n}\n```",
            "```go\nfunc LargestDivisor(n int) int {\n    for i := 2; i < n; i++ {\n        if n % i == 0 {\n            return n / i\n        }\n    }\n    return 1\n}\n```",
            "```go\nfunc Factorize(n int) []int {\n    factors := []int{}\n    divisor := 2\n    for divisor <= n {\n        if n%divisor == 0 {\n            factors = append(factors, divisor)\n            n /= divisor\n        } else {\n            divisor++\n        }\n    }\n    return factors\n}\n```",
            "```go\nfunc RemoveDuplicates(numbers []int) []int {\n    counts := make(map[int]int)\n    for _, num := range numbers {\n        counts[num]++\n    }\n    var res []int\n    for _, num := range numbers {\n        if counts[num] == 1 {\n            res = append(res, num)\n        }\n    }\n    return res\n}\n```",
            "```go\nfunc FlipCase(s string) string {\n    flipped := []rune{}\n    for _, ch := range s {\n        if !unicode.IsLetter(ch) {\n            flipped = append(flipped, ch)\n        } else if unicode.IsLower(ch) {\n            flipped = append(flipped, unicode.ToUpper(ch))\n        } else if unicode.IsUpper(ch) {\n            flipped = append(flipped, unicode.ToLower(ch))\n        }\n    }\n    return string(flipped)\n}\n```",
            "```go\nfunc Concatenate(strs []string) string {\n    return strings.Join(strs, \"\")\n}\n```",
            "```go\nfunc FilterByPrefix(strs []string, prefixStr string) []string {\n    var result []string\n    for _, s := range strs {\n        if strings.HasPrefix(s, prefixStr) {\n            result = append(result, s)\n        }\n    }\n    return result\n}\n```",
            "```go\nfunc GetPositive(l []int) []int {\n    var result []int\n    for _, num := range l {\n        if num > 0 {\n            result = append(result, num)\n        }\n    }\n    return result\n}\n```",
            "```go\nfunc IsPrime(n int) bool {\n    if n < 2 {\n        return false\n    }\n    for i := 2; i <= int(math.Sqrt(float64(n))); i++ {\n        if n%i == 0 {\n            return false\n        }\n    }\n    return true\n}\n```",
            "```go\nfunc Poly(xs []int, x float64) float64 {\n    res := 0.0\n    for i := 0; i < len(xs); i++ {\n        res += float64(xs[i]) * math.Pow(x, float64(i))\n    }\n    return res\n}\n\nfunc FindZero(xs []int) float64 {\n    x1, x2 := 1.0, -1.0\n    for Poly(xs, x1)*Poly(xs, x2) > 0 {\n        x1 *= 2\n        x2 *= 2\n    }\n    for math.Abs(x1-x2) > 1e-10 {\n        mid := (x1 + x2) / 2\n        if Poly(xs, mid) == 0 {\n            return mid\n        } else if Poly(xs, mid)*Poly(xs, x1) < 0 {\n            x2 = mid\n        } else {\n            x1 = mid\n        }\n    }\n    return (x1 + x2) / 2\n}\n```",
            "```go\nfunc SortThird(l []int) []int {\n    n := len(l)\n    sortedThird := make([]int, (n+2)/3)\n    copy(sortedThird, l[0:n:3])\n    sort.Ints(sortedThird)\n\n    result := make([]int, n)\n    for i := range l {\n        if i%3 == 0 {\n            result[i] = sortedThird[i/3]\n        } else {\n            result[i] = l[i]\n        }\n    }\n    return result\n}\n```",
            "```go\nfunc ListUnique(l []int) []int {\n    uniqueMap := make(map[int]bool)\n    var result []int\n    for _, value := range l {\n        if _, exists := uniqueMap[value]; !exists {\n            uniqueMap[value] = true\n            result = append(result, value)\n        }\n    }\n    sort.Ints(result)\n    return result\n}\n```",
            "```go\nfunc MaxElement(l []int) int {\n    if len(l) == 0 {\n        return 0\n    }\n    max := l[0]\n    for _, v := range l {\n        if v > max {\n            max = v\n        }\n    }\n    return max\n}\n```",
            "```go\nfunc FizzBuzz(n int) int {\n    cnt := 0\n    for i := 0; i < n; i++ {\n        if i%11 == 0 || i%13 == 0 {\n            cnt += countSevens(i)\n        }\n    }\n    return cnt\n}\n\nfunc countSevens(num int) int {\n    cnt := 0\n    for num > 0 {\n        if num % 10 == 7 {\n            cnt++\n        }\n        num /= 10\n    }\n    return cnt\n}\n```",
            "```go\nfunc SortEven(l []int) []int {\n    evenIndices := make([]int, 0)\n    for i := range l {\n        if i % 2 == 0 {\n            evenIndices = append(evenIndices, l[i])\n        }\n    }\n    sort.Ints(evenIndices)\n    \n    sortedList := make([]int, len(l))\n    evenIndex := 0\n    for i := range l {\n        if i % 2 == 0 {\n            sortedList[i] = evenIndices[evenIndex]\n            evenIndex++\n        } else {\n            sortedList[i] = l[i]\n        }\n    }\n    return sortedList\n}\n```",
            "```go\nfunc EncodeCyclic(s string) string {\n    result := []byte{}\n    for i := 0; i < len(s); i += 3 {\n        if i+3 > len(s) {\n            result = append(result, s[i:]...)\n        } else {\n            result, _ = append(result, s[i+1:i+3]...)\n            result = append(result, s[i])\n        }\n    }\n    return string(result)\n}\n\nfunc DecodeCyclic(s string) string {\n    return EncodeCyclic(EncodeCyclic(s))\n}\n```",
            "```go\nfunc PrimeFib(n int) int {\n    if n < 2 {\n        return 1\n    }\n    f := []int{0, 1}\n    cnt := 0\n    for cnt < n {\n        f = append(f, f[len(f)-1]+f[len(f)-2])\n        if isPrime(f[len(f)-1]) {\n            cnt++\n        }\n    }\n    return f[len(f)-1]\n}\n\nfunc isPrime(n int) bool {\n    if n < 2 {\n        return false\n    }\n    for i := 2; i*i <= n; i++ {\n        if n%i == 0 {\n            return false\n        }\n    }\n    return true\n}\n```",
            "```go\nfunc TriplesSumToZero(l []int) bool {\n    for i := 0; i < len(l); i++ {\n        for j := i + 1; j < len(l); j++ {\n            for k := j + 1; k < len(l); k++ {\n                if l[i]+l[j]+l[k] == 0 {\n                    return true\n                }\n            }\n        }\n    }\n    return false\n}\n```",
            "```go\nfunc CarRaceCollision(n int) int {\n    return n * n\n}\n```",
            "```go\nfunc IncrList(l []int) []int {\n    result := make([]int, len(l))\n    for i, v := range l {\n        result[i] = v + 1\n    }\n    return result\n}\n```",
            "```go\nfunc PairsSumToZero(l []int) bool {\n    seen := make(map[int]struct{})\n    for _, num := range l {\n        if _, exists := seen[-num]; exists {\n            return true\n        }\n        seen[num] = struct{}{}\n    }\n    return false\n}\n```",
            "```go\nfunc ChangeBase(x int, bas int) string {\n    if x == 0 {\n        return \"0\"\n    }\n    var digits []string\n    for x > 0 {\n        digits = append(digits, strconv.Itoa(x % bas))\n        x /= bas\n    }\n    for i, j := 0, len(digits)-1; i < j; i, j = i+1, j-1 {\n        digits[i], digits[j] = digits[j], digits[i]\n    }\n    return strings.Join(digits, \"\")\n}\n```",
            "```go\nfunc TriangleArea(a int, h int) float64 {\n    return float64(a * h) / 2.0\n}\n```",
            "```go\nfunc Fib4(n int) int {\n    fib := [4]int{0, 0, 2, 0}\n    for i := 4; i <= n; i++ {\n        sum := 0\n        for _, value := range fib {\n            sum += value\n        }\n        fib[i%4] = sum\n    }\n    return fib[n%4]\n}\n```",
            "```go\nfunc Median(l []float64) float64 {\n    sort.Float64s(l)\n    n := len(l)\n    if n%2 != 0 {\n        return l[n/2]\n    } else {\n        return (l[n/2] + l[n/2-1]) / 2\n    }\n}\n```",
            "```go\nfunc IsPalindrome(txt string) bool {\n    n := len(txt)\n    for i := 0; i < n/2; i++ {\n        if txt[i] != txt[n-1-i] {\n            return false\n        }\n    }\n    return true\n}\n```",
            "```go\nfunc Modp(n int, p int) int {\n    ret := 1\n    for i := 0; i < n; i++ {\n        ret = (ret * 2) % p\n    }\n    return ret\n}\n```",
            "```go\nfunc EncodeShift(s string) string {\n    result := []byte{}\n    for _, ch := range s {\n        shiftedCh := byte(((ch - 97 + 5) % 26) + 97)\n        result = append(result, shiftedCh)\n    }\n    return string(result)\n}\n\nfunc DecodeShift(s string) string {\n    result := []byte{}\n    for _, ch := range s {\n        shiftedCh := byte(((ch - 97 + 21) % 26) + 97)\n        result = append(result, shiftedCh)\n    }\n    return string(result)\n}\n```",
            "```go\nfunc RemoveVowels(txt string) string {\n    vowels := \"aeiouAEIOU\"\n    result := \"\"\n    for _, char := range txt {\n        if !strings.ContainsRune(vowels, char) {\n            result += string(char)\n        }\n    }\n    return result\n}\n```",
            "```go\nfunc BelowThreshold(l []int, t int) bool {\n    for _, x := range l {\n        if x >= t {\n            return false\n        }\n    }\n    return true\n}\n```",
            "```go\nfunc Add(x int, y int) int {\n    return x + y\n}\n```",
            "```go\nfunc SameChars(s0 string, s1 string) bool {\n    return setEqual(stringToSet(s0), stringToSet(s1))\n}\n\nfunc stringToSet(s string) map[rune]bool {\n    m := make(map[rune]bool)\n    for _, c := range s {\n        m[c] = true\n    }\n    return m\n}\n\nfunc setEqual(set1, set2 map[rune]bool) bool {\n    if len(set1) != len(set2) {\n        return false\n    }\n    for key := range set1 {\n        if !set2[key] {\n            return false\n        }\n    }\n    return true\n}\n```",
            "```go\nfunc Fib(n int) int {\n    if n <= 1 {\n        return n\n    } else {\n        return Fib(n - 1) + Fib(n - 2)\n    }\n}\n```",
            "```go\nfunc CorrectBracketing(brackets string) bool {\n    depth := 0\n    for _, b := range brackets {\n        if b == '<' {\n            depth += 1\n        } else if b == '>' {\n            depth -= 1\n        }\n        if depth < 0 {\n            return false\n        }\n    }\n    return depth == 0\n}\n```",
            "```go\nfunc Monotonic(l []int) bool {\n    if len(l) <= 1 {\n        return true\n    }\n\n    increasing := true\n    decreasing := true\n\n    for i := 1; i < len(l); i++ {\n        if l[i] > l[i-1] {\n            decreasing = false\n        }\n        if l[i] < l[i-1] {\n            increasing = false\n        }\n    }\n\n    return increasing || decreasing\n}\n```",
            "```go\nfunc Common(l1 []int, l2 []int) []int {\n    set1 := make(map[int]bool)\n    for _, v := range l1 {\n        set1[v] = true\n    }\n\n    set2 := make(map[int]bool)\n    for _, v := range l2 {\n        set2[v] = true\n    }\n\n    var result []int\n    for k := range set1 {\n        if set2[k] {\n            result = append(result, k)\n        }\n    }\n\n    sort.Ints(result)\n    return result\n}\n```",
            "```go\nfunc LargestPrimeFactor(n int) int {\n    i := 2\n    for i*i <= n {\n        if n%i != 0 {\n            i++\n        } else {\n            n /= i\n        }\n    }\n    return n\n}\n```",
            "```go\nfunc SumToN(n int) int {\n    sum := 0\n    for i := 0; i <= n; i++ {\n        sum += i\n    }\n    return sum\n}\n```",
            "```go\nfunc CorrectBracketing(brackets string) bool {\n    depth := 0\n    for _, b := range brackets {\n        if b == '(' {\n            depth++\n        } else if b == ')' {\n            depth--\n        }\n        if depth < 0 {\n            return false\n        }\n    }\n    return depth == 0\n}\n```",
            "```go\nfunc Derivative(xs []int) []int {\n\tresult := make([]int, len(xs)-1)\n\tfor i := 1; i < len(xs); i++ {\n\t\tresult[i-1] = xs[i] * i\n\t}\n\treturn result\n}\n```",
            "```go\nfunc Fibfib(n int) int {\n\tif n <= 1 {\n\t\treturn 0\n\t}\n\ta, b, c := 0, 0, 1\n\tfor n > 2 {\n\t\ta, b, c = b, c, a+b+c\n\t\tn -= 1\n\t}\n\treturn c\n}\n```",
            "```go\nfunc VowelsCount(s string) int {\n    vowels := \"aeiou\"\n    cnt := 0\n    for i := range s {\n        if strings.ContainsRune(vowels, unicode.ToLower(rune(s[i]))) || (i == len(s)-1 && unicode.ToLower(rune(s[i])) == 'y') {\n            cnt++\n        }\n    }\n    return cnt\n}\n```",
            "```go\nfunc CircularShift(x int, shift int) string {\n    xStr := strconv.Itoa(x)\n    if shift > len(xStr) {\n        return reverseString(xStr)\n    } else {\n        return xStr[len(xStr)-shift:] + xStr[:len(xStr)-shift]\n    }\n}\n\nfunc reverseString(s string) string {\n    runes := []rune(s)\n    for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\n        runes[i], runes[j] = runes[j], runes[i]\n    }\n    return string(runes)\n}\n```",
            "```go\nfunc DigitSum(s string) int {\n    sum := 0\n    for _, c := range s {\n        if c >= 'A' && c <= 'Z' {\n            sum += int(c)\n        }\n    }\n    return sum\n}\n```",
            "```go\nfunc FruitDistribution(s string, n int) int {\n    words := strings.Split(s, \" \")\n    applesIndex := slices.Index(words, \"apples\") - 1\n    orangesIndex := slices.Index(words, \"oranges\") - 1\n    apples, _ := strconv.Atoi(words[applesIndex])\n    oranges, _ := strconv.Atoi(words[orangesIndex])\n    return n - apples - oranges\n}\n```",
            "```go\nfunc Pluck(arr []int) []int {\n    evens := []int{}\n    for _, n := range arr {\n        if n % 2 == 0 {\n            evens = append(evens, n)\n        }\n    }\n    if len(evens) == 0 {\n        return []int{}\n    }\n    min_even := evens[0]\n    for _, n := range evens {\n        if n < min_even {\n            min_even = n\n        }\n    }\n    index := -1\n    for i, n := range arr {\n        if n == min_even {\n            index = i\n            break\n        }\n    }\n    return []int{min_even, index}\n}\n```",
            "```go\nfunc Search(lst []int) int {\n    freqs := make(map[int]int)\n    for _, n := range lst {\n        if _, exists := freqs[n]; exists {\n            freqs[n]++\n        } else {\n            freqs[n] = 1\n        }\n    }\n    goodVals := []int{}\n    for k, v := range freqs {\n        if v >= k {\n            goodVals = append(goodVals, k)\n        }\n    }\n    if len(goodVals) == 0 {\n        return -1\n    }\n    maxVal := goodVals[0]\n    for _, val := range goodVals {\n        if val > maxVal {\n            maxVal = val\n        }\n    }\n    return maxVal\n}\n```",
            "```go\nfunc StrangeSortList(lst []int) []int {\n    sl := make([]int, len(lst))\n    copy(sl, lst)\n    sort.Ints(sl)\n    result := make([]int, 0, len(lst))\n    left, right := 0, len(sl)-1\n    for left <= right {\n        result = append(result, sl[left])\n        left++\n        if left <= right {\n            result = append(result, sl[right])\n            right--\n        }\n    }\n    return result\n}\n```",
            "```go\nfunc TriangleArea(a int, b int, c int) float64 {\n    if a+b > c && a+c > b && b+c > a {\n        s := (float64(a) + float64(b) + float64(c)) / 2.0\n        return math.Sqrt(s * (s - float64(a)) * (s - float64(b)) * (s - float64(c)))\n    } else {\n        return -1.0\n    }\n}\n```",
            "```go\nfunc WillItFly(q []int, w int) bool {\n    if len(q) == 0 {\n        return false\n    }\n    is_palin := true\n    for i := range q {\n        if q[i] != q[len(q)-i-1] {\n            is_palin = false\n            break\n        }\n    }\n    total := 0\n    for _, v := range q {\n        total += v\n    }\n    return is_palin && total <= w\n}\n```",
            "```go\nfunc SmallestChange(arr []int) int {\n    ans := 0\n    for i := 0; i < len(arr)/2; i++ {\n        if arr[i] != arr[len(arr)-i-1] {\n            ans++\n        }\n    }\n    return ans\n}\n```",
            "```go\nfunc TotalMatch(lst1 []string, lst2 []string) []string {\n    cnt1 := 0\n    for _, s := range lst1 {\n        cnt1 += len(s)\n    }\n    cnt2 := 0\n    for _, s := range lst2 {\n        cnt2 += len(s)\n    }\n    if cnt1 <= cnt2 {\n        return lst1\n    } else {\n        return lst2\n    }\n}\n```",
            "```go\nfunc IsPrime(n int) bool {\n    if n < 2 {\n        return false\n    }\n    for i := 2; i <= int(math.Sqrt(float64(n))); i++ {\n        if n%i == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc IsMultiplyPrime(a int) bool {\n    cnt := 0\n    for i := 2; i <= a; i++ {\n        if IsPrime(i) {\n            for a%i == 0 {\n                cnt++\n                a /= i\n            }\n        }\n    }\n    return cnt == 3\n}\n```",
            "```go\nfunc IsSimplePower(x int, n int) bool {\n    if n < 2 {\n        return x == n\n    }\n    tmp := 1\n    for tmp < x {\n        tmp *= n\n    }\n    return tmp == x\n}\n```",
            "```go\nfunc IsCube(a int) bool {\n    a = abs(a)\n    root := int(round(math.Pow(float64(a), 1.0/3.0)))\n    return root*root*root == a\n}\n```",
            "```go\nfunc HexKey(num string) int {\n    count := 0\n    for _, x := range num {\n        if x == '2' || x == '3' || x == '5' || x == '7' || x == 'B' || x == 'D' {\n            count++\n        }\n    }\n    return count\n}\n```",
            "```go\nfunc DecimalToBinary(dec int) string {\n    binary := strconv.FormatInt(int64(dec), 2)\n    return fmt.Sprintf(\"db%sdb\", binary)\n}\n```",
            "```go\nfunc IsHappy(s string) bool {\n    if len(s) < 3 {\n        return false\n    }\n    for i := 0; i < len(s)-2; i++ {\n        if s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2] {\n            return false\n        }\n    }\n    return true\n}\n```",
            "```go\nfunc NumericalLetterGrade(grades []float64) []string {\n    result := []string{}\n    for _, g := range grades {\n        if g == 4.0 {\n            result = append(result, \"A+\")\n        } else if g > 3.7 {\n            result = append(result, \"A\")\n        } else if g > 3.3 {\n            result = append(result, \"A-\")\n        } else if g > 3.0 {\n            result = append(result, \"B+\")\n        } else if g > 2.7 {\n            result = append(result, \"B\")\n        } else if g > 2.3 {\n            result = append(result, \"B-\")\n        } else if g > 2.0 {\n            result = append(result, \"C+\")\n        } else if g > 1.7 {\n            result = append(result, \"C\")\n        } else if g > 1.3 {\n            result = append(result, \"C-\")\n        } else if g > 1.0 {\n            result = append(result, \"D+\")\n        } else if g > 0.7 {\n            result = append(result, \"D\")\n        } else if g > 0.0 {\n            result = append(result, \"D-\")\n        } else {\n            result = append(result, \"E\")\n        }\n    }\n    return result\n}\n```",
            "```go\nfunc PrimeLength(s string) bool {\n    length := len(s)\n    if length < 2 {\n        return false\n    }\n    for i := 2; i <= int(math.Sqrt(float64(length))); i++ {\n        if length%i == 0 {\n            return false\n        }\n    }\n    return true\n}\n```",
            "```go\nfunc StartsOneEnds(n int) int {\n    if n == 1 {\n        return 1\n    }\n    return 2 * 9 * (int(math.Pow(10, float64(n-2))))\n}\n```",
            "```go\nfunc Solve(n int) string {\n    digitsSum := 0\n    for n > 0 {\n        digit := n % 10\n        digitsSum += digit\n        n /= 10\n    }\n    return fmt.Sprintf(\"%b\", digitsSum)\n}\n```",
            "```go\nfunc Add(lst []int) int {\n    sum := 0\n    for i, x := range lst {\n        if i%2 == 1 && x%2 == 0 {\n            sum += x\n        }\n    }\n    return sum\n}\n```",
            "```go\nfunc AntiShuffle(s string) string {\n    words := strings.Fields(s)\n    for i, word := range words {\n        runes := []rune(word)\n        sort.Slice(runes, func(i, j int) bool {\n            return runes[i] < runes[j]\n        })\n        words[i] = string(runes)\n    }\n    return strings.Join(words, \" \")\n}\n```",
            "```go\nfunc GetRow(lst [][]int, x int) [][]int {\n    var coords [][]int\n    for i := range lst {\n        for j := range lst[i] {\n            if lst[i][j] == x {\n                coords = append(coords, []int{i, j})\n            }\n        }\n    }\n    sort.Slice(coords, func(i, j int) bool {\n        if coords[i][0] == coords[j][0] {\n            return coords[i][1] > coords[j][1]\n        }\n        return coords[i][0] < coords[j][0]\n    })\n    return coords\n}\n```",
            "```go\nfunc SortArray(arr []int) []int {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    if (arr[0] + arr[len(arr)-1])%2 == 0 {\n        sort.Sort(sort.Reverse(sort.IntSlice(arr)))\n        return arr\n    } else {\n        sort.Ints(arr)\n        return arr\n    }\n}\n```",
            "```go\nfunc Encrypt(s string) string {\n    result := []byte{}\n    for _, ch := range s {\n        shifted := ch + 4\n        if shifted > 'z' {\n            shifted -= 26\n        }\n        result = append(result, byte(shifted))\n    }\n    return string(result)\n}\n```",
            "```go\nfunc NextSmallest(lst []int) *int {\n    sl := make(map[int]struct{})\n    for _, num := range lst {\n        sl[num] = struct{}{}\n    }\n    \n    if len(sl) < 2 {\n        return nil\n    }\n    \n    first, second := true, false\n    var smallest int\n    for num := range sl {\n        if first || num < smallest {\n            smallest = num\n            first = false\n        }\n    }\n    \n    delete(sl, smallest)\n    nextSmallest := math.MaxInt64\n    for num := range sl {\n        if num < nextSmallest {\n            nextSmallest = num\n        }\n    }\n    \n    return &nextSmallest\n}\n```",
            "```go\nfunc IsBored(s string) int {\n    sentences := strings.FieldsFunc(s, func(r rune) bool {\n        return r == '.' || r == '!' || r == '?' || unicode.IsSpace(r)\n    })\n    count := 0\n    for _, sentence := range sentences {\n        if len(sentence) >= 2 && sentence[:2] == \"I \" {\n            count++\n        }\n    }\n    return count\n}\n```",
            "```go\nfunc AnyInt(x interface{}, y interface{}, z interface{}) bool {\n    xInt, xOk := x.(int)\n    yInt, yOk := y.(int)\n    zInt, zOk := z.(int)\n\n    if xOk && yOk && zOk {\n        return (xInt + yInt == zInt) || (xInt + zInt == yInt) || (yInt + zInt == xInt)\n    }\n    return false\n}\n```",
            "```go\nfunc Encode(message string) string {\n\tvowels := \"aeiouAEIOU\"\n\tresult := []rune{}\n\n\tfor _, ch := range message {\n\t\tif unicode.IsLetter(ch) {\n\t\t\tvar ch1 rune\n\t\t\tif unicode.IsLower(ch) {\n\t\t\t\tch1 = unicode.ToUpper(ch)\n\t\t\t} else {\n\t\t\t\tch1 = unicode.ToLower(ch)\n\t\t\t}\n\t\t\tif strings.ContainsRune(vowels, ch1) {\n\t\t\t\tch1 += 2\n\t\t\t}\n\t\t\tresult = append(result, ch1)\n\t\t} else {\n\t\t\tresult = append(result, ch)\n\t\t}\n\t}\n\n\treturn string(result)\n}\n```",
            "```go\nfunc isPrime(n int) bool {\n    if n < 2 {\n        return false\n    }\n    for i := 2; i <= int(math.Sqrt(float64(n))); i++ {\n        if n%i == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc Skjkasdkd(lst []int) int {\n    var primes []int\n    for _, n := range lst {\n        if isPrime(n) {\n            primes = append(primes, n)\n        }\n    }\n    if len(primes) == 0 {\n        return 0\n    }\n    largest := fmt.Sprintf(\"%d\", max(primes))\n    sum := 0\n    for _, digit := range largest {\n        sum += int(digit - '0')\n    }\n    return sum\n}\n\nfunc max(nums []int) int {\n    if len(nums) == 0 {\n        return 0\n    }\n    maxNum := nums[0]\n    for _, num := range nums {\n        if num > maxNum {\n            maxNum = num\n        }\n    }\n    return maxNum\n}\n```",
            "```go\nfunc CheckDictCase(d map[string]string) bool {\n\tif len(d) == 0 {\n\t\treturn false\n\t}\n\tallLower := true\n\tallUpper := true\n\tfor k := range d {\n\t\tfor _, c := range k {\n\t\t\tif unicode.IsLetter(c) && !unicode.IsLower(c) {\n\t\t\t\tallLower = false\n\t\t\t}\n\t\t\tif unicode.IsLetter(c) && !unicode.IsUpper(c) {\n\t\t\t\tallUpper = false\n\t\t\t}\n\t\t}\n\t\tif !allLower && !allUpper {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn allLower || allUpper\n}\n```",
            "```go\nfunc CountUpTo(n int) []int {\n    primes := []int{}\n    for num := 2; num < n; num++ {\n        isPrime := true\n        for _, p := range primes {\n            if num%p == 0 {\n                isPrime = false\n                break\n            }\n        }\n        if isPrime {\n            primes = append(primes, num)\n        }\n    }\n    return primes\n}\n```",
            "```go\nfunc Multiply(a int, b int) int {\n    return (abs(a) % 10) * (abs(b) % 10)\n}\n\nfunc abs(x int) int {\n    if x < 0 {\n        return -x\n    }\n    return x\n}\n```",
            "```go\nfunc CountUpper(s string) int {\n\tvowels := \"AEIOU\"\n\tcount := 0\n\tfor i, c := range s {\n\t\tif i%2 == 0 && strings.ContainsRune(vowels, c) {\n\t\t\tcount++\n\t\t}\n\t}\n\treturn count\n}\n```",
            "```go\nfunc ClosestInteger(value string) int {\n    num, _ := strconv.ParseFloat(value, 64)\n    if num >= 0 {\n        return int(num + 0.5)\n    } else {\n        return int(num - 0.5)\n    }\n}\n```",
            "```go\nfunc MakeAPile(n int) []int {\n    pile := make([]int, n)\n    for i := 0; i < n; i++ {\n        pile[i] = n + 2*i\n    }\n    return pile\n}\n```",
            "```go\nfunc WordsString(s string) []string {\n    words := strings.FieldsFunc(s, func(c rune) bool {\n        return c == ',' || c == ' '\n    })\n    var result []string\n    for _, w := range words {\n        if len(w) > 0 {\n            result = append(result, w)\n        }\n    }\n    return result\n}\n```",
            "```go\nfunc ChooseNum(x int, y int) int {\n    if x > y {\n        return -1\n    }\n    if y%2 == 0 {\n        return y\n    }\n    if x != y {\n        return y - 1\n    }\n    return -1\n}\n```",
            "```go\nfunc RoundedAvg(n int, m int) *string {\n    if n > m {\n        return nil\n    }\n    r_avg := (m + n) >> 1\n    if (n|m)&1 == 1 {\n        r_avg++\n    }\n    binStr := strconv.FormatInt(int64(r_avg), 2)\n    return &binStr\n}\n```",
            "```go\nfunc allDigitsOdd(s string) bool {\n    for _, digit := range s {\n        if digit%2 == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc UniqueDigits(x []int) []int {\n    var result []int\n    for _, num := range x {\n        if allDigitsOdd(strconv.Itoa(num)) {\n            result = append(result, num)\n        }\n    }\n    sort.Ints(result)\n    return result\n}\n```",
            "```go\nfunc ByLength(arr []int) []string {\n    digitNames := []string{\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"}\n    var sortedArr []int\n    for _, x := range arr {\n        if x >= 1 && x <= 9 {\n            sortedArr = append(sortedArr, x)\n        }\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(sortedArr)))\n    result := make([]string, len(sortedArr))\n    for i, x := range sortedArr {\n        result[i] = digitNames[x-1]\n    }\n    return result\n}\n```",
            "```go\nfunc F(n int) []int {\n    nums := make([]int, n)\n    for i := 1; i <= n; i++ {\n        nums[i-1] = i\n    }\n    \n    result := make([]int, n)\n    for i := 0; i < n; i++ {\n        if (i + 1) % 2 != 0 {\n            sum := 0\n            for j := 0; j <= i; j++ {\n                sum += nums[j]\n            }\n            result[i] = sum\n        } else {\n            product := 1\n            for j := 0; j <= i; j++ {\n                product *= nums[j]\n            }\n            result[i] = product\n        }\n    }\n    \n    return result\n}\n```",
            "```go\nfunc EvenOddPalindrome(n int) []int {\n    cnt := [2]int{0, 0}\n    for i := 1; i <= n; i++ {\n        if isPalindrome(strconv.Itoa(i)) {\n            cnt[i%2]++\n        }\n    }\n    return cnt[:]\n}\n\nfunc isPalindrome(s string) bool {\n    for i := 0; i < len(s)/2; i++ {\n        if s[i] != s[len(s)-1-i] {\n            return false\n        }\n    }\n    return true\n}\n```",
            "```go\nfunc DigitsSum(n int) int {\n    nStr := fmt.Sprintf(\"%d\", n)\n    if n >= 0 {\n        sum := 0\n        for _, d := range nStr {\n            sum += int(d - '0')\n        }\n        return sum\n    } else {\n        firstDigit, _ := strconv.Atoi(string(nStr[0:2]))\n        return firstDigit * 2 + DigitsSum(abs(n))\n    }\n}\n\nfunc CountNums(arr []int) int {\n    count := 0\n    for _, n := range arr {\n        if DigitsSum(n) > 0 {\n            count++\n        }\n    }\n    return count\n}\n```",
            "```go\nfunc MoveOneBall(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    sortedArr := make([]int, len(arr))\n    copy(sortedArr, arr)\n    sort.Ints(sortedArr)\n    for i := 0; i < len(arr); i++ {\n        if reflect.DeepEqual(arr[i:], sortedArr[:len(arr)-i]) && reflect.DeepEqual(arr[:i], sortedArr[len(arr)-i:]) {\n            return true\n        }\n    }\n    return false\n}\n```",
            "```go\nfunc CanExchange(lst1 []int, lst2 []int) string {\n    oddCnt := 0\n    for _, num := range lst1 {\n        if num%2 != 0 {\n            oddCnt++\n        }\n    }\n    evenCnt := 0\n    for _, num := range lst2 {\n        if num%2 == 0 {\n            evenCnt++\n        }\n    }\n    if evenCnt >= oddCnt {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n```",
            "```go\nfunc Histogram(test string) map[string]int {\n    freq := make(map[string]int)\n    words := strings.Fields(test)\n    for _, w := range words {\n        if len(w) > 0 {\n            freq[w]++\n        }\n    }\n    result := make(map[string]int)\n    if len(freq) > 0 {\n        maxFreq := 0\n        for _, v := range freq {\n            if v > maxFreq {\n                maxFreq = v\n            }\n        }\n        for k, v := range freq {\n            if v == maxFreq {\n                result[k] = v\n            }\n        }\n    }\n    return result\n}\n```",
            "```go\nfunc ReverseDelete(s string, c string) []string {\n    s1 := \"\"\n    for _, ch := range s {\n        if !strings.ContainsRune(c, ch) {\n            s1 += string(ch)\n        }\n    }\n    isPalindrome := func(str string) bool {\n        n := len(str)\n        for i := 0; i < n/2; i++ {\n            if str[i] != str[n-1-i] {\n                return false\n            }\n        }\n        return true\n    }\n    result := []string{s1}\n    if isPalindrome(s1) {\n        result = append(result, \"yes\")\n    } else {\n        result = append(result, \"no\")\n    }\n    return result\n}\n```",
            "```go\nfunc OddCount(lst []string) []string {\n    result := []string{}\n    for _, num := range lst {\n        n := 0\n        for _, d := range num {\n            if int(d)%2 == 1 {\n                n++\n            }\n        }\n        rs := \"the number of odd elements in the string i of the input.\"\n        rs = strings.Replace(rs, \"i\", fmt.Sprintf(\"%d\", n), -1)\n        result = append(result, rs)\n    }\n    return result\n}\n```",
            "```go\nfunc MinSubArraySum(nums []int) int {\n    min_sum := 0\n    cur_sum := 0\n    for _, n := range nums {\n        cur_sum = min(cur_sum+n, 0)\n        min_sum = min(cur_sum, min_sum)\n    }\n    if min_sum == 0 {\n        min_sum = min(nums...)\n    }\n    return min_sum\n}\n\nfunc min(a, b int) int {\n    if a < b {\n        return a\n    }\n    return b\n}\n```",
            "```go\nfunc MaxFill(grid [][]int, capacity int) int {\n    sum := 0\n    for _, arr := range grid {\n        rowSum := 0\n        for _, num := range arr {\n            rowSum += num\n        }\n        if rowSum % capacity != 0 {\n            sum += rowSum / capacity + 1\n        } else {\n            sum += rowSum / capacity\n        }\n    }\n    return sum\n}\n```",
            "```go\nfunc countOnes(num int) int {\n    count := 0\n    for num > 0 {\n        count += num & 1\n        num >>= 1\n    }\n    return count\n}\n\nfunc SortArray(arr []int) []int {\n    sort.Slice(arr, func(i, j int) bool {\n        if countOnes(arr[i]) == countOnes(arr[j]) {\n            return arr[i] < arr[j]\n        }\n        return countOnes(arr[i]) < countOnes(arr[j])\n    })\n    return arr\n}\n```",
            "```go\nfunc SelectWords(s string, n int) []string {\n\tConsonants := \"bcdfghjklmnpqrstvwxyz\"\n\twords := strings.Fields(s)\n\tvar result []string\n\tfor _, w := range words {\n\t\tcount := 0\n\t\tfor _, c := range w {\n\t\t\tif strings.ContainsRune(Consonants, unicode.ToLower(c)) {\n\t\t\t\tcount++\n\t\t\t}\n\t\t}\n\t\tif count == n {\n\t\t\tresult = append(result, w)\n\t\t}\n\t}\n\treturn result\n}\n```",
            "```go\nfunc GetClosestVowel(word string) string {\n    vowels := \"aeiouAEIOU\"\n    for i := len(word) - 2; i > 0; i-- {\n        if strings.ContainsRune(vowels, rune(word[i])) && !strings.ContainsRune(vowels, rune(word[i-1])) && !strings.ContainsRune(vowels, rune(word[i+1])) {\n            return string(word[i])\n        }\n    }\n    return \"\"\n}\n```",
            "```go\nfunc check(s string) bool {\n    depth := 0\n    for _, ch := range s {\n        if ch == '(' {\n            depth++\n        } else {\n            depth--\n        }\n        if depth < 0 {\n            return false\n        }\n    }\n    return depth == 0\n}\n\nfunc MatchParens(lst []string) string {\n    s1 := lst[0] + lst[1]\n    s2 := lst[1] + lst[0]\n    if check(s1) || check(s2) {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n```",
            "```go\nfunc Maximum(arr []int, k int) []int {\n    if k == 0 {\n        return []int{}\n    }\n    sort.Ints(arr)\n    return arr[len(arr)-k:]\n}\n```",
            "```go\nfunc Solution(lst []int) int {\n    sum := 0\n    for i, x := range lst {\n        if i%2 == 0 && x%2 != 0 {\n            sum += x\n        }\n    }\n    return sum\n}\n```",
            "```go\nfunc AddElements(arr []int, k int) int {\n    sum := 0\n    for i := 0; i < k && i < len(arr); i++ {\n        if n := arr[i]; n >= -99 && n <= 99 {\n            sum += n\n        }\n    }\n    return sum\n}\n```",
            "```go\nfunc GetOddCollatz(n int) []int {\n    collatz := []int{1}\n    for n != 1 {\n        if n%2 != 0 {\n            collatz = append(collatz, n)\n            n = 3*n + 1\n        } else {\n            n = n / 2\n        }\n    }\n    sort.Ints(collatz)\n    return collatz\n}\n```",
            "```go\nfunc ValidDate(date string) bool {\n    if len(date) != 10 || date[2] != '-' || date[5] != '-' {\n        return false\n    }\n    m := int(date[:2])\n    d := int(date[3:5])\n    if (m == 1 || m == 3 || m == 5 || m == 7 || m == 8 || m == 10 || m == 12) && d >= 1 && d <= 31 {\n        return true\n    }\n    if (m == 4 || m == 6 || m == 9 || m == 11) && d >= 1 && d <= 30 {\n        return true\n    }\n    if m == 2 && d >= 1 && d <= 29 {\n        return true\n    }\n    return false\n}\n```",
            "```go\nfunc SplitWords(txt string) []string {\n    if strings.Contains(txt, \" \") {\n        return strings.Split(txt, \" \")\n    } else if strings.Contains(txt, \",\") {\n        return strings.Split(txt, \",\")\n    } else {\n        count := 0\n        for _, c := range txt {\n            if unicode.IsLower(c) && c%2 == 0 {\n                count++\n            }\n        }\n        return []string{strconv.Itoa(count)}\n    }\n}\n```",
            "```go\nfunc IsSorted(lst []int) bool {\n    if len(lst) == 0 {\n        return true\n    }\n    for i := 1; i < len(lst); i++ {\n        if lst[i-1] > lst[i] {\n            return false\n        }\n    }\n    freq := make(map[int]int)\n    for _, i := range lst {\n        freq[i]++\n    }\n    for _, count := range freq {\n        if count > 2 {\n            return false\n        }\n    }\n    return true\n}\n```",
            "```go\nfunc isPrime(n int) bool {\n    if n < 2 {\n        return false\n    }\n    for i := 2; i <= int(math.Sqrt(float64(n))); i++ {\n        if n%i == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc Intersection(interval1 []int, interval2 []int) string {\n    l := max(interval1[0], interval2[0])\n    r := min(interval1[1], interval2[1])\n    length := r - l\n    if length > 0 && isPrime(length) {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n\nfunc max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n\nfunc min(a, b int) int {\n    if a < b {\n        return a\n    }\n    return b\n}\n```",
            "```go\nfunc ProdSigns(arr []int) *int {\n    if len(arr) == 0 {\n        return nil\n    }\n    for _, n := range arr {\n        if n == 0 {\n            return intPtr(0)\n        }\n    }\n    sign := -1\n    negativeCount := 0\n    for _, n := range arr {\n        if n < 0 {\n            negativeCount++\n        }\n    }\n    if negativeCount%2 == 0 {\n        sign = 1\n    }\n    sum := 0\n    for _, n := range arr {\n        sum += int(math.Abs(float64(n)))\n    }\n    return intPtr(sign * sum)\n}\n\nfunc intPtr(i int) *int {\n    return &i\n}\n```",
            "```go\nfunc MinPath(grid [][]int, k int) []int {\n    n := len(grid)\n    minVal := n * n + 1\n    for i := 0; i < n; i++ {\n        for j := 0; j < n; j++ {\n            if grid[i][j] == 1 {\n                temp := []int{}\n                if i != 0 {\n                    temp = append(temp, grid[i-1][j])\n                }\n                if j != 0 {\n                    temp = append(temp, grid[i][j-1])\n                }\n                if i != n-1 {\n                    temp = append(temp, grid[i+1][j])\n                }\n                if j != n-1 {\n                    temp = append(temp, grid[i][j+1])\n                }\n                for _, val := range temp {\n                    if val < minVal {\n                        minVal = val\n                    }\n                }\n            }\n        }\n    }\n    result := make([]int, k)\n    for i := 0; i < k; i++ {\n        result[i] = 1\n        if i%2 != 0 {\n            result[i] = minVal\n        }\n    }\n    return result\n}\n```",
            "```go\nfunc Tri(n int) []int {\n    if n == 0 {\n        return []int{1}\n    }\n    seq := []int{1, 3}\n    for i := 2; i <= n; i++ {\n        if i%2 == 0 {\n            seq = append(seq, i/2+1)\n        } else {\n            seq = append(seq, seq[i-1]+seq[i-2]+(i+3)/2)\n        }\n    }\n    return seq\n}\n```",
            "```go\nfunc Digits(n int) int {\n    odds := []int{}\n    for _, d := range strconv.Itoa(n) {\n        digit := int(d - '0')\n        if digit%2 == 1 {\n            odds = append(odds, digit)\n        }\n    }\n    result := 1\n    for _, o := range odds {\n        result *= o\n    }\n    if len(odds) > 0 {\n        return result\n    }\n    return 0\n}\n```",
            "```go\nfunc IsNested(s string) bool {\n    openIdx := []int{}\n    closeIdx := []int{}\n\n    for i, ch := range s {\n        if ch == '[' {\n            openIdx = append(openIdx, i)\n        } else if ch == ']' {\n            closeIdx = append(closeIdx, i)\n        }\n    }\n\n    for i, j := 0, len(closeIdx)-1; i < j; i, j = i+1, j-1 {\n        closeIdx[i], closeIdx[j] = closeIdx[j], closeIdx[i]\n    }\n\n    cnt := 0\n    i := 0\n    l := len(closeIdx)\n    for _, idx := range openIdx {\n        if i < l && idx < closeIdx[i] {\n            cnt++\n            i++\n        }\n    }\n    return cnt >= 2\n}\n```",
            "```go\nfunc SumSquares(lst []float64) int {\n    sum := 0\n    for _, n := range lst {\n        sum += int(math.Pow(math.Ceil(n), 2))\n    }\n    return sum\n}\n```",
            "```go\nfunc CheckIfLastCharIsALetter(txt string) bool {\n    if len(txt) == 0 {\n        return false\n    }\n    last := txt[txt.rfind(' ') + 1:]\n    return len(last) == 1 && last[0] >= 'a' && last[0] <= 'z'\n}\n```",
            "```go\nfunc CanArrange(arr []int) int {\n    if len(arr) <= 1 {\n        return -1\n    }\n    idx := -1\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < arr[i-1] {\n            idx = i\n        }\n    }\n    return idx\n}\n```",
            "```go\nfunc LargestSmallestIntegers(lst []int) []*int {\n    var neg []int\n    var pos []int\n\n    for _, i := range lst {\n        if i < 0 {\n            neg = append(neg, i)\n        }\n        if i > 0 {\n            pos = append(pos, i)\n        }\n    }\n\n    var maxNeg *int\n    if len(neg) > 0 {\n        maxNegVal := neg[0]\n        for _, n := range neg {\n            if n > maxNegVal {\n                maxNegVal = n\n            }\n        }\n        maxNeg = &maxNegVal\n    }\n\n    var minPos *int\n    if len(pos) > 0 {\n        minPosVal := pos[0]\n        for _, p := range pos {\n            if p < minPosVal {\n                minPosVal = p\n            }\n        }\n        minPos = &minPosVal\n    }\n\n    return []*int{maxNeg, minPos}\n}\n```",
            "```go\nfunc anyToReal(o interface{}) (float64, error) {\n    switch v := o.(type) {\n    case string:\n        f, err := strconv.ParseFloat(strings.ReplaceAll(v, \",\", \".\"), 64)\n        if err != nil {\n            return 0, fmt.Errorf(\"invalid float representation: %v\", v)\n        }\n        return f, nil\n    case int:\n        return float64(v), nil\n    case float64:\n        return v, nil\n    default:\n        return 0, fmt.Errorf(\"unsupported type: %T\", o)\n    }\n}\n\nfunc CompareOne(a interface{}, b interface{}) *float64 {\n    a1, err := anyToReal(a)\n    if err != nil {\n        panic(err) // or handle it appropriately\n    }\n    b1, err := anyToReal(b)\n    if err != nil {\n        panic(err) // or handle it appropriately\n    }\n    if a1 == b1 {\n        return nil\n    } else if a1 > b1 {\n        f := float64(a1)\n        return &f\n    } else {\n        f := float64(b1)\n        return &f\n    }\n}\n```",
            "```go\nfunc IsEqualToSumEven(n int) bool {\n    return n%2 == 0 && n >= 8\n}\n```",
            "```go\nfunc SpecialFactorial(n int) int {\n    fact := 1\n    result := 1\n    for i := 1; i <= n; i++ {\n        fact *= i\n        result *= fact\n    }\n    return result\n}\n```",
            "```go\nfunc FixSpaces(txt string) string {\n    return regexp.MustCompile(`\\s{3,}`).ReplaceAllString(txt, \"-\").ReplaceAllString(\" \", \"_\")\n}\n```",
            "```go\nfunc FileNameCheck(fileName string) string {\n\tsuf := []string{\"txt\", \"exe\", \"dll\"}\n\tlst := strings.Split(fileName, \".\")\n\tif len(lst) != 2 || !contains(suf, lst[1]) || len(lst[0]) == 0 || !unicode.IsLetter(rune(lst[0][0])) || countDigits(lst[0]) > 3 {\n\t\treturn \"No\"\n\t}\n\treturn \"Yes\"\n}\n\nfunc contains(slice []string, item string) bool {\n\tfor _, v := range slice {\n\t\tif v == item {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc countDigits(s string) int {\n\tcount := 0\n\tfor _, c := range s {\n\t\tif unicode.IsDigit(c) {\n\t\t\tcount++\n\t\t}\n\t}\n\treturn count\n}\n```",
            "```go\nfunc SumSquares(lst []int) int {\n    result := 0\n    for i := 0; i < len(lst); i++ {\n        if i % 3 == 0 {\n            result += lst[i] * lst[i]\n        } else if i % 4 == 0 {\n            result += lst[i] * lst[i] * lst[i]\n        } else {\n            result += lst[i]\n        }\n    }\n    return result\n}\n```",
            "```go\nfunc WordsInSentence(sentence string) string {\n    words := strings.Split(sentence, \" \")\n    var primeWords []string\n    for _, w := range words {\n        if isPrime(len(w)) {\n            primeWords = append(primeWords, w)\n        }\n    }\n    return strings.Join(primeWords, \" \")\n}\n\nfunc isPrime(n int) bool {\n    if n < 2 {\n        return false\n    }\n    for i := 2; i <= int(math.Sqrt(float64(n))); i++ {\n        if n%i == 0 {\n            return false\n        }\n    }\n    return true\n}\n```",
            "```go\nfunc Simplify(x string, n string) bool {\n    xs := strings.Split(x, \"/\")\n    ns := strings.Split(n, \"/\")\n    num, _ := strconv.Atoi(xs[0])\n    den, _ := strconv.Atoi(xs[1])\n    numer, _ := strconv.Atoi(ns[0])\n    denom, _ := strconv.Atoi(ns[1])\n    return (num * numer) % (den * denom) == 0\n}\n```",
            "```go\nfunc digitsSum(n int) int {\n\tnStr := strconv.Itoa(n)\n\tif n >= 0 {\n\t\tsum := 0\n\t\tfor _, d := range nStr {\n\t\t\tsum += int(d - '0')\n\t\t}\n\t\treturn sum\n\t} else {\n\t\tfirstTwo, _ := strconv.Atoi(nStr[:2])\n\t\treturn firstTwo * 2 + digitsSum(abs(n))\n\t}\n}\n\nfunc OrderByPoints(nums []int) []int {\n\tsort.Slice(nums, func(i, j int) bool {\n\t\treturn digitsSum(nums[i]) < digitsSum(nums[j])\n\t})\n\treturn nums\n}\n\nfunc abs(x int) int {\n\tif x < 0 {\n\t\treturn -x\n\t}\n\treturn x\n}\n```",
            "```go\nfunc SpecialFilter(nums []int) int {\n    odds := \"13579\"\n    count := 0\n    for _, n := range nums {\n        if n > 10 && n%2 == 1 && strings.ContainsRune(odds, rune(strconv.Itoa(n)[0])) {\n            count++\n        }\n    }\n    return count\n}\n```",
            "```go\nfunc GetMaxTriples(n int) int {\n    c := [3]int{0, 0, 0}\n    for i := 1; i <= n; i++ {\n        a := i*i - i + 1\n        c[a%3]++\n    }\n    return c[0]*c[1]*c[2] + (c[0]*(c[0]-1)*(c[0]-2) + c[1]*(c[1]-1)*(c[1]-2) + c[2]*(c[2]-1)*(c[2]-2)) / 6\n}\n```",
            "```go\nfunc Bf(planet1 string, planet2 string) []string {\n    names := []string{\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    l := -1\n    r := -1\n    for i, name := range names {\n        if name == planet1 {\n            l = i\n        }\n        if name == planet2 {\n            r = i\n        }\n    }\n    if l == -1 || r == -1 {\n        return []string{}\n    }\n    if l > r {\n        l, r = r, l\n    }\n    if l == r {\n        return []string{}\n    }\n    return names[l+1 : r]\n}\n```",
            "```go\nfunc SortedListSum(lst []string) []string {\n    var result []string\n    for _, s := range lst {\n        if len(s)%2 == 0 {\n            result = append(result, s)\n        }\n    }\n    sort.Slice(result, func(i, j int) bool {\n        if len(result[i]) == len(result[j]) {\n            return result[i] < result[j]\n        }\n        return len(result[i]) < len(result[j])\n    })\n    return result\n}\n```",
            "```go\nfunc XOrY(n int, x int, y int) int {\n    if n < 2 {\n        return y\n    }\n    for i := 2; i <= int(math.Sqrt(float64(n))); i++ {\n        if n%i == 0 {\n            return y\n        }\n    }\n    return x\n}\n```",
            "```go\nfunc DoubleTheDifference(lst []float64) int {\n    sum := 0\n    for _, n := range lst {\n        if n >= 0 && n == float64(int(n)) && int(n)%2 == 1 {\n            sum += int(n * n)\n        }\n    }\n    return sum\n}\n```",
            "```go\nfunc Compare(game []int, guess []int) []int {\n    result := make([]int, len(game))\n    for i := range game {\n        result[i] = abs(game[i] - guess[i])\n    }\n    return result\n}\n\nfunc abs(x int) int {\n    if x < 0 {\n        return -x\n    }\n    return x\n}\n```",
            "```go\nfunc StrongestExtension(className string, extensions []string) string {\n    maxS := -1000\n    maxExt := \"\"\n    for _, ext := range extensions {\n        upper := 0\n        lower := 0\n        for _, c := range ext {\n            if unicode.IsUpper(c) {\n                upper++\n            } else if unicode.IsLower(c) {\n                lower++\n            }\n        }\n        s := upper - lower\n        if s > maxS {\n            maxS = s\n            maxExt = ext\n        }\n    }\n    return className + \".\" + maxExt\n}\n```",
            "```go\nfunc CycpatternCheck(a string, b string) bool {\n    if len(a) < len(b) {\n        return false\n    }\n    for i := 0; i < len(b); i++ {\n        rotated := b[i:] + b[:i]\n        if strings.Contains(a, rotated) {\n            return true\n        }\n    }\n    return false\n}\n```",
            "```go\nfunc EvenOddCount(num int) []int {\n    ds := fmt.Sprintf(\"%d\", abs(num))\n    even := 0\n    for _, d := range ds {\n        if (d - '0') % 2 == 0 {\n            even++\n        }\n    }\n    return []int{even, len(ds) - even}\n}\n\nfunc abs(num int) int {\n    if num < 0 {\n        return -num\n    }\n    return num\n}\n```",
            "```go\nfunc IntToMiniRoman(num int) string {\n    values := []int{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}\n    numerals := []string{\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"}\n    var res []string\n    for i := 0; i < len(values); i++ {\n        for num >= values[i] {\n            res = append(res, numerals[i])\n            num -= values[i]\n        }\n    }\n    return strings.Join(res, \"\")\n}\n```",
            "```go\nfunc RightAngleTriangle(a int, b int, c int) bool {\n    s := []int{a, b, c}\n    sort.Ints(s)\n    return s[0]*s[0]+s[1]*s[1] == s[2]*s[2]\n}\n```",
            "```go\nfunc FindMax(words []string) string {\n    maxCnt := 0\n    maxW := \"\"\n    for _, w := range words {\n        cnt := len(uniqueChars(w))\n        if cnt > maxCnt {\n            maxCnt = cnt\n            maxW = w\n        } else if cnt == maxCnt {\n            if w < maxW {\n                maxW = w\n            }\n        }\n    }\n    return maxW\n}\n\nfunc uniqueChars(s string) map[rune]bool {\n    charSet := make(map[rune]bool)\n    for _, c := range s {\n        charSet[c] = true\n    }\n    return charSet\n}\n```",
            "```go\nfunc Eat(num int, need int, remaining int) []int {\n    if need <= remaining {\n        return []int{num + need, remaining - need}\n    } else {\n        return []int{num + remaining, 0}\n    }\n}\n```",
            "```go\nfunc DoAlgebra(operators []string, operands []int) int {\n    ops := make([]string, len(operators))\n    copy(ops, operators)\n    nums := make([]int, len(operands))\n    copy(nums, operands)\n    i := len(ops) - 1\n    for i >= 0 {\n        if ops[i] == \"**\" {\n            nums[i] = int(math.Pow(float64(nums[i]), float64(nums[i+1])))\n            nums = append(nums[:i+1], nums[i+2:]...)\n            ops = append(ops[:i], ops[i+1:]...)\n        }\n        i--\n    }\n    i = 0\n    for i < len(ops) {\n        if ops[i] == \"*\" {\n            nums[i] *= nums[i+1]\n            nums = append(nums[:i+1], nums[i+2:]...)\n            ops = append(ops[:i], ops[i+1:]...)\n            i--\n        } else if ops[i] == \"//\" {\n            nums[i] /= nums[i+1]\n            nums = append(nums[:i+1], nums[i+2:]...)\n            ops = append(ops[:i], ops[i+1:]...)\n            i--\n        }\n        i++\n    }\n    i = 0\n    for i < len(ops) {\n        if ops[i] == \"+\" {\n            nums[i] += nums[i+1]\n            nums = append(nums[:i+1], nums[i+2:]...)\n            ops = append(ops[:i], ops[i+1:]...)\n            i--\n        } else if ops[i] == \"-\" {\n            nums[i] -= nums[i+1]\n            nums = append(nums[:i+1], nums[i+2:]...)\n            ops = append(ops[:i], ops[i+1:]...)\n            i--\n        }\n        i++\n    }\n    return nums[0]\n}\n```",
            "```go\nfunc Solve(s string) string {\n    if !hasAlpha(s) {\n        return reverseString(s)\n    }\n    var result []rune\n    for _, ch := range s {\n        if !unicode.IsLetter(ch) {\n            result = append(result, ch)\n        } else if unicode.IsUpper(ch) {\n            result = append(result, unicode.ToLower(ch))\n        } else {\n            result = append(result, unicode.ToUpper(ch))\n        }\n    }\n    return string(result)\n}\n\nfunc hasAlpha(s string) bool {\n    for _, ch := range s {\n        if unicode.IsLetter(ch) {\n            return true\n        }\n    }\n    return false\n}\n\nfunc reverseString(s string) string {\n    runes := []rune(s)\n    for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\n        runes[i], runes[j] = runes[j], runes[i]\n    }\n    return string(runes)\n}\n```",
            "```go\nfunc StringToMd5(txt string) *string {\n    if txt == \"\" {\n        return nil\n    }\n    md5Hash := md5.New()\n    txtBytes := []byte(txt)\n    md5Hash.Write(txtBytes)\n    md5Encoded := fmt.Sprintf(\"%x\", md5Hash.Sum(nil))\n    return &md5Encoded\n}\n```",
            "```go\nfunc GenerateIntegers(a int, b int) []int {\n    lower := max(2, min(a, b))\n    upper := min(8, max(a, b))\n    var result []int\n    for i := lower; i <= upper; i++ {\n        if i%2 == 0 {\n            result = append(result, i)\n        }\n    }\n    return result\n}\n\nfunc min(x, y int) int {\n    if x < y {\n        return x\n    }\n    return y\n}\n\nfunc max(x, y int) int {\n    if x > y {\n        return x\n    }\n    return y\n}\n```"
        ]
    }
}