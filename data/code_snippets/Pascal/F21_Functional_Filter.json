[
  {
    "task": "Filter out all even numbers from a list of integers.",
    "code": "```pascal\nprogram FilterEvenNumbers;\n\nuses\n  SysUtils;\n\ntype\n  TIntegerArray = array of Integer;\n\nfunction FilterOddNumbers(const nums: TIntegerArray): TIntegerArray;\nvar\n  i, j: Integer;\nbegin\n  SetLength(Result, 0);\n  j := 0;\n  for i := 0 to High(nums) do\n  begin\n    if nums[i] mod 2 <> 0 then\n    begin\n      SetLength(Result, j + 1);\n      Result[j] := nums[i];\n      Inc(j);\n    end;\n  end;\nend;\n\nvar\n  numbers, oddNumbers: TIntegerArray;\n  i: Integer;\nbegin\n  numbers := TIntegerArray.Create(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n  oddNumbers := FilterOddNumbers(numbers);\n  for i := 0 to High(oddNumbers) do\n    WriteLn(oddNumbers[i]);\nend.\n```"
  },
  {
    "task": "Select all words from a list that start with the letter 'a'.",
    "code": "```pascal\nprogram FilterWords;\n\nuses\n  SysUtils;\n\nfunction StartsWithA(const Word: string): Boolean;\nbegin\n  Result := (Length(Word) > 0) and (Word[1] = 'a');\nend;\n\nprocedure FilterWordsWithA(const Words: array of string; var FilteredWords: array of string);\nvar\n  i, j: Integer;\nbegin\n  j := 0;\n  for i := 0 to High(Words) do\n  begin\n    if StartsWithA(Words[i]) then\n    begin\n      FilteredWords[j] := Words[i];\n      Inc(j);\n    end;\n  end;\n  SetLength(FilteredWords, j);\nend;\n\nvar\n  Words: array of string;\n  FilteredWords: array of string;\nbegin\n  Words := ['apple', 'banana', 'apricot', 'cherry', 'avocado'];\n  SetLength(FilteredWords, Length(Words));\n  FilterWordsWithA(Words, FilteredWords);\n  for var i := 0 to High(FilteredWords) do\n    WriteLn(FilteredWords[i]);\nend.\n```"
  },
  {
    "task": "Find all positive numbers in a collection of integers.",
    "code": "```pascal\nprogram FilterPositiveNumbers;\n\ntype\n  IntArray = array of Integer;\n\nfunction FilterPositive(const numbers: IntArray): IntArray;\nvar\n  i, count: Integer;\nbegin\n  count := 0;\n  SetLength(Result, Length(numbers));\n  for i := 0 to High(numbers) do\n  begin\n    if numbers[i] > 0 then\n    begin\n      Result[count] := numbers[i];\n      Inc(count);\n    end;\n  end;\n  SetLength(Result, count);\nend;\n\nvar\n  numbers, positives: IntArray;\n  i: Integer;\nbegin\n  numbers := IntArray(-3, 0, 2, 7, -1, 5, -8);\n  positives := FilterPositive(numbers);\n  for i := 0 to High(positives) do\n    WriteLn(positives[i]);\nend.\n```"
  },
  {
    "task": "Extract all employees who are older than 30 from an employee directory.",
    "code": "```pascal\nprogram FilterEmployees;\n\ntype\n  Employee = record\n    Name: string;\n    Age: Integer;\n  end;\n\nvar\n  Employees, FilteredEmployees: array of Employee;\n  i, Count: Integer;\n\nfunction FilterByAge(const E: Employee): Boolean;\nbegin\n  Result := E.Age > 30;\nend;\n\nprocedure ApplyFilter;\nvar\n  ResultIndex: Integer;\nbegin\n  ResultIndex := 0;\n  SetLength(FilteredEmployees, Length(Employees));\n  for i := 0 to High(Employees) do\n  begin\n    if FilterByAge(Employees[i]) then\n    begin\n      FilteredEmployees[ResultIndex] := Employees[i];\n      Inc(ResultIndex);\n    end;\n  end;\n  SetLength(FilteredEmployees, ResultIndex);\nend;\n\nbegin\n  // Example initialization for Employees array\n  SetLength(Employees, 5);\n  Employees[0].Name := 'Alice';\n  Employees[0].Age := 28;\n  Employees[1].Name := 'Bob';\n  Employees[1].Age := 35;\n  Employees[2].Name := 'Charlie';\n  Employees[2].Age := 40;\n  Employees[3].Name := 'David';\n  Employees[3].Age := 22;\n  Employees[4].Name := 'Eve';\n  Employees[4].Age := 31;\n\n  ApplyFilter;\n\n  // Output FilteredEmployees for demonstration\n  for i := 0 to High(FilteredEmployees) do\n  begin\n    WriteLn(FilteredEmployees[i].Name, ' ', FilteredEmployees[i].Age);\n  end;\nend.\n```"
  },
  {
    "task": "List all cities with a population greater than one million from a dataset.",
    "code": "```pascal\nprogram FilterCities;\n\ntype\n  City = record\n    name: string;\n    population: integer;\n  end;\n\nvar\n  cities, largeCities: array of City;\n  i, n: integer;\n\nfunction FilterCitiesByPopulation(cities: array of City; minPopulation: integer): array of City;\nvar\n  result: array of City;\n  i, count: integer;\nbegin\n  count := 0;\n  for i := 0 to High(cities) do\n  begin\n    if cities[i].population > minPopulation then\n    begin\n      SetLength(result, count + 1);\n      result[count] := cities[i];\n      count := count + 1;\n    end;\n  end;\n  FilterCitiesByPopulation := result;\nend;\n\nbegin\n  n := 5; \n  SetLength(cities, n);\n  \n  cities[0].name := 'CityA';\n  cities[0].population := 500000;\n  cities[1].name := 'CityB';\n  cities[1].population := 2000000;\n  cities[2].name := 'CityC';\n  cities[2].population := 1500000;\n  cities[3].name := 'CityD';\n  cities[3].population := 300000;\n  cities[4].name := 'CityE';\n  cities[4].population := 1200000;\n  \n  largeCities := FilterCitiesByPopulation(cities, 1000000);\n  \n  for i := 0 to High(largeCities) do\n  begin\n    writeln(largeCities[i].name);\n  end;\nend.\n```"
  },
  {
    "task": "Filter out products that are out of stock from a product list.",
    "code": "```pascal\nprogram FilterProducts;\n\ntype\n  Product = record\n    name: string;\n    inStock: boolean;\n  end;\n\nvar\n  products, filteredProducts: array of Product;\n  i, j: integer;\n\nfunction FilterOutOfStock(products: array of Product): array of Product;\nvar\n  result: array of Product;\n  i, count: integer;\nbegin\n  count := 0;\n  SetLength(result, Length(products));\n  for i := 0 to High(products) do\n  begin\n    if products[i].inStock then\n    begin\n      result[count] := products[i];\n      Inc(count);\n    end;\n  end;\n  SetLength(result, count);\n  FilterOutOfStock := result;\nend;\n\nbegin\n  { Example data }\n  SetLength(products, 3);\n  products[0].name := 'Product A';\n  products[0].inStock := true;\n  products[1].name := 'Product B';\n  products[1].inStock := false;\n  products[2].name := 'Product C';\n  products[2].inStock := true;\n\n  filteredProducts := FilterOutOfStock(products);\n\n  for i := 0 to High(filteredProducts) do\n  begin\n    WriteLn('In stock: ', filteredProducts[i].name);\n  end;\nend.\n```"
  },
  {
    "task": "Select all students who have passed with a grade above 70 from a list of student scores.",
    "code": "```pascal\nprogram FilterStudents;\n\ntype\n  TStudent = record\n    Name: string;\n    Grade: Integer;\n  end;\n\nvar\n  Students, PassedStudents: array of TStudent;\n  i, count: Integer;\n\nfunction FilterPassedStudents(const Students: array of TStudent): array of TStudent;\nvar\n  i, j: Integer;\nbegin\n  SetLength(Result, 0);\n  j := 0;\n  for i := 0 to High(Students) do\n  begin\n    if Students[i].Grade > 70 then\n    begin\n      SetLength(Result, j + 1);\n      Result[j] := Students[i];\n      Inc(j);\n    end;\n  end;\nend;\n\nbegin\n  // Example input\n  SetLength(Students, 4);\n  Students[0].Name := 'Alice'; Students[0].Grade := 85;\n  Students[1].Name := 'Bob'; Students[1].Grade := 65;\n  Students[2].Name := 'Charlie'; Students[2].Grade := 90;\n  Students[3].Name := 'David'; Students[3].Grade := 70;\n\n  // Filtering\n  PassedStudents := FilterPassedStudents(Students);\n\n  // Output result\n  for i := 0 to High(PassedStudents) do\n  begin\n    WriteLn(PassedStudents[i].Name, ': ', PassedStudents[i].Grade);\n  end;\nend.\n```"
  },
  {
    "task": "Identify all strings in an array that contain the substring 'cat'.",
    "code": "```pascal\nprogram FilterStrings;\n\nuses\n  SysUtils;\n\nvar\n  strings: array of string;\n  filteredStrings: array of string;\n  i, count: Integer;\n\nbegin\n  strings := ['concatenate', 'category', 'dog', 'catalog', 'bat', 'cat'];\n  count := 0;\n  SetLength(filteredStrings, Length(strings));\n\n  for i := 0 to High(strings) do\n  begin\n    if Pos('cat', strings[i]) > 0 then\n    begin\n      filteredStrings[count] := strings[i];\n      Inc(count);\n    end;\n  end;\n\n  SetLength(filteredStrings, count);\n\n  for i := 0 to High(filteredStrings) do\n  begin\n    WriteLn(filteredStrings[i]);\n  end;\nend.\n```"
  },
  {
    "task": "Extract all transactions above $1000 from a financial record.",
    "code": "```pascal\nprogram FilterTransactions;\n\ntype\n  Transaction = record\n    amount: Real;\n    description: String;\n  end;\n\nvar\n  transactions, filteredTransactions: array of Transaction;\n  i, count: Integer;\n\nfunction FilterAbove1000(const trans: array of Transaction): array of Transaction;\nvar\n  result: array of Transaction;\n  i, j: Integer;\nbegin\n  SetLength(result, 0);\n  j := 0;\n  for i := 0 to High(trans) do\n  begin\n    if trans[i].amount > 1000 then\n    begin\n      SetLength(result, j + 1);\n      result[j] := trans[i];\n      Inc(j);\n    end;\n  end;\n  FilterAbove1000 := result;\nend;\n\nbegin\n  { Example data setup }\n  SetLength(transactions, 3);\n  transactions[0].amount := 500;\n  transactions[0].description := 'Groceries';\n  transactions[1].amount := 1500;\n  transactions[1].description := 'Salary';\n  transactions[2].amount := 2500;\n  transactions[2].description := 'Bonus';\n\n  filteredTransactions := FilterAbove1000(transactions);\n\n  { Output filtered transactions }\n  for i := 0 to High(filteredTransactions) do\n  begin\n    Writeln('Amount: ', filteredTransactions[i].amount:0:2, ' Description: ', filteredTransactions[i].description);\n  end;\nend.\n```"
  },
  {
    "task": "Filter out all non-prime numbers from a list of numbers.",
    "code": "```pascal\nprogram FilterPrimes;\n\nuses\n  SysUtils;\n\nfunction IsPrime(n: Integer): Boolean;\nvar\n  i: Integer;\nbegin\n  if n <= 1 then\n    Exit(False);\n  for i := 2 to Trunc(Sqrt(n)) do\n    if n mod i = 0 then\n      Exit(False);\n  Exit(True);\nend;\n\nfunction FilterPrimes(numbers: array of Integer): TArray<Integer>;\nvar\n  n: Integer;\n  primes: TArray<Integer>;\nbegin\n  SetLength(primes, 0);\n  for n in numbers do\n  begin\n    if IsPrime(n) then\n    begin\n      SetLength(primes, Length(primes) + 1);\n      primes[High(primes)] := n;\n    end;\n  end;\n  Result := primes;\nend;\n\nvar\n  numbers: array of Integer;\n  primes: TArray<Integer>;\n  i: Integer;\nbegin\n  numbers := [10, 15, 3, 7, 11, 19, 21, 23];\n  primes := FilterPrimes(numbers);\n  for i := 0 to High(primes) do\n    WriteLn(primes[i]);\nend.\n```"
  },
  {
    "task": "Select all books with more than 300 pages from a library catalog.",
    "code": "```pascal\nprogram FilterBooks;\n\ntype\n  TBook = record\n    Title: string;\n    Pages: Integer;\n  end;\n\nvar\n  LibraryCatalog: array of TBook;\n  FilteredBooks: array of TBook;\n  i, Count: Integer;\n\nfunction FilterBooksByPages(Books: array of TBook; MinPages: Integer): array of TBook;\nvar\n  ResultList: array of TBook;\n  i, ResultCount: Integer;\nbegin\n  SetLength(ResultList, Length(Books));\n  ResultCount := 0;\n  for i := 0 to High(Books) do\n  begin\n    if Books[i].Pages > MinPages then\n    begin\n      ResultList[ResultCount] := Books[i];\n      Inc(ResultCount);\n    end;\n  end;\n  SetLength(ResultList, ResultCount);\n  Result := ResultList;\nend;\n\nbegin\n  { Example data }\n  SetLength(LibraryCatalog, 3);\n  LibraryCatalog[0].Title := 'Book One';\n  LibraryCatalog[0].Pages := 250;\n  LibraryCatalog[1].Title := 'Book Two';\n  LibraryCatalog[1].Pages := 320;\n  LibraryCatalog[2].Title := 'Book Three';\n  LibraryCatalog[2].Pages := 450;\n\n  FilteredBooks := FilterBooksByPages(LibraryCatalog, 300);\n\n  { Output filtered books }\n  Count := Length(FilteredBooks);\n  for i := 0 to Count - 1 do\n  begin\n    writeln('Title: ', FilteredBooks[i].Title, ', Pages: ', FilteredBooks[i].Pages);\n  end;\nend.\n```"
  },
  {
    "task": "Identify all users who have logged in within the past week from a user database.",
    "code": "```pascal\nprogram FilterRecentLogins;\n\nuses\n  SysUtils, DateUtils;\n\ntype\n  TUser = record\n    Name: string;\n    LastLogin: TDateTime;\n  end;\n\nvar\n  Users: array of TUser;\n  RecentUsers: array of TUser;\n  i: Integer;\n  OneWeekAgo: TDateTime;\n\nfunction FilterUsers(Users: array of TUser; Predicate: TFunc<TUser, Boolean>): array of TUser;\nvar\n  i, Count: Integer;\nbegin\n  SetLength(Result, Length(Users));\n  Count := 0;\n  for i := 0 to High(Users) do\n    if Predicate(Users[i]) then\n    begin\n      Result[Count] := Users[i];\n      Inc(Count);\n    end;\n  SetLength(Result, Count);\nend;\n\nfunction LoggedInPastWeek(User: TUser): Boolean;\nbegin\n  LoggedInPastWeek := User.LastLogin >= OneWeekAgo;\nend;\n\nbegin\n  // Example data - replace with actual user data\n  SetLength(Users, 3);\n  Users[0].Name := 'Alice';\n  Users[0].LastLogin := Now - 2; // 2 days ago\n  Users[1].Name := 'Bob';\n  Users[1].LastLogin := Now - 10; // 10 days ago\n  Users[2].Name := 'Charlie';\n  Users[2].LastLogin := Now - 5; // 5 days ago\n\n  OneWeekAgo := IncDay(Now, -7);\n\n  RecentUsers := FilterUsers(Users, @LoggedInPastWeek);\n\n  for i := 0 to High(RecentUsers) do\n    WriteLn('Recent User: ', RecentUsers[i].Name);\nend.\n```"
  },
  {
    "task": "Extract all URLs that contain 'https' from a list of web addresses.",
    "code": "```pascal\nprogram ExtractHttpsUrls;\n\ntype\n  TStringArray = array of string;\n\nfunction FilterHttpsUrls(urls: TStringArray): TStringArray;\nvar\n  filteredUrls: TStringArray;\n  i, count: Integer;\nbegin\n  SetLength(filteredUrls, 0);\n  count := 0;\n  for i := 0 to High(urls) do\n  begin\n    if Pos('https', urls[i]) = 1 then\n    begin\n      SetLength(filteredUrls, count + 1);\n      filteredUrls[count] := urls[i];\n      Inc(count);\n    end;\n  end;\n  Result := filteredUrls;\nend;\n\nvar\n  urls, httpsUrls: TStringArray;\n  i: Integer;\nbegin\n  urls := TStringArray.Create(\n    'http://example.com',\n    'https://secure-site.com',\n    'https://another-secure.com',\n    'http://insecure.com'\n  );\n  \n  httpsUrls := FilterHttpsUrls(urls);\n\n  for i := 0 to High(httpsUrls) do\n  begin\n    WriteLn(httpsUrls[i]);\n  end;\nend.\n```"
  },
  {
    "task": "Find all movies released after the year 2000 from a movie database.",
    "code": "```pascal\nprogram FilterMovies;\n\nuses\n  SysUtils;\n\ntype\n  TMovie = record\n    Title: string;\n    Year: Integer;\n  end;\n\nvar\n  Movies: array of TMovie;\n  FilteredMovies: array of TMovie;\n  I: Integer;\n\nfunction FilterMoviesAfter2000(MovieList: array of TMovie): array of TMovie;\nvar\n  Filtered: array of TMovie;\n  Index: Integer;\nbegin\n  SetLength(Filtered, 0);\n  Index := 0;\n  for I := Low(MovieList) to High(MovieList) do\n  begin\n    if MovieList[I].Year > 2000 then\n    begin\n      SetLength(Filtered, Index + 1);\n      Filtered[Index] := MovieList[I];\n      Inc(Index);\n    end;\n  end;\n  Result := Filtered;\nend;\n\nbegin\n  // Example data\n  SetLength(Movies, 5);\n  Movies[0].Title := 'The Matrix';\n  Movies[0].Year := 1999;\n  Movies[1].Title := 'Inception';\n  Movies[1].Year := 2010;\n  Movies[2].Title := 'Gladiator';\n  Movies[2].Year := 2000;\n  Movies[3].Title := 'The Dark Knight';\n  Movies[3].Year := 2008;\n  Movies[4].Title := 'Interstellar';\n  Movies[4].Year := 2014;\n\n  FilteredMovies := FilterMoviesAfter2000(Movies);\n\n  for I := Low(FilteredMovies) to High(FilteredMovies) do\n    Writeln(FilteredMovies[I].Title);\nend.\n```"
  },
  {
    "task": "Select all tasks with a priority level of 'high' from a task management system.",
    "code": "```pascal\nprogram HighPriorityTasks;\n\ntype\n  Task = record\n    name: string;\n    priority: string;\n  end;\n\nvar\n  tasks: array of Task;\n  highPriorityTasks: array of Task;\n  i, count: integer;\n\nfunction IsHighPriority(task: Task): boolean;\nbegin\n  result := task.priority = 'high';\nend;\n\nbegin\n  // Sample data\n  SetLength(tasks, 5);\n  tasks[0].name := 'Task 1'; tasks[0].priority := 'low';\n  tasks[1].name := 'Task 2'; tasks[1].priority := 'high';\n  tasks[2].name := 'Task 3'; tasks[2].priority := 'medium';\n  tasks[3].name := 'Task 4'; tasks[3].priority := 'high';\n  tasks[4].name := 'Task 5'; tasks[4].priority := 'low';\n\n  count := 0;\n  for i := 0 to High(tasks) do\n    if IsHighPriority(tasks[i]) then\n    begin\n      SetLength(highPriorityTasks, count + 1);\n      highPriorityTasks[count] := tasks[i];\n      Inc(count);\n    end;\n\n  // Output high priority tasks (for demonstration purposes)\n  for i := 0 to High(highPriorityTasks) do\n    writeln('High Priority Task: ', highPriorityTasks[i].name);\nend.\n```"
  },
  {
    "task": "Filter out all words longer than five characters from a text document.",
    "code": "```pascal\nprogram FilterWords;\n\nuses\n  SysUtils;\n\nfunction IsShortWord(const Word: string): Boolean;\nbegin\n  Result := Length(Word) <= 5;\nend;\n\nprocedure FilterWords(const InputFileName, OutputFileName: string);\nvar\n  InputFile, OutputFile: TextFile;\n  Line, Word: string;\n  Words: TStringArray;\n  i: Integer;\nbegin\n  AssignFile(InputFile, InputFileName);\n  AssignFile(OutputFile, OutputFileName);\n  Reset(InputFile);\n  Rewrite(OutputFile);\n\n  while not Eof(InputFile) do\n  begin\n    ReadLn(InputFile, Line);\n    Words := Line.Split([' ']);\n\n    for i := Low(Words) to High(Words) do\n    begin\n      Word := Words[i];\n      if IsShortWord(Word) then\n        Write(OutputFile, Word, ' ');\n    end;\n    WriteLn(OutputFile);\n  end;\n\n  CloseFile(InputFile);\n  CloseFile(OutputFile);\nend;\n\nbegin\n  FilterWords('input.txt', 'output.txt');\nend.\n```"
  },
  {
    "task": "Extract all odd numbers from a sequence of integers.",
    "code": "```pascal\nprogram FilterOddNumbers;\n\nuses\n  SysUtils;\n\nfunction IsOdd(x: Integer): Boolean;\nbegin\n  Result := x mod 2 <> 0;\nend;\n\nfunction FilterOddNumbers(const numbers: array of Integer): TArray<Integer>;\nvar\n  i, count: Integer;\nbegin\n  count := 0;\n  SetLength(Result, Length(numbers));\n  for i := Low(numbers) to High(numbers) do\n  begin\n    if IsOdd(numbers[i]) then\n    begin\n      Result[count] := numbers[i];\n      Inc(count);\n    end;\n  end;\n  SetLength(Result, count);\nend;\n\nvar\n  numbers, oddNumbers: TArray<Integer>;\n  i: Integer;\nbegin\n  numbers := TArray<Integer>.Create(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n  oddNumbers := FilterOddNumbers(numbers);\n  \n  for i := Low(oddNumbers) to High(oddNumbers) do\n    WriteLn(oddNumbers[i]);\nend.\n```"
  },
  {
    "task": "Select all files larger than 10MB from a list of files.",
    "code": "```pascal\nprogram FilterFiles;\n\ntype\n  TFile = record\n    Name: string;\n    SizeInMB: Real;\n  end;\n\nvar\n  Files: array of TFile;\n  LargeFiles: array of TFile;\n  File: TFile;\n  i, Count: Integer;\n\nfunction IsLargeFile(const F: TFile): Boolean;\nbegin\n  Result := F.SizeInMB > 10.0;\nend;\n\nbegin\n  // Example initialization of file list\n  SetLength(Files, 3);\n  Files[0].Name := 'File1.txt';\n  Files[0].SizeInMB := 5.0;\n  Files[1].Name := 'File2.txt';\n  Files[1].SizeInMB := 12.0;\n  Files[2].Name := 'File3.txt';\n  Files[2].SizeInMB := 15.0;\n\n  // Filter files larger than 10MB\n  SetLength(LargeFiles, Length(Files));\n  Count := 0;\n  for i := 0 to High(Files) do\n  begin\n    if IsLargeFile(Files[i]) then\n    begin\n      LargeFiles[Count] := Files[i];\n      Inc(Count);\n    end;\n  end;\n  SetLength(LargeFiles, Count);\n\n  // Output the filtered files\n  for i := 0 to High(LargeFiles) do\n  begin\n    WriteLn('Large File: ', LargeFiles[i].Name, ' Size: ', LargeFiles[i].SizeInMB:0:2, ' MB');\n  end;\nend.\n```"
  },
  {
    "task": "Identify all events occurring on weekends from an event schedule.",
    "code": "```pascal\nprogram WeekendEventsFilter;\n\nuses\n  SysUtils;\n\ntype\n  TEvent = record\n    Name: string;\n    Date: TDateTime;\n  end;\n\nvar\n  Events: array of TEvent;\n  WeekendEvents: array of TEvent;\n  i, j: Integer;\n  DayOfWeek: Integer;\n\nfunction IsWeekend(ADate: TDateTime): Boolean;\nbegin\n  DayOfWeek := DayOfWeek(ADate);\n  Result := (DayOfWeek = 1) or (DayOfWeek = 7);\nend;\n\nbegin\n  // Example event data\n  SetLength(Events, 5);\n  Events[0].Name := 'Event 1';\n  Events[0].Date := EncodeDate(2023, 10, 14); // Saturday\n  Events[1].Name := 'Event 2';\n  Events[1].Date := EncodeDate(2023, 10, 15); // Sunday\n  Events[2].Name := 'Event 3';\n  Events[2].Date := EncodeDate(2023, 10, 16); // Monday\n  Events[3].Name := 'Event 4';\n  Events[3].Date := EncodeDate(2023, 10, 17); // Tuesday\n  Events[4].Name := 'Event 5';\n  Events[4].Date := EncodeDate(2023, 10, 20); // Friday\n\n  // Filtering events occurring on weekends\n  SetLength(WeekendEvents, 0);\n  for i := 0 to High(Events) do\n  begin\n    if IsWeekend(Events[i].Date) then\n    begin\n      j := Length(WeekendEvents);\n      SetLength(WeekendEvents, j + 1);\n      WeekendEvents[j] := Events[i];\n    end;\n  end;\n\n  // Output weekend events\n  for i := 0 to High(WeekendEvents) do\n  begin\n    WriteLn('Event: ', WeekendEvents[i].Name, ', Date: ', DateTimeToStr(WeekendEvents[i].Date));\n  end;\nend.\n```"
  },
  {
    "task": "Find all emails from a specific domain in an email list.",
    "code": "```pascal\nprogram FilterEmails;\n\nuses\n  SysUtils;\n\ntype\n  TStringArray = array of string;\n\nfunction FilterEmailsByDomain(emails: TStringArray; domain: string): TStringArray;\nvar\n  i, count: Integer;\n  filteredEmails: TStringArray;\nbegin\n  count := 0;\n  SetLength(filteredEmails, Length(emails));\n\n  for i := 0 to High(emails) do\n  begin\n    if AnsiEndsStr('@' + domain, emails[i]) then\n    begin\n      filteredEmails[count] := emails[i];\n      Inc(count);\n    end;\n  end;\n\n  SetLength(filteredEmails, count);\n  Result := filteredEmails;\nend;\n\nvar\n  emails, result: TStringArray;\n  i: Integer;\nbegin\n  emails := TStringArray.Create('user1@example.com', 'user2@test.com', 'user3@example.com', 'user4@domain.com');\n  result := FilterEmailsByDomain(emails, 'example.com');\n\n  for i := 0 to High(result) do\n  begin\n    WriteLn(result[i]);\n  end;\nend.\n```"
  },
  {
    "task": "Filter out all people not living in a specific city from a contact list.",
    "code": "```pascal\nprogram FilterContacts;\n\ntype\n  Person = record\n    Name: string;\n    City: string;\n  end;\n\nvar\n  Contacts: array of Person;\n  FilteredContacts: array of Person;\n  i, count: Integer;\n  TargetCity: string;\n\nfunction FilterByCity(const Contacts: array of Person; const City: string): array of Person;\nvar\n  i, j, length: Integer;\nbegin\n  length := 0;\n  SetLength(Result, length);\n  for i := 0 to High(Contacts) do\n  begin\n    if Contacts[i].City = City then\n    begin\n      Inc(length);\n      SetLength(Result, length);\n      Result[length - 1] := Contacts[i];\n    end;\n  end;\nend;\n\nbegin\n  { Example initialization of contacts }\n  SetLength(Contacts, 3);\n  Contacts[0].Name := 'Alice';\n  Contacts[0].City := 'New York';\n  Contacts[1].Name := 'Bob';\n  Contacts[1].City := 'Los Angeles';\n  Contacts[2].Name := 'Charlie';\n  Contacts[2].City := 'New York';\n\n  TargetCity := 'New York';\n  FilteredContacts := FilterByCity(Contacts, TargetCity);\n\n  for i := 0 to High(FilteredContacts) do\n  begin\n    writeln('Name: ', FilteredContacts[i].Name, ', City: ', FilteredContacts[i].City);\n  end;\nend.\n```"
  },
  {
    "task": "Select all rectangles with an area greater than 50 from a list of rectangles.",
    "code": "```pascal\nprogram FilterRectangles;\n\ntype\n  Rectangle = record\n    width, height: Integer;\n  end;\n\nvar\n  rectangles, filteredRectangles: array of Rectangle;\n  i: Integer;\n\nfunction AreaGreaterThan50(rect: Rectangle): Boolean;\nbegin\n  Result := (rect.width * rect.height) > 50;\nend;\n\nbegin\n  { Example initialization of rectangles }\n  SetLength(rectangles, 3);\n  rectangles[0].width := 5;\n  rectangles[0].height := 11;\n  rectangles[1].width := 3;\n  rectangles[1].height := 15;\n  rectangles[2].width := 7;\n  rectangles[2].height := 5;\n\n  { Filter rectangles with area greater than 50 }\n  for i := 0 to High(rectangles) do\n  begin\n    if AreaGreaterThan50(rectangles[i]) then\n    begin\n      SetLength(filteredRectangles, Length(filteredRectangles) + 1);\n      filteredRectangles[High(filteredRectangles)] := rectangles[i];\n    end;\n  end;\n\n  { Output filtered rectangles (for demonstration purposes) }\n  for i := 0 to High(filteredRectangles) do\n  begin\n    WriteLn('Rectangle ', i + 1, ': Width = ', filteredRectangles[i].width, \n            ', Height = ', filteredRectangles[i].height);\n  end;\nend.\n```"
  },
  {
    "task": "Extract all elements that are not null from a collection.",
    "code": "```pascal\nprogram FilterNonNull;\n\ntype\n  TIntArray = array of Integer;\n\nfunction FunctionalFilter(arr: TIntArray): TIntArray;\nvar\n  i, count: Integer;\nbegin\n  count := 0;\n  SetLength(Result, Length(arr));\n  for i := 0 to High(arr) do\n  begin\n    if arr[i] <> 0 then\n    begin\n      Result[count] := arr[i];\n      Inc(count);\n    end;\n  end;\n  SetLength(Result, count);\nend;\n\nvar\n  input, output: TIntArray;\n  i: Integer;\nbegin\n  input := TIntArray.Create(1, 0, 3, 0, 5, 6);\n  output := FunctionalFilter(input);\n  for i := 0 to High(output) do\n    WriteLn(output[i]);\nend.\n```"
  },
  {
    "task": "Identify all registered voters over the age of 18 from a voter registration list.",
    "code": "```pascal\nprogram VoterFilter;\n\ntype\n  Voter = record\n    Name: string;\n    Age: Integer;\n  end;\n\nvar\n  Voters: array of Voter;\n  RegisteredVoters: array of Voter;\n  i, Count: Integer;\n\nfunction FilterVoters(Voters: array of Voter; AgeLimit: Integer): array of Voter;\nvar\n  i, j: Integer;\nbegin\n  SetLength(Result, Length(Voters));\n  j := 0;\n  for i := 0 to High(Voters) do\n  begin\n    if Voters[i].Age > AgeLimit then\n    begin\n      Result[j] := Voters[i];\n      Inc(j);\n    end;\n  end;\n  SetLength(Result, j);\nend;\n\nbegin\n  { Initialize the voter list for demonstration purposes }\n  SetLength(Voters, 5);\n  Voters[0] := Voter(Name: 'Alice', Age: 30);\n  Voters[1] := Voter(Name: 'Bob', Age: 17);\n  Voters[2] := Voter(Name: 'Charlie', Age: 22);\n  Voters[3] := Voter(Name: 'David', Age: 18);\n  Voters[4] := Voter(Name: 'Eve', Age: 25);\n\n  { Filter registered voters over the age of 18 }\n  RegisteredVoters := FilterVoters(Voters, 18);\n\n  { Output the registered voters }\n  Count := Length(RegisteredVoters);\n  for i := 0 to Count - 1 do\n  begin\n    WriteLn('Registered Voter: ', RegisteredVoters[i].Name, ', Age: ', RegisteredVoters[i].Age);\n  end;\nend.\n```"
  },
  {
    "task": "Select all cars manufactured after 2015 from a vehicle registry.",
    "code": "```pascal\nprogram FilterCars;\n\ntype\n  Car = record\n    Model: string;\n    Year: Integer;\n  end;\n\nvar\n  Cars: array[1..5] of Car;\n  FilteredCars: array of Car;\n  i, Count: Integer;\n\nfunction Filter(const Cars: array of Car; FilterFunc: function(C: Car): Boolean): array of Car;\nvar\n  ResultArray: array of Car;\n  i, j: Integer;\nbegin\n  SetLength(ResultArray, 0);\n  j := 0;\n  for i := Low(Cars) to High(Cars) do\n    if FilterFunc(Cars[i]) then\n    begin\n      SetLength(ResultArray, j + 1);\n      ResultArray[j] := Cars[i];\n      Inc(j);\n    end;\n  Filter := ResultArray;\nend;\n\nfunction IsManufacturedAfter2015(C: Car): Boolean;\nbegin\n  IsManufacturedAfter2015 := C.Year > 2015;\nend;\n\nbegin\n  Cars[1].Model := 'Model A';\n  Cars[1].Year := 2014;\n  Cars[2].Model := 'Model B';\n  Cars[2].Year := 2016;\n  Cars[3].Model := 'Model C';\n  Cars[3].Year := 2017;\n  Cars[4].Model := 'Model D';\n  Cars[4].Year := 2015;\n  Cars[5].Model := 'Model E';\n  Cars[5].Year := 2019;\n\n  FilteredCars := Filter(Cars, @IsManufacturedAfter2015);\n\n  for i := Low(FilteredCars) to High(FilteredCars) do\n    WriteLn('Car: ', FilteredCars[i].Model, ', Year: ', FilteredCars[i].Year);\nend.\n```"
  },
  {
    "task": "Filter out all negative numbers from a dataset of integers.",
    "code": "```pascal\nprogram FilterNegativeNumbers;\n\ntype\n  TIntArray = array of Integer;\n\nfunction FilterNegative(const Data: TIntArray): TIntArray;\nvar\n  i, j, Count: Integer;\nbegin\n  Count := 0;\n  SetLength(Result, Length(Data));\n  for i := 0 to High(Data) do\n  begin\n    if Data[i] >= 0 then\n    begin\n      Result[Count] := Data[i];\n      Inc(Count);\n    end;\n  end;\n  SetLength(Result, Count);\nend;\n\nvar\n  Dataset, FilteredData: TIntArray;\n  i: Integer;\nbegin\n  Dataset := TIntArray.Create(4, -1, 8, -3, 0, 9);\n  FilteredData := FilterNegative(Dataset);\n\n  for i := 0 to High(FilteredData) do\n    Write(FilteredData[i], ' ');\nend.\n```"
  },
  {
    "task": "Extract all characters from a string that are uppercase.",
    "code": "```pascal\nprogram ExtractUppercase;\n\nuses SysUtils;\n\nfunction IsUpperCase(ch: Char): Boolean;\nbegin\n  Result := ch in ['A'..'Z'];\nend;\n\nfunction FilterUppercase(const input: string): string;\nvar\n  i: Integer;\n  resultStr: string;\nbegin\n  resultStr := '';\n  for i := 1 to Length(input) do\n  begin\n    if IsUpperCase(input[i]) then\n      resultStr := resultStr + input[i];\n  end;\n  Result := resultStr;\nend;\n\nvar\n  inputStr, outputStr: string;\nbegin\n  inputStr := 'Hello World!';\n  outputStr := FilterUppercase(inputStr);\n  WriteLn(outputStr);\nend.\n```"
  },
  {
    "task": "Identify all projects with a deadline within the next month from a project database.",
    "code": "```pascal\nprogram FilterProjects;\n\nuses\n  SysUtils, DateUtils;\n\ntype\n  TProject = record\n    Name: string;\n    Deadline: TDateTime;\n  end;\n\nvar\n  Projects: array of TProject;\n  FilteredProjects: array of TProject;\n  Today, OneMonthLater: TDateTime;\n  i, Count: Integer;\n\nbegin\n  // Initialize today's date and the date one month later\n  Today := Now;\n  OneMonthLater := IncMonth(Today);\n\n  // Example projects for demonstration purposes\n  SetLength(Projects, 5);\n  Projects[0].Name := 'Project Alpha';\n  Projects[0].Deadline := Today + 10;\n  Projects[1].Name := 'Project Beta';\n  Projects[1].Deadline := Today + 40;\n  Projects[2].Name := 'Project Gamma';\n  Projects[2].Deadline := Today + 20;\n  Projects[3].Name := 'Project Delta';\n  Projects[3].Deadline := Today + 5;\n  Projects[4].Name := 'Project Epsilon';\n  Projects[4].Deadline := Today + 35;\n\n  // Filter projects with deadlines within the next month\n  Count := 0;\n  for i := 0 to High(Projects) do\n  begin\n    if (Projects[i].Deadline >= Today) and (Projects[i].Deadline <= OneMonthLater) then\n    begin\n      SetLength(FilteredProjects, Count + 1);\n      FilteredProjects[Count] := Projects[i];\n      Inc(Count);\n    end;\n  end;\n\n  // Output filtered projects\n  for i := 0 to High(FilteredProjects) do\n  begin\n    WriteLn('Project: ', FilteredProjects[i].Name, ', Deadline: ', DateToStr(FilteredProjects[i].Deadline));\n  end;\nend.\n```"
  },
  {
    "task": "Select all athletes with a score higher than 90 from a competition result list.",
    "code": "```pascal\nprogram FilterAthletes;\n\ntype\n  TAthlete = record\n    Name: string;\n    Score: Integer;\n  end;\n\nvar\n  Athletes: array of TAthlete;\n  HighScorers: array of TAthlete;\n  I: Integer;\n\nfunction FilterAthletes(const List: array of TAthlete; MinScore: Integer): array of TAthlete;\nvar\n  ResultList: array of TAthlete;\n  Count, J: Integer;\nbegin\n  Count := 0;\n  SetLength(ResultList, Length(List));\n  for J := 0 to High(List) do\n  begin\n    if List[J].Score > MinScore then\n    begin\n      ResultList[Count] := List[J];\n      Inc(Count);\n    end;\n  end;\n  SetLength(ResultList, Count);\n  FilterAthletes := ResultList;\nend;\n\nbegin\n  SetLength(Athletes, 5);\n  Athletes[0].Name := 'Athlete1'; Athletes[0].Score := 85;\n  Athletes[1].Name := 'Athlete2'; Athletes[1].Score := 92;\n  Athletes[2].Name := 'Athlete3'; Athletes[2].Score := 88;\n  Athletes[3].Name := 'Athlete4'; Athletes[3].Score := 95;\n  Athletes[4].Name := 'Athlete5'; Athletes[4].Score := 91;\n\n  HighScorers := FilterAthletes(Athletes, 90);\n\n  for I := 0 to High(HighScorers) do\n    WriteLn(HighScorers[I].Name, ': ', HighScorers[I].Score);\nend.\n```"
  },
  {
    "task": "Filter out all strings that do not contain vowels from a list of words.",
    "code": "```pascal\nprogram FilterVowels;\n\nuses\n  SysUtils;\n\ntype\n  TStringArray = array of string;\n\nfunction ContainsVowel(const s: string): Boolean;\nvar\n  i: Integer;\n  vowels: set of Char;\nbegin\n  vowels := ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'];\n  for i := 1 to Length(s) do\n    if s[i] in vowels then\n      Exit(True);\n  Result := False;\nend;\n\nfunction FilterWordsWithVowels(const words: TStringArray): TStringArray;\nvar\n  i, count: Integer;\nbegin\n  count := 0;\n  SetLength(Result, Length(words));\n  for i := 0 to High(words) do\n    if ContainsVowel(words[i]) then\n    begin\n      Result[count] := words[i];\n      Inc(count);\n    end;\n  SetLength(Result, count);\nend;\n\nvar\n  words, filteredWords: TStringArray;\n  i: Integer;\nbegin\n  words := TStringArray.Create('sky', 'apple', 'try', 'orange', 'fly');\n  filteredWords := FilterWordsWithVowels(words);\n  for i := 0 to High(filteredWords) do\n    WriteLn(filteredWords[i]);\nend.\n```"
  },
  {
    "task": "Extract all dates that fall on a weekday from a calendar.",
    "code": "```pascal\nprogram FilterWeekdayDates;\n\nuses\n  SysUtils, DateUtils;\n\ntype\n  TDateArray = array of TDateTime;\n\nfunction IsWeekday(date: TDateTime): Boolean;\nbegin\n  Result := not (DayOfTheWeek(date) in [DaySaturday, DaySunday]);\nend;\n\nfunction FilterWeekdayDates(dates: TDateArray): TDateArray;\nvar\n  i, count: Integer;\nbegin\n  count := 0;\n  SetLength(Result, Length(dates));\n  for i := 0 to High(dates) do\n  begin\n    if IsWeekday(dates[i]) then\n    begin\n      Result[count] := dates[i];\n      Inc(count);\n    end;\n  end;\n  SetLength(Result, count);\nend;\n\nvar\n  allDates, weekdayDates: TDateArray;\n  i: Integer;\nbegin\n  allDates := [EncodeDate(2023, 10, 1), EncodeDate(2023, 10, 2), EncodeDate(2023, 10, 3),\n               EncodeDate(2023, 10, 4), EncodeDate(2023, 10, 5), EncodeDate(2023, 10, 6),\n               EncodeDate(2023, 10, 7)];\n  weekdayDates := FilterWeekdayDates(allDates);\n  for i := 0 to High(weekdayDates) do\n    Writeln(FormatDateTime('yyyy-mm-dd', weekdayDates[i]));\nend.\n```"
  },
  {
    "task": "Find all software versions that are stable releases from a list of software versions.",
    "code": "```pascal\nprogram FilterStableReleases;\n\ntype\n  TStringArray = array of string;\n\nfunction IsStable(version: string): Boolean;\nbegin\n  IsStable := Pos('stable', version) > 0;\nend;\n\nfunction FilterStableReleases(versions: TStringArray): TStringArray;\nvar\n  i, count: Integer;\nbegin\n  count := 0;\n  SetLength(Result, Length(versions));\n  for i := 0 to High(versions) do\n  begin\n    if IsStable(versions[i]) then\n    begin\n      Result[count] := versions[i];\n      Inc(count);\n    end;\n  end;\n  SetLength(Result, count);\nend;\n\nvar\n  versions, stableVersions: TStringArray;\n  i: Integer;\nbegin\n  versions := TStringArray.Create('1.0-stable', '1.1-beta', '2.0-stable', '3.0-alpha', '4.0-stable');\n  stableVersions := FilterStableReleases(versions);\n  for i := 0 to High(stableVersions) do\n    WriteLn(stableVersions[i]);\nend.\n```"
  },
  {
    "task": "Select all temperatures above freezing from a weather report.",
    "code": "```pascal\nprogram FilterTemperatures;\n\ntype\n  TTemperatureArray = array of Integer;\n\nfunction FilterAboveFreezing(temps: TTemperatureArray): TTemperatureArray;\nvar\n  i, count: Integer;\nbegin\n  count := 0;\n  SetLength(Result, Length(temps));\n  for i := 0 to High(temps) do\n    if temps[i] > 0 then\n    begin\n      Result[count] := temps[i];\n      Inc(count);\n    end;\n  SetLength(Result, count);\nend;\n\nvar\n  temperatures, aboveFreezing: TTemperatureArray;\n  i: Integer;\nbegin\n  temperatures := TTemperatureArray.Create(-5, 3, -2, 7, 0, 12, -1);\n  aboveFreezing := FilterAboveFreezing(temperatures);\n  for i := 0 to High(aboveFreezing) do\n    WriteLn(aboveFreezing[i]);\nend.\n```"
  },
  {
    "task": "Identify all countries with a GDP per capita above $40,000 from a country dataset.",
    "code": "```pascal\nprogram FilterCountriesByGDP;\n\ntype\n  Country = record\n    Name: string;\n    GDPPerCapita: real;\n  end;\n\nvar\n  countries: array of Country;\n  filteredCountries: array of Country;\n  i, count: integer;\n\nfunction FilterByGDP(countries: array of Country; threshold: real): array of Country;\nvar\n  i, k: integer;\nbegin\n  SetLength(Result, 0);\n  k := 0;\n  for i := 0 to High(countries) do\n  begin\n    if countries[i].GDPPerCapita > threshold then\n    begin\n      SetLength(Result, k + 1);\n      Result[k] := countries[i];\n      Inc(k);\n    end;\n  end;\nend;\n\nbegin\n  { Example dataset }\n  SetLength(countries, 3);\n  countries[0].Name := 'CountryA';\n  countries[0].GDPPerCapita := 45000;\n  countries[1].Name := 'CountryB';\n  countries[1].GDPPerCapita := 35000;\n  countries[2].Name := 'CountryC';\n  countries[2].GDPPerCapita := 50000;\n\n  filteredCountries := FilterByGDP(countries, 40000);\n\n  { Output filtered countries }\n  for i := 0 to High(filteredCountries) do\n  begin\n    writeln(filteredCountries[i].Name);\n  end;\nend.\n```"
  },
  {
    "task": "Filter out all names shorter than four letters from a roster.",
    "code": "```pascal\nprogram FilterNames;\n\ntype\n  TStringArray = array of string;\n\nfunction FilterNamesByLength(names: TStringArray; minLength: Integer): TStringArray;\nvar\n  i, index: Integer;\nbegin\n  SetLength(Result, 0);\n  index := 0;\n  for i := 0 to High(names) do\n  begin\n    if Length(names[i]) >= minLength then\n    begin\n      SetLength(Result, index + 1);\n      Result[index] := names[i];\n      Inc(index);\n    end;\n  end;\nend;\n\nvar\n  roster, filteredRoster: TStringArray;\n  i: Integer;\nbegin\n  roster := TStringArray.Create('Tom', 'Lisa', 'John', 'Anna', 'Bob');\n  filteredRoster := FilterNamesByLength(roster, 4);\n  for i := 0 to High(filteredRoster) do\n  begin\n    WriteLn(filteredRoster[i]);\n  end;\nend.\n```"
  },
  {
    "task": "Extract all numbers divisible by five from a sequence.",
    "code": "```pascal\nprogram FilterDivisibleByFive;\n\ntype\n  TIntArray = array of Integer;\n\nfunction Filter(const Arr: TIntArray; Predicate: function(X: Integer): Boolean): TIntArray;\nvar\n  ResultArr: TIntArray;\n  I, Count: Integer;\nbegin\n  Count := 0;\n  SetLength(ResultArr, Length(Arr));\n  for I := 0 to High(Arr) do\n  begin\n    if Predicate(Arr[I]) then\n    begin\n      ResultArr[Count] := Arr[I];\n      Inc(Count);\n    end;\n  end;\n  SetLength(ResultArr, Count);\n  Result := ResultArr;\nend;\n\nfunction IsDivisibleByFive(X: Integer): Boolean;\nbegin\n  Result := X mod 5 = 0;\nend;\n\nvar\n  Numbers, NumbersDivisibleByFive: TIntArray;\n  I: Integer;\nbegin\n  Numbers := TIntArray.Create(1, 2, 5, 10, 15, 3, 8, 20, 25);\n  NumbersDivisibleByFive := Filter(Numbers, @IsDivisibleByFive);\n\n  for I := 0 to High(NumbersDivisibleByFive) do\n    WriteLn(NumbersDivisibleByFive[I]);\nend.\n```"
  },
  {
    "task": "Select all movies with a rating above 4 stars from a film review site.",
    "code": "```pascal\nprogram FilterMovies;\n\ntype\n  TMovie = record\n    Title: string;\n    Rating: real;\n  end;\n\nvar\n  Movies, FilteredMovies: array of TMovie;\n  i, Count: Integer;\n\nfunction FilterMoviesByRating(const MovieList: array of TMovie; MinRating: real): array of TMovie;\nvar\n  i, j: Integer;\nbegin\n  SetLength(Result, Length(MovieList));\n  j := 0;\n  for i := 0 to High(MovieList) do\n  begin\n    if MovieList[i].Rating > MinRating then\n    begin\n      Result[j] := MovieList[i];\n      Inc(j);\n    end;\n  end;\n  SetLength(Result, j);\nend;\n\nbegin\n  { Example data setup }\n  SetLength(Movies, 5);\n  Movies[0].Title := 'Movie A'; Movies[0].Rating := 4.5;\n  Movies[1].Title := 'Movie B'; Movies[1].Rating := 3.9;\n  Movies[2].Title := 'Movie C'; Movies[2].Rating := 4.2;\n  Movies[3].Title := 'Movie D'; Movies[3].Rating := 4.0;\n  Movies[4].Title := 'Movie E'; Movies[4].Rating := 5.0;\n\n  { Filter movies with rating above 4 }\n  FilteredMovies := FilterMoviesByRating(Movies, 4.0);\n\n  { Display filtered movies }\n  Count := Length(FilteredMovies);\n  for i := 0 to Count - 1 do\n    WriteLn(FilteredMovies[i].Title, ' with rating ', FilteredMovies[i].Rating:0:1);\nend.\n```"
  },
  {
    "task": "Find all jobs with a salary above $50,000 from a job listing.",
    "code": "```pascal\nprogram FilterJobs;\n\ntype\n  Job = record\n    title: string;\n    salary: integer;\n  end;\n\nvar\n  jobs: array[1..5] of Job;\n  highSalaryJobs: array of Job;\n  i, count: integer;\n\nbegin\n  jobs[1].title := 'Developer'; jobs[1].salary := 60000;\n  jobs[2].title := 'Designer'; jobs[2].salary := 45000;\n  jobs[3].title := 'Manager'; jobs[3].salary := 75000;\n  jobs[4].title := 'Analyst'; jobs[4].salary := 50000;\n  jobs[5].title := 'Tester'; jobs[5].salary := 55000;\n\n  count := 0;\n  for i := 1 to Length(jobs) do\n    if jobs[i].salary > 50000 then\n    begin\n      SetLength(highSalaryJobs, count + 1);\n      highSalaryJobs[count] := jobs[i];\n      Inc(count);\n    end;\n\n  for i := 0 to High(highSalaryJobs) do\n    WriteLn('Job Title: ', highSalaryJobs[i].title, ', Salary: ', highSalaryJobs[i].salary);\nend.\n```"
  },
  {
    "task": "Filter out all entries without an email address from a contact form submission list.",
    "code": "```pascal\nprogram FilterEmailContacts;\n\ntype\n  Contact = record\n    name: string;\n    email: string;\n  end;\n\nvar\n  contacts, filteredContacts: array of Contact;\n  i, filteredIndex: Integer;\n\nfunction HasEmail(contact: Contact): Boolean;\nbegin\n  Result := contact.email <> '';\nend;\n\nbegin\n  SetLength(contacts, 5);\n  contacts[0].name := 'John Doe'; contacts[0].email := 'john@example.com';\n  contacts[1].name := 'Jane Smith'; contacts[1].email := '';\n  contacts[2].name := 'Alice Brown'; contacts[2].email := 'alice@example.com';\n  contacts[3].name := 'Bob White'; contacts[3].email := '';\n  contacts[4].name := 'Charlie Black'; contacts[4].email := 'charlie@example.com';\n\n  SetLength(filteredContacts, 0);\n  filteredIndex := 0;\n  for i := 0 to High(contacts) do\n  begin\n    if HasEmail(contacts[i]) then\n    begin\n      SetLength(filteredContacts, filteredIndex + 1);\n      filteredContacts[filteredIndex] := contacts[i];\n      Inc(filteredIndex);\n    end;\n  end;\n\n  for i := 0 to High(filteredContacts) do\n  begin\n    WriteLn('Name: ', filteredContacts[i].name, ', Email: ', filteredContacts[i].email);\n  end;\nend.\n```"
  },
  {
    "task": "Identify all animals weighing more than 50kg from a zoo inventory.",
    "code": "```pascal\nprogram FilterAnimals;\n\ntype\n  Animal = record\n    Name: string;\n    Weight: Real;\n  end;\n\nvar\n  zoo: array of Animal;\n  filteredAnimals: array of Animal;\n  i, count: Integer;\n\nbegin\n  zoo := [\n    (Name: 'Elephant'; Weight: 5000),\n    (Name: 'Monkey'; Weight: 30),\n    (Name: 'Giraffe'; Weight: 900),\n    (Name: 'Panda'; Weight: 70),\n    (Name: 'Kangaroo'; Weight: 80)\n  ];\n\n  SetLength(filteredAnimals, Length(zoo));\n  count := 0;\n\n  for i := 0 to High(zoo) do\n  begin\n    if zoo[i].Weight > 50 then\n    begin\n      filteredAnimals[count] := zoo[i];\n      Inc(count);\n    end;\n  end;\n\n  SetLength(filteredAnimals, count);\n\n  for i := 0 to High(filteredAnimals) do\n  begin\n    WriteLn('Animal: ', filteredAnimals[i].Name, ', Weight: ', filteredAnimals[i].Weight:0:2, ' kg');\n  end;\nend.\n```"
  },
  {
    "task": "Select all songs with a duration longer than three minutes from a playlist.",
    "code": "```pascal\nprogram FilterSongs;\n\ntype\n  Song = record\n    title: string;\n    duration: integer; { Duration in seconds }\n  end;\n\nvar\n  playlist, filteredPlaylist: array of Song;\n  i, count: integer;\n\nfunction FilterSongsByDuration(songs: array of Song; minDuration: integer): array of Song;\nvar\n  i, j: integer;\nbegin\n  SetLength(Result, Length(songs));\n  j := 0;\n  for i := 0 to High(songs) do\n  begin\n    if songs[i].duration > minDuration then\n    begin\n      Result[j] := songs[i];\n      Inc(j);\n    end;\n  end;\n  SetLength(Result, j);\nend;\n\nbegin\n  { Assume playlist is already populated with songs }\n\n  filteredPlaylist := FilterSongsByDuration(playlist, 180);\n\n  { Output filteredPlaylist or use it further }\nend.\n```"
  },
  {
    "task": "Extract all accounts with a balance below zero from a bank statement.",
    "code": "```pascal\nprogram FilterNegativeBalances;\n\ntype\n  Account = record\n    id: Integer;\n    balance: Real;\n  end;\n\nvar\n  accounts, negativeAccounts: array of Account;\n  i, n: Integer;\n\nfunction FilterNegative(accs: array of Account): array of Account;\nvar\n  i, count: Integer;\nbegin\n  SetLength(Result, 0);\n  count := 0;\n  for i := 0 to High(accs) do\n  begin\n    if accs[i].balance < 0 then\n    begin\n      SetLength(Result, count + 1);\n      Result[count] := accs[i];\n      Inc(count);\n    end;\n  end;\nend;\n\nbegin\n  { Example input: initializing accounts }\n  n := 3;\n  SetLength(accounts, n);\n  accounts[0].id := 1; accounts[0].balance := -100.50;\n  accounts[1].id := 2; accounts[1].balance := 200.00;\n  accounts[2].id := 3; accounts[2].balance := -50.00;\n\n  { Applying the filter }\n  negativeAccounts := FilterNegative(accounts);\n\n  { Output the negative accounts }\n  for i := 0 to High(negativeAccounts) do\n    WriteLn('Account ID: ', negativeAccounts[i].id, ' Balance: ', negativeAccounts[i].balance:0:2);\nend.\n```"
  },
  {
    "task": "Filter out all non-alphabetic characters from a string of text.",
    "code": "```pascal\nprogram FilterAlphabetic;\n\nuses\n  SysUtils;\n\nfunction IsAlphabetic(c: Char): Boolean;\nbegin\n  Result := (c in ['A'..'Z']) or (c in ['a'..'z']);\nend;\n\nfunction FilterAlphabetic(const s: string): string;\nvar\n  i: Integer;\n  resultString: string;\nbegin\n  resultString := '';\n  for i := 1 to Length(s) do\n  begin\n    if IsAlphabetic(s[i]) then\n      resultString := resultString + s[i];\n  end;\n  Result := resultString;\nend;\n\nvar\n  input: string;\n  filtered: string;\nbegin\n  Write('Enter a string: ');\n  ReadLn(input);\n  filtered := FilterAlphabetic(input);\n  WriteLn('Filtered string: ', filtered);\nend.\n```"
  },
  {
    "task": "Select all participants who scored above average in a competition.",
    "code": "```pascal\nprogram FilterAboveAverage;\n\ntype\n  TParticipant = record\n    name: string;\n    score: integer;\n  end;\n\nvar\n  participants: array of TParticipant;\n  selected: array of TParticipant;\n  totalScore, i, count: integer;\n  average: real;\n\nbegin\n  // Example data\n  participants := [\n    (name: 'Alice'; score: 85),\n    (name: 'Bob'; score: 90),\n    (name: 'Charlie'; score: 75),\n    (name: 'Diana'; score: 95)\n  ];\n\n  // Calculate the average score\n  totalScore := 0;\n  for i := 0 to High(participants) do\n    totalScore := totalScore + participants[i].score;\n  average := totalScore / Length(participants);\n\n  // Filter participants who scored above average\n  SetLength(selected, 0);\n  for i := 0 to High(participants) do\n  begin\n    if participants[i].score > average then\n    begin\n      count := Length(selected);\n      SetLength(selected, count + 1);\n      selected[count] := participants[i];\n    end;\n  end;\n\n  // Output selected participants\n  for i := 0 to High(selected) do\n    writeln(selected[i].name, ' scored ', selected[i].score, ' which is above average');\nend.\n```"
  },
  {
    "task": "Find all houses priced under $300,000 from a real estate database.",
    "code": "```pascal\nprogram FilterHouses;\n\ntype\n  THouse = record\n    Price: Integer;\n  end;\n\nvar\n  Houses: array[1..5] of THouse;\n  AffordableHouses: array of THouse;\n  i, count: Integer;\n\nbegin\n  // Example data\n  Houses[1].Price := 250000;\n  Houses[2].Price := 320000;\n  Houses[3].Price := 275000;\n  Houses[4].Price := 300000;\n  Houses[5].Price := 150000;\n\n  count := 0;\n  SetLength(AffordableHouses, Length(Houses));\n\n  for i := 1 to Length(Houses) do\n  begin\n    if Houses[i].Price < 300000 then\n    begin\n      AffordableHouses[count] := Houses[i];\n      Inc(count);\n    end;\n  end;\n\n  SetLength(AffordableHouses, count);\n\n  for i := 0 to High(AffordableHouses) do\n    WriteLn('House found with price: ', AffordableHouses[i].Price);\nend.\n```"
  },
  {
    "task": "Identify all plants that bloom in spring from a botanical catalog.",
    "code": "```pascal\nprogram SpringBloomingPlants;\n\ntype\n  TPlant = record\n    Name: string;\n    BloomsInSpring: Boolean;\n  end;\n\nvar\n  BotanicalCatalog: array of TPlant;\n  SpringBloomingPlants: array of TPlant;\n  i, Count: Integer;\n\nfunction FilterSpringBloomingPlants(Catalog: array of TPlant): array of TPlant;\nvar\n  i, j: Integer;\nbegin\n  j := 0;\n  SetLength(Result, Length(Catalog));\n  for i := 0 to High(Catalog) do\n  begin\n    if Catalog[i].BloomsInSpring then\n    begin\n      Result[j] := Catalog[i];\n      Inc(j);\n    end;\n  end;\n  SetLength(Result, j);\nend;\n\nbegin\n  SetLength(BotanicalCatalog, 5);\n  BotanicalCatalog[0].Name := 'Rose';\n  BotanicalCatalog[0].BloomsInSpring := True;\n  BotanicalCatalog[1].Name := 'Tulip';\n  BotanicalCatalog[1].BloomsInSpring := True;\n  BotanicalCatalog[2].Name := 'Sunflower';\n  BotanicalCatalog[2].BloomsInSpring := False;\n  BotanicalCatalog[3].Name := 'Daisy';\n  BotanicalCatalog[3].BloomsInSpring := True;\n  BotanicalCatalog[4].Name := 'Lily';\n  BotanicalCatalog[4].BloomsInSpring := False;\n\n  SpringBloomingPlants := FilterSpringBloomingPlants(BotanicalCatalog);\n\n  Count := Length(SpringBloomingPlants);\n  WriteLn('Plants that bloom in spring: ');\n  for i := 0 to Count - 1 do\n    WriteLn(SpringBloomingPlants[i].Name);\nend.\n```"
  },
  {
    "task": "Extract all passwords that are longer than eight characters from a user database.",
    "code": "```pascal\nprogram FilterPasswords;\n\nuses SysUtils;\n\ntype\n  User = record\n    username: string;\n    password: string;\n  end;\n\nvar\n  users: array[1..5] of User;\n  i: Integer;\n  longPasswords: array of string;\n\nfunction FilterLongPasswords(const userList: array of User): array of string;\nvar\n  i, count: Integer;\nbegin\n  count := 0;\n  for i := Low(userList) to High(userList) do\n    if Length(userList[i].password) > 8 then\n    begin\n      SetLength(Result, count + 1);\n      Result[count] := userList[i].password;\n      Inc(count);\n    end;\nend;\n\nbegin\n  users[1].username := 'user1'; users[1].password := 'short';\n  users[2].username := 'user2'; users[2].password := 'averylongpassword';\n  users[3].username := 'user3'; users[3].password := '123456789';\n  users[4].username := 'user4'; users[4].password := 'longerthanten';\n  users[5].username := 'user5'; users[5].password := 'pass';\n\n  longPasswords := FilterLongPasswords(users);\n\n  for i := Low(longPasswords) to High(longPasswords) do\n    WriteLn(longPasswords[i]);\nend.\n```"
  },
  {
    "task": "Filter out all projects that are not yet started from a project management tool.",
    "code": "```pascal\nprogram FilterProjects;\n\ntype\n  TProject = record\n    Name: string;\n    Status: string;\n  end;\n\nvar\n  Projects, StartedProjects: array of TProject;\n  i, Count: Integer;\n\nfunction FilterStartedProjects(const Projects: array of TProject): array of TProject;\nvar\n  i, j, Total: Integer;\nbegin\n  Total := 0;\n  SetLength(Result, Length(Projects));\n  for i := 0 to High(Projects) do\n  begin\n    if Projects[i].Status = 'Started' then\n    begin\n      Result[Total] := Projects[i];\n      Inc(Total);\n    end;\n  end;\n  SetLength(Result, Total);\nend;\n\nbegin\n  { Example initialization of Projects array }\n  SetLength(Projects, 3);\n  Projects[0].Name := 'Project A';\n  Projects[0].Status := 'Not Started';\n  Projects[1].Name := 'Project B';\n  Projects[1].Status := 'Started';\n  Projects[2].Name := 'Project C';\n  Projects[2].Status := 'Completed';\n\n  { Filter projects that are started }\n  StartedProjects := FilterStartedProjects(Projects);\n\n  { Output result }\n  Count := Length(StartedProjects);\n  for i := 0 to Count - 1 do\n    WriteLn('Started Project: ', StartedProjects[i].Name);\nend.\n```"
  },
  {
    "task": "Select all days with temperatures exceeding 25\u00b0C from a climate report.",
    "code": "```pascal\nprogram FilterDays;\n\ntype\n    DayRecord = record\n        day: string;\n        temperature: real;\n    end;\n\nvar\n    ClimateReport: array of DayRecord;\n    FilteredDays: array of DayRecord;\n    i, count: Integer;\n\nbegin\n    { Example data }\n    SetLength(ClimateReport, 7);\n    ClimateReport[0].day := 'Monday'; ClimateReport[0].temperature := 23;\n    ClimateReport[1].day := 'Tuesday'; ClimateReport[1].temperature := 27;\n    ClimateReport[2].day := 'Wednesday'; ClimateReport[2].temperature := 26;\n    ClimateReport[3].day := 'Thursday'; ClimateReport[3].temperature := 22;\n    ClimateReport[4].day := 'Friday'; ClimateReport[4].temperature := 29;\n    ClimateReport[5].day := 'Saturday'; ClimateReport[5].temperature := 24;\n    ClimateReport[6].day := 'Sunday'; ClimateReport[6].temperature := 28;\n\n    count := 0;\n    SetLength(FilteredDays, Length(ClimateReport));\n    \n    for i := 0 to High(ClimateReport) do\n    begin\n        if ClimateReport[i].temperature > 25 then\n        begin\n            FilteredDays[count] := ClimateReport[i];\n            Inc(count);\n        end;\n    end;\n\n    SetLength(FilteredDays, count);\n\n    for i := 0 to High(FilteredDays) do\n    begin\n        WriteLn('Day: ', FilteredDays[i].day, ', Temperature: ', FilteredDays[i].temperature:0:2, '\u00b0C');\n    end;\nend.\n```"
  },
  {
    "task": "Find all recipes that are vegetarian from a cookbook.",
    "code": "```pascal\nprogram FilterVegetarianRecipes;\n\ntype\n  Recipe = record\n    name: string;\n    isVegetarian: boolean;\n  end;\n\nvar\n  cookbook: array of Recipe;\n  vegetarianRecipes: array of Recipe;\n  i, count: integer;\n\nbegin\n  // Example data for the cookbook\n  SetLength(cookbook, 5);\n  cookbook[0].name := 'Spaghetti Carbonara';\n  cookbook[0].isVegetarian := False;\n  cookbook[1].name := 'Vegetable Stir Fry';\n  cookbook[1].isVegetarian := True;\n  cookbook[2].name := 'Chicken Curry';\n  cookbook[2].isVegetarian := False;\n  cookbook[3].name := 'Caprese Salad';\n  cookbook[3].isVegetarian := True;\n  cookbook[4].name := 'Beef Tacos';\n  cookbook[4].isVegetarian := False;\n\n  // Initialize the vegetarianRecipes array\n  SetLength(vegetarianRecipes, 0);\n\n  // Filter vegetarian recipes\n  count := 0;\n  for i := 0 to High(cookbook) do\n  begin\n    if cookbook[i].isVegetarian then\n    begin\n      SetLength(vegetarianRecipes, count + 1);\n      vegetarianRecipes[count] := cookbook[i];\n      Inc(count);\n    end;\n  end;\n\n  // Output vegetarian recipes\n  for i := 0 to High(vegetarianRecipes) do\n  begin\n    writeln(vegetarianRecipes[i].name);\n  end;\nend.\n```"
  },
  {
    "task": "Identify all articles that mention a specific keyword from a news feed.",
    "code": "```pascal\nprogram FilterArticles;\n\nuses\n  SysUtils;\n\ntype\n  TArticle = record\n    Title: string;\n    Content: string;\n  end;\n\nfunction ContainsKeyword(const Article: TArticle; const Keyword: string): Boolean;\nbegin\n  Result := Pos(Keyword, Article.Title) > 0 \n            or Pos(Keyword, Article.Content) > 0;\nend;\n\nfunction FilterArticles(const Articles: array of TArticle; const Keyword: string): TArray<TArticle>;\nvar\n  I, Count: Integer;\nbegin\n  SetLength(Result, Length(Articles));\n  Count := 0;\n  for I := Low(Articles) to High(Articles) do\n  begin\n    if ContainsKeyword(Articles[I], Keyword) then\n    begin\n      Result[Count] := Articles[I];\n      Inc(Count);\n    end;\n  end;\n  SetLength(Result, Count);\nend;\n\nvar\n  Articles: array of TArticle;\n  Filtered: TArray<TArticle>;\n  Keyword: string;\n  I: Integer;\nbegin\n  // Example setup\n  SetLength(Articles, 2);\n  Articles[0].Title := 'Breaking News';\n  Articles[0].Content := 'This is a sample content mentioning the keyword.';\n  Articles[1].Title := 'Weather Update';\n  Articles[1].Content := 'No relevant keyword here.';\n\n  Keyword := 'keyword';\n  Filtered := FilterArticles(Articles, Keyword);\n\n  for I := Low(Filtered) to High(Filtered) do\n  begin\n    WriteLn('Title: ', Filtered[I].Title);\n    WriteLn('Content: ', Filtered[I].Content);\n  end;\nend.\n```"
  },
  {
    "task": "Extract all files with the '.jpg' extension from a directory.",
    "code": "```pascal\nprogram ExtractJpgFiles;\n\nuses\n  SysUtils, Classes;\n\nfunction FilterJpgFiles(const FileName: string): Boolean;\nbegin\n  Result := ExtractFileExt(FileName) = '.jpg';\nend;\n\nprocedure ListJpgFiles(const Directory: string; var JpgFiles: TStringList);\nvar\n  SearchRec: TSearchRec;\nbegin\n  if FindFirst(Directory + PathDelim + '*.*', faAnyFile, SearchRec) = 0 then\n  begin\n    repeat\n      if (SearchRec.Attr and faDirectory) = 0 then\n      begin\n        if FilterJpgFiles(SearchRec.Name) then\n          JpgFiles.Add(SearchRec.Name);\n      end;\n    until FindNext(SearchRec) <> 0;\n    FindClose(SearchRec);\n  end;\nend;\n\nvar\n  JpgFiles: TStringList;\n  i: Integer;\nbegin\n  JpgFiles := TStringList.Create;\n  try\n    ListJpgFiles('C:\\YourDirectory', JpgFiles);\n    for i := 0 to JpgFiles.Count - 1 do\n      WriteLn(JpgFiles[i]);\n  finally\n    JpgFiles.Free;\n  end;\nend.\n```"
  },
  {
    "task": "Filter out all transactions that are not categorized from a financial statement.",
    "code": "```pascal\nprogram FilterTransactions;\n\ntype\n  Transaction = record\n    amount: Real;\n    category: String;\n  end;\n\nvar\n  transactions, filteredTransactions: array of Transaction;\n  i, count: Integer;\n\nfunction IsCategorized(t: Transaction): Boolean;\nbegin\n  Result := t.category <> '';\nend;\n\nbegin\n  { Assume transactions are already populated with data }\n  \n  count := 0;\n  SetLength(filteredTransactions, Length(transactions));\n\n  for i := 0 to High(transactions) do\n  begin\n    if IsCategorized(transactions[i]) then\n    begin\n      filteredTransactions[count] := transactions[i];\n      Inc(count);\n    end;\n  end;\n  \n  SetLength(filteredTransactions, count);\n  { filteredTransactions now contains only categorized transactions }\nend.\n```"
  },
  {
    "task": "Select all paintings created before 1900 from an art gallery collection.",
    "code": "```pascal\nprogram FunctionalFilter;\n\ntype\n  Painting = record\n    Title: string;\n    Year: Integer;\n  end;\n\nvar\n  Gallery: array of Painting;\n  Selected: array of Painting;\n  i, count: Integer;\n\nfunction FilterBefore1900(const painting: Painting): Boolean;\nbegin\n  Result := painting.Year < 1900;\nend;\n\nbegin\n  { Initialize the gallery collection }\n  SetLength(Gallery, 5);\n  Gallery[0].Title := 'Starry Night'; Gallery[0].Year := 1889;\n  Gallery[1].Title := 'The Persistence of Memory'; Gallery[1].Year := 1931;\n  Gallery[2].Title := 'Mona Lisa'; Gallery[2].Year := 1503;\n  Gallery[3].Title := 'The Scream'; Gallery[3].Year := 1893;\n  Gallery[4].Title := 'Girl with a Pearl Earring'; Gallery[4].Year := 1665;\n\n  { Initialize the selected paintings list }\n  SetLength(Selected, Length(Gallery));\n  count := 0;\n\n  { Filter paintings created before 1900 }\n  for i := 0 to High(Gallery) do\n    if FilterBefore1900(Gallery[i]) then\n    begin\n      Selected[count] := Gallery[i];\n      Inc(count);\n    end;\n\n  { Resize the selected array to match the number of paintings found }\n  SetLength(Selected, count);\nend.\n```"
  },
  {
    "task": "Find all students with perfect attendance from a school record.",
    "code": "```pascal\nprogram PerfectAttendance;\n\ntype\n  TStudent = record\n    Name: string;\n    Attendance: integer;\n  end;\n\nvar\n  Students: array of TStudent;\n  PerfectAttendanceStudents: array of TStudent;\n  i, count: integer;\n\nfunction HasPerfectAttendance(Student: TStudent): boolean;\nbegin\n  Result := Student.Attendance = 100;\nend;\n\nbegin\n  // Example data\n  SetLength(Students, 3);\n  Students[0].Name := 'Alice';\n  Students[0].Attendance := 100;\n  Students[1].Name := 'Bob';\n  Students[1].Attendance := 98;\n  Students[2].Name := 'Charlie';\n  Students[2].Attendance := 100;\n\n  // Filter students with perfect attendance\n  count := 0;\n  for i := 0 to High(Students) do\n  begin\n    if HasPerfectAttendance(Students[i]) then\n    begin\n      SetLength(PerfectAttendanceStudents, count + 1);\n      PerfectAttendanceStudents[count] := Students[i];\n      Inc(count);\n    end;\n  end;\n\n  // Output result\n  for i := 0 to High(PerfectAttendanceStudents) do\n  begin\n    writeln(PerfectAttendanceStudents[i].Name);\n  end;\nend.\n```"
  },
  {
    "task": "Identify all messages sent by a specific user from a chat application.",
    "code": "```pascal\nprogram FilterMessages;\n\ntype\n  TMessage = record\n    User: string;\n    Content: string;\n  end;\n\nvar\n  Messages, FilteredMessages: array of TMessage;\n  SpecificUser: string;\n  i, FilteredCount: Integer;\n\nbegin\n  { Initialize the list of messages (example data) }\n  SetLength(Messages, 3);\n  Messages[0].User := 'Alice';\n  Messages[0].Content := 'Hi there!';\n  Messages[1].User := 'Bob';\n  Messages[1].Content := 'Hello!';\n  Messages[2].User := 'Alice';\n  Messages[2].Content := 'How are you?';\n\n  { Specify the user whose messages we want to filter }\n  SpecificUser := 'Alice';\n\n  { Filter messages }\n  FilteredCount := 0;\n  for i := 0 to High(Messages) do\n  begin\n    if Messages[i].User = SpecificUser then\n    begin\n      SetLength(FilteredMessages, FilteredCount + 1);\n      FilteredMessages[FilteredCount] := Messages[i];\n      Inc(FilteredCount);\n    end;\n  end;\n\n  { Output filtered messages }\n  for i := 0 to High(FilteredMessages) do\n  begin\n    WriteLn('User: ', FilteredMessages[i].User, ', Message: ', FilteredMessages[i].Content);\n  end;\nend.\n```"
  },
  {
    "task": "Extract all elements greater than 100 from an array of numbers.",
    "code": "```pascal\nprogram FilterNumbers;\n\ntype\n  TIntArray = array of Integer;\n\nfunction FilterGreaterThan100(const arr: TIntArray): TIntArray;\nvar\n  i, count: Integer;\nbegin\n  count := 0;\n  for i := 0 to High(arr) do\n    if arr[i] > 100 then\n      Inc(count);\n  \n  SetLength(Result, count);\n  count := 0;\n  for i := 0 to High(arr) do\n    if arr[i] > 100 then\n    begin\n      Result[count] := arr[i];\n      Inc(count);\n    end;\nend;\n\nvar\n  numbers, filtered: TIntArray;\n  i: Integer;\nbegin\n  numbers := TIntArray.Create(50, 150, 200, 75, 101, 90);\n  filtered := FilterGreaterThan100(numbers);\n  \n  for i := 0 to High(filtered) do\n    WriteLn(filtered[i]);\nend.\n```"
  },
  {
    "task": "Filter out all words that do not end in 'ed' from a paragraph.",
    "code": "```pascal\nprogram FilterWords;\n\nuses\n  SysUtils;\n\nfunction FilteredWords(const paragraph: string): TStringArray;\nvar\n  words, resultArray: TStringArray;\n  word: string;\n  i, count: Integer;\nbegin\n  words := paragraph.Split([' '], TStringSplitOptions.ExcludeEmpty);\n\n  count := 0;\n  SetLength(resultArray, Length(words));\n\n  for i := 0 to High(words) do\n  begin\n    word := words[i];\n    if word.EndsWith('ed') then\n    begin\n      resultArray[count] := word;\n      Inc(count);\n    end;\n  end;\n\n  SetLength(resultArray, count);\n  Result := resultArray;\nend;\n\nvar\n  paragraph: string;\n  filtered: TStringArray;\n  i: Integer;\nbegin\n  paragraph := 'This is a filtered paragraph that should only contain words that are ended.';\n  filtered := FilteredWords(paragraph);\n\n  for i := 0 to High(filtered) do\n    WriteLn(filtered[i]);\nend.\n```"
  },
  {
    "task": "Select all flights departing before noon from a flight schedule.",
    "code": "```pascal\nprogram FilterFlights;\n\ntype\n  TFlight = record\n    FlightNumber: string;\n    DepartureTime: TDateTime;\n  end;\n\nvar\n  FlightSchedule: array[1..5] of TFlight;\n  FilteredFlights: array of TFlight;\n  i, FilteredCount: Integer;\n\nfunction IsBeforeNoon(DepartureTime: TDateTime): Boolean;\nbegin\n  Result := HourOf(DepartureTime) < 12;\nend;\n\nbegin\n  { Example flight schedule initialization }\n  FlightSchedule[1].FlightNumber := 'AB123';\n  FlightSchedule[1].DepartureTime := EncodeTime(9, 0, 0, 0);\n\n  FlightSchedule[2].FlightNumber := 'CD456';\n  FlightSchedule[2].DepartureTime := EncodeTime(13, 45, 0, 0);\n\n  FlightSchedule[3].FlightNumber := 'EF789';\n  FlightSchedule[3].DepartureTime := EncodeTime(11, 30, 0, 0);\n\n  FlightSchedule[4].FlightNumber := 'GH012';\n  FlightSchedule[4].DepartureTime := EncodeTime(15, 0, 0, 0);\n\n  FlightSchedule[5].FlightNumber := 'IJ345';\n  FlightSchedule[5].DepartureTime := EncodeTime(10, 15, 0, 0);\n\n  FilteredCount := 0;\n  SetLength(FilteredFlights, Length(FlightSchedule));\n\n  for i := Low(FlightSchedule) to High(FlightSchedule) do\n  begin\n    if IsBeforeNoon(FlightSchedule[i].DepartureTime) then\n    begin\n      FilteredFlights[FilteredCount] := FlightSchedule[i];\n      Inc(FilteredCount);\n    end;\n  end;\n\n  SetLength(FilteredFlights, FilteredCount);\n\n  for i := 0 to High(FilteredFlights) do\n    WriteLn('Flight ', FilteredFlights[i].FlightNumber, ' departs at ', TimeToStr(FilteredFlights[i].DepartureTime));\nend.\n```"
  },
  {
    "task": "Find all products priced above $20 from an online store inventory.",
    "code": "```pascal\nprogram FilterProductsAbove20;\n\ntype\n  Product = record\n    Name: string;\n    Price: real;\n  end;\n\nvar\n  inventory: array[1..5] of Product;\n  filteredProducts: array of Product;\n  i, count: integer;\n\nbegin\n  inventory[1].Name := 'Product 1';\n  inventory[1].Price := 15.99;\n  inventory[2].Name := 'Product 2';\n  inventory[2].Price := 25.50;\n  inventory[3].Name := 'Product 3';\n  inventory[3].Price := 18.75;\n  inventory[4].Name := 'Product 4';\n  inventory[4].Price := 22.00;\n  inventory[5].Name := 'Product 5';\n  inventory[5].Price := 30.00;\n\n  count := 0;\n  for i := 1 to Length(inventory) do\n  begin\n    if inventory[i].Price > 20.0 then\n    begin\n      SetLength(filteredProducts, count + 1);\n      filteredProducts[count] := inventory[i];\n      Inc(count);\n    end;\n  end;\n\n  for i := 0 to High(filteredProducts) do\n  begin\n    writeln('Product: ', filteredProducts[i].Name, ', Price: ', filteredProducts[i].Price:0:2);\n  end;\nend.\n```"
  },
  {
    "task": "Identify all sessions longer than one hour from a webinar series.",
    "code": "```pascal\nprogram FilterSessions;\n\ntype\n  TSession = record\n    Title: string;\n    DurationInMinutes: Integer;\n  end;\n\nvar\n  Sessions: array of TSession;\n  LongSessions: array of TSession;\n  i, Count: Integer;\n\nfunction FilterLongSessions(const SessionArray: array of TSession): array of TSession;\nvar\n  i, Index, Len: Integer;\nbegin\n  Len := Length(SessionArray);\n  SetLength(Result, Len);\n  Index := 0;\n  for i := 0 to Len - 1 do\n  begin\n    if SessionArray[i].DurationInMinutes > 60 then\n    begin\n      Result[Index] := SessionArray[i];\n      Inc(Index);\n    end;\n  end;\n  SetLength(Result, Index);\nend;\n\nbegin\n  { Example initialization, replace with actual data }\n  SetLength(Sessions, 3);\n  Sessions[0].Title := 'Session 1';\n  Sessions[0].DurationInMinutes := 45;\n  Sessions[1].Title := 'Session 2';\n  Sessions[1].DurationInMinutes := 75;\n  Sessions[2].Title := 'Session 3';\n  Sessions[2].DurationInMinutes := 120;\n\n  LongSessions := FilterLongSessions(Sessions);\n\n  { Output long sessions }\n  Count := Length(LongSessions);\n  for i := 0 to Count - 1 do\n    WriteLn('Long Session: ', LongSessions[i].Title, ' - ', LongSessions[i].DurationInMinutes, ' minutes');\nend.\n```"
  },
  {
    "task": "Extract all images with a resolution higher than 1080p from a photo library.",
    "code": "```pascal\nprogram FilterHighResolutionImages;\n\ntype\n  TImage = record\n    Width: Integer;\n    Height: Integer;\n  end;\n\nvar\n  PhotoLibrary: array of TImage;\n  FilteredImages: array of TImage;\n  Image: TImage;\n  i: Integer;\n\nfunction IsHighResolution(Image: TImage): Boolean;\nbegin\n  Result := (Image.Width > 1920) and (Image.Height > 1080);\nend;\n\nbegin\n  // Assume PhotoLibrary is populated with images\n  SetLength(FilteredImages, 0);\n\n  for i := 0 to High(PhotoLibrary) do\n  begin\n    Image := PhotoLibrary[i];\n    if IsHighResolution(Image) then\n    begin\n      SetLength(FilteredImages, Length(FilteredImages) + 1);\n      FilteredImages[High(FilteredImages)] := Image;\n    end;\n  end;\n\n  // FilteredImages now contains all images with resolution higher than 1080p\nend.\n```"
  },
  {
    "task": "Filter out all responses that are not 'yes' or 'no' from a survey result.",
    "code": "```pascal\nprogram FilterResponses;\n\nuses\n  SysUtils;\n\ntype\n  TStringArray = array of string;\n\nfunction FilterResponses(const responses: TStringArray): TStringArray;\nvar\n  i, count: Integer;\n  filtered: TStringArray;\nbegin\n  count := 0;\n  SetLength(filtered, Length(responses));\n  for i := 0 to High(responses) do\n  begin\n    if (responses[i] = 'yes') or (responses[i] = 'no') then\n    begin\n      filtered[count] := responses[i];\n      Inc(count);\n    end;\n  end;\n  SetLength(filtered, count);\n  Result := filtered;\nend;\n\nvar\n  responses: TStringArray;\n  filteredResponses: TStringArray;\n  i: Integer;\nbegin\n  responses := TStringArray.Create('yes', 'no', 'maybe', 'yes', 'no', 'unknown');\n  filteredResponses := FilterResponses(responses);\n  for i := 0 to High(filteredResponses) do\n    WriteLn(filteredResponses[i]);\nend.\n```"
  },
  {
    "task": "Select all tweets with more than 100 likes from a Twitter feed.",
    "code": "```pascal\nprogram FilterTweets;\n\ntype\n  Tweet = record\n    content: string;\n    likes: Integer;\n  end;\n\n  TweetsArray = array of Tweet;\n\nfunction FilterTweetsByLikes(tweets: TweetsArray; minLikes: Integer): TweetsArray;\nvar\n  i, count: Integer;\nbegin\n  count := 0;\n  SetLength(Result, Length(tweets));\n  \n  for i := 0 to High(tweets) do\n  begin\n    if tweets[i].likes > minLikes then\n    begin\n      Result[count] := tweets[i];\n      Inc(count);\n    end;\n  end;\n  \n  SetLength(Result, count);\nend;\n\nvar\n  tweets, filteredTweets: TweetsArray;\nbegin\n  // Example data\n  SetLength(tweets, 3);\n  tweets[0].content := 'Tweet 1';\n  tweets[0].likes := 150;\n  tweets[1].content := 'Tweet 2';\n  tweets[1].likes := 90;\n  tweets[2].content := 'Tweet 3';\n  tweets[2].likes := 200;\n\n  filteredTweets := FilterTweetsByLikes(tweets, 100);\n\n  // Output the filtered tweets\n  for var i := 0 to High(filteredTweets) do\n    WriteLn(filteredTweets[i].content);\nend.\n```"
  },
  {
    "task": "Find all links that are broken from a webpage.",
    "code": "```pascal\nprogram FindBrokenLinks;\n\nuses\n  SysUtils, Classes, fphttpclient, fpopenssl;\n\nfunction IsLinkBroken(const URL: string): Boolean;\nvar\n  HttpClient: TFPHTTPClient;\nbegin\n  HttpClient := TFPHTTPClient.Create(nil);\n  try\n    try\n      HttpClient.Get(URL);\n      Result := False;\n    except\n      Result := True;\n    end;\n  finally\n    HttpClient.Free;\n  end;\nend;\n\nprocedure FindBrokenLinks(const Links: TStringList; var BrokenLinks: TStringList);\nvar\n  i: Integer;\nbegin\n  for i := 0 to Links.Count - 1 do\n  begin\n    if IsLinkBroken(Links[i]) then\n      BrokenLinks.Add(Links[i]);\n  end;\nend;\n\nvar\n  Links, BrokenLinks: TStringList;\nbegin\n  Links := TStringList.Create;\n  BrokenLinks := TStringList.Create;\n  try\n    // Assume Links is populated with URLs from the webpage\n\n    FindBrokenLinks(Links, BrokenLinks);\n\n    // Output broken links\n    WriteLn('Broken Links:');\n    WriteLn(BrokenLinks.Text);\n  finally\n    Links.Free;\n    BrokenLinks.Free;\n  end;\nend.\n```"
  },
  {
    "task": "Identify all machines that are currently offline from a network monitoring tool.",
    "code": "```pascal\nprogram FilterOfflineMachines;\n\ntype\n  TMachine = record\n    name: string;\n    isOnline: boolean;\n  end;\n\nvar\n  machines: array of TMachine;\n  offlineMachines: array of TMachine;\n  i, offlineCount: integer;\n\nbegin\n  { Example: Populate the machines array with some data }\n  machines := [ \n    (name: 'Machine1'; isOnline: true),\n    (name: 'Machine2'; isOnline: false),\n    (name: 'Machine3'; isOnline: true),\n    (name: 'Machine4'; isOnline: false)\n  ];\n\n  { Initialize offline machines counter }\n  offlineCount := 0;\n\n  { Filter offline machines }\n  SetLength(offlineMachines, Length(machines));\n  for i := 0 to High(machines) do\n  begin\n    if not machines[i].isOnline then\n    begin\n      offlineMachines[offlineCount] := machines[i];\n      Inc(offlineCount);\n    end;\n  end;\n  SetLength(offlineMachines, offlineCount);\n\n  { Output offline machines }\n  for i := 0 to High(offlineMachines) do\n  begin\n    WriteLn('Offline Machine: ', offlineMachines[i].name);\n  end;\nend.\n```"
  },
  {
    "task": "Extract all invoices with a due date in the current month from an accounting system.",
    "code": "```pascal\nprogram FilterInvoices;\n\nuses\n  SysUtils, DateUtils;\n\ntype\n  TInvoice = record\n    ID: Integer;\n    DueDate: TDateTime;\n  end;\n\nvar\n  Invoices, CurrentMonthInvoices: array of TInvoice;\n  CurrentMonth, CurrentYear: Word;\n  I, Count: Integer;\n\nfunction IsDueThisMonth(Invoice: TInvoice): Boolean;\nvar\n  Year, Month, Day: Word;\nbegin\n  DecodeDate(Invoice.DueDate, Year, Month, Day);\n  Result := (Month = CurrentMonth) and (Year = CurrentYear);\nend;\n\nbegin\n  DecodeDate(Now, CurrentYear, CurrentMonth, Count);\n\n  SetLength(Invoices, 5);\n  Invoices[0].ID := 1; Invoices[0].DueDate := EncodeDate(CurrentYear, CurrentMonth, 5);\n  Invoices[1].ID := 2; Invoices[1].DueDate := EncodeDate(CurrentYear, CurrentMonth, 15);\n  Invoices[2].ID := 3; Invoices[2].DueDate := EncodeDate(CurrentYear, CurrentMonth - 1, 25);\n  Invoices[3].ID := 4; Invoices[3].DueDate := EncodeDate(CurrentYear, CurrentMonth, 20);\n  Invoices[4].ID := 5; Invoices[4].DueDate := EncodeDate(CurrentYear, CurrentMonth + 1, 10);\n\n  Count := 0;\n  for I := 0 to High(Invoices) do\n  begin\n    if IsDueThisMonth(Invoices[I]) then\n    begin\n      SetLength(CurrentMonthInvoices, Count + 1);\n      CurrentMonthInvoices[Count] := Invoices[I];\n      Inc(Count);\n    end;\n  end;\n\n  for I := 0 to High(CurrentMonthInvoices) do\n    WriteLn('Invoice ID: ', CurrentMonthInvoices[I].ID, ', Due Date: ', DateToStr(CurrentMonthInvoices[I].DueDate));\nend.\n```"
  },
  {
    "task": "Filter out all lines in a file that start with a '#' from a configuration file.",
    "code": "```pascal\nprogram FilterConfig;\n\nuses\n  SysUtils, Classes;\n\nvar\n  InputFile, OutputFile: TextFile;\n  Line: string;\n\nbegin\n  AssignFile(InputFile, 'config.txt');\n  AssignFile(OutputFile, 'filtered_config.txt');\n  Reset(InputFile);\n  Rewrite(OutputFile);\n  while not EOF(InputFile) do\n  begin\n    ReadLn(InputFile, Line);\n    if (Length(Line) > 0) and (Line[1] <> '#') then\n      WriteLn(OutputFile, Line);\n  end;\n  CloseFile(InputFile);\n  CloseFile(OutputFile);\nend.\n```"
  },
  {
    "task": "Select all posts with a comment count higher than 50 from a blog.",
    "code": "```pascal\nprogram FilterPosts;\n\ntype\n  Post = record\n    Title: string;\n    CommentCount: integer;\n  end;\n\nvar\n  Posts, FilteredPosts: array of Post;\n  i, PostCount: integer;\n\nfunction FilterByCommentCount(Posts: array of Post; MinComments: integer): array of Post;\nvar\n  i, j: integer;\nbegin\n  SetLength(Result, 0);\n  j := 0;\n  for i := 0 to High(Posts) do\n  begin\n    if Posts[i].CommentCount > MinComments then\n    begin\n      SetLength(Result, j + 1);\n      Result[j] := Posts[i];\n      Inc(j);\n    end;\n  end;\nend;\n\nbegin\n  { Example data }\n  PostCount := 3;\n  SetLength(Posts, PostCount);\n  Posts[0].Title := 'Post 1';\n  Posts[0].CommentCount := 30;\n  Posts[1].Title := 'Post 2';\n  Posts[1].CommentCount := 60;\n  Posts[2].Title := 'Post 3';\n  Posts[2].CommentCount := 70;\n\n  { Filter posts }\n  FilteredPosts := FilterByCommentCount(Posts, 50);\n\n  { Output filtered posts }\n  for i := 0 to High(FilteredPosts) do\n  begin\n    WriteLn('Title: ', FilteredPosts[i].Title, ', Comments: ', FilteredPosts[i].CommentCount);\n  end;\nend.\n```"
  },
  {
    "task": "Find all offers that expire within the next week from a promotional database.",
    "code": "```pascal\nprogram FilterOffers;\n\nuses\n  SysUtils, DateUtils;\n\ntype\n  TOffer = record\n    Name: string;\n    ExpiryDate: TDateTime;\n  end;\n\nvar\n  Offers: array of TOffer;\n  FilteredOffers: array of TOffer;\n  Today, NextWeek: TDateTime;\n  I, Count: Integer;\n\nfunction OfferExpiresWithinAWeek(Offer: TOffer): Boolean;\nbegin\n  Result := (Offer.ExpiryDate > Today) and (Offer.ExpiryDate <= NextWeek);\nend;\n\nbegin\n  Today := Date;\n  NextWeek := Today + 7;\n\n  // Sample data for demonstration\n  SetLength(Offers, 3);\n  Offers[0].Name := 'Offer1';\n  Offers[0].ExpiryDate := Today + 5;\n  Offers[1].Name := 'Offer2';\n  Offers[1].ExpiryDate := Today + 8;\n  Offers[2].Name := 'Offer3';\n  Offers[2].ExpiryDate := Today + 3;\n\n  SetLength(FilteredOffers, Length(Offers));\n  Count := 0;\n\n  for I := 0 to High(Offers) do\n  begin\n    if OfferExpiresWithinAWeek(Offers[I]) then\n    begin\n      FilteredOffers[Count] := Offers[I];\n      Inc(Count);\n    end;\n  end;\n\n  SetLength(FilteredOffers, Count);\n\n  for I := 0 to High(FilteredOffers) do\n    WriteLn('Offer: ', FilteredOffers[I].Name, ', Expires on: ', DateToStr(FilteredOffers[I].ExpiryDate));\nend.\n```"
  },
  {
    "task": "Identify all items that are on sale from a shopping catalog.",
    "code": "```pascal\nprogram OnSaleItemsFilter;\n\ntype\n  TItem = record\n    Name: string;\n    Price: Real;\n    OnSale: Boolean;\n  end;\n\nvar\n  Catalog: array of TItem;\n  OnSaleItems: array of TItem;\n  I, Count: Integer;\n\nfunction FilterOnSaleItems(Catalog: array of TItem): array of TItem;\nvar\n  TempItems: array of TItem;\n  J, TempCount: Integer;\nbegin\n  TempCount := 0;\n  SetLength(TempItems, Length(Catalog));\n  for J := Low(Catalog) to High(Catalog) do\n  begin\n    if Catalog[J].OnSale then\n    begin\n      TempItems[TempCount] := Catalog[J];\n      Inc(TempCount);\n    end;\n  end;\n  SetLength(TempItems, TempCount);\n  Result := TempItems;\nend;\n\nbegin\n  { Example data }\n  SetLength(Catalog, 3);\n  Catalog[0].Name := 'Item1'; Catalog[0].Price := 100.0; Catalog[0].OnSale := True;\n  Catalog[1].Name := 'Item2'; Catalog[1].Price := 150.0; Catalog[1].OnSale := False;\n  Catalog[2].Name := 'Item3'; Catalog[2].Price := 200.0; Catalog[2].OnSale := True;\n\n  OnSaleItems := FilterOnSaleItems(Catalog);\n\n  { Output result }\n  for I := Low(OnSaleItems) to High(OnSaleItems) do\n  begin\n    WriteLn('On Sale: ', OnSaleItems[I].Name, ' at $', OnSaleItems[I].Price:0:2);\n  end;\nend.\n```"
  },
  {
    "task": "Extract all notes that mention 'urgent' from a meeting record.",
    "code": "```pascal\nprogram ExtractUrgentNotes;\n\ntype\n    TStringArray = array of string;\n\nfunction FilterUrgentNotes(notes: TStringArray): TStringArray;\nvar\n    i, count: Integer;\n    resultIndex: Integer;\nbegin\n    count := 0;\n    // Count how many notes contain 'urgent'\n    for i := 0 to High(notes) do\n    begin\n        if Pos('urgent', notes[i]) > 0 then\n            Inc(count);\n    end;\n\n    SetLength(Result, count);\n    resultIndex := 0;\n\n    // Populate the result array with urgent notes\n    for i := 0 to High(notes) do\n    begin\n        if Pos('urgent', notes[i]) > 0 then\n        begin\n            Result[resultIndex] := notes[i];\n            Inc(resultIndex);\n        end;\n    end;\nend;\n\nvar\n    meetingNotes, urgentNotes: TStringArray;\n    i: Integer;\nbegin\n    meetingNotes := TStringArray.Create(\n        'Discuss project updates',\n        'Prepare financial report - urgent',\n        'Schedule team building event',\n        'Review urgent client feedback',\n        'Plan holiday schedule'\n    );\n\n    urgentNotes := FilterUrgentNotes(meetingNotes);\n\n    for i := 0 to High(urgentNotes) do\n    begin\n        WriteLn(urgentNotes[i]);\n    end;\nend.\n```"
  },
  {
    "task": "Filter out all numbers that do not have a remainder when divided by two from a list.",
    "code": "```pascal\nprogram FilterEvenNumbers;\n\ntype\n  IntArray = array of Integer;\n\nfunction FilterOdds(const numbers: IntArray): IntArray;\nvar\n  i, count: Integer;\nbegin\n  count := 0;\n  SetLength(Result, Length(numbers));\n  for i := 0 to High(numbers) do\n  begin\n    if numbers[i] mod 2 <> 0 then\n    begin\n      Result[count] := numbers[i];\n      Inc(count);\n    end;\n  end;\n  SetLength(Result, count);\nend;\n\nvar\n  numbers, filtered: IntArray;\n  i: Integer;\nbegin\n  numbers := [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n  filtered := FilterOdds(numbers);\n  for i := 0 to High(filtered) do\n    WriteLn(filtered[i]);\nend.\n```"
  },
  {
    "task": "Select all concerts happening in the summer from an event calendar.",
    "code": "```pascal\nprogram SummerConcerts;\n\ntype\n  TEvent = record\n    Name: string;\n    Date: TDateTime;\n    EventType: string;\n  end;\n\nvar\n  events: array of TEvent;\n  summerConcerts: array of TEvent;\n  i: Integer;\n  event: TEvent;\n\nfunction IsSummerConcert(event: TEvent): Boolean;\nvar\n  month: Word;\nbegin\n  month := MonthOf(event.Date);\n  Result := (event.EventType = 'Concert') and ((month = 6) or (month = 7) or (month = 8));\nend;\n\nbegin\n  { Assume events array is populated with event data }\n\n  SetLength(summerConcerts, 0);\n\n  for i := 0 to High(events) do\n  begin\n    event := events[i];\n    if IsSummerConcert(event) then\n    begin\n      SetLength(summerConcerts, Length(summerConcerts) + 1);\n      summerConcerts[High(summerConcerts)] := event;\n    end;\n  end;\n\n  { Summer concerts are now in summerConcerts array }\nend.\n```"
  },
  {
    "task": "Find all users with more than 1000 followers from a social media platform.",
    "code": "```pascal\nprogram FilterUsers;\n\ntype\n  TUser = record\n    Name: string;\n    Followers: Integer;\n  end;\n\nvar\n  Users: array of TUser;\n  FilteredUsers: array of TUser;\n  i, Count: Integer;\n\nfunction Filter(const UserList: array of TUser; MinFollowers: Integer): array of TUser;\nvar\n  ResultList: array of TUser;\n  j: Integer;\nbegin\n  SetLength(ResultList, 0);\n  for i := Low(UserList) to High(UserList) do\n  begin\n    if UserList[i].Followers > MinFollowers then\n    begin\n      j := Length(ResultList);\n      SetLength(ResultList, j + 1);\n      ResultList[j] := UserList[i];\n    end;\n  end;\n  Filter := ResultList;\nend;\n\nbegin\n  { Assume Users array is initialized with data here }\n\n  FilteredUsers := Filter(Users, 1000);\n\n  { Output or process FilteredUsers array here }\nend.\n```"
  },
  {
    "task": "Identify all stocks with a growth rate above 10% from a financial portfolio.",
    "code": "```pascal\nprogram FilterStocks;\n\ntype\n  Stock = record\n    name: string;\n    growthRate: real;\n  end;\n\nvar\n  portfolio: array of Stock;\n  filteredStocks: array of Stock;\n  i, count: integer;\n\nfunction FilterGrowthRate(stocks: array of Stock; rate: real): array of Stock;\nvar\n  i, index: integer;\nbegin\n  SetLength(Result, 0);\n  index := 0;\n  for i := 0 to High(stocks) do\n  begin\n    if stocks[i].growthRate > rate then\n    begin\n      SetLength(Result, index + 1);\n      Result[index] := stocks[i];\n      index := index + 1;\n    end;\n  end;\nend;\n\nbegin\n  SetLength(portfolio, 5);\n  portfolio[0].name := 'Stock A'; portfolio[0].growthRate := 12.5;\n  portfolio[1].name := 'Stock B'; portfolio[1].growthRate := 8.4;\n  portfolio[2].name := 'Stock C'; portfolio[2].growthRate := 15.2;\n  portfolio[3].name := 'Stock D'; portfolio[3].growthRate := 9.8;\n  portfolio[4].name := 'Stock E'; portfolio[4].growthRate := 11.3;\n\n  filteredStocks := FilterGrowthRate(portfolio, 10.0);\n\n  for i := 0 to High(filteredStocks) do\n  begin\n    writeln('Stock: ', filteredStocks[i].name, ', Growth Rate: ', filteredStocks[i].growthRate:0:2, '%');\n  end;\nend.\n```"
  },
  {
    "task": "Extract all reviews that have a five-star rating from a product review site.",
    "code": "```pascal\nprogram FilterFiveStarReviews;\n\ntype\n  Review = record\n    rating: Integer;\n    content: String;\n  end;\n\nvar\n  reviews, fiveStarReviews: array of Review;\n  i, fiveStarCount: Integer;\n\nfunction FilterFiveStarReviews(reviews: array of Review): array of Review;\nvar\n  i, count: Integer;\nbegin\n  count := 0;\n  for i := Low(reviews) to High(reviews) do\n    if reviews[i].rating = 5 then\n      Inc(count);\n\n  SetLength(Result, count);\n  count := 0;\n  for i := Low(reviews) to High(reviews) do\n    if reviews[i].rating = 5 then\n    begin\n      Result[count] := reviews[i];\n      Inc(count);\n    end;\nend;\n\nbegin\n  { Example initialization of reviews array }\n  SetLength(reviews, 3);\n  reviews[0].rating := 5;\n  reviews[0].content := 'Excellent product!';\n  reviews[1].rating := 3;\n  reviews[1].content := 'Average quality.';\n  reviews[2].rating := 5;\n  reviews[2].content := 'Highly recommend!';\n\n  fiveStarReviews := FilterFiveStarReviews(reviews);\n\n  { Output five-star reviews }\n  for i := Low(fiveStarReviews) to High(fiveStarReviews) do\n    Writeln(fiveStarReviews[i].content);\nend.\n```"
  },
  {
    "task": "Filter out all emails that are not flagged from an inbox.",
    "code": "```pascal\nprogram FilterEmails;\n\ntype\n  Email = record\n    Address: string;\n    IsFlagged: Boolean;\n  end;\n\nvar\n  Inbox, FlaggedEmails: array of Email;\n  FilteredEmails: array of Email;\n  i, Count: Integer;\n\nbegin\n  { Assume Inbox is already populated with emails }\n  \n  SetLength(FlaggedEmails, Length(Inbox));\n  Count := 0;\n\n  for i := 0 to High(Inbox) do\n    if Inbox[i].IsFlagged then\n    begin\n      FlaggedEmails[Count] := Inbox[i];\n      Inc(Count);\n    end;\n\n  SetLength(FilteredEmails, Count);\n  for i := 0 to Count - 1 do\n    FilteredEmails[i] := FlaggedEmails[i];\n  \n  { FilteredEmails now contains only flagged emails }\nend.\n```"
  },
  {
    "task": "Select all entries with a timestamp from the past 24 hours from a log file.",
    "code": "```pascal\nprogram FilterRecentEntries;\n\nuses\n  SysUtils, DateUtils;\n\ntype\n  TLogEntry = record\n    Timestamp: TDateTime;\n    Message: string;\n  end;\n\nvar\n  LogEntries: array of TLogEntry;\n  RecentEntries: array of TLogEntry;\n  i, Count: Integer;\n  CurrentTime: TDateTime;\n\nfunction IsRecent(Entry: TLogEntry): Boolean;\nbegin\n  Result := Entry.Timestamp >= IncHour(CurrentTime, -24);\nend;\n\nbegin\n  CurrentTime := Now;\n  \n  // Assume LogEntries is already populated with log data\n\n  Count := 0;\n  SetLength(RecentEntries, Length(LogEntries));\n\n  for i := 0 to High(LogEntries) do\n  begin\n    if IsRecent(LogEntries[i]) then\n    begin\n      RecentEntries[Count] := LogEntries[i];\n      Inc(Count);\n    end;\n  end;\n  \n  SetLength(RecentEntries, Count);\n\n  // RecentEntries now contains all log entries from the past 24 hours\nend.\n```"
  },
  {
    "task": "Find all books by a specific author from a library database.",
    "code": "```pascal\nprogram FilterBooksByAuthor;\n\ntype\n  Book = record\n    Title: string;\n    Author: string;\n  end;\n\nvar\n  Library: array of Book;\n  AuthorToFind: string;\n  i: integer;\n\nfunction FilterBooksByAuthor(const Books: array of Book; const Author: string): array of Book;\nvar\n  ResultBooks: array of Book;\n  j, Count: integer;\nbegin\n  Count := 0;\n  SetLength(ResultBooks, Length(Books));\n  \n  for i := 0 to High(Books) do\n  begin\n    if Books[i].Author = Author then\n    begin\n      ResultBooks[Count] := Books[i];\n      Inc(Count);\n    end;\n  end;\n  \n  SetLength(ResultBooks, Count);\n  FilterBooksByAuthor := ResultBooks;\nend;\n\nbegin\n  { Example usage }\n  SetLength(Library, 3);\n  Library[0].Title := 'Book One';\n  Library[0].Author := 'Author A';\n  Library[1].Title := 'Book Two';\n  Library[1].Author := 'Author B';\n  Library[2].Title := 'Book Three';\n  Library[2].Author := 'Author A';\n\n  AuthorToFind := 'Author A';\n  Library := FilterBooksByAuthor(Library, AuthorToFind);\n\n  { Output results }\n  for i := 0 to High(Library) do\n  begin\n    WriteLn('Title: ', Library[i].Title, ', Author: ', Library[i].Author);\n  end;\nend.\n```"
  },
  {
    "task": "Identify all donations above $500 from a charity fundraiser report.",
    "code": "```pascal\nprogram FilterDonations;\n\ntype\n  TDonations = array of Real;\n\nfunction FilterAboveFiveHundred(donations: TDonations): TDonations;\nvar\n  filtered: TDonations;\n  i, count: Integer;\nbegin\n  count := 0;\n  SetLength(filtered, Length(donations));\n  for i := 0 to High(donations) do\n  begin\n    if donations[i] > 500 then\n    begin\n      filtered[count] := donations[i];\n      Inc(count);\n    end;\n  end;\n  SetLength(filtered, count);\n  FilterAboveFiveHundred := filtered;\nend;\n\nvar\n  donations, filteredDonations: TDonations;\n  i: Integer;\nbegin\n  donations := TDonations.Create(100.0, 250.0, 600.0, 750.0, 450.0, 550.0);\n  filteredDonations := FilterAboveFiveHundred(donations);\n  for i := 0 to High(filteredDonations) do\n  begin\n    WriteLn(filteredDonations[i]:0:2);\n  end;\nend.\n```"
  },
  {
    "task": "Extract all assignments due in the next week from a course syllabus.",
    "code": "```pascal\nprogram ExtractAssignments;\n\nuses\n  SysUtils, DateUtils;\n\ntype\n  TAssignment = record\n    Title: string;\n    DueDate: TDateTime;\n  end;\n\nvar\n  Syllabus, FilteredAssignments: array of TAssignment;\n  Today, NextWeek: TDateTime;\n  i: Integer;\n\nfunction IsDueNextWeek(const Assignment: TAssignment): Boolean;\nbegin\n  Result := (Assignment.DueDate >= Today) and (Assignment.DueDate <= NextWeek);\nend;\n\nbegin\n  // Initialize today's date\n  Today := Date;\n  NextWeek := IncWeek(Today, 1);\n  \n  // Example data\n  SetLength(Syllabus, 3);\n  Syllabus[0].Title := 'Assignment 1';\n  Syllabus[0].DueDate := Today + 2;\n  Syllabus[1].Title := 'Assignment 2';\n  Syllabus[1].DueDate := Today + 9;\n  Syllabus[2].Title := 'Assignment 3';\n  Syllabus[2].DueDate := Today + 5;\n\n  // Filter assignments due in the next week\n  for i := 0 to High(Syllabus) do\n  begin\n    if IsDueNextWeek(Syllabus[i]) then\n    begin\n      SetLength(FilteredAssignments, Length(FilteredAssignments) + 1);\n      FilteredAssignments[High(FilteredAssignments)] := Syllabus[i];\n    end;\n  end;\n\n  // Output the filtered assignments\n  for i := 0 to High(FilteredAssignments) do\n  begin\n    Writeln(FilteredAssignments[i].Title, ' is due on ', DateToStr(FilteredAssignments[i].DueDate));\n  end;\nend.\n```"
  },
  {
    "task": "Filter out all movies that are not in English from a streaming service.",
    "code": "```pascal\nprogram FilterMovies;\n\ntype\n  TMovie = record\n    Title: string;\n    Language: string;\n  end;\n\nvar\n  Movies, EnglishMovies: array of TMovie;\n  i, count: Integer;\n\nfunction IsEnglishMovie(Movie: TMovie): Boolean;\nbegin\n  Result := Movie.Language = 'English';\nend;\n\nbegin\n  { Assuming Movies array is populated with movie records }\n  SetLength(EnglishMovies, Length(Movies));\n  count := 0;\n\n  for i := 0 to High(Movies) do\n    if IsEnglishMovie(Movies[i]) then\n    begin\n      EnglishMovies[count] := Movies[i];\n      Inc(count);\n    end;\n\n  SetLength(EnglishMovies, count);\n\n  { EnglishMovies now contains only the movies in English }\nend.\n```"
  },
  {
    "task": "Select all landmarks located in Europe from a travel guide.",
    "code": "```pascal\nprogram FilterLandmarks;\n\ntype\n  Landmark = record\n    Name: string;\n    Location: string;\n  end;\n\nvar\n  Landmarks, EuropeanLandmarks: array of Landmark;\n  i, count: Integer;\n\nfunction IsInEurope(Location: string): Boolean;\nbegin\n  case Location of\n    'France', 'Germany', 'Italy', 'Spain', 'UK', 'Netherlands', 'Greece', 'Portugal', 'Sweden', 'Norway':\n      IsInEurope := True;\n  else\n    IsInEurope := False;\n  end;\nend;\n\nbegin\n  Landmarks := [\n    (Name: 'Eiffel Tower'; Location: 'France'),\n    (Name: 'Great Wall'; Location: 'China'),\n    (Name: 'Colosseum'; Location: 'Italy'),\n    (Name: 'Statue of Liberty'; Location: 'USA')\n  ];\n\n  SetLength(EuropeanLandmarks, Length(Landmarks));\n  count := 0;\n\n  for i := 0 to High(Landmarks) do\n    if IsInEurope(Landmarks[i].Location) then\n    begin\n      EuropeanLandmarks[count] := Landmarks[i];\n      Inc(count);\n    end;\n\n  SetLength(EuropeanLandmarks, count);\nend.\n```"
  },
  {
    "task": "Find all contracts that are set to renew next month from a contract management system.",
    "code": "```pascal\nprogram FilterContracts;\n\ntype\n  TContract = record\n    ID: Integer;\n    RenewalDate: TDateTime;\n  end;\n\n  TContractArray = array of TContract;\n\nfunction NextMonth: TDateTime;\nvar\n  Year, Month, Day: Word;\nbegin\n  DecodeDate(Date, Year, Month, Day);\n  if Month = 12 then\n  begin\n    Month := 1;\n    Inc(Year);\n  end\n  else\n    Inc(Month);\n  Result := EncodeDate(Year, Month, 1);\nend;\n\nfunction FilterContracts(const Contracts: TContractArray): TContractArray;\nvar\n  I: Integer;\n  Count: Integer;\nbegin\n  Count := 0;\n  SetLength(Result, Length(Contracts));\n  for I := Low(Contracts) to High(Contracts) do\n  begin\n    if MonthOfTheYear(Contracts[I].RenewalDate) = MonthOfTheYear(NextMonth) then\n    begin\n      Result[Count] := Contracts[I];\n      Inc(Count);\n    end;\n  end;\n  SetLength(Result, Count);\nend;\n\nvar\n  Contracts, RenewingContracts: TContractArray;\nbegin\n  // Assume Contracts is filled with data\n  RenewingContracts := FilterContracts(Contracts);\nend.\n```"
  },
  {
    "task": "Identify all volunteer hours logged in the past year from a non-profit organization database.",
    "code": "```pascal\nprogram FilterVolunteerHours;\n\nuses\n  SysUtils, DateUtils;\n\ntype\n  TVolunteerLog = record\n    VolunteerID: Integer;\n    Hours: Integer;\n    DateLogged: TDateTime;\n  end;\n\nvar\n  VolunteerLogs: array of TVolunteerLog;\n  FilteredLogs: array of TVolunteerLog;\n  CurrentDate: TDateTime;\n  OneYearAgo: TDateTime;\n  i, FilteredCount: Integer;\n\nbegin\n  CurrentDate := Now;\n  OneYearAgo := IncYear(CurrentDate, -1);\n\n  // Assume VolunteerLogs is populated with data\n  // ...\n\n  // Initialize filtered logs array\n  SetLength(FilteredLogs, Length(VolunteerLogs));\n  FilteredCount := 0;\n\n  // Filter logs from the past year\n  for i := 0 to High(VolunteerLogs) do\n  begin\n    if VolunteerLogs[i].DateLogged >= OneYearAgo then\n    begin\n      FilteredLogs[FilteredCount] := VolunteerLogs[i];\n      Inc(FilteredCount);\n    end;\n  end;\n\n  // Adjust the length of the FilteredLogs array\n  SetLength(FilteredLogs, FilteredCount);\n\n  // Output or process FilteredLogs\n  // ...\nend.\n```"
  },
  {
    "task": "Extract all elements that are not strings from a mixed-type list.",
    "code": "```pascal\nprogram FunctionalFilter;\n\nuses\n  SysUtils;\n\ntype\n  TAnyArray = array of Variant;\n\nfunction IsNotString(const Value: Variant): Boolean;\nbegin\n  Result := not VarIsStr(Value);\nend;\n\nfunction FilterNotStrings(const Arr: TAnyArray): TAnyArray;\nvar\n  i, Count: Integer;\nbegin\n  Count := 0;\n  SetLength(Result, Length(Arr));\n  \n  for i := 0 to High(Arr) do\n  begin\n    if IsNotString(Arr[i]) then\n    begin\n      Result[Count] := Arr[i];\n      Inc(Count);\n    end;\n  end;\n  \n  SetLength(Result, Count);\nend;\n\nvar\n  MixedList, FilteredList: TAnyArray;\n  i: Integer;\nbegin\n  MixedList := VarArrayOf([42, 'string', 3.14, 'hello', True, 7]);\n\n  FilteredList := FilterNotStrings(MixedList);\n  \n  for i := 0 to High(FilteredList) do\n    WriteLn(FilteredList[i]);\nend.\n```"
  },
  {
    "task": "Filter out all orders that are not yet shipped from an e-commerce system.",
    "code": "```pascal\nprogram FilterOrders;\n\ntype\n  Order = record\n    id: Integer;\n    status: String;\n  end;\n\nvar\n  orders, shippedOrders: array of Order;\n  i, count: Integer;\n\nfunction IsShipped(order: Order): Boolean;\nbegin\n  Result := order.status = 'shipped';\nend;\n\nbegin\n  // Example orders for demonstration\n  SetLength(orders, 5);\n  orders[0].id := 1; orders[0].status := 'shipped';\n  orders[1].id := 2; orders[1].status := 'pending';\n  orders[2].id := 3; orders[2].status := 'shipped';\n  orders[3].id := 4; orders[3].status := 'processing';\n  orders[4].id := 5; orders[4].status := 'shipped';\n\n  count := 0;\n  for i := 0 to High(orders) do\n    if IsShipped(orders[i]) then\n    begin\n      SetLength(shippedOrders, count + 1);\n      shippedOrders[count] := orders[i];\n      Inc(count);\n    end;\n\n  // Output filtered shipped orders\n  for i := 0 to High(shippedOrders) do\n    WriteLn('Order ID: ', shippedOrders[i].id, ' Status: ', shippedOrders[i].status);\nend.\n```"
  },
  {
    "task": "Select all emails sent from a specific address in an email server.",
    "code": "```pascal\nprogram FilterEmails;\n\ntype\n  TEmail = record\n    From: string;\n    Subject: string;\n    Body: string;\n  end;\n\nvar\n  Emails: array of TEmail;\n  FilteredEmails: array of TEmail;\n  Email: TEmail;\n  SpecificAddress: string;\n  i, Count: Integer;\n\nbegin\n  SpecificAddress := 'specific@example.com';\n\n  { Assuming Emails array is already populated with email records }\n  Count := 0;\n  SetLength(FilteredEmails, Length(Emails));\n\n  for i := 0 to High(Emails) do\n  begin\n    Email := Emails[i];\n    if Email.From = SpecificAddress then\n    begin\n      FilteredEmails[Count] := Email;\n      Inc(Count);\n    end;\n  end;\n\n  SetLength(FilteredEmails, Count);\n\n  { FilteredEmails now contains only emails sent from the specific address }\nend.\n```"
  },
  {
    "task": "Find all passwords with at least one special character from a security database.",
    "code": "```pascal\nprogram FilterPasswords;\n\nuses\n  SysUtils;\n\ntype\n  TPasswordArray = array of string;\n\nfunction HasSpecialCharacter(const password: string): Boolean;\nvar\n  i: Integer;\n  specialChars: set of Char;\nbegin\n  specialChars := ['!', '@', '#', '$', '%', '^', '&', '*', '(', ')', '-', '_', '=', '+', '[', ']', '{', '}', '|', '\\', ':', ';', '\"', '''', '<', '>', ',', '.', '?', '/'];\n  for i := 1 to Length(password) do\n    if password[i] in specialChars then\n      Exit(True);\n  Result := False;\nend;\n\nfunction FilterPasswordsWithSpecialChar(passwords: TPasswordArray): TPasswordArray;\nvar\n  i, count: Integer;\nbegin\n  count := 0;\n  SetLength(Result, Length(passwords));\n  for i := 0 to High(passwords) do\n    if HasSpecialCharacter(passwords[i]) then\n    begin\n      Result[count] := passwords[i];\n      Inc(count);\n    end;\n  SetLength(Result, count);\nend;\n\nvar\n  passwords, filteredPasswords: TPasswordArray;\nbegin\n  // Example data\n  passwords := TPasswordArray.Create('password123', 'hello@world', 'secure#pass', 'simplepass', 'test*pass');\n\n  filteredPasswords := FilterPasswordsWithSpecialChar(passwords);\n\n  // Output filtered passwords\n  for var i := 0 to High(filteredPasswords) do\n    Writeln(filteredPasswords[i]);\nend.\n```"
  },
  {
    "task": "Identify all courses with a prerequisite from a university catalog.",
    "code": "```pascal\nprogram FilterCoursesWithPrerequisite;\n\ntype\n  Course = record\n    Name: string;\n    Prerequisite: string;\n  end;\n\nvar\n  Catalog: array of Course;\n  FilteredCourses: array of Course;\n  i, j: Integer;\n\nfunction HasPrerequisite(const C: Course): Boolean;\nbegin\n  Result := C.Prerequisite <> '';\nend;\n\nbegin\n  // Example catalog initialization\n  SetLength(Catalog, 5);\n  Catalog[0].Name := 'Math 101'; Catalog[0].Prerequisite := '';\n  Catalog[1].Name := 'Physics 101'; Catalog[1].Prerequisite := 'Math 101';\n  Catalog[2].Name := 'Chemistry 101'; Catalog[2].Prerequisite := '';\n  Catalog[3].Name := 'Biology 101'; Catalog[3].Prerequisite := 'Chemistry 101';\n  Catalog[4].Name := 'Computer Science 101'; Catalog[4].Prerequisite := 'Math 101';\n\n  // Filter courses with prerequisites\n  SetLength(FilteredCourses, 0);\n  for i := 0 to High(Catalog) do\n  begin\n    if HasPrerequisite(Catalog[i]) then\n    begin\n      j := Length(FilteredCourses);\n      SetLength(FilteredCourses, j + 1);\n      FilteredCourses[j] := Catalog[i];\n    end;\n  end;\n\n  // Output filtered courses\n  for i := 0 to High(FilteredCourses) do\n  begin\n    WriteLn('Course: ', FilteredCourses[i].Name);\n  end;\nend.\n```"
  },
  {
    "task": "Extract all genes associated with a specific trait from a genetic database.",
    "code": "```pascal\nprogram ExtractGenes;\n\ntype\n  Gene = record\n    name: string;\n    trait: string;\n  end;\n\nvar\n  geneticDatabase: array of Gene;\n  extractedGenes: array of Gene;\n  specificTrait: string;\n  i, count: integer;\n\nfunction FilterGenesByTrait(trait: string; database: array of Gene): array of Gene;\nvar\n  filtered: array of Gene;\n  j, k: integer;\nbegin\n  SetLength(filtered, Length(database));\n  j := 0;\n  for k := 0 to High(database) do\n  begin\n    if database[k].trait = trait then\n    begin\n      filtered[j] := database[k];\n      Inc(j);\n    end;\n  end;\n  SetLength(filtered, j);\n  FilterGenesByTrait := filtered;\nend;\n\nbegin\n  { Assume geneticDatabase is populated with data }\n  specificTrait := 'desiredTrait';\n  extractedGenes := FilterGenesByTrait(specificTrait, geneticDatabase);\n  \n  { Output or further processing of extractedGenes }\nend.\n```"
  },
  {
    "task": "Filter out all investments with a risk level below medium from a portfolio.",
    "code": "```pascal\nprogram FilterInvestments;\n\ntype\n  Investment = record\n    name: string;\n    riskLevel: string;\n  end;\n\nvar\n  portfolio: array[1..5] of Investment;\n  filteredPortfolio: array of Investment;\n  i, count: integer;\n\nfunction IsMediumOrAboveRisk(risk: string): boolean;\nbegin\n  IsMediumOrAboveRisk := (risk = 'medium') or (risk = 'high');\nend;\n\nbegin\n  portfolio[1].name := 'Investment A';\n  portfolio[1].riskLevel := 'low';\n  portfolio[2].name := 'Investment B';\n  portfolio[2].riskLevel := 'medium';\n  portfolio[3].name := 'Investment C';\n  portfolio[3].riskLevel := 'high';\n  portfolio[4].name := 'Investment D';\n  portfolio[4].riskLevel := 'medium';\n  portfolio[5].name := 'Investment E';\n  portfolio[5].riskLevel := 'low';\n\n  count := 0;\n  for i := 1 to Length(portfolio) do\n  begin\n    if IsMediumOrAboveRisk(portfolio[i].riskLevel) then\n    begin\n      count := count + 1;\n      SetLength(filteredPortfolio, count);\n      filteredPortfolio[count-1] := portfolio[i];\n    end;\n  end;\nend.\n```"
  },
  {
    "task": "Select all calls longer than five minutes from a call log.",
    "code": "```pascal\nprogram FilterCalls;\n\ntype\n  TCall = record\n    duration: Integer; // in minutes\n  end;\n\nvar\n  callLog: array of TCall;\n  longCalls: array of TCall;\n  i: Integer;\n\nfunction FilterCalls(log: array of TCall; minDuration: Integer): array of TCall;\nvar\n  filtered: array of TCall;\n  j: Integer;\nbegin\n  SetLength(filtered, 0);\n  for i := 0 to High(log) do\n  begin\n    if log[i].duration > minDuration then\n    begin\n      SetLength(filtered, Length(filtered) + 1);\n      filtered[High(filtered)] := log[i];\n    end;\n  end;\n  FilterCalls := filtered;\nend;\n\nbegin\n  // Example call log setup\n  SetLength(callLog, 3);\n  callLog[0].duration := 6;\n  callLog[1].duration := 4;\n  callLog[2].duration := 10;\n\n  longCalls := FilterCalls(callLog, 5);\n\n  // Output long calls\n  for i := 0 to High(longCalls) do\n  begin\n    writeln('Call duration: ', longCalls[i].duration);\n  end;\nend.\n```"
  }
]