[
  {
    "task": "Write a function that reads a file and handles the exception if the file is not found.",
    "code": "```pascal\nprogram FileExceptionHandling;\n\nuses\n  SysUtils;\n\nprocedure ReadFile(const FileName: string);\nvar\n  FileContent: TextFile;\n  Line: string;\nbegin\n  AssignFile(FileContent, FileName);\n  try\n    Reset(FileContent);\n    while not Eof(FileContent) do\n    begin\n      ReadLn(FileContent, Line);\n      WriteLn(Line);\n    end;\n    CloseFile(FileContent);\n  except\n    on E: EInOutError do\n      WriteLn('File not found: ', E.Message);\n  end;\nend;\n\nbegin\n  ReadFile('example.txt');\nend.\n```"
  },
  {
    "task": "Create a program that divides two numbers and catches any division by zero errors.",
    "code": "```pascal\nprogram DivideNumbers;\n\nuses SysUtils;\n\nvar\n  num1, num2, result: Real;\n\nbegin\n  Write('Enter the first number: ');\n  ReadLn(num1);\n  Write('Enter the second number: ');\n  ReadLn(num2);\n\n  try\n    result := num1 / num2;\n    WriteLn('Result: ', result:0:2);\n  except\n    on E: EDivByZero do\n      WriteLn('Error: Division by zero is not allowed.');\n  end;\nend.\n```"
  },
  {
    "task": "Design a function to parse an integer from a string and manage invalid input exceptions.",
    "code": "```pascal\nprogram ParseIntegerExample;\n\nuses\n  SysUtils;\n\nfunction ParseInteger(const str: string): Integer;\nbegin\n  try\n    Result := StrToInt(str);\n  except\n    on E: EConvertError do\n    begin\n      Writeln('Invalid input: ', str);\n      Result := 0; // You can change this to any default value as needed\n    end;\n  end;\nend;\n\nvar\n  input: string;\n  number: Integer;\nbegin\n  Write('Enter a number: ');\n  Readln(input);\n  number := ParseInteger(input);\n  Writeln('Parsed integer: ', number);\nend.\n```"
  },
  {
    "task": "Implement an API call and catch exceptions related to network errors or timeouts.",
    "code": "```pascal\nprogram APICallWithExceptionHandling;\n\nuses\n  SysUtils, fphttpclient;\n\nprocedure CallAPI;\nvar\n  HTTPClient: TFPHTTPClient;\n  Response: string;\nbegin\n  HTTPClient := TFPHTTPClient.Create(nil);\n  try\n    try\n      Response := HTTPClient.Get('http://example.com/api');\n      WriteLn('API Response: ', Response);\n    except\n      on E: EHTTPClient do\n        WriteLn('HTTP Error: ', E.Message);\n      on E: Exception do\n        WriteLn('General Error: ', E.Message);\n    end;\n  finally\n    HTTPClient.Free;\n  end;\nend;\n\nbegin\n  CallAPI;\nend.\n```"
  },
  {
    "task": "Develop a program that opens a database connection and handles any connection failure exceptions.",
    "code": "```pascal\nprogram DatabaseConnection;\n\nuses\n  SysUtils;\n\nprocedure OpenDatabaseConnection;\nbegin\n  // Simulating a database connection attempt\n  raise Exception.Create('Failed to connect to the database');\nend;\n\nbegin\n  try\n    OpenDatabaseConnection;\n  except\n    on E: Exception do\n      Writeln('An error occurred: ', E.Message);\n  end;\nend.\n```"
  },
  {
    "task": "Write a function that accesses an array by index and catches out-of-bounds exceptions.",
    "code": "```pascal\nprogram ArrayAccessWithExceptionHandling;\n\nuses\n  SysUtils;\n\nfunction AccessArray(arr: array of Integer; index: Integer): Integer;\nbegin\n  try\n    Result := arr[index];\n  except\n    on E: ERangeError do\n    begin\n      Writeln('Error: Index out of bounds.');\n      Result := -1; // or any other default value\n    end;\n  end;\nend;\n\nvar\n  numbers: array[0..4] of Integer = (10, 20, 30, 40, 50);\n  value: Integer;\nbegin\n  value := AccessArray(numbers, 6);\n  Writeln('Accessed value: ', value);\nend.\n```"
  },
  {
    "task": "Create a function that converts a string to a date object and manages format exceptions.",
    "code": "```pascal\nprogram StringToDateExample;\n\nuses\n  SysUtils, DateUtils;\n\nfunction StringToDate(const S: string): TDateTime;\nbegin\n  try\n    Result := StrToDate(S);\n  except\n    on E: EConvertError do\n    begin\n      Writeln('Invalid date format: ', E.Message);\n      Result := 0; // or some other default value\n    end;\n  end;\nend;\n\nvar\n  DateStr: string;\n  DateObj: TDateTime;\nbegin\n  DateStr := '2021-12-31'; // Example date string\n  DateObj := StringToDate(DateStr);\n  if DateObj <> 0 then\n    Writeln('Converted date: ', DateToStr(DateObj))\n  else\n    Writeln('Failed to convert date.');\nend.\n```"
  },
  {
    "task": "Design a program that writes data to a file and catches any file permission exceptions.",
    "code": "```pascal\nprogram FileWriteWithExceptionHandling;\n\nuses SysUtils;\n\nvar\n  MyFile: Text;\nbegin\n  try\n    AssignFile(MyFile, 'output.txt');\n    Rewrite(MyFile);\n    try\n      Writeln(MyFile, 'Hello, world!');\n    finally\n      CloseFile(MyFile);\n    end;\n  except\n    on E: EInOutError do\n      Writeln('File handling error occurred. Details: ', E.Message);\n  end;\nend.\n```"
  },
  {
    "task": "Implement a module that retrieves data from a URL and handles malformed URL exceptions.",
    "code": "```pascal\nprogram RetrieveDataFromURL;\n\nuses\n  SysUtils, Classes;\n\nprocedure GetDataFromURL(const URL: string);\nbegin\n  try\n    // Simulate a URL retrieval process\n    if (Pos('http://', URL) = 0) and (Pos('https://', URL) = 0) then\n      raise EConvertError.Create('Malformed URL: ' + URL);\n\n    // Simulated successful data retrieval\n    WriteLn('Data retrieved from URL: ', URL);\n    \n  except\n    on E: EConvertError do\n      WriteLn('Error: ', E.Message);\n    on E: Exception do\n      WriteLn('An unexpected error occurred: ', E.Message);\n  end;\nend;\n\nbegin\n  GetDataFromURL('http://example.com');\n  GetDataFromURL('invalid-url');\nend.\n```"
  },
  {
    "task": "Write a function to calculate the square root of a number and catch any negative input exceptions.",
    "code": "```pascal\nprogram SquareRootExceptionHandling;\n\nuses\n  SysUtils, Math;\n\nfunction SafeSqrt(x: Double): Double;\nbegin\n  try\n    if x < 0 then\n      raise Exception.Create('Negative input is not allowed');\n    Result := Sqrt(x);\n  except\n    on E: Exception do\n    begin\n      Writeln('Error: ', E.Message);\n      Result := 0.0;  // or any other appropriate error value\n    end;\n  end;\nend;\n\nvar\n  number: Double;\n  result: Double;\nbegin\n  Write('Enter a number: ');\n  Readln(number);\n  result := SafeSqrt(number);\n  Writeln('Square root: ', result:0:2);\nend.\n```"
  },
  {
    "task": "Develop a program that sends an email and manages exceptions for invalid email addresses.",
    "code": "```pascal\nprogram SendEmailWithExceptionHandling;\n\nuses\n  SysUtils;\n\ntype\n  EInvalidEmailException = class(Exception);\n\nprocedure ValidateEmail(const Email: string);\nbegin\n  if Pos('@', Email) = 0 then\n    raise EInvalidEmailException.Create('Invalid email address.');\nend;\n\nprocedure SendEmail(const Email: string);\nbegin\n  try\n    ValidateEmail(Email);\n    // Simulate sending email\n    WriteLn('Email sent to: ', Email);\n  except\n    on E: EInvalidEmailException do\n      WriteLn('Error: ', E.Message);\n    on E: Exception do\n      WriteLn('An unexpected error occurred: ', E.Message);\n  end;\nend;\n\nvar\n  Email: string;\nbegin\n  Write('Enter email address: ');\n  ReadLn(Email);\n  SendEmail(Email);\nend.\n```"
  },
  {
    "task": "Create a calculator application that handles invalid operations gracefully.",
    "code": "```pascal\nprogram Calculator;\n\nuses\n  SysUtils;\n\nvar\n  num1, num2, result: Real;\n  operation: Char;\n\nbegin\n  try\n    Write('Enter first number: ');\n    ReadLn(num1);\n    Write('Enter an operation (+, -, *, /): ');\n    ReadLn(operation);\n    Write('Enter second number: ');\n    ReadLn(num2);\n\n    case operation of\n      '+': result := num1 + num2;\n      '-': result := num1 - num2;\n      '*': result := num1 * num2;\n      '/': \n        begin\n          if num2 = 0 then\n            raise Exception.Create('Error: Division by zero.');\n          result := num1 / num2;\n        end;\n    else\n      raise Exception.Create('Error: Invalid operation.');\n    end;\n\n    WriteLn('Result: ', result:0:2);\n  except\n    on E: Exception do\n      WriteLn(E.Message);\n  end;\nend.\n```"
  },
  {
    "task": "Design a function that tries to parse JSON data and catches parsing errors.",
    "code": "```pascal\nuses\n  SysUtils, fpjson, jsonparser;\n\nfunction TryParseJSON(const JSONData: string): TJSONObject;\nbegin\n  Result := nil;\n  try\n    Result := TJSONObject(GetJSON(JSONData));\n  except\n    on E: EJSONParser do\n    begin\n      Writeln('JSON parsing error: ', E.Message);\n    end;\n  end;\nend;\n```"
  },
  {
    "task": "Implement a system that processes user input and handles any type conversion exceptions.",
    "code": "```pascal\nprogram ExceptionHandlingExample;\n\nuses\n  SysUtils;\n\nvar\n  userInput: string;\n  number: Integer;\n  conversionSuccessful: Boolean;\n\nbegin\n  Write('Enter a number: ');\n  ReadLn(userInput);\n  \n  conversionSuccessful := False;\n  \n  try\n    number := StrToInt(userInput);\n    conversionSuccessful := True;\n  except\n    on E: EConvertError do\n      WriteLn('Error: Invalid input. Please enter a valid integer.');\n  end;\n  \n  if conversionSuccessful then\n    WriteLn('You entered the number: ', number);\nend.\n```"
  },
  {
    "task": "Write a function that fetches data from a database and manages exceptions for missing records.",
    "code": "```pascal\nprogram DatabaseExceptionHandling;\n\nuses\n  SysUtils;\n\nfunction FetchDataFromDatabase(recordId: Integer): String;\nbegin\n  try\n    // Simulate fetching record from database\n    if recordId = 0 then\n      raise Exception.Create('Record not found');\n    \n    Result := 'Record Data for ID: ' + IntToStr(recordId);\n  except\n    on E: Exception do\n    begin\n      Writeln('Exception: ', E.Message);\n      Result := 'Error fetching data';\n    end;\n  end;\nend;\n\nvar\n  data: String;\nbegin\n  data := FetchDataFromDatabase(0);  // Attempt to fetch a non-existing record\n  Writeln('Fetched Data: ', data);\n  \n  data := FetchDataFromDatabase(1);  // Attempt to fetch an existing record\n  Writeln('Fetched Data: ', data);\nend.\n```"
  },
  {
    "task": "Create a program that connects to a remote server and handles authentication failure exceptions.",
    "code": "```pascal\nprogram ServerConnection;\n\nuses\n  SysUtils;\n\ntype\n  EAuthenticationFailure = class(Exception);\n\nprocedure ConnectToServer;\nbegin\n  // Simulate an authentication failure\n  raise EAuthenticationFailure.Create('Authentication failed.');\nend;\n\nbegin\n  try\n    ConnectToServer;\n  except\n    on E: EAuthenticationFailure do\n      Writeln('Error: ', E.Message);\n  end;\nend.\n```"
  },
  {
    "task": "Develop a function to download a file from the internet and handle file not found exceptions.",
    "code": "```pascal\nuses\n  SysUtils, IdHTTP;\n\nprocedure DownloadFile(const URL, FileName: string);\nvar\n  HTTP: TIdHTTP;\n  FileStream: TFileStream;\nbegin\n  HTTP := TIdHTTP.Create(nil);\n  try\n    FileStream := TFileStream.Create(FileName, fmCreate);\n    try\n      HTTP.Get(URL, FileStream);\n    except\n      on E: EIdHTTPProtocolException do\n        if E.ErrorCode = 404 then\n          Writeln('Error: File not found at ', URL)\n        else\n          Writeln('HTTP Error: ', E.Message);\n    end;\n  finally\n    FileStream.Free;\n    HTTP.Free;\n  end;\nend;\n```"
  },
  {
    "task": "Design a program that attempts to connect to an API and handles rate limit exceptions.",
    "code": "```pascal\nprogram APIConnection;\n\nuses\n  SysUtils;\n\ntype\n  ERateLimitException = class(Exception);\n\nprocedure ConnectToAPI;\nbegin\n  // Simulating the API connection and rate limit exception\n  if Random(10) < 3 then\n    raise ERateLimitException.Create('Rate limit exceeded');\nend;\n\nprocedure HandleConnection;\nbegin\n  try\n    ConnectToAPI;\n    Writeln('Connected to API successfully.');\n  except\n    on E: ERateLimitException do\n      Writeln('Error: ', E.Message);\n    on E: Exception do\n      Writeln('An unexpected error occurred: ', E.Message);\n  end;\nend;\n\nbegin\n  Randomize;\n  HandleConnection;\nend.\n```"
  },
  {
    "task": "Write a function that reads from a configuration file and manages key not found exceptions.",
    "code": "```pascal\nprogram ConfigReader;\n\nuses\n  SysUtils, Classes;\n\nfunction ReadConfigKey(const FileName, Key: string): string;\nvar\n  ConfigFile: TStringList;\n  i: Integer;\n  KeyValue: string;\nbegin\n  Result := '';\n  ConfigFile := TStringList.Create;\n  try\n    try\n      ConfigFile.LoadFromFile(FileName);\n      for i := 0 to ConfigFile.Count - 1 do\n      begin\n        if Pos(Key + '=', ConfigFile[i]) = 1 then\n        begin\n          KeyValue := Copy(ConfigFile[i], Length(Key) + 2, MaxInt);\n          Result := KeyValue;\n          Exit;\n        end;\n      end;\n      raise Exception.CreateFmt('Key \"%s\" not found in configuration file.', [Key]);\n    except\n      on E: Exception do\n      begin\n        Writeln('An error occurred: ', E.Message);\n      end;\n    end;\n  finally\n    ConfigFile.Free;\n  end;\nend;\n\nbegin\n  Writeln(ReadConfigKey('config.cfg', 'desiredKey'));\nend.\n```"
  },
  {
    "task": "Create an application that processes a list of tasks and catches any task execution exceptions.",
    "code": "```pascal\nprogram TaskProcessor;\n\nuses\n  SysUtils;\n\ntype\n  TTask = procedure;\n\nprocedure Task1;\nbegin\n  // Simulate a task that may succeed\n  Writeln('Task 1 executed successfully.');\nend;\n\nprocedure Task2;\nbegin\n  // Simulate a task that raises an exception\n  raise Exception.Create('Error executing Task 2.');\nend;\n\nprocedure ExecuteTask(Task: TTask);\nbegin\n  try\n    Task();\n  except\n    on E: Exception do\n      Writeln('Exception caught: ', E.Message);\n  end;\nend;\n\nvar\n  Tasks: array[1..2] of TTask;\n  I: Integer;\nbegin\n  Tasks[1] := @Task1;\n  Tasks[2] := @Task2;\n  \n  for I := Low(Tasks) to High(Tasks) do\n  begin\n    ExecuteTask(Tasks[I]);\n  end;\nend.\n```"
  },
  {
    "task": "Implement a program that performs batch processing and handles individual item processing exceptions.",
    "code": "```pascal\nprogram BatchProcessingWithExceptionHandling;\n\nuses\n  SysUtils;\n\nvar\n  items: array[1..5] of Integer;\n  i: Integer;\n\nprocedure ProcessItem(item: Integer);\nbegin\n  if item mod 2 = 0 then\n    raise Exception.Create('Error: Item is even, cannot process.');\n  Writeln('Processed item: ', item);\nend;\n\nbegin\n  items[1] := 1;\n  items[2] := 2;\n  items[3] := 3;\n  items[4] := 4;\n  items[5] := 5;\n\n  for i := 1 to Length(items) do\n  begin\n    try\n      ProcessItem(items[i]);\n    except\n      on E: Exception do\n        Writeln('Exception while processing item ', items[i], ': ', E.Message);\n    end;\n  end;\nend.\n```"
  },
  {
    "task": "Develop a function that performs mathematical operations and catches arithmetic exceptions.",
    "code": "```pascal\nprogram ArithmeticOperationsWithExceptionHandling;\n\nuses\n  SysUtils;\n\nfunction PerformOperation(a, b: Integer; op: Char): Real;\nbegin\n  try\n    case op of\n      '+': Result := a + b;\n      '-': Result := a - b;\n      '*': Result := a * b;\n      '/': begin\n             if b = 0 then\n               raise Exception.Create('Division by zero');\n             Result := a / b;\n           end;\n    else\n      raise Exception.Create('Invalid operation');\n    end;\n  except\n    on E: Exception do\n    begin\n      Writeln('An error occurred: ', E.Message);\n      Result := 0;\n    end;\n  end;\nend;\n\nvar\n  result: Real;\nbegin\n  result := PerformOperation(10, 0, '/');\n  Writeln('Result: ', result:0:2);\nend.\n```"
  },
  {
    "task": "Write a program that logs error messages when exceptions occur during data processing.",
    "code": "```pascal\nprogram ExceptionHandlingExample;\n\nuses\n  SysUtils;\n\nprocedure ProcessData;\nbegin\n  // Simulate a data processing procedure that can raise exceptions\n  raise Exception.Create('An error occurred during data processing.');\nend;\n\nprocedure LogError(ErrorMessage: string);\nbegin\n  // In a real application, this would write to a log file\n  WriteLn('Error: ', ErrorMessage);\nend;\n\nbegin\n  try\n    ProcessData;\n  except\n    on E: Exception do\n      LogError(E.Message);\n  end;\nend.\n```"
  },
  {
    "task": "Create a script that monitors system resources and handles exceptions when limits are exceeded.",
    "code": "```pascal\nprogram MonitorSystemResources;\n\nuses\n  SysUtils;\n\nvar\n  cpuUsage, memoryUsage: Integer;\n\nprocedure CheckSystemResources;\nbegin\n  try\n    // Simulate retrieving system resource usage\n    Randomize;\n    cpuUsage := Random(100); // Simulated CPU usage percentage\n    memoryUsage := Random(100); // Simulated Memory usage percentage\n\n    if cpuUsage > 80 then\n      raise Exception.Create('CPU usage limit exceeded.');\n\n    if memoryUsage > 80 then\n      raise Exception.Create('Memory usage limit exceeded.');\n      \n    Writeln('CPU Usage: ', cpuUsage, '%');\n    Writeln('Memory Usage: ', memoryUsage, '%');\n  except\n    on E: Exception do\n    begin\n      Writeln('Exception: ', E.Message);\n    end;\n  end;\nend;\n\nbegin\n  while True do\n  begin\n    CheckSystemResources;\n    Sleep(1000); // Wait for 1 second before checking again\n  end;\nend.\n```"
  },
  {
    "task": "Design a function that validates user input and manages any format exceptions.",
    "code": "```pascal\nprogram ValidateUserInput;\n\nuses\n  SysUtils;\n\nfunction ValidateInput(input: string): Boolean;\nbegin\n  try\n    // Attempt to convert the input to an integer\n    StrToInt(input);\n    Result := True; // If successful, input is valid\n  except\n    on E: EConvertError do\n    begin\n      // Handle any conversion errors (invalid format)\n      Writeln('Input format exception: ', E.Message);\n      Result := False; // Invalid input\n    end;\n  end;\nend;\n\nvar\n  userInput: string;\n  isValid: Boolean;\nbegin\n  Write('Enter a number: ');\n  Readln(userInput);\n  isValid := ValidateInput(userInput);\n  \n  if isValid then\n    Writeln('Valid input.')\n  else\n    Writeln('Invalid input.');\nend.\n```"
  },
  {
    "task": "Implement a service that interacts with third-party APIs and handles unexpected response exceptions.",
    "code": "```pascal\nprogram APIService;\n\nuses\n  SysUtils;\n\nprocedure CallThirdPartyAPI;\nbegin\n  // Simulate an API call that might throw an exception\n  if Random(2) = 0 then\n    raise Exception.Create('Unexpected response from API');\nend;\n\nprocedure ExecuteService;\nbegin\n  try\n    CallThirdPartyAPI;\n    Writeln('API call succeeded.');\n  except\n    on E: Exception do\n    begin\n      Writeln('An error occurred: ', E.Message);\n      // Handle the exception (e.g., log it, retry, etc.)\n    end;\n  end;\nend;\n\nbegin\n  Randomize;\n  ExecuteService;\nend.\n```"
  },
  {
    "task": "Write a function that uploads files to a server and handles exceptions for unsupported file types.",
    "code": "```pascal\nprogram FileUploader;\n\nuses\n  SysUtils;\n\ntype\n  EUnsupportedFileType = class(Exception);\n\nprocedure UploadFile(const FileName: string);\nbegin\n  if not (LowerCase(ExtractFileExt(FileName)) in ['.txt', '.jpg', '.png']) then\n    raise EUnsupportedFileType.Create('Unsupported file type: ' + FileName);\n  \n  // Code to upload the file goes here\n  Writeln('File uploaded successfully: ' + FileName);\nend;\n\nvar\n  FileName: string;\nbegin\n  FileName := 'example.docx'; // Change to test different files\n  try\n    UploadFile(FileName);\n  except\n    on E: EUnsupportedFileType do\n      Writeln('Error: ', E.Message);\n    on E: Exception do\n      Writeln('An unexpected error occurred: ', E.Message);\n  end;\nend.\n```"
  },
  {
    "task": "Create a program that simulates network traffic and manages packet loss exceptions.",
    "code": "```pascal\nprogram NetworkTrafficSimulation;\n\nuses\n  SysUtils;\n\nprocedure SimulateNetworkTraffic;\nvar\n  packetsSent, packetsLost: Integer;\n  randomValue: Double;\nbegin\n  packetsSent := 0;\n  packetsLost := 0;\n\n  Randomize;\n\n  while packetsSent < 100 do\n  begin\n    Inc(packetsSent);\n    randomValue := Random;\n    try\n      if randomValue < 0.1 then\n        raise Exception.Create('Packet lost');\n    except\n      on E: Exception do\n      begin\n        Inc(packetsLost);\n        Writeln('Exception: ', E.Message);\n      end;\n    end;\n  end;\n\n  Writeln('Total packets sent: ', packetsSent);\n  Writeln('Total packets lost: ', packetsLost);\nend;\n\nbegin\n  try\n    SimulateNetworkTraffic;\n  except\n    on E: Exception do\n      Writeln('An unexpected error occurred: ', E.Message);\n  end;\nend.\n```"
  },
  {
    "task": "Develop a function that processes XML data and catches any structural exceptions.",
    "code": "```pascal\nprogram XMLProcessing;\n\nuses\n  SysUtils, XMLRead, DOM;\n\nprocedure ProcessXMLData(const XMLData: string);\nvar\n  Doc: TXMLDocument;\nbegin\n  try\n    ReadXMLFile(Doc, XMLData);\n    try\n      // Process the XML document here\n    finally\n      Doc.Free;\n    end;\n  except\n    on E: EXMLReadError do\n      Writeln('XML structural exception caught: ', E.Message);\n    on E: Exception do\n      Writeln('General exception caught: ', E.Message);\n  end;\nend;\n\nbegin\n  ProcessXMLData('path_to_xml_file.xml');\nend.\n```"
  },
  {
    "task": "Design a program that handles exceptions when accessing environment variables.",
    "code": "```pascal\nprogram EnvVarExceptionHandling;\n\nuses\n  SysUtils;\n\nvar\n  envVarName: string;\n  envVarValue: string;\nbegin\n  writeln('Enter the environment variable name:');\n  readln(envVarName);\n  try\n    envVarValue := GetEnvironmentVariable(envVarName);\n    if envVarValue = '' then\n      raise Exception.Create('Environment variable not found.');\n    writeln('Value of ', envVarName, ': ', envVarValue);\n  except\n    on E: Exception do\n      writeln('An error occurred: ', E.Message);\n  end;\nend.\n```"
  },
  {
    "task": "Write a function that calculates factorial and manages exceptions for negative input values.",
    "code": "```pascal\nprogram FactorialExceptionHandling;\n\nuses SysUtils;\n\nfunction Factorial(n: Integer): Int64;\nbegin\n  if n < 0 then\n    raise Exception.Create('Negative input is not allowed for factorial calculation.');\n\n  if n = 0 then\n    Result := 1\n  else\n    Result := n * Factorial(n - 1);\nend;\n\nvar\n  num: Integer;\n  result: Int64;\nbegin\n  try\n    Write('Enter a number to calculate its factorial: ');\n    ReadLn(num);\n    result := Factorial(num);\n    WriteLn('Factorial of ', num, ' is ', result);\n  except\n    on E: Exception do\n      WriteLn('Error: ', E.Message);\n  end;\nend.\n```"
  },
  {
    "task": "Create a software tool that converts file formats and handles unsupported format exceptions.",
    "code": "```pascal\nprogram FileFormatConverter;\n\nuses\n  SysUtils;\n\nprocedure ConvertFileFormat(const InputFile, OutputFile, OutputFormat: string);\nbegin\n  try\n    if (OutputFormat <> 'txt') and (OutputFormat <> 'csv') then\n      raise Exception.Create('Unsupported format: ' + OutputFormat);\n\n    // Simulating file conversion process\n    Writeln('Converting ', InputFile, ' to ', OutputFile, ' as ', OutputFormat, ' format.');\n    // Actual conversion logic would be implemented here\n\n  except\n    on E: Exception do\n    begin\n      Writeln('Error: ', E.Message);\n    end;\n  end;\nend;\n\nbegin\n  ConvertFileFormat('example.docx', 'output.txt', 'txt');\n  ConvertFileFormat('example.docx', 'output.pdf', 'pdf'); // This will trigger an exception\nend.\n```"
  },
  {
    "task": "Implement a function that sends HTTP requests and catches exceptions for invalid response status codes.",
    "code": "```pascal\nuses\n  SysUtils, fphttpclient, fpjson;\n\nfunction SendHttpRequest(const URL: string): string;\nvar\n  HttpClient: TFPHTTPClient;\nbegin\n  HttpClient := TFPHTTPClient.Create(nil);\n  try\n    try\n      Result := HttpClient.Get(URL);\n    except\n      on E: EHTTPClient do\n        if HttpClient.ResponseStatusCode <> 200 then\n          raise Exception.CreateFmt('Invalid response status code: %d', [HttpClient.ResponseStatusCode]);\n    end;\n  finally\n    HttpClient.Free;\n  end;\nend;\n```"
  },
  {
    "task": "Develop a program that interacts with a message queue and handles message delivery exceptions.",
    "code": "```pascal\nprogram MessageQueueHandler;\n\nuses\n  SysUtils;\n\ntype\n  EMessageDeliveryException = class(Exception);\n\nprocedure ConnectToMessageQueue;\nbegin\n  // Simulate connection to a message queue\n  WriteLn('Connected to message queue.');\nend;\n\nprocedure SendMessageToQueue(const Message: string);\nbegin\n  // Simulate a message delivery failure\n  raise EMessageDeliveryException.Create('Failed to deliver message: ' + Message);\nend;\n\nprocedure HandleMessageQueue;\nbegin\n  try\n    ConnectToMessageQueue;\n    SendMessageToQueue('Hello, World!');\n  except\n    on E: EMessageDeliveryException do\n      WriteLn('Error: ', E.Message);\n    on E: Exception do\n      WriteLn('An unexpected error occurred: ', E.Message);\n  end;\nend;\n\nbegin\n  HandleMessageQueue;\nend.\n```"
  },
  {
    "task": "Write a function that reads user input and catches exceptions for unexpected data types.",
    "code": "```pascal\nprogram ExceptionHandlingExample;\n\nuses\n  SysUtils;\n\nfunction ReadIntegerInput: Integer;\nvar\n  userInput: string;\n  number: Integer;\nbegin\n  Write('Enter an integer: ');\n  ReadLn(userInput);\n  try\n    number := StrToInt(userInput);\n    Result := number;\n  except\n    on E: EConvertError do\n    begin\n      WriteLn('Error: Invalid input. Please enter a valid integer.');\n      Result := ReadIntegerInput;\n    end;\n  end;\nend;\n\nvar\n  userInput: Integer;\nbegin\n  userInput := ReadIntegerInput;\n  WriteLn('You entered: ', userInput);\nend.\n```"
  },
  {
    "task": "Create a system that processes transactions and manages exceptions for insufficient funds.",
    "code": "```pascal\nprogram TransactionSystem;\n\nuses\n  SysUtils;\n\ntype\n  EInsufficientFunds = class(Exception);\n\nprocedure ProcessTransaction(balance, amount: Double);\nbegin\n  if amount > balance then\n    raise EInsufficientFunds.Create('Insufficient funds for the transaction.');\n  balance := balance - amount;\n  WriteLn('Transaction successful. New balance: ', balance:0:2);\nend;\n\nvar\n  balance, amount: Double;\n\nbegin\n  balance := 1000.00; { Example starting balance }\n\n  try\n    Write('Enter transaction amount: ');\n    ReadLn(amount);\n    ProcessTransaction(balance, amount);\n  except\n    on E: EInsufficientFunds do\n      WriteLn('Error: ', E.Message);\n    on E: Exception do\n      WriteLn('An unexpected error occurred: ', E.Message);\n  end;\nend.\n```"
  },
  {
    "task": "Design a function that generates random numbers and handles exceptions when the range is invalid.",
    "code": "```pascal\nprogram RandomNumberGenerator;\n\nuses\n  SysUtils, Math;\n\nfunction GenerateRandomNumber(LowerBound, UpperBound: Integer): Integer;\nbegin\n  try\n    if LowerBound > UpperBound then\n      raise Exception.Create('Invalid range: LowerBound is greater than UpperBound');\n    Result := RandomRange(LowerBound, UpperBound + 1);\n  except\n    on E: Exception do\n    begin\n      WriteLn('Error: ', E.Message);\n      Result := -1; // or some default error value\n    end;\n  end;\nend;\n\nvar\n  RandomNumber: Integer;\nbegin\n  Randomize;\n  RandomNumber := GenerateRandomNumber(10, 5);\n  WriteLn('Generated number: ', RandomNumber);\nend.\n```"
  },
  {
    "task": "Implement a program that performs image processing and catches exceptions for unsupported file dimensions.",
    "code": "```pascal\nprogram ImageProcessing;\n\nuses\n  SysUtils;\n\ntype\n  EUnsupportedDimension = class(Exception);\n\nprocedure ProcessImage(width, height: Integer);\nbegin\n  if (width <= 0) or (height <= 0) then\n    raise EUnsupportedDimension.Create('Unsupported image dimensions');\n  writeln('Processing image with dimensions: ', width, 'x', height);\nend;\n\nvar\n  width, height: Integer;\nbegin\n  try\n    width := 1024;  // Example width\n    height := -768; // Example height, causing an exception\n    ProcessImage(width, height);\n  except\n    on E: EUnsupportedDimension do\n      writeln('Exception caught: ', E.Message);\n  end;\nend.\n```"
  },
  {
    "task": "Write a function that manipulates strings and manages exceptions for invalid operations.",
    "code": "```pascal\nprogram StringManipulation;\n\nuses SysUtils;\n\nfunction ManipulateString(input: string): string;\nbegin\n  try\n    if input = '' then\n      raise Exception.Create('Input string cannot be empty.');\n\n    // Example operation: reverse the string\n    Result := '';\n    for var i := Length(input) downto 1 do\n      Result := Result + input[i];\n      \n  except\n    on E: Exception do\n    begin\n      Writeln('An error occurred: ', E.Message);\n      Result := '';\n    end;\n  end;\nend;\n\nvar\n  str: string;\nbegin\n  // Example usage\n  str := 'Hello, World!';\n  Writeln('Original: ', str);\n  Writeln('Manipulated: ', ManipulateString(str));\n\n  // Example with an empty string to trigger exception\n  str := '';\n  Writeln('Original: ', str);\n  Writeln('Manipulated: ', ManipulateString(str));\nend.\n```"
  },
  {
    "task": "Create a script that automates tasks and handles exceptions for missing dependencies.",
    "code": "```pascal\nprogram TaskAutomation;\n\nuses\n  SysUtils;\n\nprocedure AutomateTask;\nbegin\n  writeln('Task started.');\n  // Simulate task automation here\n  writeln('Task completed successfully.');\nend;\n\nprocedure CheckDependencies;\nbegin\n  // Simulate dependency check\n  raise Exception.Create('Missing dependency detected.');\nend;\n\nbegin\n  try\n    CheckDependencies;\n    AutomateTask;\n  except\n    on E: Exception do\n      writeln('An error occurred: ', E.Message);\n  end;\nend.\n```"
  },
  {
    "task": "Develop a function that accesses nested data structures and manages key access exceptions.",
    "code": "```pascal\nprogram NestedDataAccess;\n\nuses SysUtils, Variants;\n\ntype\n  TData = Variant;\n\nfunction AccessNestedData(Data: TData; Keys: array of String): Variant;\nvar\n  i: Integer;\nbegin\n  Result := Data;\n  try\n    for i := 0 to High(Keys) do\n    begin\n      if VarIsType(Result, varUnknown) or not VarIsType(Result, varDispatch) then\n        raise Exception.CreateFmt('Invalid access for key: %s', [Keys[i]]);\n      Result := Result[Keys[i]];\n    end;\n  except\n    on E: Exception do\n    begin\n      Writeln('Exception: ', E.Message);\n      Result := Null;\n    end;\n  end;\nend;\n\nvar\n  Data: TData;\n  Result: Variant;\nbegin\n  // Example data structure\n  Data := VarArrayOf([\n    VarArrayOf(['key1', VarArrayOf(['key2', 'value'])])\n  ]);\n\n  // Access with valid keys\n  Result := AccessNestedData(Data, ['key1', 'key2']);\n  Writeln('Result: ', VarToStr(Result));\n\n  // Access with an invalid key\n  Result := AccessNestedData(Data, ['key1', 'invalidKey']);\n  Writeln('Result: ', VarToStr(Result));\nend.\n```"
  },
  {
    "task": "Design a program that synchronizes data between sources and handles data mismatch exceptions.",
    "code": "```pascal\nprogram DataSynchronization;\n\nuses\n  SysUtils;\n\nprocedure SynchronizeData;\nvar\n  sourceData, targetData: string;\nbegin\n  // Simulate data fetching\n  sourceData := 'Data from Source';\n  targetData := 'Data from Target';\n  \n  // Check for data mismatch\n  if sourceData <> targetData then\n    raise Exception.Create('Data mismatch exception: Sources do not match.');\n    \n  // If no exception, data is synchronized\n  WriteLn('Data synchronized successfully.');\nend;\n\nbegin\n  try\n    SynchronizeData;\n  except\n    on E: Exception do\n      WriteLn('Error: ', E.Message);\n  end;\nend.\n```"
  },
  {
    "task": "Write a function that interacts with hardware devices and handles connection failure exceptions.",
    "code": "```pascal\nprogram HardwareInteraction;\n\nuses SysUtils;\n\nprocedure ConnectToDevice;\nbegin\n  // Simulated code to interact with a hardware device\n  if Random(10) < 3 then\n    raise Exception.Create('Connection failed');\nend;\n\nprocedure HandleDeviceConnection;\nbegin\n  try\n    ConnectToDevice;\n    Writeln('Device connected successfully.');\n  except\n    on E: Exception do\n      Writeln('Error: ', E.Message);\n  end;\nend;\n\nbegin\n  Randomize;\n  HandleDeviceConnection;\nend.\n```"
  },
  {
    "task": "Create a tool that compresses files and manages exceptions for unsupported compression formats.",
    "code": "```pascal\nprogram FileCompressor;\n\nuses\n  SysUtils, Classes;\n\nprocedure CompressFile(const FileName: string);\nbegin\n  try\n    // Here we simulate the compression process\n    if ExtractFileExt(FileName) <> '.zip' then\n      raise Exception.Create('Unsupported compression format: ' + ExtractFileExt(FileName));\n      \n    // Simulate compression logic\n    WriteLn('Compressing file: ', FileName);\n    // Compression logic would go here\n    \n  except\n    on E: Exception do\n      WriteLn('Error: ', E.Message);\n  end;\nend;\n\nvar\n  FileName: string;\nbegin\n  Write('Enter the file name to compress: ');\n  ReadLn(FileName);\n  CompressFile(FileName);\nend.\n```"
  },
  {
    "task": "Implement a function that parses command-line arguments and handles missing argument exceptions.",
    "code": "```pascal\nprogram CommandLineParser;\n\nuses\n  SysUtils;\n\nprocedure ParseArguments;\nvar\n  Arg: string;\nbegin\n  try\n    if ParamCount < 1 then\n      raise Exception.Create('Missing command-line arguments.');\n\n    Arg := ParamStr(1);\n    WriteLn('Parsed argument: ', Arg);\n  except\n    on E: Exception do\n      WriteLn('Error: ', E.Message);\n  end;\nend;\n\nbegin\n  ParseArguments;\nend.\n```"
  },
  {
    "task": "Develop a program that simulates user interactions and manages timing exceptions.",
    "code": "```pascal\nprogram UserInteractionSimulator;\n\nuses\n  SysUtils;\n\nprocedure SimulateInteraction;\nbegin\n  // Simulating a user interaction\n  writeln('Simulating user interaction...');\n  // Raise an exception to simulate a timing issue\n  raise Exception.Create('Timing exception occurred during interaction.');\nend;\n\nbegin\n  try\n    SimulateInteraction;\n  except\n    on E: Exception do\n      writeln('Exception caught: ', E.Message);\n  end;\nend.\n```"
  },
  {
    "task": "Write a function that encrypts data and handles exceptions for unsupported encryption algorithms.",
    "code": "```pascal\nprogram EncryptDataWithExceptionHandling;\n\nuses\n  SysUtils;\n\ntype\n  EUnsupportedAlgorithm = class(Exception);\n\nfunction EncryptData(const Data: string; const Algorithm: string): string;\nbegin\n  try\n    if Algorithm = 'AES' then\n    begin\n      // Simulate AES encryption\n      Result := 'AES: ' + Data;\n    end\n    else if Algorithm = 'RSA' then\n    begin\n      // Simulate RSA encryption\n      Result := 'RSA: ' + Data;\n    end\n    else\n    begin\n      raise EUnsupportedAlgorithm.Create('Unsupported encryption algorithm: ' + Algorithm);\n    end;\n  except\n    on E: EUnsupportedAlgorithm do\n    begin\n      Writeln('Error: ', E.Message);\n      Result := '';\n    end;\n  end;\nend;\n\nvar\n  EncryptedData: string;\n\nbegin\n  EncryptedData := EncryptData('Hello, World!', 'AES');\n  Writeln('Encrypted Data: ', EncryptedData);\n\n  EncryptedData := EncryptData('Hello, World!', 'UnknownAlgo');\n  Writeln('Encrypted Data: ', EncryptedData);\nend.\n```"
  },
  {
    "task": "Create a system that aggregates data and manages exceptions for data inconsistency.",
    "code": "```pascal\nprogram DataAggregator;\n\nuses\n  SysUtils;\n\ntype\n  EDataInconsistencyException = class(Exception);\n\nprocedure AggregateData;\nvar\n  data: array of Integer;\n  i, sum: Integer;\nbegin\n  // Simulating data fetching\n  SetLength(data, 5);\n  data[0] := 10;\n  data[1] := 20;\n  data[2] := -1; // Simulating inconsistent data\n  data[3] := 30;\n  data[4] := 40;\n  \n  sum := 0;\n  try\n    for i := 0 to High(data) do\n    begin\n      if data[i] < 0 then\n        raise EDataInconsistencyException.Create('Data inconsistency detected at index ' + IntToStr(i));\n      sum := sum + data[i];\n    end;\n    Writeln('Total sum: ', sum);\n  except\n    on E: EDataInconsistencyException do\n    begin\n      Writeln('Error: ', E.Message);\n    end;\n  end;\nend;\n\nbegin\n  Writeln('Starting data aggregation...');\n  AggregateData;\n  Writeln('Data aggregation completed.');\nend.\n```"
  },
  {
    "task": "Design a program that processes real-time data streams and handles connection drop exceptions.",
    "code": "```pascal\nprogram RealTimeDataProcessor;\n\nuses\n  SysUtils;\n\nprocedure ProcessDataStream;\nbegin\n  try\n    // Simulate processing data from a stream\n    WriteLn('Processing data stream...');\n    // Simulate a connection drop exception\n    raise Exception.Create('Connection dropped');\n  except\n    on E: Exception do\n      WriteLn('An error occurred: ', E.Message);\n  end;\nend;\n\nbegin\n  WriteLn('Starting real-time data processor...');\n  ProcessDataStream;\n  WriteLn('Data processor finished.');\nend.\n```"
  },
  {
    "task": "Implement a function that performs scientific calculations and manages precision exceptions.",
    "code": "```pascal\nprogram ScientificCalculations;\n\nuses\n  SysUtils;\n\nfunction PerformCalculation(x: Double): Double;\nbegin\n  try\n    Result := 1.0 / x; // Example calculation\n  except\n    on E: EDivByZero do\n    begin\n      Writeln('Error: Division by zero');\n      Result := 0.0; // Handle exception with default value\n    end;\n    on E: EInvalidOp do\n    begin\n      Writeln('Error: Invalid operation');\n      Result := 0.0; // Handle exception with default value\n    end;\n    else\n    begin\n      Writeln('Error: An unexpected error occurred');\n      Result := 0.0; // Handle any other exceptions\n    end;\n  end;\nend;\n\nvar\n  value, result: Double;\n\nbegin\n  value := 0.0;\n  result := PerformCalculation(value);\n  Writeln('Result: ', result:0:2);\nend.\n```"
  },
  {
    "task": "Write a script that generates reports and handles exceptions for missing data sources.",
    "code": "```pascal\nprogram ReportGenerator;\n\nuses\n  SysUtils;\n\nprocedure GenerateReport;\nbegin\n  writeln('Generating report...');\n  // Simulate report generation\nend;\n\nprocedure HandleMissingDataSource;\nbegin\n  writeln('Error: Missing data source.');\nend;\n\nbegin\n  try\n    // Simulate checking for data source\n    if Random(2) = 0 then\n      raise Exception.Create('Data source missing');\n\n    GenerateReport;\n  except\n    on E: Exception do\n      HandleMissingDataSource;\n  end;\nend.\n```"
  },
  {
    "task": "Create a program that validates digital certificates and manages trust exceptions.",
    "code": "```pascal\nprogram CertificateValidator;\n\nuses\n  SysUtils;\n\ntype\n  ECertificateException = class(Exception);\n\nprocedure ValidateCertificate(cert: string);\nbegin\n  if cert = '' then\n    raise ECertificateException.Create('Invalid certificate: Empty certificate.');\n  // Simulate certificate validation logic\n  if cert = 'untrusted' then\n    raise ECertificateException.Create('Certificate is not trusted.');\nend;\n\nprocedure ManageTrustExceptions(cert: string);\nbegin\n  try\n    ValidateCertificate(cert);\n    Writeln('Certificate is valid and trusted.');\n  except\n    on E: ECertificateException do\n      Writeln('Trust Exception: ', E.Message);\n  end;\nend;\n\nvar\n  certificate: string;\nbegin\n  certificate := 'untrusted';  // Example of an untrusted certificate\n  ManageTrustExceptions(certificate);\n\n  certificate := '';  // Example of an invalid certificate\n  ManageTrustExceptions(certificate);\n\n  certificate := 'trusted';  // Example of a trusted certificate\n  ManageTrustExceptions(certificate);\nend.\n```"
  },
  {
    "task": "Develop a function that schedules tasks and handles exceptions for scheduling conflicts.",
    "code": "```pascal\nprogram TaskScheduler;\n\nuses\n  SysUtils;\n\ntype\n  ETaskConflictException = class(Exception);\n\nprocedure ScheduleTask(TaskID: Integer);\nbegin\n  // Example logic to detect a scheduling conflict\n  if TaskID = 1 then\n    raise ETaskConflictException.Create('Scheduling conflict detected for Task ID: ' + IntToStr(TaskID));\n\n  // Logic to schedule the task\n  Writeln('Task ', TaskID, ' scheduled successfully.');\nend;\n\nprocedure ScheduleTasks;\nvar\n  TaskID: Integer;\nbegin\n  for TaskID := 0 to 2 do\n  begin\n    try\n      ScheduleTask(TaskID);\n    except\n      on E: ETaskConflictException do\n        Writeln('Error scheduling task: ', E.Message);\n    end;\n  end;\nend;\n\nbegin\n  ScheduleTasks;\nend.\n```"
  },
  {
    "task": "Design a system that manages user sessions and handles session timeout exceptions.",
    "code": "```pascal\nprogram UserSessionManagement;\n\nuses\n  SysUtils, DateUtils;\n\ntype\n  ESessionTimeout = class(Exception);\n\n  TUserSession = class\n  private\n    FUserID: Integer;\n    FLastActivity: TDateTime;\n    FTimeoutMinutes: Integer;\n  public\n    constructor Create(UserID: Integer; TimeoutMinutes: Integer);\n    procedure UpdateActivity;\n    procedure CheckSession;\n  end;\n\nconstructor TUserSession.Create(UserID: Integer; TimeoutMinutes: Integer);\nbegin\n  FUserID := UserID;\n  FTimeoutMinutes := TimeoutMinutes;\n  UpdateActivity;\nend;\n\nprocedure TUserSession.UpdateActivity;\nbegin\n  FLastActivity := Now;\nend;\n\nprocedure TUserSession.CheckSession;\nbegin\n  if MinutesBetween(Now, FLastActivity) > FTimeoutMinutes then\n    raise ESessionTimeout.CreateFmt('Session for user %d has timed out.', [FUserID]);\nend;\n\nvar\n  Session: TUserSession;\n\nbegin\n  try\n    Session := TUserSession.Create(1, 30);\n    Writeln('Session created for user 1.');\n    // Simulate time passing by using sleep or other operations\n    // Sleep(1000); // Example: wait for 1 second\n    Session.CheckSession;\n    Writeln('Session is still active.');\n  except\n    on E: ESessionTimeout do\n      Writeln(E.Message);\n  end;\nend.\n```"
  },
  {
    "task": "Write a function that processes audio files and manages exceptions for unsupported audio formats.",
    "code": "```pascal\nprogram AudioProcessor;\n\nuses\n  SysUtils;\n\ntype\n  UnsupportedAudioFormatException = class(Exception);\n\nprocedure ProcessAudioFile(fileName: string);\nbegin\n  try\n    if not (LowerCase(ExtractFileExt(fileName)) in ['.mp3', '.wav', '.flac']) then\n      raise UnsupportedAudioFormatException.Create('Unsupported audio format: ' + fileName);\n\n    // Processing logic for supported audio files\n    Writeln('Processing audio file: ', fileName);\n  except\n    on E: UnsupportedAudioFormatException do\n      Writeln('Error: ', E.Message);\n    on E: Exception do\n      Writeln('An error occurred: ', E.Message);\n  end;\nend;\n\nbegin\n  ProcessAudioFile('track1.mp3');\n  ProcessAudioFile('track2.ogg'); // This will trigger an exception\nend.\n```"
  },
  {
    "task": "Create a service that sends notifications and handles exceptions for unreachable destinations.",
    "code": "```pascal\nprogram NotificationService;\n\nuses\n  SysUtils;\n\ntype\n  NotificationException = class(Exception);\n\nprocedure SendNotification(destination: string);\nbegin\n  if destination = '' then\n    raise NotificationException.Create('Destination is unreachable');\n  writeln('Notification sent to ', destination);\nend;\n\nprocedure Notify(destination: string);\nbegin\n  try\n    SendNotification(destination);\n  except\n    on E: NotificationException do\n      writeln('Error: ', E.Message);\n  end;\nend;\n\nbegin\n  Notify('user@example.com');\n  Notify('');\nend.\n```"
  },
  {
    "task": "Implement a program that performs data migration and manages data transformation exceptions.",
    "code": "```pascal\nprogram DataMigration;\n\nuses SysUtils;\n\nprocedure MigrateData;\nbegin\n  try\n    // Simulate data transformation\n    if Random(2) = 0 then\n      raise Exception.Create('Data transformation error');\n      \n    // Simulate successful data migration\n    WriteLn('Data migrated successfully');\n  except\n    on E: Exception do\n      WriteLn('Exception occurred: ', E.Message);\n  end;\nend;\n\nbegin\n  Randomize;\n  MigrateData;\nend.\n```"
  },
  {
    "task": "Develop a function that processes video files and handles codec compatibility exceptions.",
    "code": "```pascal\nprogram VideoProcessor;\n\nuses\n  SysUtils;\n\ntype\n  ECodecCompatibilityException = class(Exception);\n\nprocedure ProcessVideoFile(const FileName: string);\nbegin\n  try\n    // Simulate processing\n    if Pos('.unsupportedcodec', FileName) > 0 then\n      raise ECodecCompatibilityException.Create('Unsupported codec detected.');\n\n    WriteLn('Video file processed successfully: ', FileName);\n  except\n    on E: ECodecCompatibilityException do\n      WriteLn('Error processing video file: ', E.Message);\n  end;\nend;\n\nbegin\n  try\n    ProcessVideoFile('samplevideo.unsupportedcodec');\n    ProcessVideoFile('samplevideo.mp4');\n  except\n    on E: Exception do\n      WriteLn('An unexpected error occurred: ', E.Message);\n  end;\nend.\n```"
  },
  {
    "task": "Write a function that manages memory allocation and catches out-of-memory exceptions.",
    "code": "```pascal\nprogram MemoryAllocation;\n\nuses SysUtils;\n\nfunction AllocateMemory(Size: Integer): Pointer;\nbegin\n  try\n    GetMem(Result, Size);\n  except\n    on E: EOutOfMemory do\n    begin\n      Writeln('Out of memory error: ', E.Message);\n      Result := nil;\n    end;\n  end;\nend;\n\nvar\n  MemPointer: Pointer;\nbegin\n  MemPointer := AllocateMemory(1024);\n  if MemPointer <> nil then\n  begin\n    // Use the allocated memory\n    FreeMem(MemPointer);\n  end;\nend.\n```"
  },
  {
    "task": "Create a program that processes financial transactions and handles currency conversion exceptions.",
    "code": "```pascal\nprogram FinancialTransactions;\n\nuses\n  SysUtils;\n\ntype\n  ECurrencyConversionError = class(Exception);\n\nfunction ConvertCurrency(amount: Double; fromCurrency, toCurrency: String): Double;\nbegin\n  if (fromCurrency <> 'USD') or (toCurrency <> 'EUR') then\n    raise ECurrencyConversionError.Create('Currency conversion not supported for ' + fromCurrency + ' to ' + toCurrency);\n  Result := amount * 0.85;  // Example conversion rate\nend;\n\nprocedure ProcessTransaction(amount: Double; fromCurrency, toCurrency: String);\nvar\n  convertedAmount: Double;\nbegin\n  try\n    convertedAmount := ConvertCurrency(amount, fromCurrency, toCurrency);\n    Writeln('Converted Amount: ', convertedAmount:0:2, ' ', toCurrency);\n  except\n    on E: ECurrencyConversionError do\n      Writeln('Error: ', E.Message);\n  end;\nend;\n\nbegin\n  ProcessTransaction(100.0, 'USD', 'EUR');\n  ProcessTransaction(50.0, 'GBP', 'EUR');\nend.\n```"
  },
  {
    "task": "Design a function that interacts with cloud storage and manages access permission exceptions.",
    "code": "```pascal\nprogram CloudStorageAccess;\n\nuses\n  SysUtils;\n\ntype\n  EAccessPermissionException = class(Exception);\n\nfunction AccessCloudStorage: Boolean;\nbegin\n  try\n    // Simulate access attempt to cloud storage\n    // Raise an exception to simulate a permission error\n    raise EAccessPermissionException.Create('Access denied to cloud storage');\n    Result := True;  // Access granted\n  except\n    on E: EAccessPermissionException do\n    begin\n      Writeln('Exception caught: ', E.Message);\n      Result := False;  // Access denied\n    end;\n    on E: Exception do\n    begin\n      Writeln('Unexpected exception: ', E.Message);\n      Result := False;  // General failure\n    end;\n  end;\nend;\n\nbegin\n  if AccessCloudStorage then\n    Writeln('Access granted.')\n  else\n    Writeln('Access denied.');\nend.\n```"
  },
  {
    "task": "Implement a script that automates deployment and handles exceptions for missing configuration files.",
    "code": "```pascal\nprogram DeploymentAutomation;\n\nuses\n  SysUtils;\n\nprocedure Deploy;\nbegin\n  writeln('Deployment started...');\n  // Simulate deployment process\n  writeln('Deployment completed successfully.');\nend;\n\nprocedure LoadConfiguration;\nbegin\n  if not FileExists('config.cfg') then\n    raise Exception.Create('Configuration file not found.');\n  writeln('Configuration file loaded.');\nend;\n\nbegin\n  try\n    LoadConfiguration;\n    Deploy;\n  except\n    on E: Exception do\n      writeln('Error: ', E.Message);\n  end;\nend.\n```"
  },
  {
    "task": "Write a function that normalizes data and handles exceptions for invalid data ranges.",
    "code": "```pascal\nprogram NormalizeData;\n\nuses\n  SysUtils;\n\nfunction NormalizeValue(value, min, max: Double): Double;\nbegin\n  if min >= max then\n    raise Exception.Create('Invalid range: min should be less than max');\n  \n  if (value < min) or (value > max) then\n    raise Exception.Create('Value is out of the specified range');\n\n  NormalizeValue := (value - min) / (max - min);\nend;\n\nvar\n  normalized: Double;\nbegin\n  try\n    normalized := NormalizeValue(50, 0, 100);\n    WriteLn('Normalized value: ', normalized:0:2);\n  except\n    on E: Exception do\n      WriteLn('Error: ', E.Message);\n  end;\nend.\n```"
  },
  {
    "task": "Create a system that monitors application performance and handles threshold breach exceptions.",
    "code": "```pascal\nprogram PerformanceMonitor;\n\nuses\n  SysUtils;\n\ntype\n  EThresholdBreachException = class(Exception);\n\nprocedure MonitorPerformance(threshold: Integer; currentLoad: Integer);\nbegin\n  if currentLoad > threshold then\n    raise EThresholdBreachException.Create('Performance threshold breached!');\nend;\n\nvar\n  threshold, currentLoad: Integer;\nbegin\n  threshold := 80;\n  currentLoad := 85;  // Example load\n\n  try\n    MonitorPerformance(threshold, currentLoad);\n    WriteLn('Performance is within acceptable limits.');\n  except\n    on E: EThresholdBreachException do\n      WriteLn('Exception caught: ', E.Message);\n  end;\nend.\n```"
  },
  {
    "task": "Develop a program that processes social media data and manages API limit exceptions.",
    "code": "```pascal\nprogram SocialMediaDataProcessor;\n\nuses\n  SysUtils;\n\nprocedure ProcessData;\nbegin\n  // Simulate processing social media data\n  Writeln('Processing social media data...');\nend;\n\nprocedure HandleAPILimitException;\nbegin\n  Writeln('API limit exceeded. Please try again later.');\nend;\n\nprocedure ProcessSocialMediaData;\nbegin\n  try\n    // Simulate API call\n    Writeln('Calling social media API...');\n    // Simulate an API limit exception\n    raise Exception.Create('API limit exceeded');\n    ProcessData;\n  except\n    on E: Exception do\n    begin\n      if E.Message = 'API limit exceeded' then\n        HandleAPILimitException\n      else\n        Writeln('An unexpected error occurred: ', E.Message);\n    end;\n  end;\nend;\n\nbegin\n  ProcessSocialMediaData;\nend.\n```"
  },
  {
    "task": "Design a function that integrates with payment gateways and handles payment failure exceptions.",
    "code": "```pascal\nprogram PaymentGatewayIntegration;\n\nuses SysUtils;\n\ntype\n  EPaymentException = class(Exception);\n\nfunction ProcessPayment(amount: Double): Boolean;\nbegin\n  // Simulate payment gateway interaction\n  if amount <= 0 then\n    raise EPaymentException.Create('Invalid payment amount.');\n\n  // Simulate a possible payment failure\n  if Random(10) < 3 then\n    raise EPaymentException.Create('Payment processing failed at the gateway.');\n\n  Result := True;\nend;\n\nprocedure HandlePayment(amount: Double);\nbegin\n  try\n    if ProcessPayment(amount) then\n      WriteLn('Payment processed successfully.')\n    else\n      WriteLn('Payment failed.');\n  except\n    on E: EPaymentException do\n      WriteLn('Error: ', E.Message);\n  end;\nend;\n\nbegin\n  Randomize;\n  HandlePayment(100.0);\n  HandlePayment(0.0);\nend.\n```"
  },
  {
    "task": "Write a function that backs up data and handles exceptions for unavailable storage media.",
    "code": "```pascal\nprogram BackupData;\n\nuses\n  SysUtils;\n\nprocedure BackupData;\nbegin\n  try\n    // Simulate a backup process\n    WriteLn('Backing up data...');\n    // Raise an exception to simulate storage media being unavailable\n    raise Exception.Create('Storage media unavailable');\n  except\n    on E: Exception do\n    begin\n      // Handle the exception\n      WriteLn('Error: ', E.Message);\n    end;\n  end;\nend;\n\nbegin\n  BackupData;\nend.\n```"
  },
  {
    "task": "Create a tool that manages software updates and handles exceptions for version conflicts.",
    "code": "```pascal\nprogram SoftwareUpdateManager;\n\nuses\n  SysUtils;\n\nprocedure UpdateSoftware(currentVersion, newVersion: string);\nbegin\n  if currentVersion = newVersion then\n    raise Exception.Create('Version conflict: Software is already up-to-date.')\n  else\n    Writeln('Updating software from version ', currentVersion, ' to ', newVersion);\n  // Further update logic would go here\nend;\n\nvar\n  currentVersion, newVersion: string;\nbegin\n  currentVersion := '1.0.0';\n  newVersion := '1.0.0'; // Change this value to simulate different scenarios\n\n  try\n    UpdateSoftware(currentVersion, newVersion);\n  except\n    on E: Exception do\n      Writeln('Error: ', E.Message);\n  end;\nend.\n```"
  },
  {
    "task": "Implement a program that performs sentiment analysis and manages exceptions for ambiguous texts.",
    "code": "```pascal\nprogram SentimentAnalysis;\n\nuses\n  SysUtils;\n\nfunction AnalyzeSentiment(text: string): string;\nbegin\n  if Pos('happy', text) > 0 then\n    Result := 'Positive'\n  else if Pos('sad', text) > 0 then\n    Result := 'Negative'\n  else\n    raise Exception.Create('Ambiguous sentiment');\nend;\n\nvar\n  text: string;\n  sentiment: string;\nbegin\n  try\n    Write('Enter text for sentiment analysis: ');\n    ReadLn(text);\n    sentiment := AnalyzeSentiment(text);\n    WriteLn('Sentiment: ', sentiment);\n  except\n    on E: Exception do\n      WriteLn('Error: ', E.Message);\n  end;\nend.\n```"
  },
  {
    "task": "Develop a function that manages user authentication and handles credential mismatch exceptions.",
    "code": "```pascal\nprogram UserAuthentication;\n\nuses\n  SysUtils;\n\ntype\n  ECredentialMismatch = class(Exception);\n\nfunction AuthenticateUser(username, password: string): Boolean;\nbegin\n  try\n    if (username = 'admin') and (password = 'password123') then\n      Result := True\n    else\n      raise ECredentialMismatch.Create('Credential Mismatch');\n  except\n    on E: ECredentialMismatch do\n    begin\n      Writeln('Authentication failed: ', E.Message);\n      Result := False;\n    end;\n  end;\nend;\n\nvar\n  isAuthenticated: Boolean;\nbegin\n  isAuthenticated := AuthenticateUser('admin', 'wrongpassword');\n  if isAuthenticated then\n    Writeln('User authenticated successfully.')\n  else\n    Writeln('User authentication failed.');\nend.\n```"
  },
  {
    "task": "Write a program that processes geographic data and handles exceptions for invalid coordinates.",
    "code": "```pascal\nprogram GeoDataProcessor;\n\nuses\n  SysUtils;\n\nprocedure ProcessCoordinates(latitude, longitude: Double);\nbegin\n  if (latitude < -90) or (latitude > 90) then\n    raise Exception.Create('Invalid latitude: ' + FloatToStr(latitude));\n  if (longitude < -180) or (longitude > 180) then\n    raise Exception.Create('Invalid longitude: ' + FloatToStr(longitude));\n  WriteLn('Processing coordinates: Latitude ', latitude:0:2, ', Longitude ', longitude:0:2);\nend;\n\nvar\n  lat, lon: Double;\nbegin\n  try\n    Write('Enter latitude: ');\n    ReadLn(lat);\n    Write('Enter longitude: ');\n    ReadLn(lon);\n    ProcessCoordinates(lat, lon);\n  except\n    on E: Exception do\n      WriteLn('Error: ', E.Message);\n  end;\nend.\n```"
  },
  {
    "task": "Create a script that manages network configurations and handles exceptions for invalid syntax.",
    "code": "```pascal\nprogram NetworkConfigManager;\n\nuses\n  SysUtils;\n\nprocedure ManageNetworkConfig;\nbegin\n  // Simulate network configuration logic\n  Writeln('Configuring network...');\n  \n  // Simulate an error\n  raise Exception.Create('Invalid syntax in network configuration.');\nend;\n\nbegin\n  try\n    ManageNetworkConfig;\n  except\n    on E: Exception do\n      Writeln('Error: ', E.Message);\n  end;\nend.\n```"
  },
  {
    "task": "Design a function that processes biometric data and handles exceptions for sensor errors.",
    "code": "```pascal\nprogram BiometricDataProcessing;\n\nuses SysUtils;\n\nfunction ProcessBiometricData(data: string): string;\nbegin\n  try\n    if data = '' then\n      raise Exception.Create('Sensor error: no data received');\n    // Simulate processing of the biometric data\n    Result := 'Processed data: ' + data;\n  except\n    on E: Exception do\n      Result := 'Error: ' + E.Message;\n  end;\nend;\n\nvar\n  biometricData, result: string;\nbegin\n  biometricData := ''; // Example of biometric data input\n  result := ProcessBiometricData(biometricData);\n  Writeln(result);\nend.\n```"
  },
  {
    "task": "Implement a system that manages access control and handles exceptions for unauthorized access attempts.",
    "code": "```pascal\nprogram AccessControl;\n\nuses\n  SysUtils;\n\ntype\n  EUnauthorizedAccessException = class(Exception);\n\nprocedure CheckAccess(userLevel: Integer);\nbegin\n  if userLevel < 1 then\n    raise EUnauthorizedAccessException.Create('Unauthorized access attempt detected.');\nend;\n\nvar\n  userLevel: Integer;\nbegin\n  try\n    Write('Enter user access level (1 or higher required): ');\n    ReadLn(userLevel);\n    CheckAccess(userLevel);\n    WriteLn('Access granted.');\n  except\n    on E: EUnauthorizedAccessException do\n      WriteLn('Exception: ', E.Message);\n  end;\nend.\n```"
  },
  {
    "task": "Write a function that performs load balancing and handles exceptions for unreachable nodes.",
    "code": "```pascal\nprogram LoadBalancer;\n\nuses\n  SysUtils;\n\ntype\n  TNode = record\n    Address: string;\n    Reachable: Boolean;\n  end;\n\nfunction LoadBalance(Nodes: array of TNode): string;\nvar\n  i: Integer;\nbegin\n  try\n    for i := 0 to High(Nodes) do\n    begin\n      if Nodes[i].Reachable then\n      begin\n        Result := Nodes[i].Address;\n        Exit;\n      end;\n    end;\n    raise Exception.Create('No reachable nodes found.');\n  except\n    on E: Exception do\n    begin\n      Result := 'Error: ' + E.Message;\n    end;\n  end;\nend;\n\nvar\n  Nodes: array of TNode;\n  SelectedNode: string;\nbegin\n  SetLength(Nodes, 3);\n  Nodes[0].Address := '192.168.0.1';\n  Nodes[0].Reachable := False;\n  Nodes[1].Address := '192.168.0.2';\n  Nodes[1].Reachable := False;\n  Nodes[2].Address := '192.168.0.3';\n  Nodes[2].Reachable := True;\n\n  SelectedNode := LoadBalance(Nodes);\n  WriteLn('Selected Node: ', SelectedNode);\nend.\n```"
  },
  {
    "task": "Create a program that simulates virtual environments and manages resource allocation exceptions.",
    "code": "```pascal\nprogram VirtualEnvironmentSimulation;\n\nuses\n  SysUtils;\n\ntype\n  EResourceAllocationException = class(Exception);\n\nprocedure AllocateResources;\nbegin\n  // Simulate a resource allocation failure\n  raise EResourceAllocationException.Create('Resource allocation failed.');\nend;\n\nprocedure SimulateEnvironment;\nbegin\n  try\n    Writeln('Starting virtual environment simulation...');\n    AllocateResources;\n    Writeln('Resources allocated successfully.');\n  except\n    on E: EResourceAllocationException do\n      Writeln('Exception caught: ', E.Message);\n  end;\nend;\n\nbegin\n  SimulateEnvironment;\n  Writeln('Simulation complete.');\nend.\n```"
  },
  {
    "task": "Develop a tool that manages digital rights and handles exceptions for unauthorized content access.",
    "code": "```pascal\nprogram DigitalRightsManagement;\n\nuses SysUtils;\n\ntype\n  EUnauthorizedAccess = class(Exception);\n\nprocedure AccessContent(userAuthorized: Boolean);\nbegin\n  if not userAuthorized then\n    raise EUnauthorizedAccess.Create('Unauthorized access detected.');\n  Writeln('Content accessed successfully.');\nend;\n\nvar\n  userAuthorized: Boolean;\nbegin\n  userAuthorized := False; // Change to True to simulate authorized access\n\n  try\n    AccessContent(userAuthorized);\n  except\n    on E: EUnauthorizedAccess do\n      Writeln(E.Message);\n  end;\nend.\n```"
  },
  {
    "task": "Design a function that synchronizes clocks and handles exceptions for time drift.",
    "code": "```pascal\nprogram SynchronizeClocks;\n\nuses\n  SysUtils;\n\nprocedure SynchronizeClock;\nvar\n  IsSynchronized: Boolean;\nbegin\n  try\n    // Simulate synchronization logic\n    IsSynchronized := Random(10) > 2; // Random success/failure\n    if not IsSynchronized then\n      raise Exception.Create('Time drift detected');\n      \n    Writeln('Clocks synchronized successfully');\n  except\n    on E: Exception do\n      Writeln('Error during synchronization: ', E.Message);\n  end;\nend;\n\nbegin\n  Randomize;\n  SynchronizeClock;\nend.\n```"
  },
  {
    "task": "Write a script that manages system backups and handles exceptions for insufficient backup space.",
    "code": "```pascal\nprogram BackupManager;\n\nuses\n  SysUtils;\n\nprocedure PerformBackup;\nbegin\n  try\n    // Simulate backup process\n    if Random(2) = 0 then\n      raise Exception.Create('Insufficient backup space.');\n\n    // Backup successful\n    WriteLn('Backup completed successfully.');\n  except\n    on E: Exception do\n      WriteLn('Backup failed: ', E.Message);\n  end;\nend;\n\nbegin\n  Randomize;\n  PerformBackup;\nend.\n```"
  },
  {
    "task": "Create a program that processes natural language text and handles parsing exceptions.",
    "code": "```pascal\nprogram TextParser;\n\nuses\n  SysUtils;\n\nprocedure ParseText(text: string);\nbegin\n  try\n    // Simulate parsing logic\n    if text = '' then\n      raise Exception.Create('Parsing error: Text is empty');\n      \n    // More parsing logic here\n\n    writeln('Text parsed successfully');\n  except\n    on E: Exception do\n      writeln('An error occurred: ', E.Message);\n  end;\nend;\n\nvar\n  inputText: string;\nbegin\n  writeln('Enter text to parse: ');\n  readln(inputText);\n  ParseText(inputText);\nend.\n```"
  },
  {
    "task": "Implement a function that manages thread execution and handles race condition exceptions.",
    "code": "```pascal\nprogram ThreadManagement;\n\nuses\n  SysUtils, Classes;\n\ntype\n  TMyThread = class(TThread)\n  protected\n    procedure Execute; override;\n  end;\n\nprocedure TMyThread.Execute;\nbegin\n  try\n    Synchronize(\n      procedure\n      begin\n        // Simulate thread execution\n        WriteLn('Thread is executing.');\n      end\n    );\n  except\n    on E: Exception do\n      WriteLn('Exception caught: ', E.Message);\n  end;\nend;\n\nprocedure ManageThreads;\nvar\n  Thread1, Thread2: TMyThread;\nbegin\n  try\n    Thread1 := TMyThread.Create(False);\n    Thread2 := TMyThread.Create(False);\n    Thread1.WaitFor;\n    Thread2.WaitFor;\n  except\n    on E: Exception do\n      WriteLn('Exception during thread management: ', E.Message);\n  end;\nend;\n\nbegin\n  ManageThreads;\nend.\n```"
  },
  {
    "task": "Develop a system that integrates with IoT devices and handles connectivity exceptions.",
    "code": "```pascal\nprogram IoTDeviceIntegration;\n\nuses\n  SysUtils;\n\nprocedure ConnectToDevice(deviceId: string);\nbegin\n  // Simulate connectivity process\n  if deviceId = '' then\n    raise Exception.Create('Device ID is invalid or empty.');\n  Writeln('Connected to device: ', deviceId);\nend;\n\nprocedure HandleIoTDevices;\nvar\n  deviceIds: array of string;\n  i: Integer;\nbegin\n  deviceIds := ['Device1', '', 'Device3']; // Sample device IDs\n  for i := Low(deviceIds) to High(deviceIds) do\n  begin\n    try\n      ConnectToDevice(deviceIds[i]);\n    except\n      on E: Exception do\n        Writeln('Failed to connect to device: ', E.Message);\n    end;\n  end;\nend;\n\nbegin\n  HandleIoTDevices;\nend.\n```"
  },
  {
    "task": "Write a function that manages application logging and handles exceptions for log overflow.",
    "code": "```pascal\nprogram LogManager;\n\nuses\n  SysUtils;\n\nconst\n  MAX_LOG_SIZE = 1000;\n\ntype\n  ELogOverflow = class(Exception);\n\nvar\n  LogData: array of string;\n  LogCount: Integer;\n\nprocedure LogMessage(const Msg: string);\nbegin\n  if LogCount >= MAX_LOG_SIZE then\n    raise ELogOverflow.Create('Log overflow occurred');\n  SetLength(LogData, LogCount + 1);\n  LogData[LogCount] := Msg;\n  Inc(LogCount);\nend;\n\nprocedure HandleException(E: Exception);\nbegin\n  Writeln('Exception: ', E.Message);\nend;\n\nprocedure ManageLogging;\nbegin\n  try\n    LogMessage('New log entry');\n  except\n    on E: ELogOverflow do\n      HandleException(E);\n  end;\nend;\n\nbegin\n  LogCount := 0;\n  SetLength(LogData, 0);\n  ManageLogging;\nend.\n```"
  },
  {
    "task": "Create a tool that visualizes data and handles exceptions for unsupported visualization types.",
    "code": "```pascal\nprogram DataVisualizer;\n\nuses\n  SysUtils;\n\ntype\n  TVisualizationType = (vtBarChart, vtLineGraph, vtPieChart);\n\nprocedure VisualizeData(vizType: TVisualizationType);\nbegin\n  case vizType of\n    vtBarChart: WriteLn('Visualizing data as Bar Chart...');\n    vtLineGraph: WriteLn('Visualizing data as Line Graph...');\n    vtPieChart: WriteLn('Visualizing data as Pie Chart...');\n  else\n    raise Exception.Create('Unsupported visualization type!');\n  end;\nend;\n\nvar\n  vizType: TVisualizationType;\nbegin\n  try\n    vizType := vtPieChart; // Change this to test different visualizations\n    VisualizeData(vizType);\n  except\n    on E: Exception do\n      WriteLn('Error: ', E.Message);\n  end;\nend.\n```"
  },
  {
    "task": "Design a program that performs genetic algorithm simulations and manages exception for invalid mutations.",
    "code": "```pascal\nprogram GeneticAlgorithmSim;\n\nuses\n  SysUtils;\n\ntype\n  TChromosome = array of Integer;\n\nprocedure PerformMutation(var Chromosome: TChromosome);\nvar\n  i: Integer;\nbegin\n  // Simulate mutation by randomly adjusting genes\n  for i := Low(Chromosome) to High(Chromosome) do\n  begin\n    if Random < 0.1 then\n      Chromosome[i] := Chromosome[i] + Random(3) - 1; // Mutation step\n  end;\n  \n  // Check for invalid mutation\n  for i := Low(Chromosome) to High(Chromosome) do\n  begin\n    if (Chromosome[i] < 0) or (Chromosome[i] > 100) then\n      raise Exception.Create('Invalid mutation detected');\n  end;\nend;\n\nprocedure RunSimulation;\nvar\n  Chromosome: TChromosome;\n  i, PopulationSize: Integer;\nbegin\n  PopulationSize := 10;\n  SetLength(Chromosome, PopulationSize);\n  \n  // Initialize chromosomes\n  for i := 0 to PopulationSize - 1 do\n    Chromosome[i] := Random(101);\n  \n  try\n    PerformMutation(Chromosome);\n    Writeln('Mutation performed successfully.');\n  except\n    on E: Exception do\n      Writeln('Error: ', E.Message);\n  end;\nend;\n\nbegin\n  Randomize;\n  RunSimulation;\nend.\n```"
  },
  {
    "task": "Implement a function that manages distributed transactions and handles consistency exceptions.",
    "code": "```pascal\nprogram DistributedTransactionManager;\n\nuses SysUtils;\n\ntype\n  EConsistencyException = class(Exception);\n\nprocedure PerformTransaction;\nbegin\n  // Code to perform a transaction.\n  // Raise EConsistencyException if a consistency error occurs.\n  if Random < 0.5 then\n    raise EConsistencyException.Create('Consistency error during transaction.');\nend;\n\nprocedure ManageTransaction;\nbegin\n  try\n    PerformTransaction;\n    Writeln('Transaction completed successfully.');\n  except\n    on E: EConsistencyException do\n      Writeln('Exception caught: ', E.Message);\n    on E: Exception do\n      Writeln('An unexpected exception occurred: ', E.Message);\n  end;\nend;\n\nbegin\n  Randomize;\n  ManageTransaction;\nend.\n```"
  },
  {
    "task": "Write a function that handles secure communications and manages encryption key exceptions.",
    "code": "```pascal\nprogram SecureCommunications;\n\nuses\n  SysUtils;\n\ntype\n  EEncryptionKeyError = class(Exception);\n\nfunction SecureCommunicate(const Message, Key: string): string;\nbegin\n  try\n    if Key = '' then\n      raise EEncryptionKeyError.Create('Encryption key is missing.');\n      \n    // Imagine encryption logic here, simplified for this example\n    Result := 'EncryptedMessageWithKey:' + Key;\n\n  except\n    on E: EEncryptionKeyError do\n    begin\n      Writeln('Encryption Key Error: ', E.Message);\n      Result := '';\n    end;\n    on E: Exception do\n    begin\n      Writeln('General Error: ', E.Message);\n      Result := '';\n    end;\n  end;\nend;\n\nbegin\n  Writeln(SecureCommunicate('Hello World', ''));\nend.\n```"
  },
  {
    "task": "Create a system that processes sensor data and handles out-of-range value exceptions.",
    "code": "```pascal\nprogram SensorDataProcessing;\n\nuses\n  SysUtils;\n\ntype\n  EOutOfRangeException = class(Exception);\n\nprocedure ProcessSensorData(value: Integer);\nbegin\n  if (value < 0) or (value > 100) then\n    raise EOutOfRangeException.Create('Sensor value out of range: ' + IntToStr(value));\n\n  // Simulate processing the sensor data\n  Writeln('Processing sensor value: ', value);\nend;\n\nvar\n  sensorValues: array[1..5] of Integer = (10, 50, 150, 75, -10);\n  i: Integer;\nbegin\n  for i := 1 to Length(sensorValues) do\n  begin\n    try\n      ProcessSensorData(sensorValues[i]);\n    except\n      on E: EOutOfRangeException do\n        Writeln('Exception: ', E.Message);\n    end;\n  end;\nend.\n```"
  },
  {
    "task": "Develop a program that simulates weather patterns and handles model prediction exceptions.",
    "code": "```pascal\nprogram WeatherSimulation;\n\nuses\n  SysUtils;\n\nprocedure SimulateWeather;\nvar\n  prediction: Integer;\nbegin\n  Randomize;\n  prediction := Random(10); // Simulate a prediction from 0 to 9\n  if prediction > 7 then\n    raise Exception.Create('Prediction model failed: Unreliable prediction value.');\n  WriteLn('Weather prediction for today: ', prediction);\nend;\n\nbegin\n  try\n    SimulateWeather;\n  except\n    on E: Exception do\n      WriteLn('An error occurred: ', E.Message);\n  end;\nend.\n```"
  },
  {
    "task": "Design a function that manages API versioning and handles backward compatibility exceptions.",
    "code": "```pascal\nprogram APIVersioning;\n\nuses\n  SysUtils;\n\ntype\n  EVersionException = class(Exception);\n\nfunction GetAPIVersion(version: Integer): string;\nbegin\n  case version of\n    1: Result := 'API Version 1: Basic Features';\n    2: Result := 'API Version 2: Advanced Features';\n    3: Result := 'API Version 3: Pro Features';\n  else\n    raise EVersionException.Create('Unsupported API version: ' + IntToStr(version));\n  end;\nend;\n\nprocedure HandleAPIVersion(version: Integer);\nbegin\n  try\n    Writeln(GetAPIVersion(version));\n  except\n    on E: EVersionException do\n      Writeln('Exception: ', E.Message);\n  end;\nend;\n\nbegin\n  HandleAPIVersion(2);  // Supported version\n  HandleAPIVersion(4);  // Unsupported version\nend.\n```"
  },
  {
    "task": "Write a tool that converts character encodings and handles unsupported encoding exceptions.",
    "code": "```pascal\nprogram EncodingConverter;\n\nuses\n  SysUtils;\n\nprocedure ConvertEncoding(const InputStr: string; const SourceEncoding, TargetEncoding: string);\nvar\n  EncodedStr: string;\nbegin\n  try\n    // Dummy encoding conversion for demonstration\n    if (SourceEncoding = 'UTF-8') and (TargetEncoding = 'ISO-8859-1') then\n      EncodedStr := InputStr  // Simulated conversion\n    else\n      raise Exception.Create('Unsupported encoding conversion.');\n    \n    Writeln('Converted string: ', EncodedStr);\n  except\n    on E: Exception do\n      Writeln('Error: ', E.Message);\n  end;\nend;\n\nbegin\n  try\n    ConvertEncoding('Sample text', 'UTF-8', 'ISO-8859-1');\n    ConvertEncoding('Sample text', 'UTF-8', 'Unsupported-Encoding');\n  except\n    on E: Exception do\n      Writeln('Unhandled exception: ', E.Message);\n  end;\nend.\n```"
  },
  {
    "task": "Create a program that handles dynamic content generation and manages template parsing exceptions.",
    "code": "```pascal\nprogram DynamicContentGenerator;\n\nuses\n  SysUtils;\n\nprocedure ParseTemplate(template: string);\nbegin\n  if template = '' then\n    raise Exception.Create('Template cannot be empty');\n\n  // Simulate parsing logic\n  if Pos('<%ERROR%>', template) > 0 then\n    raise Exception.Create('Error parsing template');\nend;\n\nprocedure GenerateContent(template: string);\nbegin\n  try\n    ParseTemplate(template);\n    Writeln('Content generated successfully: ', template);\n  except\n    on E: Exception do\n      Writeln('An error occurred: ', E.Message);\n  end;\nend;\n\nvar\n  template: string;\n\nbegin\n  template := 'Hello, <%ERROR%> World!';\n  GenerateContent(template);\n\n  template := 'Hello, World!';\n  GenerateContent(template);\nend.\n```"
  },
  {
    "task": "Implement a script that schedules automated tests and handles exceptions for missing test cases.",
    "code": "```pascal\nprogram TestScheduler;\n\nuses\n  SysUtils;\n\nprocedure RunTest(testName: string);\nbegin\n  if testName = '' then\n    raise Exception.Create('Missing test case');\n\n  // Placeholder for actual test execution logic\n  WriteLn('Running test: ', testName);\nend;\n\nprocedure ScheduleTests;\nvar\n  testNames: array of string;\n  i: Integer;\nbegin\n  // Example test names, with an intentional missing test case\n  testNames := ['Test1', '', 'Test3'];\n\n  for i := 0 to High(testNames) do\n  begin\n    try\n      RunTest(testNames[i]);\n    except\n      on E: Exception do\n        WriteLn('Error: ', E.Message);\n    end;\n  end;\nend;\n\nbegin\n  ScheduleTests;\nend.\n```"
  },
  {
    "task": "Develop a system that manages virtual machine instances and handles provisioning exceptions.",
    "code": "```pascal\nprogram VirtualMachineManager;\n\nuses\n  SysUtils;\n\ntype\n  EProvisioningException = class(Exception);\n\nprocedure ProvisionVM;\nbegin\n  // Simulate a provisioning error\n  raise EProvisioningException.Create('Provisioning failed: insufficient resources');\nend;\n\nprocedure ManageVMs;\nbegin\n  try\n    ProvisionVM;\n  except\n    on E: EProvisioningException do\n      Writeln('Error: ', E.Message);\n  end;\nend;\n\nbegin\n  Writeln('Starting VM management system...');\n  ManageVMs;\n  Writeln('VM management system finished.');\nend.\n```"
  },
  {
    "task": "Write a function that processes credit scores and handles exceptions for missing credit history.",
    "code": "```pascal\nprogram CreditScoreProcessor;\n\nuses\n  SysUtils;\n\nfunction ProcessCreditScore(creditScore: Integer): String;\nbegin\n  try\n    if creditScore < 0 then\n      raise Exception.Create('Missing credit history');\n      \n    if creditScore >= 750 then\n      Result := 'Excellent'\n    else if creditScore >= 700 then\n      Result := 'Good'\n    else if creditScore >= 650 then\n      Result := 'Fair'\n    else\n      Result := 'Poor';\n  except\n    on E: Exception do\n      Result := 'Error: ' + E.Message;\n  end;\nend;\n\nvar\n  score: Integer;\n  resultMessage: String;\n\nbegin\n  score := -1;  // Example score for testing\n  resultMessage := ProcessCreditScore(score);\n  WriteLn('Credit score processing result: ', resultMessage);\nend.\n```"
  },
  {
    "task": "Create a tool that manages digital certificates and handles expiration exceptions.",
    "code": "```pascal\nprogram CertificateManager;\n\nuses\n  SysUtils, DateUtils;\n\ntype\n  ECertificateExpired = class(Exception);\n\n  TCertificate = record\n    Name: string;\n    ExpirationDate: TDateTime;\n  end;\n\nprocedure CheckCertificate(const Cert: TCertificate);\nbegin\n  if Now > Cert.ExpirationDate then\n    raise ECertificateExpired.Create('Certificate has expired: ' + Cert.Name);\nend;\n\nvar\n  Cert: TCertificate;\nbegin\n  try\n    Cert.Name := 'My Digital Certificate';\n    Cert.ExpirationDate := EncodeDate(2023, 9, 15); // Example expiration date\n\n    CheckCertificate(Cert);\n    Writeln('Certificate is valid: ', Cert.Name);\n  except\n    on E: ECertificateExpired do\n      Writeln('Error: ', E.Message);\n    on E: Exception do\n      Writeln('An unexpected error occurred: ', E.Message);\n  end;\nend.\n```"
  },
  {
    "task": "Design a program that processes genome sequences and handles exceptions for sequence alignment.",
    "code": "```pascal\nprogram GenomeSequenceProcessor;\n\nuses\n  SysUtils;\n\ntype\n  ESequenceAlignmentError = class(Exception);\n\nfunction AlignSequences(seq1, seq2: string): string;\nbegin\n  if Length(seq1) <> Length(seq2) then\n    raise ESequenceAlignmentError.Create('Sequences must be of equal length for alignment.');\n\n  // Dummy alignment logic for demonstration\n  Result := seq1 + '|' + seq2;\nend;\n\nvar\n  sequence1, sequence2, alignedSequence: string;\nbegin\n  sequence1 := 'ATCG';\n  sequence2 := 'ATCGG'; // Unequal length to trigger exception\n\n  try\n    alignedSequence := AlignSequences(sequence1, sequence2);\n    Writeln('Aligned Sequence: ', alignedSequence);\n  except\n    on E: ESequenceAlignmentError do\n      Writeln('Sequence Alignment Error: ', E.Message);\n    on E: Exception do\n      Writeln('An unexpected error occurred: ', E.Message);\n  end;\nend.\n```"
  }
]