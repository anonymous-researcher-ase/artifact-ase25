[
  {
    "task": "Create a function that modifies the first element of an array passed to it. Explain how the changes are reflected in the original array.",
    "code": "```pascal\nprogram ModifyArrayElement;\n\nprocedure ModifyFirstElement(var arr: array of Integer);\nbegin\n  if Length(arr) > 0 then\n    arr[0] := 42;\nend;\n\nvar\n  numbers: array[1..5] of Integer = (1, 2, 3, 4, 5);\n  i: Integer;\nbegin\n  ModifyFirstElement(numbers);\n  for i := 1 to 5 do\n    WriteLn('Element ', i, ': ', numbers[i]);\nend.\n```"
  },
  {
    "task": "Design a function that swaps the values of two variables using pass-by-reference. Demonstrate how the swap affects the original variables.",
    "code": "```pascal\nprogram SwapExample;\n\nprocedure Swap(var a: Integer; var b: Integer);\nvar\n  temp: Integer;\nbegin\n  temp := a;\n  a := b;\n  b := temp;\nend;\n\nvar\n  x, y: Integer;\nbegin\n  x := 10;\n  y := 20;\n  \n  writeln('Before swap: x = ', x, ', y = ', y);\n  Swap(x, y);\n  writeln('After swap: x = ', x, ', y = ', y);\nend.\n```"
  },
  {
    "task": "Write a program that passes a large data structure to a function by value and by reference. Compare the performance and memory usage for both approaches.",
    "code": "```pascal\nprogram ParameterPassingDemo;\n\nuses\n  sysutils, DateUtils;\n\ntype\n  TLargeArray = array[1..10000] of Integer;\n\nvar\n  LargeData: TLargeArray;\n  StartTime, EndTime: TDateTime;\n\nprocedure InitializeArray(var Arr: TLargeArray);\nvar\n  I: Integer;\nbegin\n  for I := Low(Arr) to High(Arr) do\n    Arr[I] := Random(10000);\nend;\n\nprocedure ProcessByValue(Arr: TLargeArray);\nvar\n  Sum, I: Integer;\nbegin\n  Sum := 0;\n  for I := Low(Arr) to High(Arr) do\n    Sum := Sum + Arr[I];\nend;\n\nprocedure ProcessByReference(var Arr: TLargeArray);\nvar\n  Sum, I: Integer;\nbegin\n  Sum := 0;\n  for I := Low(Arr) to High(Arr) do\n    Sum := Sum + Arr[I];\nend;\n\nbegin\n  Randomize;\n  InitializeArray(LargeData);\n\n  StartTime := Now;\n  ProcessByValue(LargeData);\n  EndTime := Now;\n  WriteLn('Time taken for pass by value: ', MilliSecondsBetween(EndTime, StartTime), ' ms');\n\n  StartTime := Now;\n  ProcessByReference(LargeData);\n  EndTime := Now;\n  WriteLn('Time taken for pass by reference: ', MilliSecondsBetween(EndTime, StartTime), ' ms');\nend.\n```"
  },
  {
    "task": "Implement a function that accepts an integer and doubles its value. Show the difference in the original variable when using pass-by-value versus pass-by-reference.",
    "code": "```pascal\nprogram ParameterPassingDemo;\n\nprocedure DoubleValueByValue(value: Integer);\nbegin\n  value := value * 2;\nend;\n\nprocedure DoubleValueByReference(var value: Integer);\nbegin\n  value := value * 2;\nend;\n\nvar\n  originalValue, valueByValue, valueByReference: Integer;\nbegin\n  originalValue := 10;\n  \n  valueByValue := originalValue;\n  DoubleValueByValue(valueByValue);\n  writeln('Original value after pass-by-value: ', originalValue);\n  writeln('Value after pass-by-value: ', valueByValue);\n  \n  valueByReference := originalValue;\n  DoubleValueByReference(valueByReference);\n  writeln('Original value after pass-by-reference: ', originalValue);\n  writeln('Value after pass-by-reference: ', valueByReference);\nend.\n```"
  },
  {
    "task": "Create a function that takes a list and returns a new list with elements doubled. Ensure the original list remains unchanged.",
    "code": "```pascal\nprogram DoubleListElements;\n\ntype\n  TIntArray = array of Integer;\n\nfunction DoubleElements(const InputList: TIntArray): TIntArray;\nvar\n  i: Integer;\nbegin\n  SetLength(Result, Length(InputList));\n  for i := 0 to High(InputList) do\n  begin\n    Result[i] := InputList[i] * 2;\n  end;\nend;\n\nvar\n  OriginalList, NewList: TIntArray;\n  i: Integer;\nbegin\n  OriginalList := TIntArray.Create(1, 2, 3, 4, 5);\n  NewList := DoubleElements(OriginalList);\n\n  Write('Original list: ');\n  for i := 0 to High(OriginalList) do\n    Write(OriginalList[i], ' ');\n  Writeln;\n\n  Write('New list: ');\n  for i := 0 to High(NewList) do\n    Write(NewList[i], ' ');\n  Writeln;\nend.\n```"
  },
  {
    "task": "Design a function that takes a string argument and appends a character to it. Illustrate the result when the string is passed by value.",
    "code": "```pascal\nprogram AppendCharByValue;\n\nfunction AppendChar(s: string; c: char): string;\nbegin\n  AppendChar := s + c;\nend;\n\nvar\n  originalStr, resultStr: string;\nbegin\n  originalStr := 'Hello';\n  resultStr := AppendChar(originalStr, '!');\n  writeln('Original String: ', originalStr);\n  writeln('Result String: ', resultStr);\nend.\n```"
  },
  {
    "task": "Write a function that increments a counter variable. Pass the variable by reference to see changes in the original variable.",
    "code": "```pascal\nprogram IncrementCounter;\n\nprocedure Increment(var counter: Integer);\nbegin\n  counter := counter + 1;\nend;\n\nvar\n  myCounter: Integer;\nbegin\n  myCounter := 0;\n  Increment(myCounter);\n  WriteLn('Counter after increment: ', myCounter);\nend.\n```"
  },
  {
    "task": "Develop a function that removes an item from a dictionary passed to it. Demonstrate how pass-by-reference affects the original dictionary.",
    "code": "```pascal\nprogram RemoveItemFromDictionary;\n\ntype\n  TDictionary = record\n    Keys: array of string;\n    Values: array of string;\n    Count: Integer;\n  end;\n\nprocedure InitializeDictionary(var Dict: TDictionary);\nbegin\n  SetLength(Dict.Keys, 0);\n  SetLength(Dict.Values, 0);\n  Dict.Count := 0;\nend;\n\nprocedure AddItem(var Dict: TDictionary; Key, Value: string);\nbegin\n  SetLength(Dict.Keys, Dict.Count + 1);\n  SetLength(Dict.Values, Dict.Count + 1);\n  Dict.Keys[Dict.Count] := Key;\n  Dict.Values[Dict.Count] := Value;\n  Dict.Count := Dict.Count + 1;\nend;\n\nprocedure RemoveItem(var Dict: TDictionary; Key: string);\nvar\n  i, j: Integer;\nbegin\n  for i := 0 to Dict.Count - 1 do\n  begin\n    if Dict.Keys[i] = Key then\n    begin\n      for j := i to Dict.Count - 2 do\n      begin\n        Dict.Keys[j] := Dict.Keys[j + 1];\n        Dict.Values[j] := Dict.Values[j + 1];\n      end;\n      SetLength(Dict.Keys, Dict.Count - 1);\n      SetLength(Dict.Values, Dict.Count - 1);\n      Dict.Count := Dict.Count - 1;\n      Exit;\n    end;\n  end;\nend;\n\nprocedure PrintDictionary(var Dict: TDictionary);\nvar\n  i: Integer;\nbegin\n  for i := 0 to Dict.Count - 1 do\n  begin\n    WriteLn(Dict.Keys[i], ': ', Dict.Values[i]);\n  end;\nend;\n\nvar\n  MyDict: TDictionary;\nbegin\n  InitializeDictionary(MyDict);\n  AddItem(MyDict, 'apple', 'fruit');\n  AddItem(MyDict, 'carrot', 'vegetable');\n  WriteLn('Dictionary before removal:');\n  PrintDictionary(MyDict);\n  RemoveItem(MyDict, 'apple');\n  WriteLn('Dictionary after removal:');\n  PrintDictionary(MyDict);\nend.\n```"
  },
  {
    "task": "Create a program that passes a matrix to a function, which transposes it. Explain how the transposition affects the original matrix with pass-by-reference.",
    "code": "```pascal\nprogram TransposeMatrix;\n\ntype\n  Matrix = array of array of Integer;\n\nprocedure Transpose(var M: Matrix);\nvar\n  i, j: Integer;\n  temp: Matrix;\nbegin\n  SetLength(temp, Length(M[0]), Length(M));\n  for i := 0 to High(M) do\n    for j := 0 to High(M[0]) do\n      temp[j][i] := M[i][j];\n  M := temp;\nend;\n\nprocedure PrintMatrix(M: Matrix);\nvar\n  i, j: Integer;\nbegin\n  for i := 0 to High(M) do\n  begin\n    for j := 0 to High(M[i]) do\n      Write(M[i][j]:4);\n    Writeln;\n  end;\nend;\n\nvar\n  M: Matrix;\nbegin\n  SetLength(M, 3, 3);\n  M[0][0] := 1; M[0][1] := 2; M[0][2] := 3;\n  M[1][0] := 4; M[1][1] := 5; M[1][2] := 6;\n  M[2][0] := 7; M[2][1] := 8; M[2][2] := 9;\n\n  Writeln('Original Matrix:');\n  PrintMatrix(M);\n\n  Transpose(M);\n\n  Writeln('Transposed Matrix:');\n  PrintMatrix(M);\nend.\n```"
  },
  {
    "task": "Implement a function that takes a float number and rounds it. Discuss the implications of passing the number by value.",
    "code": "```pascal\nprogram RoundFloatExample;\n\nfunction RoundFloatByValue(x: Real): Integer;\nbegin\n  RoundFloatByValue := Round(x);\nend;\n\nvar\n  number: Real;\n  roundedNumber: Integer;\nbegin\n  number := 3.6;\n  roundedNumber := RoundFloatByValue(number);\n  WriteLn('Original number: ', number:0:1);\n  WriteLn('Rounded number: ', roundedNumber);\nend.\n```"
  },
  {
    "task": "Design a function that accepts a dictionary and adds a key-value pair to it. Show the changes when the dictionary is passed by reference.",
    "code": "```pascal\nprogram ParameterPassingExample;\n\ntype\n  TDictionary = record\n    keys: array of string;\n    values: array of string;\n  end;\n\nprocedure AddKeyValuePair(var dict: TDictionary; key, value: string);\nbegin\n  SetLength(dict.keys, Length(dict.keys) + 1);\n  SetLength(dict.values, Length(dict.values) + 1);\n  dict.keys[High(dict.keys)] := key;\n  dict.values[High(dict.values)] := value;\nend;\n\nprocedure PrintDictionary(const dict: TDictionary);\nvar\n  i: Integer;\nbegin\n  for i := 0 to High(dict.keys) do\n    WriteLn(dict.keys[i], ': ', dict.values[i]);\nend;\n\nvar\n  myDict: TDictionary;\nbegin\n  SetLength(myDict.keys, 0);\n  SetLength(myDict.values, 0);\n  \n  WriteLn('Dictionary before adding key-value pair:');\n  PrintDictionary(myDict);\n  \n  AddKeyValuePair(myDict, 'color', 'blue');\n  \n  WriteLn('Dictionary after adding key-value pair:');\n  PrintDictionary(myDict);\nend.\n```"
  },
  {
    "task": "Write a program that passes a string to a function that converts it to uppercase. Explain how this affects the original string with pass-by-value.",
    "code": "```pascal\nprogram UpperCaseConversion;\n\nuses\n  SysUtils;\n  \nfunction ToUpperCase(s: string): string;\nbegin\n  ToUpperCase := UpperCase(s);\nend;\n\nvar\n  originalStr, upperStr: string;\nbegin\n  originalStr := 'hello world';\n  upperStr := ToUpperCase(originalStr);\n  writeln('Original String: ', originalStr);\n  writeln('Uppercase String: ', upperStr);\nend.\n```"
  },
  {
    "task": "Create a function that receives a tuple and attempts to modify one of its elements. Discuss the outcome of using pass-by-value.",
    "code": "```pascal\nprogram TupleParameterPassing;\n\ntype\n  TTuple = record\n    First: Integer;\n    Second: Integer;\n  end;\n\nfunction ModifyTupleElement(aTuple: TTuple): TTuple;\nbegin\n  aTuple.First := aTuple.First + 10;\n  Result := aTuple;\nend;\n\nvar\n  OriginalTuple, ModifiedTuple: TTuple;\nbegin\n  OriginalTuple.First := 5;\n  OriginalTuple.Second := 15;\n\n  ModifiedTuple := ModifyTupleElement(OriginalTuple);\n\n  writeln('Original Tuple: (', OriginalTuple.First, ', ', OriginalTuple.Second, ')');\n  writeln('Modified Tuple: (', ModifiedTuple.First, ', ', ModifiedTuple.Second, ')');\nend.\n```"
  },
  {
    "task": "Develop a function that accepts an object and modifies one of its attributes. Illustrate how pass-by-reference alters the original object.",
    "code": "```pascal\nprogram ParameterPassingExample;\n\ntype\n  TMyObject = record\n    attribute: Integer;\n  end;\n\nprocedure ModifyAttribute(var obj: TMyObject);\nbegin\n  obj.attribute := obj.attribute + 10;\nend;\n\nvar\n  myObj: TMyObject;\nbegin\n  myObj.attribute := 5;\n  WriteLn('Before modification: ', myObj.attribute);\n  ModifyAttribute(myObj);\n  WriteLn('After modification: ', myObj.attribute);\nend.\n```"
  },
  {
    "task": "Design a function that outputs the sum of all elements in an array passed by value. Confirm the original array remains unchanged.",
    "code": "```pascal\nprogram SumArrayByValue;\n\ntype\n  TIntArray = array of Integer;\n\nfunction SumArray(arr: TIntArray): Integer;\nvar\n  i, sum: Integer;\nbegin\n  sum := 0;\n  for i := 0 to High(arr) do\n    sum := sum + arr[i];\n  SumArray := sum;\nend;\n\nvar\n  myArray: TIntArray;\n  result: Integer;\nbegin\n  myArray := TIntArray.Create(1, 2, 3, 4, 5);\n  result := SumArray(myArray);\n  WriteLn('Sum of the array elements: ', result);\nend.\n```"
  },
  {
    "task": "Write a function that takes a boolean flag and toggles its value. Demonstrate the effect of pass-by-reference on the original flag.",
    "code": "```pascal\nprogram ToggleBooleanFlag;\n\nprocedure ToggleFlag(var flag: Boolean);\nbegin\n  flag := not flag;\nend;\n\nvar\n  myFlag: Boolean;\nbegin\n  myFlag := True;\n  WriteLn('Original flag value: ', myFlag);\n  ToggleFlag(myFlag);\n  WriteLn('Toggled flag value: ', myFlag);\nend.\n```"
  },
  {
    "task": "Create a function that takes an object and clones it. Modify the clone and show that the original object remains unaffected.",
    "code": "```pascal\nprogram CloneObjectExample;\n\ntype\n  TObject = record\n    data: integer;\n  end;\n\nfunction Clone(original: TObject): TObject;\nbegin\n  Clone := original;\nend;\n\nprocedure Modify(var obj: TObject);\nbegin\n  obj.data := obj.data + 10;\nend;\n\nvar\n  original, cloneObj: TObject;\nbegin\n  original.data := 5;\n  cloneObj := Clone(original);\n  \n  Modify(cloneObj);\n  \n  writeln('Original object data: ', original.data);\n  writeln('Cloned object data: ', cloneObj.data);\nend.\n```"
  },
  {
    "task": "Implement a function that accepts a list of integers and removes all even numbers. Describe the difference in behavior when using pass-by-value and pass-by-reference.",
    "code": "```pascal\nprogram RemoveEvenNumbers;\n\ntype\n  TIntArray = array of Integer;\n\nprocedure RemoveEvenNumbersByValue(arr: TIntArray);\nvar\n  i, j: Integer;\n  temp: TIntArray;\nbegin\n  SetLength(temp, Length(arr));\n  j := 0;\n  for i := 0 to High(arr) do\n  begin\n    if arr[i] mod 2 <> 0 then\n    begin\n      temp[j] := arr[i];\n      Inc(j);\n    end;\n  end;\n  SetLength(temp, j);\n  arr := temp;\nend;\n\nprocedure RemoveEvenNumbersByReference(var arr: TIntArray);\nvar\n  i, j: Integer;\nbegin\n  j := 0;\n  for i := 0 to High(arr) do\n  begin\n    if arr[i] mod 2 <> 0 then\n    begin\n      arr[j] := arr[i];\n      Inc(j);\n    end;\n  end;\n  SetLength(arr, j);\nend;\n\nvar\n  numbers: TIntArray;\n  i: Integer;\nbegin\n  numbers := TIntArray.Create(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n\n  // Using pass-by-value\n  RemoveEvenNumbersByValue(numbers);\n  Write('After pass-by-value: ');\n  for i := 0 to High(numbers) do\n    Write(numbers[i], ' ');\n  WriteLn;\n\n  // Using pass-by-reference\n  numbers := TIntArray.Create(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n  RemoveEvenNumbersByReference(numbers);\n  Write('After pass-by-reference: ');\n  for i := 0 to High(numbers) do\n    Write(numbers[i], ' ');\n  WriteLn;\nend.\n```"
  },
  {
    "task": "Develop a function that takes a complex number and returns its conjugate. Explain how pass-by-value affects the original complex number.",
    "code": "```pascal\nprogram ComplexConjugate;\n\ntype\n  TComplex = record\n    RealPart: Double;\n    ImaginaryPart: Double;\n  end;\n\nfunction Conjugate(c: TComplex): TComplex;\nbegin\n  Conjugate.RealPart := c.RealPart;\n  Conjugate.ImaginaryPart := -c.ImaginaryPart;\nend;\n\nvar\n  original, result: TComplex;\nbegin\n  original.RealPart := 3.0;\n  original.ImaginaryPart := 4.0;\n  \n  result := Conjugate(original);\n\n  WriteLn('Original Complex Number: Real=', original.RealPart:0:2, ', Imaginary=', original.ImaginaryPart:0:2);\n  WriteLn('Conjugate Complex Number: Real=', result.RealPart:0:2, ', Imaginary=', result.ImaginaryPart:0:2);\nend.\n```"
  },
  {
    "task": "Design a program where a function receives a binary tree and inverts it. Discuss how pass-by-reference impacts the original tree structure.",
    "code": "```pascal\nprogram InvertBinaryTree;\n\ntype\n  PNode = ^TNode;\n  TNode = record\n    Data: Integer;\n    Left, Right: PNode;\n  end;\n\nprocedure InvertTree(var Root: PNode);\nvar\n  Temp: PNode;\nbegin\n  if Root = nil then\n    Exit;\n    \n  Temp := Root^.Left;\n  Root^.Left := Root^.Right;\n  Root^.Right := Temp;\n  \n  InvertTree(Root^.Left);\n  InvertTree(Root^.Right);\nend;\n\nprocedure InsertNode(var Root: PNode; Data: Integer);\nbegin\n  if Root = nil then\n  begin\n    New(Root);\n    Root^.Data := Data;\n    Root^.Left := nil;\n    Root^.Right := nil;\n  end\n  else if Data < Root^.Data then\n    InsertNode(Root^.Left, Data)\n  else\n    InsertNode(Root^.Right, Data);\nend;\n\nprocedure PrintInOrder(Root: PNode);\nbegin\n  if Root = nil then\n    Exit;\n  PrintInOrder(Root^.Left);\n  Write(Root^.Data, ' ');\n  PrintInOrder(Root^.Right);\nend;\n\nvar\n  Root: PNode;\nbegin\n  Root := nil;\n  InsertNode(Root, 4);\n  InsertNode(Root, 2);\n  InsertNode(Root, 7);\n  InsertNode(Root, 1);\n  InsertNode(Root, 3);\n  InsertNode(Root, 6);\n  InsertNode(Root, 9);\n  \n  Write('Original Tree (InOrder): ');\n  PrintInOrder(Root);\n  WriteLn;\n  \n  InvertTree(Root);\n  \n  Write('Inverted Tree (InOrder): ');\n  PrintInOrder(Root);\n  WriteLn;\nend.\n```"
  },
  {
    "task": "Write a function that adds an element to a set passed to it. Show how pass-by-reference affects the original set.",
    "code": "```pascal\nprogram AddElementToSet;\n\ntype\n  TIntegerSet = set of 1..100;\n\nprocedure AddElement(var s: TIntegerSet; element: Integer);\nbegin\n  s := s + [element];\nend;\n\nvar\n  mySet: TIntegerSet;\nbegin\n  mySet := [1, 2, 3];\n  writeln('Set before adding element: ', mySet);\n  AddElement(mySet, 4);\n  writeln('Set after adding element: ', mySet);\nend.\n```"
  },
  {
    "task": "Create a function that accepts an integer array and sorts it. Demonstrate the difference when the array is passed by value.",
    "code": "```pascal\nprogram SortArrayDemo;\n\nprocedure SortArray(var arr: array of Integer);\nvar\n  i, j, temp: Integer;\nbegin\n  for i := Low(arr) to High(arr) - 1 do\n    for j := i + 1 to High(arr) do\n      if arr[i] > arr[j] then\n      begin\n        temp := arr[i];\n        arr[i] := arr[j];\n        arr[j] := temp;\n      end;\nend;\n\nfunction CopyAndSortArray(arr: array of Integer): array of Integer;\nvar\n  i: Integer;\nbegin\n  SetLength(Result, Length(arr));\n  for i := Low(arr) to High(arr) do\n    Result[i] := arr[i];\n  SortArray(Result);\nend;\n\nprocedure PrintArray(arr: array of Integer);\nvar\n  i: Integer;\nbegin\n  for i := Low(arr) to High(arr) do\n    Write(arr[i], ' ');\n  Writeln;\nend;\n\nvar\n  originalArray, sortedArray: array of Integer;\nbegin\n  originalArray := [5, 3, 8, 1, 2];\n  \n  Writeln('Original array:');\n  PrintArray(originalArray);\n  \n  sortedArray := CopyAndSortArray(originalArray);\n  Writeln('Sorted copy (passed by value):');\n  PrintArray(sortedArray);\n  \n  Writeln('Original array after copy sorted:');\n  PrintArray(originalArray);\n  \n  SortArray(originalArray);\n  Writeln('Original array after sorting (passed by reference):');\n  PrintArray(originalArray);\nend.\n```"
  },
  {
    "task": "Implement a function that takes a configuration object and toggles a setting. Illustrate the changes with pass-by-reference.",
    "code": "```pascal\nprogram ToggleSettingDemo;\n\ntype\n  TConfig = record\n    SettingEnabled: Boolean;\n  end;\n\nprocedure ToggleSetting(var Config: TConfig);\nbegin\n  Config.SettingEnabled := not Config.SettingEnabled;\nend;\n\nvar\n  MyConfig: TConfig;\nbegin\n  { Initial state }\n  MyConfig.SettingEnabled := False;\n  WriteLn('Initial Setting: ', MyConfig.SettingEnabled);\n\n  { Toggle setting }\n  ToggleSetting(MyConfig);\n  WriteLn('Toggled Setting: ', MyConfig.SettingEnabled);\n\n  { Toggle setting again }\n  ToggleSetting(MyConfig);\n  WriteLn('Toggled Setting Again: ', MyConfig.SettingEnabled);\nend.\n```"
  },
  {
    "task": "Design a function that receives a file path and reads its content. Explain how passing the path by value affects the outcome.",
    "code": "```pascal\nprogram ReadFileContent;\n\nuses\n  SysUtils;\n\nprocedure ReadFile(const filePath: string);\nvar\n  fileContent: TextFile;\n  line: string;\nbegin\n  AssignFile(fileContent, filePath);\n  try\n    Reset(fileContent);\n    while not Eof(fileContent) do\n    begin\n      ReadLn(fileContent, line);\n      WriteLn(line);\n    end;\n  finally\n    CloseFile(fileContent);\n  end;\nend;\n\nvar\n  path: string;\nbegin\n  path := 'example.txt';\n  ReadFile(path);\nend.\n```"
  },
  {
    "task": "Write a program in which a function takes a stack and reverses its elements. Discuss the impact of pass-by-reference on the stack.",
    "code": "```pascal\nprogram ReverseStack;\n\ntype\n  TStack = record\n    items: array of Integer;\n    top: Integer;\n  end;\n\nprocedure InitStack(var S: TStack);\nbegin\n  SetLength(S.items, 0);\n  S.top := -1;\nend;\n\nprocedure Push(var S: TStack; value: Integer);\nbegin\n  Inc(S.top);\n  SetLength(S.items, S.top + 1);\n  S.items[S.top] := value;\nend;\n\nfunction Pop(var S: TStack): Integer;\nbegin\n  if S.top >= 0 then\n  begin\n    Result := S.items[S.top];\n    Dec(S.top);\n    SetLength(S.items, S.top + 1);\n  end\n  else\n    Result := -1;  // Error value\nend;\n\nprocedure ReverseStack(var S: TStack);\nvar\n  TempStack: TStack;\n  value: Integer;\nbegin\n  InitStack(TempStack);\n  while S.top >= 0 do\n  begin\n    value := Pop(S);\n    Push(TempStack, value);\n  end;\n  S := TempStack;\nend;\n\nprocedure PrintStack(S: TStack);\nvar\n  i: Integer;\nbegin\n  for i := 0 to S.top do\n    Write(S.items[i], ' ');\n  Writeln;\nend;\n\nvar\n  myStack: TStack;\nbegin\n  InitStack(myStack);\n  Push(myStack, 1);\n  Push(myStack, 2);\n  Push(myStack, 3);\n  Writeln('Original stack:');\n  PrintStack(myStack);\n\n  ReverseStack(myStack);\n  Writeln('Reversed stack:');\n  PrintStack(myStack);\nend.\n```"
  },
  {
    "task": "Create a function that takes a queue and dequeues an element. Show the result when the queue is passed by reference.",
    "code": "```pascal\nprogram QueueDemo;\n\ntype\n  QueueType = record\n    Items: array[1..100] of Integer;\n    Front, Rear: Integer;\n  end;\n\nprocedure InitializeQueue(var Q: QueueType);\nbegin\n  Q.Front := 1;\n  Q.Rear := 0;\nend;\n\nfunction IsEmpty(var Q: QueueType): Boolean;\nbegin\n  IsEmpty := Q.Front > Q.Rear;\nend;\n\nprocedure Enqueue(var Q: QueueType; Element: Integer);\nbegin\n  Inc(Q.Rear);\n  Q.Items[Q.Rear] := Element;\nend;\n\nfunction Dequeue(var Q: QueueType; var Element: Integer): Boolean;\nbegin\n  if IsEmpty(Q) then\n    Dequeue := False\n  else\n  begin\n    Element := Q.Items[Q.Front];\n    Inc(Q.Front);\n    Dequeue := True;\n  end;\nend;\n\nvar\n  MyQueue: QueueType;\n  Element: Integer;\nbegin\n  InitializeQueue(MyQueue);\n  Enqueue(MyQueue, 10);\n  Enqueue(MyQueue, 20);\n  Enqueue(MyQueue, 30);\n  \n  if Dequeue(MyQueue, Element) then\n    WriteLn('Dequeued: ', Element)\n  else\n    WriteLn('Queue is empty');\nend.\n```"
  },
  {
    "task": "Develop a function that accepts a hashmap and updates a value for a specific key. Illustrate the effects of pass-by-reference.",
    "code": "```pascal\nprogram UpdateHashMap;\n\nuses\n  SysUtils, Generics.Collections;\n\ntype\n  TMyHashMap = TDictionary<string, string>;\n\nprocedure UpdateValue(var map: TMyHashMap; key: string; newValue: string);\nbegin\n  if map.ContainsKey(key) then\n    map[key] := newValue\n  else\n    map.Add(key, newValue);\nend;\n\nvar\n  myMap: TMyHashMap;\n  key, value: string;\nbegin\n  myMap := TMyHashMap.Create;\n  try\n    myMap.Add('apple', 'red');\n    myMap.Add('banana', 'yellow');\n\n    key := 'apple';\n    value := 'green';\n\n    UpdateValue(myMap, key, value);\n    WriteLn('Updated value for key \"', key, '\": ', myMap[key]);\n\n    key := 'banana';\n    value := 'brown';\n\n    UpdateValue(myMap, key, value);\n    WriteLn('Updated value for key \"', key, '\": ', myMap[key]);\n  finally\n    myMap.Free;\n  end;\nend.\n```"
  },
  {
    "task": "Design a function that receives a JSON object and adds a new property. Discuss the implications of modifying the object by reference.",
    "code": "```pascal\nprogram ModifyJsonObject;\n\nuses\n  SysUtils, fpjson;\n\nprocedure AddPropertyToJson(var jsonObj: TJSONObject; const key: string; const value: string);\nbegin\n  jsonObj.Add(key, value);\nend;\n\nvar\n  myJson: TJSONObject;\nbegin\n  myJson := TJSONObject.Create;\n  try\n    myJson.Add('existingKey', 'existingValue');\n    AddPropertyToJson(myJson, 'newKey', 'newValue');\n    WriteLn(myJson.AsJSON);\n  finally\n    myJson.Free;\n  end;\nend.\n```"
  },
  {
    "task": "Write a program where a function accepts a graph and adds a node. Explain how pass-by-reference affects the original graph structure.",
    "code": "```pascal\nprogram GraphAddNode;\n\ntype\n  NodePtr = ^Node;\n  Node = record\n    id: Integer;\n    next: NodePtr;\n  end;\n\n  Graph = record\n    head: NodePtr;\n  end;\n\nprocedure AddNode(var g: Graph; newId: Integer);\nvar\n  newNode: NodePtr;\nbegin\n  New(newNode);\n  newNode^.id := newId;\n  newNode^.next := g.head;\n  g.head := newNode;\nend;\n\nprocedure PrintGraph(g: Graph);\nvar\n  current: NodePtr;\nbegin\n  current := g.head;\n  while current <> nil do\n  begin\n    WriteLn('Node ID: ', current^.id);\n    current := current^.next;\n  end;\nend;\n\nvar\n  myGraph: Graph;\nbegin\n  myGraph.head := nil;\n  AddNode(myGraph, 1);\n  AddNode(myGraph, 2);\n  AddNode(myGraph, 3);\n  \n  WriteLn('Graph structure after adding nodes:');\n  PrintGraph(myGraph);\nend.\n```"
  },
  {
    "task": "Create a function that accepts a set of coordinates and shifts them. Demonstrate how pass-by-value ensures the original set is unchanged.",
    "code": "```pascal\nprogram ShiftCoordinates;\n\ntype\n  TCoordinate = record\n    x: Integer;\n    y: Integer;\n  end;\n\nfunction Shift(coord: TCoordinate; deltaX, deltaY: Integer): TCoordinate;\nbegin\n  Shift.x := coord.x + deltaX;\n  Shift.y := coord.y + deltaY;\nend;\n\nvar\n  originalCoord, shiftedCoord: TCoordinate;\nbegin\n  originalCoord.x := 10;\n  originalCoord.y := 15;\n\n  shiftedCoord := Shift(originalCoord, 5, -3);\n\n  WriteLn('Original Coordinates: (', originalCoord.x, ', ', originalCoord.y, ')');\n  WriteLn('Shifted Coordinates: (', shiftedCoord.x, ', ', shiftedCoord.y, ')');\nend.\n```"
  },
  {
    "task": "Implement a function that takes a date object and sets it to the next day. Discuss the effects of pass-by-reference on the date object.",
    "code": "```pascal\nprogram NextDayExample;\n\ntype\n  TDate = record\n    Year: Integer;\n    Month: Integer;\n    Day: Integer;\n  end;\n\nprocedure SetNextDay(var ADate: TDate);\nvar\n  DaysInMonth: array[1..12] of Integer = (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31);\nbegin\n  { Check for leap year }\n  if (ADate.Year mod 4 = 0) and ((ADate.Year mod 100 <> 0) or (ADate.Year mod 400 = 0)) then\n    DaysInMonth[2] := 29;\n\n  Inc(ADate.Day);\n\n  if ADate.Day > DaysInMonth[ADate.Month] then\n  begin\n    ADate.Day := 1;\n    Inc(ADate.Month);\n    if ADate.Month > 12 then\n    begin\n      ADate.Month := 1;\n      Inc(ADate.Year);\n    end;\n  end;\nend;\n\nvar\n  Date: TDate;\nbegin\n  Date.Year := 2023;\n  Date.Month := 10;\n  Date.Day := 31;\n\n  SetNextDay(Date);\n  WriteLn('Next day: ', Date.Year, '-', Date.Month, '-', Date.Day);\nend.\n```"
  },
  {
    "task": "Develop a function that receives a polynomial represented as a list of coefficients and differentiates it. Show how the original list remains unchanged with pass-by-value.",
    "code": "```pascal\nprogram DifferentiatePolynomial;\n\ntype\n  CoefficientsArray = array of Integer;\n\nfunction Differentiate(coeffs: CoefficientsArray): CoefficientsArray;\nvar\n  i: Integer;\nbegin\n  SetLength(Result, Length(coeffs) - 1);\n  for i := 0 to High(Result) do\n    Result[i] := coeffs[i + 1] * (i + 1);\nend;\n\nprocedure PrintPolynomial(coeffs: CoefficientsArray);\nvar\n  i: Integer;\nbegin\n  for i := 0 to High(coeffs) do\n  begin\n    Write(coeffs[i]);\n    if i < High(coeffs) then\n      Write('x^', i);\n    if i < High(coeffs) - 1 then\n      Write(' + ');\n  end;\n  Writeln;\nend;\n\nvar\n  originalPoly, derivedPoly: CoefficientsArray;\nbegin\n  originalPoly := CoefficientsArray.Create(3, 2, 1); { Represents 3 + 2x + x^2 }\n  \n  Write('Original Polynomial: ');\n  PrintPolynomial(originalPoly);\n\n  derivedPoly := Differentiate(originalPoly);\n  \n  Write('Differentiated Polynomial: ');\n  PrintPolynomial(derivedPoly);\n\n  Write('Original Polynomial after differentiation: ');\n  PrintPolynomial(originalPoly);\nend.\n```"
  },
  {
    "task": "Design a function that accepts a stack and clears it. Explain how pass-by-reference affects the original stack.",
    "code": "```pascal\nprogram ClearStackExample;\n\ntype\n  Stack = record\n    items: array of Integer;\n    top: Integer;\n  end;\n\nprocedure InitializeStack(var s: Stack);\nbegin\n  SetLength(s.items, 0);\n  s.top := -1;\nend;\n\nfunction IsEmpty(var s: Stack): Boolean;\nbegin\n  IsEmpty := s.top = -1;\nend;\n\nprocedure Push(var s: Stack; value: Integer);\nbegin\n  Inc(s.top);\n  if Length(s.items) <= s.top then\n    SetLength(s.items, s.top + 1);\n  s.items[s.top] := value;\nend;\n\nprocedure ClearStack(var s: Stack);\nbegin\n  SetLength(s.items, 0);\n  s.top := -1;\nend;\n\nvar\n  myStack: Stack;\nbegin\n  InitializeStack(myStack);\n  Push(myStack, 10);\n  Push(myStack, 20);\n  Push(myStack, 30);\n  \n  ClearStack(myStack);\nend.\n```"
  },
  {
    "task": "Write a function that takes a linked list and appends a new node. Demonstrate the impact of pass-by-reference on the list.",
    "code": "```pascal\nprogram LinkedListDemo;\n\ntype\n    PNode = ^TNode;\n    TNode = record\n        data: Integer;\n        next: PNode;\n    end;\n\nprocedure AppendNode(var head: PNode; value: Integer);\nvar\n    newNode, current: PNode;\nbegin\n    new(newNode);\n    newNode^.data := value;\n    newNode^.next := nil;\n    \n    if head = nil then\n        head := newNode\n    else\n    begin\n        current := head;\n        while current^.next <> nil do\n            current := current^.next;\n        current^.next := newNode;\n    end;\nend;\n\nprocedure PrintList(head: PNode);\nbegin\n    while head <> nil do\n    begin\n        WriteLn(head^.data);\n        head := head^.next;\n    end;\nend;\n\nvar\n    head: PNode;\nbegin\n    head := nil;\n    \n    AppendNode(head, 10);\n    AppendNode(head, 20);\n    AppendNode(head, 30);\n    \n    PrintList(head);\nend.\n```"
  },
  {
    "task": "Create a function that receives a URL and extracts the domain name. Discuss the effects of pass-by-value on the URL string.",
    "code": "```pascal\nprogram ExtractDomain;\n\nuses\n  SysUtils;\n\nfunction ExtractDomainFromURL(URL: string): string;\nvar\n  ProtocolEnd, DomainEnd: Integer;\nbegin\n  ProtocolEnd := Pos('://', URL);\n  if ProtocolEnd > 0 then\n    Delete(URL, 1, ProtocolEnd + 2);\n\n  DomainEnd := Pos('/', URL);\n  if DomainEnd > 0 then\n    Result := Copy(URL, 1, DomainEnd - 1)\n  else\n    Result := URL;\nend;\n\nvar\n  URL, Domain: string;\n\nbegin\n  URL := 'http://www.example.com/path';\n  Domain := ExtractDomainFromURL(URL);\n  Writeln('Domain: ', Domain);\nend.\n```"
  },
  {
    "task": "Implement a function that takes a priority queue and changes the priority of an element. Illustrate the effects using pass-by-reference.",
    "code": "```pascal\nprogram PriorityQueueDemo;\n\ntype\n  TElement = record\n    Value: Integer;\n    Priority: Integer;\n  end;\n\n  TPriorityQueue = array of TElement;\n\nprocedure ChangePriority(var Queue: TPriorityQueue; Index: Integer; NewPriority: Integer);\nbegin\n  if (Index >= 0) and (Index < Length(Queue)) then\n    Queue[Index].Priority := NewPriority;\nend;\n\nprocedure PrintQueue(const Queue: TPriorityQueue);\nvar\n  i: Integer;\nbegin\n  for i := 0 to High(Queue) do\n    WriteLn('Value: ', Queue[i].Value, ', Priority: ', Queue[i].Priority);\nend;\n\nvar\n  Queue: TPriorityQueue;\nbegin\n  SetLength(Queue, 3);\n  \n  Queue[0].Value := 1;\n  Queue[0].Priority := 3;\n  Queue[1].Value := 2;\n  Queue[1].Priority := 1;\n  Queue[2].Value := 3;\n  Queue[2].Priority := 2;\n  \n  WriteLn('Original Queue:');\n  PrintQueue(Queue);\n  \n  ChangePriority(Queue, 1, 5);\n  \n  WriteLn('Queue after changing priority of element at index 1:');\n  PrintQueue(Queue);\nend.\n```"
  },
  {
    "task": "Develop a function that accepts a circular buffer and reads an element. Explain how pass-by-reference influences the buffer.",
    "code": "```pascal\nprogram CircularBufferDemo;\n\ntype\n  TCircularBuffer = record\n    Buffer: array of Integer;\n    Head, Tail, Size, Capacity: Integer;\n  end;\n\nprocedure InitCircularBuffer(var Buf: TCircularBuffer; Capacity: Integer);\nbegin\n  SetLength(Buf.Buffer, Capacity);\n  Buf.Head := 0;\n  Buf.Tail := 0;\n  Buf.Size := 0;\n  Buf.Capacity := Capacity;\nend;\n\nprocedure Enqueue(var Buf: TCircularBuffer; Value: Integer);\nbegin\n  if Buf.Size < Buf.Capacity then\n  begin\n    Buf.Buffer[Buf.Tail] := Value;\n    Buf.Tail := (Buf.Tail + 1) mod Buf.Capacity;\n    Inc(Buf.Size);\n  end;\nend;\n\nfunction Dequeue(var Buf: TCircularBuffer): Integer;\nbegin\n  if Buf.Size > 0 then\n  begin\n    Result := Buf.Buffer[Buf.Head];\n    Buf.Head := (Buf.Head + 1) mod Buf.Capacity;\n    Dec(Buf.Size);\n  end\n  else\n    Result := -1; // or raise an error\nend;\n\nvar\n  Buffer: TCircularBuffer;\n  Element: Integer;\n\nbegin\n  InitCircularBuffer(Buffer, 5);\n  Enqueue(Buffer, 10);\n  Enqueue(Buffer, 20);\n  Enqueue(Buffer, 30);\n\n  Element := Dequeue(Buffer);\n  WriteLn('Dequeued Element: ', Element);\n  Element := Dequeue(Buffer);\n  WriteLn('Dequeued Element: ', Element);\nend.\n```"
  },
  {
    "task": "Design a program where a function receives a record and updates a field. Show how pass-by-reference affects the original record.",
    "code": "```pascal\nprogram UpdateRecordDemo;\n\ntype\n  TPerson = record\n    Name: string;\n    Age: Integer;\n  end;\n\nprocedure UpdateAge(var person: TPerson; newAge: Integer);\nbegin\n  person.Age := newAge;\nend;\n\nvar\n  person: TPerson;\nbegin\n  person.Name := 'Alice';\n  person.Age := 30;\n  \n  writeln('Before update: ', person.Name, ' is ', person.Age, ' years old.');\n  \n  UpdateAge(person, 35);\n  \n  writeln('After update: ', person.Name, ' is ', person.Age, ' years old.');\nend.\n```"
  },
  {
    "task": "Write a function that takes a frequency list and normalizes it. Describe how pass-by-value ensures the original list remains unchanged.",
    "code": "```pascal\nprogram NormalizeFrequency;\n\ntype\n  TFloatArray = array of Real;\n\nfunction NormalizeList(const freqList: TFloatArray): TFloatArray;\nvar\n  total, sum: Real;\n  i: Integer;\nbegin\n  sum := 0.0;\n  for i := Low(freqList) to High(freqList) do\n    sum := sum + freqList[i];\n\n  SetLength(Result, Length(freqList));\n  if sum <> 0 then\n  begin\n    for i := Low(freqList) to High(freqList) do\n      Result[i] := freqList[i] / sum;\n  end;\nend;\n\nvar\n  frequencies, normalized: TFloatArray;\nbegin\n  frequencies := TFloatArray.Create(1.0, 2.0, 3.0, 4.0, 5.0);\n  normalized := NormalizeList(frequencies);\n\n  { Output result for demonstration purposes }\n  WriteLn('Original Frequencies: ');\n  for var i := Low(frequencies) to High(frequencies) do\n    WriteLn(frequencies[i]:0:2);\n\n  WriteLn('Normalized Frequencies: ');\n  for var i := Low(normalized) to High(normalized) do\n    WriteLn(normalized[i]:0:2);\nend.\n```"
  },
  {
    "task": "Create a function that accepts a chessboard and makes a move. Discuss how pass-by-reference alters the original board setup.",
    "code": "```pascal\nprogram ChessMove;\n\ntype\n  TChessBoard = array[1..8, 1..8] of char;\n\nprocedure MovePiece(var board: TChessBoard; startX, startY, endX, endY: Integer);\nbegin\n  board[endX, endY] := board[startX, startY];\n  board[startX, startY] := ' ';\nend;\n\nvar\n  chessBoard: TChessBoard;\nbegin\n  // Initialize the chessboard for demonstration\n  chessBoard[1, 1] := 'R'; // Example: Rook\n  chessBoard[1, 2] := 'N'; // Example: Knight\n  chessBoard[1, 3] := 'B'; // Example: Bishop\n  // ... Initialize other pieces as needed\n\n  // Make a move from (1, 1) to (2, 1)\n  MovePiece(chessBoard, 1, 1, 2, 1);\n\n  // The original chessBoard is altered here due to pass-by-reference\nend.\n```"
  },
  {
    "task": "Implement a function that takes a decimal number and converts it to binary. Explain the effects of pass-by-value on the original number.",
    "code": "```pascal\nprogram DecimalToBinary;\n\nfunction DecimalToBinary(n: Integer): String;\nvar\n  result: String;\n  remainder: Integer;\nbegin\n  result := '';\n  while n > 0 do\n  begin\n    remainder := n mod 2;\n    result := Chr(48 + remainder) + result;\n    n := n div 2;\n  end;\n  DecimalToBinary := result;\nend;\n\nvar\n  originalNumber: Integer;\n  binaryRepresentation: String;\nbegin\n  originalNumber := 10; // Example number\n  binaryRepresentation := DecimalToBinary(originalNumber);\n  WriteLn('Original number: ', originalNumber);\n  WriteLn('Binary representation: ', binaryRepresentation);\nend.\n```"
  },
  {
    "task": "Develop a function that receives a DNA sequence and counts nucleotides. Illustrate how pass-by-value ensures the original sequence remains intact.",
    "code": "```pascal\nprogram NucleotideCounter;\n\ntype\n  TNucleotideCounts = record\n    A: Integer;\n    C: Integer;\n    G: Integer;\n    T: Integer;\n  end;\n\nfunction CountNucleotides(dnaSequence: String): TNucleotideCounts;\nvar\n  i: Integer;\n  counts: TNucleotideCounts;\nbegin\n  counts.A := 0;\n  counts.C := 0;\n  counts.G := 0;\n  counts.T := 0;\n\n  for i := 1 to Length(dnaSequence) do\n  begin\n    case dnaSequence[i] of\n      'A': Inc(counts.A);\n      'C': Inc(counts.C);\n      'G': Inc(counts.G);\n      'T': Inc(counts.T);\n    end;\n  end;\n\n  CountNucleotides := counts;\nend;\n\nvar\n  originalSequence: String;\n  nucleotideCounts: TNucleotideCounts;\nbegin\n  originalSequence := 'AGCTAGCTAGCTA';\n  nucleotideCounts := CountNucleotides(originalSequence);\n  \n  WriteLn('Original Sequence: ', originalSequence);\n  WriteLn('A: ', nucleotideCounts.A);\n  WriteLn('C: ', nucleotideCounts.C);\n  WriteLn('G: ', nucleotideCounts.G);\n  WriteLn('T: ', nucleotideCounts.T);\nend.\n```"
  },
  {
    "task": "Design a function that accepts a shopping cart object and applies a discount. Show the changes with pass-by-reference.",
    "code": "```pascal\nprogram ShoppingCartDiscount;\n\ntype\n  TShoppingCart = record\n    TotalPrice: Real;\n  end;\n\nprocedure ApplyDiscount(var Cart: TShoppingCart; DiscountRate: Real);\nbegin\n  Cart.TotalPrice := Cart.TotalPrice * (1 - DiscountRate);\nend;\n\nvar\n  MyCart: TShoppingCart;\nbegin\n  MyCart.TotalPrice := 100.0;  // Example total price\n  ApplyDiscount(MyCart, 0.1);  // Applying a 10% discount\n  writeln('Total price after discount: ', MyCart.TotalPrice:0:2);\nend.\n```"
  },
  {
    "task": "Write a program where a function receives a playlist and adds a song. Discuss how pass-by-reference affects the original playlist.",
    "code": "```pascal\nprogram PlaylistManager;\n\ntype\n  TPlaylist = array of string;\n\nprocedure AddSong(var playlist: TPlaylist; song: string);\nvar\n  len: Integer;\nbegin\n  len := Length(playlist);\n  SetLength(playlist, len + 1);\n  playlist[len] := song;\nend;\n\nvar\n  myPlaylist: TPlaylist;\nbegin\n  SetLength(myPlaylist, 0);\n\n  AddSong(myPlaylist, 'Song 1');\n  AddSong(myPlaylist, 'Song 2');\n  AddSong(myPlaylist, 'Song 3');\n\n  // Output the playlist to show the songs have been added\n  for var i := 0 to High(myPlaylist) do\n    Writeln(myPlaylist[i]);\nend.\n```"
  },
  {
    "task": "Create a function that takes a sprite in a game and moves it. Demonstrate the result when the sprite is passed by reference.",
    "code": "```pascal\nprogram SpriteMovement;\n\ntype\n  TSprite = record\n    x, y: Integer;\n  end;\n\nprocedure MoveSprite(var sprite: TSprite; dx, dy: Integer);\nbegin\n  sprite.x := sprite.x + dx;\n  sprite.y := sprite.y + dy;\nend;\n\nvar\n  sprite: TSprite;\n\nbegin\n  sprite.x := 10;\n  sprite.y := 20;\n\n  WriteLn('Before moving: x = ', sprite.x, ', y = ', sprite.y);\n  \n  MoveSprite(sprite, 5, -3);\n  \n  WriteLn('After moving: x = ', sprite.x, ', y = ', sprite.y);\nend.\n```"
  },
  {
    "task": "Implement a function that accepts a book object and updates the title. Illustrate the impact of pass-by-reference on the original object.",
    "code": "```pascal\nprogram UpdateBookTitle;\n\ntype\n  TBook = record\n    Title: string;\n  end;\n\nprocedure UpdateTitle(var Book: TBook; NewTitle: string);\nbegin\n  Book.Title := NewTitle;\nend;\n\nvar\n  MyBook: TBook;\nbegin\n  MyBook.Title := 'Original Title';\n  writeln('Before update: ', MyBook.Title);\n  UpdateTitle(MyBook, 'Updated Title');\n  writeln('After update: ', MyBook.Title);\nend.\n```"
  },
  {
    "task": "Develop a function that receives a sound wave and normalizes it. Explain how pass-by-value affects the original sound wave.",
    "code": "```pascal\nprogram NormalizeSoundWave;\n\ntype\n  TSoundWave = array of real;\n\nfunction NormalizeWave(wave: TSoundWave): TSoundWave;\nvar\n  i: Integer;\n  maxVal, factor: real;\nbegin\n  maxVal := 0.0;\n  for i := 0 to High(wave) do\n  begin\n    if Abs(wave[i]) > maxVal then\n      maxVal := Abs(wave[i]);\n  end;\n\n  if maxVal = 0.0 then\n    factor := 1.0\n  else\n    factor := 1.0 / maxVal;\n\n  SetLength(Result, Length(wave));\n  for i := 0 to High(wave) do\n  begin\n    Result[i] := wave[i] * factor;\n  end;\nend;\n\nvar\n  originalWave, normalizedWave: TSoundWave;\nbegin\n  originalWave := TSoundWave.Create(0.5, -1.0, 0.75, -0.25);\n\n  normalizedWave := NormalizeWave(originalWave);\n\n  // Output the result\nend.\n```"
  },
  {
    "task": "Design a program where a function receives a bank account object and credits an amount. Discuss the effects of pass-by-reference.",
    "code": "```pascal\nprogram BankAccountCredit;\n\ntype\n  TBankAccount = record\n    Balance: Real;\n  end;\n\nprocedure CreditAmount(var Account: TBankAccount; Amount: Real);\nbegin\n  Account.Balance := Account.Balance + Amount;\nend;\n\nvar\n  MyAccount: TBankAccount;\n  Credit: Real;\nbegin\n  MyAccount.Balance := 1000.0;\n  Credit := 200.0;\n  CreditAmount(MyAccount, Credit);\n  WriteLn('New Balance: ', MyAccount.Balance:0:2);\nend.\n```"
  },
  {
    "task": "Write a function that takes an email list and filters out invalid addresses. Show the difference in the list when using pass-by-value.",
    "code": "```pascal\nprogram FilterEmails;\n\ntype\n  TEmailList = array of string;\n\nfunction IsValidEmail(const email: string): Boolean;\nvar\n  atPos: Integer;\nbegin\n  atPos := Pos('@', email);\n  Result := (atPos > 1) and (Pos('.', email, atPos) > atPos + 1);\nend;\n\nprocedure FilterInvalidEmailsByValue(emails: TEmailList);\nvar\n  i: Integer;\n  validEmails: TEmailList;\nbegin\n  SetLength(validEmails, 0);\n  for i := 0 to High(emails) do\n  begin\n    if IsValidEmail(emails[i]) then\n    begin\n      SetLength(validEmails, Length(validEmails) + 1);\n      validEmails[High(validEmails)] := emails[i];\n    end;\n  end;\n  emails := validEmails;\nend;\n\nprocedure PrintEmails(const emails: TEmailList);\nvar\n  i: Integer;\nbegin\n  for i := 0 to High(emails) do\n  begin\n    WriteLn(emails[i]);\n  end;\nend;\n\nvar\n  emailList: TEmailList;\nbegin\n  emailList := TEmailList.Create('user@example.com', 'invalid-email', 'another@domain.com');\n  WriteLn('Original Emails:');\n  PrintEmails(emailList);\n\n  FilterInvalidEmailsByValue(emailList);\n\n  WriteLn('Emails after Filtering (Pass-by-Value):');\n  PrintEmails(emailList);\nend.\n```"
  },
  {
    "task": "Create a function that accepts a 3D model and scales it. Demonstrate how pass-by-reference affects the original model.",
    "code": "```pascal\nprogram Scale3DModel;\n\ntype\n  TPoint3D = record\n    x, y, z: real;\n  end;\n\n  TModel3D = record\n    vertices: array of TPoint3D;\n  end;\n\nprocedure ScaleModel(var model: TModel3D; scaleFactor: real);\nvar\n  i: integer;\nbegin\n  for i := 0 to High(model.vertices) do\n  begin\n    model.vertices[i].x := model.vertices[i].x * scaleFactor;\n    model.vertices[i].y := model.vertices[i].y * scaleFactor;\n    model.vertices[i].z := model.vertices[i].z * scaleFactor;\n  end;\nend;\n\nvar\n  myModel: TModel3D;\n  i: integer;\nbegin\n  SetLength(myModel.vertices, 3);\n  \n  myModel.vertices[0].x := 1.0; myModel.vertices[0].y := 1.0; myModel.vertices[0].z := 1.0;\n  myModel.vertices[1].x := 2.0; myModel.vertices[1].y := 2.0; myModel.vertices[1].z := 2.0;\n  myModel.vertices[2].x := 3.0; myModel.vertices[2].y := 3.0; myModel.vertices[2].z := 3.0;\n\n  ScaleModel(myModel, 2.0);\n\n  for i := 0 to High(myModel.vertices) do\n  begin\n    WriteLn('Vertex ', i + 1, ': (', myModel.vertices[i].x:0:2, ', ', myModel.vertices[i].y:0:2, ', ', myModel.vertices[i].z:0:2, ')');\n  end;\nend.\n```"
  },
  {
    "task": "Implement a function that receives a text document and redacts sensitive information. Explain the impact of pass-by-reference.",
    "code": "```pascal\nprogram RedactSensitiveInfo;\n\ntype\n  TStringArray = array of string;\n\nprocedure Redact(var document: TStringArray);\nvar\n  i: Integer;\nbegin\n  for i := 0 to High(document) do\n  begin\n    if Pos('sensitive', document[i]) > 0 then\n      document[i] := 'REDACTED';\n  end;\nend;\n\nvar\n  doc: TStringArray;\n  i: Integer;\nbegin\n  SetLength(doc, 3);\n  doc[0] := 'This is a sensitive document.';\n  doc[1] := 'Handle with care.';\n  doc[2] := 'sensitive information is present.';\n\n  Redact(doc);\n\n  for i := 0 to High(doc) do\n    Writeln(doc[i]);\nend.\n```"
  },
  {
    "task": "Develop a function that takes a temperature reading and adjusts for calibration. Discuss how pass-by-value ensures the original reading is unchanged.",
    "code": "```pascal\nprogram TemperatureAdjustment;\n\nfunction AdjustTemperature(reading: Real; calibration: Real): Real;\nbegin\n  AdjustTemperature := reading + calibration;\nend;\n\nvar\n  originalReading, adjustedReading, calibrationValue: Real;\nbegin\n  originalReading := 25.0;  // Example temperature reading\n  calibrationValue := 1.5;  // Example calibration value\n\n  adjustedReading := AdjustTemperature(originalReading, calibrationValue);\n\n  writeln('Original Reading: ', originalReading:0:2);\n  writeln('Adjusted Reading: ', adjustedReading:0:2);\nend.\n```"
  },
  {
    "task": "Design a function that accepts a bug report and updates its status. Show the changes with pass-by-reference.",
    "code": "```pascal\nprogram BugReportUpdate;\n\ntype\n  TBugReport = record\n    ID: Integer;\n    Description: String;\n    Status: String;\n  end;\n\nprocedure UpdateBugStatus(var Report: TBugReport; NewStatus: String);\nbegin\n  Report.Status := NewStatus;\nend;\n\nvar\n  Bug: TBugReport;\nbegin\n  Bug.ID := 1;\n  Bug.Description := 'Sample bug report';\n  Bug.Status := 'Open';\n\n  WriteLn('Before update:');\n  WriteLn('ID: ', Bug.ID, ' Description: ', Bug.Description, ' Status: ', Bug.Status);\n\n  UpdateBugStatus(Bug, 'Closed');\n\n  WriteLn('After update:');\n  WriteLn('ID: ', Bug.ID, ' Description: ', Bug.Description, ' Status: ', Bug.Status);\nend.\n```"
  },
  {
    "task": "Write a program where a function receives a sensor array and calibrates it. Demonstrate the effect of pass-by-reference on the array.",
    "code": "```pascal\nprogram SensorCalibration;\n\ntype\n  TSensorArray = array of Real;\n\nprocedure CalibrateSensorArray(var sensors: TSensorArray);\nvar\n  i: Integer;\nbegin\n  for i := Low(sensors) to High(sensors) do\n    sensors[i] := sensors[i] * 1.1;  // Example calibration by scaling\nend;\n\nprocedure PrintSensorArray(sensors: TSensorArray);\nvar\n  i: Integer;\nbegin\n  for i := Low(sensors) to High(sensors) do\n    WriteLn('Sensor ', i, ': ', sensors[i]:0:2);\nend;\n\nvar\n  sensorData: TSensorArray;\nbegin\n  SetLength(sensorData, 5);\n  sensorData[0] := 10.0;\n  sensorData[1] := 20.0;\n  sensorData[2] := 30.0;\n  sensorData[3] := 40.0;\n  sensorData[4] := 50.0;\n\n  WriteLn('Original Sensor Data:');\n  PrintSensorArray(sensorData);\n\n  CalibrateSensorArray(sensorData);\n\n  WriteLn('Calibrated Sensor Data:');\n  PrintSensorArray(sensorData);\nend.\n```"
  },
  {
    "task": "Create a function that takes a vector and rotates it. Explain how pass-by-value ensures the original vector remains unchanged.",
    "code": "```pascal\nprogram RotateVectorExample;\n\ntype\n  TVector = array of Integer;\n\nfunction RotateVector(vec: TVector): TVector;\nvar\n  i, n: Integer;\nbegin\n  n := Length(vec);\n  if n = 0 then\n    Exit(vec);\n\n  SetLength(Result, n);\n  Result[0] := vec[n - 1];\n  for i := 1 to n - 1 do\n    Result[i] := vec[i - 1];\nend;\n\nvar\n  originalVector, rotatedVector: TVector;\n  i: Integer;\nbegin\n  originalVector := TVector.Create(1, 2, 3, 4, 5);\n  rotatedVector := RotateVector(originalVector);\n\n  Write('Original Vector: ');\n  for i := 0 to High(originalVector) do\n    Write(originalVector[i], ' ');\n  Writeln;\n\n  Write('Rotated Vector: ');\n  for i := 0 to High(rotatedVector) do\n    Write(rotatedVector[i], ' ');\n  Writeln;\nend.\n```"
  },
  {
    "task": "Implement a function that accepts an operation log and compresses it. Discuss the impact of pass-by-reference on the log.",
    "code": "```pascal\nprogram CompressOperationLog;\n\ntype\n  TStringArray = array of string;\n\nprocedure CompressLog(var log: TStringArray);\nvar\n  i, j: Integer;\nbegin\n  i := 0;\n  j := 0;\n  while i < Length(log) do\n  begin\n    if (i > 0) and (log[i] = log[i - 1]) then\n    begin\n      Inc(j);\n    end\n    else\n    begin\n      log[i - j] := log[i];\n    end;\n    Inc(i);\n  end;\n  SetLength(log, Length(log) - j);\nend;\n\nvar\n  operationLog: TStringArray;\n  i: Integer;\nbegin\n  operationLog := TStringArray.Create('start', 'start', 'process', 'process', 'process', 'end', 'end');\n  CompressLog(operationLog);\n  \n  for i := 0 to High(operationLog) do\n  begin\n    WriteLn(operationLog[i]);\n  end;\nend.\n```"
  },
  {
    "task": "Develop a function that receives a neural network model and updates its weights. Illustrate the effects of pass-by-reference.",
    "code": "```pascal\nprogram UpdateWeights;\n\ntype\n  TWeights = array of real;\n  TModel = record\n    Weights: TWeights;\n  end;\n\nprocedure UpdateModelWeights(var model: TModel);\nvar\n  i: Integer;\nbegin\n  for i := 0 to High(model.Weights) do\n  begin\n    model.Weights[i] := model.Weights[i] * 1.1; // Example of weight update\n  end;\nend;\n\nvar\n  model: TModel;\n  i: Integer;\nbegin\n  // Initialize the model with some weights\n  SetLength(model.Weights, 3);\n  model.Weights[0] := 0.5;\n  model.Weights[1] := 1.5;\n  model.Weights[2] := -0.5;\n\n  // Update weights by reference\n  UpdateModelWeights(model);\n\n  // Output updated weights to illustrate changes\n  for i := 0 to High(model.Weights) do\n  begin\n    WriteLn('Weight ', i, ': ', model.Weights[i]:0:2);\n  end;\nend.\n```"
  },
  {
    "task": "Design a function that accepts a command history and reverts the last command. Show the changes with pass-by-reference.",
    "code": "```pascal\nprogram RevertLastCommand;\n\ntype\n  TStringArray = array of string;\n\nprocedure RevertCommand(var history: TStringArray);\nvar\n  newLength: Integer;\nbegin\n  newLength := Length(history) - 1;\n  if newLength >= 0 then\n    SetLength(history, newLength);\nend;\n\nprocedure PrintHistory(history: TStringArray);\nvar\n  i: Integer;\nbegin\n  for i := 0 to High(history) do\n    writeln(history[i]);\nend;\n\nvar\n  commandHistory: TStringArray;\nbegin\n  SetLength(commandHistory, 3);\n  commandHistory[0] := 'Command 1';\n  commandHistory[1] := 'Command 2';\n  commandHistory[2] := 'Command 3';\n\n  writeln('Original Command History:');\n  PrintHistory(commandHistory);\n\n  RevertCommand(commandHistory);\n\n  writeln('Command History after Reverting Last Command:');\n  PrintHistory(commandHistory);\nend.\n```"
  },
  {
    "task": "Write a function that takes a user profile and anonymizes it. Discuss how pass-by-reference affects the original profile.",
    "code": "```pascal\nprogram AnonymizeUserProfile;\n\ntype\n  UserProfile = record\n    Name: string;\n    Email: string;\n    Age: integer;\n  end;\n\nprocedure AnonymizeProfile(var profile: UserProfile);\nbegin\n  profile.Name := 'Anonymous';\n  profile.Email := 'anonymous@example.com';\n  profile.Age := 0;\nend;\n\nvar\n  user: UserProfile;\nbegin\n  user.Name := 'John Doe';\n  user.Email := 'john.doe@example.com';\n  user.Age := 30;\n  \n  AnonymizeProfile(user);\n\n  writeln('Name: ', user.Name);\n  writeln('Email: ', user.Email);\n  writeln('Age: ', user.Age);\nend.\n```"
  },
  {
    "task": "Create a function that accepts a polynomial and evaluates it at a given point. Explain how pass-by-value ensures the polynomial remains unchanged.",
    "code": "```pascal\nprogram EvaluatePolynomial;\n\ntype\n  TPolynomial = array of Real;\n\nfunction EvaluatePoly(coefficients: TPolynomial; x: Real): Real;\nvar\n  i: Integer;\n  resultValue, term: Real;\nbegin\n  resultValue := 0.0;\n  for i := Low(coefficients) to High(coefficients) do\n  begin\n    term := coefficients[i] * Power(x, i);\n    resultValue := resultValue + term;\n  end;\n  EvaluatePoly := resultValue;\nend;\n\nvar\n  poly: TPolynomial;\n  xValue, result: Real;\nbegin\n  SetLength(poly, 3);\n  poly[0] := 1.0;  // Constant term\n  poly[1] := -3.0; // x term\n  poly[2] := 2.0;  // x^2 term\n  xValue := 2.0;\n  result := EvaluatePoly(poly, xValue);\n  WriteLn('The polynomial evaluated at ', xValue:0:2, ' is ', result:0:2);\nend.\n```"
  },
  {
    "task": "Implement a function that receives a video stream and applies a filter. Demonstrate the effects of pass-by-reference on the stream.",
    "code": "```pascal\nprogram VideoFilterDemo;\n\ntype\n  TVideoStream = record\n    data: array of byte;\n  end;\n\nprocedure ApplyFilter(var stream: TVideoStream);\nvar\n  i: Integer;\nbegin\n  for i := 0 to Length(stream.data) - 1 do\n  begin\n    stream.data[i] := stream.data[i] div 2;  // Example filter: reduce brightness\n  end;\nend;\n\nvar\n  myStream: TVideoStream;\n  i: Integer;\nbegin\n  SetLength(myStream.data, 10);  // Example stream with 10 frames\n  for i := 0 to 9 do\n    myStream.data[i] := i * 25;  // Initialize with sample data\n\n  WriteLn('Original stream data:');\n  for i := 0 to 9 do\n    Write(myStream.data[i], ' ');\n  WriteLn;\n\n  ApplyFilter(myStream);\n\n  WriteLn('Filtered stream data:');\n  for i := 0 to 9 do\n    Write(myStream.data[i], ' ');\n  WriteLn;\nend.\n```"
  },
  {
    "task": "Develop a function that takes a task queue and reorders tasks based on priority. Illustrate the impact of pass-by-reference.",
    "code": "```pascal\nprogram TaskQueueReordering;\n\ntype\n  Task = record\n    name: string;\n    priority: integer;\n  end;\n\n  TaskQueue = array of Task;\n\nprocedure ReorderTasks(var queue: TaskQueue);\nvar\n  i, j: integer;\n  temp: Task;\nbegin\n  for i := 0 to High(queue) - 1 do\n    for j := 0 to High(queue) - i - 1 do\n      if queue[j].priority < queue[j + 1].priority then\n      begin\n        temp := queue[j];\n        queue[j] := queue[j + 1];\n        queue[j + 1] := temp;\n      end;\nend;\n\nprocedure PrintQueue(const queue: TaskQueue);\nvar\n  i: integer;\nbegin\n  for i := 0 to High(queue) do\n    writeln('Task: ', queue[i].name, ', Priority: ', queue[i].priority);\nend;\n\nvar\n  myQueue: TaskQueue;\nbegin\n  SetLength(myQueue, 3);\n  myQueue[0].name := 'Task1';\n  myQueue[0].priority := 1;\n  myQueue[1].name := 'Task2';\n  myQueue[1].priority := 3;\n  myQueue[2].name := 'Task3';\n  myQueue[2].priority := 2;\n\n  writeln('Before reordering:');\n  PrintQueue(myQueue);\n\n  ReorderTasks(myQueue);\n\n  writeln('After reordering:');\n  PrintQueue(myQueue);\nend.\n```"
  },
  {
    "task": "Design a program where a function receives a blockchain and verifies a transaction. Discuss how pass-by-reference affects the blockchain.",
    "code": "```pascal\nprogram BlockchainTransactionVerification;\n\ntype\n  Transaction = record\n    sender: string;\n    receiver: string;\n    amount: real;\n  end;\n  \n  Block = record\n    transaction: Transaction;\n    previousHash: string;\n  end;\n  \n  Blockchain = array of Block;\n\nfunction VerifyTransaction(var chain: Blockchain; t: Transaction): boolean;\nvar\n  i: integer;\nbegin\n  VerifyTransaction := False;\n  for i := Low(chain) to High(chain) do\n  begin\n    if (chain[i].transaction.sender = t.sender) and\n       (chain[i].transaction.receiver = t.receiver) and\n       (chain[i].transaction.amount = t.amount) then\n    begin\n      VerifyTransaction := True;\n      Exit;\n    end;\n  end;\nend;\n\nvar\n  myChain: Blockchain;\n  myTransaction: Transaction;\n  isValid: boolean;\nbegin\n  SetLength(myChain, 2);\n  \n  myChain[0].transaction.sender := 'Alice';\n  myChain[0].transaction.receiver := 'Bob';\n  myChain[0].transaction.amount := 100.0;\n  myChain[0].previousHash := 'hash0';\n  \n  myChain[1].transaction.sender := 'Bob';\n  myChain[1].transaction.receiver := 'Charlie';\n  myChain[1].transaction.amount := 50.0;\n  myChain[1].previousHash := 'hash1';\n  \n  myTransaction.sender := 'Alice';\n  myTransaction.receiver := 'Bob';\n  myTransaction.amount := 100.0;\n  \n  isValid := VerifyTransaction(myChain, myTransaction);\n  \n  if isValid then\n    writeln('Transaction is valid.')\n  else\n    writeln('Transaction is invalid.');\nend.\n```"
  },
  {
    "task": "Write a function that takes a game leaderboard and updates scores. Show the changes with pass-by-reference.",
    "code": "```pascal\nprogram LeaderboardUpdate;\n\ntype\n  TPlayer = record\n    name: string;\n    score: integer;\n  end;\n\n  TLeaderboard = array of TPlayer;\n\nprocedure UpdateScores(var leaderboard: TLeaderboard; playerName: string; newScore: integer);\nvar\n  i: integer;\nbegin\n  for i := 0 to High(leaderboard) do\n  begin\n    if leaderboard[i].name = playerName then\n    begin\n      leaderboard[i].score := newScore;\n      Break;\n    end;\n  end;\nend;\n\nvar\n  leaderboard: TLeaderboard;\n  i: integer;\nbegin\n  SetLength(leaderboard, 3);\n  leaderboard[0].name := 'Alice'; leaderboard[0].score := 100;\n  leaderboard[1].name := 'Bob'; leaderboard[1].score := 150;\n  leaderboard[2].name := 'Charlie'; leaderboard[2].score := 200;\n\n  UpdateScores(leaderboard, 'Bob', 180);\n\n  for i := 0 to High(leaderboard) do\n    writeln(leaderboard[i].name, ': ', leaderboard[i].score);\nend.\n```"
  },
  {
    "task": "Create a function that accepts a project timeline and adjusts for delays. Explain how pass-by-reference influences the timeline.",
    "code": "```pascal\nprogram AdjustProjectTimeline;\n\ntype\n  TTimeline = record\n    startDate: string;\n    endDate: string;\n    delayDays: integer;\n  end;\n\nprocedure AdjustForDelays(var timeline: TTimeline);\nbegin\n  timeline.endDate := timeline.endDate + ' + ' + IntToStr(timeline.delayDays) + ' days';\nend;\n\nvar\n  projectTimeline: TTimeline;\n\nbegin\n  projectTimeline.startDate := '2023-10-01';\n  projectTimeline.endDate := '2023-12-01';\n  projectTimeline.delayDays := 15;\n\n  AdjustForDelays(projectTimeline);\n  writeln('Adjusted Project End Date: ', projectTimeline.endDate);\nend.\n```"
  },
  {
    "task": "Implement a function that receives a to-do list and completes a task. Demonstrate the effect of pass-by-reference on the list.",
    "code": "```pascal\nprogram ToDoListManager;\n\ntype\n  TStringArray = array of string;\n\nprocedure CompleteTask(var todoList: TStringArray; taskIndex: Integer);\nvar\n  i: Integer;\nbegin\n  if (taskIndex < 0) or (taskIndex >= Length(todoList)) then\n    Exit;\n\n  for i := taskIndex to High(todoList) - 1 do\n    todoList[i] := todoList[i + 1];\n\n  SetLength(todoList, Length(todoList) - 1);\nend;\n\nprocedure PrintToDoList(todoList: TStringArray);\nvar\n  i: Integer;\nbegin\n  for i := 0 to High(todoList) do\n    Writeln(i + 1, '. ', todoList[i]);\nend;\n\nvar\n  myToDoList: TStringArray;\nbegin\n  myToDoList := TStringArray.Create('Buy groceries', 'Write report', 'Read book');\n\n  Writeln('To-Do List:');\n  PrintToDoList(myToDoList);\n\n  CompleteTask(myToDoList, 1);\n\n  Writeln('To-Do List after completing task 2:');\n  PrintToDoList(myToDoList);\nend.\n```"
  },
  {
    "task": "Develop a function that takes a paint canvas and adds a layer. Discuss the impact of pass-by-reference on the canvas.",
    "code": "```pascal\nprogram CanvasLayer;\n\ntype\n  TCanvas = record\n    Layers: array of string;\n  end;\n\nprocedure AddLayer(var canvas: TCanvas; const layer: string);\nbegin\n  SetLength(canvas.Layers, Length(canvas.Layers) + 1);\n  canvas.Layers[High(canvas.Layers)] := layer;\nend;\n\nvar\n  MyCanvas: TCanvas;\nbegin\n  SetLength(MyCanvas.Layers, 0);\n  AddLayer(MyCanvas, 'Layer 1');\n  AddLayer(MyCanvas, 'Layer 2');\nend.\n```"
  },
  {
    "task": "Design a function that accepts a URL list and fetches content. Show the difference in the list when using pass-by-value.",
    "code": "```pascal\nprogram URLFetcher;\n\nuses\n  SysUtils;\n\ntype\n  TStringArray = array of string;\n\nfunction FetchContent(urls: TStringArray): TStringArray;\nvar\n  i: Integer;\nbegin\n  SetLength(Result, Length(urls));\n  for i := 0 to High(urls) do\n  begin\n    // Simulate content fetching by appending '_content' to the URL\n    Result[i] := urls[i] + '_content';\n  end;\nend;\n\nprocedure PrintArray(arr: TStringArray);\nvar\n  i: Integer;\nbegin\n  for i := 0 to High(arr) do\n  begin\n    WriteLn(arr[i]);\n  end;\nend;\n\nvar\n  urlList: TStringArray;\n  newUrlList: TStringArray;\nbegin\n  SetLength(urlList, 3);\n  urlList[0] := 'http://example.com/page1';\n  urlList[1] := 'http://example.com/page2';\n  urlList[2] := 'http://example.com/page3';\n\n  WriteLn('Original URL List:');\n  PrintArray(urlList);\n\n  newUrlList := FetchContent(urlList);\n\n  WriteLn('New URL List with fetched content:');\n  PrintArray(newUrlList);\n\n  WriteLn('Original URL List after function call:');\n  PrintArray(urlList);\nend.\n```"
  },
  {
    "task": "Write a program where a function receives a game board and resets it. Illustrate the effects of pass-by-reference.",
    "code": "```pascal\nprogram ResetGameBoard;\n\ntype\n  TBoard = array[1..3, 1..3] of Char;\n\nprocedure ResetBoard(var board: TBoard);\nvar\n  i, j: Integer;\nbegin\n  for i := 1 to 3 do\n    for j := 1 to 3 do\n      board[i, j] := '-';\nend;\n\nprocedure PrintBoard(const board: TBoard);\nvar\n  i, j: Integer;\nbegin\n  for i := 1 to 3 do\n  begin\n    for j := 1 to 3 do\n      Write(board[i, j], ' ');\n    Writeln;\n  end;\nend;\n\nvar\n  gameBoard: TBoard;\nbegin\n  gameBoard[1, 1] := 'X';\n  gameBoard[1, 2] := 'O';\n  gameBoard[1, 3] := 'X';\n  gameBoard[2, 1] := 'O';\n  gameBoard[2, 2] := 'X';\n  gameBoard[2, 3] := 'O';\n  gameBoard[3, 1] := 'X';\n  gameBoard[3, 2] := 'O';\n  gameBoard[3, 3] := 'X';\n\n  Writeln('Original Board:');\n  PrintBoard(gameBoard);\n\n  ResetBoard(gameBoard);\n\n  Writeln('Reset Board:');\n  PrintBoard(gameBoard);\nend.\n```"
  },
  {
    "task": "Create a function that takes a sound effect and increases its volume. Explain how pass-by-reference affects the original sound.",
    "code": "```pascal\nprogram SoundEffectVolumeIncrease;\n\ntype\n  TSoundEffect = record\n    Volume: Integer;\n  end;\n\nprocedure IncreaseVolume(var soundEffect: TSoundEffect);\nbegin\n  soundEffect.Volume := soundEffect.Volume + 10;\nend;\n\nvar\n  mySound: TSoundEffect;\n\nbegin\n  mySound.Volume := 50;\n  IncreaseVolume(mySound);\nend.\n```"
  },
  {
    "task": "Implement a function that accepts a weather forecast and updates temperature predictions. Discuss the impact of pass-by-reference.",
    "code": "```pascal\nprogram WeatherForecast;\n\ntype\n  TWeatherForecast = record\n    Temperature: Integer;\n  end;\n\nprocedure UpdateTemperature(var forecast: TWeatherForecast; newTemperature: Integer);\nbegin\n  forecast.Temperature := newTemperature;\nend;\n\nvar\n  forecast: TWeatherForecast;\nbegin\n  forecast.Temperature := 20; // Initial temperature\n  UpdateTemperature(forecast, 25); // Update temperature by reference\n  writeln('Updated Temperature: ', forecast.Temperature);\nend.\n```"
  },
  {
    "task": "Develop a function that receives a system log and extracts error messages. Show how pass-by-value ensures the original log remains unchanged.",
    "code": "```pascal\nprogram ExtractErrorMessages;\n\ntype\n  TStringArray = array of string;\n\nfunction ExtractErrors(log: TStringArray): TStringArray;\nvar\n  i, errorCount: Integer;\nbegin\n  errorCount := 0;\n  for i := 0 to High(log) do\n  begin\n    if Pos('ERROR', log[i]) > 0 then\n    begin\n      SetLength(Result, errorCount + 1);\n      Result[errorCount] := log[i];\n      Inc(errorCount);\n    end;\n  end;\nend;\n\nvar\n  systemLog, errorMessages: TStringArray;\n  i: Integer;\nbegin\n  systemLog := TStringArray.Create(\n    'INFO: System started.',\n    'ERROR: Failed to load configuration.',\n    'WARNING: Low disk space.',\n    'ERROR: Connection timeout.',\n    'INFO: Update completed.'\n  );\n\n  errorMessages := ExtractErrors(systemLog);\n\n  WriteLn('Original Log:');\n  for i := 0 to High(systemLog) do\n    WriteLn(systemLog[i]);\n\n  WriteLn('Extracted Error Messages:');\n  for i := 0 to High(errorMessages) do\n    WriteLn(errorMessages[i]);\nend.\n```"
  },
  {
    "task": "Design a function that accepts a data packet and encrypts it. Demonstrate the effect of pass-by-value on the packet.",
    "code": "```pascal\nprogram EncryptPacketDemo;\n\ntype\n  TDataPacket = record\n    content: String;\n  end;\n\nfunction EncryptPacket(packet: TDataPacket): TDataPacket;\nvar\n  i: Integer;\nbegin\n  Result := packet;\n  for i := 1 to Length(Result.content) do\n    Result.content[i] := Chr(Ord(Result.content[i]) + 1);\nend;\n\nvar\n  originalPacket, encryptedPacket: TDataPacket;\nbegin\n  originalPacket.content := 'Hello, World!';\n  encryptedPacket := EncryptPacket(originalPacket);\n  \n  WriteLn('Original Packet Content: ', originalPacket.content);\n  WriteLn('Encrypted Packet Content: ', encryptedPacket.content);\nend.\n```"
  },
  {
    "task": "Write a function that takes a website theme and applies a color change. Explain how pass-by-reference affects the original theme.",
    "code": "```pascal\nprogram ThemeColorChange;\n\ntype\n  TTheme = record\n    Name: string;\n    Color: string;\n  end;\n\nprocedure ApplyColorChange(var Theme: TTheme; NewColor: string);\nbegin\n  Theme.Color := NewColor;\nend;\n\nvar\n  MyTheme: TTheme;\nbegin\n  MyTheme.Name := 'Default';\n  MyTheme.Color := 'Blue';\n\n  // Apply a color change\n  ApplyColorChange(MyTheme, 'Green');\n\n  // Output the result\n  writeln('Theme Name: ', MyTheme.Name);\n  writeln('Theme Color: ', MyTheme.Color);\nend.\n```"
  },
  {
    "task": "Create a function that accepts a digital signature and verifies it. Discuss the implications of pass-by-value on the signature.",
    "code": "```pascal\nprogram SignatureVerification;\n\nfunction VerifySignature(signature: string): Boolean;\nbegin\n  // Simulate signature verification logic\n  // This is a stub, as actual verification would require cryptographic operations\n  if signature = 'valid_signature' then\n    VerifySignature := True\n  else\n    VerifySignature := False;\nend;\n\nvar\n  testSignature: string;\n  isValid: Boolean;\nbegin\n  testSignature := 'valid_signature';\n  isValid := VerifySignature(testSignature);\n  if isValid then\n    writeln('Signature is valid.')\n  else\n    writeln('Signature is invalid.');\nend.\n```"
  },
  {
    "task": "Implement a function that receives a robot's path and optimizes it. Illustrate the effects of pass-by-reference on the path.",
    "code": "```pascal\nprogram OptimizeRobotPath;\n\ntype\n  PathArray = array of string;\n\nprocedure OptimizePath(var path: PathArray);\nvar\n  i, j, n: Integer;\nbegin\n  n := Length(path);\n  j := 0;\n\n  for i := 0 to n-1 do\n  begin\n    if (i < n-1) and ((path[i] = 'UP') and (path[i+1] = 'DOWN') or\n                      (path[i] = 'DOWN') and (path[i+1] = 'UP') or\n                      (path[i] = 'LEFT') and (path[i+1] = 'RIGHT') or\n                      (path[i] = 'RIGHT') and (path[i+1] = 'LEFT')) then\n    begin\n      Inc(i); // Skip the next element as it cancels out with the current\n    end\n    else\n    begin\n      path[j] := path[i];\n      Inc(j);\n    end;\n  end;\n  SetLength(path, j); // Resize the path array to the new optimized length\nend;\n\nvar\n  robotPath: PathArray;\n  i: Integer;\nbegin\n  robotPath := ['UP', 'DOWN', 'LEFT', 'RIGHT', 'UP', 'UP', 'RIGHT', 'DOWN', 'LEFT'];\n\n  WriteLn('Original Path:');\n  for i := 0 to High(robotPath) do\n    Write(robotPath[i], ' ');\n  WriteLn;\n\n  OptimizePath(robotPath);\n\n  WriteLn('Optimized Path:');\n  for i := 0 to High(robotPath) do\n    Write(robotPath[i], ' ');\n  WriteLn;\nend.\n```"
  },
  {
    "task": "Develop a function that takes a music playlist and shuffles it. Demonstrate the impact of pass-by-reference on the playlist.",
    "code": "```pascal\nprogram ShufflePlaylistDemo;\n\nuses SysUtils;\n\ntype\n  TPlaylist = array of string;\n\nprocedure ShufflePlaylist(var playlist: TPlaylist);\nvar\n  i, j: Integer;\n  temp: string;\nbegin\n  Randomize;\n  for i := High(playlist) downto Low(playlist) + 1 do\n  begin\n    j := Random(i + 1);\n    temp := playlist[i];\n    playlist[i] := playlist[j];\n    playlist[j] := temp;\n  end;\nend;\n\nprocedure PrintPlaylist(const playlist: TPlaylist);\nvar\n  i: Integer;\nbegin\n  for i := Low(playlist) to High(playlist) do\n    WriteLn(playlist[i]);\nend;\n\nvar\n  myPlaylist: TPlaylist;\nbegin\n  myPlaylist := TPlaylist.Create('Song A', 'Song B', 'Song C', 'Song D', 'Song E');\n  \n  WriteLn('Original Playlist:');\n  PrintPlaylist(myPlaylist);\n  \n  ShufflePlaylist(myPlaylist);\n  \n  WriteLn('Shuffled Playlist:');\n  PrintPlaylist(myPlaylist);\nend.\n```"
  },
  {
    "task": "Design a program where a function receives a social media feed and removes duplicates. Show the changes with pass-by-reference.",
    "code": "```pascal\nprogram RemoveDuplicatesFromFeed;\n\ntype\n  TFeed = array of string;\n\nprocedure RemoveDuplicates(var feed: TFeed);\nvar\n  tempFeed: TFeed;\n  i, j, k: Integer;\n  isDuplicate: Boolean;\nbegin\n  SetLength(tempFeed, Length(feed));\n  k := 0;\n  \n  for i := 0 to High(feed) do\n  begin\n    isDuplicate := False;\n    for j := 0 to k - 1 do\n    begin\n      if feed[i] = tempFeed[j] then\n      begin\n        isDuplicate := True;\n        Break;\n      end;\n    end;\n    \n    if not isDuplicate then\n    begin\n      tempFeed[k] := feed[i];\n      Inc(k);\n    end;\n  end;\n  \n  SetLength(feed, k);\n  for i := 0 to k - 1 do\n    feed[i] := tempFeed[i];\nend;\n\nvar\n  myFeed: TFeed;\n  i: Integer;\nbegin\n  myFeed := TFeed.Create('post1', 'post2', 'post1', 'post3', 'post2', 'post4');\n  \n  WriteLn('Original Feed:');\n  for i := 0 to High(myFeed) do\n    WriteLn(myFeed[i]);\n    \n  RemoveDuplicates(myFeed);\n  \n  WriteLn('Feed after removing duplicates:');\n  for i := 0 to High(myFeed) do\n    WriteLn(myFeed[i]);\nend.\n```"
  },
  {
    "task": "Write a function that takes a coding challenge and adds test cases. Discuss the effects of pass-by-reference on the challenge.",
    "code": "```pascal\nprogram AddTestCases;\n\ntype\n  TCodingChallenge = record\n    description: string;\n    tests: array of string;\n  end;\n\nprocedure AddTestCasesToChallenge(var challenge: TCodingChallenge);\nbegin\n  SetLength(challenge.tests, Length(challenge.tests) + 2);\n  challenge.tests[High(challenge.tests) - 1] := 'TestCase 1: Input -> ExpectedOutput';\n  challenge.tests[High(challenge.tests)] := 'TestCase 2: Input -> ExpectedOutput';\nend;\n\nvar\n  challenge: TCodingChallenge;\n  i: Integer;\nbegin\n  challenge.description := 'Sample Coding Challenge';\n  SetLength(challenge.tests, 0);\n\n  AddTestCasesToChallenge(challenge);\n\n  writeln('Challenge: ', challenge.description);\n  writeln('Test Cases:');\n  for i := 0 to High(challenge.tests) do\n    writeln(challenge.tests[i]);\nend.\n```"
  },
  {
    "task": "Create a function that accepts an animation sequence and reverses it. Explain how pass-by-value ensures the sequence remains unchanged.",
    "code": "```pascal\nprogram ReverseAnimationSequence;\n\ntype\n  TAnimationSequence = array of Integer;\n\nfunction ReverseSequence(seq: TAnimationSequence): TAnimationSequence;\nvar\n  i, n: Integer;\nbegin\n  n := Length(seq);\n  SetLength(Result, n);\n  for i := 0 to n - 1 do\n  begin\n    Result[i] := seq[n - i - 1];\n  end;\nend;\n\nvar\n  originalSequence, reversedSequence: TAnimationSequence;\n  i: Integer;\nbegin\n  originalSequence := [1, 2, 3, 4, 5];\n  reversedSequence := ReverseSequence(originalSequence);\n\n  WriteLn('Original Sequence:');\n  for i := 0 to High(originalSequence) do\n    Write(originalSequence[i], ' ');\n\n  WriteLn;\n  WriteLn('Reversed Sequence:');\n  for i := 0 to High(reversedSequence) do\n    Write(reversedSequence[i], ' ');\nend.\n```"
  },
  {
    "task": "Implement a function that receives a GPS route and recalculates it. Illustrate the impact of pass-by-reference on the route.",
    "code": "```pascal\nprogram RecalculateRoute;\n\ntype\n  TGPSPoint = record\n    Latitude: Double;\n    Longitude: Double;\n  end;\n  \n  TGPSRoute = array of TGPSPoint;\n\nprocedure Recalculate(var route: TGPSRoute);\nvar\n  i: Integer;\nbegin\n  for i := 0 to High(route) do\n  begin\n    // Example modification: Increase latitude and longitude by 0.01\n    route[i].Latitude := route[i].Latitude + 0.01;\n    route[i].Longitude := route[i].Longitude + 0.01;\n  end;\nend;\n\nvar\n  route: TGPSRoute;\n  i: Integer;\nbegin\n  SetLength(route, 3);\n  \n  // Initialize route with some values\n  route[0].Latitude := 34.0522;\n  route[0].Longitude := -118.2437;\n  \n  route[1].Latitude := 36.1699;\n  route[1].Longitude := -115.1398;\n  \n  route[2].Latitude := 40.7128;\n  route[2].Longitude := -74.0060;\n  \n  Writeln('Original Route:');\n  for i := 0 to High(route) do\n    Writeln('Point ', i, ': (', route[i].Latitude:0:4, ', ', route[i].Longitude:0:4, ')');\n  \n  // Recalculate the route\n  Recalculate(route);\n  \n  Writeln('Recalculated Route:');\n  for i := 0 to High(route) do\n    Writeln('Point ', i, ': (', route[i].Latitude:0:4, ', ', route[i].Longitude:0:4, ')');\nend.\n```"
  },
  {
    "task": "Develop a function that takes a chat history and censors inappropriate language. Show the effect of pass-by-reference on the history.",
    "code": "```pascal\nprogram CensorChat;\n\nuses\n  SysUtils;\n\ntype\n  TStringArray = array of string;\n\nprocedure CensorInappropriateLanguage(var chatHistory: TStringArray; const inappropriateWords: TStringArray);\nvar\n  i, j: Integer;\nbegin\n  for i := 0 to High(chatHistory) do\n  begin\n    for j := 0 to High(inappropriateWords) do\n    begin\n      if Pos(inappropriateWords[j], chatHistory[i]) > 0 then\n        chatHistory[i] := StringReplace(chatHistory[i], inappropriateWords[j], '****', [rfReplaceAll, rfIgnoreCase]);\n    end;\n  end;\nend;\n\nvar\n  chatHistory: TStringArray;\n  inappropriateWords: TStringArray;\n  i: Integer;\nbegin\n  chatHistory := TStringArray.Create('Hello there!', 'This is a badword example.', 'No issues here.');\n  inappropriateWords := TStringArray.Create('badword');\n\n  Writeln('Original Chat History:');\n  for i := 0 to High(chatHistory) do\n    Writeln(chatHistory[i]);\n\n  CensorInappropriateLanguage(chatHistory, inappropriateWords);\n\n  Writeln('Censored Chat History:');\n  for i := 0 to High(chatHistory) do\n    Writeln(chatHistory[i]);\nend.\n```"
  },
  {
    "task": "Design a function that accepts a lighting setup and adjusts brightness. Discuss the changes when the setup is passed by reference.",
    "code": "```pascal\nprogram AdjustBrightnessDemo;\n\ntype\n  TLightingSetup = record\n    brightness: Integer;\n  end;\n\nprocedure AdjustBrightness(var setup: TLightingSetup; adjustment: Integer);\nbegin\n  setup.brightness := setup.brightness + adjustment;\nend;\n\nvar\n  myLightingSetup: TLightingSetup;\nbegin\n  myLightingSetup.brightness := 50;\n  AdjustBrightness(myLightingSetup, 10);\n  WriteLn('Adjusted Brightness: ', myLightingSetup.brightness);\nend.\n```"
  },
  {
    "task": "Write a program where a function receives a VR environment and changes the scenery. Demonstrate the effects of pass-by-reference.",
    "code": "```pascal\nprogram VRSceneryChange;\n\ntype\n  TVREnvironment = record\n    scenery: string;\n  end;\n\nprocedure ChangeScenery(var environment: TVREnvironment; newScenery: string);\nbegin\n  environment.scenery := newScenery;\nend;\n\nvar\n  myEnvironment: TVREnvironment;\nbegin\n  myEnvironment.scenery := 'Beach';\n  writeln('Original Scenery: ', myEnvironment.scenery);\n\n  ChangeScenery(myEnvironment, 'Mountain');\n  writeln('Changed Scenery: ', myEnvironment.scenery);\nend.\n```"
  },
  {
    "task": "Create a function that takes a blockchain ledger and adds a block. Explain how pass-by-reference affects the ledger.",
    "code": "```pascal\nprogram BlockchainLedger;\n\ntype\n  TBlock = record\n    index: Integer;\n    data: String;\n  end;\n\n  TLedger = array of TBlock;\n\nprocedure AddBlock(var ledger: TLedger; newBlock: TBlock);\nbegin\n  SetLength(ledger, Length(ledger) + 1);\n  ledger[High(ledger)] := newBlock;\nend;\n\nvar\n  ledger: TLedger;\n  block: TBlock;\nbegin\n  block.index := 1;\n  block.data := 'First Block';\n  \n  AddBlock(ledger, block);\n  \n  block.index := 2;\n  block.data := 'Second Block';\n  \n  AddBlock(ledger, block);\nend.\n```"
  },
  {
    "task": "Implement a function that accepts a network packet and alters its headers. Discuss the implications of pass-by-value on the packet.",
    "code": "```pascal\nprogram ModifyNetworkPacket;\n\ntype\n  TPacket = record\n    Header: string;\n    Data: string;\n  end;\n\nfunction ModifyPacket(var Packet: TPacket): TPacket;\nbegin\n  Packet.Header := 'Modified Header';\n  Result := Packet;\nend;\n\nvar\n  OriginalPacket, ModifiedPacket: TPacket;\nbegin\n  OriginalPacket.Header := 'Original Header';\n  OriginalPacket.Data := 'Some data';\n\n  ModifiedPacket := ModifyPacket(OriginalPacket);\n\n  writeln('Original Packet Header: ', OriginalPacket.Header);\n  writeln('Modified Packet Header: ', ModifiedPacket.Header);\nend.\n```"
  }
]