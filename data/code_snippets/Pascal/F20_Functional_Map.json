[
  {
    "task": "Convert a list of temperatures from Celsius to Fahrenheit using a map function.",
    "code": "```pascal\nprogram ConvertTemperatures;\n\ntype\n  TRealArray = array of Real;\n\nfunction MapCelsiusToFahrenheit(const CelsiusTemps: TRealArray): TRealArray;\nvar\n  i: Integer;\nbegin\n  SetLength(Result, Length(CelsiusTemps));\n  for i := Low(CelsiusTemps) to High(CelsiusTemps) do\n  begin\n    Result[i] := CelsiusTemps[i] * 9/5 + 32;\n  end;\nend;\n\nvar\n  CelsiusTemps, FahrenheitTemps: TRealArray;\n  i: Integer;\nbegin\n  CelsiusTemps := TRealArray.Create(0, 20, 37, 100);\n  FahrenheitTemps := MapCelsiusToFahrenheit(CelsiusTemps);\n  \n  for i := Low(FahrenheitTemps) to High(FahrenheitTemps) do\n  begin\n    WriteLn('Celsius: ', CelsiusTemps[i]:0:2, ' -> Fahrenheit: ', FahrenheitTemps[i]:0:2);\n  end;\nend.\n```"
  },
  {
    "task": "Use map to convert a list of lowercase words to uppercase.",
    "code": "```pascal\nprogram ConvertToUpperCase;\n\nuses\n  SysUtils;\n\ntype\n  TStringArray = array of string;\n\nfunction ToUpperCaseMap(const words: TStringArray): TStringArray;\nvar\n  i: Integer;\nbegin\n  SetLength(Result, Length(words));\n  for i := 0 to High(words) do\n    Result[i] := UpperCase(words[i]);\nend;\n\nvar\n  words, upperWords: TStringArray;\n  i: Integer;\nbegin\n  words := TStringArray.Create('hello', 'world', 'pascal', 'programming');\n  upperWords := ToUpperCaseMap(words);\n\n  for i := 0 to High(upperWords) do\n    Writeln(upperWords[i]);\nend.\n```"
  },
  {
    "task": "Apply map to add a prefix to each string in a list of filenames.",
    "code": "```pascal\nprogram AddPrefixToFilenames;\n\ntype\n  TStringArray = array of string;\n\nfunction MapStrings(arr: TStringArray; func: function(s: string): string): TStringArray;\nvar\n  i: Integer;\nbegin\n  SetLength(Result, Length(arr));\n  for i := 0 to High(arr) do\n    Result[i] := func(arr[i]);\nend;\n\nfunction AddPrefix(s: string): string;\nconst\n  Prefix = 'prefix_';\nbegin\n  Result := Prefix + s;\nend;\n\nvar\n  Filenames, ResultFilenames: TStringArray;\n  i: Integer;\nbegin\n  Filenames := TStringArray.Create('file1.txt', 'file2.txt', 'file3.txt');\n  ResultFilenames := MapStrings(Filenames, @AddPrefix);\n\n  for i := 0 to High(ResultFilenames) do\n    WriteLn(ResultFilenames[i]);\nend.\n```"
  },
  {
    "task": "Transform a list of numbers by squaring each element with a map function.",
    "code": "```pascal\nprogram SquareList;\n\ntype\n  TIntArray = array of Integer;\n\nfunction MapSquare(arr: TIntArray): TIntArray;\nvar\n  i: Integer;\nbegin\n  SetLength(Result, Length(arr));\n  for i := 0 to High(arr) do\n    Result[i] := arr[i] * arr[i];\nend;\n\nvar\n  numbers, squaredNumbers: TIntArray;\n  i: Integer;\nbegin\n  numbers := TIntArray.Create(1, 2, 3, 4, 5);\n  squaredNumbers := MapSquare(numbers);\n  \n  for i := 0 to High(squaredNumbers) do\n    WriteLn(squaredNumbers[i]);\nend.\n```"
  },
  {
    "task": "Convert a list of integers to their string representations using map.",
    "code": "```pascal\nprogram ConvertIntegersToStrings;\n\nuses\n  SysUtils;\n\nvar\n  integers: array of Integer;\n  strings: array of String;\n  i: Integer;\nbegin\n  integers := [1, 2, 3, 4, 5];\n  SetLength(strings, Length(integers));\n\n  for i := Low(integers) to High(integers) do\n    strings[i] := IntToStr(integers[i]);\n\n  for i := Low(strings) to High(strings) do\n    WriteLn(strings[i]);\nend.\n```"
  },
  {
    "task": "Use map to compute the length of each string in a list of sentences.",
    "code": "```pascal\nprogram FunctionalMapExample;\n\nuses SysUtils;\n\ntype\n  TStringArray = array of string;\n  TIntegerArray = array of Integer;\n\nfunction MapStringLength(arr: TStringArray): TIntegerArray;\nvar\n  i: Integer;\nbegin\n  SetLength(Result, Length(arr));\n  for i := Low(arr) to High(arr) do\n    Result[i] := Length(arr[i]);\nend;\n\nvar\n  sentences: TStringArray;\n  lengths: TIntegerArray;\n  i: Integer;\nbegin\n  sentences := TStringArray.Create('Hello World', 'Pascal Programming', 'Functional Map Example');\n  lengths := MapStringLength(sentences);\n\n  for i := Low(lengths) to High(lengths) do\n    WriteLn('Length of sentence ', i + 1, ': ', lengths[i]);\nend.\n```"
  },
  {
    "task": "Apply a discount to a list of prices using a map function.",
    "code": "```pascal\nprogram ApplyDiscount;\n\ntype\n  TRealArray = array of Real;\n\nfunction Map(const Prices: TRealArray; Discount: Real): TRealArray;\nvar\n  i: Integer;\nbegin\n  SetLength(Result, Length(Prices));\n  for i := 0 to High(Prices) do\n    Result[i] := Prices[i] * (1 - Discount);\nend;\n\nvar\n  Prices, DiscountedPrices: TRealArray;\n  Discount: Real;\nbegin\n  Prices := TRealArray.Create(100.0, 200.0, 300.0, 400.0);\n  Discount := 0.1; // 10% discount\n\n  DiscountedPrices := Map(Prices, Discount);\n\n  // Output the discounted prices\n  for var i := 0 to High(DiscountedPrices) do\n    WriteLn('Discounted Price:', DiscountedPrices[i]:0:2);\nend.\n```"
  },
  {
    "task": "Extract the first element from each tuple in a list of tuples with map.",
    "code": "```pascal\nprogram ExtractFirstElement;\n\ntype\n  TupleArray = array of array of Integer;\n  IntArray = array of Integer;\n\nfunction FirstElementMap(tuples: TupleArray): IntArray;\nvar\n  i: Integer;\n  resultArray: IntArray;\nbegin\n  SetLength(resultArray, Length(tuples));\n  for i := 0 to High(tuples) do\n  begin\n    if Length(tuples[i]) > 0 then\n      resultArray[i] := tuples[i][0];\n  end;\n  FirstElementMap := resultArray;\nend;\n\nvar\n  tuples: TupleArray;\n  firstElements: IntArray;\n  i: Integer;\nbegin\n  tuples := [[1, 2], [3, 4], [5, 6]];\n  firstElements := FirstElementMap(tuples);\n  \n  for i := 0 to High(firstElements) do\n    WriteLn(firstElements[i]);\nend.\n```"
  },
  {
    "task": "Use map to round a list of floating-point numbers to two decimal places.",
    "code": "```pascal\nprogram RoundFloatArray;\n\ntype\n  TFloatArray = array of Double;\n\nfunction RoundToTwoDecimals(x: Double): Double;\nbegin\n  RoundToTwoDecimals := Round(x * 100) / 100;\nend;\n\nfunction MapArray(arr: TFloatArray; func: function(x: Double): Double): TFloatArray;\nvar\n  i: Integer;\nbegin\n  SetLength(Result, Length(arr));\n  for i := 0 to High(arr) do\n    Result[i] := func(arr[i]);\nend;\n\nvar\n  numbers, roundedNumbers: TFloatArray;\nbegin\n  numbers := TFloatArray.Create(3.1415, 2.7182, 1.6180);\n  roundedNumbers := MapArray(numbers, @RoundToTwoDecimals);\n\n  // To print the results (optional, not part of the task)\n  // for i := 0 to High(roundedNumbers) do\n  //   WriteLn(roundedNumbers[i]:0:2);\nend.\n```"
  },
  {
    "task": "Capitalize the first letter of each word in a list of names using map.",
    "code": "```pascal\nprogram CapitalizeNames;\n\nuses\n  SysUtils;\n\nfunction CapitalizeWord(const s: string): string;\nbegin\n  if Length(s) > 0 then\n    CapitalizeWord := UpCase(s[1]) + LowerCase(Copy(s, 2, Length(s) - 1))\n  else\n    CapitalizeWord := s;\nend;\n\nprocedure CapitalizeNamesInList(var names: array of string);\nvar\n  i: Integer;\nbegin\n  for i := 0 to High(names) do\n    names[i] := CapitalizeWord(names[i]);\nend;\n\nvar\n  names: array of string;\n  i: Integer;\nbegin\n  names := ['john', 'doe', 'alice', 'bob'];\n  CapitalizeNamesInList(names);\n  for i := 0 to High(names) do\n    WriteLn(names[i]);\nend.\n```"
  },
  {
    "task": "Convert a list of JSON strings to corresponding dictionary objects with map.",
    "code": "```pascal\nprogram ConvertJSONToDict;\n\nuses\n  fpjson, jsonparser, SysUtils;\n\ntype\n  TJSONArray = array of String;\n  TJSONDictionaryArray = array of TJSONObject;\n\nfunction MapJSONToDict(JSONStrings: TJSONArray): TJSONDictionaryArray;\nvar\n  I: Integer;\nbegin\n  SetLength(Result, Length(JSONStrings));\n  for I := 0 to High(JSONStrings) do\n  begin\n    Result[I] := TJSONObject(GetJSON(JSONStrings[I]));\n  end;\nend;\n\nvar\n  JSONStrings: TJSONArray;\n  JSONDicts: TJSONDictionaryArray;\n  I: Integer;\nbegin\n  JSONStrings := ['{\"key1\": \"value1\"}', '{\"key2\": \"value2\"}'];\n\n  JSONDicts := MapJSONToDict(JSONStrings);\n\n  for I := 0 to High(JSONDicts) do\n    WriteLn(JSONDicts[I].AsJSON);\n\n  for I := 0 to High(JSONDicts) do\n    JSONDicts[I].Free;\nend.\n```"
  },
  {
    "task": "Use map to double the value of each number in a list.",
    "code": "// [ERROR] Connection error."
  },
  {
    "task": "Transform a list of RGB tuples to hexadecimal color codes using map.",
    "code": "```pascal\nprogram RGBToHexMap;\n\ntype\n  TRGB = record\n    R, G, B: Byte;\n  end;\n\nfunction RGBToHex(rgb: TRGB): string;\nbegin\n  Result := Format('#%.2x%.2x%.2x', [rgb.R, rgb.G, rgb.B]);\nend;\n\nvar\n  RGBList: array of TRGB;\n  HexList: array of string;\n  i: Integer;\nbegin\n  // Example list of RGB tuples\n  RGBList := [ (R: 255; G: 0; B: 0), (R: 0; G: 255; B: 0), (R: 0; G: 0; B: 255) ];\n  SetLength(HexList, Length(RGBList));\n\n  for i := 0 to High(RGBList) do\n    HexList[i] := RGBToHex(RGBList[i]);\n\n  // Output the results\n  for i := 0 to High(HexList) do\n    Writeln(HexList[i]);\nend.\n```"
  },
  {
    "task": "Use map to compute the factorial of each number in a list.",
    "code": "```pascal\nprogram MapFactorial;\n\nuses SysUtils;\n\ntype\n  TIntArray = array of Integer;\n\nfunction Factorial(n: Integer): Integer;\nvar\n  i, result: Integer;\nbegin\n  result := 1;\n  for i := 2 to n do\n    result := result * i;\n  Factorial := result;\nend;\n\nfunction MapFactorial(arr: TIntArray): TIntArray;\nvar\n  i: Integer;\nbegin\n  SetLength(MapFactorial, Length(arr));\n  for i := Low(arr) to High(arr) do\n    MapFactorial[i] := Factorial(arr[i]);\nend;\n\nvar\n  numbers, factorials: TIntArray;\n  i: Integer;\nbegin\n  numbers := TIntArray.Create(1, 2, 3, 4, 5);\n  factorials := MapFactorial(numbers);\n  \n  for i := Low(factorials) to High(factorials) do\n    WriteLn('Factorial of ', numbers[i], ' is ', factorials[i]);\nend.\n```"
  },
  {
    "task": "Translate a list of English words to Spanish using a map function.",
    "code": "```pascal\nprogram TranslateWords;\n\ntype\n  TStringArray = array of string;\n\nfunction Translate(word: string): string;\nbegin\n  if word = 'hello' then\n    Exit('hola')\n  else if word = 'world' then\n    Exit('mundo')\n  else if word = 'good' then\n    Exit('bueno')\n  else if word = 'morning' then\n    Exit('ma\u00f1ana')\n  else\n    Exit(word);\nend;\n\nfunction MapTranslate(words: TStringArray; translateFunc: function(word: string): string): TStringArray;\nvar\n  i: Integer;\nbegin\n  SetLength(Result, Length(words));\n  for i := Low(words) to High(words) do\n    Result[i] := translateFunc(words[i]);\nend;\n\nvar\n  englishWords, spanishWords: TStringArray;\n  i: Integer;\nbegin\n  englishWords := TStringArray.Create('hello', 'world', 'good', 'morning');\n  spanishWords := MapTranslate(englishWords, Translate);\n\n  for i := Low(spanishWords) to High(spanishWords) do\n    WriteLn(spanishWords[i]);\nend.\n```"
  },
  {
    "task": "Apply a map function to format a list of dates from one format to another.",
    "code": "```pascal\nprogram FormatDates;\n\nuses\n  SysUtils;\n\ntype\n  TDateArray = array of string;\n  TFormatFunction = function(const DateStr: string): string;\n\nfunction FormatDate(const DateStr: string): string;\nvar\n  DateValue: TDateTime;\nbegin\n  DateValue := StrToDate(DateStr); // Assuming input format is 'dd/mm/yyyy'\n  Result := FormatDateTime('yyyy-mm-dd', DateValue); // Convert to 'yyyy-mm-dd'\nend;\n\nprocedure MapDates(var Dates: TDateArray; FormatFunc: TFormatFunction);\nvar\n  i: Integer;\nbegin\n  for i := 0 to High(Dates) do\n    Dates[i] := FormatFunc(Dates[i]);\nend;\n\nvar\n  Dates: TDateArray;\n  i: Integer;\nbegin\n  Dates := TDateArray.Create('01/12/2023', '15/01/2024', '23/11/2023');\n  MapDates(Dates, @FormatDate);\n  \n  for i := 0 to High(Dates) do\n    WriteLn(Dates[i]);\nend.\n```"
  },
  {
    "task": "Use map to check if each number in a list is even, returning a list of booleans.",
    "code": "```pascal\nprogram CheckEven;\n\nuses\n  SysUtils;\n\ntype\n  TIntArray = array of Integer;\n  TBoolArray = array of Boolean;\n\nfunction IsEven(n: Integer): Boolean;\nbegin\n  Result := n mod 2 = 0;\nend;\n\nfunction MapArray(arr: TIntArray; func: function(n: Integer): Boolean): TBoolArray;\nvar\n  i: Integer;\nbegin\n  SetLength(Result, Length(arr));\n  for i := Low(arr) to High(arr) do\n    Result[i] := func(arr[i]);\nend;\n\nvar\n  numbers: TIntArray;\n  results: TBoolArray;\n  i: Integer;\nbegin\n  numbers := TIntArray.Create(1, 2, 3, 4, 5, 6);\n  results := MapArray(numbers, @IsEven);\n\n  for i := Low(results) to High(results) do\n    WriteLn(BoolToStr(results[i], True));\nend.\n```"
  },
  {
    "task": "Convert a list of binary strings to decimal numbers using map.",
    "code": "```pascal\nprogram BinaryStringsToDecimal;\n\nuses\n  SysUtils;\n\ntype\n  TStringArray = array of string;\n  TIntegerArray = array of Integer;\n\nfunction BinStrToDec(const BinStr: string): Integer;\nvar\n  i, Value, Power: Integer;\nbegin\n  Value := 0;\n  Power := 1;\n  for i := Length(BinStr) downto 1 do\n  begin\n    if BinStr[i] = '1' then\n      Value := Value + Power;\n    Power := Power * 2;\n  end;\n  Result := Value;\nend;\n\nfunction MapBinaryStringsToDecimal(const BinStrings: TStringArray): TIntegerArray;\nvar\n  i: Integer;\nbegin\n  SetLength(Result, Length(BinStrings));\n  for i := Low(BinStrings) to High(BinStrings) do\n  begin\n    Result[i] := BinStrToDec(BinStrings[i]);\n  end;\nend;\n\nvar\n  BinaryStrings: TStringArray;\n  DecimalNumbers: TIntegerArray;\n  i: Integer;\nbegin\n  BinaryStrings := TStringArray.Create('101', '110', '111');\n  DecimalNumbers := MapBinaryStringsToDecimal(BinaryStrings);\n  for i := Low(DecimalNumbers) to High(DecimalNumbers) do\n  begin\n    WriteLn(DecimalNumbers[i]);\n  end;\nend.\n```"
  },
  {
    "task": "Use map to append a domain name to a list of user names to create email addresses.",
    "code": "```pascal\nprogram EmailAddressMap;\n\nuses\n  SysUtils;\n\nfunction AppendDomain(const UserName: string; const Domain: string): string;\nbegin\n  Result := UserName + '@' + Domain;\nend;\n\nprocedure Map(const UserNames: array of string; const Domain: string; var Emails: array of string);\nvar\n  I: Integer;\nbegin\n  for I := Low(UserNames) to High(UserNames) do\n  begin\n    Emails[I] := AppendDomain(UserNames[I], Domain);\n  end;\nend;\n\nvar\n  UserNames: array of string;\n  Emails: array of string;\n  Domain: string;\nbegin\n  UserNames := ['alice', 'bob', 'charlie'];\n  SetLength(Emails, Length(UserNames));\n  Domain := 'example.com';\n\n  Map(UserNames, Domain, Emails);\n  \n  // Example of processing the Emails array\n  for var I := Low(Emails) to High(Emails) do\n    Writeln(Emails[I]);\nend.\n```"
  },
  {
    "task": "Calculate the area of each circle in a list of radii using a map function.",
    "code": "```pascal\nprogram CalculateAreas;\n\nuses\n  SysUtils, Math;\n\ntype\n  TRealArray = array of Real;\n\nfunction MapRadiiToAreas(radii: TRealArray): TRealArray;\nvar\n  i: Integer;\nbegin\n  SetLength(Result, Length(radii));\n  for i := Low(radii) to High(radii) do\n    Result[i] := Pi * Power(radii[i], 2);\nend;\n\nvar\n  radii, areas: TRealArray;\n  i: Integer;\nbegin\n  radii := TRealArray.Create(1.0, 2.0, 3.0, 4.0, 5.0);\n  areas := MapRadiiToAreas(radii);\n\n  for i := Low(areas) to High(areas) do\n    WriteLn(Format('Area of circle with radius %.2f is %.2f', [radii[i], areas[i]]));\nend.\n```"
  },
  {
    "task": "Use map to strip whitespace from the start and end of each string in a list.",
    "code": "```pascal\nprogram StripWhitespace;\n\nuses\n  SysUtils;\n\nvar\n  strings: array of string;\n  trimmedStrings: array of string;\n  i: Integer;\n\nfunction TrimString(s: string): string;\nbegin\n  Result := Trim(s);\nend;\n\nbegin\n  strings := ['  hello  ', '  world', 'pascal  ', ' programming '];\n  SetLength(trimmedStrings, Length(strings));\n\n  for i := 0 to High(strings) do\n  begin\n    trimmedStrings[i] := TrimString(strings[i]);\n  end;\n\n  for i := 0 to High(trimmedStrings) do\n  begin\n    WriteLn(trimmedStrings[i]);\n  end;\nend.\n```"
  },
  {
    "task": "Apply map to replace spaces with underscores in a list of file paths.",
    "code": "```pascal\nprogram ReplaceSpacesWithUnderscores;\n\nuses\n  SysUtils;\n\ntype\n  TStringArray = array of string;\n\nfunction ReplaceSpaces(const s: string): string;\nbegin\n  Result := StringReplace(s, ' ', '_', [rfReplaceAll]);\nend;\n\nfunction Map(const arr: TStringArray; func: function(const s: string): string): TStringArray;\nvar\n  i: Integer;\nbegin\n  SetLength(Result, Length(arr));\n  for i := 0 to High(arr) do\n    Result[i] := func(arr[i]);\nend;\n\nvar\n  filePaths, updatedPaths: TStringArray;\n  i: Integer;\nbegin\n  filePaths := TStringArray.Create('path with spaces/file1.txt', 'another path/file2.txt', 'yet another path/file3.txt');\n  updatedPaths := Map(filePaths, ReplaceSpaces);\n\n  for i := 0 to High(updatedPaths) do\n    WriteLn(updatedPaths[i]);\nend.\n```"
  },
  {
    "task": "Convert a list of mixed-case strings to title case using map.",
    "code": "```pascal\nprogram TitleCaseMap;\n\nuses\n  SysUtils;\n\nfunction ToTitleCase(const s: string): string;\nvar\n  i: Integer;\n  inWord: Boolean;\nbegin\n  Result := LowerCase(s);\n  inWord := False;\n  for i := 1 to Length(Result) do\n  begin\n    if not inWord and (Result[i] in ['a'..'z']) then\n    begin\n      Result[i] := UpCase(Result[i]);\n      inWord := True;\n    end\n    else if not (Result[i] in ['a'..'z', 'A'..'Z']) then\n      inWord := False;\n  end;\nend;\n\nprocedure MapTitleCase(var strs: array of string);\nvar\n  i: Integer;\nbegin\n  for i := Low(strs) to High(strs) do\n    strs[i] := ToTitleCase(strs[i]);\nend;\n\nvar\n  strings: array of string;\n  i: Integer;\nbegin\n  strings := ['hello world', 'pascal PROGRAMMING', 'functional map'];\n\n  MapTitleCase(strings);\n\n  for i := Low(strings) to High(strings) do\n    WriteLn(strings[i]);\nend.\n```"
  },
  {
    "task": "Use map to filter out only the digits from a list of mixed alphanumeric strings.",
    "code": "```pascal\nprogram FilterDigitsUsingMap;\n\nuses\n  SysUtils;\n\ntype\n  TStringArray = array of string;\n\nfunction MapToDigits(const arr: TStringArray): TStringArray;\nvar\n  i, j, idx: Integer;\n  temp: string;\nbegin\n  SetLength(Result, Length(arr));\n  for i := 0 to High(arr) do\n  begin\n    temp := '';\n    for j := 1 to Length(arr[i]) do\n      if arr[i][j] in ['0'..'9'] then\n        temp := temp + arr[i][j];\n    Result[i] := temp;\n  end;\nend;\n\nvar\n  InputArray, DigitsArray: TStringArray;\n  i: Integer;\nbegin\n  InputArray := TStringArray.Create('abc123', 'def456', '78ghi', 'jkl90mno');\n  DigitsArray := MapToDigits(InputArray);\n  \n  for i := 0 to High(DigitsArray) do\n    WriteLn(DigitsArray[i]);\nend.\n```"
  },
  {
    "task": "Apply map to convert a list of Unix timestamps to readable date strings.",
    "code": "```pascal\nprogram TimestampsToDateStrings;\n\nuses\n  SysUtils, DateUtils;\n\ntype\n  TDateStringArray = array of string;\n  TTimestampArray = array of Int64;\n\nfunction MapTimestampsToDates(timestamps: TTimestampArray): TDateStringArray;\nvar\n  i: Integer;\n  dateTime: TDateTime;\nbegin\n  SetLength(Result, Length(timestamps));\n  for i := 0 to High(timestamps) do\n  begin\n    dateTime := UnixToDateTime(timestamps[i]);\n    Result[i] := DateTimeToStr(dateTime);\n  end;\nend;\n\nvar\n  timestamps: TTimestampArray;\n  dateStrings: TDateStringArray;\n  i: Integer;\nbegin\n  timestamps := TTimestampArray.Create(1609459200, 1612137600, 1614556800);\n  dateStrings := MapTimestampsToDates(timestamps);\n\n  for i := 0 to High(dateStrings) do\n    WriteLn(dateStrings[i]);\nend.\n```"
  },
  {
    "task": "Transform a list of dictionary objects by extracting a specific key's value using map.",
    "code": "```pascal\nprogram FunctionalMapExample;\nuses SysUtils;\n\ntype\n  TDictionary = record\n    Key1: string;\n    Key2: string;\n  end;\n\nvar\n  dictionaries: array of TDictionary;\n  values: array of string;\n  i: Integer;\n\nfunction ExtractKey2Value(const Dict: TDictionary): string;\nbegin\n  Result := Dict.Key2;\nend;\n\nbegin\n  // Sample data\n  SetLength(dictionaries, 3);\n  dictionaries[0].Key1 := 'Value1_1';\n  dictionaries[0].Key2 := 'Value1_2';\n  dictionaries[1].Key1 := 'Value2_1';\n  dictionaries[1].Key2 := 'Value2_2';\n  dictionaries[2].Key1 := 'Value3_1';\n  dictionaries[2].Key2 := 'Value3_2';\n\n  // Transform using map\n  SetLength(values, Length(dictionaries));\n  for i := 0 to High(dictionaries) do\n  begin\n    values[i] := ExtractKey2Value(dictionaries[i]);\n  end;\n\n  // Example output\n  for i := 0 to High(values) do\n  begin\n    WriteLn(values[i]);\n  end;\nend.\n```"
  },
  {
    "task": "Use map to compute the cube of each number in a list.",
    "code": "```pascal\nprogram CubeMap;\n\ntype\n  IntArray = array of Integer;\n\nfunction MapCube(arr: IntArray): IntArray;\nvar\n  i: Integer;\nbegin\n  SetLength(Result, Length(arr));\n  for i := 0 to High(arr) do\n    Result[i] := arr[i] * arr[i] * arr[i];\nend;\n\nvar\n  numbers, cubedNumbers: IntArray;\n  i: Integer;\nbegin\n  numbers := IntArray.Create(1, 2, 3, 4, 5);\n  cubedNumbers := MapCube(numbers);\n\n  for i := 0 to High(cubedNumbers) do\n    WriteLn(cubedNumbers[i]);\nend.\n```"
  },
  {
    "task": "Translate a list of URLs to their respective domain names using a map function.",
    "code": "```pascal\nprogram MapFunction;\n\nuses\n  SysUtils, Classes;\n\nfunction GetDomainName(const URL: string): string;\nvar\n  URI: TURI;\nbegin\n  URI := TURI.Create(URL);\n  Result := URI.Host;\nend;\n\nfunction MapURLsToDomains(const URLs: array of string): TStringList;\nvar\n  I: Integer;\n  Domains: TStringList;\nbegin\n  Domains := TStringList.Create;\n  for I := Low(URLs) to High(URLs) do\n    Domains.Add(GetDomainName(URLs[I]));\n  Result := Domains;\nend;\n\nvar\n  URLs: array of string;\n  Domains: TStringList;\n  I: Integer;\nbegin\n  URLs := ['http://example.com/path', 'https://www.example.org', 'ftp://example.net/resource'];\n\n  Domains := MapURLsToDomains(URLs);\n\n  for I := 0 to Domains.Count - 1 do\n    WriteLn(Domains[I]);\n\n  Domains.Free;\nend.\n```"
  },
  {
    "task": "Use map to generate HTML list items from a list of text strings.",
    "code": "```pascal\nprogram HTMLListItems;\n\nuses\n  SysUtils;\n\ntype\n  TStringArray = array of string;\n\nfunction MapToHTMLListItems(arr: TStringArray): TStringArray;\nvar\n  i: Integer;\nbegin\n  SetLength(Result, Length(arr));\n  for i := 0 to High(arr) do\n  begin\n    Result[i] := '<li>' + arr[i] + '</li>';\n  end;\nend;\n\nvar\n  textList, htmlList: TStringArray;\n  i: Integer;\nbegin\n  textList := TStringArray.Create('Item 1', 'Item 2', 'Item 3');\n\n  htmlList := MapToHTMLListItems(textList);\n\n  for i := 0 to High(htmlList) do\n  begin\n    WriteLn(htmlList[i]);\n  end;\nend.\n```"
  },
  {
    "task": "Convert a list of polar coordinates to Cartesian coordinates using map.",
    "code": "```pascal\nprogram PolarToCartesian;\n\ntype\n  TPolarCoord = record\n    r, theta: Real;\n  end;\n\n  TCartesianCoord = record\n    x, y: Real;\n  end;\n\nfunction PolarToCartesianMap(p: TPolarCoord): TCartesianCoord;\nbegin\n  PolarToCartesianMap.x := p.r * Cos(p.theta);\n  PolarToCartesianMap.y := p.r * Sin(p.theta);\nend;\n\nfunction MapPolarToCartesian(polarCoords: array of TPolarCoord): array of TCartesianCoord;\nvar\n  i: Integer;\nbegin\n  SetLength(Result, Length(polarCoords));\n  for i := 0 to High(polarCoords) do\n  begin\n    Result[i] := PolarToCartesianMap(polarCoords[i]);\n  end;\nend;\n\nvar\n  polarCoords: array of TPolarCoord;\n  cartesianCoords: array of TCartesianCoord;\nbegin\n  // Example usage:\n  SetLength(polarCoords, 2);\n  polarCoords[0].r := 1.0;\n  polarCoords[0].theta := Pi / 4;\n  polarCoords[1].r := 2.0;\n  polarCoords[1].theta := Pi / 3;\n\n  cartesianCoords := MapPolarToCartesian(polarCoords);\n\n  // Output the results (for demonstration purposes)\n  WriteLn('Cartesian Coordinates:');\n  WriteLn('(', cartesianCoords[0].x:0:2, ', ', cartesianCoords[0].y:0:2, ')');\n  WriteLn('(', cartesianCoords[1].x:0:2, ', ', cartesianCoords[1].y:0:2, ')');\nend.\n```"
  },
  {
    "task": "Use map to decode a list of Base64 encoded strings.",
    "code": "```pascal\nprogram DecodeBase64;\n\nuses\n  SysUtils, Classes, base64;\n\nfunction DecodeString(const EncodedStr: string): string;\nbegin\n  Result := DecodeStringBase64(EncodedStr);\nend;\n\nvar\n  EncodedList, DecodedList: TStringList;\n  i: Integer;\nbegin\n  EncodedList := TStringList.Create;\n  DecodedList := TStringList.Create;\n  try\n    // Example encoded strings\n    EncodedList.Add('SGVsbG8sIFdvcmxkIQ==');\n    EncodedList.Add('UGFzY2FsIGlzIGZ1biE=');\n\n    for i := 0 to EncodedList.Count - 1 do\n    begin\n      DecodedList.Add(DecodeString(EncodedList[i]));\n    end;\n\n    // Output decoded strings\n    for i := 0 to DecodedList.Count - 1 do\n    begin\n      WriteLn(DecodedList[i]);\n    end;\n  finally\n    EncodedList.Free;\n    DecodedList.Free;\n  end;\nend.\n```"
  },
  {
    "task": "Convert a list of English sentences to Pig Latin using a map function.",
    "code": "```pascal\nprogram PigLatinConverter;\n\nuses\n  SysUtils;\n\ntype\n  TStringArray = array of string;\n\nfunction ConvertToPigLatin(const sentence: string): string;\nvar\n  words, result: TStringArray;\n  i: Integer;\n  firstLetter, restOfWord: string;\nbegin\n  words := sentence.Split([' ']);\n  SetLength(result, Length(words));\n  for i := Low(words) to High(words) do\n  begin\n    firstLetter := words[i][1];\n    restOfWord := Copy(words[i], 2, Length(words[i]) - 1);\n    result[i] := restOfWord + firstLetter + 'ay';\n  end;\n  ConvertToPigLatin := String.Join(' ', result);\nend;\n\nfunction MapPigLatin(const sentences: TStringArray; mapFunc: TFunc<string, string>): TStringArray;\nvar\n  i: Integer;\nbegin\n  SetLength(MapPigLatin, Length(sentences));\n  for i := Low(sentences) to High(sentences) do\n  begin\n    MapPigLatin[i] := mapFunc(sentences[i]);\n  end;\nend;\n\nvar\n  sentences, pigLatinSentences: TStringArray;\n  i: Integer;\nbegin\n  sentences := TStringArray.Create('Hello world', 'Pascal is great', 'Functional programming');\n  pigLatinSentences := MapPigLatin(sentences, @ConvertToPigLatin);\n  \n  for i := Low(pigLatinSentences) to High(pigLatinSentences) do\n  begin\n    WriteLn(pigLatinSentences[i]);\n  end;\nend.\n```"
  },
  {
    "task": "Use map to anonymize a list of email addresses by masking them.",
    "code": "```pascal\nprogram AnonymizeEmails;\n\nuses\n  SysUtils;\n\ntype\n  TStringArray = array of string;\n\nfunction MaskEmail(const email: string): string;\nvar\n  atIndex: Integer;\nbegin\n  atIndex := Pos('@', email);\n  if atIndex > 1 then\n    Result := Copy(email, 1, 1) + '***' + Copy(email, atIndex, Length(email))\n  else\n    Result := email; // Return as is if no '@' found\nend;\n\nfunction MapEmails(const emails: TStringArray; maskFunc: function(const email: string): string): TStringArray;\nvar\n  i: Integer;\nbegin\n  SetLength(Result, Length(emails));\n  for i := Low(emails) to High(emails) do\n    Result[i] := maskFunc(emails[i]);\nend;\n\nvar\n  emails, maskedEmails: TStringArray;\n  i: Integer;\nbegin\n  emails := TStringArray.Create('user1@example.com', 'user2@example.com', 'user3@example.com');\n  maskedEmails := MapEmails(emails, @MaskEmail);\n\n  for i := Low(maskedEmails) to High(maskedEmails) do\n    WriteLn(maskedEmails[i]);\nend.\n```"
  },
  {
    "task": "Apply map to reverse each string in a list of words.",
    "code": "```pascal\nprogram ReverseWords;\n\nuses\n  SysUtils;\n\nfunction ReverseString(const S: string): string;\nvar\n  i: Integer;\nbegin\n  Result := '';\n  for i := Length(S) downto 1 do\n    Result := Result + S[i];\nend;\n\nprocedure MapReverseWords(var Words: array of string);\nvar\n  i: Integer;\nbegin\n  for i := Low(Words) to High(Words) do\n    Words[i] := ReverseString(Words[i]);\nend;\n\nvar\n  Words: array of string;\n  i: Integer;\nbegin\n  Words := ['hello', 'world', 'pascal'];\n  \n  MapReverseWords(Words);\n\n  for i := Low(Words) to High(Words) do\n    WriteLn(Words[i]);\nend.\n```"
  },
  {
    "task": "Convert a list of hexadecimal color codes to RGB tuples using map.",
    "code": "```pascal\nprogram HexToRGB;\n\ntype\n  TColorTuple = record\n    R, G, B: Byte;\n  end;\n\nfunction HexToColorTuple(HexColor: String): TColorTuple;\nvar\n  ColorValue: LongInt;\nbegin\n  if Length(HexColor) = 7 then\n    HexColor := Copy(HexColor, 2, 6);\n\n  ColorValue := StrToInt('$' + HexColor);\n  Result.R := (ColorValue shr 16) and $FF;\n  Result.G := (ColorValue shr 8) and $FF;\n  Result.B := ColorValue and $FF;\nend;\n\nfunction MapHexColorsToRGB(HexColors: array of String): array of TColorTuple;\nvar\n  I: Integer;\nbegin\n  SetLength(Result, Length(HexColors));\n  for I := 0 to High(HexColors) do\n  begin\n    Result[I] := HexToColorTuple(HexColors[I]);\n  end;\nend;\n\nvar\n  HexColors: array of String;\n  RGBColors: array of TColorTuple;\n  I: Integer;\nbegin\n  HexColors := ['#FF5733', '#33FF57', '#3357FF'];\n  RGBColors := MapHexColorsToRGB(HexColors);\n\n  for I := 0 to High(RGBColors) do\n    WriteLn('R: ', RGBColors[I].R, ', G: ', RGBColors[I].G, ', B: ', RGBColors[I].B);\nend.\n```"
  },
  {
    "task": "Use map to increment each integer in a list by a constant value.",
    "code": "```pascal\nprogram IncrementList;\n\nuses SysUtils;\n\ntype\n  TIntArray = array of Integer;\n\nfunction MapIncrement(const arr: TIntArray; increment: Integer): TIntArray;\nvar\n  i: Integer;\nbegin\n  SetLength(Result, Length(arr));\n  for i := 0 to High(arr) do\n    Result[i] := arr[i] + increment;\nend;\n\nvar\n  originalList, incrementedList: TIntArray;\n  i, constantValue: Integer;\nbegin\n  originalList := [1, 2, 3, 4, 5];\n  constantValue := 1;\n  \n  incrementedList := MapIncrement(originalList, constantValue);\n  \n  for i := 0 to High(incrementedList) do\n    WriteLn(incrementedList[i]);\nend.\n```"
  },
  {
    "task": "Calculate the square root of each number in a list using a map function.",
    "code": "```pascal\nprogram SquareRootMap;\n\nuses\n  SysUtils, Math;\n\ntype\n  TRealArray = array of Real;\n\nfunction MapArray(arr: TRealArray; func: function(x: Real): Real): TRealArray;\nvar\n  i: Integer;\nbegin\n  SetLength(Result, Length(arr));\n  for i := 0 to High(arr) do\n    Result[i] := func(arr[i]);\nend;\n\nfunction SquareRoot(x: Real): Real;\nbegin\n  Result := Sqrt(x);\nend;\n\nvar\n  numbers, results: TRealArray;\n  i: Integer;\nbegin\n  numbers := TRealArray.Create(1.0, 4.0, 9.0, 16.0, 25.0);\n  results := MapArray(numbers, @SquareRoot);\n\n  for i := 0 to High(results) do\n    WriteLn('Square root of ', numbers[i]:0:2, ' is ', results[i]:0:2);\nend.\n```"
  },
  {
    "task": "Use map to convert a list of currency amounts from dollars to euros.",
    "code": "```pascal\nprogram ConvertCurrency;\n\ntype\n  TCurrencyArray = array of Real;\n\nfunction DollarToEuro(dollar: Real): Real;\nconst\n  ExchangeRate = 0.85; // Example exchange rate\nbegin\n  DollarToEuro := dollar * ExchangeRate;\nend;\n\nfunction MapCurrencyArray(converter: function(dollar: Real): Real; amounts: TCurrencyArray): TCurrencyArray;\nvar\n  i: Integer;\nbegin\n  SetLength(Result, Length(amounts));\n  for i := 0 to High(amounts) do\n    Result[i] := converter(amounts[i]);\nend;\n\nvar\n  DollarAmounts, EuroAmounts: TCurrencyArray;\n  i: Integer;\nbegin\n  DollarAmounts := TCurrencyArray.Create(10.0, 20.0, 50.0, 100.0);\n  EuroAmounts := MapCurrencyArray(@DollarToEuro, DollarAmounts);\n\n  for i := 0 to High(EuroAmounts) do\n    writeln('Amount in Euros: ', EuroAmounts[i]:0:2);\nend.\n```"
  },
  {
    "task": "Extract the domain from each email address in a list using map.",
    "code": "```pascal\nprogram ExtractDomainFromEmails;\n\nuses SysUtils;\n\ntype\n  TStringArray = array of string;\n\nfunction ExtractDomain(const email: string): string;\nvar\n  atPos: Integer;\nbegin\n  atPos := Pos('@', email);\n  if atPos > 0 then\n    Result := Copy(email, atPos + 1, Length(email) - atPos)\n  else\n    Result := '';\nend;\n\nfunction MapEmailsToDomains(const emails: TStringArray): TStringArray;\nvar\n  i: Integer;\nbegin\n  SetLength(Result, Length(emails));\n  for i := 0 to High(emails) do\n    Result[i] := ExtractDomain(emails[i]);\nend;\n\nvar\n  emails, domains: TStringArray;\n  i: Integer;\nbegin\n  emails := TStringArray.Create('user1@example.com', 'user2@test.org', 'user3@domain.net');\n  domains := MapEmailsToDomains(emails);\n\n  for i := 0 to High(domains) do\n    Writeln(domains[i]);\nend.\n```"
  },
  {
    "task": "Use map to serialize a list of objects into JSON strings.",
    "code": "```pascal\nprogram SerializeObjects;\n\nuses\n  SysUtils, Classes, fpjson, jsonparser, typinfo;\n\ntype\n  TMyObject = class\n  private\n    FName: string;\n    FAge: Integer;\n  public\n    constructor Create(AName: string; AAge: Integer);\n    function ToJSON: string;\n  end;\n\nfunction MapToJSON(ObjList: array of TMyObject): TStringList;\nvar\n  i: Integer;\n  JSONList: TStringList;\nbegin\n  JSONList := TStringList.Create;\n  for i := Low(ObjList) to High(ObjList) do\n    JSONList.Add(ObjList[i].ToJSON);\n  Result := JSONList;\nend;\n\nconstructor TMyObject.Create(AName: string; AAge: Integer);\nbegin\n  FName := AName;\n  FAge := AAge;\nend;\n\nfunction TMyObject.ToJSON: string;\nvar\n  JSONObject: TJSONObject;\nbegin\n  JSONObject := TJSONObject.Create;\n  try\n    JSONObject.Add('Name', FName);\n    JSONObject.Add('Age', FAge);\n    Result := JSONObject.AsJSON;\n  finally\n    JSONObject.Free;\n  end;\nend;\n\nvar\n  ObjectList: array of TMyObject;\n  JSONStrings: TStringList;\n  i: Integer;\nbegin\n  SetLength(ObjectList, 2);\n  ObjectList[0] := TMyObject.Create('Alice', 30);\n  ObjectList[1] := TMyObject.Create('Bob', 25);\n\n  JSONStrings := MapToJSON(ObjectList);\n  try\n    for i := 0 to JSONStrings.Count - 1 do\n      WriteLn(JSONStrings[i]);\n  finally\n    JSONStrings.Free;\n    for i := Low(ObjectList) to High(ObjectList) do\n      ObjectList[i].Free;\n  end;\nend.\n```"
  },
  {
    "task": "Transform a list of file sizes from bytes to kilobytes using map.",
    "code": "```pascal\nprogram TransformFileSizes;\n\nuses\n  SysUtils;\n\ntype\n  TIntegerArray = array of Integer;\n\nfunction MapToKilobytes(sizes: TIntegerArray): TIntegerArray;\nvar\n  i: Integer;\nbegin\n  SetLength(Result, Length(sizes));\n  for i := 0 to High(sizes) do\n    Result[i] := sizes[i] div 1024;\nend;\n\nvar\n  byteSizes: TIntegerArray;\n  kiloByteSizes: TIntegerArray;\n  i: Integer;\nbegin\n  byteSizes := TIntegerArray.Create(2048, 4096, 8192, 16384);\n  kiloByteSizes := MapToKilobytes(byteSizes);\n\n  for i := 0 to High(kiloByteSizes) do\n    WriteLn(kiloByteSizes[i]);\nend.\n```"
  },
  {
    "task": "Use map to append a suffix to each string in a list of identifiers.",
    "code": "```pascal\nprogram AppendSuffix;\n\nuses\n  SysUtils;\n\ntype\n  TStringArray = array of string;\n\nfunction MapSuffix(const identifiers: TStringArray; const suffix: string): TStringArray;\nvar\n  i: Integer;\nbegin\n  SetLength(Result, Length(identifiers));\n  for i := Low(identifiers) to High(identifiers) do\n  begin\n    Result[i] := identifiers[i] + suffix;\n  end;\nend;\n\nvar\n  Ids, ModifiedIds: TStringArray;\n  i: Integer;\nbegin\n  Ids := TStringArray.Create('id1', 'id2', 'id3');\n  ModifiedIds := MapSuffix(Ids, '_suffix');\n\n  for i := Low(ModifiedIds) to High(ModifiedIds) do\n  begin\n    WriteLn(ModifiedIds[i]);\n  end;\nend.\n```"
  },
  {
    "task": "Apply map to convert measurements from inches to centimeters in a list.",
    "code": "```pascal\nprogram ConvertInchesToCentimeters;\n\nuses\n  SysUtils;\n\ntype\n  TDoubleArray = array of Double;\n\nfunction MapInchesToCentimeters(measurements: TDoubleArray): TDoubleArray;\nvar\n  i: Integer;\nbegin\n  SetLength(Result, Length(measurements));\n  for i := 0 to High(measurements) do\n    Result[i] := measurements[i] * 2.54;\nend;\n\nvar\n  inches, centimeters: TDoubleArray;\n  i: Integer;\nbegin\n  inches := TDoubleArray.Create(1.0, 2.0, 3.5, 4.0, 5.5);\n  centimeters := MapInchesToCentimeters(inches);\n\n  for i := 0 to High(centimeters) do\n    WriteLn(Format('%.2f inches = %.2f centimeters', [inches[i], centimeters[i]]));\nend.\n```"
  },
  {
    "task": "Use map to encrypt a list of plaintext messages using a simple cipher.",
    "code": "```pascal\nprogram EncryptMessages;\n\nuses\n  SysUtils;\n  \ntype\n  TStringArray = array of string;\n\nfunction Encrypt(const message: string): string;\nvar\n  i: Integer;\nbegin\n  Result := '';\n  for i := 1 to Length(message) do\n    Result := Result + Chr(Ord(message[i]) + 1);\nend;\n\nfunction MapEncryptMessages(const messages: TStringArray): TStringArray;\nvar\n  i: Integer;\nbegin\n  SetLength(Result, Length(messages));\n  for i := 0 to High(messages) do\n    Result[i] := Encrypt(messages[i]);\nend;\n\nvar\n  PlainTextMessages, EncryptedMessages: TStringArray;\n  i: Integer;\nbegin\n  PlainTextMessages := TStringArray.Create('Hello', 'World', 'Pascal');\n  EncryptedMessages := MapEncryptMessages(PlainTextMessages);\n  \n  for i := 0 to High(EncryptedMessages) do\n    WriteLn(EncryptedMessages[i]);\nend.\n```"
  },
  {
    "task": "Transform a list of date strings to day of the week names using a map function.",
    "code": "```pascal\nprogram MapDateToDay;\n\nuses\n  SysUtils, DateUtils;\n\ntype\n  TStringArray = array of string;\n\nfunction DateToDayName(DateString: string): string;\nvar\n  Date: TDateTime;\nbegin\n  Date := StrToDate(DateString);\n  Result := FormatDateTime('dddd', Date);\nend;\n\nfunction MapDatesToDays(DateList: TStringArray): TStringArray;\nvar\n  i: Integer;\nbegin\n  SetLength(Result, Length(DateList));\n  for i := 0 to High(DateList) do\n    Result[i] := DateToDayName(DateList[i]);\nend;\n\nvar\n  Dates, Days: TStringArray;\n  i: Integer;\nbegin\n  Dates := TStringArray.Create('2023-10-01', '2023-10-02', '2023-10-03');\n  Days := MapDatesToDays(Dates);\n  for i := 0 to High(Days) do\n    WriteLn(Days[i]);\nend.\n```"
  },
  {
    "task": "Use map to derive the absolute value of each number in a list.",
    "code": "```pascal\nprogram AbsoluteValueMap;\n\nuses\n  SysUtils;\n\ntype\n  TIntegerArray = array of Integer;\n\nfunction MapArray(arr: TIntegerArray; f: function(x: Integer): Integer): TIntegerArray;\nvar\n  i: Integer;\nbegin\n  SetLength(Result, Length(arr));\n  for i := 0 to High(arr) do\n    Result[i] := f(arr[i]);\nend;\n\nfunction AbsoluteValue(x: Integer): Integer;\nbegin\n  Result := Abs(x);\nend;\n\nvar\n  numbers, absoluteValues: TIntegerArray;\n  i: Integer;\nbegin\n  numbers := TIntegerArray.Create(-5, -1, 0, 2, 3, -8);\n  absoluteValues := MapArray(numbers, @AbsoluteValue);\n\n  for i := 0 to High(absoluteValues) do\n    WriteLn(absoluteValues[i]);\nend.\n```"
  },
  {
    "task": "Convert a list of lowercase hexadecimal strings to uppercase using map.",
    "code": "```pascal\nprogram HexToUpper;\n\ntype\n  TStringArray = array of string;\n\nfunction ToUpperHex(const s: string): string;\nvar\n  i: Integer;\nbegin\n  Result := '';\n  for i := 1 to Length(s) do\n    Result := Result + UpCase(s[i]);\nend;\n\nfunction MapHexToUpper(const hexList: TStringArray): TStringArray;\nvar\n  i: Integer;\nbegin\n  SetLength(Result, Length(hexList));\n  for i := Low(hexList) to High(hexList) do\n    Result[i] := ToUpperHex(hexList[i]);\nend;\n\nvar\n  hexList, upperList: TStringArray;\nbegin\n  hexList := TStringArray.Create('1a3f', '4b2c', 'dead', 'beef');\n  upperList := MapHexToUpper(hexList);\n\n  { Output the result }\n  for var i := Low(upperList) to High(upperList) do\n    WriteLn(upperList[i]);\nend.\n```"
  },
  {
    "task": "Use map to find the maximum value in a list of lists of numbers.",
    "code": "```pascal\nprogram MaxValueInListOfLists;\n\nuses\n  SysUtils;\n\ntype\n  TIntArray = array of Integer;\n  TIntArrayArray = array of TIntArray;\n\nvar\n  ListOfLists: TIntArrayArray;\n  MaxValues: TIntArray;\n  MaxValue, I: Integer;\n\nfunction MaxInList(L: TIntArray): Integer;\nvar\n  I, MaxValue: Integer;\nbegin\n  if Length(L) = 0 then\n    Exit(0);\n  MaxValue := L[0];\n  for I := 1 to High(L) do\n    if L[I] > MaxValue then\n      MaxValue := L[I];\n  Result := MaxValue;\nend;\n\nbegin\n  ListOfLists := [[1, 2, 3], [4, 5, 6], [7, 8, 9]];\n  SetLength(MaxValues, Length(ListOfLists));\n\n  for I := 0 to High(ListOfLists) do\n    MaxValues[I] := MaxInList(ListOfLists[I]);\n\n  MaxValue := MaxInList(MaxValues);\n  WriteLn('Maximum value: ', MaxValue);\nend.\n```"
  },
  {
    "task": "Apply map to extract the year from each date in a list of date objects.",
    "code": "```pascal\nprogram ExtractYearFromDates;\n\ntype\n  TDate = record\n    Year: Integer;\n    Month: Integer;\n    Day: Integer;\n  end;\n\nvar\n  Dates: array of TDate;\n  Years: array of Integer;\n  i: Integer;\n\nfunction MapExtractYear(Date: TDate): Integer;\nbegin\n  Result := Date.Year;\nend;\n\nbegin\n  SetLength(Dates, 3);\n  Dates[0].Year := 2023; Dates[0].Month := 10; Dates[0].Day := 5;\n  Dates[1].Year := 2022; Dates[1].Month := 5; Dates[1].Day := 15;\n  Dates[2].Year := 2021; Dates[2].Month := 12; Dates[2].Day := 25;\n\n  SetLength(Years, Length(Dates));\n  \n  for i := 0 to High(Dates) do\n    Years[i] := MapExtractYear(Dates[i]);\n\n  for i := 0 to High(Years) do\n    WriteLn('Year: ', Years[i]);\nend.\n```"
  },
  {
    "task": "Use map to prepend a country code to each phone number in a list.",
    "code": "```pascal\nprogram PrependCountryCode;\n\ntype\n  TStringArray = array of string;\n\nfunction PrependCode(phoneNumbers: TStringArray; countryCode: string): TStringArray;\nvar\n  i: Integer;\nbegin\n  SetLength(Result, Length(phoneNumbers));\n  for i := 0 to High(phoneNumbers) do\n  begin\n    Result[i] := countryCode + phoneNumbers[i];\n  end;\nend;\n\nvar\n  phoneNumbers, updatedNumbers: TStringArray;\n  i: Integer;\nbegin\n  phoneNumbers := TStringArray.Create('123456789', '987654321', '555666777');\n  updatedNumbers := PrependCode(phoneNumbers, '+1');\n\n  for i := 0 to High(updatedNumbers) do\n  begin\n    WriteLn(updatedNumbers[i]);\n  end;\nend.\n```"
  },
  {
    "task": "Capitalize the last letter of each word in a list using a map function.",
    "code": "```pascal\nprogram CapitalizeLastLetter;\n\nuses\n  SysUtils;\n\ntype\n  TStringArray = array of string;\n\nfunction CapitalizeLastLetterOfWord(const word: string): string;\nvar\n  len: Integer;\nbegin\n  len := Length(word);\n  if len = 0 then\n    Exit(word);\n  Result := Copy(word, 1, len - 1) + UpCase(word[len]);\nend;\n\nfunction Map(const arr: TStringArray; func: function(const word: string): string): TStringArray;\nvar\n  i: Integer;\nbegin\n  SetLength(Result, Length(arr));\n  for i := Low(arr) to High(arr) do\n  begin\n    Result[i] := func(arr[i]);\n  end;\nend;\n\nvar\n  words, capitalizedWords: TStringArray;\n  i: Integer;\nbegin\n  words := TStringArray.Create('hello', 'world', 'test', 'pascal');\n  capitalizedWords := Map(words, @CapitalizeLastLetterOfWord);\n\n  for i := Low(capitalizedWords) to High(capitalizedWords) do\n  begin\n    WriteLn(capitalizedWords[i]);\n  end;\nend.\n```"
  },
  {
    "task": "Use map to transform a list of strings by removing all vowels.",
    "code": "```pascal\nprogram RemoveVowels;\n\nuses\n  SysUtils;\n\ntype\n  TStringArray = array of string;\n\nfunction RemoveVowelsFromString(const s: string): string;\nvar\n  i: Integer;\n  ResultBuilder: TStringBuilder;\nbegin\n  ResultBuilder := TStringBuilder.Create;\n  try\n    for i := 1 to Length(s) do\n    begin\n      if not (s[i] in ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']) then\n        ResultBuilder.Append(s[i]);\n    end;\n    Result := ResultBuilder.ToString;\n  finally\n    ResultBuilder.Free;\n  end;\nend;\n\nfunction MapRemoveVowels(const arr: TStringArray): TStringArray;\nvar\n  i: Integer;\nbegin\n  SetLength(Result, Length(arr));\n  for i := Low(arr) to High(arr) do\n  begin\n    Result[i] := RemoveVowelsFromString(arr[i]);\n  end;\nend;\n\nvar\n  strings, transformed: TStringArray;\n  i: Integer;\nbegin\n  strings := TStringArray.Create('example', 'functional', 'programming', 'pascal');\n  transformed := MapRemoveVowels(strings);\n  for i := Low(transformed) to High(transformed) do\n  begin\n    WriteLn(transformed[i]);\n  end;\nend.\n```"
  },
  {
    "task": "Convert a list of music notes to their corresponding frequencies using map.",
    "code": "```pascal\nprogram MusicNotesToFrequencies;\n\nuses\n  SysUtils;\n\ntype\n  TNotesArray = array of string;\n  TFrequenciesArray = array of Real;\n\nfunction NoteToFrequency(note: string): Real;\nbegin\n  case note of\n    'C': Result := 261.63;\n    'D': Result := 293.66;\n    'E': Result := 329.63;\n    'F': Result := 349.23;\n    'G': Result := 392.00;\n    'A': Result := 440.00;\n    'B': Result := 493.88;\n  else\n    raise Exception.Create('Unknown note: ' + note);\n  end;\nend;\n\nfunction MapNotesToFrequencies(notes: TNotesArray): TFrequenciesArray;\nvar\n  i: Integer;\nbegin\n  SetLength(Result, Length(notes));\n  for i := 0 to High(notes) do\n    Result[i] := NoteToFrequency(notes[i]);\nend;\n\nvar\n  Notes: TNotesArray;\n  Frequencies: TFrequenciesArray;\n  i: Integer;\nbegin\n  Notes := TNotesArray.Create('C', 'D', 'E', 'F', 'G', 'A', 'B');\n  Frequencies := MapNotesToFrequencies(Notes);\n  \n  for i := 0 to High(Frequencies) do\n    WriteLn(Format('Note: %s, Frequency: %.2f Hz', [Notes[i], Frequencies[i]]));\nend.\n```"
  },
  {
    "task": "Use map to find the reciprocal of each number in a list.",
    "code": "```pascal\nprogram ReciprocalMap;\n\nuses SysUtils;\n\ntype\n  RealArray = array of Real;\n  RealArrayFunc = function(x: Real): Real;\n\nfunction Map(arr: RealArray; func: RealArrayFunc): RealArray;\nvar\n  i: Integer;\nbegin\n  SetLength(Result, Length(arr));\n  for i := 0 to High(arr) do\n    Result[i] := func(arr[i]);\nend;\n\nfunction Reciprocal(x: Real): Real;\nbegin\n  Result := 1 / x;\nend;\n\nvar\n  numbers, reciprocals: RealArray;\n  i: Integer;\nbegin\n  numbers := RealArray.Create(1.0, 2.0, 4.0, 8.0);\n  reciprocals := Map(numbers, @Reciprocal);\n  \n  for i := 0 to High(reciprocals) do\n    WriteLn(Format('Reciprocal of %.2f is %.2f', [numbers[i], reciprocals[i]]));\nend.\n```"
  },
  {
    "task": "Transform a list of URLs to their shortened versions using a map function.",
    "code": "```pascal\nprogram ShortenURLs;\n\nuses\n  SysUtils;\n\ntype\n  TStringArray = array of string;\n\nfunction ShortenURL(const URL: string): string;\nbegin\n  Result := 'short.ly/' + Copy(URL, 8, 5);\nend;\n\nfunction MapURLs(const URLs: TStringArray; Func: function(const URL: string): string): TStringArray;\nvar\n  i: Integer;\nbegin\n  SetLength(Result, Length(URLs));\n  for i := 0 to High(URLs) do\n    Result[i] := Func(URLs[i]);\nend;\n\nvar\n  URLs, ShortenedURLs: TStringArray;\n  i: Integer;\nbegin\n  URLs := TStringArray.Create('https://example.com/page1', 'https://example.com/page2', 'https://example.com/page3');\n  ShortenedURLs := MapURLs(URLs, @ShortenURL);\n\n  for i := 0 to High(ShortenedURLs) do\n    WriteLn(ShortenedURLs[i]);\nend.\n```"
  },
  {
    "task": "Use map to generate a list of initials from a list of full names.",
    "code": "```pascal\nprogram GenerateInitials;\n\nuses\n  SysUtils;\n\ntype\n  TStringArray = array of string;\n\nfunction MapInitials(Names: TStringArray): TStringArray;\nvar\n  I: Integer;\n  Initials: TStringArray;\nbegin\n  SetLength(Initials, Length(Names));\n  for I := 0 to High(Names) do\n  begin\n    Initials[I] := Copy(Names[I], 1, 1);\n  end;\n  Result := Initials;\nend;\n\nvar\n  Names, Initials: TStringArray;\n  I: Integer;\nbegin\n  Names := TStringArray.Create('Alice', 'Bob', 'Charlie', 'Diana');\n  Initials := MapInitials(Names);\n  \n  for I := 0 to High(Initials) do\n  begin\n    WriteLn(Initials[I]);\n  end;\nend.\n```"
  },
  {
    "task": "Convert a list of decimal numbers to their binary string representations using map.",
    "code": "```pascal\nprogram DecimalToBinary;\n\nuses\n  SysUtils;\n\ntype\n  TIntegerArray = array of Integer;\n  TStringArray = array of String;\n\nfunction DecimalToBinaryMap(const nums: TIntegerArray): TStringArray;\nvar\n  i: Integer;\nbegin\n  SetLength(Result, Length(nums));\n  for i := 0 to High(nums) do\n    Result[i] := IntToBin(nums[i], 0);\nend;\n\nvar\n  decimalNumbers: TIntegerArray;\n  binaryStrings: TStringArray;\n  i: Integer;\nbegin\n  decimalNumbers := [3, 7, 10, 15];\n  binaryStrings := DecimalToBinaryMap(decimalNumbers);\n  \n  for i := 0 to High(binaryStrings) do\n    WriteLn(binaryStrings[i]);\nend.\n```"
  },
  {
    "task": "Use map to adjust the brightness of each color in a list of RGB tuples.",
    "code": "```pascal\nprogram AdjustBrightness;\n\ntype\n  TRGB = record\n    R, G, B: Byte;\n  end;\n\nfunction AdjustColorBrightness(Color: TRGB; Factor: Real): TRGB;\nbegin\n  AdjustColorBrightness.R := Round(Color.R * Factor);\n  AdjustColorBrightness.G := Round(Color.G * Factor);\n  AdjustColorBrightness.B := Round(Color.B * Factor);\n\n  if AdjustColorBrightness.R > 255 then AdjustColorBrightness.R := 255;\n  if AdjustColorBrightness.G > 255 then AdjustColorBrightness.G := 255;\n  if AdjustColorBrightness.B > 255 then AdjustColorBrightness.B := 255;\nend;\n\nprocedure MapRGB(var Colors: array of TRGB; Factor: Real);\nvar\n  i: Integer;\nbegin\n  for i := Low(Colors) to High(Colors) do\n    Colors[i] := AdjustColorBrightness(Colors[i], Factor);\nend;\n\nvar\n  Colors: array[0..2] of TRGB = (\n    (R: 100; G: 150; B: 200),\n    (R: 123; G: 222; B: 111),\n    (R: 50; G: 50; B: 50)\n  );\n  BrightnessFactor: Real;\n  i: Integer;\nbegin\n  BrightnessFactor := 1.2; { Example adjustment factor }\n  MapRGB(Colors, BrightnessFactor);\n  \n  for i := Low(Colors) to High(Colors) do\n    WriteLn('R:', Colors[i].R, ' G:', Colors[i].G, ' B:', Colors[i].B);\nend.\n```"
  },
  {
    "task": "Apply map to filter out only alphabetic characters from a list of strings.",
    "code": "```pascal\nprogram FunctionalMapExample;\n\nuses SysUtils;\n\nfunction IsAlphabetic(ch: Char): Boolean;\nbegin\n  Result := ch in ['A'..'Z', 'a'..'z'];\nend;\n\nfunction FilterAlphabetic(const s: String): String;\nvar\n  ch: Char;\nbegin\n  Result := '';\n  for ch in s do\n    if IsAlphabetic(ch) then\n      Result := Result + ch;\nend;\n\nvar\n  inputList: array[1..3] of String = ('Hello123', 'World!@#', 'Pascal456');\n  filteredList: array[1..3] of String;\n  i: Integer;\nbegin\n  for i := Low(inputList) to High(inputList) do\n    filteredList[i] := FilterAlphabetic(inputList[i]);\n\n  for i := Low(filteredList) to High(filteredList) do\n    Writeln(filteredList[i]);\nend.\n```"
  },
  {
    "task": "Use map to compute the prime factorization of each number in a list.",
    "code": "```pascal\nprogram PrimeFactorizationMap;\n\nuses\n  SysUtils, Math;\n\ntype\n  TIntArray = array of Integer;\n  TIntArray2D = array of TIntArray;\n\nfunction IsPrime(n: Integer): Boolean;\nvar\n  i: Integer;\nbegin\n  if n <= 1 then\n    Exit(False);\n  if n <= 3 then\n    Exit(True);\n  if (n mod 2 = 0) or (n mod 3 = 0) then\n    Exit(False);\n  i := 5;\n  while i * i <= n do\n  begin\n    if (n mod i = 0) or (n mod (i + 2) = 0) then\n      Exit(False);\n    i := i + 6;\n  end;\n  Result := True;\nend;\n\nfunction PrimeFactors(n: Integer): TIntArray;\nvar\n  factors: TIntArray;\n  i, index: Integer;\nbegin\n  index := 0;\n  SetLength(factors, 0);\n  while n mod 2 = 0 do\n  begin\n    SetLength(factors, index + 1);\n    factors[index] := 2;\n    n := n div 2;\n    index := index + 1;\n  end;\n  for i := 3 to Trunc(Sqrt(n)) do\n  begin\n    while n mod i = 0 do\n    begin\n      SetLength(factors, index + 1);\n      factors[index] := i;\n      n := n div i;\n      index := index + 1;\n    end;\n  end;\n  if n > 2 then\n  begin\n    SetLength(factors, index + 1);\n    factors[index] := n;\n  end;\n  Result := factors;\nend;\n\nfunction MapPrimeFactorization(numbers: TIntArray): TIntArray2D;\nvar\n  resultArray: TIntArray2D;\n  i: Integer;\nbegin\n  SetLength(resultArray, Length(numbers));\n  for i := 0 to High(numbers) do\n  begin\n    resultArray[i] := PrimeFactors(numbers[i]);\n  end;\n  Result := resultArray;\nend;\n\nvar\n  numbers: TIntArray;\n  factorization: TIntArray2D;\n  i, j: Integer;\nbegin\n  numbers := TIntArray.Create(10, 15, 21, 33, 50);\n  factorization := MapPrimeFactorization(numbers);\n  for i := 0 to High(factorization) do\n  begin\n    Write('Prime factors of ', numbers[i], ': ');\n    for j := 0 to High(factorization[i]) do\n    begin\n      Write(factorization[i][j], ' ');\n    end;\n    Writeln;\n  end;\nend.\n```"
  },
  {
    "task": "Calculate the exponential of each number in a list using a map function.",
    "code": "```pascal\nprogram ExponentialMap;\n\nuses Math;\n\ntype\n  TRealArray = array of Real;\n\nfunction MapExponential(arr: TRealArray): TRealArray;\nvar\n  i: Integer;\nbegin\n  SetLength(Result, Length(arr));\n  for i := 0 to High(arr) do\n    Result[i] := Exp(arr[i]);\nend;\n\nvar\n  numbers, result: TRealArray;\n  i: Integer;\nbegin\n  numbers := TRealArray.Create(1.0, 2.0, 3.0, 4.0, 5.0); // Example list\n  result := MapExponential(numbers);\n  for i := 0 to High(result) do\n    WriteLn('Exp(', numbers[i]:0:2, ') = ', result[i]:0:2);\nend.\n```"
  },
  {
    "task": "Use map to convert a list of text messages to morse code.",
    "code": "```pascal\nprogram ConvertTextToMorse;\n\nuses\n  SysUtils;\n\ntype\n  TStringArray = array of string;\n\nconst\n  MorseMap: array['A'..'Z'] of string = (\n    '.-', '-...', '-.-.', '-..', '.', '..-.', '--.', '....', '..', '.---',\n    '-.-', '.-..', '--', '-.', '---', '.--.', '--.-', '.-.', '...', '-',\n    '..-', '...-', '.--', '-..-', '-.--', '--..'\n  );\n\nfunction CharToMorse(c: Char): string;\nbegin\n  c := UpCase(c);\n  if (c >= 'A') and (c <= 'Z') then\n    Result := MorseMap[c]\n  else\n    Result := '';\nend;\n\nfunction TextToMorse(const Text: string): string;\nvar\n  i: Integer;\n  MorseText: TStringArray;\nbegin\n  SetLength(MorseText, Length(Text));\n  for i := 1 to Length(Text) do\n    MorseText[i - 1] := CharToMorse(Text[i]);\n  Result := String.Join(' ', MorseText);\nend;\n\nfunction MapToMorse(const Messages: TStringArray): TStringArray;\nvar\n  i: Integer;\nbegin\n  SetLength(Result, Length(Messages));\n  for i := 0 to High(Messages) do\n    Result[i] := TextToMorse(Messages[i]);\nend;\n\nvar\n  Messages, MorseMessages: TStringArray;\n  i: Integer;\nbegin\n  Messages := TStringArray.Create('HELLO', 'WORLD');\n  MorseMessages := MapToMorse(Messages);\n  for i := 0 to High(MorseMessages) do\n    WriteLn(MorseMessages[i]);\nend.\n```"
  },
  {
    "task": "Transform a list of JSON objects to XML strings using a map function.",
    "code": "```pascal\nprogram JSONToXML;\n\nuses\n  fpjson, jsonparser, Classes, SysUtils;\n\ntype\n  TJSONStringArray = array of string;\n\nfunction JSONToXMLString(const JSONStr: string): string;\nvar\n  JSONData: TJSONData;\nbegin\n  JSONData := GetJSON(JSONStr);\n  try\n    Result := JSONData.AsXML;\n  finally\n    JSONData.Free;\n  end;\nend;\n\nfunction MapJSONToXMLStrings(const JSONList: TJSONStringArray): TJSONStringArray;\nvar\n  i: Integer;\nbegin\n  SetLength(Result, Length(JSONList));\n  for i := 0 to High(JSONList) do\n    Result[i] := JSONToXMLString(JSONList[i]);\nend;\n\nvar\n  JSONList, XMLList: TJSONStringArray;\n  i: Integer;\nbegin\n  JSONList := TJSONStringArray.Create(\n    '{\"name\": \"John\", \"age\": 30}',\n    '{\"name\": \"Jane\", \"age\": 25}'\n  );\n\n  XMLList := MapJSONToXMLStrings(JSONList);\n\n  for i := 0 to High(XMLList) do\n    WriteLn(XMLList[i]);\nend.\n```"
  },
  {
    "task": "Use map to extract the extension from each filename in a list.",
    "code": "```pascal\nprogram ExtractExtensions;\n\nuses\n  SysUtils;\n\nfunction GetExtension(const FileName: string): string;\nbegin\n  Result := ExtractFileExt(FileName);\nend;\n\nvar\n  FileNames: array of string;\n  Extensions: array of string;\n  i: Integer;\nbegin\n  FileNames := ['document.txt', 'image.jpeg', 'archive.zip', 'notes.docx'];\n  SetLength(Extensions, Length(FileNames));\n\n  for i := 0 to High(FileNames) do\n    Extensions[i] := GetExtension(FileNames[i]);\n\n  for i := 0 to High(Extensions) do\n    WriteLn(Extensions[i]);\nend.\n```"
  },
  {
    "task": "Convert a list of temperatures from Fahrenheit to Kelvin using map.",
    "code": "```pascal\nprogram FahrenheitToKelvin;\n\nuses SysUtils;\n\ntype\n  TDoubleArray = array of Double;\n\nfunction FahrenheitToKelvin(temp: Double): Double;\nbegin\n  Result := (temp - 32) * 5/9 + 273.15;\nend;\n\nfunction Map(arr: TDoubleArray; func: function(temp: Double): Double): TDoubleArray;\nvar\n  i: Integer;\nbegin\n  SetLength(Result, Length(arr));\n  for i := 0 to High(arr) do\n    Result[i] := func(arr[i]);\nend;\n\nvar\n  fahrenheitTemps, kelvinTemps: TDoubleArray;\n  i: Integer;\nbegin\n  fahrenheitTemps := TDoubleArray.Create(32.0, 68.0, 212.0);\n  kelvinTemps := Map(fahrenheitTemps, @FahrenheitToKelvin);\n\n  for i := 0 to High(kelvinTemps) do\n    WriteLn(Format('%.2f', [kelvinTemps[i]]));\nend.\n```"
  },
  {
    "task": "Use map to calculate the perimeter of each rectangle in a list of dimensions.",
    "code": "```pascal\nprogram RectanglePerimeters;\n\ntype\n  TRectangle = record\n    width, height: Integer;\n  end;\n\nvar\n  rectangles: array of TRectangle;\n  perimeters: array of Integer;\n  i: Integer;\n\nfunction CalculatePerimeter(rect: TRectangle): Integer;\nbegin\n  CalculatePerimeter := 2 * (rect.width + rect.height);\nend;\n\nprocedure MapPerimeters(var rects: array of TRectangle; var perims: array of Integer);\nvar\n  i: Integer;\nbegin\n  SetLength(perims, Length(rects));\n  for i := 0 to High(rects) do\n    perims[i] := CalculatePerimeter(rects[i]);\nend;\n\nbegin\n  // Example list of rectangles\n  SetLength(rectangles, 3);\n  rectangles[0].width := 3; rectangles[0].height := 4;\n  rectangles[1].width := 5; rectangles[1].height := 6;\n  rectangles[2].width := 7; rectangles[2].height := 8;\n\n  MapPerimeters(rectangles, perimeters);\n\n  // Output the perimeters\n  for i := 0 to High(perimeters) do\n    WriteLn('Perimeter of rectangle ', i + 1, ': ', perimeters[i]);\nend.\n```"
  },
  {
    "task": "Apply map to format a list of phone numbers into a standard format.",
    "code": "```pascal\nprogram FormatPhoneNumbers;\n\ntype\n  TStringArray = array of string;\n\nfunction FormatNumber(number: string): string;\nbegin\n  if Length(number) = 10 then\n    FormatNumber := '(' + Copy(number, 1, 3) + ') ' + Copy(number, 4, 3) + '-' + Copy(number, 7, 4)\n  else\n    FormatNumber := number; // unchanged if not 10 digits\nend;\n\nfunction MapFormatNumbers(numbers: TStringArray): TStringArray;\nvar\n  i: Integer;\nbegin\n  SetLength(Result, Length(numbers));\n  for i := 0 to High(numbers) do\n    Result[i] := FormatNumber(numbers[i]);\nend;\n\nvar\n  phoneNumbers, formattedNumbers: TStringArray;\n  i: Integer;\nbegin\n  phoneNumbers := TStringArray.Create('1234567890', '9876543210', '5551234567');\n  formattedNumbers := MapFormatNumbers(phoneNumbers);\n  for i := 0 to High(formattedNumbers) do\n    WriteLn(formattedNumbers[i]);\nend.\n```"
  },
  {
    "task": "Use map to generate a hashed version of passwords from a list.",
    "code": "```pascal\nprogram HashedPasswords;\n\nuses\n  sysutils;\n\ntype\n  TStringArray = array of String;\n\nfunction HashPassword(const password: String): String;\nvar\n  i: Integer;\n  hashed: String;\nbegin\n  hashed := '';\n  for i := 1 to Length(password) do\n    hashed := hashed + Chr(Ord(password[i]) + 3); // Simple Caesar cipher for illustration\n  Result := hashed;\nend;\n\nfunction MapPasswords(const passwords: TStringArray): TStringArray;\nvar\n  i: Integer;\nbegin\n  SetLength(Result, Length(passwords));\n  for i := 0 to High(passwords) do\n    Result[i] := HashPassword(passwords[i]);\nend;\n\nvar\n  passwords, hashedPasswords: TStringArray;\n  i: Integer;\nbegin\n  passwords := TStringArray.Create('password1', '123456', 'admin');\n\n  hashedPasswords := MapPasswords(passwords);\n\n  for i := 0 to High(hashedPasswords) do\n    WriteLn(hashedPasswords[i]);\nend.\n```"
  },
  {
    "task": "Convert a list of text paragraphs to a word count using map.",
    "code": "```pascal\nprogram WordCountMap;\n\nuses\n  SysUtils, StrUtils;\n\ntype\n  TStringArray = array of string;\n  TIntArray = array of integer;\n\nfunction SplitParagraphsToWords(paragraph: string): Integer;\nvar\n  words: TStringArray;\nbegin\n  words := SplitString(paragraph, ' ');\n  Result := Length(words);\nend;\n\nfunction MapToWordCount(paragraphs: TStringArray): TIntArray;\nvar\n  i: Integer;\nbegin\n  SetLength(Result, Length(paragraphs));\n  for i := 0 to High(paragraphs) do\n    Result[i] := SplitParagraphsToWords(paragraphs[i]);\nend;\n\nvar\n  paragraphs: TStringArray;\n  wordCounts: TIntArray;\n  i: Integer;\nbegin\n  paragraphs := TStringArray.Create(\n    'Hello world',\n    'Pascal programming language',\n    'Functional programming with map'\n  );\n\n  wordCounts := MapToWordCount(paragraphs);\n\n  for i := 0 to High(wordCounts) do\n    WriteLn('Paragraph ', i + 1, ' word count: ', wordCounts[i]);\nend.\n```"
  },
  {
    "task": "Use map to remove punctuation from each string in a list of sentences.",
    "code": "```pascal\nprogram MapRemovePunctuation;\n\nuses\n  SysUtils;\n\ntype\n  TStringArray = array of string;\n\nfunction RemovePunctuation(const s: string): string;\nvar\n  i: Integer;\n  resultStr: string;\nbegin\n  resultStr := '';\n  for i := 1 to Length(s) do\n  begin\n    if not (s[i] in ['!', '(', ')', ',', '-', '.', ':', ';', '?']) then\n      resultStr := resultStr + s[i];\n  end;\n  Result := resultStr;\nend;\n\nfunction MapRemovePunctuation(const sentences: TStringArray): TStringArray;\nvar\n  i: Integer;\nbegin\n  SetLength(Result, Length(sentences));\n  for i := 0 to High(sentences) do\n  begin\n    Result[i] := RemovePunctuation(sentences[i]);\n  end;\nend;\n\nvar\n  sentences, processedSentences: TStringArray;\n  i: Integer;\nbegin\n  sentences := TStringArray.Create('Hello, world!', 'This is a test.', 'Pascal: easy to learn.');\n\n  processedSentences := MapRemovePunctuation(sentences);\n\n  for i := 0 to High(processedSentences) do\n  begin\n    WriteLn(processedSentences[i]);\n  end;\nend.\n```"
  },
  {
    "task": "Transform a list of URLs to their base domain using a map function.",
    "code": "```pascal\nprogram BaseDomainExtractor;\n\nuses\n  SysUtils, StrUtils;\n\ntype\n  TStringArray = array of string;\n\nfunction ExtractBaseDomain(const URL: string): string;\nvar\n  ProtocolPos, DomainEndPos: Integer;\n  Domain: string;\nbegin\n  ProtocolPos := Pos('://', URL);\n  if ProtocolPos > 0 then\n    ProtocolPos := ProtocolPos + 3\n  else\n    ProtocolPos := 1;\n\n  DomainEndPos := PosEx('/', URL, ProtocolPos);\n  if DomainEndPos = 0 then\n    DomainEndPos := Length(URL) + 1;\n\n  Domain := Copy(URL, ProtocolPos, DomainEndPos - ProtocolPos);\n  Result := Domain;\nend;\n\nfunction MapURLsToDomains(const URLs: TStringArray): TStringArray;\nvar\n  I: Integer;\nbegin\n  SetLength(Result, Length(URLs));\n  for I := 0 to High(URLs) do\n    Result[I] := ExtractBaseDomain(URLs[I]);\nend;\n\nvar\n  URLs, BaseDomains: TStringArray;\n  I: Integer;\nbegin\n  URLs := TStringArray.Create(\n    'https://www.example.com/page',\n    'http://subdomain.example.org/path',\n    'ftp://another-example.net/resource'\n  );\n  \n  BaseDomains := MapURLsToDomains(URLs);\n\n  for I := 0 to High(BaseDomains) do\n    WriteLn(BaseDomains[I]);\nend.\n```"
  },
  {
    "task": "Use map to translate a list of expressions to their symbolic algebraic forms.",
    "code": "```pascal\nprogram SymbolicAlgebraicForms;\n\nuses\n  SysUtils, StrUtils;\n\ntype\n  TStringArray = array of string;\n\nfunction MapToSymbolicAlgebraicForms(expressions: TStringArray): TStringArray;\nvar\n  i: Integer;\nbegin\n  SetLength(Result, Length(expressions));\n  for i := 0 to High(expressions) do\n  begin\n    // Simulate a symbolic algebraic form transformation\n    Result[i] := 'SymbolicFormOf(' + expressions[i] + ')';\n  end;\nend;\n\nvar\n  expressions, symbolicForms: TStringArray;\n  i: Integer;\nbegin\n  expressions := TStringArray.Create('2*x + 3', 'y^2 - 4*y + 4', 'sin(theta)');\n  \n  symbolicForms := MapToSymbolicAlgebraicForms(expressions);\n  \n  for i := 0 to High(symbolicForms) do\n    WriteLn(symbolicForms[i]);\nend.\n```"
  },
  {
    "task": "Apply map to convert a list of ASCII codes to corresponding characters.",
    "code": "```pascal\nprogram MapAsciiToChar;\n\nuses\n  SysUtils;\n\ntype\n  TIntArray = array of Integer;\n  TCharArray = array of Char;\n\nfunction MapAsciiToChar(const asciiCodes: TIntArray): TCharArray;\nvar\n  i: Integer;\nbegin\n  SetLength(Result, Length(asciiCodes));\n  for i := 0 to High(asciiCodes) do\n    Result[i] := Chr(asciiCodes[i]);\nend;\n\nvar\n  asciiCodes: TIntArray;\n  characters: TCharArray;\n  i: Integer;\nbegin\n  asciiCodes := TIntArray.Create(65, 66, 67, 68, 69);\n  characters := MapAsciiToChar(asciiCodes);\n  for i := 0 to High(characters) do\n    WriteLn(characters[i]);\nend.\n```"
  },
  {
    "task": "Use map to transform a list of text strings to their lemmatized forms.",
    "code": "```pascal\nprogram LemmatizeStrings;\n\nuses\n  SysUtils, Classes;\n\ntype\n  TStringArray = array of string;\n\nfunction Lemmatize(const s: string): string;\nbegin\n  // Placeholder for lemmatization logic\n  Result := s; // Assuming the input is returned as-is\nend;\n\nfunction MapLemmatize(const input: TStringArray): TStringArray;\nvar\n  i: Integer;\nbegin\n  SetLength(Result, Length(input));\n  for i := 0 to High(input) do\n    Result[i] := Lemmatize(input[i]);\nend;\n\nvar\n  strings, lemmatizedStrings: TStringArray;\n  i: Integer;\nbegin\n  strings := TStringArray.Create('running', 'jumps', 'easily');\n  lemmatizedStrings := MapLemmatize(strings);\n\n  for i := 0 to High(lemmatizedStrings) do\n    WriteLn(lemmatizedStrings[i]);\nend.\n```"
  },
  {
    "task": "Convert a list of HTML strings to plain text using map.",
    "code": "```pascal\nprogram HtmlToPlainText;\n\nuses\n  SysUtils, StrUtils;\n\ntype\n  TStringArray = array of string;\n\nfunction StripHtmlTags(const Html: string): string;\nvar\n  i, j: Integer;\n  InTag: Boolean;\nbegin\n  Result := '';\n  InTag := False;\n  i := 1;\n  while i <= Length(Html) do\n  begin\n    if Html[i] = '<' then\n      InTag := True\n    else if Html[i] = '>' then\n    begin\n      InTag := False;\n      Inc(i);\n      Continue;\n    end;\n\n    if not InTag then\n      Result := Result + Html[i];\n\n    Inc(i);\n  end;\nend;\n\nfunction MapHtmlToPlainText(const HtmlList: TStringArray): TStringArray;\nvar\n  i: Integer;\nbegin\n  SetLength(Result, Length(HtmlList));\n  for i := 0 to High(HtmlList) do\n    Result[i] := StripHtmlTags(HtmlList[i]);\nend;\n\nvar\n  HtmlList, PlainTextList: TStringArray;\nbegin\n  HtmlList := TStringArray.Create(\n    '<p>Hello, <b>world</b>!</p>',\n    '<div>Pascal <i>is</i> great.</div>',\n    '<span>Functional programming in <span>Pascal</span>.</span>'\n  );\n\n  PlainTextList := MapHtmlToPlainText(HtmlList);\n\n  for var Text in PlainTextList do\n    Writeln(Text);\nend.\n```"
  },
  {
    "task": "Use map to create a summary of each article in a list of texts.",
    "code": "```pascal\nprogram ArticleSummarizer;\n\nuses\n  SysUtils;\n\ntype\n  TStringArray = array of string;\n\nfunction SummarizeArticle(const article: string): string;\nbegin\n  // Placeholder for actual summarization logic\n  Result := Copy(article, 1, Min(50, Length(article))) + '...';\nend;\n\nfunction Map(const texts: TStringArray; func: function(const s: string): string): TStringArray;\nvar\n  i: Integer;\nbegin\n  SetLength(Result, Length(texts));\n  for i := 0 to High(texts) do\n    Result[i] := func(texts[i]);\nend;\n\nvar\n  articles, summaries: TStringArray;\n  i: Integer;\nbegin\n  // Example articles\n  articles := TStringArray.Create(\n    'This is the first article. It has a lot of information about various topics.',\n    'The second article is here. It covers different subjects and insights.',\n    'Here is the third article. It is full of interesting facts and figures.'\n  );\n\n  // Map articles to their summaries\n  summaries := Map(articles, @SummarizeArticle);\n\n  // Output summaries\n  for i := 0 to High(summaries) do\n    WriteLn('Summary ', i + 1, ': ', summaries[i]);\nend.\n```"
  },
  {
    "task": "Transform a list of paths to their absolute paths using a map function.",
    "code": "```pascal\nprogram TransformPaths;\n\nuses\n  SysUtils;\n\ntype\n  TStringArray = array of string;\n\nfunction MapPathsToAbsolute(const paths: TStringArray): TStringArray;\nvar\n  i: Integer;\nbegin\n  SetLength(Result, Length(paths));\n  for i := 0 to High(paths) do\n  begin\n    Result[i] := ExpandFileName(paths[i]);\n  end;\nend;\n\nvar\n  paths, absolutePaths: TStringArray;\n  i: Integer;\nbegin\n  paths := TStringArray.Create('path1', 'path2', 'path3');\n  absolutePaths := MapPathsToAbsolute(paths);\n\n  for i := 0 to High(absolutePaths) do\n  begin\n    WriteLn(absolutePaths[i]);\n  end;\nend.\n```"
  },
  {
    "task": "Use map to generate QR codes from a list of URLs.",
    "code": "```pascal\nprogram GenerateQRCodes;\n\nuses\n  SysUtils, fphttpclient, qrcodegen;\n\ntype\n  TStringArray = array of string;\n\nfunction GenerateQRCode(url: string): TQRCode;\nbegin\n  Result := TQRCode.Create;\n  if not Result.Encode(url) then\n    raise Exception.Create('Failed to generate QR code for: ' + url);\nend;\n\nfunction MapURLsToQRCodes(urls: TStringArray): array of TQRCode;\nvar\n  i: Integer;\nbegin\n  SetLength(Result, Length(urls));\n  for i := 0 to High(urls) do\n    Result[i] := GenerateQRCode(urls[i]);\nend;\n\nvar\n  urls: TStringArray;\n  qrCodes: array of TQRCode;\n  i: Integer;\nbegin\n  urls := TStringArray.Create(\n    'http://example.com',\n    'http://anotherexample.com'\n  );\n\n  qrCodes := MapURLsToQRCodes(urls);\n\n  for i := 0 to High(qrCodes) do\n  begin\n    qrCodes[i].SaveToFile('QRCode' + IntToStr(i) + '.png');\n    qrCodes[i].Free;\n  end;\nend.\n```"
  },
  {
    "task": "Convert a list of angles from degrees to radians using map.",
    "code": "```pascal\nprogram ConvertDegreesToRadians;\n\nuses Math;\n\ntype\n  TRealArray = array of Real;\n\nfunction DegreesToRadians(angle: Real): Real;\nbegin\n  Result := angle * Pi / 180;\nend;\n\nfunction MapArray(arr: TRealArray; func: function(angle: Real): Real): TRealArray;\nvar\n  i: Integer;\nbegin\n  SetLength(Result, Length(arr));\n  for i := 0 to High(arr) do\n  begin\n    Result[i] := func(arr[i]);\n  end;\nend;\n\nvar\n  degrees, radians: TRealArray;\nbegin\n  degrees := TRealArray.Create(45.0, 90.0, 180.0);\n\n  radians := MapArray(degrees, @DegreesToRadians);\n\n  // Output the results\n  for var i := 0 to High(radians) do\n    WriteLn(radians[i]:0:6);\nend.\n```"
  },
  {
    "task": "Use map to anonymize a list of IP addresses by masking parts of them.",
    "code": "```pascal\nprogram AnonymizeIPs;\n\nuses\n  SysUtils;\n\ntype\n  TStringArray = array of string;\n\nfunction MaskIP(const IP: string): string;\nvar\n  Parts: TStringArray;\n  i: Integer;\nbegin\n  Parts := IP.Split(['.']);\n  if Length(Parts) = 4 then\n  begin\n    for i := 1 to 2 do\n      Parts[i] := 'xxx';\n    Result := String.Join('.', Parts);\n  end\n  else\n    Result := IP; // Return original if not a valid IP\nend;\n\nfunction MapIPs(const IPs: TStringArray): TStringArray;\nvar\n  i: Integer;\nbegin\n  SetLength(Result, Length(IPs));\n  for i := 0 to High(IPs) do\n    Result[i] := MaskIP(IPs[i]);\nend;\n\nvar\n  IPs, AnonymizedIPs: TStringArray;\n  i: Integer;\nbegin\n  IPs := TStringArray.Create('192.168.1.1', '10.0.0.5', '172.16.0.10');\n  AnonymizedIPs := MapIPs(IPs);\n\n  for i := 0 to High(AnonymizedIPs) do\n    WriteLn(AnonymizedIPs[i]);\nend.\n```"
  },
  {
    "task": "Transform a list of tuples by swapping their elements using a map function.",
    "code": "```pascal\nprogram SwapTupleElements;\n\ntype\n  Tuple = record\n    First: Integer;\n    Second: Integer;\n  end;\n\nvar\n  tuples: array of Tuple;\n  swappedTuples: array of Tuple;\n  i: Integer;\n\nfunction Swap(t: Tuple): Tuple;\nvar\n  temp: Integer;\nbegin\n  temp := t.First;\n  t.First := t.Second;\n  t.Second := temp;\n  Swap := t;\nend;\n\nbegin\n  SetLength(tuples, 3);\n  tuples[0].First := 1; tuples[0].Second := 2;\n  tuples[1].First := 3; tuples[1].Second := 4;\n  tuples[2].First := 5; tuples[2].Second := 6;\n\n  SetLength(swappedTuples, Length(tuples));\n\n  for i := 0 to High(tuples) do\n  begin\n    swappedTuples[i] := Swap(tuples[i]);\n  end;\n\n  for i := 0 to High(swappedTuples) do\n  begin\n    WriteLn('(', swappedTuples[i].First, ', ', swappedTuples[i].Second, ')');\n  end;\nend.\n```"
  },
  {
    "task": "Use map to compute the greatest common divisor of pairs in a list of number pairs.",
    "code": "```pascal\nprogram GCDMap;\n\nuses\n  SysUtils;\n\ntype\n  TIntPair = record\n    A, B: Integer;\n  end;\n\nfunction GCD(x, y: Integer): Integer;\nbegin\n  while y <> 0 do\n  begin\n    Result := y;\n    y := x mod y;\n    x := Result;\n  end;\n  Result := x;\nend;\n\nfunction MapGCD(pairs: array of TIntPair): array of Integer;\nvar\n  i: Integer;\nbegin\n  SetLength(Result, Length(pairs));\n  for i := 0 to High(pairs) do\n  begin\n    Result[i] := GCD(pairs[i].A, pairs[i].B);\n  end;\nend;\n\nvar\n  pairs: array of TIntPair;\n  results: array of Integer;\n  i: Integer;\nbegin\n  // Example input\n  SetLength(pairs, 3);\n  pairs[0].A := 48; pairs[0].B := 18;\n  pairs[1].A := 56; pairs[1].B := 98;\n  pairs[2].A := 45; pairs[2].B := 75;\n\n  results := MapGCD(pairs);\n\n  for i := 0 to High(results) do\n  begin\n    WriteLn('GCD of pair ', i+1, ': ', results[i]);\n  end;\nend.\n```"
  },
  {
    "task": "Convert a list of file paths to their directory names using map.",
    "code": "```pascal\nprogram MapFilePathsToDirectories;\n\nuses\n  SysUtils;\n\ntype\n  TStringArray = array of string;\n\nfunction MapToDirectories(const FilePaths: TStringArray): TStringArray;\nvar\n  I: Integer;\nbegin\n  SetLength(Result, Length(FilePaths));\n  for I := 0 to High(FilePaths) do\n  begin\n    Result[I] := ExtractFileDir(FilePaths[I]);\n  end;\nend;\n\nvar\n  FilePaths, Directories: TStringArray;\n  I: Integer;\nbegin\n  FilePaths := TStringArray.Create(\n    '/usr/local/bin/executable',\n    '/home/user/docs/file.txt',\n    '/etc/nginx/nginx.conf'\n  );\n\n  Directories := MapToDirectories(FilePaths);\n\n  for I := 0 to High(Directories) do\n  begin\n    WriteLn(Directories[I]);\n  end;\nend.\n```"
  },
  {
    "task": "Use map to replace each vowel in a list of strings with a specific character.",
    "code": "```pascal\nprogram ReplaceVowels;\n\nuses\n  SysUtils;\n\nfunction ReplaceVowel(c: Char): Char;\nbegin\n  if c in ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'] then\n    ReplaceVowel := '*'\n  else\n    ReplaceVowel := c;\nend;\n\nfunction MapString(s: String): String;\nvar\n  i: Integer;\nbegin\n  for i := 1 to Length(s) do\n    s[i] := ReplaceVowel(s[i]);\n  MapString := s;\nend;\n\nprocedure ReplaceVowelsInList(var strs: array of String);\nvar\n  i: Integer;\nbegin\n  for i := Low(strs) to High(strs) do\n    strs[i] := MapString(strs[i]);\nend;\n\nvar\n  strings: array of String;\n  i: Integer;\nbegin\n  strings := ['hello', 'world', 'example', 'Pascal'];\n  ReplaceVowelsInList(strings);\n  \n  for i := Low(strings) to High(strings) do\n    Writeln(strings[i]);\nend.\n```"
  },
  {
    "task": "Transform a list of integers to their hexadecimal representations using map.",
    "code": "```pascal\nprogram HexMap;\n\nuses SysUtils;\n\nvar\n  intList: array of Integer;\n  hexList: array of String;\n  i: Integer;\n\nfunction IntToHexStr(n: Integer): String;\nbegin\n  Result := IntToHex(n, 0);\nend;\n\nbegin\n  intList := [10, 15, 255, 32, 100];\n  SetLength(hexList, Length(intList));\n\n  for i := 0 to High(intList) do\n  begin\n    hexList[i] := IntToHexStr(intList[i]);\n  end;\n\n  for i := 0 to High(hexList) do\n  begin\n    WriteLn(hexList[i]);\n  end;\nend.\n```"
  },
  {
    "task": "Use map to apply a transformation matrix to a list of 2D vectors.",
    "code": "```pascal\nprogram TransformVectors;\n\ntype\n  TVector = record\n    x, y: Real;\n  end;\n\n  TMatrix = array[1..2, 1..2] of Real;\n\nvar\n  vectors: array of TVector;\n  transformedVectors: array of TVector;\n  matrix: TMatrix;\n  i: Integer;\n\nfunction TransformVector(const v: TVector; const m: TMatrix): TVector;\nbegin\n  TransformVector.x := v.x * m[1, 1] + v.y * m[1, 2];\n  TransformVector.y := v.x * m[2, 1] + v.y * m[2, 2];\nend;\n\nbegin\n  { Initialize the transformation matrix }\n  matrix[1, 1] := 1.0;\n  matrix[1, 2] := 0.0;\n  matrix[2, 1] := 0.0;\n  matrix[2, 2] := 1.0;\n\n  { Initialize the list of vectors }\n  SetLength(vectors, 3);\n  vectors[0].x := 1.0; vectors[0].y := 2.0;\n  vectors[1].x := 3.0; vectors[1].y := 4.0;\n  vectors[2].x := 5.0; vectors[2].y := 6.0;\n\n  { Apply the matrix to each vector }\n  SetLength(transformedVectors, Length(vectors));\n  for i := 0 to High(vectors) do\n    transformedVectors[i] := TransformVector(vectors[i], matrix);\n\n  { Output the transformed vectors }\n  for i := 0 to High(transformedVectors) do\n    writeln('Transformed Vector ', i + 1, ': (', transformedVectors[i].x:0:2, ', ', transformedVectors[i].y:0:2, ')');\nend.\n```"
  },
  {
    "task": "Convert a list of text strings to their phonetic alphabet equivalents using map.",
    "code": "```pascal\nprogram PhoneticMapExample;\n\nuses\n  SysUtils;\n\ntype\n  TStringArray = array of string;\n\nfunction PhoneticMap(s: string): string;\nvar\n  i: Integer;\nbegin\n  Result := '';\n  for i := 1 to Length(s) do\n  begin\n    case UpCase(s[i]) of\n      'A': Result := Result + 'Alpha ';\n      'B': Result := Result + 'Bravo ';\n      'C': Result := Result + 'Charlie ';\n      'D': Result := Result + 'Delta ';\n      'E': Result := Result + 'Echo ';\n      'F': Result := Result + 'Foxtrot ';\n      'G': Result := Result + 'Golf ';\n      'H': Result := Result + 'Hotel ';\n      'I': Result := Result + 'India ';\n      'J': Result := Result + 'Juliett ';\n      'K': Result := Result + 'Kilo ';\n      'L': Result := Result + 'Lima ';\n      'M': Result := Result + 'Mike ';\n      'N': Result := Result + 'November ';\n      'O': Result := Result + 'Oscar ';\n      'P': Result := Result + 'Papa ';\n      'Q': Result := Result + 'Quebec ';\n      'R': Result := Result + 'Romeo ';\n      'S': Result := Result + 'Sierra ';\n      'T': Result := Result + 'Tango ';\n      'U': Result := Result + 'Uniform ';\n      'V': Result := Result + 'Victor ';\n      'W': Result := Result + 'Whiskey ';\n      'X': Result := Result + 'X-ray ';\n      'Y': Result := Result + 'Yankee ';\n      'Z': Result := Result + 'Zulu ';\n    else\n      Result := Result + s[i] + ' ';\n    end;\n  end;\n  Result := Trim(Result);\nend;\n\nfunction MapPhonetic(input: TStringArray): TStringArray;\nvar\n  i: Integer;\nbegin\n  SetLength(Result, Length(input));\n  for i := 0 to High(input) do\n  begin\n    Result[i] := PhoneticMap(input[i]);\n  end;\nend;\n\nvar\n  input, output: TStringArray;\n  i: Integer;\nbegin\n  input := TStringArray.Create('hello', 'world', 'pascal');\n  output := MapPhonetic(input);\n\n  for i := 0 to High(output) do\n  begin\n    WriteLn(output[i]);\n  end;\nend.\n```"
  },
  {
    "task": "Use map to determine if each word in a list is a palindrome, returning booleans.",
    "code": "```pascal\nprogram CheckPalindromes;\n\nuses\n  SysUtils;\n\ntype\n  TStringArray = array of string;\n  TBooleanArray = array of Boolean;\n\nfunction IsPalindrome(const s: string): Boolean;\nvar\n  i, len: Integer;\nbegin\n  len := Length(s);\n  for i := 1 to len div 2 do\n    if s[i] <> s[len - i + 1] then\n      Exit(False);\n  Result := True;\nend;\n\nfunction MapIsPalindrome(words: TStringArray): TBooleanArray;\nvar\n  i: Integer;\nbegin\n  SetLength(Result, Length(words));\n  for i := 0 to High(words) do\n    Result[i] := IsPalindrome(words[i]);\nend;\n\nvar\n  words: TStringArray;\n  results: TBooleanArray;\n  i: Integer;\nbegin\n  words := TStringArray.Create('level', 'world', 'radar', 'hello', 'civic');\n  results := MapIsPalindrome(words);\n  for i := 0 to High(results) do\n    WriteLn(words[i], ' is palindrome: ', results[i]);\nend.\n```"
  },
  {
    "task": "Transform a list of dictionaries by renaming a specified key using a map function.",
    "code": "```pascal\nprogram TransformList;\n\nuses\n  SysUtils, Generics.Collections;\n\ntype\n  TDictionary = class(TObjectDictionary<string, string>)\n  end;\n\n  TListDict = TList<TDictionary>;\n\nfunction RenameKey(ADict: TDictionary; const OldKey, NewKey: string): TDictionary;\nbegin\n  if ADict.ContainsKey(OldKey) then\n  begin\n    ADict.Add(NewKey, ADict[OldKey]);\n    ADict.Remove(OldKey);\n  end;\n  Result := ADict;\nend;\n\nprocedure TransformList(AList: TListDict; const OldKey, NewKey: string);\nvar\n  i: Integer;\nbegin\n  for i := 0 to AList.Count - 1 do\n    AList[i] := RenameKey(AList[i], OldKey, NewKey);\nend;\n\nvar\n  List: TListDict;\n  Dict: TDictionary;\nbegin\n  List := TListDict.Create;\n\n  Dict := TDictionary.Create;\n  Dict.Add('old_key', 'value1');\n  List.Add(Dict);\n\n  Dict := TDictionary.Create;\n  Dict.Add('old_key', 'value2');\n  List.Add(Dict);\n\n  TransformList(List, 'old_key', 'new_key');\n\n  // Output transformed list for demonstration\n  for Dict in List do\n    Writeln(Dict['new_key']);\n\n  List.Free;\nend.\n```"
  },
  {
    "task": "Use map to compute the logarithm of each number in a list.",
    "code": "```pascal\nprogram FunctionalMapLogarithm;\nuses Math;\n\nfunction MapLogarithm(list: array of Real): array of Real;\nvar\n  i: Integer;\nbegin\n  SetLength(Result, Length(list));\n  for i := Low(list) to High(list) do\n    Result[i] := Ln(list[i]);\nend;\n\nvar\n  numbers, logNumbers: array of Real;\n  i: Integer;\nbegin\n  numbers := [1.0, 2.0, 3.0, 4.0, 5.0];\n  logNumbers := MapLogarithm(numbers);\n  \n  for i := Low(logNumbers) to High(logNumbers) do\n    WriteLn(logNumbers[i]:0:4);\nend.\n```"
  },
  {
    "task": "Convert a list of image file paths to grayscale versions using map.",
    "code": "```pascal\nprogram ConvertToGrayscale;\n\nuses\n  Classes, SysUtils, fpimage, FPReadPNG, FPWritePNG;\n\ntype\n  TImagePathList = specialize TFPGList<string>;\n\nfunction ConvertToGrayscale(const FilePath: string): string;\nvar\n  Image: TFPMemoryImage;\n  Reader: TFPReaderPNG;\n  Writer: TFPWriterPNG;\n  x, y: Integer;\n  GrayColor: TFPColor;\n  NewFilePath: string;\nbegin\n  Image := TFPMemoryImage.Create(0, 0);\n  Reader := TFPReaderPNG.Create;\n  Writer := TFPWriterPNG.Create;\n  try\n    Image.LoadFromFile(FilePath, Reader);\n    for y := 0 to Image.Height - 1 do\n      for x := 0 to Image.Width - 1 do\n      begin\n        with Image.Colors[x, y] do\n          GrayColor := FPColor(Red div 3 + Green div 3 + Blue div 3,\n                               Red div 3 + Green div 3 + Blue div 3,\n                               Red div 3 + Green div 3 + Blue div 3);\n        Image.Colors[x, y] := GrayColor;\n      end;\n    NewFilePath := ChangeFileExt(FilePath, '_gray.png');\n    Image.SaveToFile(NewFilePath, Writer);\n    Result := NewFilePath;\n  finally\n    Image.Free;\n    Reader.Free;\n    Writer.Free;\n  end;\nend;\n\nvar\n  FilePaths, GrayscalePaths: TImagePathList;\n  i: Integer;\nbegin\n  FilePaths := TImagePathList.Create;\n  GrayscalePaths := TImagePathList.Create;\n  try\n    // Example file paths, should be filled with actual paths\n    FilePaths.Add('image1.png');\n    FilePaths.Add('image2.png');\n\n    for i := 0 to FilePaths.Count - 1 do\n      GrayscalePaths.Add(ConvertToGrayscale(FilePaths[i]));\n\n    // Output the resulting file paths\n    for i := 0 to GrayscalePaths.Count - 1 do\n      WriteLn(GrayscalePaths[i]);\n  finally\n    FilePaths.Free;\n    GrayscalePaths.Free;\n  end;\nend.\n```"
  },
  {
    "task": "Use map to flatten a list of lists of strings into a single list of strings.",
    "code": "```pascal\nprogram FlattenListOfLists;\n\nuses SysUtils;\n\nvar\n  listOfLists: array of array of string;\n  resultList: array of string;\n  i, j, index: integer;\n\nbegin\n  // Example input\n  listOfLists := [['Hello', 'World'], ['Pascal', 'Language'], ['Functional', 'Map']];\n\n  // Calculate total length for resultList\n  index := 0;\n  for i := 0 to High(listOfLists) do\n    index := index + Length(listOfLists[i]);\n\n  // Initialize resultList with the total length\n  SetLength(resultList, index);\n\n  // Flatten listOfLists into resultList\n  index := 0;\n  for i := 0 to High(listOfLists) do\n    for j := 0 to High(listOfLists[i]) do\n    begin\n      resultList[index] := listOfLists[i][j];\n      Inc(index);\n    end;\n\n  // Output resultList\n  for i := 0 to High(resultList) do\n    WriteLn(resultList[i]);\nend.\n```"
  },
  {
    "task": "Transform a list of temperature readings to temperature anomalies using a map function.",
    "code": "```pascal\nprogram TemperatureAnomalies;\n\ntype\n  TFloatArray = array of Real;\n\nfunction MapToAnomalies(temperatures: TFloatArray; average: Real): TFloatArray;\nvar\n  i: Integer;\nbegin\n  SetLength(Result, Length(temperatures));\n  for i := Low(temperatures) to High(temperatures) do\n    Result[i] := temperatures[i] - average;\nend;\n\nfunction CalculateAverage(temperatures: TFloatArray): Real;\nvar\n  sum: Real;\n  i: Integer;\nbegin\n  sum := 0;\n  for i := Low(temperatures) to High(temperatures) do\n    sum := sum + temperatures[i];\n  Result := sum / Length(temperatures);\nend;\n\nvar\n  temperatures, anomalies: TFloatArray;\n  average: Real;\nbegin\n  temperatures := TFloatArray.Create(15.0, 16.5, 14.3, 18.2, 17.4);\n  average := CalculateAverage(temperatures);\n  anomalies := MapToAnomalies(temperatures, average);\n\n  // Output anomalies\nend.\n```"
  }
]