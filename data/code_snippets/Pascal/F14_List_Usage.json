[
  {
    "task": "Create a list of the first ten positive integers and calculate their sum.",
    "code": "```pascal\nprogram SumOfList;\n\nvar\n  numbers: array[1..10] of Integer;\n  i, sum: Integer;\n\nbegin\n  sum := 0;\n  \n  for i := 1 to 10 do\n    numbers[i] := i;\n    \n  for i := 1 to 10 do\n    sum := sum + numbers[i];\n    \n  WriteLn('The sum is: ', sum);\nend.\n```"
  },
  {
    "task": "Write a program to reverse the order of elements in a given list.",
    "code": "```pascal\nprogram ReverseList;\n\nuses SysUtils;\n\nvar\n  originalList, reversedList: array of Integer;\n  i, n: Integer;\n\nbegin\n  // Example list\n  originalList := [1, 2, 3, 4, 5];\n  n := Length(originalList);\n  SetLength(reversedList, n);\n\n  for i := 0 to n - 1 do\n  begin\n    reversedList[i] := originalList[n - 1 - i];\n  end;\n\n  // Output the reversed list\n  for i := 0 to n - 1 do\n  begin\n    Write(reversedList[i], ' ');\n  end;\n  Writeln;\nend.\n```"
  },
  {
    "task": "Implement a function that takes a list and returns the list with duplicates removed.",
    "code": "```pascal\nprogram RemoveDuplicates;\n\nuses\n  SysUtils;\n\ntype\n  TIntArray = array of Integer;\n\nfunction RemoveDuplicatesFromList(lst: TIntArray): TIntArray;\nvar\n  seen: array of Integer;\n  result: TIntArray;\n  i, j: Integer;\n  found: Boolean;\nbegin\n  SetLength(seen, 0);\n  SetLength(result, 0);\n  \n  for i := 0 to High(lst) do\n  begin\n    found := False;\n    for j := 0 to High(seen) do\n    begin\n      if lst[i] = seen[j] then\n      begin\n        found := True;\n        Break;\n      end;\n    end;\n    if not found then\n    begin\n      SetLength(seen, Length(seen) + 1);\n      seen[High(seen)] := lst[i];\n      \n      SetLength(result, Length(result) + 1);\n      result[High(result)] := lst[i];\n    end;\n  end;\n  \n  RemoveDuplicatesFromList := result;\nend;\n\nvar\n  input: TIntArray;\n  output: TIntArray;\n  i: Integer;\nbegin\n  input := TIntArray.Create(1, 2, 3, 2, 4, 1);\n  output := RemoveDuplicatesFromList(input);\n  \n  for i := 0 to High(output) do\n    WriteLn(output[i]);\nend.\n```"
  },
  {
    "task": "Create a list of names and sort them in alphabetical order.",
    "code": "```pascal\nprogram SortNames;\n\nuses\n  Classes, SysUtils;\n\nvar\n  NameList: TStringList;\nbegin\n  NameList := TStringList.Create;\n  try\n    NameList.Add('Alice');\n    NameList.Add('Charlie');\n    NameList.Add('Bob');\n    \n    NameList.Sort;\n    \n    WriteLn('Sorted Names:');\n    WriteLn(NameList.Text);\n  finally\n    NameList.Free;\n  end;\nend.\n```"
  },
  {
    "task": "Write a function that appends a new element to an existing list.",
    "code": "```pascal\nprogram AppendToList;\n\ntype\n  TIntegerList = array of Integer;\n\nfunction AppendElement(var List: TIntegerList; NewElement: Integer): TIntegerList;\nbegin\n  SetLength(List, Length(List) + 1);\n  List[High(List)] := NewElement;\n  AppendElement := List;\nend;\n\nvar\n  MyList: TIntegerList;\n  i: Integer;\nbegin\n  SetLength(MyList, 3);\n  MyList[0] := 1;\n  MyList[1] := 2;\n  MyList[2] := 3;\n\n  MyList := AppendElement(MyList, 4);\n\n  for i := 0 to High(MyList) do\n    WriteLn(MyList[i]);\nend.\n```"
  },
  {
    "task": "Generate a list of the first 20 even numbers.",
    "code": "```pascal\nprogram GenerateEvenNumbers;\nuses SysUtils;\n\nvar\n  evenNumbers: array of Integer;\n  i: Integer;\nbegin\n  SetLength(evenNumbers, 20);\n  for i := 0 to 19 do\n    evenNumbers[i] := (i + 1) * 2;\n\n  for i := 0 to 19 do\n    WriteLn(evenNumbers[i]);\nend.\n```"
  },
  {
    "task": "Create a nested list (a list of lists) and access an element from the inner list.",
    "code": "```pascal\nprogram NestedListExample;\n\ntype\n  TIntArray = array of Integer;\n  TIntArray2D = array of TIntArray;\n\nvar\n  NestedList: TIntArray2D;\n  Element: Integer;\nbegin\n  SetLength(NestedList, 2);\n  SetLength(NestedList[0], 3);\n  SetLength(NestedList[1], 3);\n\n  NestedList[0][0] := 1;\n  NestedList[0][1] := 2;\n  NestedList[0][2] := 3;\n  NestedList[1][0] := 4;\n  NestedList[1][1] := 5;\n  NestedList[1][2] := 6;\n\n  Element := NestedList[1][2];\n  WriteLn('Accessed Element: ', Element);\nend.\n```"
  },
  {
    "task": "Write a program that finds the maximum value in a list of integers.",
    "code": "```pascal\nprogram FindMaxValue;\n\nuses SysUtils;\n\nvar\n  numbers: array of Integer;\n  i, maxValue, count: Integer;\n\nbegin\n  Write('Enter the number of elements: ');\n  ReadLn(count);\n  SetLength(numbers, count);\n  \n  WriteLn('Enter the elements:');\n  for i := 0 to count - 1 do\n    ReadLn(numbers[i]);\n\n  if count > 0 then\n  begin\n    maxValue := numbers[0];\n    for i := 1 to count - 1 do\n    begin\n      if numbers[i] > maxValue then\n        maxValue := numbers[i];\n    end;\n    WriteLn('The maximum value is: ', maxValue);\n  end\n  else\n    WriteLn('The list is empty.');\nend.\n```"
  },
  {
    "task": "Implement a function to merge two lists into a single list without duplicates.",
    "code": "```pascal\nprogram MergeListsWithoutDuplicates;\n\nuses SysUtils;\n\ntype\n  TIntegerArray = array of Integer;\n\nfunction MergeWithoutDuplicates(list1, list2: TIntegerArray): TIntegerArray;\nvar\n  mergedList: TIntegerArray;\n  seen: set of Byte;\n  i: Integer;\nbegin\n  SetLength(mergedList, 0);\n  seen := [];\n  for i := 0 to High(list1) do\n  begin\n    if not (list1[i] in seen) then\n    begin\n      Include(seen, list1[i]);\n      SetLength(mergedList, Length(mergedList) + 1);\n      mergedList[High(mergedList)] := list1[i];\n    end;\n  end;\n  for i := 0 to High(list2) do\n  begin\n    if not (list2[i] in seen) then\n    begin\n      Include(seen, list2[i]);\n      SetLength(mergedList, Length(mergedList) + 1);\n      mergedList[High(mergedList)] := list2[i];\n    end;\n  end;\n  MergeWithoutDuplicates := mergedList;\nend;\n\nvar\n  list1, list2, mergedList: TIntegerArray;\n  i: Integer;\nbegin\n  list1 := [1, 2, 3, 4];\n  list2 := [3, 4, 5, 6];\n  mergedList := MergeWithoutDuplicates(list1, list2);\n  for i := 0 to High(mergedList) do\n    WriteLn(mergedList[i]);\nend.\n```"
  },
  {
    "task": "Create a list from user input, then display the list in reverse order.",
    "code": "```pascal\nprogram ReverseList;\n\nuses\n  SysUtils;\n\nvar\n  inputList: array of String;\n  input: String;\n  i: Integer;\nbegin\n  SetLength(inputList, 0);\n  \n  WriteLn('Enter strings to add to the list (type \"done\" to finish):');\n  repeat\n    ReadLn(input);\n    if input <> 'done' then\n    begin\n      SetLength(inputList, Length(inputList) + 1);\n      inputList[High(inputList)] := input;\n    end;\n  until input = 'done';\n  \n  WriteLn('List in reverse order:');\n  for i := High(inputList) downto Low(inputList) do\n  begin\n    WriteLn(inputList[i]);\n  end;\nend.\n```"
  },
  {
    "task": "Write a function that takes a list and returns a new list containing only the even numbers.",
    "code": "```pascal\nprogram FilterEvenNumbers;\n\ntype\n  TIntArray = array of Integer;\n\nfunction GetEvenNumbers(const nums: TIntArray): TIntArray;\nvar\n  i, count: Integer;\nbegin\n  count := 0;\n  SetLength(Result, Length(nums));\n  for i := 0 to High(nums) do\n  begin\n    if nums[i] mod 2 = 0 then\n    begin\n      Result[count] := nums[i];\n      Inc(count);\n    end;\n  end;\n  SetLength(Result, count);\nend;\n\nvar\n  input, output: TIntArray;\n  i: Integer;\nbegin\n  input := TIntArray.Create(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n  output := GetEvenNumbers(input);\n  for i := 0 to High(output) do\n    Write(output[i], ' ');\nend.\n```"
  },
  {
    "task": "Generate a list of squares for the numbers 1 through 10.",
    "code": "```pascal\nprogram ListOfSquares;\n\nuses SysUtils;\n\nvar\n  squares: array[1..10] of Integer;\n  i: Integer;\n\nbegin\n  for i := 1 to 10 do\n    squares[i] := i * i;\n\n  for i := 1 to 10 do\n    WriteLn('Square of ', i, ' is ', squares[i]);\nend.\n```"
  },
  {
    "task": "Create a list of floating-point numbers and find their average.",
    "code": "```pascal\nprogram AverageOfList;\n\nvar\n  numbers: array of Real;\n  sum, average: Real;\n  i, count: Integer;\n\nbegin\n  { Initialize the list of floating-point numbers }\n  numbers := [1.5, 2.3, 3.8, 4.7, 5.9];\n  count := Length(numbers);\n  sum := 0.0;\n\n  { Calculate the sum of the numbers }\n  for i := 0 to count - 1 do\n    sum := sum + numbers[i];\n\n  { Calculate the average }\n  if count > 0 then\n    average := sum / count\n  else\n    average := 0.0;\n\n  { Output the average }\n  WriteLn('Average: ', average:0:2);\nend.\n```"
  },
  {
    "task": "Implement a program to rotate the elements of a list to the right by a given number of steps.",
    "code": "```pascal\nprogram RotateList;\n\nuses SysUtils;\n\ntype\n  TIntegerList = array of Integer;\n\nfunction RotateRight(const List: TIntegerList; Steps: Integer): TIntegerList;\nvar\n  Len, i, NewIndex: Integer;\nbegin\n  Len := Length(List);\n  SetLength(Result, Len);\n  if Len = 0 then\n    Exit;\n\n  Steps := Steps mod Len;\n  for i := 0 to Len - 1 do\n  begin\n    NewIndex := (i + Steps) mod Len;\n    Result[NewIndex] := List[i];\n  end;\nend;\n\nprocedure PrintList(const List: TIntegerList);\nvar\n  i: Integer;\nbegin\n  for i := 0 to High(List) do\n    Write(List[i], ' ');\n  Writeln;\nend;\n\nvar\n  MyList: TIntegerList;\nbegin\n  MyList := TIntegerList.Create(1, 2, 3, 4, 5);\n  MyList := RotateRight(MyList, 2);\n  PrintList(MyList);\nend.\n```"
  },
  {
    "task": "Write a function that checks if a list is a palindrome (reads the same forwards and backwards).",
    "code": "```pascal\nprogram PalindromeCheck;\n\nuses SysUtils;\n\nfunction IsPalindrome(list: array of Integer): Boolean;\nvar\n  i, n: Integer;\nbegin\n  n := Length(list);\n  IsPalindrome := True;\n  for i := 0 to n div 2 - 1 do\n  begin\n    if list[i] <> list[n - i - 1] then\n    begin\n      IsPalindrome := False;\n      Break;\n    end;\n  end;\nend;\n\nvar\n  nums: array of Integer;\nbegin\n  nums := [1, 2, 3, 2, 1];\n  if IsPalindrome(nums) then\n    WriteLn('The list is a palindrome.')\n  else\n    WriteLn('The list is not a palindrome.');\nend.\n```"
  },
  {
    "task": "Create a list of random integers and count how many are greater than 50.",
    "code": "```pascal\nprogram CountGreaterThanFifty;\nuses SysUtils;\n\nvar\n  numbers: array of Integer;\n  i, count, num: Integer;\nbegin\n  Randomize;\n  SetLength(numbers, 10); // Example size\n  count := 0;\n\n  for i := 0 to High(numbers) do\n  begin\n    num := Random(100);\n    numbers[i] := num;\n    if num > 50 then\n      Inc(count);\n  end;\n\n  WriteLn('Numbers greater than 50: ', count);\nend.\n```"
  },
  {
    "task": "Write a program that removes the first occurrence of a specified element from a list.",
    "code": "```pascal\nprogram RemoveElement;\n\nuses SysUtils;\n\nvar\n  numbers: array of Integer;\n  i, j, n, toRemove: Integer;\n  found: Boolean;\n\nbegin\n  // Initialize the list\n  numbers := [1, 2, 3, 4, 5, 6, 3, 8, 9];\n  n := Length(numbers);\n  \n  // Element to remove\n  toRemove := 3;\n  found := False;\n\n  // Iterate to find and remove the first occurrence\n  for i := 0 to n - 1 do\n  begin\n    if (numbers[i] = toRemove) then\n    begin\n      found := True;\n      for j := i to n - 2 do\n      begin\n        numbers[j] := numbers[j + 1];\n      end;\n      SetLength(numbers, n - 1);\n      Break;\n    end;\n  end;\n\n  // Output the result\n  for i := 0 to High(numbers) do\n  begin\n    Write(numbers[i], ' ');\n  end;\nend.\n```"
  },
  {
    "task": "Implement a function that takes two lists and returns a list containing their intersection.",
    "code": "```pascal\nprogram ListIntersection;\n\ntype\n  TIntArray = array of Integer;\n\nfunction ListIntersection(list1, list2: TIntArray): TIntArray;\nvar\n  i, j, k: Integer;\n  tempList: TIntArray;\n  found: Boolean;\nbegin\n  SetLength(tempList, 0);\n  k := 0;\n\n  for i := 0 to High(list1) do\n  begin\n    found := False;\n    for j := 0 to High(list2) do\n    begin\n      if list1[i] = list2[j] then\n      begin\n        found := True;\n        break;\n      end;\n    end;\n\n    if found then\n    begin\n      SetLength(tempList, k + 1);\n      tempList[k] := list1[i];\n      Inc(k);\n    end;\n  end;\n\n  ListIntersection := tempList;\nend;\n\nvar\n  list1, list2, result: TIntArray;\n  i: Integer;\nbegin\n  list1 := TIntArray.Create(1, 2, 3, 4, 5);\n  list2 := TIntArray.Create(3, 4, 5, 6, 7);\n\n  result := ListIntersection(list1, list2);\n\n  for i := 0 to High(result) do\n    Write(result[i], ' ');\nend.\n```"
  },
  {
    "task": "Create a list of prime numbers less than 100.",
    "code": "```pascal\nprogram PrimeNumbers;\n\nvar\n  primes: array of Integer;\n  i, j: Integer;\n  isPrime: Boolean;\n\nbegin\n  SetLength(primes, 0);\n\n  for i := 2 to 99 do\n  begin\n    isPrime := True;\n    for j := 2 to Trunc(Sqrt(i)) do\n    begin\n      if (i mod j = 0) then\n      begin\n        isPrime := False;\n        Break;\n      end;\n    end;\n    \n    if isPrime then\n    begin\n      SetLength(primes, Length(primes) + 1);\n      primes[High(primes)] := i;\n    end;\n  end;\nend.\n```"
  },
  {
    "task": "Write a function to split a list into two lists: one with even numbers and one with odd numbers.",
    "code": "```pascal\nprogram SplitListIntoEvenAndOdd;\n\ntype\n  TIntArray = array of Integer;\n\nprocedure SplitEvenOdd(const input: TIntArray; var evens, odds: TIntArray);\nvar\n  i: Integer;\n  evenCount, oddCount: Integer;\nbegin\n  evenCount := 0;\n  oddCount := 0;\n  \n  // Count evens and odds\n  for i := Low(input) to High(input) do\n  begin\n    if input[i] mod 2 = 0 then\n      Inc(evenCount)\n    else\n      Inc(oddCount);\n  end;\n  \n  // Set lengths of evens and odds arrays\n  SetLength(evens, evenCount);\n  SetLength(odds, oddCount);\n  \n  evenCount := 0;\n  oddCount := 0;\n  \n  // Populate evens and odds arrays\n  for i := Low(input) to High(input) do\n  begin\n    if input[i] mod 2 = 0 then\n    begin\n      evens[evenCount] := input[i];\n      Inc(evenCount);\n    end\n    else\n    begin\n      odds[oddCount] := input[i];\n      Inc(oddCount);\n    end;\n  end;\nend;\n\nvar\n  input, evens, odds: TIntArray;\n  i: Integer;\nbegin\n  input := TIntArray.Create(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n  \n  SplitEvenOdd(input, evens, odds);\n  \n  Write('Evens: ');\n  for i := Low(evens) to High(evens) do\n    Write(evens[i], ' ');\n  Writeln;\n  \n  Write('Odds: ');\n  for i := Low(odds) to High(odds) do\n    Write(odds[i], ' ');\n  Writeln;\nend.\n```"
  },
  {
    "task": "Create a list of strings and convert all the strings to uppercase.",
    "code": "```pascal\nprogram UpperCaseList;\n\nuses\n  SysUtils, Classes;\n\nvar\n  stringList: TStringList;\n  i: Integer;\nbegin\n  stringList := TStringList.Create;\n  try\n    stringList.Add('hello');\n    stringList.Add('world');\n    stringList.Add('pascal');\n    \n    for i := 0 to stringList.Count - 1 do\n    begin\n      stringList[i] := AnsiUpperCase(stringList[i]);\n    end;\n\n    for i := 0 to stringList.Count - 1 do\n    begin\n      WriteLn(stringList[i]);\n    end;\n  finally\n    stringList.Free;\n  end;\nend.\n```"
  },
  {
    "task": "Implement a program that removes all elements from a list that are less than a specified value.",
    "code": "```pascal\nprogram RemoveElements;\n\ntype\n  IntArray = array of Integer;\n\nvar\n  numbers: IntArray;\n  i, n, threshold: Integer;\n\nbegin\n  { Define the list }\n  numbers := IntArray.Create(10, 5, 8, 3, 20, 7, 15);\n\n  { Specify the threshold value }\n  threshold := 10;\n\n  { Remove elements less than threshold }\n  i := 0;\n  n := Length(numbers);\n  while i < n do\n  begin\n    if numbers[i] < threshold then\n    begin\n      numbers[i] := numbers[n - 1];\n      Dec(n);\n    end\n    else\n      Inc(i);\n  end;\n\n  { Resize the array }\n  SetLength(numbers, n);\n\n  { Output the modified list }\n  for i := 0 to High(numbers) do\n    WriteLn(numbers[i]);\nend.\n```"
  },
  {
    "task": "Write a function that takes a list and returns a new list with elements in random order.",
    "code": "```pascal\nprogram RandomOrderList;\n\nuses\n  SysUtils;\n\ntype\n  TIntArray = array of Integer;\n\nprocedure Swap(var A, B: Integer);\nvar\n  Temp: Integer;\nbegin\n  Temp := A;\n  A := B;\n  B := Temp;\nend;\n\nfunction RandomOrder(const A: TIntArray): TIntArray;\nvar\n  I, J: Integer;\nbegin\n  Result := Copy(A, 0, Length(A));\n  Randomize;\n  for I := High(Result) downto Low(Result) + 1 do\n  begin\n    J := Random(I + 1);\n    Swap(Result[I], Result[J]);\n  end;\nend;\n\nvar\n  Original, Shuffled: TIntArray;\n  I: Integer;\nbegin\n  Original := TIntArray.Create(1, 2, 3, 4, 5);\n  Shuffled := RandomOrder(Original);\n  for I := Low(Shuffled) to High(Shuffled) do\n    WriteLn(Shuffled[I]);\nend.\n```"
  },
  {
    "task": "Create a list of tuples where each tuple contains a number and its square.",
    "code": "```pascal\nprogram ListOfTuples;\n\ntype\n  Tuple = record\n    number: Integer;\n    square: Integer;\n  end;\n\nvar\n  i: Integer;\n  list: array of Tuple;\n\nbegin\n  SetLength(list, 10);\n  for i := 0 to High(list) do\n  begin\n    list[i].number := i;\n    list[i].square := i * i;\n  end;\nend.\n```"
  },
  {
    "task": "Write a program to multiply all elements in a list by a given factor.",
    "code": "```pascal\nprogram MultiplyListElements;\n\ntype\n  TIntArray = array of Integer;\n\nvar\n  numbers: TIntArray;\n  factor, i: Integer;\n\nprocedure MultiplyElements(var arr: TIntArray; factor: Integer);\nvar\n  i: Integer;\nbegin\n  for i := 0 to High(arr) do\n    arr[i] := arr[i] * factor;\nend;\n\nbegin\n  numbers := TIntArray.Create(1, 2, 3, 4, 5);\n  factor := 3;\n  \n  MultiplyElements(numbers, factor);\n  \n  for i := 0 to High(numbers) do\n    WriteLn(numbers[i]);\nend.\n```"
  },
  {
    "task": "Implement a function that flattens a nested list.",
    "code": "```pascal\nprogram FlattenNestedList;\n\ntype\n  PNode = ^TNode;\n  TNode = record\n    IsList: Boolean;\n    Next: PNode;\n    case Integer of\n      0: (Value: Integer);\n      1: (SubList: PNode);\n  end;\n\nprocedure AppendNode(var Head, Tail: PNode; Node: PNode);\nbegin\n  if Head = nil then\n    Head := Node\n  else\n    Tail^.Next := Node;\n  Tail := Node;\nend;\n\nfunction FlattenList(NestedList: PNode): PNode;\nvar\n  FlatList, Tail, Current, NewNode: PNode;\nbegin\n  FlatList := nil;\n  Tail := nil;\n  Current := NestedList;\n  while Current <> nil do\n  begin\n    if Current^.IsList then\n    begin\n      NewNode := FlattenList(Current^.SubList);\n      while NewNode <> nil do\n      begin\n        AppendNode(FlatList, Tail, NewNode);\n        NewNode := NewNode^.Next;\n      end;\n    end\n    else\n    begin\n      New(NewNode);\n      NewNode^.IsList := False;\n      NewNode^.Value := Current^.Value;\n      NewNode^.Next := nil;\n      AppendNode(FlatList, Tail, NewNode);\n    end;\n    Current := Current^.Next;\n  end;\n  FlattenList := FlatList;\nend;\n\nbegin\n  { Example usage }\nend.\n```"
  },
  {
    "task": "Create a list of dates and sort them chronologically.",
    "code": "```pascal\nprogram SortDates;\n\nuses\n  SysUtils, DateUtils;\n\nvar\n  Dates: array of TDateTime;\n  i: Integer;\n\nprocedure SortChronologically(var Arr: array of TDateTime);\nvar\n  i, j: Integer;\n  Temp: TDateTime;\nbegin\n  for i := Low(Arr) to High(Arr) - 1 do\n    for j := i + 1 to High(Arr) do\n      if Arr[i] > Arr[j] then\n      begin\n        Temp := Arr[i];\n        Arr[i] := Arr[j];\n        Arr[j] := Temp;\n      end;\nend;\n\nbegin\n  SetLength(Dates, 5);\n  \n  Dates[0] := EncodeDate(2023, 10, 1);\n  Dates[1] := EncodeDate(2023, 5, 15);\n  Dates[2] := EncodeDate(2023, 1, 20);\n  Dates[3] := EncodeDate(2023, 12, 25);\n  Dates[4] := EncodeDate(2023, 7, 4);\n  \n  SortChronologically(Dates);\n  \n  for i := Low(Dates) to High(Dates) do\n    WriteLn(FormatDateTime('yyyy-mm-dd', Dates[i]));\nend.\n```"
  },
  {
    "task": "Write a function that finds the index of the first occurrence of a given element in a list.",
    "code": "```pascal\nprogram FindIndexInList;\n\nuses SysUtils;\n\nfunction FindIndex(const aList: array of Integer; const element: Integer): Integer;\nvar\n  i: Integer;\nbegin\n  for i := Low(aList) to High(aList) do\n  begin\n    if aList[i] = element then\n    begin\n      Exit(i);\n    end;\n  end;\n  Result := -1;\nend;\n\nvar\n  myList: array of Integer;\n  index: Integer;\nbegin\n  myList := [10, 20, 30, 40, 50];\n  index := FindIndex(myList, 30);\n  WriteLn('Index of 30: ', index);\nend.\n```"
  },
  {
    "task": "Generate a list of Fibonacci numbers up to a specified limit.",
    "code": "```pascal\nprogram FibonacciList;\n\nuses SysUtils;\n\nvar\n  fibList: array of Integer;\n  limit, a, b, next: Integer;\n\nbegin\n  Write('Enter the limit: ');\n  ReadLn(limit);\n\n  a := 0;\n  b := 1;\n  SetLength(fibList, 0);\n\n  if limit >= 0 then\n  begin\n    while a <= limit do\n    begin\n      SetLength(fibList, Length(fibList) + 1);\n      fibList[High(fibList)] := a;\n      next := a + b;\n      a := b;\n      b := next;\n    end;\n  end;\n\n  Write('Fibonacci numbers up to ', limit, ': ');\n  for a := 0 to High(fibList) do\n    Write(fibList[a], ' ');\n\n  WriteLn;\nend.\n```"
  },
  {
    "task": "Create a list of booleans and determine if all are True.",
    "code": "```pascal\nprogram CheckAllTrue;\n\nuses SysUtils;\n\nvar\n  boolList: array of Boolean;\n  i: Integer;\n  allTrue: Boolean;\nbegin\n  boolList := [True, True, True, False, True];\n\n  allTrue := True;\n  for i := 0 to High(boolList) do\n  begin\n    if not boolList[i] then\n    begin\n      allTrue := False;\n      Break;\n    end;\n  end;\n\n  if allTrue then\n    WriteLn('All are True')\n  else\n    WriteLn('Not all are True');\nend.\n```"
  },
  {
    "task": "Write a program to concatenate two lists.",
    "code": "```pascal\nprogram ConcatenateLists;\nuses sysutils;\n\nvar\n  List1, List2, ConcatenatedList: array of Integer;\n  i, n1, n2: Integer;\n  \nbegin\n  { Initialize the first list }\n  n1 := 3; { Example size }\n  SetLength(List1, n1);\n  List1[0] := 1;\n  List1[1] := 2;\n  List1[2] := 3;\n\n  { Initialize the second list }\n  n2 := 2; { Example size }\n  SetLength(List2, n2);\n  List2[0] := 4;\n  List2[1] := 5;\n\n  { Concatenate lists }\n  SetLength(ConcatenatedList, n1 + n2);\n\n  for i := 0 to n1 - 1 do\n    ConcatenatedList[i] := List1[i];\n\n  for i := 0 to n2 - 1 do\n    ConcatenatedList[n1 + i] := List2[i];\n\n  { Output concatenated list }\n  for i := 0 to High(ConcatenatedList) do\n    WriteLn(ConcatenatedList[i]);\nend.\n```"
  },
  {
    "task": "Implement a function that returns the length of a list without using built-in functions.",
    "code": "```pascal\nprogram ListLength;\n\ntype\n  TIntList = array of Integer;\n\nfunction GetListLength(lst: TIntList): Integer;\nvar\n  i, count: Integer;\nbegin\n  count := 0;\n  for i := Low(lst) to High(lst) do\n  begin\n    count := count + 1;\n  end;\n  GetListLength := count;\nend;\n\nvar\n  myList: TIntList;\n  length: Integer;\nbegin\n  SetLength(myList, 5);\n  myList[0] := 10;\n  myList[1] := 20;\n  myList[2] := 30;\n  myList[3] := 40;\n  myList[4] := 50;\n\n  length := GetListLength(myList);\n  WriteLn('Length of the list: ', length);\nend.\n```"
  },
  {
    "task": "Create a list of words and find the longest word.",
    "code": "```pascal\nprogram FindLongestWord;\n\nuses SysUtils;\n\nvar\n  words: array of string;\n  longestWord: string;\n  i: Integer;\nbegin\n  // Initialize the list of words\n  words := ['apple', 'banana', 'strawberry', 'kiwi', 'grapefruit'];\n\n  // Initialize the longest word as an empty string\n  longestWord := '';\n\n  // Iterate through the list to find the longest word\n  for i := 0 to High(words) do\n  begin\n    if Length(words[i]) > Length(longestWord) then\n      longestWord := words[i];\n  end;\n\n  // Output the longest word\n  WriteLn('The longest word is: ', longestWord);\nend.\n```"
  },
  {
    "task": "Write a function that takes a list and a predicate function, returning a list of elements that satisfy the predicate.",
    "code": "```pascal\nprogram ListFilter;\n\ntype\n  TIntegerArray = array of Integer;\n  TPredicate = function(Value: Integer): Boolean;\n\nfunction FilterList(InputList: TIntegerArray; Predicate: TPredicate): TIntegerArray;\nvar\n  i, Count: Integer;\nbegin\n  Count := 0;\n  SetLength(Result, Length(InputList));\n  for i := 0 to High(InputList) do\n  begin\n    if Predicate(InputList[i]) then\n    begin\n      Result[Count] := InputList[i];\n      Inc(Count);\n    end;\n  end;\n  SetLength(Result, Count);\nend;\n\nfunction IsEven(Value: Integer): Boolean;\nbegin\n  Result := Value mod 2 = 0;\nend;\n\nvar\n  Numbers, Filtered: TIntegerArray;\nbegin\n  Numbers := TIntegerArray.Create(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n  Filtered := FilterList(Numbers, @IsEven);\nend.\n```"
  },
  {
    "task": "Generate a list of strings and filter out those with less than 5 characters.",
    "code": "```pascal\nprogram FilterStrings;\n\nuses\n  SysUtils;\n\nvar\n  inputList, outputList: array of string;\n  i: Integer;\n\nbegin\n  inputList := ['apple', 'kiwi', 'banana', 'pear', 'peach'];\n  SetLength(outputList, 0);\n\n  for i := 0 to High(inputList) do\n  begin\n    if Length(inputList[i]) >= 5 then\n    begin\n      SetLength(outputList, Length(outputList) + 1);\n      outputList[High(outputList)] := inputList[i];\n    end;\n  end;\n\n  for i := 0 to High(outputList) do\n  begin\n    WriteLn(outputList[i]);\n  end;\nend.\n```"
  },
  {
    "task": "Create a list of mixed data types and separate them into lists by type.",
    "code": "```pascal\nprogram SeparateTypes;\n\ntype\n  MixedArray = array of Variant;\n  IntegerArray = array of Integer;\n  RealArray = array of Real;\n  StringArray = array of String;\n\nvar\n  mixedList: MixedArray;\n  integers: IntegerArray;\n  reals: RealArray;\n  strings: StringArray;\n  i: Integer;\n\nbegin\n  mixedList := VarArrayOf([1, 2.5, 'hello', 3, 'world', 4.2]);\n\n  SetLength(integers, 0);\n  SetLength(reals, 0);\n  SetLength(strings, 0);\n\n  for i := Low(mixedList) to High(mixedList) do\n  begin\n    if VarIsType(mixedList[i], varInteger) then\n    begin\n      SetLength(integers, Length(integers) + 1);\n      integers[High(integers)] := mixedList[i];\n    end\n    else if VarIsType(mixedList[i], varDouble) then\n    begin\n      SetLength(reals, Length(reals) + 1);\n      reals[High(reals)] := mixedList[i];\n    end\n    else if VarIsType(mixedList[i], varUString) then\n    begin\n      SetLength(strings, Length(strings) + 1);\n      strings[High(strings)] := mixedList[i];\n    end;\n  end;\nend.\n```"
  },
  {
    "task": "Write a program to find the common elements between two lists.",
    "code": "```pascal\nprogram CommonElements;\n\nuses\n  SysUtils;\n  \nvar\n  list1, list2, commonList: array of Integer;\n  i, j: Integer;\n  found: Boolean;\n\nbegin\n  list1 := [1, 2, 3, 4, 5];\n  list2 := [4, 5, 6, 7, 8];\n  SetLength(commonList, 0);\n\n  for i := 0 to High(list1) do\n  begin\n    found := False;\n    for j := 0 to High(list2) do\n    begin\n      if list1[i] = list2[j] then\n      begin\n        found := True;\n        Break;\n      end;\n    end;\n    if found then\n    begin\n      SetLength(commonList, Length(commonList) + 1);\n      commonList[High(commonList)] := list1[i];\n    end;\n  end;\n\n  for i := 0 to High(commonList) do\n    WriteLn(commonList[i]);\nend.\n```"
  },
  {
    "task": "Implement a function to rotate the elements of a list to the left by a given number of steps.",
    "code": "```pascal\nprogram RotateList;\n\ntype\n  TIntArray = array of Integer;\n\nfunction RotateLeft(arr: TIntArray; steps: Integer): TIntArray;\nvar\n  i, n: Integer;\n  rotatedArr: TIntArray;\nbegin\n  n := Length(arr);\n  SetLength(rotatedArr, n);\n  for i := 0 to n - 1 do\n  begin\n    rotatedArr[i] := arr[(i + steps) mod n];\n  end;\n  RotateLeft := rotatedArr;\nend;\n\nvar\n  originalList, rotatedList: TIntArray;\n  i: Integer;\nbegin\n  originalList := TIntArray.Create(1, 2, 3, 4, 5);\n  rotatedList := RotateLeft(originalList, 2);\n\n  for i := 0 to High(rotatedList) do\n  begin\n    Write(rotatedList[i], ' ');\n  end;\n  WriteLn;\nend.\n```"
  },
  {
    "task": "Create a list of numbers and find the product of all the elements.",
    "code": "```pascal\nprogram ListProduct;\nuses SysUtils;\n\nvar\n  numbers: array of Integer;\n  product, i: Integer;\nbegin\n  numbers := [1, 2, 3, 4, 5]; // Example list of numbers\n  product := 1;\n  \n  for i := Low(numbers) to High(numbers) do\n  begin\n    product := product * numbers[i];\n  end;\n  \n  WriteLn('Product of all elements: ', product);\nend.\n```"
  },
  {
    "task": "Write a function that removes all occurrences of a specified element from a list.",
    "code": "```pascal\nprogram RemoveElementFromList;\n\nuses SysUtils;\n\ntype\n  TIntList = array of Integer;\n\nfunction RemoveElement(var AList: TIntList; Element: Integer): TIntList;\nvar\n  i, j, Count: Integer;\nbegin\n  Count := 0;\n  for i := 0 to High(AList) do\n    if AList[i] = Element then\n      Inc(Count);\n\n  SetLength(Result, Length(AList) - Count);\n  j := 0;\n  for i := 0 to High(AList) do\n  begin\n    if AList[i] <> Element then\n    begin\n      Result[j] := AList[i];\n      Inc(j);\n    end;\n  end;\nend;\n\nvar\n  MyList: TIntList;\n  NewList: TIntList;\n  i: Integer;\nbegin\n  MyList := [1, 2, 3, 4, 3, 5, 3];\n  NewList := RemoveElement(MyList, 3);\n\n  for i := 0 to High(NewList) do\n    WriteLn(NewList[i]);\nend.\n```"
  },
  {
    "task": "Generate a list of random numbers and find the median value.",
    "code": "```pascal\nprogram FindMedian;\n\nuses\n  SysUtils, Math;\n\ntype\n  TIntegerArray = array of Integer;\n\nfunction GenerateRandomNumbers(Count: Integer; MaxValue: Integer): TIntegerArray;\nvar\n  i: Integer;\nbegin\n  Randomize;\n  SetLength(Result, Count);\n  for i := 0 to Count - 1 do\n    Result[i] := Random(MaxValue);\nend;\n\nprocedure SortList(var List: TIntegerArray);\nvar\n  i, j, Temp: Integer;\nbegin\n  for i := 0 to High(List) - 1 do\n    for j := i + 1 to High(List) do\n      if List[i] > List[j] then\n      begin\n        Temp := List[i];\n        List[i] := List[j];\n        List[j] := Temp;\n      end;\nend;\n\nfunction FindMedian(List: TIntegerArray): Double;\nvar\n  Middle: Integer;\nbegin\n  SortList(List);\n  Middle := Length(List) div 2;\n  if Length(List) mod 2 = 0 then\n    Result := (List[Middle - 1] + List[Middle]) / 2\n  else\n    Result := List[Middle];\nend;\n\nvar\n  Numbers: TIntegerArray;\n  Median: Double;\nbegin\n  Numbers := GenerateRandomNumbers(10, 100);\n  Median := FindMedian(Numbers);\n  WriteLn('Median value: ', Median:0:2);\nend.\n```"
  },
  {
    "task": "Create a list of dictionaries and sort them by a specific key.",
    "code": "```pascal\nprogram SortListOfDictionaries;\n\ntype\n  Dict = record\n    Key: string;\n    Value: integer;\n  end;\n\nvar\n  List: array of Dict;\n  i, j: integer;\n  Temp: Dict;\n\nbegin\n  // Sample data\n  SetLength(List, 3);\n  List[0].Key := 'apple';\n  List[0].Value := 5;\n  List[1].Key := 'banana';\n  List[1].Value := 2;\n  List[2].Key := 'cherry';\n  List[2].Value := 8;\n\n  // Sort List by Value\n  for i := 0 to High(List) - 1 do\n    for j := i + 1 to High(List) do\n      if List[i].Value > List[j].Value then\n      begin\n        Temp := List[i];\n        List[i] := List[j];\n        List[j] := Temp;\n      end;\n\n  // Output sorted List\n  for i := 0 to High(List) do\n    writeln(List[i].Key, ': ', List[i].Value);\nend.\n```"
  },
  {
    "task": "Write a program to split a list into chunks of a specified size.",
    "code": "```pascal\nprogram SplitListIntoChunks;\n\ntype\n  TIntArray = array of Integer;\n  TListOfIntArray = array of TIntArray;\n\nfunction SplitIntoChunks(arr: TIntArray; chunkSize: Integer): TListOfIntArray;\nvar\n  i, j, len, numChunks: Integer;\nbegin\n  len := Length(arr);\n  if chunkSize <= 0 then\n  begin\n    SetLength(Result, 0);\n    Exit;\n  end;\n\n  numChunks := (len + chunkSize - 1) div chunkSize;\n  SetLength(Result, numChunks);\n\n  for i := 0 to numChunks - 1 do\n  begin\n    SetLength(Result[i], Min(chunkSize, len - i * chunkSize));\n    for j := 0 to High(Result[i]) do\n    begin\n      Result[i][j] := arr[i * chunkSize + j];\n    end;\n  end;\nend;\n\nvar\n  originalList: TIntArray;\n  chunkedList: TListOfIntArray;\n  i, j: Integer;\nbegin\n  originalList := TIntArray.Create(1, 2, 3, 4, 5, 6, 7, 8, 9);\n  chunkedList := SplitIntoChunks(originalList, 3);\n\n  for i := 0 to High(chunkedList) do\n  begin\n    Write('Chunk ', i + 1, ': ');\n    for j := 0 to High(chunkedList[i]) do\n    begin\n      Write(chunkedList[i][j], ' ');\n    end;\n    Writeln;\n  end;\nend.\n```"
  },
  {
    "task": "Implement a function that takes a list and returns a dictionary with the frequency of each element.",
    "code": "```pascal\nprogram ListFrequency;\n\nuses\n  SysUtils, Generics.Collections;\n\nfunction ListFrequency(const AList: TList<Integer>): TDictionary<Integer, Integer>;\nvar\n  FreqDict: TDictionary<Integer, Integer>;\n  Element: Integer;\nbegin\n  FreqDict := TDictionary<Integer, Integer>.Create;\n  try\n    for Element in AList do\n    begin\n      if FreqDict.ContainsKey(Element) then\n        FreqDict[Element] := FreqDict[Element] + 1\n      else\n        FreqDict.Add(Element, 1);\n    end;\n    Result := FreqDict;\n  except\n    FreqDict.Free;\n    raise;\n  end;\nend;\n\nvar\n  List: TList<Integer>;\n  Dict: TDictionary<Integer, Integer>;\n  Pair: TPair<Integer, Integer>;\nbegin\n  List := TList<Integer>.Create;\n  try\n    List.AddRange([1, 2, 2, 3, 1, 4, 2, 3]);\n    Dict := ListFrequency(List);\n    try\n      for Pair in Dict do\n        WriteLn(Format('Element: %d, Frequency: %d', [Pair.Key, Pair.Value]));\n    finally\n      Dict.Free;\n    end;\n  finally\n    List.Free;\n  end;\nend.\n```"
  },
  {
    "task": "Create a list of integers and replace all negative numbers with zero.",
    "code": "```pascal\nprogram ReplaceNegativeWithZero;\nuses SysUtils;\n\nvar\n  nums: array of Integer;\n  i: Integer;\n\nbegin\n  nums := [3, -1, 4, -9, 8, -7];\n  for i := 0 to High(nums) do\n  begin\n    if nums[i] < 0 then\n      nums[i] := 0;\n  end;\nend.\n```"
  },
  {
    "task": "Write a function that returns the first n elements of a list.",
    "code": "```pascal\nprogram FirstNElements;\n\ntype\n  IntArray = array of Integer;\n\nfunction FirstNElementsOfList(arr: IntArray; n: Integer): IntArray;\nvar\n  i: Integer;\n  resultArray: IntArray;\nbegin\n  if n > Length(arr) then\n    n := Length(arr);\n  SetLength(resultArray, n);\n  for i := 0 to n - 1 do\n    resultArray[i] := arr[i];\n  FirstNElementsOfList := resultArray;\nend;\n\nvar\n  myArray, subArray: IntArray;\n  i: Integer;\nbegin\n  myArray := [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n  subArray := FirstNElementsOfList(myArray, 5);\n  for i := 0 to High(subArray) do\n    WriteLn(subArray[i]);\nend.\n```"
  },
  {
    "task": "Generate a list of strings and join them into a single string with spaces.",
    "code": "```pascal\nprogram JoinStringList;\n\nuses\n  SysUtils;\n\nvar\n  stringList: array of string;\n  joinedString: string;\n  i: Integer;\nbegin\n  stringList := ['Hello', 'world', 'this', 'is', 'Pascal'];\n  joinedString := '';\n  \n  for i := Low(stringList) to High(stringList) do\n  begin\n    if i > Low(stringList) then\n      joinedString := joinedString + ' ';\n    joinedString := joinedString + stringList[i];\n  end;\n\n  WriteLn(joinedString);\nend.\n```"
  },
  {
    "task": "Create a list of lists and find the sum of each inner list.",
    "code": "```pascal\nprogram ListOfListsSum;\n\ntype\n  TIntList = array of Integer;\n  TIntListArray = array of TIntList;\n\nvar\n  lists: TIntListArray;\n  sumList: TIntList;\n  i, j, sum: Integer;\n\nbegin\n  // Initialize the list of lists\n  SetLength(lists, 3);\n  \n  SetLength(lists[0], 3);\n  lists[0][0] := 1;\n  lists[0][1] := 2;\n  lists[0][2] := 3;\n\n  SetLength(lists[1], 2);\n  lists[1][0] := 4;\n  lists[1][1] := 5;\n\n  SetLength(lists[2], 4);\n  lists[2][0] := 6;\n  lists[2][1] := 7;\n  lists[2][2] := 8;\n  lists[2][3] := 9;\n\n  // Initialize the result list\n  SetLength(sumList, Length(lists));\n\n  // Calculate the sum of each inner list\n  for i := 0 to High(lists) do\n  begin\n    sum := 0;\n    for j := 0 to High(lists[i]) do\n    begin\n      sum := sum + lists[i][j];\n    end;\n    sumList[i] := sum;\n  end;\n\n  // Output the result\n  for i := 0 to High(sumList) do\n  begin\n    WriteLn('Sum of list ', i, ': ', sumList[i]);\n  end;\nend.\n```"
  },
  {
    "task": "Write a function that finds the second largest number in a list.",
    "code": "```pascal\nprogram SecondLargestFinder;\n\nuses SysUtils;\n\nfunction SecondLargest(numbers: array of Integer): Integer;\nvar\n  first, second, i: Integer;\nbegin\n  if Length(numbers) < 2 then\n    raise Exception.Create('List must contain at least two elements.');\n\n  first := -MaxInt;\n  second := -MaxInt;\n\n  for i := 0 to High(numbers) do\n  begin\n    if numbers[i] > first then\n    begin\n      second := first;\n      first := numbers[i];\n    end\n    else if (numbers[i] > second) and (numbers[i] <> first) then\n    begin\n      second := numbers[i];\n    end;\n  end;\n\n  if second = -MaxInt then\n    raise Exception.Create('No second largest element found.');\n\n  Result := second;\nend;\n\nvar\n  nums: array of Integer;\n  result: Integer;\nbegin\n  nums := [5, 8, 12, 7, 10];\n  result := SecondLargest(nums);\n  WriteLn('The second largest number is: ', result);\nend.\n```"
  },
  {
    "task": "Generate a list of numbers and remove the duplicates while maintaining order.",
    "code": "```pascal\nprogram RemoveDuplicates;\n\nuses\n  sysutils;\n\nvar\n  numbers, uniqueNumbers: array of Integer;\n  i, num: Integer;\n  found: Boolean;\n\nbegin\n  // Example input list\n  numbers := [5, 3, 9, 3, 5, 7, 8, 9, 2, 1];\n  \n  SetLength(uniqueNumbers, 0);\n  \n  for i := 0 to High(numbers) do\n  begin\n    num := numbers[i];\n    found := False;\n    \n    for num in uniqueNumbers do\n    begin\n      if num = numbers[i] then\n      begin\n        found := True;\n        Break;\n      end;\n    end;\n    \n    if not found then\n    begin\n      SetLength(uniqueNumbers, Length(uniqueNumbers) + 1);\n      uniqueNumbers[High(uniqueNumbers)] := numbers[i];\n    end;\n  end;\n  \n  // Output the result\n  for i := 0 to High(uniqueNumbers) do\n    Write(uniqueNumbers[i], ' ');\n  Writeln;\nend.\n```"
  },
  {
    "task": "Create a list of integers and partition it into two lists: one with numbers above the average and one below.",
    "code": "```pascal\nprogram PartitionList;\n\ntype\n  TIntArray = array of Integer;\n\nvar\n  numbers, aboveAverage, belowAverage: TIntArray;\n  sum, average: Real;\n  i, n: Integer;\n\nbegin\n  { Initialize the list of integers }\n  numbers := TIntArray.Create(10, 20, 30, 40, 50);\n  \n  { Calculate the sum of the integers }\n  sum := 0;\n  for i := 0 to High(numbers) do\n    sum := sum + numbers[i];\n  \n  { Calculate the average }\n  average := sum / (High(numbers) + 1);\n  \n  { Partition the numbers into aboveAverage and belowAverage lists }\n  SetLength(aboveAverage, 0);\n  SetLength(belowAverage, 0);\n  for i := 0 to High(numbers) do\n  begin\n    if numbers[i] > average then\n    begin\n      SetLength(aboveAverage, Length(aboveAverage) + 1);\n      aboveAverage[High(aboveAverage)] := numbers[i];\n    end\n    else\n    begin\n      SetLength(belowAverage, Length(belowAverage) + 1);\n      belowAverage[High(belowAverage)] := numbers[i];\n    end;\n  end;\nend.\n```"
  },
  {
    "task": "Write a program to find the longest increasing subsequence in a list of numbers.",
    "code": "```pascal\nprogram LongestIncreasingSubsequence;\n\ntype\n  TIntArray = array of Integer;\n\nfunction Max(a, b: Integer): Integer;\nbegin\n  if a > b then\n    Max := a\n  else\n    Max := b;\nend;\n\nfunction LongestIncreasingSubsequenceLength(arr: TIntArray): Integer;\nvar\n  n, i, j, maxLength: Integer;\n  lis: array of Integer;\nbegin\n  n := Length(arr);\n  SetLength(lis, n);\n\n  for i := 0 to n - 1 do\n    lis[i] := 1;\n\n  for i := 1 to n - 1 do\n    for j := 0 to i - 1 do\n      if (arr[i] > arr[j]) and (lis[i] < lis[j] + 1) then\n        lis[i] := lis[j] + 1;\n\n  maxLength := 0;\n  for i := 0 to n - 1 do\n    maxLength := Max(maxLength, lis[i]);\n\n  LongestIncreasingSubsequenceLength := maxLength;\nend;\n\nvar\n  numbers: TIntArray;\n  length: Integer;\nbegin\n  numbers := TIntArray.Create(10, 22, 9, 33, 21, 50, 41, 60, 80);\n  length := LongestIncreasingSubsequenceLength(numbers);\n  WriteLn('Length of Longest Increasing Subsequence is: ', length);\nend.\n```"
  },
  {
    "task": "Implement a function to zip two lists into a single list of tuples.",
    "code": "```pascal\nprogram ZipLists;\n\ntype\n  TIntArray = array of Integer;\n  TTupleArray = array of record\n    First: Integer;\n    Second: Integer;\n  end;\n\nfunction ZipLists(list1, list2: TIntArray): TTupleArray;\nvar\n  i, minLength: Integer;\nbegin\n  if Length(list1) < Length(list2) then\n    minLength := Length(list1)\n  else\n    minLength := Length(list2);\n    \n  SetLength(Result, minLength);\n\n  for i := 0 to minLength - 1 do\n  begin\n    Result[i].First := list1[i];\n    Result[i].Second := list2[i];\n  end;\nend;\n\nvar\n  list1, list2: TIntArray;\n  zippedList: TTupleArray;\n  i: Integer;\nbegin\n  list1 := TIntArray.Create(1, 2, 3);\n  list2 := TIntArray.Create(4, 5, 6);\n  zippedList := ZipLists(list1, list2);\n  \n  for i := 0 to High(zippedList) do\n  begin\n    WriteLn('(', zippedList[i].First, ', ', zippedList[i].Second, ')');\n  end;\nend.\n```"
  },
  {
    "task": "Create a list of characters and count the vowels.",
    "code": "```pascal\nprogram VowelCounter;\n\nuses\n  SysUtils;\n\nvar\n  CharList: array of Char;\n  Vowels: set of Char;\n  i, VowelCount: Integer;\n\nbegin\n  CharList := ['a', 'b', 'c', 'e', 'i', 'o', 'u', 'x', 'y', 'z'];\n  Vowels := ['a', 'e', 'i', 'o', 'u'];\n  VowelCount := 0;\n\n  for i := 0 to High(CharList) do\n  begin\n    if CharList[i] in Vowels then\n      Inc(VowelCount);\n  end;\n\n  WriteLn('Number of vowels: ', VowelCount);\nend.\n```"
  },
  {
    "task": "Write a function that returns the last n elements of a list.",
    "code": "```pascal\nprogram LastNElements;\n\ntype\n  TIntArray = array of Integer;\n\nfunction GetLastNElements(arr: TIntArray; n: Integer): TIntArray;\nvar\n  len, i: Integer;\nbegin\n  len := Length(arr);\n  if n > len then\n    n := len;\n  SetLength(Result, n);\n  for i := 0 to n - 1 do\n    Result[i] := arr[len - n + i];\nend;\n\nvar\n  arr, lastN: TIntArray;\n  i: Integer;\nbegin\n  arr := TIntArray.Create(1, 2, 3, 4, 5);\n  lastN := GetLastNElements(arr, 3);\n  for i := 0 to High(lastN) do\n    WriteLn(lastN[i]);\nend.\n```"
  },
  {
    "task": "Generate a list of numbers and split it into two lists: one with positive numbers and one with negative numbers.",
    "code": "```pascal\nprogram SplitNumbers;\n\nuses SysUtils;\n\nvar\n  numbers, positives, negatives: array of Integer;\n  i, num: Integer;\n\nbegin\n  numbers := [10, -3, 5, -7, 0, 2, -1];\n  SetLength(positives, 0);\n  SetLength(negatives, 0);\n\n  for i := 0 to High(numbers) do\n  begin\n    num := numbers[i];\n    if num > 0 then\n    begin\n      SetLength(positives, Length(positives) + 1);\n      positives[High(positives)] := num;\n    end\n    else if num < 0 then\n    begin\n      SetLength(negatives, Length(negatives) + 1);\n      negatives[High(negatives)] := num;\n    end;\n  end;\n\n  Write('Positives: ');\n  for i := 0 to High(positives) do\n    Write(positives[i], ' ');\n\n  WriteLn;\n  \n  Write('Negatives: ');\n  for i := 0 to High(negatives) do\n    Write(negatives[i], ' ');\n\n  WriteLn;\nend.\n```"
  },
  {
    "task": "Create a list of random integers and find the mode.",
    "code": "```pascal\nprogram FindMode;\n\nuses SysUtils;\n\ntype\n  TIntegerArray = array of Integer;\n\nfunction RandomIntList(Count, MaxValue: Integer): TIntegerArray;\nvar\n  i: Integer;\nbegin\n  SetLength(Result, Count);\n  Randomize;\n  for i := 0 to Count - 1 do\n    Result[i] := Random(MaxValue);\nend;\n\nfunction FindMode(const List: TIntegerArray): Integer;\nvar\n  Frequency: array of Integer;\n  i, MaxFreq, ModeValue: Integer;\nbegin\n  SetLength(Frequency, Length(List));\n  for i := 0 to High(List) do\n    Inc(Frequency[List[i]]);\n  \n  MaxFreq := 0;\n  ModeValue := -1;\n  for i := 0 to High(List) do\n  begin\n    if Frequency[List[i]] > MaxFreq then\n    begin\n      MaxFreq := Frequency[List[i]];\n      ModeValue := List[i];\n    end;\n  end;\n  Result := ModeValue;\nend;\n\nvar\n  RandomList: TIntegerArray;\n  Mode: Integer;\nbegin\n  RandomList := RandomIntList(20, 10);\n  Mode := FindMode(RandomList);\n  WriteLn('The mode is: ', Mode);\nend.\n```"
  },
  {
    "task": "Write a program to find the shortest path in a grid using a list to represent the path.",
    "code": "```pascal\nprogram ShortestPathGrid;\n\nuses sysutils, classes;\n\ntype\n  TPoint = record\n    X, Y: Integer;\n  end;\n\nvar\n  Grid: array of array of Integer;\n  Visited: array of array of Boolean;\n  Path: TList;\n  Directions: array[0..3] of TPoint = ((X: 0; Y: 1), (X: 1; Y: 0), (X: 0; Y: -1), (X: -1; Y: 0));\n  StartPoint, EndPoint: TPoint;\n  GridSize, i, j: Integer;\n\nfunction IsValidPoint(Point: TPoint): Boolean;\nbegin\n  Result := (Point.X >= 0) and (Point.X < GridSize) and\n            (Point.Y >= 0) and (Point.Y < GridSize) and\n            (Grid[Point.X][Point.Y] = 0) and\n            not Visited[Point.X][Point.Y];\nend;\n\nfunction FindShortestPath(Start, Dest: TPoint): Boolean;\nvar\n  Queue: TQueue;\n  Current, Next: TPoint;\n  i: Integer;\nbegin\n  Result := False;\n  Queue := TQueue.Create;\n  try\n    Queue.Push(Start);\n    Visited[Start.X][Start.Y] := True;\n    while Queue.Count > 0 do\n    begin\n      Current := TPoint(Queue.Pop);\n      Path.Add(@Current);\n      if (Current.X = Dest.X) and (Current.Y = Dest.Y) then\n      begin\n        Result := True;\n        Exit;\n      end;\n      for i := 0 to 3 do\n      begin\n        Next.X := Current.X + Directions[i].X;\n        Next.Y := Current.Y + Directions[i].Y;\n        if IsValidPoint(Next) then\n        begin\n          Queue.Push(Next);\n          Visited[Next.X][Next.Y] := True;\n        end;\n      end;\n    end;\n  finally\n    Queue.Free;\n  end;\nend;\n\nbegin\n  GridSize := 5;  // Example grid size, can be modified\n  SetLength(Grid, GridSize, GridSize);\n  SetLength(Visited, GridSize, GridSize);\n\n  // Initialize Grid (0 = open path, 1 = obstacle)\n  for i := 0 to GridSize - 1 do\n    for j := 0 to GridSize - 1 do\n      Grid[i][j] := 0;\n\n  // Example obstacles\n  Grid[1][2] := 1;\n  Grid[2][2] := 1;\n  Grid[3][2] := 1;\n\n  StartPoint.X := 0;\n  StartPoint.Y := 0;\n  EndPoint.X := 4;\n  EndPoint.Y := 4;\n\n  Path := TList.Create;\n  try\n    if FindShortestPath(StartPoint, EndPoint) then\n    begin\n      WriteLn('Path found:');\n      for i := 0 to Path.Count - 1 do\n      begin\n        WriteLn('(', TPoint(Path.Items[i]^).X, ', ', TPoint(Path.Items[i]^).Y, ')');\n      end;\n    end\n    else\n      WriteLn('No path found.');\n  finally\n    Path.Free;\n  end;\nend.\n```"
  },
  {
    "task": "Implement a function that takes a list and returns a list with elements doubled.",
    "code": "```pascal\nprogram DoubleList;\n\ntype\n  TIntArray = array of Integer;\n\nfunction DoubleElements(inputList: TIntArray): TIntArray;\nvar\n  i: Integer;\nbegin\n  SetLength(Result, Length(inputList));\n  for i := 0 to High(inputList) do\n  begin\n    Result[i] := inputList[i] * 2;\n  end;\nend;\n\nvar\n  originalList, doubledList: TIntArray;\n  i: Integer;\nbegin\n  originalList := TIntArray.Create(1, 2, 3, 4, 5);\n  doubledList := DoubleElements(originalList);\n\n  for i := 0 to High(doubledList) do\n  begin\n    WriteLn(doubledList[i]);\n  end;\nend.\n```"
  },
  {
    "task": "Create a list of integers and sort them in descending order.",
    "code": "```pascal\nprogram SortDescending;\n\nuses\n  SysUtils;\n\nvar\n  intList: array of Integer;\n  i, j, temp: Integer;\n\nbegin\n  // Initialize list with some integers\n  intList := [5, 3, 8, 1, 9, 2, 7, 4, 6];\n\n  // Sort the list in descending order using bubble sort\n  for i := 0 to High(intList) - 1 do\n    for j := 0 to High(intList) - i - 1 do\n      if intList[j] < intList[j + 1] then\n      begin\n        temp := intList[j];\n        intList[j] := intList[j + 1];\n        intList[j + 1] := temp;\n      end;\n\n  // Output the sorted list\n  for i := 0 to High(intList) do\n    WriteLn(intList[i]);\nend.\n```"
  },
  {
    "task": "Write a function that takes a list of intervals and merges overlapping intervals.",
    "code": "```pascal\nprogram MergeIntervals;\n\ntype\n  TInterval = record\n    Start, End_: Integer;\n  end;\n\n  TIntervalList = array of TInterval;\n\nfunction MergeIntervals(intervals: TIntervalList): TIntervalList;\nvar\n  i, j, n: Integer;\n  resultList: TIntervalList;\nbegin\n  n := Length(intervals);\n  if n = 0 then\n  begin\n    SetLength(resultList, 0);\n    Exit(resultList);\n  end;\n\n  // Sort intervals by Start\n  for i := 0 to n - 2 do\n    for j := 0 to n - 2 - i do\n      if intervals[j].Start > intervals[j + 1].Start then\n      begin\n        intervals[j] := intervals[j + 1];\n        intervals[j + 1] := intervals[j];\n      end;\n\n  SetLength(resultList, 0);\n  SetLength(resultList, 1);\n  resultList[0] := intervals[0];\n\n  for i := 1 to n - 1 do\n  begin\n    if resultList[High(resultList)].End_ >= intervals[i].Start then\n    begin\n      if resultList[High(resultList)].End_ < intervals[i].End_ then\n        resultList[High(resultList)].End_ := intervals[i].End_;\n    end\n    else\n    begin\n      SetLength(resultList, Length(resultList) + 1);\n      resultList[High(resultList)] := intervals[i];\n    end;\n  end;\n\n  Result := resultList;\nend;\n\nbegin\n  // Example usage could be placed here\nend.\n```"
  },
  {
    "task": "Generate a list of random numbers and find the range (difference between max and min).",
    "code": "```pascal\nprogram RandomNumberRange;\n\nuses\n  SysUtils;\n\nconst\n  ListSize = 10;\n\nvar\n  Numbers: array of Integer;\n  i, MaxNum, MinNum, Range: Integer;\nbegin\n  Randomize;\n  SetLength(Numbers, ListSize);\n\n  for i := 0 to ListSize - 1 do\n    Numbers[i] := Random(100);\n\n  MaxNum := Numbers[0];\n  MinNum := Numbers[0];\n\n  for i := 1 to ListSize - 1 do\n  begin\n    if Numbers[i] > MaxNum then\n      MaxNum := Numbers[i];\n    if Numbers[i] < MinNum then\n      MinNum := Numbers[i];\n  end;\n\n  Range := MaxNum - MinNum;\n  WriteLn('Range: ', Range);\nend.\n```"
  },
  {
    "task": "Create a list of strings and remove any that are palindromes.",
    "code": "```pascal\nprogram RemovePalindromeStrings;\n\nuses\n  SysUtils;\n\nvar\n  strList: array of string;\n  i: Integer;\n\nfunction IsPalindrome(s: string): Boolean;\nvar\n  len, j: Integer;\nbegin\n  len := Length(s);\n  for j := 1 to len div 2 do\n    if s[j] <> s[len - j + 1] then\n      Exit(False);\n  Exit(True);\nend;\n\nbegin\n  // Initialize the list\n  strList := ['level', 'world', 'deified', 'hello', 'racecar', 'coding'];\n\n  // Remove palindromes\n  i := 0;\n  while i < Length(strList) do\n  begin\n    if IsPalindrome(strList[i]) then\n    begin\n      strList[i] := strList[High(strList)];\n      SetLength(strList, Length(strList) - 1);\n    end\n    else\n      Inc(i);\n  end;\n\n  // Output the list\n  for i := 0 to High(strList) do\n    WriteLn(strList[i]);\nend.\n```"
  },
  {
    "task": "Write a program to cyclically permute the elements of a list.",
    "code": "```pascal\nprogram CyclicPermute;\n\nuses sysutils;\n\nvar\n  List: array of Integer;\n  n, i, temp: Integer;\n\nbegin\n  // Example list initialization\n  List := [1, 2, 3, 4, 5];\n  n := Length(List);\n\n  if n > 0 then\n  begin\n    temp := List[n-1];\n    for i := n-1 downto 1 do\n      List[i] := List[i-1];\n    List[0] := temp;\n  end;\n\n  for i := 0 to n-1 do\n    Write(List[i], ' ');\n  Writeln;\nend.\n```"
  },
  {
    "task": "Implement a function to create a list of cumulative sums from a list of numbers.",
    "code": "```pascal\nprogram CumulativeSums;\n\ntype\n  TIntegerArray = array of Integer;\n\nfunction CumulativeSumList(numbers: TIntegerArray): TIntegerArray;\nvar\n  i, sum: Integer;\nbegin\n  SetLength(Result, Length(numbers));\n  sum := 0;\n  for i := 0 to High(numbers) do\n  begin\n    sum := sum + numbers[i];\n    Result[i] := sum;\n  end;\nend;\n\nvar\n  numbers, cumSums: TIntegerArray;\n  i: Integer;\nbegin\n  numbers := TIntegerArray.Create(1, 2, 3, 4, 5);\n  cumSums := CumulativeSumList(numbers);\n  for i := 0 to High(cumSums) do\n    WriteLn(cumSums[i]);\nend.\n```"
  },
  {
    "task": "Create a list of numbers and shift all zeros to the end.",
    "code": "```pascal\nprogram ShiftZerosToEnd;\nuses SysUtils;\n\nvar\n  numbers, result: array of Integer;\n  i, count: Integer;\nbegin\n  numbers := [0, 1, 0, 3, 12, 0, 5];\n  SetLength(result, Length(numbers));\n\n  count := 0;\n  for i := 0 to High(numbers) do\n    if numbers[i] <> 0 then\n    begin\n      result[count] := numbers[i];\n      Inc(count);\n    end;\n\n  while count < Length(numbers) do\n  begin\n    result[count] := 0;\n    Inc(count);\n  end;\n\n  for i := 0 to High(result) do\n    Write(result[i], ' ');\n  WriteLn;\nend.\n```"
  },
  {
    "task": "Write a program to simulate a queue using a list.",
    "code": "```pascal\nprogram QueueSimulation;\n\ntype\n  TQueue = record\n    items: array of Integer;\n  end;\n\nprocedure InitializeQueue(var q: TQueue);\nbegin\n  SetLength(q.items, 0);\nend;\n\nprocedure Enqueue(var q: TQueue; value: Integer);\nbegin\n  SetLength(q.items, Length(q.items) + 1);\n  q.items[High(q.items)] := value;\nend;\n\nfunction Dequeue(var q: TQueue): Integer;\nvar\n  i: Integer;\n  resultValue: Integer;\nbegin\n  if Length(q.items) = 0 then\n    raise Exception.Create('Queue is empty');\n\n  resultValue := q.items[0];\n  for i := 0 to High(q.items) - 1 do\n    q.items[i] := q.items[i + 1];\n\n  SetLength(q.items, Length(q.items) - 1);\n  Dequeue := resultValue;\nend;\n\nfunction IsEmpty(var q: TQueue): Boolean;\nbegin\n  IsEmpty := Length(q.items) = 0;\nend;\n\nvar\n  queue: TQueue;\n  dequeuedValue: Integer;\nbegin\n  InitializeQueue(queue);\n\n  Enqueue(queue, 10);\n  Enqueue(queue, 20);\n  Enqueue(queue, 30);\n\n  while not IsEmpty(queue) do\n  begin\n    dequeuedValue := Dequeue(queue);\n    WriteLn('Dequeued: ', dequeuedValue);\n  end;\nend.\n```"
  },
  {
    "task": "Generate a list of numbers and identify all prime numbers.",
    "code": "```pascal\nprogram PrimeNumbers;\n\nuses SysUtils;\n\nvar\n  numbers: array of Integer;\n  primes: array of Integer;\n  i, j, n: Integer;\n  isPrime: Boolean;\n\nbegin\n  n := 100; { Example: Generate numbers up to 100 }\n  SetLength(numbers, n);\n  SetLength(primes, 0);\n\n  for i := 0 to n - 1 do\n    numbers[i] := i + 1;\n\n  for i := 0 to High(numbers) do\n  begin\n    if numbers[i] < 2 then\n      Continue;\n    isPrime := True;\n    for j := 2 to Trunc(Sqrt(numbers[i])) do\n    begin\n      if numbers[i] mod j = 0 then\n      begin\n        isPrime := False;\n        Break;\n      end;\n    end;\n    if isPrime then\n    begin\n      SetLength(primes, Length(primes) + 1);\n      primes[High(primes)] := numbers[i];\n    end;\n  end;\n\n  WriteLn('Prime numbers:');\n  for i := 0 to High(primes) do\n    WriteLn(primes[i]);\nend.\n```"
  },
  {
    "task": "Create a list of strings and group them by their starting letter.",
    "code": "```pascal\nprogram GroupStringsByStartingLetter;\n\nuses SysUtils, Classes, Generics.Collections;\n\nvar\n  strings: TList<string>;\n  groupedStrings: TObjectDictionary<Char, TList<string>>;\n  str: string;\n  c: Char;\n  i: Integer;\nbegin\n  strings := TList<string>.Create;\n  groupedStrings := TObjectDictionary<Char, TList<string>>.Create([doOwnsValues]);\n\n  try\n    // Example strings added to the list\n    strings.Add('apple');\n    strings.Add('banana');\n    strings.Add('apricot');\n    strings.Add('blueberry');\n    strings.Add('cherry');\n    strings.Add('avocado');\n\n    // Group strings by their starting letter\n    for i := 0 to strings.Count - 1 do\n    begin\n      str := strings[i];\n      if str <> '' then\n      begin\n        c := str[1];\n        if not groupedStrings.TryGetValue(c, strings) then\n        begin\n          strings := TList<string>.Create;\n          groupedStrings.Add(c, strings);\n        end;\n        strings.Add(str);\n      end;\n    end;\n\n    // Output grouped strings (Example)\n    for c in groupedStrings.Keys do\n    begin\n      Write(c, ': ');\n      for str in groupedStrings[c] do\n        Write(str, ' ');\n      WriteLn;\n    end;\n  finally\n    strings.Free;\n    groupedStrings.Free;\n  end;\nend.\n```"
  },
  {
    "task": "Write a function that takes a list and returns a new list with all elements squared.",
    "code": "```pascal\nprogram SquareListElements;\n\ntype\n  TIntArray = array of Integer;\n\nfunction SquareList(inputList: TIntArray): TIntArray;\nvar\n  i: Integer;\nbegin\n  SetLength(Result, Length(inputList));\n  for i := 0 to High(inputList) do\n  begin\n    Result[i] := inputList[i] * inputList[i];\n  end;\nend;\n\nvar\n  originalList, squaredList: TIntArray;\n  i: Integer;\nbegin\n  originalList := TIntArray.Create(1, 2, 3, 4, 5);\n  squaredList := SquareList(originalList);\n\n  for i := 0 to High(squaredList) do\n  begin\n    WriteLn(squaredList[i]);\n  end;\nend.\n```"
  },
  {
    "task": "Generate a list of timestamps and find the time difference between consecutive elements.",
    "code": "```pascal\nprogram TimeDifference;\n\nuses\n  SysUtils, DateUtils;\n\nvar\n  Timestamps: array of TDateTime;\n  TimeDiffs: array of Integer;\n  i: Integer;\n  nowTime: TDateTime;\n\nbegin\n  SetLength(Timestamps, 5);\n  SetLength(TimeDiffs, 4);\n\n  for i := 0 to High(Timestamps) do\n  begin\n    nowTime := Now + i * OneMinute; // Simulating timestamps every minute\n    Timestamps[i] := nowTime;\n  end;\n\n  for i := 1 to High(Timestamps) do\n  begin\n    TimeDiffs[i - 1] := SecondsBetween(Timestamps[i], Timestamps[i - 1]);\n  end;\n\n  for i := 0 to High(TimeDiffs) do\n  begin\n    WriteLn('Time difference ', i + 1, ': ', TimeDiffs[i], ' seconds');\n  end;\nend.\n```"
  },
  {
    "task": "Create a list of numbers and rotate it such that the smallest number is first.",
    "code": "```pascal\nprogram RotateList;\n\nuses\n  SysUtils;\n\nvar\n  numbers: array of Integer;\n  i, minIndex, temp, n: Integer;\n\nbegin\n  // Initialize the list of numbers\n  numbers := [4, 2, 9, 1, 5, 6];\n  n := Length(numbers);\n\n  // Find the index of the smallest number\n  minIndex := 0;\n  for i := 1 to n - 1 do\n  begin\n    if numbers[i] < numbers[minIndex] then\n      minIndex := i;\n  end;\n\n  // Rotate the list so the smallest number is first\n  while minIndex > 0 do\n  begin\n    temp := numbers[0];\n    for i := 0 to n - 2 do\n      numbers[i] := numbers[i + 1];\n    numbers[n - 1] := temp;\n    Dec(minIndex);\n  end;\n\n  // Output the rotated list\n  for i := 0 to n - 1 do\n    Write(numbers[i], ' ');\n  WriteLn;\nend.\n```"
  },
  {
    "task": "Write a program to find all unique pairs in a list that sum up to a specific target.",
    "code": "```pascal\nprogram UniquePairsSum;\n\nuses\n  SysUtils;\n\ntype\n  TIntArray = array of Integer;\n\nprocedure FindPairs(arr: TIntArray; target: Integer);\nvar\n  i, j: Integer;\n  seenPairs: TStringList;\n  pairStr: String;\nbegin\n  seenPairs := TStringList.Create;\n  try\n    for i := 0 to High(arr) do\n      for j := i + 1 to High(arr) do\n      begin\n        if arr[i] + arr[j] = target then\n        begin\n          pairStr := Format('(%d, %d)', [arr[i], arr[j]]);\n          if seenPairs.IndexOf(pairStr) = -1 then\n          begin\n            seenPairs.Add(pairStr);\n            WriteLn(pairStr);\n          end;\n        end;\n      end;\n  finally\n    seenPairs.Free;\n  end;\nend;\n\nvar\n  numbers: TIntArray;\n  targetSum: Integer;\nbegin\n  numbers := TIntArray.Create(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n  targetSum := 10;\n\n  FindPairs(numbers, targetSum);\nend.\n```"
  },
  {
    "task": "Implement a function that returns true if a list contains a cycle.",
    "code": "```pascal\nprogram DetectCycle;\n\ntype\n  PNode = ^TNode;\n  TNode = record\n    Data: Integer;\n    Next: PNode;\n  end;\n\nfunction ContainsCycle(head: PNode): Boolean;\nvar\n  slow, fast: PNode;\nbegin\n  slow := head;\n  fast := head;\n  while (fast <> nil) and (fast^.Next <> nil) do\n  begin\n    slow := slow^.Next;\n    fast := fast^.Next^.Next;\n    if slow = fast then\n    begin\n      ContainsCycle := True;\n      Exit;\n    end;\n  end;\n  ContainsCycle := False;\nend;\n\nvar\n  head, node1, node2, node3: PNode;\n\nbegin\n  New(head);\n  New(node1);\n  New(node2);\n  New(node3);\n\n  head^.Data := 1;\n  head^.Next := node1;\n  node1^.Data := 2;\n  node1^.Next := node2;\n  node2^.Data := 3;\n  node2^.Next := node3;\n  node3^.Data := 4;\n  node3^.Next := node1; // Creates a cycle\n\n  if ContainsCycle(head) then\n    WriteLn('Cycle detected.')\n  else\n    WriteLn('No cycle detected.');\nend.\n```"
  },
  {
    "task": "Create a list of numbers and find the contiguous subarray with the maximum sum.",
    "code": "```pascal\nprogram MaxSubarraySum;\n\ntype\n  TIntArray = array of Integer;\n\nfunction MaxSubArraySum(arr: TIntArray): Integer;\nvar\n  maxSoFar, maxEndingHere, i: Integer;\nbegin\n  maxSoFar := arr[0];\n  maxEndingHere := arr[0];\n  \n  for i := 1 to High(arr) do\n  begin\n    if maxEndingHere + arr[i] > arr[i] then\n      maxEndingHere := maxEndingHere + arr[i]\n    else\n      maxEndingHere := arr[i];\n    \n    if maxEndingHere > maxSoFar then\n      maxSoFar := maxEndingHere;\n  end;\n  \n  Result := maxSoFar;\nend;\n\nvar\n  numbers: TIntArray;\n  maxSum: Integer;\nbegin\n  numbers := TIntArray.Create(-2, 1, -3, 4, -1, 2, 1, -5, 4);\n  maxSum := MaxSubArraySum(numbers);\n  WriteLn('Maximum contiguous subarray sum is: ', maxSum);\nend.\n```"
  },
  {
    "task": "Write a function that takes a list and a number, and finds two numbers in the list that sum to the given number.",
    "code": "```pascal\nprogram FindTwoSum;\n\nuses\n  SysUtils;\n\ntype\n  TIntArray = array of Integer;\n\nfunction FindTwoNumbersWithSum(const numbers: TIntArray; target: Integer): TStringArray;\nvar\n  i, j: Integer;\nbegin\n  SetLength(Result, 0);\n  for i := 0 to High(numbers) do\n    for j := i + 1 to High(numbers) do\n      if (numbers[i] + numbers[j] = target) then\n      begin\n        SetLength(Result, 2);\n        Result[0] := IntToStr(numbers[i]);\n        Result[1] := IntToStr(numbers[j]);\n        Exit;\n      end;\nend;\n\nbegin\nend.\n```"
  },
  {
    "task": "Generate a list of even numbers and filter out those that are greater than a specific value.",
    "code": "```pascal\nprogram FilterEvenNumbers;\n\nuses\n  SysUtils;\n\ntype\n  TIntArray = array of Integer;\n\nfunction GenerateEvenNumbers(UpperLimit: Integer): TIntArray;\nvar\n  i, Count: Integer;\nbegin\n  Count := 0;\n  SetLength(Result, UpperLimit div 2);\n  for i := 1 to UpperLimit do\n  begin\n    if i mod 2 = 0 then\n    begin\n      Result[Count] := i;\n      Inc(Count);\n    end;\n  end;\n  SetLength(Result, Count);\nend;\n\nfunction FilterGreaterThan(numbers: TIntArray; value: Integer): TIntArray;\nvar\n  i, Count: Integer;\nbegin\n  Count := 0;\n  SetLength(Result, Length(numbers));\n  for i := 0 to High(numbers) do\n  begin\n    if numbers[i] <= value then\n    begin\n      Result[Count] := numbers[i];\n      Inc(Count);\n    end;\n  end;\n  SetLength(Result, Count);\nend;\n\nvar\n  evenNumbers, filteredNumbers: TIntArray;\n  upperLimit, filterValue: Integer;\nbegin\n  upperLimit := 20;\n  filterValue := 10;\n\n  evenNumbers := GenerateEvenNumbers(upperLimit);\n  filteredNumbers := FilterGreaterThan(evenNumbers, filterValue);\n\n  WriteLn('Filtered Even Numbers:');\n  for upperLimit := 0 to High(filteredNumbers) do\n    Write(filteredNumbers[upperLimit], ' ');\n\n  WriteLn;\nend.\n```"
  },
  {
    "task": "Create a list of characters and reverse the vowels only.",
    "code": "```pascal\nprogram ReverseVowelsInList;\n\nuses\n  SysUtils;\n\ntype\n  TCharList = array of Char;\n\nfunction IsVowel(ch: Char): Boolean;\nbegin\n  ch := UpCase(ch);\n  Result := (ch = 'A') or (ch = 'E') or (ch = 'I') or (ch = 'O') or (ch = 'U');\nend;\n\nprocedure ReverseVowels(var charList: TCharList);\nvar\n  i, j: Integer;\n  temp: Char;\nbegin\n  i := 0;\n  j := High(charList);\n\n  while i < j do\n  begin\n    while (i < j) and not IsVowel(charList[i]) do\n      Inc(i);\n\n    while (i < j) and not IsVowel(charList[j]) do\n      Dec(j);\n\n    if i < j then\n    begin\n      temp := charList[i];\n      charList[i] := charList[j];\n      charList[j] := temp;\n      Inc(i);\n      Dec(j);\n    end;\n  end;\nend;\n\nvar\n  charList: TCharList;\n  i: Integer;\nbegin\n  charList := ['h', 'e', 'l', 'l', 'o', 'w', 'o', 'r', 'l', 'd'];\n  ReverseVowels(charList);\n\n  for i := 0 to High(charList) do\n    Write(charList[i]);\n  Writeln;\nend.\n```"
  },
  {
    "task": "Write a program to find all permutations of a list of elements.",
    "code": "```pascal\nprogram Permutations;\n\ntype\n  TList = array of Integer;\n\nprocedure Swap(var A, B: Integer);\nvar\n  Temp: Integer;\nbegin\n  Temp := A;\n  A := B;\n  B := Temp;\nend;\n\nprocedure GeneratePermutations(var List: TList; L, R: Integer);\nvar\n  I: Integer;\nbegin\n  if L = R then\n  begin\n    for I := 0 to High(List) do\n      Write(List[I], ' ');\n    Writeln;\n  end\n  else\n  begin\n    for I := L to R do\n    begin\n      Swap(List[L], List[I]);\n      GeneratePermutations(List, L + 1, R);\n      Swap(List[L], List[I]);\n    end;\n  end;\nend;\n\nvar\n  List: TList;\n  N, I: Integer;\nbegin\n  Write('Enter the number of elements: ');\n  Readln(N);\n  SetLength(List, N);\n  Write('Enter the elements: ');\n  for I := 0 to N - 1 do\n    Read(List[I]);\n  Writeln('Permutations:');\n  GeneratePermutations(List, 0, N - 1);\nend.\n```"
  },
  {
    "task": "Implement a function that takes a list and returns the most frequently occurring element.",
    "code": "```pascal\nprogram MostFrequentElement;\n\ntype\n  IntArray = array of Integer;\n\nfunction MostFrequent(arr: IntArray): Integer;\nvar\n  counts: array of Integer;\n  i, j, maxCount, mostFrequentElement: Integer;\nbegin\n  SetLength(counts, Length(arr));\n  for i := 0 to High(arr) do\n  begin\n    counts[i] := 0;\n    for j := 0 to High(arr) do\n    begin\n      if arr[i] = arr[j] then\n        Inc(counts[i]);\n    end;\n  end;\n\n  maxCount := 0;\n  mostFrequentElement := arr[0];\n  for i := 0 to High(arr) do\n  begin\n    if counts[i] > maxCount then\n    begin\n      maxCount := counts[i];\n      mostFrequentElement := arr[i];\n    end;\n  end;\n\n  Result := mostFrequentElement;\nend;\n\nvar\n  myList: IntArray;\n  result: Integer;\nbegin\n  myList := IntArray.Create(1, 3, 2, 1, 4, 1, 5, 3, 3);\n  result := MostFrequent(myList);\n  WriteLn('Most frequent element: ', result);\nend.\n```"
  },
  {
    "task": "Create a list of numbers and calculate the variance.",
    "code": "```pascal\nprogram VarianceCalculation;\nuses SysUtils;\n\ntype\n  TNumberList = array of Real;\n\nfunction CalculateVariance(numbers: TNumberList): Real;\nvar\n  sum, mean, sumOfSquares: Real;\n  i, n: Integer;\nbegin\n  n := Length(numbers);\n  if n = 0 then\n    Exit(0);\n\n  sum := 0.0;\n  for i := 0 to n - 1 do\n    sum := sum + numbers[i];\n\n  mean := sum / n;\n\n  sumOfSquares := 0.0;\n  for i := 0 to n - 1 do\n    sumOfSquares := sumOfSquares + Sqr(numbers[i] - mean);\n\n  Result := sumOfSquares / n;\nend;\n\nvar\n  numbers: TNumberList;\n  variance: Real;\nbegin\n  numbers := TNumberList.Create(1.0, 2.0, 3.0, 4.0, 5.0);\n  variance := CalculateVariance(numbers);\n  WriteLn('Variance: ', FormatFloat('0.00', variance));\nend.\n```"
  },
  {
    "task": "Write a function to concatenate a list of lists into a single list.",
    "code": "```pascal\nprogram ConcatenateLists;\n\ntype\n  TIntArray = array of Integer;\n  TListOfIntArrays = array of TIntArray;\n\nfunction Concatenate(Lists: TListOfIntArrays): TIntArray;\nvar\n  i, j, k, TotalLength: Integer;\nbegin\n  TotalLength := 0;\n  \n  for i := 0 to High(Lists) do\n    TotalLength := TotalLength + Length(Lists[i]);\n  \n  SetLength(Result, TotalLength);\n  \n  k := 0;\n  for i := 0 to High(Lists) do\n    for j := 0 to High(Lists[i]) do\n    begin\n      Result[k] := Lists[i][j];\n      Inc(k);\n    end;\nend;\n\nvar\n  ListOfLists: TListOfIntArrays;\n  ConcatenatedList: TIntArray;\n  i: Integer;\nbegin\n  SetLength(ListOfLists, 2);\n  SetLength(ListOfLists[0], 3);\n  SetLength(ListOfLists[1], 2);\n\n  ListOfLists[0][0] := 1;\n  ListOfLists[0][1] := 2;\n  ListOfLists[0][2] := 3;\n  ListOfLists[1][0] := 4;\n  ListOfLists[1][1] := 5;\n\n  ConcatenatedList := Concatenate(ListOfLists);\n\n  for i := 0 to High(ConcatenatedList) do\n    WriteLn(ConcatenatedList[i]);\nend.\n```"
  },
  {
    "task": "Generate a list of numbers and replace each element with the product of all other elements.",
    "code": "```pascal\nprogram ProductOfOthers;\n\nvar\n  numbers, productList: array of Integer;\n  totalProduct, i: Integer;\n\nbegin\n  numbers := [1, 2, 3, 4, 5];  { Example list of numbers }\n  SetLength(productList, Length(numbers));\n  \n  totalProduct := 1;\n  for i := 0 to High(numbers) do\n    totalProduct := totalProduct * numbers[i];\n  \n  for i := 0 to High(numbers) do\n    productList[i] := totalProduct div numbers[i];\n    \n  for i := 0 to High(productList) do\n    WriteLn(productList[i]);\nend.\n```"
  },
  {
    "task": "Create a list of strings and find the common prefix.",
    "code": "```pascal\nprogram CommonPrefix;\n\nuses\n  SysUtils;\n\nfunction FindCommonPrefix(strings: array of string): string;\nvar\n  i, j, minLength: integer;\n  prefix: string;\nbegin\n  if Length(strings) = 0 then\n  begin\n    Result := '';\n    Exit;\n  end;\n\n  prefix := strings[0];\n  minLength := Length(prefix);\n\n  for i := 1 to High(strings) do\n  begin\n    if Length(strings[i]) < minLength then\n      minLength := Length(strings[i]);\n  end;\n\n  for i := 1 to minLength do\n  begin\n    for j := 1 to High(strings) do\n    begin\n      if strings[j][i] <> prefix[i] then\n      begin\n        Result := Copy(prefix, 1, i - 1);\n        Exit;\n      end;\n    end;\n  end;\n\n  Result := Copy(prefix, 1, minLength);\nend;\n\nvar\n  stringList: array[0..2] of string = ('flower', 'flow', 'flight');\n  commonPrefix: string;\nbegin\n  commonPrefix := FindCommonPrefix(stringList);\n  Writeln('Common prefix: ', commonPrefix);\nend.\n```"
  },
  {
    "task": "Write a program to partition a list into two lists based on a predicate function.",
    "code": "```pascal\nprogram PartitionList;\n\ntype\n  TIntArray = array of Integer;\n\nfunction IsEven(num: Integer): Boolean;\nbegin\n  IsEven := (num mod 2 = 0);\nend;\n\nprocedure PartitionList(const source: TIntArray; out evens, odds: TIntArray);\nvar\n  i, eCount, oCount: Integer;\nbegin\n  eCount := 0;\n  oCount := 0;\n  \n  // Calculate sizes for evens and odds\n  for i := 0 to High(source) do\n  begin\n    if IsEven(source[i]) then\n      Inc(eCount)\n    else\n      Inc(oCount);\n  end;\n\n  // Set lengths for evens and odds\n  SetLength(evens, eCount);\n  SetLength(odds, oCount);\n\n  // Reset counters\n  eCount := 0;\n  oCount := 0;\n\n  // Partition the source list\n  for i := 0 to High(source) do\n  begin\n    if IsEven(source[i]) then\n    begin\n      evens[eCount] := source[i];\n      Inc(eCount);\n    end\n    else\n    begin\n      odds[oCount] := source[i];\n      Inc(oCount);\n    end;\n  end;\nend;\n\nvar\n  source, evens, odds: TIntArray;\n  i: Integer;\nbegin\n  // Example input list\n  source := TIntArray.Create(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n\n  // Partition the list\n  PartitionList(source, evens, odds);\n\n  // Output the results\n  Write('Evens: ');\n  for i := 0 to High(evens) do\n    Write(evens[i], ' ');\n  Writeln;\n\n  Write('Odds: ');\n  for i := 0 to High(odds) do\n    Write(odds[i], ' ');\n  Writeln;\nend.\n```"
  },
  {
    "task": "Implement a function to find the kth smallest element in a list.",
    "code": "```pascal\nprogram FindKthSmallest;\n\ntype\n  TIntList = array of Integer;\n\nprocedure Swap(var a, b: Integer);\nvar\n  temp: Integer;\nbegin\n  temp := a;\n  a := b;\n  b := temp;\nend;\n\nfunction Partition(var arr: TIntList; low, high: Integer): Integer;\nvar\n  pivot, i, j: Integer;\nbegin\n  pivot := arr[high];\n  i := low - 1;\n  for j := low to high - 1 do\n  begin\n    if arr[j] < pivot then\n    begin\n      Inc(i);\n      Swap(arr[i], arr[j]);\n    end;\n  end;\n  Swap(arr[i + 1], arr[high]);\n  Partition := i + 1;\nend;\n\nfunction QuickSelect(var arr: TIntList; low, high, k: Integer): Integer;\nvar\n  pi: Integer;\nbegin\n  if (low <= high) then\n  begin\n    pi := Partition(arr, low, high);\n    if pi = k then\n      QuickSelect := arr[pi]\n    else if pi > k then\n      QuickSelect := QuickSelect(arr, low, pi - 1, k)\n    else\n      QuickSelect := QuickSelect(arr, pi + 1, high, k);\n  end;\nend;\n\nfunction FindKthSmallest(var arr: TIntList; k: Integer): Integer;\nbegin\n  FindKthSmallest := QuickSelect(arr, 0, High(arr), k - 1);\nend;\n\nvar\n  list: TIntList;\n  k, result: Integer;\nbegin\n  list := TIntList.Create(7, 10, 4, 3, 20, 15);\n  k := 3;\n  result := FindKthSmallest(list, k);\n  WriteLn('The ', k, 'th smallest element is: ', result);\nend.\n```"
  },
  {
    "task": "Create a list of integers and find the length of the longest contiguous sequence.",
    "code": "```pascal\nprogram LongestContiguousSequence;\n\nuses\n  sysutils;\n\nvar\n  List: array of Integer;\n  i, CurrentLength, MaxLength: Integer;\n\nbegin\n  List := [1, 2, 2, 3, 4, 5, 1, 2, 3, 4, 4, 4, 5]; // Example list\n  CurrentLength := 1;\n  MaxLength := 1;\n\n  for i := 1 to High(List) do\n  begin\n    if List[i] = List[i - 1] + 1 then\n      Inc(CurrentLength)\n    else\n      CurrentLength := 1;\n\n    if CurrentLength > MaxLength then\n      MaxLength := CurrentLength;\n  end;\n\n  WriteLn('Length of the longest contiguous sequence: ', MaxLength);\nend.\n```"
  },
  {
    "task": "Write a function that rotates elements in a list while maintaining the relative order of non-rotated elements.",
    "code": "```pascal\nprogram RotateList;\n\ntype\n  TIntArray = array of Integer;\n\nfunction RotateElements(arr: TIntArray; n: Integer): TIntArray;\nvar\n  i, len, newIndex: Integer;\n  resultArr: TIntArray;\nbegin\n  len := Length(arr);\n  SetLength(resultArr, len);\n  \n  for i := 0 to len - 1 do\n  begin\n    newIndex := (i + n) mod len;\n    resultArr[newIndex] := arr[i];\n  end;\n  \n  RotateElements := resultArr;\nend;\n\nvar\n  originalArray, rotatedArray: TIntArray;\n  i: Integer;\nbegin\n  originalArray := TIntArray.Create(1, 2, 3, 4, 5);\n  rotatedArray := RotateElements(originalArray, 2);\n  \n  for i := 0 to High(rotatedArray) do\n    Write(rotatedArray[i], ' ');\nend.\n```"
  },
  {
    "task": "Generate a list of random numbers and sort them while maintaining the original index positions.",
    "code": "```pascal\nprogram SortRandomList;\n\nuses\n  SysUtils, Classes;\n\ntype\n  TIndexedNumber = record\n    Number: Integer;\n    Index: Integer;\n  end;\n\nvar\n  RandomList: array of TIndexedNumber;\n  SortedList: TStringList;\n  i, n: Integer;\n\nfunction CompareNumbers(List: TStringList; Index1, Index2: Integer): Integer;\nvar\n  Num1, Num2: TIndexedNumber;\nbegin\n  Num1 := TIndexedNumber(List.Objects[Index1]);\n  Num2 := TIndexedNumber(List.Objects[Index2]);\n  Result := Num1.Number - Num2.Number;\nend;\n\nbegin\n  Randomize;\n  n := 10; // Number of random numbers\n  SetLength(RandomList, n);\n\n  for i := 0 to n - 1 do\n  begin\n    RandomList[i].Number := Random(100);\n    RandomList[i].Index := i;\n  end;\n\n  SortedList := TStringList.Create;\n  try\n    for i := 0 to n - 1 do\n      SortedList.AddObject('', TObject(@RandomList[i]));\n\n    SortedList.CustomSort(@CompareNumbers);\n\n    for i := 0 to SortedList.Count - 1 do\n    begin\n      with TIndexedNumber(SortedList.Objects[i]^) do\n        WriteLn('Index: ', Index, ' Number: ', Number);\n    end;\n  finally\n    SortedList.Free;\n  end;\nend.\n```"
  },
  {
    "task": "Create a list of numbers and find all subsets that sum up to a specific target.",
    "code": "```pascal\nprogram SubsetSum;\n\nuses SysUtils;\n\ntype\n  TIntArray = array of Integer;\n\nvar\n  numbers: TIntArray;\n  target: Integer;\n\nprocedure FindSubsets(current: TIntArray; index, currentSum: Integer);\nvar\n  i: Integer;\n  newSubset: TIntArray;\nbegin\n  if currentSum = target then\n  begin\n    Write('Subset: ');\n    for i := 0 to High(current) do\n      Write(current[i], ' ');\n    Writeln;\n    Exit;\n  end;\n\n  if index >= Length(numbers) then\n    Exit;\n\n  FindSubsets(current, index + 1, currentSum);\n\n  SetLength(newSubset, Length(current) + 1);\n  for i := 0 to High(current) do\n    newSubset[i] := current[i];\n  newSubset[High(newSubset)] := numbers[index];\n\n  FindSubsets(newSubset, index + 1, currentSum + numbers[index]);\nend;\n\nbegin\n  numbers := TIntArray.Create(1, 2, 3, 4, 5);\n  target := 5;\n  FindSubsets([], 0, 0);\nend.\n```"
  },
  {
    "task": "Write a program to simulate a stack using a list.",
    "code": "```pascal\nprogram StackSimulation;\n\nuses\n  SysUtils, Classes;\n\ntype\n  TStack = class\n  private\n    FList: TList;\n  public\n    constructor Create;\n    destructor Destroy; override;\n    procedure Push(AValue: Integer);\n    function Pop: Integer;\n    function IsEmpty: Boolean;\n  end;\n\nconstructor TStack.Create;\nbegin\n  FList := TList.Create;\nend;\n\ndestructor TStack.Destroy;\nbegin\n  FList.Free;\n  inherited Destroy;\nend;\n\nprocedure TStack.Push(AValue: Integer);\nbegin\n  FList.Add(Pointer(AValue));\nend;\n\nfunction TStack.Pop: Integer;\nbegin\n  if not IsEmpty then\n  begin\n    Result := Integer(FList.Last);\n    FList.Delete(FList.Count - 1);\n  end\n  else\n    raise Exception.Create('Stack is empty');\nend;\n\nfunction TStack.IsEmpty: Boolean;\nbegin\n  Result := FList.Count = 0;\nend;\n\nvar\n  Stack: TStack;\nbegin\n  Stack := TStack.Create;\n  try\n    Stack.Push(10);\n    Stack.Push(20);\n    Writeln(Stack.Pop); // Outputs: 20\n    Writeln(Stack.Pop); // Outputs: 10\n  finally\n    Stack.Free;\n  end;\nend.\n```"
  }
]