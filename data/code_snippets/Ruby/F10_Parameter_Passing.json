[
  {
    "task": "Create a function that modifies the first element of an array passed to it. Explain how the changes are reflected in the original array.",
    "code": "```ruby\ndef modify_first_element(array)\n  array[0] = 'modified'\nend\n\noriginal_array = [1, 2, 3, 4]\nmodify_first_element(original_array)\nputs original_array.inspect\n```"
  },
  {
    "task": "Design a function that swaps the values of two variables using pass-by-reference. Demonstrate how the swap affects the original variables.",
    "code": "```ruby\ndef swap_values!(a, b)\n  a.replace(b).replace(a)\nend\n\nfirst_var = \"hello\"\nsecond_var = \"world\"\n\nputs \"Before swap: first_var = #{first_var}, second_var = #{second_var}\"\nswap_values!(first_var, second_var)\nputs \"After swap: first_var = #{first_var}, second_var = #{second_var}\"\n```"
  },
  {
    "task": "Write a program that passes a large data structure to a function by value and by reference. Compare the performance and memory usage for both approaches.",
    "code": "```ruby\nrequire 'benchmark'\nrequire 'objspace'\n\n# Create a large data structure\nlarge_data = Array.new(10_000_000) { rand }\n\n# Function that takes an argument by value\ndef process_by_value(data)\n  data.map { |x| x * 2 }\nend\n\n# Function that takes an argument by reference\ndef process_by_reference(data)\n  data.map! { |x| x * 2 }\nend\n\n# Measure performance and memory usage for passing by value\nvalue_time = Benchmark.realtime do\n  process_by_value(large_data.dup)\nend\nvalue_memory = ObjectSpace.memsize_of(large_data.dup)\n\n# Measure performance and memory usage for passing by reference\nreference_time = Benchmark.realtime do\n  process_by_reference(large_data)\nend\nreference_memory = ObjectSpace.memsize_of(large_data)\n\nputs \"Passing by Value: Time = #{value_time} seconds, Memory Usage = #{value_memory} bytes\"\nputs \"Passing by Reference: Time = #{reference_time} seconds, Memory Usage = #{reference_memory} bytes\"\n```"
  },
  {
    "task": "Implement a function that accepts an integer and doubles its value. Show the difference in the original variable when using pass-by-value versus pass-by-reference.",
    "code": "```ruby\ndef double_value(x)\n  x * 2\nend\n\ndef double_value_in_place(x)\n  x.replace(x * 2)\nend\n\noriginal_value = 10\n\n# Pass-by-value\nnew_value = double_value(original_value)\nputs \"Original value after pass-by-value: #{original_value}\"\nputs \"New value after pass-by-value: #{new_value}\"\n\n# Pass-by-reference\noriginal_value_ref = [10]\ndouble_value_in_place(original_value_ref)\nputs \"Original value after pass-by-reference: #{original_value_ref[0]}\"\n```"
  },
  {
    "task": "Create a function that takes a list and returns a new list with elements doubled. Ensure the original list remains unchanged.",
    "code": "```ruby\ndef double_elements(original_list)\n  original_list.map { |element| element * 2 }\nend\n```"
  },
  {
    "task": "Design a function that takes a string argument and appends a character to it. Illustrate the result when the string is passed by value.",
    "code": "```ruby\ndef append_character(original_string, char_to_append)\n  new_string = original_string + char_to_append\n  new_string\nend\n\noriginal = \"Hello\"\nresult = append_character(original, \"!\")\nputs \"Original: #{original}\"  # Outputs: Original: Hello\nputs \"Result: #{result}\"      # Outputs: Result: Hello!\n```"
  },
  {
    "task": "Write a function that increments a counter variable. Pass the variable by reference to see changes in the original variable.",
    "code": "```ruby\ndef increment(counter)\n  counter[0] += 1\nend\n\ncounter = [0]\nincrement(counter)\nputs counter[0]\n```"
  },
  {
    "task": "Develop a function that removes an item from a dictionary passed to it. Demonstrate how pass-by-reference affects the original dictionary.",
    "code": "```ruby\ndef remove_item(dictionary, key)\n  dictionary.delete(key)\nend\n\n# Example usage\nmy_dict = { a: 1, b: 2, c: 3 }\nremove_item(my_dict, :b)\n\nputs my_dict\n```"
  },
  {
    "task": "Create a program that passes a matrix to a function, which transposes it. Explain how the transposition affects the original matrix with pass-by-reference.",
    "code": "```ruby\ndef transpose_matrix!(matrix)\n  matrix.replace(matrix.transpose)\nend\n\noriginal_matrix = [\n  [1, 2, 3],\n  [4, 5, 6],\n  [7, 8, 9]\n]\n\ntranspose_matrix!(original_matrix)\nputs original_matrix.inspect\n```"
  },
  {
    "task": "Implement a function that takes a float number and rounds it. Discuss the implications of passing the number by value.",
    "code": "```ruby\ndef round_number(number)\n  number.round\nend\n```"
  },
  {
    "task": "Design a function that accepts a dictionary and adds a key-value pair to it. Show the changes when the dictionary is passed by reference.",
    "code": "```ruby\ndef add_key_value_pair(hash)\n  hash[:new_key] = 'new_value'\nend\n\nmy_hash = { existing_key: 'existing_value' }\nputs \"Before: #{my_hash}\"\n\nadd_key_value_pair(my_hash)\nputs \"After: #{my_hash}\"\n```"
  },
  {
    "task": "Write a program that passes a string to a function that converts it to uppercase. Explain how this affects the original string with pass-by-value.",
    "code": "```ruby\ndef to_uppercase(str)\n  str.upcase\nend\n\noriginal_string = \"hello\"\nuppercase_string = to_uppercase(original_string)\n\nputs \"Original String: #{original_string}\"\nputs \"Uppercase String: #{uppercase_string}\"\n```"
  },
  {
    "task": "Create a function that receives a tuple and attempts to modify one of its elements. Discuss the outcome of using pass-by-value.",
    "code": "```ruby\ndef modify_tuple_element(tuple)\n  begin\n    tuple[0] = \"new_value\"\n  rescue => e\n    puts \"Error: #{e.message}\"\n  end\nend\n\noriginal_tuple = [\"original_value\", 2, 3]\nputs \"Before modification: #{original_tuple}\"\nmodify_tuple_element(original_tuple)\nputs \"After modification: #{original_tuple}\"\n```"
  },
  {
    "task": "Develop a function that accepts an object and modifies one of its attributes. Illustrate how pass-by-reference alters the original object.",
    "code": "```ruby\nclass MyObject\n  attr_accessor :attribute\n\n  def initialize(attribute)\n    @attribute = attribute\n  end\nend\n\ndef modify_object(obj)\n  obj.attribute = \"Modified\"\nend\n\nmy_obj = MyObject.new(\"Original\")\nputs \"Before modification: #{my_obj.attribute}\"\n\nmodify_object(my_obj)\nputs \"After modification: #{my_obj.attribute}\"\n```"
  },
  {
    "task": "Design a function that outputs the sum of all elements in an array passed by value. Confirm the original array remains unchanged.",
    "code": "```ruby\ndef sum_array(arr)\n  arr_copy = arr.dup\n  arr_copy.reduce(0, :+)\nend\n\noriginal_array = [1, 2, 3, 4, 5]\nsum = sum_array(original_array)\nputs \"Sum: #{sum}\"\nputs \"Original Array: #{original_array.inspect}\"\n```"
  },
  {
    "task": "Write a function that takes a boolean flag and toggles its value. Demonstrate the effect of pass-by-reference on the original flag.",
    "code": "```ruby\ndef toggle_flag(flag)\n  flag[0] = !flag[0]\nend\n\nflag = [true]\nputs \"Original flag: #{flag[0]}\"\ntoggle_flag(flag)\nputs \"Toggled flag: #{flag[0]}\"\n```"
  },
  {
    "task": "Create a function that takes an object and clones it. Modify the clone and show that the original object remains unaffected.",
    "code": "```ruby\ndef clone_and_modify(original_object)\n  cloned_object = original_object.clone\n  # Modify the cloned object in some way, for example:\n  if cloned_object.is_a?(Hash)\n    cloned_object[:modified] = true\n  elsif cloned_object.is_a?(Array)\n    cloned_object << 'modified'\n  elsif cloned_object.respond_to?(:to_s)\n    cloned_object = cloned_object.to_s + ' modified'\n  end\n  [original_object, cloned_object]\nend\n\n# Example usage\noriginal_hash = { key: 'value' }\noriginal_array = [1, 2, 3]\noriginal_string = 'example'\n\noriginal, modified = clone_and_modify(original_hash)\nputs \"Original: #{original}, Modified: #{modified}\"\n\noriginal, modified = clone_and_modify(original_array)\nputs \"Original: #{original}, Modified: #{modified}\"\n\noriginal, modified = clone_and_modify(original_string)\nputs \"Original: #{original}, Modified: #{modified}\"\n```"
  },
  {
    "task": "Implement a function that accepts a list of integers and removes all even numbers. Describe the difference in behavior when using pass-by-value and pass-by-reference.",
    "code": "```ruby\ndef remove_even_numbers(numbers)\n  numbers.reject!(&:even?)\nend\n\nnumbers_list = [1, 2, 3, 4, 5, 6]\nremove_even_numbers(numbers_list)\nputs numbers_list.inspect  # This will output [1, 3, 5]\n```"
  },
  {
    "task": "Develop a function that takes a complex number and returns its conjugate. Explain how pass-by-value affects the original complex number.",
    "code": "```ruby\ndef complex_conjugate(complex_number)\n  Complex(complex_number.real, -complex_number.imaginary)\nend\n\noriginal_number = Complex(3, 4)\nconjugate_number = complex_conjugate(original_number)\n\nputs \"Original: #{original_number}\"\nputs \"Conjugate: #{conjugate_number}\"\n```"
  },
  {
    "task": "Design a program where a function receives a binary tree and inverts it. Discuss how pass-by-reference impacts the original tree structure.",
    "code": "```ruby\nclass TreeNode\n  attr_accessor :val, :left, :right\n\n  def initialize(val = 0, left = nil, right = nil)\n    @val = val\n    @left = left\n    @right = right\n  end\nend\n\ndef invert_tree(node)\n  return if node.nil?\n\n  node.left, node.right = node.right, node.left\n  invert_tree(node.left)\n  invert_tree(node.right)\nend\n\n# Example usage:\n# root = TreeNode.new(4)\n# root.left = TreeNode.new(2)\n# root.right = TreeNode.new(7)\n# invert_tree(root)\n```"
  },
  {
    "task": "Write a function that adds an element to a set passed to it. Show how pass-by-reference affects the original set.",
    "code": "```ruby\ndef add_to_set(original_set, element)\n  original_set.add(element)\nend\n\nmy_set = Set.new([1, 2, 3])\nadd_to_set(my_set, 4)\n\nputs my_set.inspect\n```"
  },
  {
    "task": "Create a function that accepts an integer array and sorts it. Demonstrate the difference when the array is passed by value.",
    "code": "```ruby\ndef sort_array(arr)\n  arr.sort\nend\n\ndef demonstrate_parameter_passing(arr)\n  sorted_array = sort_array(arr)\n  puts \"Original array: #{arr.inspect}\"\n  puts \"Sorted array: #{sorted_array.inspect}\"\nend\n\narray = [5, 3, 8, 1, 2]\ndemonstrate_parameter_passing(array)\n```"
  },
  {
    "task": "Implement a function that takes a configuration object and toggles a setting. Illustrate the changes with pass-by-reference.",
    "code": "```ruby\ndef toggle_setting(config, setting_key)\n  if config.key?(setting_key)\n    config[setting_key] = !config[setting_key]\n  else\n    config[setting_key] = true\n  end\nend\n\n# Example usage\nconfig = { 'setting1' => true, 'setting2' => false }\ntoggle_setting(config, 'setting1')\nputs config # Output: {\"setting1\"=>false, \"setting2\"=>false}\n\ntoggle_setting(config, 'setting3')\nputs config # Output: {\"setting1\"=>false, \"setting2\"=>false, \"setting3\"=>true}\n```"
  },
  {
    "task": "Design a function that receives a file path and reads its content. Explain how passing the path by value affects the outcome.",
    "code": "```ruby\ndef read_file_content(file_path)\n  begin\n    content = File.read(file_path)\n    puts content\n  rescue Errno::ENOENT\n    puts \"File not found.\"\n  end\nend\n\n# Example usage\nread_file_content(\"example.txt\")\n```"
  },
  {
    "task": "Write a program in which a function takes a stack and reverses its elements. Discuss the impact of pass-by-reference on the stack.",
    "code": "```ruby\ndef reverse_stack(stack)\n  reversed_stack = []\n  until stack.empty?\n    reversed_stack.push(stack.pop)\n  end\n  stack.push(*reversed_stack)\nend\n\nstack = [1, 2, 3, 4, 5]\nreverse_stack(stack)\nputs stack.inspect\n```"
  },
  {
    "task": "Create a function that takes a queue and dequeues an element. Show the result when the queue is passed by reference.",
    "code": "```ruby\nrequire 'thread'\n\ndef dequeue_element(queue)\n  queue.pop(true) rescue nil\nend\n\n# Example usage:\nqueue = Queue.new\nqueue << 1 << 2 << 3\n\ndequeue_element(queue)\nputs queue.inspect  # Output the queue after dequeueing an element\n```"
  },
  {
    "task": "Develop a function that accepts a hashmap and updates a value for a specific key. Illustrate the effects of pass-by-reference.",
    "code": "```ruby\ndef update_value(hash, key, new_value)\n  hash[key] = new_value\nend\n\nmy_hash = { a: 1, b: 2, c: 3 }\nputs \"Before: #{my_hash}\"\n\nupdate_value(my_hash, :b, 42)\nputs \"After: #{my_hash}\"\n```"
  },
  {
    "task": "Design a function that receives a JSON object and adds a new property. Discuss the implications of modifying the object by reference.",
    "code": "```ruby\nrequire 'json'\n\ndef add_property(json_object, key, value)\n  json_object[key] = value\nend\n\n# Example usage:\njson_string = '{\"name\": \"Alice\", \"age\": 30}'\njson_object = JSON.parse(json_string)\n\nadd_property(json_object, \"city\", \"New York\")\n\nputs JSON.pretty_generate(json_object)\n```"
  },
  {
    "task": "Write a program where a function accepts a graph and adds a node. Explain how pass-by-reference affects the original graph structure.",
    "code": "```ruby\nclass Graph\n  attr_accessor :nodes\n\n  def initialize\n    @nodes = []\n  end\nend\n\ndef add_node(graph, node)\n  graph.nodes << node\nend\n\n# Example usage\ngraph = Graph.new\nadd_node(graph, 'A')\nputs graph.nodes.inspect\n```"
  },
  {
    "task": "Create a function that accepts a set of coordinates and shifts them. Demonstrate how pass-by-value ensures the original set is unchanged.",
    "code": "```ruby\ndef shift_coordinates(coordinates, x_shift, y_shift)\n  shifted_coordinates = coordinates.dup\n  shifted_coordinates[:x] += x_shift\n  shifted_coordinates[:y] += y_shift\n  shifted_coordinates\nend\n\noriginal_coordinates = {x: 5, y: 10}\nnew_coordinates = shift_coordinates(original_coordinates, 3, 4)\n\nputs \"Original Coordinates: #{original_coordinates}\"\nputs \"New Coordinates: #{new_coordinates}\"\n```"
  },
  {
    "task": "Implement a function that takes a date object and sets it to the next day. Discuss the effects of pass-by-reference on the date object.",
    "code": "```ruby\nrequire 'date'\n\ndef set_to_next_day(date)\n  date.next_day\nend\n\n# Example usage:\ndate = Date.new(2023, 10, 25)\nnew_date = set_to_next_day(date)\nputs new_date\n```"
  },
  {
    "task": "Develop a function that receives a polynomial represented as a list of coefficients and differentiates it. Show how the original list remains unchanged with pass-by-value.",
    "code": "```ruby\ndef differentiate_polynomial(coefficients)\n  differentiated = coefficients.each_with_index.map do |coef, index|\n    coef * index if index > 0\n  end.compact\n  differentiated\nend\n\noriginal_polynomial = [3, 2, 1]\ndifferentiated_polynomial = differentiate_polynomial(original_polynomial)\n\nputs \"Original Polynomial: #{original_polynomial.inspect}\"\nputs \"Differentiated Polynomial: #{differentiated_polynomial.inspect}\"\n```"
  },
  {
    "task": "Design a function that accepts a stack and clears it. Explain how pass-by-reference affects the original stack.",
    "code": "```ruby\ndef clear_stack(stack)\n  stack.clear\nend\n\n# Example usage\nmy_stack = [1, 2, 3, 4, 5]\nclear_stack(my_stack)\nputs my_stack.inspect  # Output will be: []\n```"
  },
  {
    "task": "Write a function that takes a linked list and appends a new node. Demonstrate the impact of pass-by-reference on the list.",
    "code": "```ruby\nclass Node\n  attr_accessor :value, :next\n\n  def initialize(value)\n    @value = value\n    @next = nil\n  end\nend\n\nclass LinkedList\n  attr_accessor :head\n\n  def initialize\n    @head = nil\n  end\n\n  def append(value)\n    if @head.nil?\n      @head = Node.new(value)\n    else\n      current = @head\n      current = current.next while current.next\n      current.next = Node.new(value)\n    end\n  end\nend\n\ndef append_node(list, value)\n  list.append(value)\nend\n\n# Example usage\nlist = LinkedList.new\nlist.append(1)\nlist.append(2)\nappend_node(list, 3)\n\ncurrent_node = list.head\nwhile current_node\n  puts current_node.value\n  current_node = current_node.next\nend\n```"
  },
  {
    "task": "Create a function that receives a URL and extracts the domain name. Discuss the effects of pass-by-value on the URL string.",
    "code": "```ruby\ndef extract_domain_name(url)\n  domain = url.split('/')[2]\n  domain\nend\n\nurl = \"https://www.example.com/path\"\ndomain_name = extract_domain_name(url)\nputs \"URL: #{url}\"\nputs \"Domain Name: #{domain_name}\"\n```"
  },
  {
    "task": "Implement a function that takes a priority queue and changes the priority of an element. Illustrate the effects using pass-by-reference.",
    "code": "```ruby\nclass PriorityQueue\n  def initialize\n    @queue = []\n  end\n\n  def enqueue(element, priority)\n    @queue << { element: element, priority: priority }\n    @queue.sort_by! { |item| item[:priority] }\n  end\n\n  def change_priority(element, new_priority)\n    item = @queue.find { |item| item[:element] == element }\n    item[:priority] = new_priority if item\n    @queue.sort_by! { |item| item[:priority] }\n  end\n\n  def display\n    @queue.each { |item| puts \"#{item[:element]}: #{item[:priority]}\" }\n  end\nend\n\ndef change_element_priority(pq, element, new_priority)\n  pq.change_priority(element, new_priority)\nend\n\n# Example usage:\npq = PriorityQueue.new\npq.enqueue('task1', 3)\npq.enqueue('task2', 1)\npq.enqueue('task3', 2)\n\nputs \"Before priority change:\"\npq.display\n\nchange_element_priority(pq, 'task3', 0)\n\nputs \"After priority change:\"\npq.display\n```"
  },
  {
    "task": "Develop a function that accepts a circular buffer and reads an element. Explain how pass-by-reference influences the buffer.",
    "code": "```ruby\nclass CircularBuffer\n  def initialize(size)\n    @buffer = Array.new(size)\n    @read_pointer = 0\n    @write_pointer = 0\n  end\n\n  def write(element)\n    @buffer[@write_pointer] = element\n    @write_pointer = (@write_pointer + 1) % @buffer.size\n  end\n\n  def read\n    element = @buffer[@read_pointer]\n    @buffer[@read_pointer] = nil\n    @read_pointer = (@read_pointer + 1) % @buffer.size\n    element\n  end\nend\n\ndef read_element_from_buffer(buffer)\n  buffer.read\nend\n\n# Example usage:\nbuffer = CircularBuffer.new(3)\nbuffer.write(10)\nbuffer.write(20)\nbuffer.write(30)\n\nelement = read_element_from_buffer(buffer)\nputs element # Outputs: 10\n```"
  },
  {
    "task": "Design a program where a function receives a record and updates a field. Show how pass-by-reference affects the original record.",
    "code": "```ruby\nclass Record\n  attr_accessor :field\n\n  def initialize(field)\n    @field = field\n  end\nend\n\ndef update_record(record, new_value)\n  record.field = new_value\nend\n\nrecord = Record.new(\"initial value\")\nputs \"Before update: #{record.field}\"\n\nupdate_record(record, \"updated value\")\nputs \"After update: #{record.field}\"\n```"
  },
  {
    "task": "Write a function that takes a frequency list and normalizes it. Describe how pass-by-value ensures the original list remains unchanged.",
    "code": "```ruby\ndef normalize_frequency(frequency_list)\n  total = frequency_list.sum.to_f\n  frequency_list.map { |frequency| frequency / total }\nend\n\noriginal_list = [10, 20, 30, 40]\nnormalized_list = normalize_frequency(original_list)\n\nputs \"Original list: #{original_list}\"\nputs \"Normalized list: #{normalized_list}\"\n```"
  },
  {
    "task": "Create a function that accepts a chessboard and makes a move. Discuss how pass-by-reference alters the original board setup.",
    "code": "```ruby\ndef make_move!(chessboard, from, to)\n  piece = chessboard[from[0]][from[1]]\n  chessboard[to[0]][to[1]] = piece\n  chessboard[from[0]][from[1]] = nil\nend\n\n# Example usage:\n# chessboard = Array.new(8) { Array.new(8) }\n# make_move!(chessboard, [1, 0], [3, 0])\n```"
  },
  {
    "task": "Implement a function that takes a decimal number and converts it to binary. Explain the effects of pass-by-value on the original number.",
    "code": "```ruby\ndef decimal_to_binary(decimal_number)\n  # Converting decimal to binary using to_s(2)\n  binary_number = decimal_number.to_s(2)\n  \n  # Printing the binary number\n  puts \"Binary representation: #{binary_number}\"\n  \n  # Demonstrating pass-by-value effect\n  decimal_number = 0  # Attempt to change the original number\n  puts \"Original number after change attempt: #{decimal_number}\"\nend\n\noriginal_number = 42\ndecimal_to_binary(original_number)\nputs \"Original number outside function: #{original_number}\"\n```"
  },
  {
    "task": "Develop a function that receives a DNA sequence and counts nucleotides. Illustrate how pass-by-value ensures the original sequence remains intact.",
    "code": "```ruby\ndef count_nucleotides(dna_sequence)\n  nucleotide_count = Hash.new(0)\n  dna_sequence.each_char do |nucleotide|\n    nucleotide_count[nucleotide] += 1\n  end\n  nucleotide_count\nend\n\ndef demonstrate_pass_by_value(dna_sequence)\n  original_sequence = dna_sequence.dup\n  count_nucleotides(dna_sequence)\n  original_sequence\nend\n\n# Example usage\ndna_sequence = \"ATCGATCGA\"\nputs \"Original sequence: #{dna_sequence}\"\nputs \"Nucleotide count: #{count_nucleotides(dna_sequence)}\"\nputs \"Sequence after function call: #{demonstrate_pass_by_value(dna_sequence)}\"\n```"
  },
  {
    "task": "Design a function that accepts a shopping cart object and applies a discount. Show the changes with pass-by-reference.",
    "code": "```ruby\nclass ShoppingCart\n  attr_accessor :total\n\n  def initialize(total)\n    @total = total\n  end\nend\n\ndef apply_discount(cart, discount_percentage)\n  discount_amount = cart.total * (discount_percentage / 100.0)\n  cart.total -= discount_amount\nend\n\n# Example usage\ncart = ShoppingCart.new(100)\napply_discount(cart, 10)\nputs cart.total  # Outputs: 90.0\n```"
  },
  {
    "task": "Write a program where a function receives a playlist and adds a song. Discuss how pass-by-reference affects the original playlist.",
    "code": "```ruby\ndef add_song_to_playlist(playlist, song)\n  playlist << song\nend\n\nplaylist = [\"Song A\", \"Song B\", \"Song C\"]\nadd_song_to_playlist(playlist, \"Song D\")\n\nputs playlist\n```"
  },
  {
    "task": "Create a function that takes a sprite in a game and moves it. Demonstrate the result when the sprite is passed by reference.",
    "code": "```ruby\nclass Sprite\n  attr_accessor :x, :y\n\n  def initialize(x, y)\n    @x = x\n    @y = y\n  end\nend\n\ndef move_sprite(sprite, dx, dy)\n  sprite.x += dx\n  sprite.y += dy\nend\n\nsprite = Sprite.new(10, 20)\nputs \"Before move: x=#{sprite.x}, y=#{sprite.y}\"\n\nmove_sprite(sprite, 5, -3)\nputs \"After move: x=#{sprite.x}, y=#{sprite.y}\"\n```"
  },
  {
    "task": "Implement a function that accepts a book object and updates the title. Illustrate the impact of pass-by-reference on the original object.",
    "code": "```ruby\nclass Book\n  attr_accessor :title\n\n  def initialize(title)\n    @title = title\n  end\nend\n\ndef update_title(book, new_title)\n  book.title = new_title\nend\n\n# Example Usage\nmy_book = Book.new(\"Original Title\")\nputs \"Before update: #{my_book.title}\"\n\nupdate_title(my_book, \"Updated Title\")\nputs \"After update: #{my_book.title}\"\n```"
  },
  {
    "task": "Develop a function that receives a sound wave and normalizes it. Explain how pass-by-value affects the original sound wave.",
    "code": "```ruby\ndef normalize_sound_wave(sound_wave)\n  max_amplitude = sound_wave.max\n  return sound_wave.map { |sample| sample / max_amplitude.to_f }\nend\n\n# Example usage:\noriginal_sound_wave = [0.2, 0.5, 0.7, 1.0]\nnormalized_wave = normalize_sound_wave(original_sound_wave)\n\nputs \"Original: #{original_sound_wave}\"\nputs \"Normalized: #{normalized_wave}\"\n```"
  },
  {
    "task": "Design a program where a function receives a bank account object and credits an amount. Discuss the effects of pass-by-reference.",
    "code": "```ruby\nclass BankAccount\n  attr_accessor :balance\n\n  def initialize(balance = 0)\n    @balance = balance\n  end\nend\n\ndef credit_account(account, amount)\n  account.balance += amount\nend\n\n# Example usage:\naccount = BankAccount.new(100)\ncredit_account(account, 50)\nputs account.balance # Output will be 150\n```"
  },
  {
    "task": "Write a function that takes an email list and filters out invalid addresses. Show the difference in the list when using pass-by-value.",
    "code": "```ruby\ndef filter_invalid_emails(email_list)\n  email_list.select { |email| email.match?(/\\A[^@\\s]+@([^@\\s]+\\.)+[^@\\s]+\\z/) }\nend\n\nemails = [\"valid@example.com\", \"invalid@\", \"another@valid.com\", \"bad@.com\"]\nfiltered_emails = filter_invalid_emails(emails.clone)\n\nputs \"Original list: #{emails}\"\nputs \"Filtered list: #{filtered_emails}\"\n```"
  },
  {
    "task": "Create a function that accepts a 3D model and scales it. Demonstrate how pass-by-reference affects the original model.",
    "code": "```ruby\nclass Model3D\n  attr_accessor :vertices\n\n  def initialize(vertices)\n    @vertices = vertices\n  end\nend\n\ndef scale_model(model, scale_factor)\n  model.vertices.map! do |vertex|\n    vertex.map { |coordinate| coordinate * scale_factor }\n  end\nend\n\n# Example usage\nmodel = Model3D.new([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nscale_model(model, 2)\n\nputs model.vertices.inspect\n```"
  },
  {
    "task": "Implement a function that receives a text document and redacts sensitive information. Explain the impact of pass-by-reference.",
    "code": "```ruby\ndef redact_sensitive_info!(document)\n  sensitive_words = [\"secret\", \"password\", \"confidential\"]\n  sensitive_words.each do |word|\n    document.gsub!(word, \"[REDACTED]\")\n  end\nend\n\ndoc = \"This is a secret document. Do not share your password. It's confidential.\"\nredact_sensitive_info!(doc)\nputs doc\n```"
  },
  {
    "task": "Develop a function that takes a temperature reading and adjusts for calibration. Discuss how pass-by-value ensures the original reading is unchanged.",
    "code": "```ruby\ndef adjust_for_calibration(temperature_reading)\n  calibration_factor = 1.05\n  adjusted_temperature = temperature_reading * calibration_factor\n  adjusted_temperature\nend\n\noriginal_reading = 100.0\nadjusted_reading = adjust_for_calibration(original_reading)\n\nputs \"Original Reading: #{original_reading}\"\nputs \"Adjusted Reading: #{adjusted_reading}\"\n```"
  },
  {
    "task": "Design a function that accepts a bug report and updates its status. Show the changes with pass-by-reference.",
    "code": "```ruby\nclass BugReport\n  attr_accessor :status\n\n  def initialize(status)\n    @status = status\n  end\nend\n\ndef update_status(bug_report, new_status)\n  bug_report.status = new_status\nend\n\n# Example usage\nreport = BugReport.new(\"open\")\nupdate_status(report, \"closed\")\nputs report.status  # Output: closed\n```"
  },
  {
    "task": "Write a program where a function receives a sensor array and calibrates it. Demonstrate the effect of pass-by-reference on the array.",
    "code": "```ruby\ndef calibrate(sensor_array)\n  sensor_array.map! { |value| value * 1.1 }\nend\n\nsensors = [100, 200, 300, 400, 500]\nputs \"Before calibration: #{sensors}\"\n\ncalibrate(sensors)\nputs \"After calibration: #{sensors}\"\n```"
  },
  {
    "task": "Create a function that takes a vector and rotates it. Explain how pass-by-value ensures the original vector remains unchanged.",
    "code": "```ruby\ndef rotate_vector(vector)\n  rotated_vector = vector.dup\n  rotated_vector.push(rotated_vector.shift)\n  rotated_vector\nend\n\noriginal_vector = [1, 2, 3, 4]\nnew_vector = rotate_vector(original_vector)\n\nputs \"Original Vector: #{original_vector}\"\nputs \"New Rotated Vector: #{new_vector}\"\n```"
  },
  {
    "task": "Implement a function that accepts an operation log and compresses it. Discuss the impact of pass-by-reference on the log.",
    "code": "```ruby\ndef compress_log(log)\n  compressed = []\n  previous_entry = nil\n  count = 1\n\n  log.each do |entry|\n    if entry == previous_entry\n      count += 1\n    else\n      compressed << {entry: previous_entry, count: count} if previous_entry\n      previous_entry = entry\n      count = 1\n    end\n  end\n\n  compressed << {entry: previous_entry, count: count} if previous_entry\n  compressed\nend\n\noperation_log = ['login', 'login', 'logout', 'logout', 'logout', 'login']\ncompressed_log = compress_log(operation_log)\n\nputs compressed_log.inspect\n```"
  },
  {
    "task": "Develop a function that receives a neural network model and updates its weights. Illustrate the effects of pass-by-reference.",
    "code": "```ruby\nclass NeuralNetwork\n  attr_accessor :weights\n\n  def initialize(weights)\n    @weights = weights\n  end\nend\n\ndef update_weights(model)\n  model.weights.map! { |w| w + rand(-0.1..0.1) }\nend\n\n# Example usage\nnn_model = NeuralNetwork.new([0.5, 0.8, 0.3])\nupdate_weights(nn_model)\nputs nn_model.weights\n```"
  },
  {
    "task": "Design a function that accepts a command history and reverts the last command. Show the changes with pass-by-reference.",
    "code": "```ruby\ndef revert_last_command(command_history)\n  return if command_history.empty?\n  command_history.pop\nend\n\n# Example usage\ncommands = [\"open file\", \"edit file\", \"save file\"]\nrevert_last_command(commands)\nputs commands.inspect # Output should be: [\"open file\", \"edit file\"]\n```"
  },
  {
    "task": "Write a function that takes a user profile and anonymizes it. Discuss how pass-by-reference affects the original profile.",
    "code": "```ruby\ndef anonymize_profile(profile)\n  profile[:name] = \"Anonymous\"\n  profile[:email] = \"hidden@example.com\"\n  profile[:phone] = \"000-000-0000\"\nend\n\nuser_profile = {\n  name: \"John Doe\",\n  email: \"john.doe@example.com\",\n  phone: \"123-456-7890\"\n}\n\nanonymize_profile(user_profile)\n```"
  },
  {
    "task": "Create a function that accepts a polynomial and evaluates it at a given point. Explain how pass-by-value ensures the polynomial remains unchanged.",
    "code": "```ruby\ndef evaluate_polynomial(coefficients, x)\n  result = 0\n  coefficients.each_with_index do |coeff, index|\n    result += coeff * (x ** index)\n  end\n  result\nend\n\n# Example usage:\n# polynomial = [2, 3, 4] represents 2 + 3x + 4x^2\n# evaluate_polynomial(polynomial, 2) evaluates 2 + 3*2 + 4*2^2\nevaluate_polynomial([2, 3, 4], 2)\n```"
  },
  {
    "task": "Implement a function that receives a video stream and applies a filter. Demonstrate the effects of pass-by-reference on the stream.",
    "code": "```ruby\nclass VideoStream\n  attr_accessor :frames\n\n  def initialize(frames)\n    @frames = frames\n  end\n\n  def apply_filter!\n    @frames.map! { |frame| \"Filtered #{frame}\" }\n  end\nend\n\ndef process_stream(stream)\n  stream.apply_filter!\nend\n\n# Example usage\nstream = VideoStream.new([\"Frame 1\", \"Frame 2\", \"Frame 3\"])\nprocess_stream(stream)\nputs stream.frames\n```"
  },
  {
    "task": "Develop a function that takes a task queue and reorders tasks based on priority. Illustrate the impact of pass-by-reference.",
    "code": "```ruby\ndef reorder_tasks!(task_queue)\n  task_queue.sort_by! { |task| -task[:priority] }\nend\n\n# Example use\ntasks = [\n  { name: 'Task 1', priority: 1 },\n  { name: 'Task 2', priority: 3 },\n  { name: 'Task 3', priority: 2 }\n]\n\nreorder_tasks!(tasks)\nputs tasks.inspect\n```"
  },
  {
    "task": "Design a program where a function receives a blockchain and verifies a transaction. Discuss how pass-by-reference affects the blockchain.",
    "code": "```ruby\nclass Blockchain\n  attr_accessor :transactions\n  \n  def initialize\n    @transactions = []\n  end\n\n  def add_transaction(transaction)\n    @transactions << transaction\n  end\nend\n\nclass Transaction\n  attr_reader :sender, :receiver, :amount\n  \n  def initialize(sender, receiver, amount)\n    @sender = sender\n    @receiver = receiver\n    @amount = amount\n  end\nend\n\ndef verify_transaction(blockchain, transaction)\n  # Simulate transaction verification logic\n  transaction_valid = true\n\n  if transaction_valid\n    # Pass-by-reference allows us to modify the original blockchain\n    blockchain.add_transaction(transaction)\n  end\n\n  transaction_valid\nend\n\n# Example usage:\nblockchain = Blockchain.new\ntransaction = Transaction.new(\"Alice\", \"Bob\", 50)\n\nif verify_transaction(blockchain, transaction)\n  puts \"Transaction verified and added to blockchain.\"\nelse\n  puts \"Transaction verification failed.\"\nend\n\nputs \"Blockchain transactions:\"\nblockchain.transactions.each do |tx|\n  puts \"#{tx.sender} sent #{tx.amount} to #{tx.receiver}\"\nend\n```"
  },
  {
    "task": "Write a function that takes a game leaderboard and updates scores. Show the changes with pass-by-reference.",
    "code": "```ruby\ndef update_scores(leaderboard, updates)\n  updates.each do |name, score|\n    leaderboard[name] = score\n  end\nend\n\n# Example usage\nleaderboard = { \"Alice\" => 100, \"Bob\" => 90 }\nupdates = { \"Alice\" => 120, \"Bob\" => 95 }\n\nupdate_scores(leaderboard, updates)\nputs leaderboard\n```"
  },
  {
    "task": "Create a function that accepts a project timeline and adjusts for delays. Explain how pass-by-reference influences the timeline.",
    "code": "```ruby\ndef adjust_timeline(timeline, delay)\n  timeline.each do |task|\n    task[:start_date] += delay\n    task[:end_date] += delay\n  end\nend\n\n# Example usage\nproject_timeline = [\n  { task: \"Design\", start_date: Date.new(2023, 10, 1), end_date: Date.new(2023, 10, 5) },\n  { task: \"Development\", start_date: Date.new(2023, 10, 6), end_date: Date.new(2023, 10, 20) },\n  { task: \"Testing\", start_date: Date.new(2023, 10, 21), end_date: Date.new(2023, 10, 25) }\n]\n\ndelay = 2 # days\nadjust_timeline(project_timeline, delay)\n\nputs project_timeline\n```"
  },
  {
    "task": "Implement a function that receives a to-do list and completes a task. Demonstrate the effect of pass-by-reference on the list.",
    "code": "```ruby\ndef complete_task(todo_list, task_index)\n  todo_list[task_index] += \" - Completed\"\nend\n\nmy_todo_list = [\"Buy groceries\", \"Clean the house\", \"Pay bills\"]\ncomplete_task(my_todo_list, 1)\n\nputs my_todo_list\n```"
  },
  {
    "task": "Develop a function that takes a paint canvas and adds a layer. Discuss the impact of pass-by-reference on the canvas.",
    "code": "```ruby\nclass Canvas\n  attr_accessor :layers\n\n  def initialize\n    @layers = []\n  end\nend\n\ndef add_layer(canvas)\n  canvas.layers << \"New Layer\"\nend\n\ncanvas = Canvas.new\nadd_layer(canvas)\n\nputs canvas.layers  # Output will show the impact of pass-by-reference\n```"
  },
  {
    "task": "Design a function that accepts a URL list and fetches content. Show the difference in the list when using pass-by-value.",
    "code": "```ruby\nrequire 'net/http'\nrequire 'uri'\n\ndef fetch_content(urls)\n  urls_copy = urls.dup\n  urls_copy.each do |url|\n    uri = URI.parse(url)\n    response = Net::HTTP.get_response(uri)\n    puts \"Content from #{url}: #{response.body[0..50]}\" # Display first 50 characters\n  end\nend\n\nurl_list = [\"http://example.com\", \"http://example.org\"]\nfetch_content(url_list)\n\n# Show the difference in the list\nputs \"Original URL list: #{url_list}\"\n```"
  },
  {
    "task": "Write a program where a function receives a game board and resets it. Illustrate the effects of pass-by-reference.",
    "code": "```ruby\ndef reset_board!(board)\n  board.each_index do |i|\n    board[i].each_index do |j|\n      board[i][j] = 0\n    end\n  end\nend\n\n# Example usage:\ngame_board = [\n  [1, 2, 3],\n  [4, 5, 6],\n  [7, 8, 9]\n]\n\nreset_board!(game_board)\np game_board\n```"
  },
  {
    "task": "Create a function that takes a sound effect and increases its volume. Explain how pass-by-reference affects the original sound.",
    "code": "```ruby\ndef increase_volume(sound_effect)\n  sound_effect[:volume] *= 1.5\nend\n\nsound = { volume: 10 }\nincrease_volume(sound)\nputs sound[:volume]\n```"
  },
  {
    "task": "Implement a function that accepts a weather forecast and updates temperature predictions. Discuss the impact of pass-by-reference.",
    "code": "```ruby\ndef update_temperature_predictions(forecast)\n  forecast.each do |day|\n    day[:temperature] += 5\n  end\nend\n\nweather_forecast = [\n  { day: 'Monday', temperature: 20 },\n  { day: 'Tuesday', temperature: 22 },\n  { day: 'Wednesday', temperature: 19 }\n]\n\nupdate_temperature_predictions(weather_forecast)\n\nputs weather_forecast\n```"
  },
  {
    "task": "Develop a function that receives a system log and extracts error messages. Show how pass-by-value ensures the original log remains unchanged.",
    "code": "```ruby\ndef extract_errors(log)\n  log_copy = log.dup\n  errors = log_copy.select { |entry| entry.include?(\"ERROR\") }\n  errors\nend\n\n# Example usage\nsystem_log = [\n  \"INFO: System started\",\n  \"ERROR: Disk full\",\n  \"WARNING: Low memory\",\n  \"ERROR: Network unreachable\",\n  \"INFO: Shutdown complete\"\n]\n\nerrors = extract_errors(system_log)\nputs \"Extracted Errors: #{errors}\"\nputs \"Original Log: #{system_log}\"\n```"
  },
  {
    "task": "Design a function that accepts a data packet and encrypts it. Demonstrate the effect of pass-by-value on the packet.",
    "code": "```ruby\ndef encrypt_packet(packet)\n  # Simple encryption by reversing the string\n  encrypted_packet = packet.reverse\n  encrypted_packet\nend\n\noriginal_packet = \"SensitiveData123\"\nencrypted_packet = encrypt_packet(original_packet)\n\nputs \"Original Packet: #{original_packet}\"\nputs \"Encrypted Packet: #{encrypted_packet}\"\n```"
  },
  {
    "task": "Write a function that takes a website theme and applies a color change. Explain how pass-by-reference affects the original theme.",
    "code": "```ruby\ndef apply_color_change(theme)\n  theme[:color] = \"new_color\"\nend\n\nwebsite_theme = { color: \"original_color\" }\napply_color_change(website_theme)\n\nputs website_theme[:color]\n```"
  },
  {
    "task": "Create a function that accepts a digital signature and verifies it. Discuss the implications of pass-by-value on the signature.",
    "code": "```ruby\nrequire 'openssl'\n\ndef verify_signature(signature, public_key, data)\n  digest = OpenSSL::Digest::SHA256.new\n  public_key.verify(digest, signature, data)\nend\n\n# Example usage:\npublic_key_pem = <<~PEM\n-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA1yZ1+8bZczhE9Bl7cDfV\n...\n-----END PUBLIC KEY-----\nPEM\n\npublic_key = OpenSSL::PKey::RSA.new(public_key_pem)\ndata = \"Important message\"\nsignature = ... # some digital signature generated previously\n\nvalid = verify_signature(signature, public_key, data)\nputs \"Signature is valid: #{valid}\"\n```"
  },
  {
    "task": "Implement a function that receives a robot's path and optimizes it. Illustrate the effects of pass-by-reference on the path.",
    "code": "```ruby\ndef optimize_path(path)\n  # Assuming path is an array of directions (e.g., [\"N\", \"S\", \"E\", \"W\"])\n  i = 0\n  while i < path.length - 1\n    if (path[i] == \"N\" && path[i + 1] == \"S\") || (path[i] == \"S\" && path[i + 1] == \"N\") ||\n       (path[i] == \"E\" && path[i + 1] == \"W\") || (path[i] == \"W\" && path[i + 1] == \"E\")\n      path.slice!(i, 2)\n      i -= 1 unless i == 0\n    else\n      i += 1\n    end\n  end\nend\n\n# Example usage\nrobot_path = [\"N\", \"E\", \"S\", \"W\", \"E\", \"W\", \"N\", \"S\"]\noptimize_path(robot_path)\nputs robot_path.inspect\n```"
  },
  {
    "task": "Develop a function that takes a music playlist and shuffles it. Demonstrate the impact of pass-by-reference on the playlist.",
    "code": "```ruby\ndef shuffle_playlist!(playlist)\n  playlist.shuffle!\nend\n\nplaylist = ['Song A', 'Song B', 'Song C', 'Song D']\nputs \"Original Playlist: #{playlist}\"\nshuffle_playlist!(playlist)\nputs \"Shuffled Playlist: #{playlist}\"\n```"
  },
  {
    "task": "Design a program where a function receives a social media feed and removes duplicates. Show the changes with pass-by-reference.",
    "code": "```ruby\ndef remove_duplicates!(feed)\n  unique_items = []\n  feed.each do |item|\n    unique_items << item unless unique_items.include?(item)\n  end\n  feed.replace(unique_items)\nend\n\nsocial_media_feed = ['post1', 'post2', 'post1', 'post3', 'post2']\nremove_duplicates!(social_media_feed)\nputs social_media_feed\n```"
  },
  {
    "task": "Write a function that takes a coding challenge and adds test cases. Discuss the effects of pass-by-reference on the challenge.",
    "code": "```ruby\ndef add_test_cases(coding_challenge)\n  test_cases = [\n    { input: [1, 2], expected_output: 3 },\n    { input: [5, 5], expected_output: 10 },\n    { input: [-1, 1], expected_output: 0 }\n  ]\n  \n  coding_challenge[:test_cases] = test_cases\nend\n\ndef discuss_pass_by_reference(coding_challenge)\n  add_test_cases(coding_challenge)\n  puts \"After adding test cases: #{coding_challenge}\"\nend\n\ncoding_challenge = { description: \"Add two numbers\" }\ndiscuss_pass_by_reference(coding_challenge)\n```"
  },
  {
    "task": "Create a function that accepts an animation sequence and reverses it. Explain how pass-by-value ensures the sequence remains unchanged.",
    "code": "```ruby\ndef reverse_animation(sequence)\n  sequence.reverse\nend\n\noriginal_sequence = [1, 2, 3, 4, 5]\nreversed_sequence = reverse_animation(original_sequence)\n\nputs \"Original sequence: #{original_sequence}\"\nputs \"Reversed sequence: #{reversed_sequence}\"\n```"
  },
  {
    "task": "Implement a function that receives a GPS route and recalculates it. Illustrate the impact of pass-by-reference on the route.",
    "code": "```ruby\ndef recalculate_route!(route)\n  route.map! { |point| [point.first + 0.001, point.last + 0.001] }\nend\n\n# Example usage\ngps_route = [[40.7128, -74.0060], [34.0522, -118.2437], [37.7749, -122.4194]]\nrecalculate_route!(gps_route)\nputs gps_route.inspect\n```"
  },
  {
    "task": "Develop a function that takes a chat history and censors inappropriate language. Show the effect of pass-by-reference on the history.",
    "code": "```ruby\ndef censor_language!(chat_history, inappropriate_words)\n  chat_history.each do |message|\n    inappropriate_words.each do |word|\n      message.gsub!(word, '*' * word.length)\n    end\n  end\nend\n\nchat_history = [\n  \"This is a clean message\",\n  \"This message contains a badword\",\n  \"Another inappropriate word here\"\n]\n\ninappropriate_words = [\"badword\", \"inappropriate\"]\n\ncensor_language!(chat_history, inappropriate_words)\n\nputs chat_history\n```"
  },
  {
    "task": "Design a function that accepts a lighting setup and adjusts brightness. Discuss the changes when the setup is passed by reference.",
    "code": "```ruby\nclass LightingSetup\n  attr_accessor :brightness\n\n  def initialize(brightness)\n    @brightness = brightness\n  end\nend\n\ndef adjust_brightness(setup)\n  setup.brightness += 10\nend\n\nlighting_setup = LightingSetup.new(50)\nadjust_brightness(lighting_setup)\nputs lighting_setup.brightness\n```"
  },
  {
    "task": "Write a program where a function receives a VR environment and changes the scenery. Demonstrate the effects of pass-by-reference.",
    "code": "```ruby\nclass VREnvironment\n  attr_accessor :scenery\n\n  def initialize(scenery)\n    @scenery = scenery\n  end\nend\n\ndef change_scenery(vr_env)\n  vr_env.scenery = \"Tropical Paradise\"\nend\n\n# Example usage:\nvr_env = VREnvironment.new(\"Mountain View\")\nputs \"Before: #{vr_env.scenery}\"\n\nchange_scenery(vr_env)\nputs \"After: #{vr_env.scenery}\"\n```"
  },
  {
    "task": "Create a function that takes a blockchain ledger and adds a block. Explain how pass-by-reference affects the ledger.",
    "code": "```ruby\nclass Block\n  attr_accessor :data, :previous_hash\n\n  def initialize(data, previous_hash)\n    @data = data\n    @previous_hash = previous_hash\n  end\nend\n\ndef add_block_to_ledger(ledger, block)\n  ledger << block\nend\n\n# Example usage:\nledger = []\nnew_block = Block.new(\"Transaction Data\", \"PreviousHashValue\")\nadd_block_to_ledger(ledger, new_block)\n\nputs ledger.inspect\n```"
  },
  {
    "task": "Implement a function that accepts a network packet and alters its headers. Discuss the implications of pass-by-value on the packet.",
    "code": "```ruby\nclass NetworkPacket\n  attr_accessor :headers\n\n  def initialize(headers)\n    @headers = headers\n  end\nend\n\ndef alter_packet_headers(packet)\n  modified_packet = NetworkPacket.new(packet.headers.dup)\n  modified_packet.headers[:modified] = true\n  modified_packet\nend\n\n# Example usage:\noriginal_packet = NetworkPacket.new({source: \"192.168.1.1\", destination: \"192.168.1.2\"})\naltered_packet = alter_packet_headers(original_packet)\n\nputs \"Original Packet Headers: #{original_packet.headers}\"\nputs \"Altered Packet Headers: #{altered_packet.headers}\"\n```"
  }
]