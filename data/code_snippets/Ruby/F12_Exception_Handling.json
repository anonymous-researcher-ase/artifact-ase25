[
  {
    "task": "Write a function that reads a file and handles the exception if the file is not found.",
    "code": "```ruby\ndef read_file(filename)\n  begin\n    File.read(filename)\n  rescue Errno::ENOENT\n    puts \"File not found: #{filename}\"\n  end\nend\n```"
  },
  {
    "task": "Create a program that divides two numbers and catches any division by zero errors.",
    "code": "```ruby\ndef divide_numbers(a, b)\n  begin\n    result = a / b\n  rescue ZeroDivisionError\n    puts \"Error: Division by zero is not allowed.\"\n    return nil\n  end\n  result\nend\n\nputs divide_numbers(10, 2) # Expected output: 5\nputs divide_numbers(10, 0) # Expected output: Error: Division by zero is not allowed.\n```"
  },
  {
    "task": "Design a function to parse an integer from a string and manage invalid input exceptions.",
    "code": "```ruby\ndef parse_integer(input)\n  begin\n    Integer(input)\n  rescue ArgumentError\n    nil\n  end\nend\n```"
  },
  {
    "task": "Implement an API call and catch exceptions related to network errors or timeouts.",
    "code": "```ruby\nrequire 'net/http'\nrequire 'uri'\n\ndef fetch_data_from_api(url)\n  uri = URI.parse(url)\n  begin\n    response = Net::HTTP.get_response(uri)\n    if response.is_a?(Net::HTTPSuccess)\n      puts response.body\n    else\n      puts \"Error: #{response.code} #{response.message}\"\n    end\n  rescue SocketError => e\n    puts \"Network error: #{e.message}\"\n  rescue Net::OpenTimeout, Net::ReadTimeout => e\n    puts \"Timeout error: #{e.message}\"\n  rescue StandardError => e\n    puts \"An error occurred: #{e.message}\"\n  end\nend\n\nfetch_data_from_api('http://example.com/api')\n```"
  },
  {
    "task": "Develop a program that opens a database connection and handles any connection failure exceptions.",
    "code": "```ruby\nrequire 'pg'\n\nbegin\n  connection = PG.connect(dbname: 'my_database', user: 'my_user', password: 'my_password')\n  puts \"Connected to the database successfully.\"\nrescue PG::Error => e\n  puts \"Connection failed: #{e.message}\"\nensure\n  connection&.close\nend\n```"
  },
  {
    "task": "Write a function that accesses an array by index and catches out-of-bounds exceptions.",
    "code": "```ruby\ndef access_array_element(array, index)\n  begin\n    array[index]\n  rescue IndexError\n    nil\n  end\nend\n```"
  },
  {
    "task": "Create a function that converts a string to a date object and manages format exceptions.",
    "code": "```ruby\nrequire 'date'\n\ndef string_to_date(date_string)\n  begin\n    Date.parse(date_string)\n  rescue ArgumentError\n    nil\n  end\nend\n```"
  },
  {
    "task": "Design a program that writes data to a file and catches any file permission exceptions.",
    "code": "```ruby\nbegin\n  File.open('output.txt', 'w') do |file|\n    file.write(\"Some data to write to the file.\")\n  end\nrescue Errno::EACCES => e\n  puts \"An error occurred: #{e.message}\"\nend\n```"
  },
  {
    "task": "Implement a module that retrieves data from a URL and handles malformed URL exceptions.",
    "code": "```ruby\nrequire 'net/http'\nrequire 'uri'\n\nmodule DataRetriever\n  def self.fetch_data(url)\n    begin\n      uri = URI.parse(url)\n      response = Net::HTTP.get_response(uri)\n      response.body\n    rescue URI::InvalidURIError\n      \"Malformed URL exception occurred\"\n    end\n  end\nend\n```"
  },
  {
    "task": "Write a function to calculate the square root of a number and catch any negative input exceptions.",
    "code": "```ruby\ndef calculate_square_root(number)\n  begin\n    raise ArgumentError, \"Negative input\" if number < 0\n    Math.sqrt(number)\n  rescue ArgumentError => e\n    puts \"Error: #{e.message}\"\n  end\nend\n```"
  },
  {
    "task": "Develop a program that sends an email and manages exceptions for invalid email addresses.",
    "code": "```ruby\nrequire 'net/smtp'\n\ndef send_email(to, subject, body)\n  raise ArgumentError, 'Invalid email address' unless to =~ URI::MailTo::EMAIL_REGEXP\n\n  message = <<~MESSAGE_END\n    From: Your Name <your.email@example.com>\n    To: <#{to}>\n    Subject: #{subject}\n\n    #{body}\n  MESSAGE_END\n\n  begin\n    Net::SMTP.start('smtp.example.com', 587, 'example.com', 'username', 'password', :plain) do |smtp|\n      smtp.send_message message, 'your.email@example.com', to\n    end\n  rescue ArgumentError => e\n    puts \"Error: #{e.message}\"\n  rescue StandardError => e\n    puts \"Failed to send email: #{e.message}\"\n  end\nend\n\nbegin\n  send_email('invalid-email', 'Test Subject', 'This is a test email.')\nrescue ArgumentError => e\n  puts \"Exception caught: #{e.message}\"\nend\n```"
  },
  {
    "task": "Create a calculator application that handles invalid operations gracefully.",
    "code": "```ruby\nclass Calculator\n  def initialize\n    @result = 0\n  end\n\n  def add(a, b)\n    a + b\n  rescue => e\n    handle_error(e)\n  end\n\n  def subtract(a, b)\n    a - b\n  rescue => e\n    handle_error(e)\n  end\n\n  def multiply(a, b)\n    a * b\n  rescue => e\n    handle_error(e)\n  end\n\n  def divide(a, b)\n    begin\n      a / b\n    rescue ZeroDivisionError\n      \"Error: Division by zero is not allowed.\"\n    rescue => e\n      handle_error(e)\n    end\n  end\n\n  private\n\n  def handle_error(e)\n    \"An error occurred: #{e.message}\"\n  end\nend\n\ncalculator = Calculator.new\nputs calculator.add(5, 3)\nputs calculator.subtract(10, 4)\nputs calculator.multiply(6, 7)\nputs calculator.divide(20, 0)\nputs calculator.divide(20, 'a')\n```"
  },
  {
    "task": "Design a function that tries to parse JSON data and catches parsing errors.",
    "code": "```ruby\nrequire 'json'\n\ndef parse_json(data)\n  begin\n    JSON.parse(data)\n  rescue JSON::ParserError => e\n    puts \"Failed to parse JSON: #{e.message}\"\n    nil\n  end\nend\n```"
  },
  {
    "task": "Implement a system that processes user input and handles any type conversion exceptions.",
    "code": "```ruby\ndef process_user_input(input)\n  begin\n    number = Integer(input)\n    puts \"The number is #{number}.\"\n  rescue ArgumentError\n    puts \"Invalid input. Please enter a valid number.\"\n  end\nend\n\nputs \"Enter a number:\"\nuser_input = gets.chomp\nprocess_user_input(user_input)\n```"
  },
  {
    "task": "Write a function that fetches data from a database and manages exceptions for missing records.",
    "code": "```ruby\nrequire 'sqlite3'\n\ndef fetch_data_from_database(query)\n  begin\n    db = SQLite3::Database.new('example.db')\n    result = db.execute(query)\n    if result.empty?\n      raise \"RecordNotFound: No records found for the given query.\"\n    end\n    result\n  rescue SQLite3::SQLException => e\n    puts \"SQL Error: #{e.message}\"\n  rescue => e\n    puts \"An error occurred: #{e.message}\"\n  ensure\n    db.close if db\n  end\nend\n```"
  },
  {
    "task": "Create a program that connects to a remote server and handles authentication failure exceptions.",
    "code": "```ruby\nrequire 'net/http'\nrequire 'uri'\n\ndef connect_to_server\n  uri = URI.parse(\"http://example.com\")\n  http = Net::HTTP.new(uri.host, uri.port)\n\n  request = Net::HTTP::Get.new(uri.request_uri)\n  request.basic_auth(\"username\", \"password\")\n\n  begin\n    response = http.request(request)\n\n    if response.code.to_i == 401\n      raise \"Authentication Failed\"\n    else\n      puts \"Connection Successful\"\n    end\n\n  rescue => e\n    puts \"An error occurred: #{e.message}\"\n  end\nend\n\nconnect_to_server\n```"
  },
  {
    "task": "Develop a function to download a file from the internet and handle file not found exceptions.",
    "code": "```ruby\nrequire 'open-uri'\n\ndef download_file(url, destination)\n  begin\n    URI.open(url) do |file|\n      File.open(destination, 'wb') do |output|\n        output.write(file.read)\n      end\n    end\n    puts \"File downloaded successfully.\"\n  rescue OpenURI::HTTPError => e\n    puts \"Failed to download file: #{e.message}\"\n  end\nend\n```"
  },
  {
    "task": "Design a program that attempts to connect to an API and handles rate limit exceptions.",
    "code": "```ruby\nrequire 'net/http'\nrequire 'json'\n\ndef connect_to_api(url)\n  uri = URI(url)\n  response = nil\n\n  begin\n    response = Net::HTTP.get_response(uri)\n\n    if response.is_a?(Net::HTTPSuccess)\n      return JSON.parse(response.body)\n    elsif response.code == '429'\n      raise 'Rate limit exceeded'\n    else\n      raise 'Failed to connect'\n    end\n\n  rescue => e\n    puts \"Error: #{e.message}\"\n    # Handle rate limit or retry logic here\n  end\n\n  nil\nend\n\napi_url = 'https://api.example.com/data'\nresult = connect_to_api(api_url)\nputs result unless result.nil?\n```"
  },
  {
    "task": "Write a function that reads from a configuration file and manages key not found exceptions.",
    "code": "```ruby\nrequire 'json'\n\ndef read_config(file_path, key)\n  begin\n    file_content = File.read(file_path)\n    config = JSON.parse(file_content)\n    value = config[key]\n    raise KeyError, \"Key not found: #{key}\" if value.nil?\n    value\n  rescue Errno::ENOENT\n    puts \"Configuration file not found: #{file_path}\"\n  rescue JSON::ParserError\n    puts \"Error parsing the configuration file: #{file_path}\"\n  rescue KeyError => e\n    puts e.message\n  end\nend\n```"
  },
  {
    "task": "Create an application that processes a list of tasks and catches any task execution exceptions.",
    "code": "```ruby\nclass TaskProcessor\n  def initialize(tasks)\n    @tasks = tasks\n  end\n\n  def process_tasks\n    @tasks.each do |task|\n      begin\n        execute_task(task)\n      rescue StandardError => e\n        puts \"An error occurred while executing task: #{e.message}\"\n      end\n    end\n  end\n\n  private\n\n  def execute_task(task)\n    # Simulating task execution\n    raise \"Task execution failed\" if rand < 0.3\n    puts \"Task executed successfully\"\n  end\nend\n\ntasks = [\"Task 1\", \"Task 2\", \"Task 3\", \"Task 4\"]\nprocessor = TaskProcessor.new(tasks)\nprocessor.process_tasks\n```"
  },
  {
    "task": "Implement a program that performs batch processing and handles individual item processing exceptions.",
    "code": "```ruby\nclass BatchProcessor\n  def process_batch(items)\n    items.each do |item|\n      begin\n        process_item(item)\n      rescue StandardError => e\n        handle_exception(item, e)\n      end\n    end\n  end\n\n  private\n\n  def process_item(item)\n    # Simulate item processing, replace with actual logic\n    raise \"Processing error for item #{item}\" if rand < 0.2\n    puts \"Processed item #{item}\"\n  end\n\n  def handle_exception(item, exception)\n    puts \"Error processing item #{item}: #{exception.message}\"\n  end\nend\n\nitems = (1..10).to_a\nprocessor = BatchProcessor.new\nprocessor.process_batch(items)\n```"
  },
  {
    "task": "Develop a function that performs mathematical operations and catches arithmetic exceptions.",
    "code": "```ruby\ndef perform_operation(a, b, operation)\n  begin\n    case operation\n    when :add\n      a + b\n    when :subtract\n      a - b\n    when :multiply\n      a * b\n    when :divide\n      a / b\n    else\n      raise ArgumentError, \"Unsupported operation\"\n    end\n  rescue ZeroDivisionError\n    \"Cannot divide by zero\"\n  rescue ArgumentError => e\n    e.message\n  rescue StandardError\n    \"An error occurred\"\n  end\nend\n```"
  },
  {
    "task": "Write a program that logs error messages when exceptions occur during data processing.",
    "code": "```ruby\ndef process_data(data)\n  begin\n    # Simulate data processing\n    raise 'Data processing error' if data.nil?\n    puts \"Processing data: #{data}\"\n  rescue StandardError => e\n    log_error(e.message)\n  end\nend\n\ndef log_error(message)\n  puts \"Error: #{message}\"\nend\n\n# Example usage\nprocess_data(nil)\nprocess_data(\"Sample Data\")\n```"
  },
  {
    "task": "Create a script that monitors system resources and handles exceptions when limits are exceeded.",
    "code": "```ruby\nrequire 'sys/proctable'\n\ndef check_system_resources\n  memory_limit = 80.0 # Memory limit in percentage\n  cpu_limit = 80.0    # CPU limit in percentage\n\n  Sys::ProcTable.ps do |proc|\n    begin\n      memory_usage = proc.rss.to_f / proc.vsize.to_f * 100\n      cpu_usage = proc.pctcpu.to_f\n\n      if memory_usage > memory_limit\n        raise \"Memory usage exceeded: #{memory_usage.round(2)}%\"\n      end\n      \n      if cpu_usage > cpu_limit\n        raise \"CPU usage exceeded: #{cpu_usage.round(2)}%\"\n      end\n\n    rescue => e\n      puts \"Exception: #{e.message}\"\n    end\n  end\nend\n\nloop do\n  check_system_resources\n  sleep 5\nend\n```"
  },
  {
    "task": "Design a function that validates user input and manages any format exceptions.",
    "code": "```ruby\ndef validate_user_input(input)\n  begin\n    raise ArgumentError, \"Invalid format\" unless input.is_a?(String) && !input.empty?\n    # Additional validation logic can be added here\n    puts \"Input is valid\"\n  rescue ArgumentError => e\n    puts \"Validation error: #{e.message}\"\n  end\nend\n```"
  },
  {
    "task": "Implement a service that interacts with third-party APIs and handles unexpected response exceptions.",
    "code": "```ruby\nrequire 'net/http'\nrequire 'json'\n\nclass ApiService\n  API_URL = 'https://api.example.com/data'\n\n  def fetch_data\n    uri = URI(API_URL)\n    response = Net::HTTP.get_response(uri)\n\n    handle_response(response)\n  rescue StandardError => e\n    puts \"An error occurred: #{e.message}\"\n    nil\n  end\n\n  private\n\n  def handle_response(response)\n    case response\n    when Net::HTTPSuccess\n      JSON.parse(response.body)\n    else\n      raise \"Unexpected response: #{response.code} #{response.message}\"\n    end\n  end\nend\n\nservice = ApiService.new\ndata = service.fetch_data\nputs data.inspect unless data.nil?\n```"
  },
  {
    "task": "Write a function that uploads files to a server and handles exceptions for unsupported file types.",
    "code": "```ruby\ndef upload_file(file)\n  begin\n    raise \"Unsupported file type\" unless supported_file_type?(file)\n    # Logic to upload the file to the server goes here\n    puts \"File uploaded successfully.\"\n  rescue => e\n    puts \"An error occurred: #{e.message}\"\n  end\nend\n\ndef supported_file_type?(file)\n  # Assume we only support .txt files for simplicity\n  File.extname(file) == '.txt'\nend\n\n# Example usage\nupload_file(\"document.txt\")   # Should print \"File uploaded successfully.\"\nupload_file(\"image.jpg\")      # Should print \"An error occurred: Unsupported file type\"\n```"
  },
  {
    "task": "Create a program that simulates network traffic and manages packet loss exceptions.",
    "code": "```ruby\nclass NetworkTrafficSimulator\n  def initialize\n    @packets = (1..10).to_a\n  end\n\n  def simulate\n    @packets.each do |packet|\n      begin\n        send_packet(packet)\n      rescue PacketLossError => e\n        handle_packet_loss(e, packet)\n      end\n    end\n  end\n\n  private\n\n  def send_packet(packet)\n    if rand < 0.2\n      raise PacketLossError, \"Packet #{packet} lost!\"\n    else\n      puts \"Packet #{packet} sent successfully.\"\n    end\n  end\n\n  def handle_packet_loss(exception, packet)\n    puts \"Handling exception: #{exception.message}. Retrying packet #{packet}...\"\n    retry_count = 0\n\n    begin\n      retry_count += 1\n      send_packet(packet)\n    rescue PacketLossError => e\n      retry if retry_count < 3\n      puts \"Failed to send packet #{packet} after 3 attempts.\"\n    end\n  end\nend\n\nclass PacketLossError < StandardError; end\n\nsimulator = NetworkTrafficSimulator.new\nsimulator.simulate\n```"
  },
  {
    "task": "Develop a function that processes XML data and catches any structural exceptions.",
    "code": "```ruby\nrequire 'nokogiri'\n\ndef process_xml(xml_data)\n  begin\n    document = Nokogiri::XML(xml_data) { |config| config.strict }\n    # Process the document here\n    puts \"XML processed successfully.\"\n  rescue Nokogiri::XML::SyntaxError => e\n    puts \"Caught XML Syntax Error: #{e.message}\"\n  rescue => e\n    puts \"Caught an unexpected exception: #{e.message}\"\n  end\nend\n```"
  },
  {
    "task": "Design a program that handles exceptions when accessing environment variables.",
    "code": "```ruby\ndef get_env_variable(var_name)\n  begin\n    value = ENV.fetch(var_name)\n    puts \"Value of #{var_name}: #{value}\"\n  rescue KeyError => e\n    puts \"Error: Environment variable '#{var_name}' not found.\"\n  end\nend\n\n# Example usage\nget_env_variable('HOME')\nget_env_variable('NON_EXISTENT_VAR')\n```"
  },
  {
    "task": "Write a function that calculates factorial and manages exceptions for negative input values.",
    "code": "```ruby\ndef factorial(n)\n  raise ArgumentError, \"Negative input not allowed\" if n < 0\n  return 1 if n == 0\n  n * factorial(n - 1)\nend\n\nbegin\n  puts factorial(5)  # Example usage\n  puts factorial(-1) # This will raise an exception\nrescue ArgumentError => e\n  puts \"Error: #{e.message}\"\nend\n```"
  },
  {
    "task": "Create a software tool that converts file formats and handles unsupported format exceptions.",
    "code": "```ruby\nclass FileFormatConverter\n  SUPPORTED_FORMATS = %w[txt csv json]\n\n  def convert_file(input_file, output_format)\n    unless SUPPORTED_FORMATS.include?(output_format)\n      raise UnsupportedFormatException.new(\"Format '#{output_format}' is not supported.\")\n    end\n    \n    # Mock conversion process\n    begin\n      data = read_file(input_file)\n      converted_data = convert_data(data, output_format)\n      write_file(input_file, converted_data, output_format)\n    rescue UnsupportedFormatException => e\n      puts \"Error: #{e.message}\"\n    rescue StandardError => e\n      puts \"An error occurred during conversion: #{e.message}\"\n    end\n  end\n\n  private\n\n  def read_file(file)\n    # Dummy data to simulate reading a file\n    \"sample data from #{file}\"\n  end\n\n  def convert_data(data, format)\n    # Mock conversion logic\n    \"converted #{data} to #{format} format\"\n  end\n\n  def write_file(original_file, data, format)\n    output_file = \"#{File.basename(original_file, '.*')}.#{format}\"\n    File.open(output_file, 'w') { |file| file.write(data) }\n    puts \"File successfully converted to #{output_file}\"\n  end\nend\n\nclass UnsupportedFormatException < StandardError; end\n\n# Example usage\nconverter = FileFormatConverter.new\nconverter.convert_file('example.txt', 'json')\nconverter.convert_file('example.txt', 'xml')\n```"
  },
  {
    "task": "Implement a function that sends HTTP requests and catches exceptions for invalid response status codes.",
    "code": "```ruby\nrequire 'net/http'\nrequire 'uri'\n\ndef send_http_request(url)\n  uri = URI.parse(url)\n  response = nil\n\n  begin\n    response = Net::HTTP.get_response(uri)\n    unless response.is_a?(Net::HTTPSuccess)\n      raise \"Invalid response status code: #{response.code}\"\n    end\n  rescue => e\n    puts \"An error occurred: #{e.message}\"\n  end\n\n  response\nend\n```"
  },
  {
    "task": "Develop a program that interacts with a message queue and handles message delivery exceptions.",
    "code": "```ruby\nrequire 'bunny'\n\nbegin\n  connection = Bunny.new\n  connection.start\n\n  channel = connection.create_channel\n  queue = channel.queue('my_queue')\n\n  queue.subscribe(block: true) do |_delivery_info, _properties, body|\n    puts \"Received message: #{body}\"\n  end\n\nrescue Bunny::Exception => e\n  puts \"Failed to deliver message: #{e.message}\"\nensure\n  connection.close if connection\nend\n```"
  },
  {
    "task": "Write a function that reads user input and catches exceptions for unexpected data types.",
    "code": "```ruby\ndef read_input\n  begin\n    puts \"Enter a number:\"\n    input = gets.chomp\n    number = Integer(input)\n    puts \"You entered the number: #{number}\"\n  rescue ArgumentError\n    puts \"Invalid input. Please enter a valid number.\"\n  end\nend\n\nread_input\n```"
  },
  {
    "task": "Create a system that processes transactions and manages exceptions for insufficient funds.",
    "code": "```ruby\nclass InsufficientFundsError < StandardError; end\n\nclass Account\n  attr_accessor :balance\n\n  def initialize(balance)\n    @balance = balance\n  end\n\n  def process_transaction(amount)\n    begin\n      if amount > @balance\n        raise InsufficientFundsError, \"Transaction failed: Insufficient funds.\"\n      end\n      @balance -= amount\n      puts \"Transaction successful. New balance: #{@balance}\"\n    rescue InsufficientFundsError => e\n      puts e.message\n    end\n  end\nend\n\naccount = Account.new(100)\naccount.process_transaction(150)\naccount.process_transaction(50)\n```"
  },
  {
    "task": "Design a function that generates random numbers and handles exceptions when the range is invalid.",
    "code": "```ruby\ndef generate_random_number(min, max)\n  begin\n    raise ArgumentError, \"Invalid range: min should be less than max\" if min >= max\n    rand(min..max)\n  rescue ArgumentError => e\n    puts \"Error: #{e.message}\"\n  end\nend\n```"
  },
  {
    "task": "Implement a program that performs image processing and catches exceptions for unsupported file dimensions.",
    "code": "```ruby\nclass UnsupportedDimensionError < StandardError; end\n\ndef process_image(file_path)\n  begin\n    # Simulating reading an image file and its dimensions\n    dimensions = [1024, 768] # Example dimensions, replace with actual image reading logic\n    if dimensions.any? { |dim| dim > 2000 }\n      raise UnsupportedDimensionError, \"Unsupported file dimensions: #{dimensions}\"\n    end\n    puts \"Processing image with dimensions: #{dimensions}\"\n    # Insert image processing logic here\n  rescue UnsupportedDimensionError => e\n    puts \"Error: #{e.message}\"\n  rescue => e\n    puts \"An unexpected error occurred: #{e.message}\"\n  end\nend\n\n# Example usage\nprocess_image(\"example_image.jpg\")\n```"
  },
  {
    "task": "Write a function that manipulates strings and manages exceptions for invalid operations.",
    "code": "```ruby\ndef manipulate_string(input)\n  begin\n    # Example operation: Reverse the string\n    result = input.reverse\n    # Raise an exception if the operation results in an invalid case\n    raise 'Invalid operation' if result.empty?\n    return result\n  rescue => e\n    return \"Error: #{e.message}\"\n  end\nend\n```"
  },
  {
    "task": "Create a script that automates tasks and handles exceptions for missing dependencies.",
    "code": "```ruby\nbegin\n  require 'some_dependency'\n\n  # Automated tasks go here\n  puts \"Running automated tasks...\"\n\nrescue LoadError => e\n  puts \"Dependency is missing: #{e.message}\"\n  # Handle missing dependency, e.g., notify user or attempt to install it\n  puts \"Attempting to install missing dependency...\"\n  system(\"gem install some_dependency\")\n  retry\nend\n```"
  },
  {
    "task": "Develop a function that accesses nested data structures and manages key access exceptions.",
    "code": "```ruby\ndef access_nested_data(data, *keys)\n  begin\n    keys.reduce(data) { |d, key| d.fetch(key) }\n  rescue KeyError\n    nil\n  end\nend\n```"
  },
  {
    "task": "Design a program that synchronizes data between sources and handles data mismatch exceptions.",
    "code": "```ruby\nclass DataSynchronizer\n  def initialize(source1, source2)\n    @source1 = source1\n    @source2 = source2\n  end\n\n  def synchronize\n    begin\n      data1 = fetch_data(@source1)\n      data2 = fetch_data(@source2)\n      \n      if data1 != data2\n        raise DataMismatchError, \"Data mismatch between sources\"\n      end\n\n      merge_data(data1, data2)\n      puts \"Data synchronized successfully\"\n    rescue DataMismatchError => e\n      puts \"Error: #{e.message}\"\n    rescue StandardError => e\n      puts \"An unexpected error occurred: #{e.message}\"\n    end\n  end\n\n  private\n\n  def fetch_data(source)\n    # Simulate data fetching\n    source[:data]\n  end\n\n  def merge_data(data1, data2)\n    # Simulate data merging\n    data1.merge(data2)\n  end\nend\n\nclass DataMismatchError < StandardError; end\n\nsource1 = { data: { key1: 'value1', key2: 'value2' } }\nsource2 = { data: { key1: 'value1', key2: 'different_value' } }\n\nsynchronizer = DataSynchronizer.new(source1, source2)\nsynchronizer.synchronize\n```"
  },
  {
    "task": "Write a function that interacts with hardware devices and handles connection failure exceptions.",
    "code": "```ruby\ndef interact_with_hardware\n  begin\n    # Simulate hardware interaction\n    connect_to_hardware_device\n  rescue ConnectionFailedError => e\n    puts \"Connection failed: #{e.message}\"\n  end\nend\n\ndef connect_to_hardware_device\n  # Simulate a situation where connection might fail\n  raise ConnectionFailedError, \"Unable to connect to the hardware device\"\nend\n\nclass ConnectionFailedError < StandardError; end\n\n# Example usage\ninteract_with_hardware\n```"
  },
  {
    "task": "Create a tool that compresses files and manages exceptions for unsupported compression formats.",
    "code": "```ruby\nrequire 'zlib'\n\nclass FileCompressor\n  SUPPORTED_FORMATS = ['.gz']\n\n  def self.compress_file(file_path, output_path)\n    unless SUPPORTED_FORMATS.any? { |ext| output_path.end_with?(ext) }\n      raise UnsupportedFormatError, \"Unsupported compression format\"\n    end\n\n    begin\n      Zlib::GzipWriter.open(output_path) do |gz|\n        File.open(file_path, 'rb') do |file|\n          while chunk = file.read(16 * 1024)\n            gz.write(chunk)\n          end\n        end\n      end\n      puts \"File compressed successfully.\"\n    rescue UnsupportedFormatError => e\n      puts e.message\n    rescue StandardError => e\n      puts \"An error occurred during compression: #{e.message}\"\n    end\n  end\nend\n\nclass UnsupportedFormatError < StandardError; end\n\n# Example usage\n# FileCompressor.compress_file('example.txt', 'example.gz')\n```"
  },
  {
    "task": "Implement a function that parses command-line arguments and handles missing argument exceptions.",
    "code": "```ruby\ndef parse_arguments\n  begin\n    args = ARGV\n    raise ArgumentError, \"Missing arguments\" if args.empty?\n    # Process the arguments here\n    puts \"Arguments: #{args.join(', ')}\"\n  rescue ArgumentError => e\n    puts \"Error: #{e.message}\"\n  end\nend\n\nparse_arguments\n```"
  },
  {
    "task": "Develop a program that simulates user interactions and manages timing exceptions.",
    "code": "```ruby\ndef simulate_user_interaction\n  begin\n    puts \"Simulating user interaction...\"\n    time_taken = rand(1..5)\n    sleep(time_taken)\n    raise \"Timeout Error\" if time_taken > 3\n    puts \"Interaction completed successfully.\"\n  rescue => e\n    puts \"Exception occurred: #{e.message}\"\n  ensure\n    puts \"End of simulation.\"\n  end\nend\n\nsimulate_user_interaction\n```"
  },
  {
    "task": "Write a function that encrypts data and handles exceptions for unsupported encryption algorithms.",
    "code": "```ruby\nrequire 'openssl'\n\ndef encrypt_data(data, algorithm)\n  begin\n    cipher = OpenSSL::Cipher.new(algorithm)\n    cipher.encrypt\n    key = cipher.random_key\n    iv = cipher.random_iv\n    encrypted = cipher.update(data) + cipher.final\n    { encrypted_data: encrypted, key: key, iv: iv }\n  rescue OpenSSL::Cipher::CipherError => e\n    puts \"Encryption failed: #{e.message}\"\n  end\nend\n```"
  },
  {
    "task": "Create a system that aggregates data and manages exceptions for data inconsistency.",
    "code": "```ruby\nclass DataAggregator\n  def initialize\n    @data_sources = []\n  end\n\n  def add_data_source(source)\n    @data_sources << source\n  end\n\n  def aggregate_data\n    aggregated_data = []\n\n    @data_sources.each do |source|\n      begin\n        data = source.fetch_data\n        raise 'Data inconsistency detected' unless data_consistent?(data)\n\n        aggregated_data.concat(data)\n      rescue StandardError => e\n        handle_exception(e, source)\n      end\n    end\n\n    aggregated_data\n  end\n\n  private\n\n  def data_consistent?(data)\n    # Placeholder for data consistency check\n    true\n  end\n\n  def handle_exception(exception, source)\n    puts \"Exception encountered in source #{source}: #{exception.message}\"\n  end\nend\n\nclass DataSource\n  def fetch_data\n    # Placeholder for fetching data logic\n    [1, 2, 3]\n  end\nend\n\n# Example usage\naggregator = DataAggregator.new\nsource1 = DataSource.new\nsource2 = DataSource.new\n\naggregator.add_data_source(source1)\naggregator.add_data_source(source2)\n\nresult = aggregator.aggregate_data\nputs \"Aggregated Data: #{result.inspect}\"\n```"
  },
  {
    "task": "Design a program that processes real-time data streams and handles connection drop exceptions.",
    "code": "```ruby\nrequire 'socket'\n\nclass DataStreamProcessor\n  def initialize(host, port)\n    @host = host\n    @port = port\n  end\n\n  def process_stream\n    begin\n      socket = TCPSocket.open(@host, @port)\n      while line = socket.gets\n        process_data(line)\n      end\n    rescue Errno::ECONNRESET => e\n      puts \"Connection dropped: #{e.message}\"\n    rescue StandardError => e\n      puts \"An error occurred: #{e.message}\"\n    ensure\n      socket.close if socket\n    end\n  end\n\n  def process_data(data)\n    # Simulate data processing\n    puts \"Processing: #{data.strip}\"\n  end\nend\n\nprocessor = DataStreamProcessor.new('localhost', 3000)\nprocessor.process_stream\n```"
  },
  {
    "task": "Implement a function that performs scientific calculations and manages precision exceptions.",
    "code": "```ruby\ndef scientific_calculation\n  begin\n    # Example of a scientific calculation\n    value = Math.sqrt(-1) # This will raise a Math::DomainError\n    result = value ** 2\n    return result\n  rescue Math::DomainError\n    puts \"Math error: Cannot perform calculation due to domain error.\"\n  rescue FloatDomainError\n    puts \"Precision error: Calculation resulted in a number too large or too small.\"\n  rescue StandardError => e\n    puts \"An error occurred: #{e.message}\"\n  end\nend\n\nscientific_calculation\n```"
  },
  {
    "task": "Write a script that generates reports and handles exceptions for missing data sources.",
    "code": "```ruby\nclass ReportGenerator\n  def initialize(data_source)\n    @data_source = data_source\n  end\n  \n  def generate_report\n    begin\n      raise \"Data source not found\" if @data_source.nil?\n      \n      # Simulate report generation\n      puts \"Generating report from #{@data_source}...\"\n      \n    rescue => e\n      puts \"Error: #{e.message}\"\n    end\n  end\nend\n\n# Example usage\ndata_source = nil # Simulate missing data source\nreport_generator = ReportGenerator.new(data_source)\nreport_generator.generate_report\n```"
  },
  {
    "task": "Create a program that validates digital certificates and manages trust exceptions.",
    "code": "```ruby\nrequire 'openssl'\n\nclass CertificateValidator\n  def initialize(certificate_path, trusted_store_path)\n    @certificate = OpenSSL::X509::Certificate.new(File.read(certificate_path))\n    @trusted_store = OpenSSL::X509::Store.new\n    @trusted_store.add_file(trusted_store_path)\n  end\n\n  def validate\n    begin\n      @trusted_store.verify(@certificate)\n      puts \"Certificate is valid and trusted.\"\n    rescue OpenSSL::X509::StoreError => e\n      puts \"Trust exception: #{e.message}\"\n      handle_trust_exception\n    end\n  end\n\n  private\n\n  def handle_trust_exception\n    puts \"Do you want to trust this certificate? (yes/no)\"\n    input = gets.chomp.downcase\n    if input == 'yes'\n      add_certificate_to_trusted_store\n      puts \"Certificate has been added to the trusted store.\"\n    else\n      puts \"Certificate is not trusted.\"\n    end\n  end\n\n  def add_certificate_to_trusted_store\n    @trusted_store.add_cert(@certificate)\n  end\nend\n\n# Example usage:\n# validator = CertificateValidator.new('path/to/certificate.pem', 'path/to/trusted_store.pem')\n# validator.validate\n```"
  },
  {
    "task": "Develop a function that schedules tasks and handles exceptions for scheduling conflicts.",
    "code": "```ruby\nclass SchedulingConflictError < StandardError; end\n\ndef schedule_task(task, schedule)\n  begin\n    if schedule.include?(task)\n      raise SchedulingConflictError, \"Task '#{task}' is already scheduled.\"\n    else\n      schedule << task\n      puts \"Task '#{task}' scheduled successfully.\"\n    end\n  rescue SchedulingConflictError => e\n    puts \"Error: #{e.message}\"\n  end\nend\n\n# Example usage\nschedule = []\nschedule_task(\"Task 1\", schedule)\nschedule_task(\"Task 1\", schedule)\n```"
  },
  {
    "task": "Design a system that manages user sessions and handles session timeout exceptions.",
    "code": "```ruby\nclass SessionTimeoutError < StandardError; end\n\nclass SessionManager\n  SESSION_DURATION = 1800 # 30 minutes in seconds\n\n  def initialize\n    @sessions = {}\n  end\n\n  def create_session(user_id)\n    @sessions[user_id] = Time.now\n    puts \"Session created for user #{user_id}\"\n  end\n\n  def validate_session(user_id)\n    if session_expired?(user_id)\n      raise SessionTimeoutError, \"Session expired for user #{user_id}\"\n    else\n      puts \"Session valid for user #{user_id}\"\n    end\n  rescue SessionTimeoutError => e\n    puts e.message\n    remove_session(user_id)\n  end\n\n  private\n\n  def session_expired?(user_id)\n    return true unless @sessions.key?(user_id)\n    Time.now - @sessions[user_id] > SESSION_DURATION\n  end\n\n  def remove_session(user_id)\n    @sessions.delete(user_id)\n    puts \"Session removed for user #{user_id}\"\n  end\nend\n\n# Example usage\nmanager = SessionManager.new\nmanager.create_session(1)\nsleep(2) # Simulate time passing\nmanager.validate_session(1)\nsleep(1800) # Simulate session timeout\nmanager.validate_session(1)\n```"
  },
  {
    "task": "Write a function that processes audio files and manages exceptions for unsupported audio formats.",
    "code": "```ruby\ndef process_audio_file(file)\n  begin\n    # Simulate processing audio file\n    if File.extname(file) != '.mp3' && File.extname(file) != '.wav'\n      raise 'Unsupported audio format'\n    end\n    # Process the audio file\n    puts \"Processing #{file}\"\n  rescue => e\n    puts \"Error: #{e.message}\"\n  end\nend\n\n# Example usage\nprocess_audio_file('song.mp3')\nprocess_audio_file('track.ogg')\n```"
  },
  {
    "task": "Create a service that sends notifications and handles exceptions for unreachable destinations.",
    "code": "```ruby\nclass NotificationService\n  def send_notification(destination, message)\n    begin\n      # Simulate sending notification\n      raise \"Destination unreachable\" unless reachable?(destination)\n      puts \"Notification sent to #{destination}: #{message}\"\n    rescue => e\n      handle_exception(e, destination)\n    end\n  end\n\n  private\n\n  def reachable?(destination)\n    # Simulate a reachability check\n    [true, false].sample\n  end\n\n  def handle_exception(exception, destination)\n    puts \"Failed to send notification to #{destination}: #{exception.message}\"\n  end\nend\n\n# Example usage\nservice = NotificationService.new\nservice.send_notification(\"example@example.com\", \"Hello, World!\")\n```"
  },
  {
    "task": "Implement a program that performs data migration and manages data transformation exceptions.",
    "code": "```ruby\ndef migrate_data(data)\n  data.each do |record|\n    begin\n      transform_data(record)\n    rescue StandardError => e\n      handle_exception(e, record)\n    end\n  end\nend\n\ndef transform_data(record)\n  # Simulate data transformation logic\n  raise 'Transformation Error' if record.nil?\n  # Continue with transformation\nend\n\ndef handle_exception(exception, record)\n  puts \"Error processing record: #{record}, Error: #{exception.message}\"\nend\n\n# Example usage\nrecords = [nil, { id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }]\nmigrate_data(records)\n```"
  },
  {
    "task": "Develop a function that processes video files and handles codec compatibility exceptions.",
    "code": "```ruby\ndef process_video(file)\n  begin\n    # Simulating video processing\n    raise 'Codec compatibility error' unless compatible_codec?(file)\n    puts \"Processing video file: #{file}\"\n  rescue => e\n    puts \"An error occurred: #{e.message}\"\n  end\nend\n\ndef compatible_codec?(file)\n  # Simulate codec check (in reality, you'd check the file's codec)\n  file.end_with?('.mp4')\nend\n\n# Example usage\nprocess_video('video.mov')\nprocess_video('video.mp4')\n```"
  },
  {
    "task": "Write a function that manages memory allocation and catches out-of-memory exceptions.",
    "code": "```ruby\ndef allocate_memory(size)\n  begin\n    data = ' ' * size\n    puts \"Memory allocated successfully.\"\n    data\n  rescue StandardError => e\n    if e.message.include?('failed to allocate memory')\n      puts \"Out of memory error: #{e.message}\"\n      nil\n    else\n      raise\n    end\n  end\nend\n```"
  },
  {
    "task": "Create a program that processes financial transactions and handles currency conversion exceptions.",
    "code": "```ruby\nclass CurrencyConverter\n  def initialize(exchange_rates)\n    @exchange_rates = exchange_rates\n  end\n\n  def convert(amount, from_currency, to_currency)\n    rate = @exchange_rates.dig(from_currency, to_currency)\n    raise \"Conversion rate not found for #{from_currency} to #{to_currency}\" unless rate\n\n    amount * rate\n  end\nend\n\nclass TransactionProcessor\n  def initialize(converter)\n    @converter = converter\n  end\n\n  def process_transaction(amount, from_currency, to_currency)\n    begin\n      converted_amount = @converter.convert(amount, from_currency, to_currency)\n      puts \"Converted #{amount} #{from_currency} to #{converted_amount} #{to_currency}\"\n    rescue => e\n      puts \"Transaction failed: #{e.message}\"\n    end\n  end\nend\n\nexchange_rates = {\n  'USD' => { 'EUR' => 0.85, 'JPY' => 110.0 },\n  'EUR' => { 'USD' => 1.18, 'JPY' => 129.5 }\n}\n\nconverter = CurrencyConverter.new(exchange_rates)\nprocessor = TransactionProcessor.new(converter)\n\nprocessor.process_transaction(100, 'USD', 'EUR')\nprocessor.process_transaction(100, 'USD', 'INR')\n```"
  },
  {
    "task": "Design a function that interacts with cloud storage and manages access permission exceptions.",
    "code": "```ruby\nrequire 'net/http'\n\ndef access_cloud_storage(url)\n  begin\n    response = Net::HTTP.get_response(URI(url))\n    if response.is_a?(Net::HTTPSuccess)\n      return response.body\n    else\n      raise \"Failed to access cloud storage: #{response.message}\"\n    end\n  rescue SocketError => e\n    puts \"Network connection error: #{e.message}\"\n  rescue StandardError => e\n    puts \"An error occurred: #{e.message}\"\n  end\nend\n```"
  },
  {
    "task": "Implement a script that automates deployment and handles exceptions for missing configuration files.",
    "code": "```ruby\nbegin\n  config_file = 'config.yml'\n\n  unless File.exist?(config_file)\n    raise \"Configuration file '#{config_file}' is missing.\"\n  end\n\n  # Simulate deployment logic\n  puts \"Deployment started with configuration from #{config_file}.\"\n\n  # Deployment logic goes here\n\n  puts \"Deployment completed successfully.\"\n\nrescue => e\n  puts \"Error during deployment: #{e.message}\"\nend\n```"
  },
  {
    "task": "Write a function that normalizes data and handles exceptions for invalid data ranges.",
    "code": "```ruby\ndef normalize_data(data)\n  begin\n    # Assuming data needs to be normalized to the range [0, 1]\n    min_value = data.min\n    max_value = data.max\n    raise \"Invalid data range\" if min_value == max_value\n\n    data.map { |value| (value - min_value).to_f / (max_value - min_value) }\n  rescue => e\n    puts \"Error: #{e.message}\"\n    []\n  end\nend\n```"
  },
  {
    "task": "Create a system that monitors application performance and handles threshold breach exceptions.",
    "code": "```ruby\nclass PerformanceMonitor\n  THRESHOLD = 80\n\n  def initialize\n    @performance_data = []\n  end\n\n  def add_performance_data(data)\n    @performance_data << data\n    check_threshold(data)\n  rescue ThresholdBreachException => e\n    handle_exception(e)\n  end\n\n  private\n\n  def check_threshold(data)\n    if data > THRESHOLD\n      raise ThresholdBreachException.new(\"Threshold of #{THRESHOLD} exceeded with data: #{data}\")\n    end\n  end\n\n  def handle_exception(exception)\n    puts \"Exception handled: #{exception.message}\"\n  end\nend\n\nclass ThresholdBreachException < StandardError; end\n\n# Example usage:\nmonitor = PerformanceMonitor.new\nmonitor.add_performance_data(85) # This will trigger the exception handling\nmonitor.add_performance_data(75) # This will not trigger the exception\n```"
  },
  {
    "task": "Develop a program that processes social media data and manages API limit exceptions.",
    "code": "```ruby\nrequire 'net/http'\nrequire 'json'\n\nclass SocialMediaProcessor\n  API_LIMIT_ERROR = 'API limit reached'\n  RETRY_AFTER = 60 # seconds\n\n  def initialize(api_url)\n    @api_url = api_url\n  end\n\n  def fetch_data\n    uri = URI(@api_url)\n    response = Net::HTTP.get_response(uri)\n    handle_response(response)\n  rescue StandardError => e\n    puts \"An error occurred: #{e.message}\"\n    retry\n  end\n\n  private\n\n  def handle_response(response)\n    case response\n    when Net::HTTPSuccess\n      process_data(JSON.parse(response.body))\n    when Net::HTTPTooManyRequests\n      puts API_LIMIT_ERROR\n      sleep(RETRY_AFTER)\n      fetch_data\n    else\n      puts \"Error: #{response.message}\"\n    end\n  end\n\n  def process_data(data)\n    # Process the social media data\n    puts \"Data processed: #{data}\"\n  end\nend\n\napi_url = 'https://api.socialmedia.com/data'\nprocessor = SocialMediaProcessor.new(api_url)\nprocessor.fetch_data\n```"
  },
  {
    "task": "Design a function that integrates with payment gateways and handles payment failure exceptions.",
    "code": "```ruby\nclass PaymentGatewayError < StandardError; end\n\ndef process_payment(amount, gateway)\n  begin\n    # Simulating payment processing with a gateway\n    if gateway == \"gateway1\"\n      raise PaymentGatewayError, \"Payment failed with Gateway 1\"\n    elsif gateway == \"gateway2\"\n      raise PaymentGatewayError, \"Payment failed with Gateway 2\"\n    else\n      puts \"Payment of #{amount} processed successfully through #{gateway}\"\n    end\n  rescue PaymentGatewayError => e\n    puts \"Error: #{e.message}\"\n    # Additional logic to handle the payment failure can be added here\n  end\nend\n\n# Example usage:\nprocess_payment(100, \"gateway1\")\nprocess_payment(200, \"gateway2\")\nprocess_payment(300, \"gateway3\")\n```"
  },
  {
    "task": "Write a function that backs up data and handles exceptions for unavailable storage media.",
    "code": "```ruby\ndef backup_data(data)\n  begin\n    # Simulate backing up data\n    raise IOError, \"Storage media unavailable\" unless storage_available?\n\n    # Code to back up data goes here\n    puts \"Data backed up successfully.\"\n  rescue IOError => e\n    puts \"Backup failed: #{e.message}\"\n  end\nend\n\ndef storage_available?\n  # Simulate checking for storage media availability\n  false\nend\n\n# Example usage\nbackup_data(\"Important data\")\n```"
  },
  {
    "task": "Create a tool that manages software updates and handles exceptions for version conflicts.",
    "code": "```ruby\nclass SoftwareUpdateManager\n  attr_accessor :installed_version\n\n  def initialize(installed_version)\n    @installed_version = installed_version\n  end\n\n  def update(new_version)\n    begin\n      check_version_conflict(new_version)\n      perform_update(new_version)\n    rescue VersionConflictError => e\n      puts \"Update failed: #{e.message}\"\n    end\n  end\n\n  private\n\n  def check_version_conflict(new_version)\n    if new_version <= @installed_version\n      raise VersionConflictError.new(\"New version #{new_version} conflicts with installed version #{@installed_version}.\")\n    end\n  end\n\n  def perform_update(new_version)\n    # Simulate update process\n    @installed_version = new_version\n    puts \"Update successful: Installed version is now #{@installed_version}.\"\n  end\nend\n\nclass VersionConflictError < StandardError; end\n\n# Example usage:\nmanager = SoftwareUpdateManager.new(1.0)\nmanager.update(1.5) # Successful update\nmanager.update(1.0) # Raises VersionConflictError\n```"
  },
  {
    "task": "Implement a program that performs sentiment analysis and manages exceptions for ambiguous texts.",
    "code": "```ruby\nrequire 'sentimental'\n\nclass SentimentAnalyzer\n  def initialize\n    @analyzer = Sentimental.new\n    @analyzer.load_defaults\n  end\n\n  def analyze(text)\n    begin\n      sentiment = @analyzer.sentiment(text)\n      \"The sentiment of the text is: #{sentiment}\"\n    rescue StandardError => e\n      \"An error occurred during sentiment analysis: #{e.message}\"\n    end\n  end\nend\n\nanalyzer = SentimentAnalyzer.new\nputs analyzer.analyze(\"This text is ambiguous and might cause issues.\")\n```"
  },
  {
    "task": "Develop a function that manages user authentication and handles credential mismatch exceptions.",
    "code": "```ruby\nclass AuthenticationError < StandardError; end\n\ndef authenticate_user(username, password)\n  # Assuming we have a hash of users for demonstration\n  users = {\n    \"user1\" => \"password123\",\n    \"user2\" => \"securepassword\",\n  }\n\n  begin\n    unless users.key?(username) && users[username] == password\n      raise AuthenticationError, \"Invalid username or password\"\n    end\n    \"User authenticated successfully\"\n  rescue AuthenticationError => e\n    e.message\n  end\nend\n```"
  },
  {
    "task": "Write a program that processes geographic data and handles exceptions for invalid coordinates.",
    "code": "```ruby\ndef process_geographic_data(data)\n  data.each do |entry|\n    begin\n      latitude, longitude = entry[:latitude], entry[:longitude]\n      raise ArgumentError, \"Invalid coordinates\" unless valid_coordinates?(latitude, longitude)\n      # Process the valid geographic data here\n    rescue ArgumentError => e\n      puts \"Error processing entry: #{e.message}\"\n    end\n  end\nend\n\ndef valid_coordinates?(latitude, longitude)\n  latitude.is_a?(Numeric) && longitude.is_a?(Numeric) &&\n    latitude.between?(-90, 90) && longitude.between?(-180, 180)\nend\n\ngeographic_data = [\n  { latitude: 34.05, longitude: -118.25 },\n  { latitude: 91.0, longitude: 45.0 }, # Invalid latitude\n  { latitude: 25.76, longitude: -80.19 }\n]\n\nprocess_geographic_data(geographic_data)\n```"
  },
  {
    "task": "Create a script that manages network configurations and handles exceptions for invalid syntax.",
    "code": "```ruby\ndef manage_network_configurations(config)\n  begin\n    # Simulate processing network configurations\n    if config.match?(/invalid/)\n      raise SyntaxError, \"Invalid network configuration syntax\"\n    end\n    puts \"Network configuration processed successfully.\"\n  rescue SyntaxError => e\n    puts \"Error: #{e.message}\"\n  end\nend\n\n# Example usage\nmanage_network_configurations(\"valid_config\")\nmanage_network_configurations(\"invalid_config\")\n```"
  },
  {
    "task": "Design a function that processes biometric data and handles exceptions for sensor errors.",
    "code": "```ruby\ndef process_biometric_data(data)\n  begin\n    # Simulate processing biometric data\n    raise 'SensorError' if data.nil? || data.empty?\n    \"Processed data: #{data}\"\n  rescue => e\n    \"Error processing data: #{e.message}\"\n  end\nend\n```"
  },
  {
    "task": "Implement a system that manages access control and handles exceptions for unauthorized access attempts.",
    "code": "```ruby\nclass AccessControlSystem\n  class UnauthorizedAccessError < StandardError; end\n\n  def initialize\n    @authorized_users = []\n  end\n\n  def authorize_user(user)\n    @authorized_users << user\n  end\n\n  def access_resource(user)\n    raise UnauthorizedAccessError, \"Access denied for user: #{user}\" unless @authorized_users.include?(user)\n\n    \"Access granted to #{user}\"\n  end\nend\n\nsystem = AccessControlSystem.new\nbegin\n  system.authorize_user(\"Alice\")\n  puts system.access_resource(\"Alice\")\n  puts system.access_resource(\"Bob\")\nrescue AccessControlSystem::UnauthorizedAccessError => e\n  puts e.message\nend\n```"
  },
  {
    "task": "Write a function that performs load balancing and handles exceptions for unreachable nodes.",
    "code": "```ruby\ndef load_balancer(nodes)\n  nodes.each do |node|\n    begin\n      connect_to(node)\n    rescue NodeUnreachableError => e\n      puts \"Node #{node} is unreachable: #{e.message}\"\n    rescue StandardError => e\n      puts \"An error occurred: #{e.message}\"\n    else\n      puts \"Successfully connected to node #{node}\"\n    end\n  end\nend\n\ndef connect_to(node)\n  # Simulate connection logic\n  raise NodeUnreachableError, \"Network timeout\" if rand > 0.7\nend\n\nclass NodeUnreachableError < StandardError; end\n\nnodes = %w[node1 node2 node3 node4]\nload_balancer(nodes)\n```"
  },
  {
    "task": "Create a program that simulates virtual environments and manages resource allocation exceptions.",
    "code": "```ruby\nclass VirtualEnvironment\n  def initialize(name)\n    @name = name\n    @resources = {}\n  end\n\n  def allocate_resource(resource, amount)\n    raise \"Resource amount must be positive\" if amount <= 0\n    if @resources.key?(resource)\n      @resources[resource] += amount\n    else\n      @resources[resource] = amount\n    end\n  rescue => e\n    puts \"Failed to allocate resource: #{e.message}\"\n  end\n\n  def deallocate_resource(resource, amount)\n    raise \"Resource not found\" unless @resources.key?(resource)\n    raise \"Cannot deallocate more than allocated\" if @resources[resource] < amount\n    @resources[resource] -= amount\n  rescue => e\n    puts \"Failed to deallocate resource: #{e.message}\"\n  end\n\n  def status\n    @resources\n  end\nend\n\nclass EnvironmentManager\n  def initialize\n    @environments = []\n  end\n\n  def create_environment(name)\n    @environments << VirtualEnvironment.new(name)\n  rescue => e\n    puts \"Failed to create environment: #{e.message}\"\n  end\n\n  def allocate_resources(env_name, resource, amount)\n    env = find_environment(env_name)\n    env.allocate_resource(resource, amount)\n  rescue => e\n    puts \"Failed to allocate resources: #{e.message}\"\n  end\n\n  def deallocate_resources(env_name, resource, amount)\n    env = find_environment(env_name)\n    env.deallocate_resource(resource, amount)\n  rescue => e\n    puts \"Failed to deallocate resources: #{e.message}\"\n  end\n\n  def environment_status(env_name)\n    env = find_environment(env_name)\n    env.status\n  rescue => e\n    puts \"Failed to retrieve environment status: #{e.message}\"\n  end\n\n  private\n\n  def find_environment(name)\n    @environments.find { |env| env.instance_variable_get(:@name) == name } || \n      raise(\"Environment not found\")\n  end\nend\n\n# Example usage\nmanager = EnvironmentManager.new\nmanager.create_environment(\"Env1\")\nmanager.allocate_resources(\"Env1\", \"CPU\", 10)\nmanager.allocate_resources(\"Env1\", \"Memory\", 20)\nputs manager.environment_status(\"Env1\")\nmanager.deallocate_resources(\"Env1\", \"CPU\", 5)\nputs manager.environment_status(\"Env1\")\n```"
  },
  {
    "task": "Develop a tool that manages digital rights and handles exceptions for unauthorized content access.",
    "code": "```ruby\nclass UnauthorizedAccessError < StandardError; end\n\nclass DigitalRightsManager\n  def initialize\n    @authorized_users = ['user1', 'user2', 'user3']\n  end\n\n  def access_content(user)\n    raise UnauthorizedAccessError, \"Access denied for #{user}\" unless authorized?(user)\n\n    puts \"Access granted to #{user}\"\n  rescue UnauthorizedAccessError => e\n    puts e.message\n  end\n\n  private\n\n  def authorized?(user)\n    @authorized_users.include?(user)\n  end\nend\n\ndrm = DigitalRightsManager.new\ndrm.access_content('user1') # Access granted to user1\ndrm.access_content('user4') # Access denied for user4\n```"
  },
  {
    "task": "Design a function that synchronizes clocks and handles exceptions for time drift.",
    "code": "```ruby\nrequire 'time'\n\nclass ClockSyncError < StandardError; end\n\ndef synchronize_clocks(standard_time_str, local_time_str)\n  begin\n    standard_time = Time.parse(standard_time_str)\n    local_time = Time.parse(local_time_str)\n    \n    drift = (standard_time - local_time).abs\n    \n    if drift > 5\n      raise ClockSyncError, \"Time drift too large: #{drift} seconds\"\n    else\n      local_time = standard_time\n    end\n    \n    local_time\n  rescue ArgumentError => e\n    puts \"Invalid time format: #{e.message}\"\n  rescue ClockSyncError => e\n    puts \"Clock synchronization error: #{e.message}\"\n  end\nend\n```"
  },
  {
    "task": "Write a script that manages system backups and handles exceptions for insufficient backup space.",
    "code": "```ruby\ndef perform_backup\n  puts \"Starting backup...\"\n  # Simulate backup process\n  if rand > 0.5\n    raise \"Insufficient backup space\"\n  else\n    puts \"Backup completed successfully.\"\n  end\nend\n\nbegin\n  perform_backup\nrescue => e\n  puts \"Backup failed: #{e.message}\"\nend\n```"
  },
  {
    "task": "Create a program that processes natural language text and handles parsing exceptions.",
    "code": "```ruby\ndef process_text(text)\n  begin\n    # Simulate text parsing\n    raise \"Parsing error\" if text.nil? || text.strip.empty?\n    puts \"Processed text: #{text}\"\n  rescue => e\n    puts \"An error occurred during text processing: #{e.message}\"\n  end\nend\n\n# Example usage\nprocess_text(\"Hello, world!\")\nprocess_text(nil)\n```"
  },
  {
    "task": "Implement a function that manages thread execution and handles race condition exceptions.",
    "code": "```ruby\nrequire 'thread'\n\ndef manage_thread_execution\n  mutex = Mutex.new\n  shared_resource = 0\n\n  threads = 10.times.map do\n    Thread.new do\n      begin\n        mutex.synchronize do\n          10.times do\n            shared_resource += 1\n          end\n        end\n      rescue ThreadError => e\n        puts \"Thread error: #{e.message}\"\n      end\n    end\n  end\n\n  threads.each do |thread|\n    begin\n      thread.join\n    rescue ThreadError => e\n      puts \"Failed to join thread: #{e.message}\"\n    end\n  end\n\n  shared_resource\nend\n\nputs manage_thread_execution\n```"
  },
  {
    "task": "Develop a system that integrates with IoT devices and handles connectivity exceptions.",
    "code": "```ruby\nrequire 'net/http'\n\nclass IoTDeviceConnector\n  def initialize(device_endpoint)\n    @device_endpoint = URI(device_endpoint)\n  end\n\n  def connect_to_device\n    begin\n      response = Net::HTTP.get_response(@device_endpoint)\n      if response.is_a?(Net::HTTPSuccess)\n        puts \"Successfully connected to the IoT device.\"\n      else\n        raise \"Failed to connect with response code: #{response.code}\"\n      end\n    rescue SocketError => e\n      puts \"Connectivity error: #{e.message}\"\n    rescue StandardError => e\n      puts \"An error occurred: #{e.message}\"\n    end\n  end\nend\n\ndevice_connector = IoTDeviceConnector.new(\"http://example-iot-device.local\")\ndevice_connector.connect_to_device\n```"
  },
  {
    "task": "Write a function that manages application logging and handles exceptions for log overflow.",
    "code": "```ruby\nclass LogOverflowError < StandardError; end\n\nclass Logger\n  MAX_LOG_SIZE = 1000\n\n  def initialize\n    @logs = []\n  end\n\n  def log(message)\n    begin\n      raise LogOverflowError, \"Log overflow\" if @logs.size >= MAX_LOG_SIZE\n      @logs << message\n    rescue LogOverflowError => e\n      handle_log_overflow(e)\n    end\n  end\n\n  private\n\n  def handle_log_overflow(exception)\n    puts \"Exception caught: #{exception.message}\"\n    # Handle log overflow, e.g., by clearing logs or saving to a file\n    @logs.clear\n  end\nend\n\n# Example usage:\n# logger = Logger.new\n# logger.log(\"This is a log message.\")\n```"
  },
  {
    "task": "Create a tool that visualizes data and handles exceptions for unsupported visualization types.",
    "code": "```ruby\nclass DataVisualizer\n  SUPPORTED_TYPES = ['bar', 'line', 'pie']\n\n  def visualize(data, type)\n    begin\n      if SUPPORTED_TYPES.include?(type)\n        puts \"Visualizing data as #{type} chart.\"\n        # Visualization logic goes here\n      else\n        raise UnsupportedVisualizationTypeError.new(\"#{type} is not a supported visualization type.\")\n      end\n    rescue UnsupportedVisualizationTypeError => e\n      puts \"Error: #{e.message}\"\n    end\n  end\nend\n\nclass UnsupportedVisualizationTypeError < StandardError; end\n\n# Example usage\nvisualizer = DataVisualizer.new\nvisualizer.visualize([1, 2, 3], 'bar')   # Supported\nvisualizer.visualize([1, 2, 3], 'scatter') # Unsupported\n```"
  },
  {
    "task": "Design a program that performs genetic algorithm simulations and manages exception for invalid mutations.",
    "code": "```ruby\nclass GeneticAlgorithm\n  def initialize(population_size, mutation_rate)\n    @population_size = population_size\n    @mutation_rate = mutation_rate\n    @population = Array.new(population_size) { generate_individual }\n  end\n\n  def generate_individual\n    # Randomly create an individual (e.g., a string of genes)\n    Array.new(10) { rand(0..1) }\n  end\n\n  def simulate_generation\n    @population.each do |individual|\n      begin\n        mutate(individual)\n      rescue InvalidMutationError => e\n        puts \"Invalid mutation: #{e.message}\"\n      end\n    end\n  end\n\n  def mutate(individual)\n    individual.map! do |gene|\n      if rand < @mutation_rate\n        mutated_gene = mutate_gene(gene)\n        raise InvalidMutationError, \"Gene mutation out of bounds\" unless valid_gene?(mutated_gene)\n        mutated_gene\n      else\n        gene\n      end\n    end\n  end\n\n  def mutate_gene(gene)\n    # Example mutation logic\n    gene == 0 ? 1 : 0\n  end\n\n  def valid_gene?(gene)\n    [0, 1].include?(gene)\n  end\nend\n\nclass InvalidMutationError < StandardError; end\n\n# Example usage\nga = GeneticAlgorithm.new(100, 0.05)\nga.simulate_generation\n```"
  },
  {
    "task": "Implement a function that manages distributed transactions and handles consistency exceptions.",
    "code": "```ruby\nclass DistributedTransactionManager\n  def initialize\n    @transactions = []\n  end\n\n  def add_transaction(transaction)\n    @transactions << transaction\n  end\n\n  def execute_transactions\n    begin\n      # Start all transactions\n      @transactions.each(&:start)\n\n      # Commit if all transactions are successful\n      @transactions.each(&:commit)\n    rescue ConsistencyException => e\n      # Rollback all transactions in case of a consistency exception\n      @transactions.each(&:rollback)\n      puts \"Transaction failed: #{e.message}\"\n    end\n  end\nend\n\nclass ConsistencyException < StandardError; end\n\nclass Transaction\n  def start\n    # Logic to start a transaction\n  end\n\n  def commit\n    # Logic to commit a transaction\n  end\n\n  def rollback\n    # Logic to rollback a transaction\n  end\nend\n```"
  },
  {
    "task": "Write a function that handles secure communications and manages encryption key exceptions.",
    "code": "```ruby\ndef secure_communication(data, key)\n  begin\n    encrypted_data = encrypt(data, key)\n    puts \"Data encrypted successfully: #{encrypted_data}\"\n    return encrypted_data\n  rescue EncryptionKeyError => e\n    puts \"Encryption failed: #{e.message}\"\n  rescue StandardError => e\n    puts \"An error occurred: #{e.message}\"\n  end\nend\n\ndef encrypt(data, key)\n  # Dummy encryption logic for demonstration\n  raise EncryptionKeyError, \"Invalid encryption key\" if key.nil? || key.empty?\n  \n  \"encrypted_#{data}\"\nend\n\nclass EncryptionKeyError < StandardError; end\n\n# Example usage\nsecure_communication(\"sensitive data\", \"valid_key\")\nsecure_communication(\"sensitive data\", \"\")\n```"
  },
  {
    "task": "Create a system that processes sensor data and handles out-of-range value exceptions.",
    "code": "```ruby\nclass SensorDataProcessor\n  OUT_OF_RANGE_THRESHOLD = 100\n\n  def process(sensor_data)\n    begin\n      sensor_data.each do |data|\n        raise OutOfRangeError, \"Value out of range: #{data}\" if data > OUT_OF_RANGE_THRESHOLD\n        puts \"Processing data: #{data}\"\n      end\n    rescue OutOfRangeError => e\n      puts \"Exception caught: #{e.message}\"\n    end\n  end\n\n  class OutOfRangeError < StandardError; end\nend\n\n# Example usage\nprocessor = SensorDataProcessor.new\nsensor_data = [23, 45, 105, 78, 50]\nprocessor.process(sensor_data)\n```"
  },
  {
    "task": "Develop a program that simulates weather patterns and handles model prediction exceptions.",
    "code": "```ruby\nclass WeatherModelError < StandardError; end\n\nclass WeatherSimulator\n  def initialize\n    @weather_patterns = [\"Sunny\", \"Cloudy\", \"Rainy\", \"Stormy\"]\n  end\n\n  def predict_weather\n    raise WeatherModelError, \"Weather prediction model failed\" if rand < 0.1\n\n    @weather_patterns.sample\n  end\nend\n\nsimulator = WeatherSimulator.new\n\nbegin\n  weather = simulator.predict_weather\n  puts \"Predicted weather: #{weather}\"\nrescue WeatherModelError => e\n  puts \"An error occurred: #{e.message}\"\nend\n```"
  },
  {
    "task": "Design a function that manages API versioning and handles backward compatibility exceptions.",
    "code": "```ruby\nclass APIVersionManager\n  def initialize\n    @versions = {}\n  end\n\n  def add_version(version, handler)\n    @versions[version] = handler\n  end\n\n  def call(version, *args)\n    if @versions.key?(version)\n      begin\n        @versions[version].call(*args)\n      rescue StandardError => e\n        handle_exception(e)\n      end\n    else\n      raise VersionNotSupportedError, \"Version #{version} is not supported\"\n    end\n  end\n\n  private\n\n  def handle_exception(exception)\n    if exception.is_a?(BackwardCompatibilityError)\n      puts \"Backward compatibility issue: #{exception.message}\"\n    else\n      puts \"An error occurred: #{exception.message}\"\n    end\n  end\nend\n\nclass VersionNotSupportedError < StandardError; end\nclass BackwardCompatibilityError < StandardError; end\n```"
  },
  {
    "task": "Write a tool that converts character encodings and handles unsupported encoding exceptions.",
    "code": "```ruby\nrequire 'iconv'\n\ndef convert_encoding(text, from_encoding, to_encoding)\n  begin\n    Iconv.conv(to_encoding, from_encoding, text)\n  rescue Iconv::InvalidEncoding => e\n    puts \"Unsupported encoding: #{e.message}\"\n  rescue Iconv::IllegalSequence => e\n    puts \"Illegal sequence encountered: #{e.message}\"\n  rescue => e\n    puts \"An error occurred: #{e.message}\"\n  end\nend\n\ntext = \"Some text here\"\nfrom_encoding = \"UTF-8\"\nto_encoding = \"ISO-8859-1\"\n\nconverted_text = convert_encoding(text, from_encoding, to_encoding)\nputs converted_text if converted_text\n```"
  },
  {
    "task": "Create a program that handles dynamic content generation and manages template parsing exceptions.",
    "code": "```ruby\nclass TemplateParser\n  def initialize(template)\n    @template = template\n  end\n\n  def parse(context)\n    begin\n      eval('\"' + @template.gsub(/{{(.*?)}}/, '#{context[\\1.strip]}') + '\"')\n    rescue Exception => e\n      puts \"Error parsing template: #{e.message}\"\n    end\n  end\nend\n\n# Example usage\ntemplate = \"Hello, {{ name }}! Today is {{ day }}.\"\ncontext = { 'name' => 'Alice', 'day' => 'Monday' }\nparser = TemplateParser.new(template)\nputs parser.parse(context)\n```"
  },
  {
    "task": "Implement a script that schedules automated tests and handles exceptions for missing test cases.",
    "code": "```ruby\nrequire 'rufus-scheduler'\n\nscheduler = Rufus::Scheduler.new\n\ndef run_test(test_case)\n  begin\n    # Simulate running a test case\n    if test_case.nil? || test_case.empty?\n      raise \"Test case not found\"\n    else\n      puts \"Running test: #{test_case}\"\n      # Here would be the logic to execute the test case\n    end\n  rescue => e\n    puts \"Exception occurred: #{e.message}\"\n  end\nend\n\nscheduler.every '1h' do\n  test_cases = [\"test_case_1\", nil, \"test_case_3\", \"\"]\n  \n  test_cases.each do |test_case|\n    run_test(test_case)\n  end\nend\n\nscheduler.join\n```"
  },
  {
    "task": "Develop a system that manages virtual machine instances and handles provisioning exceptions.",
    "code": "```ruby\nclass VirtualMachine\n  def initialize(name)\n    @name = name\n  end\n\n  def provision\n    begin\n      # Simulate provisioning process\n      raise 'ProvisioningError' if rand > 0.5\n      puts \"#{@name} provisioned successfully.\"\n    rescue => e\n      puts \"Failed to provision #{@name}: #{e.message}\"\n    end\n  end\nend\n\nclass VMManager\n  def initialize\n    @vms = []\n  end\n\n  def create_vm(name)\n    vm = VirtualMachine.new(name)\n    @vms << vm\n    vm.provision\n  end\nend\n\nmanager = VMManager.new\nmanager.create_vm('VM1')\nmanager.create_vm('VM2')\nmanager.create_vm('VM3')\n```"
  },
  {
    "task": "Write a function that processes credit scores and handles exceptions for missing credit history.",
    "code": "```ruby\ndef process_credit_score(credit_score)\n  begin\n    raise 'Missing credit history' if credit_score.nil?\n\n    # Process the credit score\n    # For example, let's just return it for now\n    \"Credit score is: #{credit_score}\"\n  rescue => e\n    \"Error: #{e.message}\"\n  end\nend\n```"
  },
  {
    "task": "Create a tool that manages digital certificates and handles expiration exceptions.",
    "code": "```ruby\nrequire 'date'\n\nclass CertificateExpiredError < StandardError; end\n\nclass Certificate\n  attr_reader :name, :expiration_date\n\n  def initialize(name, expiration_date)\n    @name = name\n    @expiration_date = Date.parse(expiration_date)\n  end\n\n  def check_validity\n    if Date.today > @expiration_date\n      raise CertificateExpiredError, \"Certificate #{@name} has expired.\"\n    else\n      \"Certificate #{@name} is valid.\"\n    end\n  end\nend\n\ndef manage_certificates(certificates)\n  certificates.each do |certificate|\n    begin\n      puts certificate.check_validity\n    rescue CertificateExpiredError => e\n      puts e.message\n    end\n  end\nend\n\ncertificates = [\n  Certificate.new(\"Cert1\", \"2023-09-30\"),\n  Certificate.new(\"Cert2\", \"2024-01-15\")\n]\n\nmanage_certificates(certificates)\n```"
  },
  {
    "task": "Design a program that processes genome sequences and handles exceptions for sequence alignment.",
    "code": "```ruby\nclass GenomeProcessor\n  def initialize(sequences)\n    @sequences = sequences\n  end\n\n  def align_sequences\n    begin\n      # Dummy alignment logic for illustration\n      raise 'No sequences provided' if @sequences.empty?\n      raise 'Invalid sequence format' unless valid_sequences?\n\n      puts \"Sequences aligned successfully\"\n    rescue => e\n      puts \"Error during sequence alignment: #{e.message}\"\n    end\n  end\n\n  private\n\n  def valid_sequences?\n    # Dummy validation logic\n    @sequences.all? { |seq| seq.is_a?(String) && seq.match?(/\\A[ATCG]+\\Z/) }\n  end\nend\n\n# Example usage\nsequences = [\"ATCG\", \"TTAG\", \"GCTA\"]\nprocessor = GenomeProcessor.new(sequences)\nprocessor.align_sequences\n```"
  }
]