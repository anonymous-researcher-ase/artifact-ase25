[
  {
    "task": "Write a function that reads a file and handles the exception if the file is not found.",
    "code": "```raku\nsub read-file($filename) {\n    try {\n        my $content = $filename.IO.slurp;\n        say $content;\n    }\n    CATCH {\n        when X::IO::NotFound {\n            say \"File not found: $filename\";\n        }\n    }\n}\n\nread-file('example.txt');\n```"
  },
  {
    "task": "Create a program that divides two numbers and catches any division by zero errors.",
    "code": "```raku\nsub divide($numerator, $denominator) {\n    try {\n        my $result = $numerator / $denominator;\n        say \"Result: $result\";\n        CATCH {\n            default {\n                say \"Error: Division by zero is not allowed.\";\n            }\n        }\n    }\n}\n\ndivide(10, 2);\ndivide(10, 0);\n```"
  },
  {
    "task": "Design a function to parse an integer from a string and manage invalid input exceptions.",
    "code": "```raku\nsub parse-int(Str $input) {\n    try {\n        my $result = $input.Int;\n        CATCH {\n            when X::Str::Numeric {\n                say \"Invalid input: $input\";\n                return Nil;\n            }\n        }\n        return $result;\n    }\n}\n\n# Example usage\nsay parse-int(\"42\");      # 42\nsay parse-int(\"notanint\"); # Invalid input: notanint\n```"
  },
  {
    "task": "Implement an API call and catch exceptions related to network errors or timeouts.",
    "code": "```raku\nuse HTTP::UserAgent;\n\nmy $ua = HTTP::UserAgent.new;\n\ntry {\n    my $response = $ua.get('https://api.example.com/data');\n    if $response.is-success {\n        say \"Data: \", $response.content;\n    } else {\n        die \"Failed to get data: \", $response.status-line;\n    }\n    CATCH {\n        when X::HTTP::NetworkError {\n            say \"Network error occurred: \", .message;\n        }\n        when X::HTTP::TimeoutError {\n            say \"Request timed out: \", .message;\n        }\n        default {\n            say \"Unexpected error: \", $_;\n        }\n    }\n}\n```"
  },
  {
    "task": "Develop a program that opens a database connection and handles any connection failure exceptions.",
    "code": "```raku\ntry {\n    my $dbh = DBIish.connect('Pg', :host<localhost>, :port<5432>, :database<testdb>, :user<user>, :password<password>);\n    CATCH {\n        when X::DBIish::Connection {\n            say \"Failed to connect to the database: \" ~ .message;\n        }\n    }\n}\n```"
  },
  {
    "task": "Write a function that accesses an array by index and catches out-of-bounds exceptions.",
    "code": "```raku\nsub access-array(@array, $index) {\n    try {\n        return @array[$index];\n        CATCH {\n            when X::OutOfRange {\n                say \"Index $index is out of bounds.\";\n            }\n        }\n    }\n}\n\nmy @data = <apple banana cherry>;\nsay access-array(@data, 1);  # banana\nsay access-array(@data, 5);  # Index 5 is out of bounds.\n```"
  },
  {
    "task": "Create a function that converts a string to a date object and manages format exceptions.",
    "code": "```raku\nuse DateTime::Parse;\n\nsub string-to-date(Str $date-str) {\n    try {\n        my $date = DateTime::Parse::parse($date-str);\n        CATCH {\n            when X::AdHoc {\n                say \"Error parsing date: $_\";\n            }\n        }\n        return $date;\n    }\n}\n\n# Example usage\nmy $date = string-to-date('2023-12-01T00:00:00Z');\nsay $date ?? $date.Str !! \"Invalid date format\";\n```"
  },
  {
    "task": "Design a program that writes data to a file and catches any file permission exceptions.",
    "code": "```raku\nsub write-to-file($filename, $content) {\n    try {\n        my $fh = open $filename, :w;\n        $fh.say($content);\n        $fh.close;\n        CATCH {\n            default {\n                if $_ ~~ X::IO::Permission {\n                    say \"Caught a file permission exception: $_\";\n                } else {\n                    say \"Caught an unexpected exception: $_\";\n                }\n            }\n        }\n    }\n}\n\nwrite-to-file('output.txt', 'Hello, Raku!');\n```"
  },
  {
    "task": "Implement a module that retrieves data from a URL and handles malformed URL exceptions.",
    "code": "```raku\nuse HTTP::UserAgent;\nuse URI;\n\nmodule URLDataFetcher {\n    sub fetch-data(Str $url) {\n        try {\n            my $uri = URI.new($url);\n            CATCH {\n                default {\n                    say \"Malformed URL: $_\";\n                    return;\n                }\n            }\n            my $ua = HTTP::UserAgent.new;\n            my $response = $ua.get($uri);\n\n            if $response.is-success {\n                return $response.content;\n            } else {\n                say \"Failed to retrieve data: \" ~ $response.status-line;\n            }\n        }\n    }\n}\n```"
  },
  {
    "task": "Write a function to calculate the square root of a number and catch any negative input exceptions.",
    "code": "```raku\nsub calculate-square-root($number) {\n    try {\n        die \"Negative input\" if $number < 0;\n        return sqrt($number);\n    }\n    CATCH {\n        when X::AdHoc {\n            say \"Error: $_\";\n            return Nil;\n        }\n    }\n}\n\nsay calculate-square-root(25);  # 5\nsay calculate-square-root(-9);  # Error: Negative input\n```"
  },
  {
    "task": "Develop a program that sends an email and manages exceptions for invalid email addresses.",
    "code": "```raku\nuse Email::Sender::Simple;\nuse Email::Simple;\nuse Email::Sender::Transport::SMTP::TLS;\n\nsub send-email(Str $to, Str $subject, Str $body) {\n    try {\n        die \"Invalid email address\" unless $to ~~ /<.email>/;\n\n        my $email = Email::Simple->create(\n            header => [\n                To      => $to,\n                From    => 'you@example.com',\n                Subject => $subject,\n            ],\n            body => $body,\n        );\n\n        my $transport = Email::Sender::Transport::SMTP::TLS.new(\n            host     => 'smtp.example.com',\n            port     => 587,\n            username => 'your-username',\n            password => 'your-password',\n        );\n\n        Email::Sender::Simple.send($email, { transport => $transport });\n        say \"Email sent successfully to $to.\";\n    }\n    CATCH {\n        when X::AdHoc {\n            say \"Failed to send email: $_.message\";\n        }\n    }\n}\n\n# Example usage\nsend-email('invalid-email-address', 'Test Subject', 'Test Body');\n```"
  },
  {
    "task": "Create a calculator application that handles invalid operations gracefully.",
    "code": "```raku\nclass Calculator {\n    method add($a, $b) {\n        return $a + $b;\n    }\n\n    method subtract($a, $b) {\n        return $a - $b;\n    }\n\n    method multiply($a, $b) {\n        return $a * $b;\n    }\n\n    method divide($a, $b) {\n        try {\n            return $a / $b;\n        }\n        CATCH {\n            default {\n                say \"Error: \" ~ .^name ~ \" - \" ~ .Str;\n                return Nil;\n            }\n        }\n    }\n}\n\nmy $calc = Calculator.new;\n\nsay \"Addition: \" ~ $calc.add(10, 5);\nsay \"Subtraction: \" ~ $calc.subtract(10, 5);\nsay \"Multiplication: \" ~ $calc.multiply(10, 5);\n\nsay \"Division: \" ~ $calc.divide(10, 5);\nsay \"Division by zero: \" ~ $calc.divide(10, 0);\n```"
  },
  {
    "task": "Design a function that tries to parse JSON data and catches parsing errors.",
    "code": "```raku\nuse JSON::Fast;\n\nsub parse-json(Str $json-str) {\n    try {\n        my $data = from-json($json-str);\n        CATCH {\n            when X::JSON::Fast {\n                say \"Failed to parse JSON: \", .message;\n            }\n        }\n        return $data;\n    }\n}\n\nmy $json-data = '{\"name\": \"Raku\", \"type\": \"language\"}';\nmy $result = parse-json($json-data);\nsay $result;\n```"
  },
  {
    "task": "Implement a system that processes user input and handles any type conversion exceptions.",
    "code": "```raku\nsub process-input(Str $input) {\n    try {\n        my Int $number = $input.Int;\n        say \"The number is $number.\";\n        CATCH {\n            default {\n                say \"An error occurred: $_\";\n            }\n        }\n    }\n}\n\nsay \"Enter a number:\";\nmy $user-input = prompt \"> \";\nprocess-input($user-input);\n```"
  },
  {
    "task": "Write a function that fetches data from a database and manages exceptions for missing records.",
    "code": "```raku\nuse DBIish;\n\nsub fetch-data($id) {\n    my $dbh = DBIish.connect('Pg', :database<your_database>, :user<your_user>, :password<your_password>);\n\n    try {\n        my $sth = $dbh.prepare('SELECT * FROM your_table WHERE id = ?');\n        $sth.execute($id);\n        if my $row = $sth.fetchrow_hashref {\n            return $row;\n        }\n        else {\n            die \"Record with id $id not found\";\n        }\n    }\n    CATCH {\n        when X::DBIish::SQL {\n            warn \"SQL Error: $_.message\";\n        }\n        when X::AdHoc {\n            warn \"Error: $_.message\";\n        }\n    }\n    finally {\n        $dbh.dispose if $dbh;\n    }\n}\n```"
  },
  {
    "task": "Create a program that connects to a remote server and handles authentication failure exceptions.",
    "code": "```raku\nuse IO::Socket::Async::SSL;\nuse Exception;\n\nclass AuthenticationFailure is Exception {\n    method message() {\n        \"Authentication failed: Invalid credentials or access denied.\"\n    }\n}\n\nsub connect-to-server($host, $port, $username, $password) {\n    my $socket;\n    try {\n        $socket = await IO::Socket::Async::SSL.connect($host, $port);\n        # Simulate authentication process\n        if $username ne 'correctUser' || $password ne 'correctPassword' {\n            die AuthenticationFailure.new;\n        }\n        say \"Connected and authenticated successfully!\";\n    }\n    CATCH {\n        when AuthenticationFailure {\n            .message.say;\n        }\n        default {\n            say \"Connection failed: \" ~ .^name ~ ' - ' ~ .message;\n        }\n    }\n}\n\nmy $host = 'example.com';\nmy $port = 443;\nmy $username = 'wrongUser';\nmy $password = 'wrongPassword';\n\nconnect-to-server($host, $port, $username, $password).await;\n```"
  },
  {
    "task": "Develop a function to download a file from the internet and handle file not found exceptions.",
    "code": "```raku\nuse HTTP::UserAgent;\nuse Cro::HTTP::Client;\nuse Cro::Uri;\n\nsub download-file($url, $output-file) {\n    try {\n        my $client = Cro::HTTP::Client.new;\n        my $uri = Cro::Uri.new($url);\n        my $response = $client.get($uri).result;\n\n        if $response.code == 404 {\n            die \"File not found\";\n        }\n        else {\n            spurt $output-file, $response.body.bytes;\n            say \"File downloaded successfully.\";\n        }\n    }\n    CATCH {\n        when X::Cro::HTTP::NotFound {\n            say \"Caught exception: $_.message\";\n        }\n        default {\n            say \"An unexpected error occurred: $_\";\n        }\n    }\n}\n\ndownload-file('http://example.com/file.txt', 'output-file.txt');\n```"
  },
  {
    "task": "Design a program that attempts to connect to an API and handles rate limit exceptions.",
    "code": "```raku\nuse Cro::HTTP::Client;\nuse Cro::HTTP::Exception;\n\nmy $client = Cro::HTTP::Client.new;\n\nsub connect-to-api(Str $url) {\n    my $response;\n    try {\n        $response = await $client.get($url);\n        CATCH {\n            default {\n                say \"An error occurred: $_\";\n            }\n            when Cro::HTTP::Exception::RateLimited {\n                say \"Rate limit exceeded. Please try again later.\";\n            }\n        }\n    }\n    return $response;\n}\n\nmy $url = 'https://api.example.com/data';\nmy $response = connect-to-api($url);\nif $response {\n    say \"Connected successfully: \", $response.body;\n}\n```"
  },
  {
    "task": "Write a function that reads from a configuration file and manages key not found exceptions.",
    "code": "```raku\nsub read-config($file, $key) {\n    try {\n        my %config = $file.IO.lines.map({ .split('=', 2) }).hash;\n        if %config{$key}:exists {\n            return %config{$key};\n        }\n        else {\n            die \"Key '$key' not found in configuration.\";\n        }\n    }\n    CATCH {\n        when X::IO::Error {\n            say \"Error reading file: $_\";\n        }\n        default {\n            say \"An error occurred: $_\";\n        }\n    }\n}\n\n# Example usage\nmy $value = read-config('config.txt', 'some_key');\nsay $value if $value.defined;\n```"
  },
  {
    "task": "Create an application that processes a list of tasks and catches any task execution exceptions.",
    "code": "```raku\nsub process-task(Str $task) {\n    # Simulate task processing\n    die \"Error processing task: $task\" if $task eq 'task2';\n    say \"Processed: $task\";\n}\n\nmy @tasks = <task1 task2 task3>;\n\nfor @tasks -> $task {\n    try {\n        process-task($task);\n        CATCH {\n            default {\n                say \"Caught exception: $_\";\n            }\n        }\n    }\n}\n```"
  },
  {
    "task": "Implement a program that performs batch processing and handles individual item processing exceptions.",
    "code": "```raku\nsub process-item($item) {\n    # Simulate item processing\n    die \"Error processing item: $item\" if $item %% 2; # Example error condition\n    return \"Processed item: $item\";\n}\n\nsub batch-process(@items) {\n    for @items -> $item {\n        try {\n            my $result = process-item($item);\n            say $result;\n        }\n        CATCH {\n            default {\n                say \"Caught an exception: $_\";\n            }\n        }\n    }\n}\n\nmy @items = 1..10;\nbatch-process(@items);\n```"
  },
  {
    "task": "Develop a function that performs mathematical operations and catches arithmetic exceptions.",
    "code": "```raku\nsub perform-operation($num1, $num2, $operation) {\n    try {\n        given $operation {\n            when 'add'      { return $num1 + $num2 }\n            when 'subtract' { return $num1 - $num2 }\n            when 'multiply' { return $num1 * $num2 }\n            when 'divide'   { return $num1 / $num2 }\n            default         { die \"Unsupported operation: $operation\" }\n        }\n    }\n    CATCH {\n        when X::Numeric::DivideByZero {\n            return \"Error: Division by zero\";\n        }\n        default {\n            return \"An error occurred: $_\";\n        }\n    }\n}\n\n# Example usage:\nsay perform-operation(10, 0, 'divide'); # Output: Error: Division by zero\nsay perform-operation(10, 5, 'add');    # Output: 15\n```"
  },
  {
    "task": "Write a program that logs error messages when exceptions occur during data processing.",
    "code": "```raku\nuse v6;\nuse Log::Timeline;\n\n# Create a logger\nmy $logger = Log::Timeline.new;\n\nsub process-data($data) {\n    # Simulate data processing that might throw an exception\n    die \"Unexpected data format\" if $data eq 'bad data';\n    return \"Processed $data\";\n}\n\nsub MAIN {\n    my @data = ('good data', 'bad data', 'more good data');\n    for @data -> $data {\n        try {\n            my $result = process-data($data);\n            say $result;\n            CATCH {\n                default {\n                    $logger.log('error', .^name ~ \": \" ~ .Str);\n                }\n            }\n        }\n    }\n}\n```"
  },
  {
    "task": "Create a script that monitors system resources and handles exceptions when limits are exceeded.",
    "code": "```raku\nsub monitor-system-resources {\n    my $cpu-limit = 80; # percentage\n    my $memory-limit = 80; # percentage\n\n    while True {\n        try {\n            my $cpu-usage = get-cpu-usage();\n            my $memory-usage = get-memory-usage();\n\n            if $cpu-usage > $cpu-limit {\n                die \"CPU usage exceeded: $cpu-usage%\";\n            }\n            if $memory-usage > $memory-limit {\n                die \"Memory usage exceeded: $memory-usage%\";\n            }\n        }\n        CATCH {\n            default {\n                say \"Exception caught: $_.message\";\n            }\n        }\n        sleep 5;\n    }\n}\n\nsub get-cpu-usage {\n    # Placeholder function for CPU usage retrieval\n    return (10..90).pick;\n}\n\nsub get-memory-usage {\n    # Placeholder function for memory usage retrieval\n    return (10..90).pick;\n}\n\nmonitor-system-resources();\n```"
  },
  {
    "task": "Design a function that validates user input and manages any format exceptions.",
    "code": "```raku\nsub validate-input(Str $input) {\n    try {\n        if $input !~~ /^\\d+$/ {\n            die \"Input must be a number\";\n        }\n        say \"Valid input: $input\";\n    }\n    CATCH {\n        default {\n            say \"Caught exception: \", .^name, \" with message: \", .Str;\n        }\n    }\n}\n\nvalidate-input(\"123\");\nvalidate-input(\"abc\");\n```"
  },
  {
    "task": "Implement a service that interacts with third-party APIs and handles unexpected response exceptions.",
    "code": "```raku\nuse HTTP::UserAgent;\nuse JSON::Fast;\n\nclass APIService {\n    has HTTP::UserAgent $.ua = HTTP::UserAgent.new;\n\n    method request(Str $url) {\n        try {\n            my $response = $.ua.get($url);\n            if $response.is-success {\n                return from-json $response.content;\n            }\n            else {\n                die \"Failed to fetch data: { $response.status-line }\";\n            }\n        }\n        CATCH {\n            default {\n                say \"An error occurred: $_\";\n            }\n        }\n    }\n}\n\nmy $service = APIService.new;\nmy $api-url = 'https://api.example.com/data';\n\nmy $result = $service.request($api-url);\nsay $result;\n```"
  },
  {
    "task": "Write a function that uploads files to a server and handles exceptions for unsupported file types.",
    "code": "```raku\nsub upload-file(Str $filename, Str $server) {\n    try {\n        my $allowed-types = <jpg png gif pdf>;\n        my $file-type = $filename.split('.').[*-1];\n\n        unless $file-type ~~ any(@allowed-types) {\n            die \"Unsupported file type: $file-type\";\n        }\n\n        # Simulated upload logic\n        say \"Uploading $filename to $server ...\";\n        CATCH {\n            when X::AdHoc {\n                say \"Error: \", .message;\n            }\n        }\n    }\n}\n\n# Example usage\nupload-file('document.txt', 'http://example.com');\nupload-file('image.jpg', 'http://example.com');\n```"
  },
  {
    "task": "Create a program that simulates network traffic and manages packet loss exceptions.",
    "code": "```raku\nclass NetworkTrafficSimulator {\n    has %.packets;\n\n    method send-packet($packet-id) {\n        try {\n            if (self.should-lose-packet) {\n                die \"Packet loss detected for packet $packet-id\";\n            }\n            self.store-packet($packet-id);\n            CATCH {\n                default {\n                    say \"Exception: $_.message\";\n                }\n            }\n        }\n    }\n\n    method should-lose-packet {\n        # Simulate packet loss with 20% probability\n        return Bool.pick(0.2);\n    }\n\n    method store-packet($packet-id) {\n        %.packets{$packet-id} = \"Packet $packet-id\";\n        say \"Packet $packet-id sent successfully.\";\n    }\n}\n\nmy $simulator = NetworkTrafficSimulator.new;\nfor 1..10 -> $id {\n    $simulator.send-packet($id);\n}\n```"
  },
  {
    "task": "Develop a function that processes XML data and catches any structural exceptions.",
    "code": "```raku\nuse XML::Parser;\n\nsub process-xml($xml-data) {\n    try {\n        my $parser = XML::Parser.new;\n        my $parsed-data = $parser.parse($xml-data);\n        # Process the parsed XML data here\n    }\n    CATCH {\n        default {\n            say \"An error occurred: $_\";\n        }\n    }\n}\n\n# Example usage\nmy $xml-data = '<root><element>Some data</element></root>';\nprocess-xml($xml-data);\n```"
  },
  {
    "task": "Design a program that handles exceptions when accessing environment variables.",
    "code": "```raku\nsub MAIN(Str $var-name) {\n    try {\n        my $value = %*ENV{$var-name};\n        if $value.defined {\n            say \"Value of '$var-name': $value\";\n        } else {\n            die \"Environment variable '$var-name' is not set.\";\n        }\n    }\n    CATCH {\n        default {\n            say \"An error occurred: $_\";\n        }\n    }\n}\n```"
  },
  {
    "task": "Write a function that calculates factorial and manages exceptions for negative input values.",
    "code": "```raku\nsub factorial(Int $n where $n >= 0) {\n    return [*] 1..$n;\n}\n\nsub factorial_safe(Int $n) {\n    try {\n        return factorial($n);\n    }\n    CATCH {\n        when X::AdHoc {\n            say \"Error: Negative input is not allowed.\";\n            return Nil;\n        }\n    }\n}\n\nsay factorial_safe(5);  # Outputs: 120\nsay factorial_safe(-3); # Outputs: Error: Negative input is not allowed.\n```"
  },
  {
    "task": "Create a software tool that converts file formats and handles unsupported format exceptions.",
    "code": "```raku\nclass FileFormatException is Exception {\n    has $.format;\n    method message() {\n        \"Unsupported file format: {$!format}\"\n    }\n}\n\nclass FileConverter {\n    my %supported-formats = ('txt' => 'text/plain', 'csv' => 'text/csv');\n\n    method convert($file, $target-format) {\n        my $file-ext = $file.IO.extension;\n        unless %supported-formats{$file-ext}:exists && %supported-formats{$target-format}:exists {\n            die FileFormatException.new(format => $target-format);\n        }\n        \n        # Assume conversion process here\n        say \"Converting $file to $target-format format\";\n    }\n}\n\n# Example usage\nsub MAIN(Str $file, Str $target-format) {\n    try {\n        FileConverter.new.convert($file, $target-format);\n        CATCH {\n            default {\n                say .message;\n            }\n        }\n    }\n}\n```"
  },
  {
    "task": "Implement a function that sends HTTP requests and catches exceptions for invalid response status codes.",
    "code": "```raku\nuse HTTP::UserAgent;\n\nsub fetch-url($url) {\n    my $ua = HTTP::UserAgent.new;\n    try {\n        my $response = $ua.get($url);\n        unless $response.is-success {\n            die \"Failed with status code: {$response.code}\";\n        }\n        return $response.content;\n    }\n    CATCH {\n        when X::HTTP::InvalidRequest {\n            say \"Caught an HTTP exception: \", $_.message;\n        }\n        default {\n            say \"Caught an unexpected exception: \", $_.message;\n        }\n    }\n}\n\n# Example usage\nmy $content = fetch-url('http://example.com');\nsay $content if $content.defined;\n```"
  },
  {
    "task": "Develop a program that interacts with a message queue and handles message delivery exceptions.",
    "code": "```raku\nuse Cro::MQTT;\n\nsub MAIN() {\n    my $mqtt = Cro::MQTT::Client.new(:host('localhost'), :port(1883));\n\n    try {\n        $mqtt.connect;\n        CATCH {\n            default {\n                say \"Connection failed: $_\";\n                exit;\n            }\n        }\n\n        $mqtt.subscribe('my/topic', sub ($message) {\n            try {\n                say \"Received message: {$message.payload}\";\n                # Simulate processing\n                die \"Failed to process message\" if $message.payload eq 'bad message';\n            }\n            CATCH {\n                default {\n                    say \"Message handling error: $_\";\n                }\n            }\n        });\n\n        $mqtt.start;\n    }\n    CATCH {\n        default {\n            say \"Unhandled exception: $_\";\n        }\n    }\n}\n```"
  },
  {
    "task": "Write a function that reads user input and catches exceptions for unexpected data types.",
    "code": "```raku\nsub read-input {\n    try {\n        print \"Enter a number: \";\n        my $input = prompt();\n        my $number = $input.Int;\n        CATCH {\n            default {\n                say \"Error: Expected a number, but received invalid input.\";\n            }\n        }\n        return $number;\n    }\n}\n\nsay read-input();\n```"
  },
  {
    "task": "Create a system that processes transactions and manages exceptions for insufficient funds.",
    "code": "```raku\nclass Account {\n    has $.balance is rw;\n\n    method process-transaction($amount) {\n        try {\n            self.debit($amount);\n            CATCH {\n                when InsufficientFunds {\n                    say \"Transaction failed: Insufficient funds.\";\n                }\n                default {\n                    say \"An unknown error occurred.\";\n                }\n            }\n        }\n    }\n\n    method debit($amount) {\n        if $amount > $.balance {\n            die InsufficientFunds.new;\n        }\n        $.balance -= $amount;\n        say \"Transaction successful: New balance is $!balance.\";\n    }\n}\n\nclass InsufficientFunds is Exception {}\n\nmy $account = Account.new(balance => 100);\n$account.process-transaction(50);  # Transaction successful\n$account.process-transaction(60);  # Transaction failed: Insufficient funds\n```"
  },
  {
    "task": "Design a function that generates random numbers and handles exceptions when the range is invalid.",
    "code": "```raku\nuse Random;\n\nsub generate-random-number($min, $max) {\n    try {\n        my $random-number = $min + floor(rand($max - $min + 1));\n        CATCH {\n            default {\n                warn \"Exception caught: $_\";\n            }\n        }\n        return $random-number;\n    }\n}\n\n# Example usage\nmy $num = generate-random-number(5, 10);\nsay \"Generated number: $num\";\n\n$num = generate-random-number(10, 5); # Invalid range, should trigger exception handling\nsay \"Generated number: $num\";\n```"
  },
  {
    "task": "Implement a program that performs image processing and catches exceptions for unsupported file dimensions.",
    "code": "```raku\nclass ImageProcessor {\n    method process-image(Str $file) {\n        try {\n            my $image = self.load-image($file);\n            self.check-dimensions($image);\n            say \"Image processed successfully.\";\n            CATCH {\n                when X::UnsupportedDimensions {\n                    say \"Error: Unsupported file dimensions.\";\n                }\n                default {\n                    say \"An unexpected error occurred: $_\";\n                }\n            }\n        }\n    }\n\n    method load-image(Str $file) {\n        # Simulate loading an image\n        return { width => 800, height => 600 };\n    }\n\n    method check-dimensions(%image) {\n        if %image<width> > 1024 || %image<height> > 768 {\n            die X::UnsupportedDimensions.new;\n        }\n    }\n}\n\nclass X::UnsupportedDimensions is Exception {\n    method message() { \"Unsupported file dimensions\" }\n}\n\nmy $processor = ImageProcessor.new;\n$processor.process-image(\"sample.jpg\");\n```"
  },
  {
    "task": "Write a function that manipulates strings and manages exceptions for invalid operations.",
    "code": "```raku\nsub manipulate-string(Str $input) {\n    try {\n        # Example string manipulation: convert to uppercase\n        my $result = $input.uc;\n        \n        # Simulate an invalid operation\n        if $input.chars == 0 {\n            die \"Invalid operation: Input string is empty\";\n        }\n        \n        return $result;\n    }\n    CATCH {\n        when X::AdHoc {\n            say \"Caught exception: \", .message;\n            return Nil;\n        }\n    }\n}\n\n# Example usage\nmy $output = manipulate-string(\"\");\nsay $output // \"Operation failed\";\n```"
  },
  {
    "task": "Create a script that automates tasks and handles exceptions for missing dependencies.",
    "code": "```raku\nuse v6;\nsub check-dependency($dependency) {\n    try {\n        shell \"which $dependency\";\n        CATCH {\n            when X::AdHoc {\n                say \"Dependency '$dependency' is missing.\";\n                return False;\n            }\n        }\n    }\n    return True;\n}\n\nsub automate-tasks() {\n    # Example tasks, replace with actual tasks\n    say \"Automating task 1\";\n    say \"Automating task 2\";\n    say \"Automating task 3\";\n}\n\nmy @dependencies = <git curl make>;\n\nfor @dependencies -> $dep {\n    unless check-dependency($dep) {\n        say \"Please install '$dep' to continue.\";\n        exit;\n    }\n}\n\nautomate-tasks();\n```"
  },
  {
    "task": "Develop a function that accesses nested data structures and manages key access exceptions.",
    "code": "```raku\nsub access-nested-data(%data, @keys) {\n    try {\n        my $value = %data;\n        for @keys -> $key {\n            $value = $value{$key};\n            CATCH {\n                when X::AdHoc {\n                    say \"Key '$key' not found.\";\n                    return Nil;\n                }\n            }\n        }\n        return $value;\n    }\n    CATCH {\n        default {\n            say \"An error occurred: $_\";\n            return Nil;\n        }\n    }\n}\n\nmy %data = (\n    foo => {\n        bar => {\n            baz => 42\n        }\n    }\n);\n\nsay access-nested-data(%data, <foo bar baz>); # Should print 42\nsay access-nested-data(%data, <foo bar qux>); # Should print \"Key 'qux' not found.\"\n```"
  },
  {
    "task": "Design a program that synchronizes data between sources and handles data mismatch exceptions.",
    "code": "```raku\nclass DataMismatchException is Exception {\n    has $.message;\n    method message() { $!message }\n}\n\nsub synchronize-data($source1, $source2) {\n    try {\n        my $data1 = $source1.get-data();\n        my $data2 = $source2.get-data();\n\n        if $data1 ne $data2 {\n            die DataMismatchException.new(message => \"Data mismatch between sources detected.\");\n        }\n\n        say \"Data is synchronized.\";\n    }\n    CATCH {\n        when DataMismatchException {\n            say \"Exception caught: \", .message;\n        }\n        default {\n            say \"An unexpected error occurred: \", .^name, \" - \", .message;\n        }\n    }\n}\n\n# Example usage\nclass DataSource {\n    has $.data;\n    method get-data() { $!data }\n}\n\nmy $source1 = DataSource.new(data => 'some data');\nmy $source2 = DataSource.new(data => 'some other data');\n\nsynchronize-data($source1, $source2);\n```"
  },
  {
    "task": "Write a function that interacts with hardware devices and handles connection failure exceptions.",
    "code": "```raku\nsub interact-with-device() {\n    try {\n        # Simulate interaction with a hardware device\n        die \"Connection failed\" if rand < 0.5;\n        say \"Device interaction successful.\";\n    }\n    CATCH {\n        when X::AdHoc {\n            say \"Caught exception: $_\";\n        }\n    }\n}\n\ninteract-with-device();\n```"
  },
  {
    "task": "Create a tool that compresses files and manages exceptions for unsupported compression formats.",
    "code": "```raku\nuse Compress::LZMA;\n\nsub compress-file(Str $file, Str $format) {\n    try {\n        given $format {\n            when 'lzma' {\n                my $lzma = Compress::LZMA.new;\n                $lzma.compress($file, \"$file.lzma\");\n            }\n            default {\n                die \"Unsupported compression format: $format\";\n            }\n        }\n    }\n    CATCH {\n        default {\n            say \"An error occurred: $_\";\n        }\n    }\n}\n\n# Example usage\ncompress-file(\"example.txt\", \"lzma\");\ncompress-file(\"example.txt\", \"unsupported-format\");\n```"
  },
  {
    "task": "Implement a function that parses command-line arguments and handles missing argument exceptions.",
    "code": "```raku\nsub MAIN(:$arg!) {\n    try {\n        CATCH {\n            when X::Usage {\n                say \"Missing argument: {$_.message}\";\n                exit 1;\n            }\n        }\n        say \"Argument provided: $arg\";\n    }\n}\n```"
  },
  {
    "task": "Develop a program that simulates user interactions and manages timing exceptions.",
    "code": "```raku\nclass UserInteraction {\n    method simulate {\n        try {\n            say \"Simulating user interaction...\";\n            self.manage_timing_exception;\n            CATCH {\n                when X::AdHoc {\n                    say \"Caught an exception: \", .^name, \" - \", .Str;\n                }\n            }\n        }\n    }\n\n    method manage_timing_exception {\n        my $random_time = (1..3).pick;\n        if $random_time == 3 {\n            die X::AdHoc.new(\"Timing issue occurred during interaction\");\n        }\n        say \"Interaction completed successfully in {$random_time} seconds.\";\n    }\n}\n\nmy $ui = UserInteraction.new;\n$ui.simulate;\n```"
  },
  {
    "task": "Write a function that encrypts data and handles exceptions for unsupported encryption algorithms.",
    "code": "```raku\nsub encrypt-data($data, $algorithm) {\n    try {\n        given $algorithm {\n            when 'AES' {\n                # Placeholder for AES encryption logic\n                return \"encrypted with AES\";\n            }\n            when 'DES' {\n                # Placeholder for DES encryption logic\n                return \"encrypted with DES\";\n            }\n            default {\n                die \"Unsupported encryption algorithm: $algorithm\";\n            }\n        }\n    }\n    CATCH {\n        default {\n            say \"Exception caught: $_\";\n            return Nil;\n        }\n    }\n}\n\n# Example usage:\nsay encrypt-data(\"my data\", \"AES\");  # should print: encrypted with AES\nsay encrypt-data(\"my data\", \"XYZ\");  # should print: Exception caught: Unsupported encryption algorithm: XYZ\n```"
  },
  {
    "task": "Create a system that aggregates data and manages exceptions for data inconsistency.",
    "code": "```raku\nclass DataAggregator {\n    has @.data;\n\n    method add-data($new-data) {\n        try {\n            CATCH {\n                when X::AdHoc {\n                    say \"Data inconsistency detected: $_\";\n                }\n            }\n            self.validate-data($new-data);\n            @!data.append($new-data);\n        }\n    }\n\n    method validate-data($data) {\n        if $data !~~ Int {\n            die X::AdHoc.new(payload => \"Invalid data type, expected Int\");\n        }\n    }\n\n    method aggregate {\n        try {\n            CATCH {\n                when X::AdHoc {\n                    say \"Aggregation error: $_\";\n                }\n            }\n            my $sum = [+] @!data;\n            say \"Aggregated data: $sum\";\n        }\n    }\n}\n\nmy $aggregator = DataAggregator.new;\n$aggregator.add-data(10);\n$aggregator.add-data(\"invalid\");\n$aggregator.add-data(20);\n$aggregator.aggregate;\n```"
  },
  {
    "task": "Design a program that processes real-time data streams and handles connection drop exceptions.",
    "code": "```raku\nclass DataStreamProcessor {\n    has $!connection;\n\n    method connect() {\n        # Simulate connection setup\n        $!connection = True;\n        say \"Connected to data stream.\";\n    }\n\n    method disconnect() {\n        # Simulate connection teardown\n        $!connection = False;\n        say \"Disconnected from data stream.\";\n    }\n\n    method process-data() {\n        try {\n            if !$!connection {\n                die \"Connection dropped!\";\n            }\n            # Simulate data processing\n            say \"Processing data...\";\n        }\n        CATCH {\n            default {\n                say \"Error: Connection dropped. Attempting to reconnect.\";\n                self.connect();\n            }\n        }\n    }\n}\n\nmy $processor = DataStreamProcessor.new;\n$processor.connect();\n\nloop {\n    $processor.process-data();\n    # Simulate random connection drop\n    if (Bool.pick) {\n        $processor.disconnect();\n    }\n    sleep 1;\n}\n```"
  },
  {
    "task": "Implement a function that performs scientific calculations and manages precision exceptions.",
    "code": "```raku\nsub perform-scientific-calculation($num1, $num2) {\n    try {\n        my $result = $num1 / $num2;\n        if $result == NaN {\n            die \"Precision error: Division resulted in NaN\";\n        }\n        return $result;\n    }\n    CATCH {\n        when X::Numeric::DivideByZero {\n            say \"Caught a division by zero error: \", .message;\n            return Failure;\n        }\n        when X::AdHoc {\n            say \"Caught a precision-related error: \", .message;\n            return Failure;\n        }\n        default {\n            say \"Caught an unexpected error: \", .message;\n            return Failure;\n        }\n    }\n}\n\n# Example usage:\nsay perform-scientific-calculation(1e-200, 1e-200);  # Precision handling\nsay perform-scientific-calculation(1, 0);            # Division by zero\n```"
  },
  {
    "task": "Write a script that generates reports and handles exceptions for missing data sources.",
    "code": "```raku\nsub generate-report(Str $source) {\n    if $source.IO.e {\n        say \"Generating report from $source...\";\n        # Code to generate the report\n    } else {\n        die \"Error: Data source $source not found.\";\n    }\n}\n\nmy @data-sources = <data1.csv data2.csv missing-data.csv>;\n\nfor @data-sources -> $source {\n    try {\n        generate-report($source);\n        CATCH {\n            default {\n                say \"Caught an exception: $_\";\n            }\n        }\n    }\n}\n```"
  },
  {
    "task": "Create a program that validates digital certificates and manages trust exceptions.",
    "code": "```raku\nclass Certificate {\n    has Str $.name;\n    has Bool $.is_valid;\n\n    method validate() {\n        if $!is_valid {\n            say \"$!name is a valid certificate.\";\n        }\n        else {\n            die \"$!name is an invalid certificate.\";\n        }\n    }\n}\n\nclass CertificateManager {\n    has @.trust_exceptions;\n\n    method add-exception(Str $cert_name) {\n        unless $cert_name ~~ @!trust_exceptions {\n            push @!trust_exceptions, $cert_name;\n            say \"Added $cert_name to trust exceptions.\";\n        }\n    }\n\n    method handle-certificate(Certificate $cert) {\n        try {\n            $cert.validate();\n            CATCH {\n                when X::AdHoc {\n                    if $cert.name ~~ @!trust_exceptions {\n                        say \"Trust exception for {$cert.name}. Ignoring validation error.\";\n                    }\n                    else {\n                        say .message;\n                    }\n                }\n            }\n        }\n    }\n}\n\n# Example usage\nmy $cert1 = Certificate.new(name => \"Cert1\", is_valid => False);\nmy $cert2 = Certificate.new(name => \"Cert2\", is_valid => True);\n\nmy $manager = CertificateManager.new(trust_exceptions => [\"Cert1\"]);\n$manager.handle-certificate($cert1);\n$manager.handle-certificate($cert2);\n```"
  },
  {
    "task": "Develop a function that schedules tasks and handles exceptions for scheduling conflicts.",
    "code": "```raku\nclass Task {\n    has Str $.name;\n    has DateTime $.start-time;\n    has DateTime $.end-time;\n\n    method conflicts-with(Task $other) {\n        return ($.start-time < $other.end-time && $.end-time > $other.start-time);\n    }\n}\n\nclass Scheduler {\n    has @!tasks;\n\n    method add-task(Task $task) {\n        try {\n            for @!tasks -> $existing-task {\n                if $task.conflicts-with($existing-task) {\n                    die \"Scheduling Conflict: '{$task.name}' conflicts with '{$existing-task.name}'\";\n                }\n            }\n            @!tasks.push($task);\n            say \"Task '{$task.name}' scheduled successfully.\";\n        }\n        CATCH {\n            default {\n                say \"Failed to schedule task: $_\";\n            }\n        }\n    }\n}\n\n# Example usage\nmy $scheduler = Scheduler.new;\n$scheduler.add-task(Task.new(name => 'Task 1', start-time => DateTime.new('2023-10-01T09:00:00'), end-time => DateTime.new('2023-10-01T10:00:00')));\n$scheduler.add-task(Task.new(name => 'Task 2', start-time => DateTime.new('2023-10-01T09:30:00'), end-time => DateTime.new('2023-10-01T11:00:00')));\n```"
  },
  {
    "task": "Design a system that manages user sessions and handles session timeout exceptions.",
    "code": "```raku\nclass Session {\n    has $.id;\n    has $.user;\n    has DateTime $.last-access-time;\n    has Int $.timeout = 30; # Timeout in minutes\n\n    method is-active {\n        DateTime.now - $.last-access-time < $.timeout * 60;\n    }\n\n    method access {\n        if self.is-active {\n            $.last-access-time = DateTime.now;\n        }\n        else {\n            die X::Session::Timeout.new(:session(self));\n        }\n    }\n}\n\nclass X::Session::Timeout is Exception {\n    has $.session;\n    method message {\n        \"Session $.session.id for user $.session.user has timed out.\"\n    }\n}\n\nmy @sessions = Session.new(:id(1), :user('Alice'), :last-access-time(DateTime.now));\n\nsub manage-sessions {\n    for @sessions -> $session {\n        try {\n            $session.access;\n            CATCH {\n                when X::Session::Timeout {\n                    say .message;\n                    # Handle session timeout, e.g., remove session or notify user\n                }\n                default {\n                    say \"An unexpected error occurred: $_\"\n                }\n            }\n        }\n    }\n}\n\n# Simulate session management\nsleep 1800; # Simulate passage of time\nmanage-sessions;\n```"
  },
  {
    "task": "Write a function that processes audio files and manages exceptions for unsupported audio formats.",
    "code": "```raku\nsub process-audio-file(Str $file) {\n    try {\n        my $format = $file.IO.extension;\n        given $format {\n            when 'mp3' { say \"Processing MP3 file: $file\" }\n            when 'wav' { say \"Processing WAV file: $file\" }\n            default { die \"Unsupported audio format: $format\" }\n        }\n        CATCH {\n            default { say \"Error processing file: $_\" }\n        }\n    }\n}\n\n# Example usage\nprocess-audio-file('song.mp3');\nprocess-audio-file('track.wav');\nprocess-audio-file('audio.ogg');\n```"
  },
  {
    "task": "Create a service that sends notifications and handles exceptions for unreachable destinations.",
    "code": "```raku\nclass NotificationService {\n    method send-notification(Str $destination, Str $message) {\n        try {\n            self.deliver($destination, $message);\n            CATCH {\n                default {\n                    say \"Failed to send notification to $destination: $_\";\n                }\n            }\n        }\n    }\n\n    method deliver(Str $destination, Str $message) {\n        die \"Destination '$destination' is unreachable.\" if $destination eq 'unreachable';\n        say \"Notification sent to $destination: $message\";\n    }\n}\n\nmy $service = NotificationService.new;\n$service.send-notification('unreachable', 'Hello, World!');\n$service.send-notification('reachable', 'Hello, Universe!');\n```"
  },
  {
    "task": "Implement a program that performs data migration and manages data transformation exceptions.",
    "code": "```raku\nclass DataMigration {\n    method transform-data(Str $data) {\n        # Simulate a data transformation that might fail\n        if $data eq 'bad-data' {\n            die \"Data transformation error: Invalid data encountered\";\n        }\n        return $data.uc;\n    }\n\n    method migrate-data(@data) {\n        for @data -> $data {\n            try {\n                my $transformed = self.transform-data($data);\n                say \"Data transformed successfully: $transformed\";\n                CATCH {\n                    default {\n                        say \"Error during data migration: $_\";\n                    }\n                }\n            }\n        }\n    }\n}\n\nmy @data = <good-data bad-data another-good-data>;\nmy $migration = DataMigration.new;\n$migration.migrate-data(@data);\n```"
  },
  {
    "task": "Develop a function that processes video files and handles codec compatibility exceptions.",
    "code": "```raku\nsub process-video-file(Str $file) {\n    try {\n        # Simulate processing the video file\n        # Raising an exception if codec is incompatible\n        die \"Codec not compatible\" if $file ~~ /incompatible/;\n        say \"Processing video file: $file\";\n    }\n    CATCH {\n        default {\n            say \"An error occurred: $_\";\n        }\n    }\n}\n\n# Example usage\nprocess-video-file(\"video1.mp4\");\nprocess-video-file(\"incompatible-video.mp4\");\n```"
  },
  {
    "task": "Write a function that manages memory allocation and catches out-of-memory exceptions.",
    "code": "```raku\nsub manage-memory-allocation($size) {\n    try {\n        my $data = Buf.new: 0 xx $size;\n        say \"Memory allocated successfully.\";\n    }\n    CATCH {\n        when X::OutOfMemory {\n            say \"Caught an out-of-memory exception!\";\n        }\n        default {\n            say \"An unexpected exception occurred: $_\";\n        }\n    }\n}\n\nmanage-memory-allocation(1e10); # Example usage with a large size\n```"
  },
  {
    "task": "Create a program that processes financial transactions and handles currency conversion exceptions.",
    "code": "```raku\nclass CurrencyConversionException is Exception {\n    has $.message;\n    method message() { \"Currency Conversion Error: \" ~ $!message }\n}\n\nsub convert-currency($amount, $from-currency, $to-currency) {\n    my %conversion-rates = (\n        'USD' => { 'EUR' => 0.85, 'JPY' => 110.0 },\n        'EUR' => { 'USD' => 1.18, 'JPY' => 129.0 },\n        'JPY' => { 'USD' => 0.009, 'EUR' => 0.0077 }\n    );\n    \n    unless %conversion-rates{$from-currency}:exists {\n        die CurrencyConversionException.new(message => \"Unsupported from-currency: $from-currency\");\n    }\n    unless %conversion-rates{$from-currency}{$to-currency}:exists {\n        die CurrencyConversionException.new(message => \"Unsupported to-currency: $to-currency\");\n    }\n    \n    return $amount * %conversion-rates{$from-currency}{$to-currency};\n}\n\nsub process-transaction($amount, $from-currency, $to-currency) {\n    try {\n        my $converted-amount = convert-currency($amount, $from-currency, $to-currency);\n        say \"Converted $amount $from-currency to $converted-amount $to-currency\";\n        CATCH {\n            when CurrencyConversionException {\n                say .message;\n            }\n            default {\n                say \"An unexpected error occurred: $_\";\n            }\n        }\n    }\n}\n\n# Example transactions\nprocess-transaction(100, 'USD', 'EUR');\nprocess-transaction(100, 'USD', 'GBP');  # Unsupported currency\n```"
  },
  {
    "task": "Design a function that interacts with cloud storage and manages access permission exceptions.",
    "code": "```raku\nuse v6;\n\nsub manage-cloud-access(Str $resource) {\n    try {\n        # Simulate cloud storage interaction\n        die \"Access Denied\" if $resource eq 'restricted';\n\n        say \"Access to $resource granted.\";\n    }\n    CATCH {\n        when X::AdHoc {\n            say \"Caught exception: $_\";\n            # Handle access permission exception\n            if .message eq 'Access Denied' {\n                say \"Permission denied for accessing $resource.\";\n            }\n            else {\n                say \"An unexpected error occurred.\";\n            }\n        }\n    }\n}\n\n# Example usage\nmanage-cloud-access('restricted');\nmanage-cloud-access('public');\n```"
  },
  {
    "task": "Implement a script that automates deployment and handles exceptions for missing configuration files.",
    "code": "```raku\nsub deploy {\n    try {\n        my $config-file = 'config.txt';\n        if !$config-file.IO.e {\n            die \"Configuration file missing!\";\n        }\n        # Simulate the deployment process\n        say \"Deployment started using $config-file\";\n        # Deployment logic here\n        CATCH {\n            default {\n                say \"An error occurred: $_\";\n            }\n        }\n    }\n}\n\ndeploy();\n```"
  },
  {
    "task": "Write a function that normalizes data and handles exceptions for invalid data ranges.",
    "code": "```raku\nsub normalize-data(@data) {\n    my $min = @data.min;\n    my $max = @data.max;\n\n    die \"Invalid data range: min and max are the same\" if $min == $max;\n\n    return @data.map({ ($_ - $min) / ($max - $min) });\n}\n\nsub MAIN {\n    try {\n        my @data = <1 2 3 4 5>;\n        my @normalized = normalize-data(@data);\n        say \"Normalized data: @normalized[]\";\n        CATCH {\n            default {\n                say \"Error: $_\";\n            }\n        }\n    }\n}\n```"
  },
  {
    "task": "Create a system that monitors application performance and handles threshold breach exceptions.",
    "code": "```raku\nclass PerformanceMonitor {\n    has $.threshold;\n    has $.current-load = 0;\n\n    method check-performance() {\n        if $.current-load > $.threshold {\n            die \"Threshold Breach: Load ($.current-load) exceeds threshold ($.threshold)\";\n        }\n        else {\n            say \"Performance is within acceptable limits.\";\n        }\n    }\n\n    method update-load(Int $new-load) {\n        $.current-load = $new-load;\n        self.check-performance();\n    }\n}\n\nmy $monitor = PerformanceMonitor.new(threshold => 100);\n\ntry {\n    $monitor.update-load(80);\n    CATCH {\n        default {\n            say \"An exception occurred: $_\";\n        }\n    }\n}\n\ntry {\n    $monitor.update-load(120);\n    CATCH {\n        default {\n            say \"An exception occurred: $_\";\n        }\n    }\n}\n```"
  },
  {
    "task": "Develop a program that processes social media data and manages API limit exceptions.",
    "code": "```raku\nclass SocialMediaAPI {\n    method process-data() {\n        try {\n            # Simulate API call\n            my $data = self.get-social-media-data; \n            CATCH {\n                when X::APILimitExceeded {\n                    say \"API limit exceeded. Please try again later.\";\n                }\n                when X::NetworkError {\n                    say \"Network error. Please check your connection.\";\n                }\n                default {\n                    say \"An unexpected error occurred: $_\";\n                }\n            }\n        }\n    }\n\n    method get-social-media-data {\n        # Simulate an API limit exceeded exception\n        die X::APILimitExceeded.new(message => \"API limit exceeded\");\n    }\n}\n\nclass X::APILimitExceeded is Exception {\n    has Str $.message;\n    method message() { $.message }\n}\n\n# Example usage\nmy $api = SocialMediaAPI.new;\n$api.process-data;\n```"
  },
  {
    "task": "Design a function that integrates with payment gateways and handles payment failure exceptions.",
    "code": "```raku\nclass PaymentGateway {\n    method process-payment($amount) {\n        die \"Payment failed\" if $amount <= 0;\n        # Simulate payment processing\n        say \"Payment of \\$${amount} processed successfully.\";\n    }\n}\n\nsub integrate-with-payment-gateway($amount) {\n    my $gateway = PaymentGateway.new;\n    try {\n        $gateway.process-payment($amount);\n        CATCH {\n            default {\n                say \"An exception occurred: $_\";\n            }\n        }\n    }\n}\n\nintegrate-with-payment-gateway(100); # Successful payment\nintegrate-with-payment-gateway(0);   # Payment failure\n```"
  },
  {
    "task": "Write a function that backs up data and handles exceptions for unavailable storage media.",
    "code": "```raku\nsub backup-data($data) {\n    try {\n        # Simulate backing up data to storage\n        # Assume backup-to-storage is a function that may throw exceptions\n        backup-to-storage($data);\n        CATCH {\n            when X::IO::Unavailable {\n                say \"Storage media unavailable. Backup failed.\";\n            }\n            default {\n                say \"An unexpected error occurred: \", $_.message;\n            }\n        }\n    }\n}\n\nsub backup-to-storage($data) {\n    # Simulate a possible exception\n    die X::IO::Unavailable.new if $data eq \"test\";\n    say \"Data backed up successfully.\";\n}\n\n# Example usage\nbackup-data(\"test\");  # This will simulate an unavailable storage media\nbackup-data(\"important data\");\n```"
  },
  {
    "task": "Create a tool that manages software updates and handles exceptions for version conflicts.",
    "code": "```raku\nclass SoftwareUpdater {\n    has %!versions;\n\n    submethod BUILD(:%versions) {\n        %!versions = %versions;\n    }\n\n    method update($software, $new-version) {\n        try {\n            my $current-version = %!versions{$software};\n            die \"No such software installed\" unless $current-version.defined;\n            if $new-version <= $current-version {\n                die \"Version conflict: $new-version is not newer than $current-version\";\n            }\n            %!versions{$software} = $new-version;\n            \"Update successful: $software updated to version $new-version\";\n        }\n        CATCH {\n            when X::AdHoc {\n                \"Update failed: $_\";\n            }\n        }\n    }\n}\n\nmy %installed = 'SoftwareA' => '1.0', 'SoftwareB' => '2.0';\nmy $updater = SoftwareUpdater.new(versions => %installed);\n\nsay $updater.update('SoftwareA', '1.0'); # Version conflict\nsay $updater.update('SoftwareA', '1.5'); # Successful update\nsay $updater.update('SoftwareC', '1.0'); # No such software\n```"
  },
  {
    "task": "Implement a program that performs sentiment analysis and manages exceptions for ambiguous texts.",
    "code": "```raku\nclass SentimentAnalyzer {\n    method analyze($text) {\n        try {\n            if $text ~~ /ambiguous/ {\n                die \"Ambiguous text detected.\";\n            }\n            # Assume sentiment_analysis is a method that processes text\n            my $result = self.sentiment_analysis($text);\n            return $result;\n        }\n        CATCH {\n            when X::AdHoc {\n                say \"Error: $_\";\n                return \"Analysis failed due to an error.\";\n            }\n        }\n    }\n\n    method sentiment_analysis($text) {\n        # Placeholder for actual sentiment analysis logic\n        return \"Positive\" if $text ~~ /happy/;\n        return \"Negative\" if $text ~~ /sad/;\n        return \"Neutral\";\n    }\n}\n\nmy $analyzer = SentimentAnalyzer.new;\nsay $analyzer.analyze(\"This is ambiguous text with happy moments.\");\nsay $analyzer.analyze(\"This is a happy story.\");\nsay $analyzer.analyze(\"This is a sad story.\");\n```"
  },
  {
    "task": "Develop a function that manages user authentication and handles credential mismatch exceptions.",
    "code": "```raku\nclass CredentialMismatchException is Exception {\n    has $.message;\n    method message() { $!message }\n}\n\nsub authenticate-user($username, $password) {\n    # Simulated user credentials\n    my %valid-users = (\n        'user1' => 'password123',\n        'user2' => 'securepass',\n    );\n\n    if %valid-users{$username}:exists && %valid-users{$username} eq $password {\n        return \"Authentication successful for $username\";\n    }\n    else {\n        die CredentialMismatchException.new(message => \"Invalid credentials for $username\");\n    }\n}\n\nsub handle-authentication($username, $password) {\n    try {\n        my $result = authenticate-user($username, $password);\n        say $result;\n    }\n    CATCH {\n        when CredentialMismatchException {\n            say \"Authentication failed: \", .message;\n        }\n        default {\n            say \"An unexpected error occurred: \", $_.message;\n        }\n    }\n}\n\n# Example usage\nhandle-authentication('user1', 'password123'); # Should succeed\nhandle-authentication('user1', 'wrongpassword'); # Should fail\n```"
  },
  {
    "task": "Write a program that processes geographic data and handles exceptions for invalid coordinates.",
    "code": "```raku\nsub process-coordinates(@coords) {\n    for @coords -> $coord {\n        try {\n            CATCH {\n                when X::AdHoc {\n                    say \"Error: {$_.message}\";\n                }\n            }\n            my ($lat, $lon) = $coord.split(',');\n            die \"Invalid latitude: $lat\" unless $lat ~~ /^ <-[+-.]>? \\d+ [.]? \\d* $/ && $lat >= -90 && $lat <= 90;\n            die \"Invalid longitude: $lon\" unless $lon ~~ /^ <-[+-.]>? \\d+ [.]? \\d* $/ && $lon >= -180 && $lon <= 180;\n            say \"Processing coordinate: ($lat, $lon)\";\n        }\n    }\n}\n\nmy @geographic-data = <34.0522,-118.2437 91.0000,0.0000 -45.0000,181.0000>;\nprocess-coordinates(@geographic-data);\n```"
  },
  {
    "task": "Create a script that manages network configurations and handles exceptions for invalid syntax.",
    "code": "```raku\nclass NetworkConfig {\n    has %.configurations;\n\n    method add-config(Str $key, Str $value) {\n        if $key ~~ / ^ \\w+ $ / && $value ~~ / ^ \\S+ $ / {\n            %.configurations{$key} = $value;\n            say \"Added configuration: $key = $value\";\n        }\n        else {\n            die \"Invalid syntax for configuration: $key = $value\";\n        }\n    }\n}\n\nsub MAIN() {\n    my $config-manager = NetworkConfig.new;\n\n    try {\n        $config-manager.add-config('ip_address', '192.168.1.1');\n        CATCH {\n            default {\n                say \"Caught exception: $_\";\n            }\n        }\n    }\n\n    try {\n        $config-manager.add-config('invalid key', 'value');\n        CATCH {\n            default {\n                say \"Caught exception: $_\";\n            }\n        }\n    }\n}\n```"
  },
  {
    "task": "Design a function that processes biometric data and handles exceptions for sensor errors.",
    "code": "```raku\nsub process-biometric-data($data) {\n    try {\n        # Simulated processing of biometric data\n        die \"Sensor error: invalid data\" unless $data.defined && $data.chars > 0;\n        \n        # Process the data\n        say \"Processing biometric data: $data\";\n    }\n    CATCH {\n        when X::AdHoc {\n            say \"Caught exception: {.message}\";\n        }\n    }\n}\n\n# Example usage\nprocess-biometric-data(\"valid data\");\nprocess-biometric-data(\"\");\n```"
  },
  {
    "task": "Implement a system that manages access control and handles exceptions for unauthorized access attempts.",
    "code": "```raku\nclass AccessControl {\n    has @.authorized-users;\n\n    method add-user(Str $user) {\n        @!authorized-users.push($user);\n    }\n\n    method remove-user(Str $user) {\n        @!authorized-users .= grep({ $_ ne $user }, @!authorized-users);\n    }\n\n    method check-access(Str $user) {\n        if $user \u2208 @!authorized-users {\n            return True;\n        }\n        else {\n            die \"Unauthorized access attempt by $user\";\n        }\n    }\n}\n\nmy $access-control = AccessControl.new;\n\n$access-control.add-user('Alice');\n$access-control.add-user('Bob');\n\nfor 'Alice', 'Charlie', 'Bob', 'Eve' -> $user {\n    try {\n        if $access-control.check-access($user) {\n            say \"$user has access.\";\n        }\n    }\n    CATCH {\n        default {\n            say .^name, \": \", .Str;\n        }\n    }\n}\n```"
  },
  {
    "task": "Write a function that performs load balancing and handles exceptions for unreachable nodes.",
    "code": "```raku\nsub perform-load-balancing(@nodes) {\n    for @nodes -> $node {\n        try {\n            # Simulate connecting to the node\n            connect-to-node($node);\n            CATCH {\n                default {\n                    say \"Node $node is unreachable: $_\";\n                }\n            }\n        }\n    }\n}\n\nsub connect-to-node($node) {\n    # Simulate a failure to connect to some nodes\n    die \"Connection failed\" if $node eq 'unreachable-node';\n    say \"Connected to $node successfully\";\n}\n\nmy @nodes = <node1 node2 unreachable-node node3>;\nperform-load-balancing(@nodes);\n```"
  },
  {
    "task": "Create a program that simulates virtual environments and manages resource allocation exceptions.",
    "code": "```raku\nclass VirtualEnvironment {\n    has $.name;\n    has $.resources;\n\n    method allocate-resources(Int $requested) {\n        try {\n            if $requested > $.resources {\n                die \"Not enough resources available\";\n            } else {\n                say \"Allocating $requested resources\";\n                $.resources -= $requested;\n            }\n        }\n        CATCH {\n            default {\n                say \"Error: $_\";\n            }\n        }\n    }\n}\n\nsub MAIN() {\n    my $env = VirtualEnvironment.new(name => 'TestEnv', resources => 10);\n    $env.allocate-resources(5);\n    $env.allocate-resources(10);\n}\n```"
  },
  {
    "task": "Develop a tool that manages digital rights and handles exceptions for unauthorized content access.",
    "code": "```raku\nclass DigitalRightsManager {\n    has %!authorized-content;\n\n    method add-authorized-content(Str $content-id) {\n        %!authorized-content{$content-id} = True;\n    }\n\n    method access-content(Str $content-id) {\n        try {\n            unless %!authorized-content{$content-id} {\n                die \"Unauthorized access to content: $content-id\";\n            }\n            say \"Access granted to content: $content-id\";\n        }\n        CATCH {\n            default {\n                say \"Exception caught: $_\";\n            }\n        }\n    }\n}\n\nmy $drm = DigitalRightsManager.new;\n$drm.add-authorized-content(\"content-123\");\n\n$drm.access-content(\"content-123\");  # Authorized access\n$drm.access-content(\"content-999\");  # Unauthorized access\n```"
  },
  {
    "task": "Design a function that synchronizes clocks and handles exceptions for time drift.",
    "code": "```raku\nsub synchronize-clocks($time1, $time2) {\n    try {\n        my $drift = $time1 - $time2;\n        if $drift.abs > 10 {\n            die \"Time drift too large: $drift seconds\";\n        }\n        $time2 += $drift;\n        return $time2;\n    }\n    CATCH {\n        when X::AdHoc {\n            say \"Exception caught: $_.message\";\n        }\n    }\n}\n\n# Example usage\nmy $clock1 = 1000;\nmy $clock2 = 990;\nmy $synchronized-time = synchronize-clocks($clock1, $clock2);\nsay \"Synchronized time: $synchronized-time\";\n```"
  },
  {
    "task": "Write a script that manages system backups and handles exceptions for insufficient backup space.",
    "code": "```raku\nsub check_backup_space(Int $required_space) {\n    my $available_space = 10; # Assume this value is fetched from the system\n    die \"Insufficient backup space.\" if $required_space > $available_space;\n}\n\nsub perform_backup {\n    # Logic for performing the backup\n    say \"Backup completed successfully!\";\n}\n\nsub MAIN(Int $required_space) {\n    try {\n        check_backup_space($required_space);\n        perform_backup();\n        CATCH {\n            when X::AdHoc {\n                say \"Backup failed: $_\";\n            }\n        }\n    }\n}\n```"
  },
  {
    "task": "Create a program that processes natural language text and handles parsing exceptions.",
    "code": "```raku\nclass TextParser {\n    method parse(Str $text) {\n        try {\n            # Simulate parsing logic\n            die \"Parsing exception\" if $text.chars < 5;\n            return \"Parsed text: {$text}\";\n            CATCH {\n                when X::AdHoc {\n                    say \"Caught exception: $_\";\n                }\n            }\n        }\n    }\n}\n\nmy $parser = TextParser.new;\nmy $result = $parser.parse(\"Hello, World!\");\nsay $result if $result;\n\n$result = $parser.parse(\"Hi!\");\nsay $result if $result;\n```"
  },
  {
    "task": "Implement a function that manages thread execution and handles race condition exceptions.",
    "code": "```raku\nuse v6;\n\nclass RaceConditionException is Exception {\n    has $.details;\n    method message() { \"Race condition detected: $!details\" }\n}\n\nsub manage-thread-execution() {\n    my $lock = Lock.new;\n    my $shared-resource = 0;\n\n    my $worker = sub {\n        $lock.protect({\n            try {\n                my $local = $shared-resource;\n                sleep 0.01; # Simulate some processing time\n                $local++;\n                if rand < 0.1 { # Simulate a potential race condition\n                    die RaceConditionException.new(details => \"Simulated race condition\");\n                }\n                $shared-resource = $local;\n            }\n            CATCH {\n                when RaceConditionException {\n                    warn .message;\n                }\n            }\n        });\n    };\n\n    await do for 1..10 {\n        start $worker;\n    }\n\n    say \"Final shared resource value: $shared-resource\";\n}\n\nmanage-thread-execution();\n```"
  },
  {
    "task": "Develop a system that integrates with IoT devices and handles connectivity exceptions.",
    "code": "```raku\nclass IoTDevice {\n    method connect {\n        # Simulate a connection attempt\n        if Bool.pick {\n            die \"Connectivity Exception: Unable to connect to device\";\n        }\n        \"Connected successfully\";\n    }\n}\n\nsub handle-connection(IoTDevice $device) {\n    try {\n        my $result = $device.connect;\n        say $result;\n        CATCH {\n            default {\n                say \"Exception Caught: $_\";\n            }\n        }\n    }\n}\n\nmy $device = IoTDevice.new;\nhandle-connection($device);\n```"
  },
  {
    "task": "Write a function that manages application logging and handles exceptions for log overflow.",
    "code": "```raku\nsub manage-logging(@log-entries, $max-entries) {\n    try {\n        if @log-entries.elems > $max-entries {\n            die \"Log overflow: maximum entries exceeded\";\n        }\n        for @log-entries -> $entry {\n            # Simulate logging the entry\n            say \"Log: $entry\";\n        }\n        CATCH {\n            when X::AdHoc {\n                say \"Exception caught: $_\";\n                # Handle the log overflow exception\n            }\n        }\n    }\n}\n\n# Example usage\nmy @logs = <entry1 entry2 entry3>;\nmanage-logging(@logs, 2);\n```"
  },
  {
    "task": "Create a tool that visualizes data and handles exceptions for unsupported visualization types.",
    "code": "```raku\nclass DataVisualizer {\n    has %!data;\n\n    method new(%data) {\n        self.bless(*, :%data);\n    }\n\n    method visualize($type) {\n        try {\n            given $type {\n                when 'bar'   { self.visualize-bar }\n                when 'line'  { self.visualize-line }\n                when 'pie'   { self.visualize-pie }\n                default {\n                    die \"Unsupported visualization type: $type\";\n                }\n            }\n            CATCH {\n                default {\n                    say \"An error occurred: $_\";\n                }\n            }\n        }\n    }\n\n    method visualize-bar {\n        # Visualization logic for bar chart\n        say \"Visualizing bar chart...\";\n    }\n\n    method visualize-line {\n        # Visualization logic for line chart\n        say \"Visualizing line chart...\";\n    }\n\n    method visualize-pie {\n        # Visualization logic for pie chart\n        say \"Visualizing pie chart...\";\n    }\n}\n\nmy %data = (\n    'A' => 10,\n    'B' => 20,\n    'C' => 30,\n);\n\nmy $visualizer = DataVisualizer.new(%data);\n$visualizer.visualize('bar');   # Supported\n$visualizer.visualize('scatter'); # Unsupported\n```"
  },
  {
    "task": "Design a program that performs genetic algorithm simulations and manages exception for invalid mutations.",
    "code": "```raku\nclass GeneticAlgorithm {\n    method simulate() {\n        try {\n            self.perform-mutation();\n            CATCH {\n                default {\n                    say \"Caught an exception: $_\";\n                }\n            }\n        }\n    }\n\n    method perform-mutation() {\n        my $is-valid = Bool.pick; # Randomly decide if mutation is valid\n        unless $is-valid {\n            die \"Invalid mutation occurred!\";\n        }\n        say \"Mutation performed successfully.\";\n    }\n}\n\nmy $ga = GeneticAlgorithm.new;\n$ga.simulate();\n```"
  },
  {
    "task": "Implement a function that manages distributed transactions and handles consistency exceptions.",
    "code": "```raku\nclass ConsistencyException is Exception {\n    has Str $.message;\n    method message() { $!message }\n}\n\nclass TransactionManager {\n    method manage-transactions(@transactions) {\n        for @transactions -> $transaction {\n            try {\n                $transaction();\n                CATCH {\n                    when ConsistencyException {\n                        .message.say;\n                    }\n                }\n            }\n        }\n    }\n}\n\nsub perform-transaction(&transaction) {\n    try {\n        transaction();\n        CATCH {\n            when ConsistencyException {\n                die ConsistencyException.new(message => \"Consistency error detected\");\n            }\n        }\n    }\n}\n\n# Example usage\nmy @transactions = (\n    sub { say \"Transaction 1\"; },\n    sub { die ConsistencyException.new(message => \"Inconsistent state in Transaction 2\"); },\n    sub { say \"Transaction 3\"; }\n);\n\nmy $manager = TransactionManager.new;\n$manager.manage-transactions(@transactions);\n```"
  },
  {
    "task": "Write a function that handles secure communications and manages encryption key exceptions.",
    "code": "```raku\nuse Crypt::Mode::CBC;\nuse Crypt::Cipher::AES;\n\nsub handle-secure-communication(Str $data, Str $key) {\n    my $cipher;\n    try {\n        $cipher = Crypt::Cipher::AES.new(key => $key);\n        CATCH {\n            when X::Crypt::Cipher::AES::KeyLength {\n                say \"Invalid encryption key length: $_\";\n                return;\n            }\n            default {\n                say \"An unexpected error occurred: $_\";\n                return;\n            }\n        }\n    }\n\n    my $cbc = Crypt::Mode::CBC.new($cipher);\n    my $iv = '1234567890123456'; # IV should be 16 bytes for AES\n\n    my $encrypted;\n    try {\n        $encrypted = $cbc.encrypt($data, $iv);\n        CATCH {\n            say \"Encryption failed: $_\";\n            return;\n        }\n    }\n\n    say \"Encrypted data: $encrypted\";\n}\n\nhandle-secure-communication('Sensitive data', 'invalid_key_length');\n```"
  },
  {
    "task": "Create a system that processes sensor data and handles out-of-range value exceptions.",
    "code": "```raku\nclass SensorData {\n    has Num $.value;\n\n    method process() {\n        try {\n            self!validate-value();\n            say \"Value {$!value} is within range.\";\n            CATCH {\n                when X::OutOfRange {\n                    say \"Exception: {$_.message}\";\n                }\n                default {\n                    say \"An unexpected error occurred.\";\n                }\n            }\n        }\n    }\n\n    method !validate-value() {\n        if $.value < 0 || $.value > 100 {\n            die X::OutOfRange.new(message => \"Value {$!value} is out of range.\");\n        }\n    }\n}\n\nclass X::OutOfRange is Exception {\n    has Str $.message;\n}\n\nmy $sensor = SensorData.new(value => 150);\n$sensor.process();\n\n$sensor = SensorData.new(value => 50);\n$sensor.process();\n```"
  },
  {
    "task": "Develop a program that simulates weather patterns and handles model prediction exceptions.",
    "code": "```raku\nclass WeatherModel {\n    method predict-weather() {\n        my @possible-weather = <Sunny Rainy Snowy Windy>;\n        if (rand < 0.1) {\n            die \"Model Prediction Error\";\n        }\n        return @possible-weather.pick;\n    }\n}\n\nsub MAIN {\n    my $model = WeatherModel.new;\n\n    for 1..10 -> $day {\n        try {\n            my $prediction = $model.predict-weather;\n            say \"Day $day: Predicted weather is $prediction\";\n            CATCH {\n                default {\n                    say \"Day $day: Warning, $!\";\n                }\n            }\n        }\n    }\n}\n```"
  },
  {
    "task": "Design a function that manages API versioning and handles backward compatibility exceptions.",
    "code": "```raku\nclass APIVersionException is Exception {\n    has Str $.message;\n    method message(Str:D $msg) {\n        self.bless(:$msg);\n    }\n}\n\nsub handle-api-version(Str $version, Str $endpoint) {\n    try {\n        given $version {\n            when 'v1' {\n                say \"Handling API version 1 for endpoint $endpoint\";\n            }\n            when 'v2' {\n                say \"Handling API version 2 for endpoint $endpoint\";\n            }\n            default {\n                die APIVersionException.message(\"Unsupported API version: $version\");\n            }\n        }\n    }\n    CATCH {\n        default {\n            my $e = $_;\n            say \"Error: \", $e.^name, \" - \", $e.message;\n        }\n    }\n}\n\n# Example usage\nhandle-api-version('v1', '/data');\nhandle-api-version('v3', '/data');\n```"
  },
  {
    "task": "Write a tool that converts character encodings and handles unsupported encoding exceptions.",
    "code": "```raku\nuse Encoding::Decoder;\n\nsub convert-encoding(Str $input, Str $from-encoding, Str $to-encoding) {\n    try {\n        my $decoder = Encoding::Decoder.new(:$from-encoding);\n        my $encoded-bytes = $decoder.decode($input.encode('utf8'));\n        my $output = $encoded-bytes.decode($to-encoding);\n        return $output;\n    }\n    CATCH {\n        when X::Encoding::Decoder {\n            say \"Error: Unsupported encoding '$from-encoding' or '$to-encoding'.\";\n        }\n        default {\n            say \"An unexpected error occurred: $_\";\n        }\n    }\n}\n\n# Example usage:\nmy $input = \"Hello, World!\";\nmy $converted = convert-encoding($input, 'utf-8', 'latin1');\nsay $converted if $converted;\n```"
  },
  {
    "task": "Create a program that handles dynamic content generation and manages template parsing exceptions.",
    "code": "```raku\nclass TemplateParser {\n    method parse(Str $template) {\n        if $template ~~ /<error>/ {\n            die \"Template parsing error: Invalid content detected\";\n        }\n        return \"Parsed content: $template\";\n    }\n}\n\nsub MAIN() {\n    my $template = \"<content><error></content>\"; # Example template\n\n    try {\n        my $parser = TemplateParser.new;\n        my $result = $parser.parse($template);\n        say $result;\n    }\n    CATCH {\n        when X::AdHoc {\n            say \"Caught an exception: $_\";\n        }\n    }\n}\n```"
  },
  {
    "task": "Implement a script that schedules automated tests and handles exceptions for missing test cases.",
    "code": "```raku\nclass TestScheduler {\n    has @.tests;\n\n    method schedule-tests() {\n        for @.tests -> $test {\n            try {\n                $test();\n                CATCH {\n                    when X::AdHoc {\n                        say \"Exception caught: $_.message()\";\n                    }\n                }\n            }\n        }\n    }\n}\n\nsub run-tests() {\n    my @test-cases = (\n        { say \"Test 1: Passed\" },\n        { die \"Test 2: Missing test case\" },\n        { say \"Test 3: Passed\" }\n    );\n\n    my $scheduler = TestScheduler.new(tests => @test-cases);\n    $scheduler.schedule-tests();\n}\n\nrun-tests();\n```"
  },
  {
    "task": "Develop a system that manages virtual machine instances and handles provisioning exceptions.",
    "code": "```raku\nclass VirtualMachine {\n    has $.name;\n    has $.status = 'stopped';\n\n    method provision() {\n        try {\n            # Simulating provisioning logic\n            if (Bool.rand) {\n                die \"Provisioning failed for VM: $!name\";\n            }\n            $.status = 'running';\n            say \"VM $!name provisioned successfully.\";\n        }\n        CATCH {\n            default {\n                say \"An error occurred: $_\";\n            }\n        }\n    }\n}\n\nclass VMManager {\n    has @.vms;\n\n    method add-vm(Str $name) {\n        my $vm = VirtualMachine.new(name => $name);\n        @.vms.push($vm);\n        say \"VM $name added.\";\n    }\n\n    method provision-all() {\n        for @.vms -> $vm {\n            $vm.provision();\n        }\n    }\n}\n\n# Usage\nmy $manager = VMManager.new;\n$manager.add-vm('VM1');\n$manager.add-vm('VM2');\n$manager.provision-all();\n```"
  },
  {
    "task": "Write a function that processes credit scores and handles exceptions for missing credit history.",
    "code": "```raku\nsub process-credit-score($credit-score) {\n    try {\n        die \"Missing credit history\" unless $credit-score.defined;\n        # Process the credit score\n        say \"Credit score is $credit-score\";\n    }\n    CATCH {\n        when X::AdHoc {\n            say \"Exception: $_\";\n        }\n    }\n}\n\n# Example usage\nprocess-credit-score(680);\nprocess-credit-score(Any);\n```"
  },
  {
    "task": "Create a tool that manages digital certificates and handles expiration exceptions.",
    "code": "```raku\nclass CertificateManager {\n    has %!certificates;\n\n    method add-certificate(Str $name, DateTime $expiry-date) {\n        %!certificates{$name} = $expiry-date;\n    }\n\n    method check-expiration(Str $name) {\n        my $current-date = DateTime.now;\n\n        try {\n            my $expiry-date = %!certificates{$name} // die \"Certificate not found\";\n            if $current-date > $expiry-date {\n                die \"Certificate '$name' has expired\";\n            }\n            CATCH {\n                when X::AdHoc { \n                    say .message;\n                }\n            }\n        }\n    }\n}\n\nmy $manager = CertificateManager.new;\n$manager.add-certificate('cert1', DateTime.new('2023-01-01T00:00:00Z'));\n$manager.check-expiration('cert1'); # This will trigger an exception if expired\n$manager.check-expiration('cert2'); # This will trigger an exception if not found\n```"
  },
  {
    "task": "Design a program that processes genome sequences and handles exceptions for sequence alignment.",
    "code": "```raku\nsub process-genome-sequences(@sequences) {\n    try {\n        for @sequences -> $seq {\n            # Simulate sequence alignment\n            my $alignment = align-sequence($seq);\n            say \"Aligned sequence: $alignment\";\n        }\n    }\n    CATCH {\n        default {\n            say \"An error occurred during sequence processing: $_\";\n        }\n    }\n}\n\nsub align-sequence($sequence) {\n    # Simulate possible error during alignment\n    die \"Invalid sequence: $sequence\" if $sequence.chars < 5;\n    return $sequence.flip;  # Example operation for alignment\n}\n\nmy @genome-sequences = <ATGC ATG ACGTA ATGCGTA>;\nprocess-genome-sequences(@genome-sequences);\n```"
  }
]