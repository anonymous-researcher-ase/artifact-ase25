[
  {
    "task": "Create a list of the first ten positive integers and calculate their sum.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tnumbers := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\n\tsum := 0\n\n\tfor _, number := range numbers {\n\t\tsum += number\n\t}\n\n\tfmt.Println(\"Sum:\", sum)\n}\n```"
  },
  {
    "task": "Write a program to reverse the order of elements in a given list.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc reverseList(list []int) []int {\n\tn := len(list)\n\treversed := make([]int, n)\n\tfor i, v := range list {\n\t\treversed[n-i-1] = v\n\t}\n\treturn reversed\n}\n\nfunc main() {\n\tlist := []int{1, 2, 3, 4, 5}\n\treversedList := reverseList(list)\n\tfmt.Println(reversedList)\n}\n```"
  },
  {
    "task": "Implement a function that takes a list and returns the list with duplicates removed.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc removeDuplicates(list []int) []int {\n\tseen := make(map[int]bool)\n\tresult := []int{}\n\t\n\tfor _, item := range list {\n\t\tif !seen[item] {\n\t\t\tseen[item] = true\n\t\t\tresult = append(result, item)\n\t\t}\n\t}\n\t\n\treturn result\n}\n\nfunc main() {\n\tlist := []int{1, 2, 3, 2, 1, 4, 5}\n\tfmt.Println(removeDuplicates(list))\n}\n```"
  },
  {
    "task": "Create a list of names and sort them in alphabetical order.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\nfunc main() {\n\tnames := []string{\"John\", \"Alice\", \"Bob\", \"Diana\"}\n\tsort.Strings(names)\n\tfmt.Println(names)\n}\n```"
  },
  {
    "task": "Write a function that appends a new element to an existing list.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc appendElement(list []int, element int) []int {\n\treturn append(list, element)\n}\n\nfunc main() {\n\texistingList := []int{1, 2, 3}\n\tnewList := appendElement(existingList, 4)\n\tfmt.Println(newList)\n}\n```"
  },
  {
    "task": "Generate a list of the first 20 even numbers.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tevenNumbers := make([]int, 0, 20)\n\tfor i := 1; i <= 20; i++ {\n\t\tevenNumbers = append(evenNumbers, i*2)\n\t}\n\tfmt.Println(evenNumbers)\n}\n```"
  },
  {
    "task": "Create a nested list (a list of lists) and access an element from the inner list.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\t// Create a nested list (a slice of slices)\n\tnestedList := [][]int{\n\t\t{1, 2, 3},\n\t\t{4, 5, 6},\n\t\t{7, 8, 9},\n\t}\n\n\t// Access an element from the inner list\n\telement := nestedList[1][2]\n\n\t// Print the accessed element\n\tfmt.Println(element)\n}\n```"
  },
  {
    "task": "Write a program that finds the maximum value in a list of integers.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc findMax(nums []int) int {\n\tif len(nums) == 0 {\n\t\tpanic(\"List is empty\")\n\t}\n\tmaxValue := nums[0]\n\tfor _, num := range nums {\n\t\tif num > maxValue {\n\t\t\tmaxValue = num\n\t\t}\n\t}\n\treturn maxValue\n}\n\nfunc main() {\n\tlist := []int{10, 5, 7, 21, 13}\n\tmaxValue := findMax(list)\n\tfmt.Println(\"The maximum value is:\", maxValue)\n}\n```"
  },
  {
    "task": "Implement a function to merge two lists into a single list without duplicates.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc mergeLists(list1, list2 []int) []int {\n\tunique := make(map[int]bool)\n\tvar mergedList []int\n\n\tfor _, item := range list1 {\n\t\tif !unique[item] {\n\t\t\tunique[item] = true\n\t\t\tmergedList = append(mergedList, item)\n\t\t}\n\t}\n\tfor _, item := range list2 {\n\t\tif !unique[item] {\n\t\t\tunique[item] = true\n\t\t\tmergedList = append(mergedList, item)\n\t\t}\n\t}\n\n\treturn mergedList\n}\n\nfunc main() {\n\tlist1 := []int{1, 2, 3, 4}\n\tlist2 := []int{3, 4, 5, 6}\n\tmergedList := mergeLists(list1, list2)\n\tfmt.Println(mergedList)\n}\n```"
  },
  {
    "task": "Create a list from user input, then display the list in reverse order.",
    "code": "```go\npackage main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc main() {\n\tscanner := bufio.NewScanner(os.Stdin)\n\tfmt.Println(\"Enter elements of the list (press Enter after each element, and an empty line to finish):\")\n\tvar list []string\n\n\t// Read user input until an empty line is entered\n\tfor scanner.Scan() {\n\t\tinput := scanner.Text()\n\t\tif input == \"\" {\n\t\t\tbreak\n\t\t}\n\t\tlist = append(list, input)\n\t}\n\n\t// Display the list in reverse order\n\tfmt.Println(\"List in reverse order:\")\n\tfor i := len(list) - 1; i >= 0; i-- {\n\t\tfmt.Println(list[i])\n\t}\n}\n```"
  },
  {
    "task": "Write a function that takes a list and returns a new list containing only the even numbers.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc filterEvenNumbers(numbers []int) []int {\n\tvar evens []int\n\tfor _, n := range numbers {\n\t\tif n%2 == 0 {\n\t\t\tevens = append(evens, n)\n\t\t}\n\t}\n\treturn evens\n}\n\nfunc main() {\n\tnumbers := []int{1, 2, 3, 4, 5, 6}\n\tevens := filterEvenNumbers(numbers)\n\tfmt.Println(evens)\n}\n```"
  },
  {
    "task": "Generate a list of squares for the numbers 1 through 10.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\tsquares := make([]int, 0, 10)\n\tfor i := 1; i <= 10; i++ {\n\t\tsquares = append(squares, i*i)\n\t}\n\tfmt.Println(squares)\n}\n```"
  },
  {
    "task": "Create a list of floating-point numbers and find their average.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tnumbers := []float64{1.5, 2.5, 3.5, 4.5, 5.5}\n\tsum := 0.0\n\tfor _, num := range numbers {\n\t\tsum += num\n\t}\n\taverage := sum / float64(len(numbers))\n\tfmt.Println(\"Average:\", average)\n}\n```"
  },
  {
    "task": "Implement a program to rotate the elements of a list to the right by a given number of steps.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc rotateRight(nums []int, steps int) []int {\n\tn := len(nums)\n\tif n == 0 || steps <= 0 || steps%n == 0 {\n\t\treturn nums\n\t}\n\tsteps = steps % n\n\treturn append(nums[n-steps:], nums[:n-steps]...)\n}\n\nfunc main() {\n\tnums := []int{1, 2, 3, 4, 5}\n\tsteps := 2\n\tresult := rotateRight(nums, steps)\n\tfmt.Println(result)\n}\n```"
  },
  {
    "task": "Write a function that checks if a list is a palindrome (reads the same forwards and backwards).",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc isPalindrome(list []int) bool {\n\tn := len(list)\n\tfor i := 0; i < n/2; i++ {\n\t\tif list[i] != list[n-i-1] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc main() {\n\ttestList := []int{1, 2, 3, 2, 1}\n\tfmt.Println(isPalindrome(testList)) // Output: true\n\n\ttestList = []int{1, 2, 3, 4, 5}\n\tfmt.Println(isPalindrome(testList)) // Output: false\n}\n```"
  },
  {
    "task": "Create a list of random integers and count how many are greater than 50.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc main() {\n\trand.Seed(time.Now().UnixNano())\n\tlist := make([]int, 10)\n\tcount := 0\n\n\tfor i := range list {\n\t\tlist[i] = rand.Intn(100)\n\t\tif list[i] > 50 {\n\t\t\tcount++\n\t\t}\n\t}\n\n\tfmt.Println(\"List:\", list)\n\tfmt.Println(\"Count of numbers greater than 50:\", count)\n}\n```"
  },
  {
    "task": "Write a program that removes the first occurrence of a specified element from a list.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc removeFirstOccurrence(slice []int, element int) []int {\n\tfor i, v := range slice {\n\t\tif v == element {\n\t\t\treturn append(slice[:i], slice[i+1:]...)\n\t\t}\n\t}\n\treturn slice\n}\n\nfunc main() {\n\tlist := []int{1, 2, 3, 4, 2, 5}\n\telementToRemove := 2\n\tnewList := removeFirstOccurrence(list, elementToRemove)\n\tfmt.Println(newList)\n}\n```"
  },
  {
    "task": "Implement a function that takes two lists and returns a list containing their intersection.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc intersection(list1, list2 []int) []int {\n    m := make(map[int]bool)\n    for _, item := range list1 {\n        m[item] = true\n    }\n\n    var result []int\n    for _, item := range list2 {\n        if _, found := m[item]; found {\n            result = append(result, item)\n            delete(m, item)\n        }\n    }\n\n    return result\n}\n\nfunc main() {\n    list1 := []int{1, 2, 3, 4, 5}\n    list2 := []int{3, 4, 5, 6, 7}\n    fmt.Println(intersection(list1, list2)) // Output: [3 4 5]\n}\n```"
  },
  {
    "task": "Create a list of prime numbers less than 100.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc isPrime(n int) bool {\n\tif n <= 1 {\n\t\treturn false\n\t}\n\tfor i := 2; i*i <= n; i++ {\n\t\tif n%i == 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc main() {\n\tvar primes []int\n\tfor i := 2; i < 100; i++ {\n\t\tif isPrime(i) {\n\t\t\tprimes = append(primes, i)\n\t\t}\n\t}\n\tfmt.Println(primes)\n}\n```"
  },
  {
    "task": "Write a function to split a list into two lists: one with even numbers and one with odd numbers.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc splitEvenOdd(numbers []int) (evenNumbers []int, oddNumbers []int) {\n\tfor _, num := range numbers {\n\t\tif num%2 == 0 {\n\t\t\tevenNumbers = append(evenNumbers, num)\n\t\t} else {\n\t\t\toddNumbers = append(oddNumbers, num)\n\t\t}\n\t}\n\treturn\n}\n\nfunc main() {\n\tnumbers := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}\n\tevens, odds := splitEvenOdd(numbers)\n\tfmt.Println(\"Even numbers:\", evens)\n\tfmt.Println(\"Odd numbers:\", odds)\n}\n```"
  },
  {
    "task": "Create a list of strings and convert all the strings to uppercase.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc main() {\n\tstringsList := []string{\"hello\", \"world\", \"golang\", \"programming\"}\n\tfor i, str := range stringsList {\n\t\tstringsList[i] = strings.ToUpper(str)\n\t}\n\tfmt.Println(stringsList)\n}\n```"
  },
  {
    "task": "Implement a program that removes all elements from a list that are less than a specified value.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc filterList(input []int, threshold int) []int {\n\tvar result []int\n\tfor _, value := range input {\n\t\tif value >= threshold {\n\t\t\tresult = append(result, value)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc main() {\n\tlist := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\n\tthreshold := 5\n\tfilteredList := filterList(list, threshold)\n\tfmt.Println(filteredList)\n}\n```"
  },
  {
    "task": "Write a function that takes a list and returns a new list with elements in random order.",
    "code": "```go\npackage main\n\nimport (\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc shuffleList(input []int) []int {\n\trand.Seed(time.Now().UnixNano())\n\tshuffled := make([]int, len(input))\n\tperm := rand.Perm(len(input))\n\tfor i, v := range perm {\n\t\tshuffled[v] = input[i]\n\t}\n\treturn shuffled\n}\n\nfunc main() {\n\tlist := []int{1, 2, 3, 4, 5}\n\tshuffledList := shuffleList(list)\n\tfmt.Println(shuffledList)\n}\n```"
  },
  {
    "task": "Create a list of tuples where each tuple contains a number and its square.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tnumbers := []int{1, 2, 3, 4, 5}\n\tvar listOfTuples [][2]int\n\n\tfor _, num := range numbers {\n\t\tlistOfTuples = append(listOfTuples, [2]int{num, num * num})\n\t}\n\n\tfmt.Println(listOfTuples)\n}\n```"
  },
  {
    "task": "Write a program to multiply all elements in a list by a given factor.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc multiplyListElements(list []int, factor int) []int {\n\tfor i := range list {\n\t\tlist[i] *= factor\n\t}\n\treturn list\n}\n\nfunc main() {\n\tlist := []int{1, 2, 3, 4, 5}\n\tfactor := 3\n\tresult := multiplyListElements(list, factor)\n\tfmt.Println(result)\n}\n```"
  },
  {
    "task": "Implement a function that flattens a nested list.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc flatten(nestedList []interface{}) []interface{} {\n\tvar flatList []interface{}\n\tfor _, item := range nestedList {\n\t\tswitch v := item.(type) {\n\t\tcase []interface{}:\n\t\t\tflatList = append(flatList, flatten(v)...)\n\t\tdefault:\n\t\t\tflatList = append(flatList, v)\n\t\t}\n\t}\n\treturn flatList\n}\n\nfunc main() {\n\tnestedList := []interface{}{1, []interface{}{2, 3, []interface{}{4, 5}}, 6}\n\tflatList := flatten(nestedList)\n\tfmt.Println(flatList)\n}\n```"
  },
  {
    "task": "Create a list of dates and sort them chronologically.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n\t\"time\"\n)\n\nfunc main() {\n\tdates := []string{\n\t\t\"2023-10-01\",\n\t\t\"2021-06-25\",\n\t\t\"2022-12-15\",\n\t}\n\n\tvar parsedDates []time.Time\n\tfor _, date := range dates {\n\t\tparsedDate, _ := time.Parse(\"2006-01-02\", date)\n\t\tparsedDates = append(parsedDates, parsedDate)\n\t}\n\n\tsort.Slice(parsedDates, func(i, j int) bool {\n\t\treturn parsedDates[i].Before(parsedDates[j])\n\t})\n\n\tfor _, date := range parsedDates {\n\t\tfmt.Println(date.Format(\"2006-01-02\"))\n\t}\n}\n```"
  },
  {
    "task": "Write a function that finds the index of the first occurrence of a given element in a list.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc indexOfFirstOccurrence(list []int, element int) int {\n    for i, v := range list {\n        if v == element {\n            return i\n        }\n    }\n    return -1\n}\n\nfunc main() {\n    list := []int{1, 2, 3, 4, 5}\n    element := 3\n    fmt.Println(indexOfFirstOccurrence(list, element))\n}\n```"
  },
  {
    "task": "Generate a list of Fibonacci numbers up to a specified limit.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc generateFibonacci(limit int) []int {\n\tif limit < 1 {\n\t\treturn []int{}\n\t}\n\n\tfibList := []int{0, 1}\n\tfor {\n\t\tnextFib := fibList[len(fibList)-1] + fibList[len(fibList)-2]\n\t\tif nextFib > limit {\n\t\t\tbreak\n\t\t}\n\t\tfibList = append(fibList, nextFib)\n\t}\n\treturn fibList\n}\n\nfunc main() {\n\tlimit := 100 // Example limit\n\tfibList := generateFibonacci(limit)\n\tfmt.Println(fibList)\n}\n```"
  },
  {
    "task": "Create a list of booleans and determine if all are True.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    boolList := []bool{true, true, true, false, true}\n\n    allTrue := true\n    for _, value := range boolList {\n        if !value {\n            allTrue = false\n            break\n        }\n    }\n\n    fmt.Println(\"All values are true:\", allTrue)\n}\n```"
  },
  {
    "task": "Write a program to concatenate two lists.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tlist1 := []int{1, 2, 3}\n\tlist2 := []int{4, 5, 6}\n\tconcatenatedList := append(list1, list2...)\n\tfmt.Println(concatenatedList)\n}\n```"
  },
  {
    "task": "Implement a function that returns the length of a list without using built-in functions.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc listLength(lst []int) int {\n\tlength := 0\n\tfor range lst {\n\t\tlength++\n\t}\n\treturn length\n}\n\nfunc main() {\n\tlist := []int{1, 2, 3, 4}\n\tfmt.Println(listLength(list)) // Output: 4\n}\n```"
  },
  {
    "task": "Create a list of words and find the longest word.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\twords := []string{\"apple\", \"banana\", \"cherry\", \"blueberry\", \"kiwi\"}\n\tlongestWord := findLongestWord(words)\n\tfmt.Println(\"The longest word is:\", longestWord)\n}\n\nfunc findLongestWord(words []string) string {\n\tvar longest string\n\tfor _, word := range words {\n\t\tif len(word) > len(longest) {\n\t\t\tlongest = word\n\t\t}\n\t}\n\treturn longest\n}\n```"
  },
  {
    "task": "Write a function that takes a list and a predicate function, returning a list of elements that satisfy the predicate.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc filterList(list []int, predicate func(int) bool) []int {\n\tvar result []int\n\tfor _, item := range list {\n\t\tif predicate(item) {\n\t\t\tresult = append(result, item)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc main() {\n\tlist := []int{1, 2, 3, 4, 5}\n\tpredicate := func(x int) bool { return x%2 == 0 }\n\tfiltered := filterList(list, predicate)\n\tfmt.Println(filtered)\n}\n```"
  },
  {
    "task": "Generate a list of strings and filter out those with less than 5 characters.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc filterStrings(input []string) []string {\n\tvar result []string\n\tfor _, str := range input {\n\t\tif len(str) >= 5 {\n\t\t\tresult = append(result, str)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc main() {\n\tstrings := []string{\"apple\", \"go\", \"banana\", \"kiwi\", \"grape\"}\n\tfiltered := filterStrings(strings)\n\tfmt.Println(filtered)\n}\n```"
  },
  {
    "task": "Create a list of mixed data types and separate them into lists by type.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n)\n\nfunc main() {\n\tmixedList := []interface{}{1, \"two\", 3.0, \"four\", 5, 6.7}\n\tintList := []int{}\n\tstringList := []string{}\n\tfloatList := []float64{}\n\n\tfor _, item := range mixedList {\n\t\tswitch v := item.(type) {\n\t\tcase int:\n\t\t\tintList = append(intList, v)\n\t\tcase string:\n\t\t\tstringList = append(stringList, v)\n\t\tcase float64:\n\t\t\tfloatList = append(floatList, v)\n\t\tdefault:\n\t\t\tfmt.Printf(\"Unhandled type: %s\\n\", reflect.TypeOf(item))\n\t\t}\n\t}\n\n\tfmt.Println(\"Integers:\", intList)\n\tfmt.Println(\"Strings:\", stringList)\n\tfmt.Println(\"Floats:\", floatList)\n}\n```"
  },
  {
    "task": "Write a program to find the common elements between two lists.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tlist1 := []int{1, 2, 3, 4, 5}\n\tlist2 := []int{4, 5, 6, 7, 8}\n\n\tcommonElements := findCommonElements(list1, list2)\n\tfmt.Println(\"Common elements:\", commonElements)\n}\n\nfunc findCommonElements(list1, list2 []int) []int {\n\telementMap := make(map[int]bool)\n\tfor _, num := range list1 {\n\t\telementMap[num] = true\n\t}\n\n\tvar common []int\n\tfor _, num := range list2 {\n\t\tif elementMap[num] {\n\t\t\tcommon = append(common, num)\n\t\t}\n\t}\n\n\treturn common\n}\n```"
  },
  {
    "task": "Implement a function to rotate the elements of a list to the left by a given number of steps.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc rotateLeft(list []int, steps int) []int {\n\tn := len(list)\n\tif n == 0 {\n\t\treturn list\n\t}\n\tsteps = steps % n\n\treturn append(list[steps:], list[:steps]...)\n}\n\nfunc main() {\n\tlist := []int{1, 2, 3, 4, 5}\n\trotatedList := rotateLeft(list, 2)\n\tfmt.Println(rotatedList)\n}\n```"
  },
  {
    "task": "Create a list of numbers and find the product of all the elements.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tnumbers := []int{1, 2, 3, 4, 5}\n\tproduct := 1\n\tfor _, number := range numbers {\n\t\tproduct *= number\n\t}\n\tfmt.Println(\"Product of all elements:\", product)\n}\n```"
  },
  {
    "task": "Write a function that removes all occurrences of a specified element from a list.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc removeOccurrences(list []int, element int) []int {\n\tresult := []int{}\n\tfor _, v := range list {\n\t\tif v != element {\n\t\t\tresult = append(result, v)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc main() {\n\tlist := []int{1, 2, 3, 4, 2, 5}\n\telement := 2\n\tupdatedList := removeOccurrences(list, element)\n\tfmt.Println(updatedList)\n}\n```"
  },
  {
    "task": "Generate a list of random numbers and find the median value.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"sort\"\n\t\"time\"\n)\n\nfunc main() {\n\trand.Seed(time.Now().UnixNano())\n\tnumbers := make([]int, 10)\n\tfor i := range numbers {\n\t\tnumbers[i] = rand.Intn(100)\n\t}\n\tsort.Ints(numbers)\n\n\tvar median float64\n\tn := len(numbers)\n\tif n%2 == 0 {\n\t\tmedian = float64(numbers[n/2-1]+numbers[n/2]) / 2\n\t} else {\n\t\tmedian = float64(numbers[n/2])\n\t}\n\n\tfmt.Println(\"Numbers:\", numbers)\n\tfmt.Println(\"Median:\", median)\n}\n```"
  },
  {
    "task": "Create a list of dictionaries and sort them by a specific key.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\nfunc main() {\n\t// Create a list of dictionaries\n\tlistOfDicts := []map[string]interface{}{\n\t\t{\"name\": \"Alice\", \"age\": 30},\n\t\t{\"name\": \"Bob\", \"age\": 25},\n\t\t{\"name\": \"Charlie\", \"age\": 35},\n\t}\n\n\t// Sort the list by the \"age\" key\n\tsort.Slice(listOfDicts, func(i, j int) bool {\n\t\treturn listOfDicts[i][\"age\"].(int) < listOfDicts[j][\"age\"].(int)\n\t})\n\n\t// Print the sorted list\n\tfmt.Println(listOfDicts)\n}\n```"
  },
  {
    "task": "Write a program to split a list into chunks of a specified size.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc chunkList(input []int, size int) [][]int {\n\tvar chunks [][]int\n\tfor size < len(input) {\n\t\tinput, chunks = input[size:], append(chunks, input[0:size:size])\n\t}\n\treturn append(chunks, input)\n}\n\nfunc main() {\n\tlist := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}\n\tchunkSize := 3\n\tchunks := chunkList(list, chunkSize)\n\tfmt.Println(chunks)\n}\n```"
  },
  {
    "task": "Implement a function that takes a list and returns a dictionary with the frequency of each element.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc frequencyCounter(list []interface{}) map[interface{}]int {\n\tfrequency := make(map[interface{}]int)\n\tfor _, item := range list {\n\t\tfrequency[item]++\n\t}\n\treturn frequency\n}\n\nfunc main() {\n\tlist := []interface{}{1, \"apple\", 2, \"apple\", 1, 3, \"banana\"}\n\tfrequency := frequencyCounter(list)\n\tfmt.Println(frequency)\n}\n```"
  },
  {
    "task": "Create a list of integers and replace all negative numbers with zero.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tnumbers := []int{-5, 3, -1, 8, -4, 2}\n\n\tfor i, num := range numbers {\n\t\tif num < 0 {\n\t\t\tnumbers[i] = 0\n\t\t}\n\t}\n\n\tfmt.Println(numbers)\n}\n```"
  },
  {
    "task": "Write a function that returns the first n elements of a list.",
    "code": "```go\npackage main\n\nfunc firstNElements(list []int, n int) []int {\n\tif n > len(list) {\n\t\treturn list\n\t}\n\treturn list[:n]\n}\n```"
  },
  {
    "task": "Generate a list of strings and join them into a single string with spaces.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc main() {\n\tstrList := []string{\"This\", \"is\", \"a\", \"list\", \"of\", \"strings\"}\n\tjoinedString := strings.Join(strList, \" \")\n\tfmt.Println(joinedString)\n}\n```"
  },
  {
    "task": "Create a list of lists and find the sum of each inner list.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\t// Create a list of lists\n\tlists := [][]int{\n\t\t{1, 2, 3},\n\t\t{4, 5, 6},\n\t\t{7, 8, 9},\n\t}\n\n\t// Find the sum of each inner list\n\tfor _, list := range lists {\n\t\tsum := 0\n\t\tfor _, num := range list {\n\t\t\tsum += num\n\t\t}\n\t\tfmt.Println(sum)\n\t}\n}\n```"
  },
  {
    "task": "Write a function that finds the second largest number in a list.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc secondLargest(nums []int) int {\n\tif len(nums) < 2 {\n\t\treturn math.MinInt // or handle the error as appropriate\n\t}\n\n\tfirst, second := math.MinInt, math.MinInt\n\tfor _, v := range nums {\n\t\tif v > first {\n\t\t\tfirst, second = v, first\n\t\t} else if v > second && v != first {\n\t\t\tsecond = v\n\t\t}\n\t}\n\n\treturn second\n}\n\nfunc main() {\n\tnumbers := []int{10, 5, 20, 10, 20, 5}\n\tfmt.Println(secondLargest(numbers)) // Should output: 10\n}\n```"
  },
  {
    "task": "Generate a list of numbers and remove the duplicates while maintaining order.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc removeDuplicates(nums []int) []int {\n\tseen := make(map[int]bool)\n\tresult := []int{}\n\tfor _, num := range nums {\n\t\tif !seen[num] {\n\t\t\tseen[num] = true\n\t\t\tresult = append(result, num)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc main() {\n\tnumbers := []int{1, 2, 3, 2, 4, 1, 5}\n\tnumbers = removeDuplicates(numbers)\n\tfmt.Println(numbers)\n}\n```"
  },
  {
    "task": "Create a list of integers and partition it into two lists: one with numbers above the average and one below.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tnumbers := []int{1, 3, 5, 7, 9, 11, 13, 15, 17, 19}\n\tvar sum int\n\tfor _, num := range numbers {\n\t\tsum += num\n\t}\n\taverage := float64(sum) / float64(len(numbers))\n\n\tvar aboveAverage, belowAverage []int\n\tfor _, num := range numbers {\n\t\tif float64(num) > average {\n\t\t\taboveAverage = append(aboveAverage, num)\n\t\t} else {\n\t\t\tbelowAverage = append(belowAverage, num)\n\t\t}\n\t}\n\n\tfmt.Println(\"Above average:\", aboveAverage)\n\tfmt.Println(\"Below average:\", belowAverage)\n}\n```"
  },
  {
    "task": "Write a program to find the longest increasing subsequence in a list of numbers.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc longestIncreasingSubsequence(nums []int) []int {\n\tif len(nums) == 0 {\n\t\treturn []int{}\n\t}\n\n\tlengths := make([]int, len(nums))\n\tsequences := make([]int, len(nums))\n\tfor i := range sequences {\n\t\tsequences[i] = -1\n\t}\n\tmaxLengthIndex := 0\n\n\tfor i := range nums {\n\t\tfor j := 0; j < i; j++ {\n\t\t\tif nums[j] < nums[i] && lengths[j]+1 > lengths[i] {\n\t\t\t\tlengths[i] = lengths[j] + 1\n\t\t\t\tsequences[i] = j\n\t\t\t}\n\t\t}\n\t\tif lengths[i] > lengths[maxLengthIndex] {\n\t\t\tmaxLengthIndex = i\n\t\t}\n\t}\n\n\treturn buildSequence(nums, sequences, maxLengthIndex)\n}\n\nfunc buildSequence(nums []int, sequences []int, currentIndex int) []int {\n\tsequence := []int{}\n\tfor currentIndex != -1 {\n\t\tsequence = append([]int{nums[currentIndex]}, sequence...)\n\t\tcurrentIndex = sequences[currentIndex]\n\t}\n\treturn sequence\n}\n\nfunc main() {\n\tnums := []int{10, 9, 2, 5, 3, 7, 101, 18}\n\tlis := longestIncreasingSubsequence(nums)\n\tfmt.Println(\"Longest Increasing Subsequence:\", lis)\n}\n```"
  },
  {
    "task": "Implement a function to zip two lists into a single list of tuples.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc zipLists(list1, list2 []interface{}) []interface{} {\n\tvar zipped []interface{}\n\tminLen := len(list1)\n\tif len(list2) < minLen {\n\t\tminLen = len(list2)\n\t}\n\tfor i := 0; i < minLen; i++ {\n\t\tzipped = append(zipped, []interface{}{list1[i], list2[i]})\n\t}\n\treturn zipped\n}\n\nfunc main() {\n\tlist1 := []interface{}{1, 2, 3}\n\tlist2 := []interface{}{\"a\", \"b\", \"c\"}\n\tzipped := zipLists(list1, list2)\n\tfmt.Println(zipped)\n}\n```"
  },
  {
    "task": "Create a list of characters and count the vowels.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"unicode\"\n)\n\nfunc main() {\n\tcharacters := []rune{'a', 'b', 'c', 'e', 'i', 'o', 'u', 'x', 'y', 'z'}\n\tvowelCount := 0\n\n\tfor _, char := range characters {\n\t\tswitch unicode.ToLower(char) {\n\t\tcase 'a', 'e', 'i', 'o', 'u':\n\t\t\tvowelCount++\n\t\t}\n\t}\n\n\tfmt.Printf(\"Number of vowels: %d\\n\", vowelCount)\n}\n```"
  },
  {
    "task": "Write a function that returns the last n elements of a list.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc lastNElements(list []int, n int) []int {\n\tif n > len(list) {\n\t\tn = len(list)\n\t}\n\treturn list[len(list)-n:]\n}\n\nfunc main() {\n\tlist := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\n\tn := 3\n\tfmt.Println(lastNElements(list, n))\n}\n```"
  },
  {
    "task": "Generate a list of numbers and split it into two lists: one with positive numbers and one with negative numbers.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tnumbers := []int{10, -5, 20, -15, 30, -25, 40, -35}\n\tvar positiveNumbers []int\n\tvar negativeNumbers []int\n\n\tfor _, num := range numbers {\n\t\tif num > 0 {\n\t\t\tpositiveNumbers = append(positiveNumbers, num)\n\t\t} else if num < 0 {\n\t\t\tnegativeNumbers = append(negativeNumbers, num)\n\t\t}\n\t}\n\n\tfmt.Println(\"Positive numbers:\", positiveNumbers)\n\tfmt.Println(\"Negative numbers:\", negativeNumbers)\n}\n```"
  },
  {
    "task": "Create a list of random integers and find the mode.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc findMode(numbers []int) int {\n\tfrequency := make(map[int]int)\n\tmaxCount := 0\n\tmode := numbers[0]\n\n\tfor _, number := range numbers {\n\t\tfrequency[number]++\n\t\tif frequency[number] > maxCount {\n\t\t\tmaxCount = frequency[number]\n\t\t\tmode = number\n\t\t}\n\t}\n\treturn mode\n}\n\nfunc main() {\n\trand.Seed(time.Now().UnixNano())\n\tnumbers := make([]int, 10)\n\tfor i := range numbers {\n\t\tnumbers[i] = rand.Intn(100)\n\t}\n\tfmt.Println(\"List of random integers:\", numbers)\n\tmode := findMode(numbers)\n\tfmt.Println(\"Mode:\", mode)\n}\n```"
  },
  {
    "task": "Write a program to find the shortest path in a grid using a list to represent the path.",
    "code": "```go\npackage main\n\nimport (\n\t\"container/heap\"\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Point struct {\n\tx, y int\n}\n\ntype Node struct {\n\tpoint    Point\n\tdistance int\n\tpath     []Point\n}\n\ntype PriorityQueue []Node\n\nfunc (pq PriorityQueue) Len() int { return len(pq) }\n\nfunc (pq PriorityQueue) Less(i, j int) bool { return pq[i].distance < pq[j].distance }\n\nfunc (pq PriorityQueue) Swap(i, j int) { pq[i], pq[j] = pq[j], pq[i] }\n\nfunc (pq *PriorityQueue) Push(x interface{}) {\n\t*pq = append(*pq, x.(Node))\n}\n\nfunc (pq *PriorityQueue) Pop() interface{} {\n\told := *pq\n\tn := len(old)\n\titem := old[n-1]\n\t*pq = old[0 : n-1]\n\treturn item\n}\n\nfunc isValid(grid [][]int, visited [][]bool, x, y int) bool {\n\treturn x >= 0 && y >= 0 && x < len(grid) && y < len(grid[0]) && grid[x][y] == 0 && !visited[x][y]\n}\n\nfunc shortestPath(grid [][]int, start, end Point) []Point {\n\tdirections := []Point{{-1, 0}, {1, 0}, {0, -1}, {0, 1}}\n\tvisited := make([][]bool, len(grid))\n\tfor i := range visited {\n\t\tvisited[i] = make([]bool, len(grid[0]))\n\t}\n\n\tpq := &PriorityQueue{}\n\theap.Init(pq)\n\theap.Push(pq, Node{point: start, distance: 0, path: []Point{start}})\n\tvisited[start.x][start.y] = true\n\n\tfor pq.Len() > 0 {\n\t\tnode := heap.Pop(pq).(Node)\n\t\tif node.point == end {\n\t\t\treturn node.path\n\t\t}\n\n\t\tfor _, dir := range directions {\n\t\t\tnewX, newY := node.point.x+dir.x, node.point.y+dir.y\n\t\t\tif isValid(grid, visited, newX, newY) {\n\t\t\t\tnewPath := append([]Point{}, node.path...)\n\t\t\t\tnewPath = append(newPath, Point{newX, newY})\n\t\t\t\theap.Push(pq, Node{\n\t\t\t\t\tpoint:    Point{newX, newY},\n\t\t\t\t\tdistance: node.distance + 1,\n\t\t\t\t\tpath:     newPath,\n\t\t\t\t})\n\t\t\t\tvisited[newX][newY] = true\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc main() {\n\tgrid := [][]int{\n\t\t{0, 1, 0, 0, 0},\n\t\t{0, 1, 0, 1, 0},\n\t\t{0, 0, 0, 1, 0},\n\t\t{0, 1, 0, 0, 0},\n\t\t{0, 0, 0, 1, 0},\n\t}\n\tstart := Point{0, 0}\n\tend := Point{4, 4}\n\n\tpath := shortestPath(grid, start, end)\n\tif path != nil {\n\t\tfmt.Println(\"Shortest Path:\", path)\n\t} else {\n\t\tfmt.Println(\"No path found\")\n\t}\n}\n```"
  },
  {
    "task": "Implement a function that takes a list and returns a list with elements doubled.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc doubleElements(input []int) []int {\n\tresult := make([]int, len(input))\n\tfor i, v := range input {\n\t\tresult[i] = v * 2\n\t}\n\treturn result\n}\n\nfunc main() {\n\tlist := []int{1, 2, 3, 4, 5}\n\tdoubledList := doubleElements(list)\n\tfmt.Println(doubledList)\n}\n```"
  },
  {
    "task": "Create a list of integers and sort them in descending order.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\nfunc main() {\n\tintegers := []int{5, 3, 8, 1, 9, 2}\n\tsort.Sort(sort.Reverse(sort.IntSlice(integers)))\n\tfmt.Println(integers)\n}\n```"
  },
  {
    "task": "Write a function that takes a list of intervals and merges overlapping intervals.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\ntype Interval struct {\n\tStart int\n\tEnd   int\n}\n\nfunc mergeIntervals(intervals []Interval) []Interval {\n\tif len(intervals) == 0 {\n\t\treturn intervals\n\t}\n\n\tsort.Slice(intervals, func(i, j int) bool {\n\t\treturn intervals[i].Start < intervals[j].Start\n\t})\n\n\tmerged := []Interval{intervals[0]}\n\tfor _, current := range intervals[1:] {\n\t\tlast := &merged[len(merged)-1]\n\t\tif current.Start <= last.End {\n\t\t\tif current.End > last.End {\n\t\t\t\tlast.End = current.End\n\t\t\t}\n\t\t} else {\n\t\t\tmerged = append(merged, current)\n\t\t}\n\t}\n\n\treturn merged\n}\n\nfunc main() {\n\tintervals := []Interval{{1, 3}, {2, 6}, {8, 10}, {15, 18}}\n\tmerged := mergeIntervals(intervals)\n\tfor _, interval := range merged {\n\t\tfmt.Printf(\"[%d, %d] \", interval.Start, interval.End)\n\t}\n}\n```"
  },
  {
    "task": "Generate a list of random numbers and find the range (difference between max and min).",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc main() {\n\trand.Seed(time.Now().UnixNano())\n\tnumbers := make([]int, 10)\n\tfor i := range numbers {\n\t\tnumbers[i] = rand.Intn(100) // Random number between 0 and 99\n\t}\n\n\tmin, max := numbers[0], numbers[0]\n\tfor _, num := range numbers {\n\t\tif num < min {\n\t\t\tmin = num\n\t\t}\n\t\tif num > max {\n\t\t\tmax = num\n\t\t}\n\t}\n\n\trangeValue := max - min\n\tfmt.Printf(\"Numbers: %v\\n\", numbers)\n\tfmt.Printf(\"Range: %d\\n\", rangeValue)\n}\n```"
  },
  {
    "task": "Create a list of strings and remove any that are palindromes.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc isPalindrome(s string) bool {\n\tfor i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {\n\t\tif s[i] != s[j] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc removePalindromes(strings []string) []string {\n\tvar result []string\n\tfor _, str := range strings {\n\t\tif !isPalindrome(str) {\n\t\t\tresult = append(result, str)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc main() {\n\tstrings := []string{\"level\", \"world\", \"hello\", \"deed\", \"golang\"}\n\tfilteredStrings := removePalindromes(strings)\n\tfmt.Println(filteredStrings)\n}\n```"
  },
  {
    "task": "Write a program to cyclically permute the elements of a list.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc cyclicPermute(list []int) []int {\n\tif len(list) == 0 {\n\t\treturn list\n\t}\n\tlast := list[len(list)-1]\n\treturn append([]int{last}, list[:len(list)-1]...)\n}\n\nfunc main() {\n\tlist := []int{1, 2, 3, 4, 5}\n\tlist = cyclicPermute(list)\n\tfmt.Println(list)\n}\n```"
  },
  {
    "task": "Implement a function to create a list of cumulative sums from a list of numbers.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc cumulativeSums(nums []int) []int {\n    result := make([]int, len(nums))\n    if len(nums) == 0 {\n        return result\n    }\n    result[0] = nums[0]\n    for i := 1; i < len(nums); i++ {\n        result[i] = result[i-1] + nums[i]\n    }\n    return result\n}\n\nfunc main() {\n    nums := []int{1, 2, 3, 4, 5}\n    fmt.Println(cumulativeSums(nums))\n}\n```"
  },
  {
    "task": "Create a list of numbers and shift all zeros to the end.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc shiftZerosToEnd(nums []int) []int {\n\tnonZeroIndex := 0\n\tfor _, num := range nums {\n\t\tif num != 0 {\n\t\t\tnums[nonZeroIndex] = num\n\t\t\tnonZeroIndex++\n\t\t}\n\t}\n\tfor i := nonZeroIndex; i < len(nums); i++ {\n\t\tnums[i] = 0\n\t}\n\treturn nums\n}\n\nfunc main() {\n\tnumbers := []int{0, 1, 0, 3, 12}\n\tresult := shiftZerosToEnd(numbers)\n\tfmt.Println(result)\n}\n```"
  },
  {
    "task": "Write a program to simulate a queue using a list.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\ntype Queue struct {\n\titems []int\n}\n\nfunc (q *Queue) Enqueue(item int) {\n\tq.items = append(q.items, item)\n}\n\nfunc (q *Queue) Dequeue() (int, bool) {\n\tif len(q.items) == 0 {\n\t\treturn 0, false\n\t}\n\titem := q.items[0]\n\tq.items = q.items[1:]\n\treturn item, true\n}\n\nfunc (q *Queue) IsEmpty() bool {\n\treturn len(q.items) == 0\n}\n\nfunc main() {\n\tq := &Queue{}\n\tq.Enqueue(1)\n\tq.Enqueue(2)\n\tq.Enqueue(3)\n\n\tfor !q.IsEmpty() {\n\t\titem, _ := q.Dequeue()\n\t\tfmt.Println(item)\n\t}\n}\n```"
  },
  {
    "task": "Generate a list of numbers and identify all prime numbers.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc isPrime(n int) bool {\n\tif n <= 1 {\n\t\treturn false\n\t}\n\tif n <= 3 {\n\t\treturn true\n\t}\n\tif n%2 == 0 || n%3 == 0 {\n\t\treturn false\n\t}\n\tfor i := 5; i*i <= n; i += 6 {\n\t\tif n%i == 0 || n%(i+2) == 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc main() {\n\tnumbers := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20}\n\tprimes := []int{}\n\n\tfor _, num := range numbers {\n\t\tif isPrime(num) {\n\t\t\tprimes = append(primes, num)\n\t\t}\n\t}\n\n\tfmt.Println(\"Prime numbers:\", primes)\n}\n```"
  },
  {
    "task": "Create a list of strings and group them by their starting letter.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc groupByStartingLetter(words []string) map[string][]string {\n\tgrouped := make(map[string][]string)\n\tfor _, word := range words {\n\t\tif len(word) > 0 {\n\t\t\tfirstLetter := string(word[0])\n\t\t\tgrouped[firstLetter] = append(grouped[firstLetter], word)\n\t\t}\n\t}\n\treturn grouped\n}\n\nfunc main() {\n\twords := []string{\"apple\", \"banana\", \"apricot\", \"blueberry\", \"cherry\", \"avocado\"}\n\tgrouped := groupByStartingLetter(words)\n\tfmt.Println(grouped)\n}\n```"
  },
  {
    "task": "Write a function that takes a list and returns a new list with all elements squared.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc squareList(lst []int) []int {\n\tsquaredList := make([]int, len(lst))\n\tfor i, v := range lst {\n\t\tsquaredList[i] = v * v\n\t}\n\treturn squaredList\n}\n\nfunc main() {\n\toriginalList := []int{1, 2, 3, 4, 5}\n\tresult := squareList(originalList)\n\tfmt.Println(result)\n}\n```"
  },
  {
    "task": "Generate a list of timestamps and find the time difference between consecutive elements.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\ttimestamps := []time.Time{\n\t\ttime.Now(),\n\t\ttime.Now().Add(10 * time.Minute),\n\t\ttime.Now().Add(20 * time.Minute),\n\t\ttime.Now().Add(40 * time.Minute),\n\t}\n\n\tfor i := 1; i < len(timestamps); i++ {\n\t\tdiff := timestamps[i].Sub(timestamps[i-1])\n\t\tfmt.Println(\"Difference:\", diff)\n\t}\n}\n```"
  },
  {
    "task": "Create a list of numbers and rotate it such that the smallest number is first.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\nfunc rotateList(numbers []int) []int {\n\tsort.Ints(numbers)\n\treturn numbers\n}\n\nfunc main() {\n\tnumbers := []int{3, 5, 1, 4, 2}\n\trotated := rotateList(numbers)\n\tfmt.Println(rotated)\n}\n```"
  },
  {
    "task": "Write a program to find all unique pairs in a list that sum up to a specific target.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc findPairs(nums []int, target int) [][2]int {\n\tseen := make(map[int]bool)\n\tpairs := make(map[[2]int]bool)\n\tvar result [][2]int\n\n\tfor _, num := range nums {\n\t\tcomplement := target - num\n\t\tif seen[complement] {\n\t\t\tpair := [2]int{num, complement}\n\t\t\tif _, exists := pairs[pair]; !exists && !pairs[[2]int{complement, num}] {\n\t\t\t\tpairs[pair] = true\n\t\t\t\tresult = append(result, pair)\n\t\t\t}\n\t\t}\n\t\tseen[num] = true\n\t}\n\n\treturn result\n}\n\nfunc main() {\n\tnums := []int{1, 2, 3, 4, 3, 5, 2, 1}\n\ttarget := 5\n\tpairs := findPairs(nums, target)\n\tfmt.Println(pairs)\n}\n```"
  },
  {
    "task": "Implement a function that returns true if a list contains a cycle.",
    "code": "```go\ntype ListNode struct {\n    Val  int\n    Next *ListNode\n}\n\nfunc hasCycle(head *ListNode) bool {\n    if head == nil {\n        return false\n    }\n\n    slow, fast := head, head.Next\n    for fast != nil && fast.Next != nil {\n        if slow == fast {\n            return true\n        }\n        slow = slow.Next\n        fast = fast.Next.Next\n    }\n    return false\n}\n```"
  },
  {
    "task": "Create a list of numbers and find the contiguous subarray with the maximum sum.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc maxSubArray(nums []int) int {\n\tmaxSoFar := nums[0]\n\tmaxEndingHere := nums[0]\n\tfor i := 1; i < len(nums); i++ {\n\t\tif maxEndingHere < 0 {\n\t\t\tmaxEndingHere = nums[i]\n\t\t} else {\n\t\t\tmaxEndingHere += nums[i]\n\t\t}\n\t\tif maxEndingHere > maxSoFar {\n\t\t\tmaxSoFar = maxEndingHere\n\t\t}\n\t}\n\treturn maxSoFar\n}\n\nfunc main() {\n\tnumbers := []int{-2, 1, -3, 4, -1, 2, 1, -5, 4}\n\tfmt.Println(maxSubArray(numbers))\n}\n```"
  },
  {
    "task": "Write a function that takes a list and a number, and finds two numbers in the list that sum to the given number.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc findTwoSum(nums []int, target int) (int, int, bool) {\n\tnumMap := make(map[int]int)\n\tfor i, num := range nums {\n\t\tcomplement := target - num\n\t\tif index, found := numMap[complement]; found {\n\t\t\treturn complement, num, true\n\t\t}\n\t\tnumMap[num] = i\n\t}\n\treturn 0, 0, false\n}\n\nfunc main() {\n\tnums := []int{2, 7, 11, 15}\n\ttarget := 9\n\tif num1, num2, found := findTwoSum(nums, target); found {\n\t\tfmt.Printf(\"Found numbers: %d and %d\\n\", num1, num2)\n\t} else {\n\t\tfmt.Println(\"No two numbers found\")\n\t}\n}\n```"
  },
  {
    "task": "Generate a list of even numbers and filter out those that are greater than a specific value.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tspecificValue := 10\n\tnumbers := []int{2, 4, 6, 8, 10, 12, 14, 16, 18, 20}\n\tvar filteredNumbers []int\n\n\tfor _, num := range numbers {\n\t\tif num <= specificValue {\n\t\t\tfilteredNumbers = append(filteredNumbers, num)\n\t\t}\n\t}\n\n\tfmt.Println(filteredNumbers)\n}\n```"
  },
  {
    "task": "Create a list of characters and reverse the vowels only.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc reverseVowels(s []rune) []rune {\n\tisVowel := func(c rune) bool {\n\t\tvowels := \"aeiouAEIOU\"\n\t\treturn strings.ContainsRune(vowels, c)\n\t}\n\n\ti, j := 0, len(s)-1\n\tfor i < j {\n\t\tfor i < j && !isVowel(s[i]) {\n\t\t\ti++\n\t\t}\n\t\tfor i < j && !isVowel(s[j]) {\n\t\t\tj--\n\t\t}\n\t\tif i < j {\n\t\t\ts[i], s[j] = s[j], s[i]\n\t\t\ti++\n\t\t\tj--\n\t\t}\n\t}\n\treturn s\n}\n\nfunc main() {\n\ts := []rune{'h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd'}\n\tfmt.Println(string(reverseVowels(s)))\n}\n```"
  },
  {
    "task": "Write a program to find all permutations of a list of elements.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc permute(arr []int) [][]int {\n\tvar helper func([]int, int)\n\tres := [][]int{}\n\n\thelper = func(arr []int, n int) {\n\t\tif n == 1 {\n\t\t\ttmp := make([]int, len(arr))\n\t\t\tcopy(tmp, arr)\n\t\t\tres = append(res, tmp)\n\t\t} else {\n\t\t\tfor i := 0; i < n; i++ {\n\t\t\t\thelper(arr, n-1)\n\t\t\t\tif n%2 == 1 {\n\t\t\t\t\tarr[0], arr[n-1] = arr[n-1], arr[0]\n\t\t\t\t} else {\n\t\t\t\t\tarr[i], arr[n-1] = arr[n-1], arr[i]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\thelper(arr, len(arr))\n\treturn res\n}\n\nfunc main() {\n\telements := []int{1, 2, 3}\n\tpermutations := permute(elements)\n\tfor _, p := range permutations {\n\t\tfmt.Println(p)\n\t}\n}\n```"
  },
  {
    "task": "Implement a function that takes a list and returns the most frequently occurring element.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc mostFrequentElement(list []interface{}) interface{} {\n\tfrequencyMap := make(map[interface{}]int)\n\tfor _, element := range list {\n\t\tfrequencyMap[element]++\n\t}\n\n\tmaxCount := 0\n\tvar mostFrequent interface{}\n\tfor element, count := range frequencyMap {\n\t\tif count > maxCount {\n\t\t\tmaxCount = count\n\t\t\tmostFrequent = element\n\t\t}\n\t}\n\n\treturn mostFrequent\n}\n\nfunc main() {\n\tlist := []interface{}{1, 2, 3, 2, 4, 2, 5}\n\tfmt.Println(mostFrequentElement(list))\n}\n```"
  },
  {
    "task": "Create a list of numbers and calculate the variance.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\tnumbers := []float64{1, 2, 3, 4, 5}\n\tvar sum, mean, variance float64\n\n\tfor _, number := range numbers {\n\t\tsum += number\n\t}\n\tmean = sum / float64(len(numbers))\n\n\tfor _, number := range numbers {\n\t\tvariance += (number - mean) * (number - mean)\n\t}\n\tvariance /= float64(len(numbers))\n\n\tfmt.Printf(\"Variance: %f\\n\", variance)\n}\n```"
  },
  {
    "task": "Write a function to concatenate a list of lists into a single list.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc concatenate(lists [][]int) []int {\n\tvar result []int\n\tfor _, list := range lists {\n\t\tresult = append(result, list...)\n\t}\n\treturn result\n}\n\nfunc main() {\n\tlists := [][]int{{1, 2}, {3, 4}, {5, 6}}\n\tconcatenated := concatenate(lists)\n\tfmt.Println(concatenated)\n}\n```"
  },
  {
    "task": "Generate a list of numbers and replace each element with the product of all other elements.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc productExceptSelf(nums []int) []int {\n\tn := len(nums)\n\tresult := make([]int, n)\n\n\tleft := 1\n\tfor i := 0; i < n; i++ {\n\t\tresult[i] = left\n\t\tleft *= nums[i]\n\t}\n\n\tright := 1\n\tfor i := n - 1; i >= 0; i-- {\n\t\tresult[i] *= right\n\t\tright *= nums[i]\n\t}\n\n\treturn result\n}\n\nfunc main() {\n\tnums := []int{1, 2, 3, 4}\n\tresult := productExceptSelf(nums)\n\tfmt.Println(result)\n}\n```"
  },
  {
    "task": "Create a list of strings and find the common prefix.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc commonPrefix(strs []string) string {\n\tif len(strs) == 0 {\n\t\treturn \"\"\n\t}\n\tprefix := strs[0]\n\tfor _, str := range strs[1:] {\n\t\tfor len(prefix) > 0 && !startsWith(str, prefix) {\n\t\t\tprefix = prefix[:len(prefix)-1]\n\t\t}\n\t\tif prefix == \"\" {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn prefix\n}\n\nfunc startsWith(str, prefix string) bool {\n\tif len(prefix) > len(str) {\n\t\treturn false\n\t}\n\tfor i := 0; i < len(prefix); i++ {\n\t\tif str[i] != prefix[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc main() {\n\tstrings := []string{\"flower\", \"flow\", \"flight\"}\n\tfmt.Println(\"Common prefix:\", commonPrefix(strings))\n}\n```"
  },
  {
    "task": "Write a program to partition a list into two lists based on a predicate function.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc partition(list []int, predicate func(int) bool) ([]int, []int) {\n\tvar trueList, falseList []int\n\tfor _, item := range list {\n\t\tif predicate(item) {\n\t\t\ttrueList = append(trueList, item)\n\t\t} else {\n\t\t\tfalseList = append(falseList, item)\n\t\t}\n\t}\n\treturn trueList, falseList\n}\n\nfunc main() {\n\tlist := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\n\tpredicate := func(x int) bool { return x%2 == 0 }\n\ttrueList, falseList := partition(list, predicate)\n\tfmt.Println(\"True list:\", trueList)\n\tfmt.Println(\"False list:\", falseList)\n}\n```"
  },
  {
    "task": "Implement a function to find the kth smallest element in a list.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\nfunc kthSmallest(nums []int, k int) int {\n\tsort.Ints(nums)\n\treturn nums[k-1]\n}\n\nfunc main() {\n\tnums := []int{3, 1, 2, 4, 5}\n\tk := 3\n\tfmt.Println(kthSmallest(nums, k))\n}\n```"
  },
  {
    "task": "Create a list of integers and find the length of the longest contiguous sequence.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc longestContiguousSequence(nums []int) int {\n\tif len(nums) == 0 {\n\t\treturn 0\n\t}\n\n\tlongest := 1\n\tcurrent := 1\n\n\tfor i := 1; i < len(nums); i++ {\n\t\tif nums[i] == nums[i-1]+1 {\n\t\t\tcurrent++\n\t\t\tif current > longest {\n\t\t\t\tlongest = current\n\t\t\t}\n\t\t} else {\n\t\t\tcurrent = 1\n\t\t}\n\t}\n\n\treturn longest\n}\n\nfunc main() {\n\tnums := []int{1, 2, 2, 3, 4, 5, 1, 2, 3, 4}\n\tfmt.Println(longestContiguousSequence(nums))\n}\n```"
  },
  {
    "task": "Write a function that rotates elements in a list while maintaining the relative order of non-rotated elements.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc rotateList(nums []int, k int) []int {\n\tn := len(nums)\n\tif n == 0 {\n\t\treturn nums\n\t}\n\n\tk = k % n\n\tif k == 0 {\n\t\treturn nums\n\t}\n\n\treturn append(nums[n-k:], nums[:n-k]...)\n}\n\nfunc main() {\n\tlist := []int{1, 2, 3, 4, 5}\n\tk := 2\n\trotatedList := rotateList(list, k)\n\tfmt.Println(rotatedList)\n}\n```"
  },
  {
    "task": "Generate a list of random numbers and sort them while maintaining the original index positions.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"sort\"\n\t\"time\"\n)\n\ntype indexedValue struct {\n\tindex int\n\tvalue int\n}\n\nfunc main() {\n\trand.Seed(time.Now().UnixNano())\n\tnumbers := make([]indexedValue, 10)\n\n\tfor i := 0; i < 10; i++ {\n\t\tnumbers[i] = indexedValue{i, rand.Intn(100)}\n\t}\n\n\tfmt.Println(\"Original list with indices:\")\n\tfor _, iv := range numbers {\n\t\tfmt.Printf(\"Index: %d, Value: %d\\n\", iv.index, iv.value)\n\t}\n\n\tsort.Slice(numbers, func(i, j int) bool {\n\t\treturn numbers[i].value < numbers[j].value\n\t})\n\n\tfmt.Println(\"\\nSorted list while maintaining original indices:\")\n\tfor _, iv := range numbers {\n\t\tfmt.Printf(\"Index: %d, Value: %d\\n\", iv.index, iv.value)\n\t}\n}\n```"
  },
  {
    "task": "Create a list of numbers and find all subsets that sum up to a specific target.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc findSubsets(nums []int, target int) [][]int {\n\tvar result [][]int\n\tvar subset []int\n\tbacktrack(nums, target, 0, subset, &result)\n\treturn result\n}\n\nfunc backtrack(nums []int, target, start int, subset []int, result *[][]int) {\n\tif target == 0 {\n\t\tcombination := make([]int, len(subset))\n\t\tcopy(combination, subset)\n\t\t*result = append(*result, combination)\n\t\treturn\n\t}\n\tfor i := start; i < len(nums); i++ {\n\t\tif nums[i] <= target {\n\t\t\tsubset = append(subset, nums[i])\n\t\t\tbacktrack(nums, target-nums[i], i+1, subset, result)\n\t\t\tsubset = subset[:len(subset)-1]\n\t\t}\n\t}\n}\n\nfunc main() {\n\tnumbers := []int{1, 2, 3, 4, 5}\n\ttarget := 5\n\tsubsets := findSubsets(numbers, target)\n\tfmt.Println(subsets)\n}\n```"
  },
  {
    "task": "Write a program to simulate a stack using a list.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\ntype Stack struct {\n\telements []int\n}\n\nfunc (s *Stack) Push(value int) {\n\ts.elements = append(s.elements, value)\n}\n\nfunc (s *Stack) Pop() (int, bool) {\n\tif s.IsEmpty() {\n\t\treturn 0, false\n\t}\n\tlastIndex := len(s.elements) - 1\n\tvalue := s.elements[lastIndex]\n\ts.elements = s.elements[:lastIndex]\n\treturn value, true\n}\n\nfunc (s *Stack) IsEmpty() bool {\n\treturn len(s.elements) == 0\n}\n\nfunc main() {\n\tstack := &Stack{}\n\tstack.Push(10)\n\tstack.Push(20)\n\tfmt.Println(stack.Pop()) // Output: 20, true\n\tfmt.Println(stack.Pop()) // Output: 10, true\n\tfmt.Println(stack.Pop()) // Output: 0, false\n}\n```"
  }
]