[
  {
    "task": "Filter out all even numbers from a list of integers.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc filter(nums []int, predicate func(int) bool) []int {\n    var result []int\n    for _, num := range nums {\n        if predicate(num) {\n            result = append(result, num)\n        }\n    }\n    return result\n}\n\nfunc isOdd(num int) bool {\n    return num%2 != 0\n}\n\nfunc main() {\n    numbers := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\n    oddNumbers := filter(numbers, isOdd)\n    fmt.Println(oddNumbers)\n}\n```"
  },
  {
    "task": "Select all words from a list that start with the letter 'a'.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc filterWordsStartingWithA(words []string) []string {\n\tvar result []string\n\tfor _, word := range words {\n\t\tif strings.HasPrefix(word, \"a\") {\n\t\t\tresult = append(result, word)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc main() {\n\twords := []string{\"apple\", \"banana\", \"avocado\", \"grape\", \"apricot\", \"berry\"}\n\tselectedWords := filterWordsStartingWithA(words)\n\tfmt.Println(selectedWords)\n}\n```"
  },
  {
    "task": "Find all positive numbers in a collection of integers.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc filterPositive(numbers []int) []int {\n\treturn filter(numbers, func(n int) bool {\n\t\treturn n > 0\n\t})\n}\n\nfunc filter(numbers []int, predicate func(int) bool) []int {\n\tvar result []int\n\tfor _, n := range numbers {\n\t\tif predicate(n) {\n\t\t\tresult = append(result, n)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc main() {\n\tnumbers := []int{-10, 20, -30, 40, 0, 50}\n\tpositiveNumbers := filterPositive(numbers)\n\tfmt.Println(positiveNumbers)\n}\n```"
  },
  {
    "task": "Extract all employees who are older than 30 from an employee directory.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\ntype Employee struct {\n\tName string\n\tAge  int\n}\n\nfunc filterEmployees(employees []Employee, predicate func(Employee) bool) []Employee {\n\tvar result []Employee\n\tfor _, e := range employees {\n\t\tif predicate(e) {\n\t\t\tresult = append(result, e)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc main() {\n\temployees := []Employee{\n\t\t{\"Alice\", 28},\n\t\t{\"Bob\", 34},\n\t\t{\"Charlie\", 31},\n\t\t{\"David\", 29},\n\t}\n\n\tolderThan30 := filterEmployees(employees, func(e Employee) bool {\n\t\treturn e.Age > 30\n\t})\n\n\tfmt.Println(olderThan30)\n}\n```"
  },
  {
    "task": "List all cities with a population greater than one million from a dataset.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\ntype City struct {\n\tName       string\n\tPopulation int\n}\n\nfunc filterCities(cities []City, predicate func(City) bool) []City {\n\tvar filteredCities []City\n\tfor _, city := range cities {\n\t\tif predicate(city) {\n\t\t\tfilteredCities = append(filteredCities, city)\n\t\t}\n\t}\n\treturn filteredCities\n}\n\nfunc main() {\n\tcities := []City{\n\t\t{\"CityA\", 500000},\n\t\t{\"CityB\", 1500000},\n\t\t{\"CityC\", 2000000},\n\t\t{\"CityD\", 750000},\n\t}\n\n\tpopulationThreshold := 1000000\n\tlargeCities := filterCities(cities, func(c City) bool {\n\t\treturn c.Population > populationThreshold\n\t})\n\n\tfmt.Println(\"Cities with a population greater than one million:\")\n\tfor _, city := range largeCities {\n\t\tfmt.Println(city.Name)\n\t}\n}\n```"
  },
  {
    "task": "Filter out products that are out of stock from a product list.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\ntype Product struct {\n\tName     string\n\tInStock  bool\n}\n\nfunc filter(products []Product, predicate func(Product) bool) []Product {\n\tvar result []Product\n\tfor _, product := range products {\n\t\tif predicate(product) {\n\t\t\tresult = append(result, product)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc main() {\n\tproducts := []Product{\n\t\t{\"Laptop\", true},\n\t\t{\"Smartphone\", false},\n\t\t{\"Tablet\", true},\n\t\t{\"Headphones\", false},\n\t}\n\n\tinStockProducts := filter(products, func(p Product) bool {\n\t\treturn p.InStock\n\t})\n\n\tfmt.Println(inStockProducts)\n}\n```"
  },
  {
    "task": "Select all students who have passed with a grade above 70 from a list of student scores.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\ntype Student struct {\n\tName  string\n\tGrade int\n}\n\nfunc filterPassedStudents(students []Student) []Student {\n\tvar passedStudents []Student\n\tfor _, student := range students {\n\t\tif student.Grade > 70 {\n\t\t\tpassedStudents = append(passedStudents, student)\n\t\t}\n\t}\n\treturn passedStudents\n}\n\nfunc main() {\n\tstudents := []Student{\n\t\t{\"Alice\", 85},\n\t\t{\"Bob\", 65},\n\t\t{\"Charlie\", 72},\n\t\t{\"David\", 90},\n\t\t{\"Eve\", 68},\n\t}\n\n\tpassedStudents := filterPassedStudents(students)\n\tfmt.Println(\"Students who passed:\")\n\tfor _, student := range passedStudents {\n\t\tfmt.Println(student.Name)\n\t}\n}\n```"
  },
  {
    "task": "Identify all strings in an array that contain the substring 'cat'.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc filterStringsContainingSubstring(arr []string, substring string) []string {\n\treturn filter(arr, func(s string) bool {\n\t\treturn strings.Contains(s, substring)\n\t})\n}\n\nfunc filter(arr []string, predicate func(string) bool) []string {\n\tvar result []string\n\tfor _, v := range arr {\n\t\tif predicate(v) {\n\t\t\tresult = append(result, v)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc main() {\n\tstringsArray := []string{\"cat\", \"dog\", \"catalog\", \"caterpillar\", \"dogcat\", \"fish\"}\n\tsubstring := \"cat\"\n\tfilteredStrings := filterStringsContainingSubstring(stringsArray, substring)\n\tfmt.Println(filteredStrings)\n}\n```"
  },
  {
    "task": "Extract all transactions above $1000 from a financial record.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\ntype Transaction struct {\n\tAmount float64\n}\n\nfunc filterTransactions(transactions []Transaction, predicate func(Transaction) bool) []Transaction {\n\tvar result []Transaction\n\tfor _, t := range transactions {\n\t\tif predicate(t) {\n\t\t\tresult = append(result, t)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc main() {\n\ttransactions := []Transaction{\n\t\t{Amount: 500},\n\t\t{Amount: 1500},\n\t\t{Amount: 700},\n\t\t{Amount: 2000},\n\t}\n\n\tfilteredTransactions := filterTransactions(transactions, func(t Transaction) bool {\n\t\treturn t.Amount > 1000\n\t})\n\n\tfmt.Println(filteredTransactions)\n}\n```"
  },
  {
    "task": "Filter out all non-prime numbers from a list of numbers.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc isPrime(n int) bool {\n\tif n < 2 {\n\t\treturn false\n\t}\n\tfor i := 2; i*i <= n; i++ {\n\t\tif n%i == 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc filterPrimes(numbers []int) []int {\n\tvar primes []int\n\tfor _, num := range numbers {\n\t\tif isPrime(num) {\n\t\t\tprimes = append(primes, num)\n\t\t}\n\t}\n\treturn primes\n}\n\nfunc main() {\n\tnumbers := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\n\tprimes := filterPrimes(numbers)\n\tfmt.Println(primes)\n}\n```"
  },
  {
    "task": "Select all books with more than 300 pages from a library catalog.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\ntype Book struct {\n\tTitle string\n\tPages int\n}\n\nfunc filterBooks(books []Book, predicate func(Book) bool) []Book {\n\tvar result []Book\n\tfor _, book := range books {\n\t\tif predicate(book) {\n\t\t\tresult = append(result, book)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc main() {\n\tlibraryCatalog := []Book{\n\t\t{\"Book One\", 250},\n\t\t{\"Book Two\", 320},\n\t\t{\"Book Three\", 400},\n\t\t{\"Book Four\", 150},\n\t\t{\"Book Five\", 310},\n\t}\n\n\tbooksWithMoreThan300Pages := filterBooks(libraryCatalog, func(b Book) bool {\n\t\treturn b.Pages > 300\n\t})\n\n\tfor _, book := range booksWithMoreThan300Pages {\n\t\tfmt.Println(book.Title)\n\t}\n}\n```"
  },
  {
    "task": "Identify all users who have logged in within the past week from a user database.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\ntype User struct {\n\tName     string\n\tLastLogin time.Time\n}\n\nfunc main() {\n\tusers := []User{\n\t\t{\"Alice\", time.Now().AddDate(0, 0, -2)},\n\t\t{\"Bob\", time.Now().AddDate(0, 0, -10)},\n\t\t{\"Charlie\", time.Now().AddDate(0, 0, -5)},\n\t}\n\n\tresult := filter(users, func(u User) bool {\n\t\treturn u.LastLogin.After(time.Now().AddDate(0, 0, -7))\n\t})\n\n\tfor _, user := range result {\n\t\tfmt.Println(user.Name)\n\t}\n}\n\nfunc filter(users []User, test func(User) bool) (ret []User) {\n\tfor _, user := range users {\n\t\tif test(user) {\n\t\t\tret = append(ret, user)\n\t\t}\n\t}\n\treturn\n}\n```"
  },
  {
    "task": "Extract all URLs that contain 'https' from a list of web addresses.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc filterURLs(urls []string) []string {\n\treturn filter(urls, func(url string) bool {\n\t\treturn strings.Contains(url, \"https\")\n\t})\n}\n\nfunc filter(urls []string, test func(string) bool) []string {\n\tvar filtered []string\n\tfor _, url := range urls {\n\t\tif test(url) {\n\t\t\tfiltered = append(filtered, url)\n\t\t}\n\t}\n\treturn filtered\n}\n\nfunc main() {\n\twebAddresses := []string{\n\t\t\"http://example.com\",\n\t\t\"https://example.com\",\n\t\t\"https://secure.com\",\n\t\t\"http://unsecure.com\",\n\t}\n\n\tfilteredURLs := filterURLs(webAddresses)\n\tfmt.Println(filteredURLs)\n}\n```"
  },
  {
    "task": "Find all movies released after the year 2000 from a movie database.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\ntype Movie struct {\n\tTitle string\n\tYear  int\n}\n\nfunc filterMovies(movies []Movie, predicate func(Movie) bool) []Movie {\n\tvar filtered []Movie\n\tfor _, movie := range movies {\n\t\tif predicate(movie) {\n\t\t\tfiltered = append(filtered, movie)\n\t\t}\n\t}\n\treturn filtered\n}\n\nfunc main() {\n\tmovies := []Movie{\n\t\t{\"The Matrix\", 1999},\n\t\t{\"Gladiator\", 2000},\n\t\t{\"Inception\", 2010},\n\t\t{\"The Dark Knight\", 2008},\n\t}\n\n\treleasedAfter2000 := func(m Movie) bool {\n\t\treturn m.Year > 2000\n\t}\n\n\tfilteredMovies := filterMovies(movies, releasedAfter2000)\n\tfor _, movie := range filteredMovies {\n\t\tfmt.Println(movie.Title)\n\t}\n}\n```"
  },
  {
    "task": "Select all tasks with a priority level of 'high' from a task management system.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\ntype Task struct {\n\tName     string\n\tPriority string\n}\n\nfunc filterHighPriorityTasks(tasks []Task) []Task {\n\tvar highPriorityTasks []Task\n\tfor _, task := range tasks {\n\t\tif task.Priority == \"high\" {\n\t\t\thighPriorityTasks = append(highPriorityTasks, task)\n\t\t}\n\t}\n\treturn highPriorityTasks\n}\n\nfunc main() {\n\ttasks := []Task{\n\t\t{\"Task 1\", \"low\"},\n\t\t{\"Task 2\", \"high\"},\n\t\t{\"Task 3\", \"medium\"},\n\t\t{\"Task 4\", \"high\"},\n\t}\n\n\thighPriorityTasks := filterHighPriorityTasks(tasks)\n\tfmt.Println(\"High Priority Tasks:\")\n\tfor _, task := range highPriorityTasks {\n\t\tfmt.Println(task.Name)\n\t}\n}\n```"
  },
  {
    "task": "Filter out all words longer than five characters from a text document.",
    "code": "```go\npackage main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n)\n\nfunc main() {\n\tfile, err := os.Open(\"document.txt\")\n\tif err != nil {\n\t\tfmt.Println(\"Error opening file:\", err)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\tscanner := bufio.NewScanner(file)\n\tfor scanner.Scan() {\n\t\tline := scanner.Text()\n\t\twords := strings.Fields(line)\n\t\tfilteredWords := Filter(words, func(word string) bool {\n\t\t\treturn len(word) <= 5\n\t\t})\n\t\tfmt.Println(strings.Join(filteredWords, \" \"))\n\t}\n\n\tif err := scanner.Err(); err != nil {\n\t\tfmt.Println(\"Error reading file:\", err)\n\t}\n}\n\nfunc Filter(words []string, test func(string) bool) []string {\n\tvar filtered []string\n\tfor _, word := range words {\n\t\tif test(word) {\n\t\t\tfiltered = append(filtered, word)\n\t\t}\n\t}\n\treturn filtered\n}\n```"
  },
  {
    "task": "Extract all odd numbers from a sequence of integers.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc filter(numbers []int, predicate func(int) bool) []int {\n\tvar result []int\n\tfor _, number := range numbers {\n\t\tif predicate(number) {\n\t\t\tresult = append(result, number)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc isOdd(number int) bool {\n\treturn number%2 != 0\n}\n\nfunc main() {\n\tnumbers := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\n\toddNumbers := filter(numbers, isOdd)\n\tfmt.Println(oddNumbers)\n}\n```"
  },
  {
    "task": "Select all files larger than 10MB from a list of files.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n)\n\ntype File struct {\n\tName string\n\tSize int64\n}\n\nfunc filterFiles(files []File, predicate func(File) bool) []File {\n\tvar result []File\n\tfor _, file := range files {\n\t\tif predicate(file) {\n\t\t\tresult = append(result, file)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc main() {\n\tfiles := []File{\n\t\t{\"file1.txt\", 5 * 1024 * 1024},\n\t\t{\"file2.txt\", 15 * 1024 * 1024},\n\t\t{\"file3.txt\", 20 * 1024 * 1024},\n\t}\n\n\tlargerThan10MB := func(file File) bool {\n\t\treturn file.Size > 10*1024*1024\n\t}\n\n\tlargeFiles := filterFiles(files, largerThan10MB)\n\n\tfor _, file := range largeFiles {\n\t\tfmt.Println(file.Name)\n\t}\n}\n```"
  },
  {
    "task": "Identify all events occurring on weekends from an event schedule.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\ntype Event struct {\n\tName string\n\tDate time.Time\n}\n\nfunc filterWeekends(events []Event) []Event {\n\tvar weekendEvents []Event\n\tfor _, event := range events {\n\t\tweekday := event.Date.Weekday()\n\t\tif weekday == time.Saturday || weekday == time.Sunday {\n\t\t\tweekendEvents = append(weekendEvents, event)\n\t\t}\n\t}\n\treturn weekendEvents\n}\n\nfunc main() {\n\tevents := []Event{\n\t\t{\"Event 1\", time.Date(2023, 10, 7, 0, 0, 0, 0, time.UTC)},\n\t\t{\"Event 2\", time.Date(2023, 10, 8, 0, 0, 0, 0, time.UTC)},\n\t\t{\"Event 3\", time.Date(2023, 10, 9, 0, 0, 0, 0, time.UTC)},\n\t}\n\n\tweekendEvents := filterWeekends(events)\n\tfor _, event := range weekendEvents {\n\t\tfmt.Println(event.Name, event.Date)\n\t}\n}\n```"
  },
  {
    "task": "Find all emails from a specific domain in an email list.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc filterEmailsByDomain(emails []string, domain string) []string {\n\treturn filter(emails, func(email string) bool {\n\t\treturn strings.HasSuffix(email, \"@\"+domain)\n\t})\n}\n\nfunc filter(emails []string, test func(string) bool) []string {\n\tvar result []string\n\tfor _, email := range emails {\n\t\tif test(email) {\n\t\t\tresult = append(result, email)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc main() {\n\temails := []string{\n\t\t\"user1@example.com\",\n\t\t\"user2@test.com\",\n\t\t\"user3@example.com\",\n\t\t\"user4@sample.com\",\n\t}\n\n\tdomain := \"example.com\"\n\tfilteredEmails := filterEmailsByDomain(emails, domain)\n\tfmt.Println(filteredEmails)\n}\n```"
  },
  {
    "task": "Filter out all people not living in a specific city from a contact list.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\ntype Contact struct {\n\tName string\n\tCity string\n}\n\nfunc filterContactsByCity(contacts []Contact, city string) []Contact {\n\tfiltered := []Contact{}\n\tfor _, c := range contacts {\n\t\tif c.City == city {\n\t\t\tfiltered = append(filtered, c)\n\t\t}\n\t}\n\treturn filtered\n}\n\nfunc main() {\n\tcontacts := []Contact{\n\t\t{\"Alice\", \"New York\"},\n\t\t{\"Bob\", \"Los Angeles\"},\n\t\t{\"Charlie\", \"New York\"},\n\t\t{\"David\", \"Chicago\"},\n\t}\n\n\tcity := \"New York\"\n\tfilteredContacts := filterContactsByCity(contacts, city)\n\n\tfmt.Println(filteredContacts)\n}\n```"
  },
  {
    "task": "Select all rectangles with an area greater than 50 from a list of rectangles.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\ntype Rectangle struct {\n\tWidth, Height float64\n}\n\nfunc main() {\n\trectangles := []Rectangle{\n\t\t{Width: 5, Height: 11},\n\t\t{Width: 3, Height: 15},\n\t\t{Width: 8, Height: 6},\n\t\t{Width: 4, Height: 4},\n\t}\n\n\tfiltered := filter(rectangles, func(r Rectangle) bool {\n\t\treturn r.Width*r.Height > 50\n\t})\n\n\tfmt.Println(filtered)\n}\n\nfunc filter(rectangles []Rectangle, test func(Rectangle) bool) []Rectangle {\n\tvar result []Rectangle\n\tfor _, rect := range rectangles {\n\t\tif test(rect) {\n\t\t\tresult = append(result, rect)\n\t\t}\n\t}\n\treturn result\n}\n```"
  },
  {
    "task": "Extract all elements that are not null from a collection.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc filterNotNull(collection []interface{}) []interface{} {\n\tresult := make([]interface{}, 0)\n\tfor _, item := range collection {\n\t\tif item != nil {\n\t\t\tresult = append(result, item)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc main() {\n\tcollection := []interface{}{1, nil, \"test\", nil, 3.14, \"Go\", nil}\n\tfilteredCollection := filterNotNull(collection)\n\tfmt.Println(filteredCollection)\n}\n```"
  },
  {
    "task": "Identify all registered voters over the age of 18 from a voter registration list.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\ntype Voter struct {\n\tName string\n\tAge  int\n}\n\nfunc filterVoters(voters []Voter, criteria func(Voter) bool) []Voter {\n\tvar filtered []Voter\n\tfor _, voter := range voters {\n\t\tif criteria(voter) {\n\t\t\tfiltered = append(filtered, voter)\n\t\t}\n\t}\n\treturn filtered\n}\n\nfunc main() {\n\tvoters := []Voter{\n\t\t{\"Alice\", 17},\n\t\t{\"Bob\", 20},\n\t\t{\"Charlie\", 19},\n\t\t{\"David\", 16},\n\t}\n\n\tover18 := func(v Voter) bool {\n\t\treturn v.Age > 18\n\t}\n\n\teligibleVoters := filterVoters(voters, over18)\n\tfmt.Println(\"Eligible Voters:\")\n\tfor _, voter := range eligibleVoters {\n\t\tfmt.Println(voter.Name)\n\t}\n}\n```"
  },
  {
    "task": "Select all cars manufactured after 2015 from a vehicle registry.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\ntype Car struct {\n\tMake      string\n\tModel     string\n\tYear      int\n}\n\nfunc filterCars(cars []Car, predicate func(Car) bool) []Car {\n\tvar filteredCars []Car\n\tfor _, car := range cars {\n\t\tif predicate(car) {\n\t\t\tfilteredCars = append(filteredCars, car)\n\t\t}\n\t}\n\treturn filteredCars\n}\n\nfunc main() {\n\tvehicleRegistry := []Car{\n\t\t{\"Toyota\", \"Camry\", 2014},\n\t\t{\"Honda\", \"Accord\", 2016},\n\t\t{\"Ford\", \"Mustang\", 2018},\n\t\t{\"Chevrolet\", \"Malibu\", 2013},\n\t}\n\n\tmanufacturedAfter2015 := filterCars(vehicleRegistry, func(car Car) bool {\n\t\treturn car.Year > 2015\n\t})\n\n\tfmt.Println(manufacturedAfter2015)\n}\n```"
  },
  {
    "task": "Filter out all negative numbers from a dataset of integers.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc filterNegatives(numbers []int) []int {\n\treturn filter(numbers, func(n int) bool {\n\t\treturn n >= 0\n\t})\n}\n\nfunc filter(numbers []int, predicate func(int) bool) []int {\n\tvar result []int\n\tfor _, n := range numbers {\n\t\tif predicate(n) {\n\t\t\tresult = append(result, n)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc main() {\n\tdata := []int{-10, 15, 0, -3, 7, -5, 8}\n\tfiltered := filterNegatives(data)\n\tfmt.Println(filtered)\n}\n```"
  },
  {
    "task": "Extract all characters from a string that are uppercase.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"unicode\"\n)\n\nfunc filterUppercase(s string) string {\n\treturn strings.Map(func(r rune) rune {\n\t\tif unicode.IsUpper(r) {\n\t\t\treturn r\n\t\t}\n\t\treturn -1\n\t}, s)\n}\n\nfunc main() {\n\ts := \"Hello, World!\"\n\tuppercaseChars := filterUppercase(s)\n\tfmt.Println(uppercaseChars)\n}\n```"
  },
  {
    "task": "Identify all projects with a deadline within the next month from a project database.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\ntype Project struct {\n\tName     string\n\tDeadline time.Time\n}\n\nfunc filterProjects(projects []Project, predicate func(Project) bool) []Project {\n\tvar filtered []Project\n\tfor _, project := range projects {\n\t\tif predicate(project) {\n\t\t\tfiltered = append(filtered, project)\n\t\t}\n\t}\n\treturn filtered\n}\n\nfunc main() {\n\tnow := time.Now()\n\toneMonthLater := now.AddDate(0, 1, 0)\n\tprojects := []Project{\n\t\t{\"Project 1\", now.AddDate(0, 0, 10)},\n\t\t{\"Project 2\", now.AddDate(0, -1, 0)},\n\t\t{\"Project 3\", now.AddDate(0, 1, 5)},\n\t}\n\n\tupcomingProjects := filterProjects(projects, func(p Project) bool {\n\t\treturn p.Deadline.Before(oneMonthLater) && p.Deadline.After(now)\n\t})\n\n\tfor _, project := range upcomingProjects {\n\t\tfmt.Println(project.Name)\n\t}\n}\n```"
  },
  {
    "task": "Select all athletes with a score higher than 90 from a competition result list.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\ntype Athlete struct {\n\tName  string\n\tScore int\n}\n\nfunc filterAthletes(athletes []Athlete, predicate func(Athlete) bool) []Athlete {\n\tvar filtered []Athlete\n\tfor _, athlete := range athletes {\n\t\tif predicate(athlete) {\n\t\t\tfiltered = append(filtered, athlete)\n\t\t}\n\t}\n\treturn filtered\n}\n\nfunc main() {\n\tathletes := []Athlete{\n\t\t{\"Alice\", 95},\n\t\t{\"Bob\", 85},\n\t\t{\"Charlie\", 92},\n\t\t{\"David\", 88},\n\t}\n\n\thighScoringAthletes := filterAthletes(athletes, func(a Athlete) bool {\n\t\treturn a.Score > 90\n\t})\n\n\tfmt.Println(highScoringAthletes)\n}\n```"
  },
  {
    "task": "Filter out all strings that do not contain vowels from a list of words.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc containsVowel(s string) bool {\n\tvowels := \"aeiouAEIOU\"\n\tfor _, char := range s {\n\t\tif strings.ContainsRune(vowels, char) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc filterWords(words []string, predicate func(string) bool) []string {\n\tvar filtered []string\n\tfor _, word := range words {\n\t\tif predicate(word) {\n\t\t\tfiltered = append(filtered, word)\n\t\t}\n\t}\n\treturn filtered\n}\n\nfunc main() {\n\twords := []string{\"sky\", \"apple\", \"fly\", \"banana\", \"dry\"}\n\tresult := filterWords(words, containsVowel)\n\tfmt.Println(result)\n}\n```"
  },
  {
    "task": "Extract all dates that fall on a weekday from a calendar.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tcalendar := []time.Time{\n\t\ttime.Date(2023, 10, 1, 0, 0, 0, 0, time.UTC), // Sunday\n\t\ttime.Date(2023, 10, 2, 0, 0, 0, 0, time.UTC), // Monday\n\t\ttime.Date(2023, 10, 3, 0, 0, 0, 0, time.UTC), // Tuesday\n\t\ttime.Date(2023, 10, 4, 0, 0, 0, 0, time.UTC), // Wednesday\n\t\ttime.Date(2023, 10, 5, 0, 0, 0, 0, time.UTC), // Thursday\n\t\ttime.Date(2023, 10, 6, 0, 0, 0, 0, time.UTC), // Friday\n\t\ttime.Date(2023, 10, 7, 0, 0, 0, 0, time.UTC), // Saturday\n\t}\n\n\tisWeekday := func(t time.Time) bool {\n\t\tweekday := t.Weekday()\n\t\treturn weekday >= time.Monday && weekday <= time.Friday\n\t}\n\n\tvar weekdays []time.Time\n\tfor _, date := range calendar {\n\t\tif isWeekday(date) {\n\t\t\tweekdays = append(weekdays, date)\n\t\t}\n\t}\n\n\tfor _, date := range weekdays {\n\t\tfmt.Println(date.Format(\"2006-01-02\"))\n\t}\n}\n```"
  },
  {
    "task": "Find all software versions that are stable releases from a list of software versions.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc filterStableVersions(versions []string) []string {\n\tisStable := func(version string) bool {\n\t\treturn !strings.Contains(version, \"-\")\n\t}\n\n\tvar stableVersions []string\n\tfor _, version := range versions {\n\t\tif isStable(version) {\n\t\t\tstableVersions = append(stableVersions, version)\n\t\t}\n\t}\n\treturn stableVersions\n}\n\nfunc main() {\n\tversions := []string{\"1.0.0\", \"1.0.1-alpha\", \"2.0.0\", \"2.1.0-beta\", \"3.0.0\"}\n\tstableVersions := filterStableVersions(versions)\n\tfmt.Println(stableVersions)\n}\n```"
  },
  {
    "task": "Select all temperatures above freezing from a weather report.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc filterTemperatures(temps []float64) []float64 {\n\tisAboveFreezing := func(temp float64) bool {\n\t\treturn temp > 0\n\t}\n\n\tvar result []float64\n\tfor _, temp := range temps {\n\t\tif isAboveFreezing(temp) {\n\t\t\tresult = append(result, temp)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc main() {\n\tweatherReport := []float64{-5.0, 3.2, 0.0, 8.5, -2.3, 15.6}\n\taboveFreezing := filterTemperatures(weatherReport)\n\tfmt.Println(aboveFreezing)\n}\n```"
  },
  {
    "task": "Identify all countries with a GDP per capita above $40,000 from a country dataset.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\ntype Country struct {\n\tName       string\n\tGDPPerCapita float64\n}\n\nfunc filterCountries(countries []Country, predicate func(Country) bool) []Country {\n\tvar result []Country\n\tfor _, country := range countries {\n\t\tif predicate(country) {\n\t\t\tresult = append(result, country)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc main() {\n\tcountries := []Country{\n\t\t{\"CountryA\", 45000},\n\t\t{\"CountryB\", 39000},\n\t\t{\"CountryC\", 50000},\n\t\t{\"CountryD\", 38000},\n\t}\n\n\tfilteredCountries := filterCountries(countries, func(c Country) bool {\n\t\treturn c.GDPPerCapita > 40000\n\t})\n\n\tfor _, country := range filteredCountries {\n\t\tfmt.Println(country.Name)\n\t}\n}\n```"
  },
  {
    "task": "Filter out all names shorter than four letters from a roster.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc filterNames(names []string) []string {\n    result := []string{}\n    for _, name := range names {\n        if len(name) >= 4 {\n            result = append(result, name)\n        }\n    }\n    return result\n}\n\nfunc main() {\n    roster := []string{\"Anna\", \"Ben\", \"Clara\", \"John\", \"Eli\"}\n    filteredRoster := filterNames(roster)\n    fmt.Println(filteredRoster)\n}\n```"
  },
  {
    "task": "Extract all numbers divisible by five from a sequence.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc filterDivisibleByFive(numbers []int) []int {\n\tfiltered := []int{}\n\tfor _, num := range numbers {\n\t\tif num%5 == 0 {\n\t\t\tfiltered = append(filtered, num)\n\t\t}\n\t}\n\treturn filtered\n}\n\nfunc main() {\n\tnumbers := []int{10, 23, 35, 40, 51, 60, 72}\n\tresult := filterDivisibleByFive(numbers)\n\tfmt.Println(result)\n}\n```"
  },
  {
    "task": "Select all movies with a rating above 4 stars from a film review site.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\ntype Movie struct {\n\tTitle  string\n\tRating float64\n}\n\nfunc filterMovies(movies []Movie, predicate func(Movie) bool) []Movie {\n\tvar result []Movie\n\tfor _, movie := range movies {\n\t\tif predicate(movie) {\n\t\t\tresult = append(result, movie)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc main() {\n\tmovies := []Movie{\n\t\t{\"Inception\", 4.8},\n\t\t{\"The Matrix\", 4.7},\n\t\t{\"Interstellar\", 4.6},\n\t\t{\"Cats\", 2.7},\n\t\t{\"Avatar\", 4.2},\n\t}\n\n\thighRatedMovies := filterMovies(movies, func(m Movie) bool {\n\t\treturn m.Rating > 4.0\n\t})\n\n\tfmt.Println(\"Movies with a rating above 4 stars:\")\n\tfor _, movie := range highRatedMovies {\n\t\tfmt.Printf(\"%s: %.1f\\n\", movie.Title, movie.Rating)\n\t}\n}\n```"
  },
  {
    "task": "Find all jobs with a salary above $50,000 from a job listing.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\ntype Job struct {\n\tTitle  string\n\tSalary int\n}\n\nfunc filterJobs(jobs []Job, predicate func(Job) bool) []Job {\n\tvar filteredJobs []Job\n\tfor _, job := range jobs {\n\t\tif predicate(job) {\n\t\t\tfilteredJobs = append(filteredJobs, job)\n\t\t}\n\t}\n\treturn filteredJobs\n}\n\nfunc main() {\n\tjobs := []Job{\n\t\t{\"Engineer\", 70000},\n\t\t{\"Teacher\", 40000},\n\t\t{\"Designer\", 55000},\n\t\t{\"Analyst\", 50000},\n\t}\n\n\tsalaryAbove50k := func(job Job) bool {\n\t\treturn job.Salary > 50000\n\t}\n\n\thighPayingJobs := filterJobs(jobs, salaryAbove50k)\n\n\tfmt.Println(highPayingJobs)\n}\n```"
  },
  {
    "task": "Filter out all entries without an email address from a contact form submission list.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\ntype Contact struct {\n\tName  string\n\tEmail string\n}\n\nfunc filterContacts(contacts []Contact) []Contact {\n\tvar filtered []Contact\n\tfor _, contact := range contacts {\n\t\tif contact.Email != \"\" {\n\t\t\tfiltered = append(filtered, contact)\n\t\t}\n\t}\n\treturn filtered\n}\n\nfunc main() {\n\tcontacts := []Contact{\n\t\t{Name: \"Alice\", Email: \"alice@example.com\"},\n\t\t{Name: \"Bob\", Email: \"\"},\n\t\t{Name: \"Charlie\", Email: \"charlie@example.com\"},\n\t}\n\n\tfilteredContacts := filterContacts(contacts)\n\tfmt.Println(filteredContacts)\n}\n```"
  },
  {
    "task": "Identify all animals weighing more than 50kg from a zoo inventory.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\ntype Animal struct {\n\tName   string\n\tWeight float64\n}\n\nfunc filterAnimals(animals []Animal, predicate func(Animal) bool) []Animal {\n\tvar result []Animal\n\tfor _, animal := range animals {\n\t\tif predicate(animal) {\n\t\t\tresult = append(result, animal)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc main() {\n\tzoo := []Animal{\n\t\t{Name: \"Elephant\", Weight: 5400.0},\n\t\t{Name: \"Giraffe\", Weight: 800.0},\n\t\t{Name: \"Monkey\", Weight: 35.0},\n\t\t{Name: \"Lion\", Weight: 190.0},\n\t\t{Name: \"Panda\", Weight: 100.0},\n\t}\n\n\theavyAnimals := filterAnimals(zoo, func(a Animal) bool {\n\t\treturn a.Weight > 50.0\n\t})\n\n\tfmt.Println(\"Animals weighing more than 50kg:\")\n\tfor _, animal := range heavyAnimals {\n\t\tfmt.Printf(\"%s weighs %.2fkg\\n\", animal.Name, animal.Weight)\n\t}\n}\n```"
  },
  {
    "task": "Select all songs with a duration longer than three minutes from a playlist.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\ntype Song struct {\n\tTitle    string\n\tDuration int // Duration in seconds\n}\n\nfunc filter(songs []Song, predicate func(Song) bool) []Song {\n\tvar result []Song\n\tfor _, song := range songs {\n\t\tif predicate(song) {\n\t\t\tresult = append(result, song)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc main() {\n\tplaylist := []Song{\n\t\t{\"Song A\", 180},\n\t\t{\"Song B\", 250},\n\t\t{\"Song C\", 190},\n\t\t{\"Song D\", 220},\n\t}\n\n\tlongSongs := filter(playlist, func(s Song) bool {\n\t\treturn s.Duration > 180\n\t})\n\n\tfmt.Println(\"Songs longer than three minutes:\")\n\tfor _, song := range longSongs {\n\t\tfmt.Println(song.Title)\n\t}\n}\n```"
  },
  {
    "task": "Extract all accounts with a balance below zero from a bank statement.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\ntype Account struct {\n\tID      string\n\tBalance float64\n}\n\nfunc filterNegativeBalanceAccounts(accounts []Account) []Account {\n\tvar negativeBalanceAccounts []Account\n\tfor _, account := range accounts {\n\t\tif account.Balance < 0 {\n\t\t\tnegativeBalanceAccounts = append(negativeBalanceAccounts, account)\n\t\t}\n\t}\n\treturn negativeBalanceAccounts\n}\n\nfunc main() {\n\taccounts := []Account{\n\t\t{\"001\", 100.0},\n\t\t{\"002\", -50.0},\n\t\t{\"003\", 0.0},\n\t\t{\"004\", -200.0},\n\t}\n\n\tnegativeBalanceAccounts := filterNegativeBalanceAccounts(accounts)\n\tfmt.Println(\"Accounts with negative balance:\", negativeBalanceAccounts)\n}\n```"
  },
  {
    "task": "Filter out all non-alphabetic characters from a string of text.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"unicode\"\n)\n\nfunc filterAlphabetic(input string) string {\n\tvar filtered strings.Builder\n\tfor _, r := range input {\n\t\tif unicode.IsLetter(r) {\n\t\t\tfiltered.WriteRune(r)\n\t\t}\n\t}\n\treturn filtered.String()\n}\n\nfunc main() {\n\ttext := \"Hello, World! 123\"\n\tresult := filterAlphabetic(text)\n\tfmt.Println(result)\n}\n```"
  },
  {
    "task": "Select all participants who scored above average in a competition.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\ntype Participant struct {\n\tName  string\n\tScore float64\n}\n\nfunc filterAboveAverage(participants []Participant) []Participant {\n\tif len(participants) == 0 {\n\t\treturn nil\n\t}\n\n\tvar total float64\n\tfor _, p := range participants {\n\t\ttotal += p.Score\n\t}\n\taverage := total / float64(len(participants))\n\n\tvar aboveAverage []Participant\n\tfor _, p := range participants {\n\t\tif p.Score > average {\n\t\t\taboveAverage = append(aboveAverage, p)\n\t\t}\n\t}\n\treturn aboveAverage\n}\n\nfunc main() {\n\tparticipants := []Participant{\n\t\t{\"Alice\", 85},\n\t\t{\"Bob\", 92},\n\t\t{\"Charlie\", 78},\n\t\t{\"David\", 88},\n\t}\n\n\tselected := filterAboveAverage(participants)\n\tfor _, p := range selected {\n\t\tfmt.Println(p.Name, p.Score)\n\t}\n}\n```"
  },
  {
    "task": "Find all houses priced under $300,000 from a real estate database.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\ntype House struct {\n\tPrice int\n}\n\nfunc filterHouses(houses []House, predicate func(House) bool) []House {\n\tvar filtered []House\n\tfor _, house := range houses {\n\t\tif predicate(house) {\n\t\t\tfiltered = append(filtered, house)\n\t\t}\n\t}\n\treturn filtered\n}\n\nfunc main() {\n\thouses := []House{\n\t\t{Price: 250000},\n\t\t{Price: 320000},\n\t\t{Price: 280000},\n\t\t{Price: 150000},\n\t}\n\n\tfilteredHouses := filterHouses(houses, func(h House) bool {\n\t\treturn h.Price < 300000\n\t})\n\n\tfmt.Println(filteredHouses)\n}\n```"
  },
  {
    "task": "Identify all plants that bloom in spring from a botanical catalog.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\ntype Plant struct {\n\tName   string\n\tBlooms string\n}\n\nfunc filter(plants []Plant, predicate func(Plant) bool) []Plant {\n\tvar result []Plant\n\tfor _, plant := range plants {\n\t\tif predicate(plant) {\n\t\t\tresult = append(result, plant)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc main() {\n\tcatalog := []Plant{\n\t\t{Name: \"Cherry Blossom\", Blooms: \"Spring\"},\n\t\t{Name: \"Sunflower\", Blooms: \"Summer\"},\n\t\t{Name: \"Daffodil\", Blooms: \"Spring\"},\n\t\t{Name: \"Maple\", Blooms: \"Fall\"},\n\t}\n\n\tspringPlants := filter(catalog, func(p Plant) bool {\n\t\treturn p.Blooms == \"Spring\"\n\t})\n\n\tfmt.Println(\"Plants that bloom in spring:\")\n\tfor _, plant := range springPlants {\n\t\tfmt.Println(plant.Name)\n\t}\n}\n```"
  },
  {
    "task": "Extract all passwords that are longer than eight characters from a user database.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc filterPasswords(passwords []string, predicate func(string) bool) []string {\n\tvar result []string\n\tfor _, password := range passwords {\n\t\tif predicate(password) {\n\t\t\tresult = append(result, password)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc main() {\n\tuserPasswords := []string{\n\t\t\"pass123\",\n\t\t\"securepassword\",\n\t\t\"12345678\",\n\t\t\"verylongpassword123\",\n\t\t\"short\",\n\t\t\"anotherlongpassword\",\n\t}\n\n\tlongPasswords := filterPasswords(userPasswords, func(password string) bool {\n\t\treturn len(password) > 8\n\t})\n\n\tfmt.Println(longPasswords)\n}\n```"
  },
  {
    "task": "Filter out all projects that are not yet started from a project management tool.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\ntype Project struct {\n\tName   string\n\tStatus string\n}\n\nfunc filterProjects(projects []Project, predicate func(Project) bool) []Project {\n\tvar filteredProjects []Project\n\tfor _, project := range projects {\n\t\tif predicate(project) {\n\t\t\tfilteredProjects = append(filteredProjects, project)\n\t\t}\n\t}\n\treturn filteredProjects\n}\n\nfunc main() {\n\tprojects := []Project{\n\t\t{\"Project A\", \"Not Started\"},\n\t\t{\"Project B\", \"In Progress\"},\n\t\t{\"Project C\", \"Completed\"},\n\t\t{\"Project D\", \"Not Started\"},\n\t\t{\"Project E\", \"In Progress\"},\n\t}\n\n\tstartedProjects := filterProjects(projects, func(p Project) bool {\n\t\treturn p.Status != \"Not Started\"\n\t})\n\n\tfmt.Println(\"Started Projects:\")\n\tfor _, project := range startedProjects {\n\t\tfmt.Println(project.Name)\n\t}\n}\n```"
  },
  {
    "task": "Select all days with temperatures exceeding 25\u00b0C from a climate report.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    // Sample data with days and temperatures\n    climateReport := map[string]float64{\n        \"Monday\":    20.5,\n        \"Tuesday\":   28.0,\n        \"Wednesday\": 22.3,\n        \"Thursday\":  30.1,\n        \"Friday\":    24.0,\n        \"Saturday\":  26.5,\n        \"Sunday\":    27.0,\n    }\n\n    // Filter temperatures exceeding 25\u00b0C\n    selectedDays := filter(climateReport, func(temp float64) bool {\n        return temp > 25.0\n    })\n\n    fmt.Println(\"Days with temperatures exceeding 25\u00b0C:\", selectedDays)\n}\n\n// filter function to select days based on a condition\nfunc filter(report map[string]float64, condition func(float64) bool) []string {\n    var result []string\n    for day, temp := range report {\n        if condition(temp) {\n            result = append(result, day)\n        }\n    }\n    return result\n}\n```"
  },
  {
    "task": "Find all recipes that are vegetarian from a cookbook.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\ntype Recipe struct {\n\tName       string\n\tIsVegetarian bool\n}\n\nfunc filterVegetarian(recipes []Recipe) []Recipe {\n\tvar vegetarianRecipes []Recipe\n\tfor _, recipe := range recipes {\n\t\tif recipe.IsVegetarian {\n\t\t\tvegetarianRecipes = append(vegetarianRecipes, recipe)\n\t\t}\n\t}\n\treturn vegetarianRecipes\n}\n\nfunc main() {\n\tcookbook := []Recipe{\n\t\t{\"Spaghetti Bolognese\", false},\n\t\t{\"Margherita Pizza\", true},\n\t\t{\"Vegetable Stir Fry\", true},\n\t\t{\"Chicken Curry\", false},\n\t}\n\n\tvegetarianRecipes := filterVegetarian(cookbook)\n\tfor _, recipe := range vegetarianRecipes {\n\t\tfmt.Println(recipe.Name)\n\t}\n}\n```"
  },
  {
    "task": "Identify all articles that mention a specific keyword from a news feed.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc filterArticles(articles []string, keyword string) []string {\n\tfiltered := make([]string, 0)\n\tfor _, article := range articles {\n\t\tif strings.Contains(article, keyword) {\n\t\t\tfiltered = append(filtered, article)\n\t\t}\n\t}\n\treturn filtered\n}\n\nfunc main() {\n\tnewsFeed := []string{\n\t\t\"Breaking news: Go is gaining popularity among developers\",\n\t\t\"Tech giants are adopting Go for high performance applications\",\n\t\t\"Economic trends to watch in the next quarter\",\n\t\t\"Go's simplicity makes it a favorite for new programmers\",\n\t}\n\n\tkeyword := \"Go\"\n\tmatchingArticles := filterArticles(newsFeed, keyword)\n\n\tfmt.Println(\"Articles mentioning the keyword:\", keyword)\n\tfor _, article := range matchingArticles {\n\t\tfmt.Println(\"-\", article)\n\t}\n}\n```"
  },
  {
    "task": "Extract all files with the '.jpg' extension from a directory.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nfunc main() {\n\tfiles, err := ioutil.ReadDir(\"./\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tjpgFiles := filter(files, func(file string) bool {\n\t\treturn strings.HasSuffix(file, \".jpg\")\n\t})\n\n\tfor _, file := range jpgFiles {\n\t\tfmt.Println(file)\n\t}\n}\n\nfunc filter(files []os.FileInfo, predicate func(string) bool) []string {\n\tvar result []string\n\tfor _, file := range files {\n\t\tif predicate(file.Name()) {\n\t\t\tresult = append(result, file.Name())\n\t\t}\n\t}\n\treturn result\n}\n```"
  },
  {
    "task": "Filter out all transactions that are not categorized from a financial statement.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\ntype Transaction struct {\n\tAmount     float64\n\tCategory   string\n}\n\nfunc filterCategorized(transactions []Transaction) []Transaction {\n\tvar filtered []Transaction\n\tfor _, t := range transactions {\n\t\tif t.Category != \"\" {\n\t\t\tfiltered = append(filtered, t)\n\t\t}\n\t}\n\treturn filtered\n}\n\nfunc main() {\n\ttransactions := []Transaction{\n\t\t{Amount: 100.0, Category: \"Groceries\"},\n\t\t{Amount: 50.0, Category: \"\"},\n\t\t{Amount: 200.0, Category: \"Rent\"},\n\t\t{Amount: 30.0, Category: \"\"},\n\t}\n\n\tcategorizedTransactions := filterCategorized(transactions)\n\tfmt.Println(categorizedTransactions)\n}\n```"
  },
  {
    "task": "Select all paintings created before 1900 from an art gallery collection.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Painting represents a painting with a title and creation year\ntype Painting struct {\n\tTitle string\n\tYear  int\n}\n\n// FilterPaintings filters paintings created before 1900\nfunc FilterPaintings(paintings []Painting) []Painting {\n\tvar filtered []Painting\n\tfor _, p := range paintings {\n\t\tif p.Year < 1900 {\n\t\t\tfiltered = append(filtered, p)\n\t\t}\n\t}\n\treturn filtered\n}\n\nfunc main() {\n\tpaintings := []Painting{\n\t\t{\"Starry Night\", 1889},\n\t\t{\"The Persistence of Memory\", 1931},\n\t\t{\"The Birth of Venus\", 1486},\n\t\t{\"American Gothic\", 1930},\n\t}\n\n\tfilteredPaintings := FilterPaintings(paintings)\n\tfor _, p := range filteredPaintings {\n\t\tfmt.Println(p.Title)\n\t}\n}\n```"
  },
  {
    "task": "Find all students with perfect attendance from a school record.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\ntype Student struct {\n\tName             string\n\tPerfectAttendance bool\n}\n\nfunc filterStudents(students []Student, predicate func(Student) bool) []Student {\n\tvar filtered []Student\n\tfor _, student := range students {\n\t\tif predicate(student) {\n\t\t\tfiltered = append(filtered, student)\n\t\t}\n\t}\n\treturn filtered\n}\n\nfunc main() {\n\tstudents := []Student{\n\t\t{\"Alice\", true},\n\t\t{\"Bob\", false},\n\t\t{\"Charlie\", true},\n\t}\n\n\tperfectAttendance := filterStudents(students, func(s Student) bool {\n\t\treturn s.PerfectAttendance\n\t})\n\n\tfmt.Println(perfectAttendance)\n}\n```"
  },
  {
    "task": "Identify all messages sent by a specific user from a chat application.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\ntype Message struct {\n\tSender  string\n\tContent string\n}\n\nfunc FilterMessagesByUser(messages []Message, username string) []Message {\n\tvar filteredMessages []Message\n\tfor _, message := range messages {\n\t\tif message.Sender == username {\n\t\t\tfilteredMessages = append(filteredMessages, message)\n\t\t}\n\t}\n\treturn filteredMessages\n}\n\nfunc main() {\n\tmessages := []Message{\n\t\t{\"Alice\", \"Hello!\"},\n\t\t{\"Bob\", \"Hi!\"},\n\t\t{\"Alice\", \"How are you?\"},\n\t\t{\"Charlie\", \"Good morning!\"},\n\t}\n\n\tuserMessages := FilterMessagesByUser(messages, \"Alice\")\n\tfmt.Println(userMessages)\n}\n```"
  },
  {
    "task": "Extract all elements greater than 100 from an array of numbers.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc filter(numbers []int, predicate func(int) bool) []int {\n\tvar result []int\n\tfor _, number := range numbers {\n\t\tif predicate(number) {\n\t\t\tresult = append(result, number)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc main() {\n\tnumbers := []int{150, 45, 200, 99, 105, 88, 300}\n\tfilteredNumbers := filter(numbers, func(n int) bool {\n\t\treturn n > 100\n\t})\n\tfmt.Println(filteredNumbers)\n}\n```"
  },
  {
    "task": "Filter out all words that do not end in 'ed' from a paragraph.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc main() {\n\tparagraph := \"He walked and talked but he never mentioned the things he avoided.\"\n\twords := strings.Fields(paragraph)\n\n\tfilteredWords := filter(words, func(word string) bool {\n\t\treturn strings.HasSuffix(word, \"ed\")\n\t})\n\n\tfmt.Println(strings.Join(filteredWords, \" \"))\n}\n\nfunc filter(words []string, predicate func(string) bool) []string {\n\tvar result []string\n\tfor _, word := range words {\n\t\tif predicate(word) {\n\t\t\tresult = append(result, word)\n\t\t}\n\t}\n\treturn result\n}\n```"
  },
  {
    "task": "Select all flights departing before noon from a flight schedule.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\ntype Flight struct {\n\tDeparture time.Time\n}\n\nfunc filterFlights(flights []Flight, filterFunc func(Flight) bool) []Flight {\n\tvar filteredFlights []Flight\n\tfor _, flight := range flights {\n\t\tif filterFunc(flight) {\n\t\t\tfilteredFlights = append(filteredFlights, flight)\n\t\t}\n\t}\n\treturn filteredFlights\n}\n\nfunc main() {\n\tflights := []Flight{\n\t\t{Departure: time.Date(2023, time.October, 15, 8, 0, 0, 0, time.UTC)},\n\t\t{Departure: time.Date(2023, time.October, 15, 14, 0, 0, 0, time.UTC)},\n\t\t{Departure: time.Date(2023, time.October, 15, 11, 30, 0, 0, time.UTC)},\n\t}\n\n\tbeforeNoon := func(f Flight) bool {\n\t\treturn f.Departure.Hour() < 12\n\t}\n\n\tmorningFlights := filterFlights(flights, beforeNoon)\n\n\tfor _, flight := range morningFlights {\n\t\tfmt.Println(flight.Departure)\n\t}\n}\n```"
  },
  {
    "task": "Find all products priced above $20 from an online store inventory.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\ntype Product struct {\n\tName  string\n\tPrice float64\n}\n\nfunc filter(products []Product, predicate func(Product) bool) []Product {\n\tvar filtered []Product\n\tfor _, product := range products {\n\t\tif predicate(product) {\n\t\t\tfiltered = append(filtered, product)\n\t\t}\n\t}\n\treturn filtered\n}\n\nfunc main() {\n\tinventory := []Product{\n\t\t{\"Book\", 10.99},\n\t\t{\"Laptop\", 999.99},\n\t\t{\"Pen\", 2.49},\n\t\t{\"Headphones\", 49.99},\n\t\t{\"Coffee Mug\", 7.99},\n\t}\n\n\tabove20 := filter(inventory, func(p Product) bool {\n\t\treturn p.Price > 20.0\n\t})\n\n\tfmt.Println(\"Products priced above $20:\")\n\tfor _, product := range above20 {\n\t\tfmt.Printf(\"Name: %s, Price: %.2f\\n\", product.Name, product.Price)\n\t}\n}\n```"
  },
  {
    "task": "Identify all sessions longer than one hour from a webinar series.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\ntype Session struct {\n\tTitle    string\n\tDuration time.Duration\n}\n\nfunc filterSessions(sessions []Session, predicate func(Session) bool) []Session {\n\tvar filtered []Session\n\tfor _, session := range sessions {\n\t\tif predicate(session) {\n\t\t\tfiltered = append(filtered, session)\n\t\t}\n\t}\n\treturn filtered\n}\n\nfunc main() {\n\tsessions := []Session{\n\t\t{\"Session 1\", 30 * time.Minute},\n\t\t{\"Session 2\", 90 * time.Minute},\n\t\t{\"Session 3\", 45 * time.Minute},\n\t\t{\"Session 4\", 120 * time.Minute},\n\t}\n\n\tlongSessions := filterSessions(sessions, func(s Session) bool {\n\t\treturn s.Duration > time.Hour\n\t})\n\n\tfor _, session := range longSessions {\n\t\tfmt.Println(session.Title)\n\t}\n}\n```"
  },
  {
    "task": "Extract all images with a resolution higher than 1080p from a photo library.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\ntype Image struct {\n\tWidth  int\n\tHeight int\n}\n\nfunc filterImages(images []Image, filterFunc func(Image) bool) []Image {\n\tvar filtered []Image\n\tfor _, img := range images {\n\t\tif filterFunc(img) {\n\t\t\tfiltered = append(filtered, img)\n\t\t}\n\t}\n\treturn filtered\n}\n\nfunc main() {\n\timages := []Image{\n\t\t{1920, 1080},\n\t\t{2560, 1440},\n\t\t{1280, 720},\n\t\t{3840, 2160},\n\t\t{1024, 768},\n\t}\n\n\tfilteredImages := filterImages(images, func(img Image) bool {\n\t\treturn img.Width > 1920 || img.Height > 1080\n\t})\n\n\tfmt.Println(\"Filtered Images:\")\n\tfor _, img := range filteredImages {\n\t\tfmt.Printf(\"Width: %d, Height: %d\\n\", img.Width, img.Height)\n\t}\n}\n```"
  },
  {
    "task": "Filter out all responses that are not 'yes' or 'no' from a survey result.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc filterResponses(responses []string) []string {\n\tvalidResponses := []string{\"yes\", \"no\"}\n\tvar filtered []string\n\tfor _, response := range responses {\n\t\tif contains(validResponses, response) {\n\t\t\tfiltered = append(filtered, response)\n\t\t}\n\t}\n\treturn filtered\n}\n\nfunc contains(slice []string, item string) bool {\n\tfor _, v := range slice {\n\t\tif v == item {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc main() {\n\tsurveyResponses := []string{\"yes\", \"no\", \"maybe\", \"yes\", \"no\", \"unknown\", \"yes\"}\n\tfilteredResponses := filterResponses(surveyResponses)\n\tfmt.Println(filteredResponses)\n}\n```"
  },
  {
    "task": "Select all tweets with more than 100 likes from a Twitter feed.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\ntype Tweet struct {\n\tContent string\n\tLikes   int\n}\n\nfunc filterTweets(tweets []Tweet, condition func(Tweet) bool) []Tweet {\n\tvar filtered []Tweet\n\tfor _, tweet := range tweets {\n\t\tif condition(tweet) {\n\t\t\tfiltered = append(filtered, tweet)\n\t\t}\n\t}\n\treturn filtered\n}\n\nfunc main() {\n\ttweets := []Tweet{\n\t\t{\"Hello World\", 50},\n\t\t{\"Go is great\", 150},\n\t\t{\"Functional programming in Go\", 200},\n\t\t{\"Let's filter tweets\", 80},\n\t}\n\n\tmoreThan100Likes := func(tweet Tweet) bool {\n\t\treturn tweet.Likes > 100\n\t}\n\n\tresult := filterTweets(tweets, moreThan100Likes)\n\tfmt.Println(result)\n}\n```"
  },
  {
    "task": "Find all links that are broken from a webpage.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"golang.org/x/net/html\"\n\t\"strings\"\n)\n\nfunc getLinksFromURL(url string) ([]string, error) {\n\tresponse, err := http.Get(url)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer response.Body.Close()\n\n\ttokenizer := html.NewTokenizer(response.Body)\n\tvar links []string\n\n\tfor {\n\t\ttt := tokenizer.Next()\n\t\tswitch tt {\n\t\tcase html.ErrorToken:\n\t\t\treturn links, nil\n\t\tcase html.StartTagToken, html.SelfClosingTagToken:\n\t\t\ttoken := tokenizer.Token()\n\t\t\tif token.Data == \"a\" {\n\t\t\t\tfor _, attr := range token.Attr {\n\t\t\t\t\tif attr.Key == \"href\" {\n\t\t\t\t\t\tlinks = append(links, attr.Val)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc isLinkBroken(url string) bool {\n\tresp, err := http.Head(url)\n\tif err != nil || resp.StatusCode >= 400 {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc filterBrokenLinks(links []string) []string {\n\tbrokenLinks := []string{}\n\tfor _, link := range links {\n\t\tif isLinkBroken(link) {\n\t\t\tbrokenLinks = append(brokenLinks, link)\n\t\t}\n\t}\n\treturn brokenLinks\n}\n\nfunc main() {\n\turl := \"http://example.com\" // Replace with target URL\n\tlinks, err := getLinksFromURL(url)\n\tif err != nil {\n\t\tfmt.Println(\"Error fetching links:\", err)\n\t\treturn\n\t}\n\n\tbrokenLinks := filterBrokenLinks(links)\n\tfmt.Println(\"Broken Links:\")\n\tfor _, link := range brokenLinks {\n\t\tfmt.Println(link)\n\t}\n}\n```"
  },
  {
    "task": "Identify all machines that are currently offline from a network monitoring tool.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\ntype Machine struct {\n\tName   string\n\tStatus string\n}\n\nfunc filterMachines(machines []Machine, predicate func(Machine) bool) []Machine {\n\tvar result []Machine\n\tfor _, machine := range machines {\n\t\tif predicate(machine) {\n\t\t\tresult = append(result, machine)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc main() {\n\tmachines := []Machine{\n\t\t{\"Machine1\", \"online\"},\n\t\t{\"Machine2\", \"offline\"},\n\t\t{\"Machine3\", \"offline\"},\n\t\t{\"Machine4\", \"online\"},\n\t}\n\n\tofflineMachines := filterMachines(machines, func(m Machine) bool {\n\t\treturn m.Status == \"offline\"\n\t})\n\n\tfmt.Println(\"Offline Machines:\")\n\tfor _, m := range offlineMachines {\n\t\tfmt.Println(m.Name)\n\t}\n}\n```"
  },
  {
    "task": "Extract all invoices with a due date in the current month from an accounting system.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\ntype Invoice struct {\n\tID      int\n\tDueDate time.Time\n}\n\nfunc filterInvoicesByCurrentMonth(invoices []Invoice) []Invoice {\n\tcurrentYear, currentMonth, _ := time.Now().Date()\n\treturn filter(invoices, func(inv Invoice) bool {\n\t\tyear, month, _ := inv.DueDate.Date()\n\t\treturn year == currentYear && month == currentMonth\n\t})\n}\n\nfunc filter(invoices []Invoice, predicate func(Invoice) bool) []Invoice {\n\tvar result []Invoice\n\tfor _, inv := range invoices {\n\t\tif predicate(inv) {\n\t\t\tresult = append(result, inv)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc main() {\n\tinvoices := []Invoice{\n\t\t{ID: 1, DueDate: time.Date(2023, 10, 1, 0, 0, 0, 0, time.UTC)},\n\t\t{ID: 2, DueDate: time.Date(2023, 11, 15, 0, 0, 0, 0, time.UTC)},\n\t\t{ID: 3, DueDate: time.Now()},\n\t}\n\n\tcurrentMonthInvoices := filterInvoicesByCurrentMonth(invoices)\n\tfor _, inv := range currentMonthInvoices {\n\t\tfmt.Printf(\"Invoice ID: %d, Due Date: %s\\n\", inv.ID, inv.DueDate)\n\t}\n}\n```"
  },
  {
    "task": "Filter out all lines in a file that start with a '#' from a configuration file.",
    "code": "```go\npackage main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n)\n\nfunc main() {\n\tfile, err := os.Open(\"config.txt\")\n\tif err != nil {\n\t\tfmt.Println(\"Error opening file:\", err)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\tscanner := bufio.NewScanner(file)\n\tfor scanner.Scan() {\n\t\tline := scanner.Text()\n\t\tif !strings.HasPrefix(line, \"#\") {\n\t\t\tfmt.Println(line)\n\t\t}\n\t}\n\n\tif err := scanner.Err(); err != nil {\n\t\tfmt.Println(\"Error reading file:\", err)\n\t}\n}\n```"
  },
  {
    "task": "Select all posts with a comment count higher than 50 from a blog.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\ntype Post struct {\n\tTitle        string\n\tCommentCount int\n}\n\nfunc filterPosts(posts []Post, predicate func(Post) bool) []Post {\n\tvar filteredPosts []Post\n\tfor _, post := range posts {\n\t\tif predicate(post) {\n\t\t\tfilteredPosts = append(filteredPosts, post)\n\t\t}\n\t}\n\treturn filteredPosts\n}\n\nfunc main() {\n\tposts := []Post{\n\t\t{\"Post 1\", 45},\n\t\t{\"Post 2\", 75},\n\t\t{\"Post 3\", 30},\n\t\t{\"Post 4\", 100},\n\t}\n\n\tfiltered := filterPosts(posts, func(p Post) bool {\n\t\treturn p.CommentCount > 50\n\t})\n\n\tfor _, post := range filtered {\n\t\tfmt.Println(post.Title)\n\t}\n}\n```"
  },
  {
    "task": "Find all offers that expire within the next week from a promotional database.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\ntype Offer struct {\n\tID     string\n\tExpiry time.Time\n}\n\nfunc filterOffers(offers []Offer, filterFunc func(Offer) bool) []Offer {\n\tvar filtered []Offer\n\tfor _, offer := range offers {\n\t\tif filterFunc(offer) {\n\t\t\tfiltered = append(filtered, offer)\n\t\t}\n\t}\n\treturn filtered\n}\n\nfunc main() {\n\toffers := []Offer{\n\t\t{\"1\", time.Now().AddDate(0, 0, 3)},\n\t\t{\"2\", time.Now().AddDate(0, 0, 10)},\n\t\t{\"3\", time.Now().AddDate(0, 0, 6)},\n\t}\n\n\tnextWeek := time.Now().AddDate(0, 0, 7)\n\texpiringSoonOffers := filterOffers(offers, func(o Offer) bool {\n\t\treturn o.Expiry.Before(nextWeek)\n\t})\n\n\tfmt.Println(\"Offers expiring within the next week:\")\n\tfor _, offer := range expiringSoonOffers {\n\t\tfmt.Printf(\"Offer ID: %s, Expiry: %s\\n\", offer.ID, offer.Expiry)\n\t}\n}\n```"
  },
  {
    "task": "Identify all items that are on sale from a shopping catalog.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\ntype Item struct {\n\tName  string\n\tPrice float64\n\tOnSale bool\n}\n\nfunc filterOnSaleItems(items []Item) []Item {\n\tonSaleItems := []Item{}\n\tfor _, item := range items {\n\t\tif item.OnSale {\n\t\t\tonSaleItems = append(onSaleItems, item)\n\t\t}\n\t}\n\treturn onSaleItems\n}\n\nfunc main() {\n\tcatalog := []Item{\n\t\t{\"Shirt\", 29.99, false},\n\t\t{\"Jeans\", 49.99, true},\n\t\t{\"Jacket\", 89.99, true},\n\t\t{\"Shoes\", 59.99, false},\n\t}\n\n\tonSaleItems := filterOnSaleItems(catalog)\n\tfmt.Println(\"Items on sale:\")\n\tfor _, item := range onSaleItems {\n\t\tfmt.Printf(\"- %s: $%.2f\\n\", item.Name, item.Price)\n\t}\n}\n```"
  },
  {
    "task": "Extract all notes that mention 'urgent' from a meeting record.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc filterNotes(notes []string, keyword string) []string {\n\treturn filter(notes, func(note string) bool {\n\t\treturn strings.Contains(note, keyword)\n\t})\n}\n\nfunc filter(notes []string, predicate func(string) bool) []string {\n\tvar result []string\n\tfor _, note := range notes {\n\t\tif predicate(note) {\n\t\t\tresult = append(result, note)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc main() {\n\tmeetingNotes := []string{\n\t\t\"Discuss budget allocation\",\n\t\t\"urgent: finalize project deadline\",\n\t\t\"Plan team building event\",\n\t\t\"urgent: review quarterly results\",\n\t}\n\n\turgentNotes := filterNotes(meetingNotes, \"urgent\")\n\tfmt.Println(urgentNotes)\n}\n```"
  },
  {
    "task": "Filter out all numbers that do not have a remainder when divided by two from a list.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc filterEvenNumbers(numbers []int) []int {\n\tvar result []int\n\tfor _, num := range numbers {\n\t\tif num%2 != 0 {\n\t\t\tresult = append(result, num)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc main() {\n\tnumbers := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\n\tfiltered := filterEvenNumbers(numbers)\n\tfmt.Println(filtered)\n}\n```"
  },
  {
    "task": "Select all concerts happening in the summer from an event calendar.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\ntype Event struct {\n\tName string\n\tDate time.Time\n}\n\nfunc filterSummerConcerts(events []Event) []Event {\n\tvar summerConcerts []Event\n\tfor _, event := range events {\n\t\tif isSummer(event.Date) {\n\t\t\tsummerConcerts = append(summerConcerts, event)\n\t\t}\n\t}\n\treturn summerConcerts\n}\n\nfunc isSummer(date time.Time) bool {\n\tmonth := date.Month()\n\treturn month == time.June || month == time.July || month == time.August\n}\n\nfunc main() {\n\tevents := []Event{\n\t\t{\"Concert A\", time.Date(2023, 5, 15, 0, 0, 0, 0, time.UTC)},\n\t\t{\"Concert B\", time.Date(2023, 6, 21, 0, 0, 0, 0, time.UTC)},\n\t\t{\"Concert C\", time.Date(2023, 7, 10, 0, 0, 0, 0, time.UTC)},\n\t\t{\"Concert D\", time.Date(2023, 8, 30, 0, 0, 0, 0, time.UTC)},\n\t\t{\"Concert E\", time.Date(2023, 9, 5, 0, 0, 0, 0, time.UTC)},\n\t}\n\n\tsummerConcerts := filterSummerConcerts(events)\n\tfor _, concert := range summerConcerts {\n\t\tfmt.Println(concert.Name, concert.Date.Format(\"2006-01-02\"))\n\t}\n}\n```"
  },
  {
    "task": "Find all users with more than 1000 followers from a social media platform.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\ntype User struct {\n\tName      string\n\tFollowers int\n}\n\nfunc filterUsers(users []User, predicate func(User) bool) []User {\n\tvar filteredUsers []User\n\tfor _, user := range users {\n\t\tif predicate(user) {\n\t\t\tfilteredUsers = append(filteredUsers, user)\n\t\t}\n\t}\n\treturn filteredUsers\n}\n\nfunc main() {\n\tusers := []User{\n\t\t{\"Alice\", 1500},\n\t\t{\"Bob\", 800},\n\t\t{\"Charlie\", 2000},\n\t\t{\"Diana\", 500},\n\t}\n\n\tmoreThan1000Followers := func(u User) bool {\n\t\treturn u.Followers > 1000\n\t}\n\n\tresult := filterUsers(users, moreThan1000Followers)\n\tfmt.Println(result)\n}\n```"
  },
  {
    "task": "Identify all stocks with a growth rate above 10% from a financial portfolio.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\ntype Stock struct {\n\tName       string\n\tGrowthRate float64\n}\n\nfunc filterStocks(stocks []Stock, filterFunc func(Stock) bool) []Stock {\n\tvar result []Stock\n\tfor _, stock := range stocks {\n\t\tif filterFunc(stock) {\n\t\t\tresult = append(result, stock)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc main() {\n\tportfolio := []Stock{\n\t\t{\"StockA\", 12.5},\n\t\t{\"StockB\", 8.0},\n\t\t{\"StockC\", 15.0},\n\t\t{\"StockD\", 9.5},\n\t\t{\"StockE\", 11.0},\n\t}\n\n\tgrowthFilter := func(stock Stock) bool {\n\t\treturn stock.GrowthRate > 10.0\n\t}\n\n\tfilteredStocks := filterStocks(portfolio, growthFilter)\n\n\tfor _, stock := range filteredStocks {\n\t\tfmt.Println(stock.Name)\n\t}\n}\n```"
  },
  {
    "task": "Extract all reviews that have a five-star rating from a product review site.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\ntype Review struct {\n\tRating int\n\tText   string\n}\n\nfunc filterFiveStarReviews(reviews []Review) []Review {\n\tvar fiveStarReviews []Review\n\tfor _, review := range reviews {\n\t\tif review.Rating == 5 {\n\t\t\tfiveStarReviews = append(fiveStarReviews, review)\n\t\t}\n\t}\n\treturn fiveStarReviews\n}\n\nfunc main() {\n\treviews := []Review{\n\t\t{Rating: 5, Text: \"Excellent product!\"},\n\t\t{Rating: 4, Text: \"Very good, but could be better.\"},\n\t\t{Rating: 5, Text: \"Absolutely love this!\"},\n\t\t{Rating: 3, Text: \"Average experience.\"},\n\t}\n\n\tfiveStarReviews := filterFiveStarReviews(reviews)\n\tfmt.Println(fiveStarReviews)\n}\n```"
  },
  {
    "task": "Filter out all emails that are not flagged from an inbox.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\ntype Email struct {\n\tSubject string\n\tFlagged bool\n}\n\nfunc filterFlaggedEmails(emails []Email) []Email {\n\tvar flaggedEmails []Email\n\tfor _, email := range emails {\n\t\tif email.Flagged {\n\t\t\tflaggedEmails = append(flaggedEmails, email)\n\t\t}\n\t}\n\treturn flaggedEmails\n}\n\nfunc main() {\n\tinbox := []Email{\n\t\t{Subject: \"Hello World\", Flagged: true},\n\t\t{Subject: \"Go Programming\", Flagged: false},\n\t\t{Subject: \"Meeting Reminder\", Flagged: true},\n\t}\n\n\tflaggedEmails := filterFlaggedEmails(inbox)\n\tfmt.Println(\"Flagged Emails:\")\n\tfor _, email := range flaggedEmails {\n\t\tfmt.Println(email.Subject)\n\t}\n}\n```"
  },
  {
    "task": "Select all entries with a timestamp from the past 24 hours from a log file.",
    "code": "```go\npackage main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n\t\"time\"\n)\n\nfunc main() {\n\tfile, err := os.Open(\"logfile.txt\")\n\tif err != nil {\n\t\tfmt.Println(\"Error opening file:\", err)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\tnow := time.Now()\n\tpast24Hours := now.Add(-24 * time.Hour)\n\n\tscanner := bufio.NewScanner(file)\n\tfor scanner.Scan() {\n\t\tline := scanner.Text()\n\t\tparts := strings.Split(line, \" \")\n\t\tif len(parts) < 2 {\n\t\t\tcontinue\n\t\t}\n\n\t\ttimestamp, err := time.Parse(time.RFC3339, parts[0])\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tif timestamp.After(past24Hours) {\n\t\t\tfmt.Println(line)\n\t\t}\n\t}\n\n\tif err := scanner.Err(); err != nil {\n\t\tfmt.Println(\"Error reading file:\", err)\n\t}\n}\n```"
  },
  {
    "task": "Find all books by a specific author from a library database.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\ntype Book struct {\n\tTitle  string\n\tAuthor string\n}\n\nfunc filterBooksByAuthor(books []Book, author string) []Book {\n\tvar result []Book\n\tfor _, book := range books {\n\t\tif book.Author == author {\n\t\t\tresult = append(result, book)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc main() {\n\tlibrary := []Book{\n\t\t{Title: \"Book One\", Author: \"Author A\"},\n\t\t{Title: \"Book Two\", Author: \"Author B\"},\n\t\t{Title: \"Book Three\", Author: \"Author A\"},\n\t}\n\n\tauthor := \"Author A\"\n\tbooksByAuthor := filterBooksByAuthor(library, author)\n\n\tfmt.Println(\"Books by\", author, \":\")\n\tfor _, book := range booksByAuthor {\n\t\tfmt.Println(book.Title)\n\t}\n}\n```"
  },
  {
    "task": "Identify all donations above $500 from a charity fundraiser report.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc filterDonations(donations []float64, threshold float64) []float64 {\n\treturn filter(donations, func(donation float64) bool {\n\t\treturn donation > threshold\n\t})\n}\n\nfunc filter(slice []float64, predicate func(float64) bool) []float64 {\n\tvar result []float64\n\tfor _, item := range slice {\n\t\tif predicate(item) {\n\t\t\tresult = append(result, item)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc main() {\n\tdonations := []float64{100.0, 250.0, 600.0, 50.0, 700.0, 800.0}\n\tthreshold := 500.0\n\thighDonations := filterDonations(donations, threshold)\n\tfmt.Println(highDonations)\n}\n```"
  },
  {
    "task": "Extract all assignments due in the next week from a course syllabus.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\ntype Assignment struct {\n\tTitle string\n\tDue   time.Time\n}\n\nfunc filterAssignmentsDueNextWeek(assignments []Assignment) []Assignment {\n\tnow := time.Now()\n\toneWeekLater := now.AddDate(0, 0, 7)\n\n\tfiltered := filter(assignments, func(a Assignment) bool {\n\t\treturn a.Due.After(now) && a.Due.Before(oneWeekLater)\n\t})\n\n\treturn filtered\n}\n\nfunc filter(assignments []Assignment, test func(Assignment) bool) []Assignment {\n\tvar result []Assignment\n\tfor _, a := range assignments {\n\t\tif test(a) {\n\t\t\tresult = append(result, a)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc main() {\n\tassignments := []Assignment{\n\t\t{\"Assignment 1\", time.Now().AddDate(0, 0, 3)},\n\t\t{\"Assignment 2\", time.Now().AddDate(0, 0, 8)},\n\t\t{\"Assignment 3\", time.Now().AddDate(0, 0, 5)},\n\t}\n\n\tdueNextWeek := filterAssignmentsDueNextWeek(assignments)\n\n\tfor _, a := range dueNextWeek {\n\t\tfmt.Println(a.Title, \"is due on\", a.Due)\n\t}\n}\n```"
  },
  {
    "task": "Filter out all movies that are not in English from a streaming service.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\ntype Movie struct {\n\tTitle    string\n\tLanguage string\n}\n\nfunc filterEnglishMovies(movies []Movie) []Movie {\n\tvar englishMovies []Movie\n\tfor _, movie := range movies {\n\t\tif movie.Language == \"English\" {\n\t\t\tenglishMovies = append(englishMovies, movie)\n\t\t}\n\t}\n\treturn englishMovies\n}\n\nfunc main() {\n\tmovies := []Movie{\n\t\t{Title: \"Movie 1\", Language: \"English\"},\n\t\t{Title: \"Movie 2\", Language: \"Spanish\"},\n\t\t{Title: \"Movie 3\", Language: \"English\"},\n\t\t{Title: \"Movie 4\", Language: \"French\"},\n\t}\n\n\tenglishMovies := filterEnglishMovies(movies)\n\tfmt.Println(\"English Movies:\")\n\tfor _, movie := range englishMovies {\n\t\tfmt.Println(movie.Title)\n\t}\n}\n```"
  },
  {
    "task": "Select all landmarks located in Europe from a travel guide.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\ntype Landmark struct {\n\tName     string\n\tLocation string\n}\n\nfunc filterLandmarks(landmarks []Landmark, predicate func(Landmark) bool) []Landmark {\n\tvar result []Landmark\n\tfor _, landmark := range landmarks {\n\t\tif predicate(landmark) {\n\t\t\tresult = append(result, landmark)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc main() {\n\tlandmarks := []Landmark{\n\t\t{\"Eiffel Tower\", \"Europe\"},\n\t\t{\"Great Wall of China\", \"Asia\"},\n\t\t{\"Colosseum\", \"Europe\"},\n\t\t{\"Statue of Liberty\", \"North America\"},\n\t}\n\n\teuropeanLandmarks := filterLandmarks(landmarks, func(l Landmark) bool {\n\t\treturn l.Location == \"Europe\"\n\t})\n\n\tfor _, landmark := range europeanLandmarks {\n\t\tfmt.Println(landmark.Name)\n\t}\n}\n```"
  },
  {
    "task": "Find all contracts that are set to renew next month from a contract management system.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\ntype Contract struct {\n\tID         int\n\tRenewalDate time.Time\n}\n\nfunc filterContracts(contracts []Contract, predicate func(Contract) bool) []Contract {\n\tvar result []Contract\n\tfor _, contract := range contracts {\n\t\tif predicate(contract) {\n\t\t\tresult = append(result, contract)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc main() {\n\tcontracts := []Contract{\n\t\t{ID: 1, RenewalDate: time.Date(2023, time.December, 15, 0, 0, 0, 0, time.UTC)},\n\t\t{ID: 2, RenewalDate: time.Date(2023, time.November, 5, 0, 0, 0, 0, time.UTC)},\n\t\t{ID: 3, RenewalDate: time.Date(2023, time.November, 20, 0, 0, 0, 0, time.UTC)},\n\t\t{ID: 4, RenewalDate: time.Date(2024, time.January, 10, 0, 0, 0, 0, time.UTC)},\n\t}\n\n\tnow := time.Now()\n\tnextMonth := now.AddDate(0, 1, 0)\n\n\trenewNextMonth := filterContracts(contracts, func(c Contract) bool {\n\t\treturn c.RenewalDate.Month() == nextMonth.Month() && c.RenewalDate.Year() == nextMonth.Year()\n\t})\n\n\tfmt.Println(\"Contracts set to renew next month:\")\n\tfor _, contract := range renewNextMonth {\n\t\tfmt.Printf(\"Contract ID: %d, Renewal Date: %s\\n\", contract.ID, contract.RenewalDate)\n\t}\n}\n```"
  },
  {
    "task": "Identify all volunteer hours logged in the past year from a non-profit organization database.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\ntype LogEntry struct {\n\tVolunteerID string\n\tHours       int\n\tDate        time.Time\n}\n\nfunc filterLogs(entries []LogEntry, filterFunc func(LogEntry) bool) []LogEntry {\n\tvar filtered []LogEntry\n\tfor _, entry := range entries {\n\t\tif filterFunc(entry) {\n\t\t\tfiltered = append(filtered, entry)\n\t\t}\n\t}\n\treturn filtered\n}\n\nfunc main() {\n\tlogs := []LogEntry{\n\t\t{\"vol1\", 5, time.Date(2023, 10, 1, 0, 0, 0, 0, time.UTC)},\n\t\t{\"vol2\", 3, time.Date(2022, 9, 30, 0, 0, 0, 0, time.UTC)},\n\t\t{\"vol3\", 8, time.Date(2023, 5, 15, 0, 0, 0, 0, time.UTC)},\n\t}\n\n\toneYearAgo := time.Now().AddDate(-1, 0, 0)\n\trecentLogs := filterLogs(logs, func(entry LogEntry) bool {\n\t\treturn entry.Date.After(oneYearAgo)\n\t})\n\n\tfor _, log := range recentLogs {\n\t\tfmt.Printf(\"VolunteerID: %s, Hours: %d, Date: %s\\n\", log.VolunteerID, log.Hours, log.Date)\n\t}\n}\n```"
  },
  {
    "task": "Extract all elements that are not strings from a mixed-type list.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n)\n\nfunc filterNonStrings(input []interface{}) []interface{} {\n\tvar result []interface{}\n\tfor _, item := range input {\n\t\tif reflect.TypeOf(item).Kind() != reflect.String {\n\t\t\tresult = append(result, item)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc main() {\n\tmixedList := []interface{}{1, \"apple\", 3.14, true, \"banana\", 42}\n\tfiltered := filterNonStrings(mixedList)\n\tfmt.Println(filtered)\n}\n```"
  },
  {
    "task": "Filter out all orders that are not yet shipped from an e-commerce system.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\ntype Order struct {\n\tID     int\n\tStatus string\n}\n\nfunc filterOrders(orders []Order, predicate func(Order) bool) []Order {\n\tvar filtered []Order\n\tfor _, order := range orders {\n\t\tif predicate(order) {\n\t\t\tfiltered = append(filtered, order)\n\t\t}\n\t}\n\treturn filtered\n}\n\nfunc main() {\n\torders := []Order{\n\t\t{ID: 1, Status: \"Shipped\"},\n\t\t{ID: 2, Status: \"Pending\"},\n\t\t{ID: 3, Status: \"Shipped\"},\n\t\t{ID: 4, Status: \"Processing\"},\n\t}\n\n\tshippedOrders := filterOrders(orders, func(o Order) bool {\n\t\treturn o.Status == \"Shipped\"\n\t})\n\n\tfmt.Println(shippedOrders)\n}\n```"
  },
  {
    "task": "Select all emails sent from a specific address in an email server.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\ntype Email struct {\n\tFrom    string\n\tSubject string\n\tBody    string\n}\n\nfunc filterEmails(emails []Email, address string) []Email {\n\tfiltered := make([]Email, 0)\n\tfor _, email := range emails {\n\t\tif strings.EqualFold(email.From, address) {\n\t\t\tfiltered = append(filtered, email)\n\t\t}\n\t}\n\treturn filtered\n}\n\nfunc main() {\n\temails := []Email{\n\t\t{From: \"example1@example.com\", Subject: \"Hello\", Body: \"Hello World\"},\n\t\t{From: \"example2@example.com\", Subject: \"Test\", Body: \"Test Email\"},\n\t\t{From: \"example1@example.com\", Subject: \"Re: Hello\", Body: \"Re: Hello World\"},\n\t}\n\n\tspecificAddress := \"example1@example.com\"\n\tselectedEmails := filterEmails(emails, specificAddress)\n\n\tfor _, email := range selectedEmails {\n\t\tfmt.Printf(\"From: %s, Subject: %s\\n\", email.From, email.Subject)\n\t}\n}\n```"
  },
  {
    "task": "Find all passwords with at least one special character from a security database.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"regexp\"\n)\n\nfunc filterPasswords(passwords []string, filterFunc func(string) bool) []string {\n\tvar result []string\n\tfor _, password := range passwords {\n\t\tif filterFunc(password) {\n\t\t\tresult = append(result, password)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc hasSpecialCharacter(s string) bool {\n\tre := regexp.MustCompile(`[!@#$%^&*(),.?\":{}|<>]`)\n\treturn re.MatchString(s)\n}\n\nfunc main() {\n\tpasswords := []string{\"password123\", \"secure!pass\", \"helloWorld\", \"pa$$word\", \"123456\"}\n\tfilteredPasswords := filterPasswords(passwords, hasSpecialCharacter)\n\tfmt.Println(filteredPasswords)\n}\n```"
  },
  {
    "task": "Identify all courses with a prerequisite from a university catalog.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\ntype Course struct {\n\tName        string\n\tPrerequisite bool\n}\n\nfunc filterCourses(courses []Course, predicate func(Course) bool) []Course {\n\tvar result []Course\n\tfor _, course := range courses {\n\t\tif predicate(course) {\n\t\t\tresult = append(result, course)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc main() {\n\tcourses := []Course{\n\t\t{\"Math 101\", false},\n\t\t{\"History 201\", true},\n\t\t{\"Chemistry 101\", true},\n\t\t{\"Physics 101\", false},\n\t}\n\n\tprerequisiteCourses := filterCourses(courses, func(c Course) bool {\n\t\treturn c.Prerequisite\n\t})\n\n\tfmt.Println(\"Courses with prerequisites:\")\n\tfor _, course := range prerequisiteCourses {\n\t\tfmt.Println(course.Name)\n\t}\n}\n```"
  },
  {
    "task": "Extract all genes associated with a specific trait from a genetic database.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\ntype Gene struct {\n\tName  string\n\tTrait string\n}\n\nfunc filterGenesByTrait(genes []Gene, trait string) []Gene {\n\treturn filter(genes, func(gene Gene) bool {\n\t\treturn strings.EqualFold(gene.Trait, trait)\n\t})\n}\n\nfunc filter(genes []Gene, predicate func(Gene) bool) []Gene {\n\tvar result []Gene\n\tfor _, gene := range genes {\n\t\tif predicate(gene) {\n\t\t\tresult = append(result, gene)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc main() {\n\tgenes := []Gene{\n\t\t{\"Gene1\", \"TraitA\"},\n\t\t{\"Gene2\", \"TraitB\"},\n\t\t{\"Gene3\", \"TraitA\"},\n\t\t{\"Gene4\", \"TraitC\"},\n\t}\n\n\ttrait := \"TraitA\"\n\tfilteredGenes := filterGenesByTrait(genes, trait)\n\tfmt.Println(\"Genes associated with\", trait+\":\")\n\tfor _, gene := range filteredGenes {\n\t\tfmt.Println(gene.Name)\n\t}\n}\n```"
  },
  {
    "task": "Filter out all investments with a risk level below medium from a portfolio.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\ntype Investment struct {\n\tName     string\n\tRiskLevel string\n}\n\nfunc filterInvestments(investments []Investment, riskThreshold string) []Investment {\n\tfiltered := []Investment{}\n\tfor _, investment := range investments {\n\t\tif investment.RiskLevel >= riskThreshold {\n\t\t\tfiltered = append(filtered, investment)\n\t\t}\n\t}\n\treturn filtered\n}\n\nfunc main() {\n\tportfolio := []Investment{\n\t\t{\"Investment A\", \"low\"},\n\t\t{\"Investment B\", \"medium\"},\n\t\t{\"Investment C\", \"high\"},\n\t}\n\n\tfilteredPortfolio := filterInvestments(portfolio, \"medium\")\n\n\tfor _, investment := range filteredPortfolio {\n\t\tfmt.Println(investment.Name, investment.RiskLevel)\n\t}\n}\n```"
  },
  {
    "task": "Select all calls longer than five minutes from a call log.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\ntype Call struct {\n\tDuration int // Duration in minutes\n}\n\nfunc FilterCalls(calls []Call, predicate func(Call) bool) []Call {\n\tvar result []Call\n\tfor _, call := range calls {\n\t\tif predicate(call) {\n\t\t\tresult = append(result, call)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc main() {\n\tcallLog := []Call{\n\t\t{Duration: 3},\n\t\t{Duration: 10},\n\t\t{Duration: 7},\n\t\t{Duration: 4},\n\t\t{Duration: 6},\n\t}\n\n\tlongCalls := FilterCalls(callLog, func(call Call) bool {\n\t\treturn call.Duration > 5\n\t})\n\n\tfmt.Println(longCalls)\n}\n```"
  }
]