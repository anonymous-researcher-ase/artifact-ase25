[
  {
    "task": "Create a program that continuously asks the user to enter a number until they input a negative number.",
    "code": "```go\npackage main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nfunc main() {\n\tscanner := bufio.NewScanner(os.Stdin)\n\tfor {\n\t\tfmt.Print(\"Enter a number: \")\n\t\tscanner.Scan()\n\t\tinput := scanner.Text()\n\t\tnumber, err := strconv.Atoi(input)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Please enter a valid number.\")\n\t\t\tcontinue\n\t\t}\n\t\tif number < 0 {\n\t\t\tbreak\n\t\t}\n\t}\n}\n```"
  },
  {
    "task": "Write a function that doubles a number and repeats the process until the number is greater than 1000.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc doubleUntilGreaterThanThousand(n int) int {\n\tfor n <= 1000 {\n\t\tn *= 2\n\t}\n\treturn n\n}\n\nfunc main() {\n\tresult := doubleUntilGreaterThanThousand(5)\n\tfmt.Println(result)\n}\n```"
  },
  {
    "task": "Develop a routine to keep printing 'Hello, World!' until a counter reaches 10.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tcounter := 0\n\tfor counter < 10 {\n\t\tfmt.Println(\"Hello, World!\")\n\t\tcounter++\n\t}\n}\n```"
  },
  {
    "task": "Construct a loop that checks if a randomly generated number is even, repeating until an odd number is found.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc main() {\n\trand.Seed(time.Now().UnixNano())\n\tnumber := rand.Int()\n\n\tfor number%2 == 0 {\n\t\tnumber = rand.Int()\n\t}\n\n\tfmt.Println(\"Found an odd number:\", number)\n}\n```"
  },
  {
    "task": "Design a countdown timer that prints each second until it reaches zero.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tcountdown := 10\n\tfor countdown > 0 {\n\t\tfmt.Println(countdown)\n\t\ttime.Sleep(1 * time.Second)\n\t\tcountdown--\n\t}\n\tfmt.Println(\"0\")\n}\n```"
  },
  {
    "task": "Implement a system where a user can keep adding items to a list until they type 'stop'.",
    "code": "```go\npackage main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n)\n\nfunc main() {\n\tvar items []string\n\tscanner := bufio.NewScanner(os.Stdin)\n\n\tfmt.Println(\"Enter items to add to the list or type 'stop' to finish:\")\n\tfor {\n\t\tfmt.Print(\"Enter item: \")\n\t\tscanner.Scan()\n\t\tinput := strings.TrimSpace(scanner.Text())\n\t\tif input == \"stop\" {\n\t\t\tbreak\n\t\t}\n\t\titems = append(items, input)\n\t}\n\n\tfmt.Println(\"Final list of items:\")\n\tfor _, item := range items {\n\t\tfmt.Println(item)\n\t}\n}\n```"
  },
  {
    "task": "Write a script that simulates rolling a die and continues until a six is rolled.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc main() {\n\trand.Seed(time.Now().UnixNano())\n\troll := 0\n\tfor roll != 6 {\n\t\troll = rand.Intn(6) + 1\n\t\tfmt.Println(\"Rolled:\", roll)\n\t}\n}\n```"
  },
  {
    "task": "Create a program that asks for a password and keeps prompting until the correct password is entered.",
    "code": "```go\npackage main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n)\n\nfunc main() {\n\tcorrectPassword := \"password123\"\n\treader := bufio.NewReader(os.Stdin)\n\n\tfor {\n\t\tfmt.Print(\"Enter password: \")\n\t\tinput, _ := reader.ReadString('\\n')\n\t\tinput = strings.TrimSpace(input)\n\n\t\tif input == correctPassword {\n\t\t\tfmt.Println(\"Access granted.\")\n\t\t\tbreak\n\t\t} else {\n\t\t\tfmt.Println(\"Incorrect password, try again.\")\n\t\t}\n\t}\n}\n```"
  },
  {
    "task": "Design a loop that calculates the sum of entered numbers until the user enters zero.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\tvar sum, num int\n\n\tfor {\n\t\tfmt.Print(\"Enter a number (0 to stop): \")\n\t\tfmt.Scan(&num)\n\n\t\tif num == 0 {\n\t\t\tbreak\n\t\t}\n\n\t\tsum += num\n\t}\n\n\tfmt.Printf(\"The sum of the entered numbers is: %d\\n\", sum)\n}\n```"
  },
  {
    "task": "Implement a feature that prints Fibonacci numbers until a number exceeds 100.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\ta, b := 0, 1\n\tfor a <= 100 {\n\t\tfmt.Println(a)\n\t\ta, b = b, a+b\n\t}\n}\n```"
  },
  {
    "task": "Develop a loop that keeps halving a number until it becomes less than one.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    number := 100.0\n    for number >= 1 {\n        number /= 2\n    }\n    fmt.Println(number)\n}\n```"
  },
  {
    "task": "Write a program that asks for names and keeps storing them until the user enters 'done'.",
    "code": "```go\npackage main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n)\n\nfunc main() {\n\tnames := []string{}\n\tscanner := bufio.NewScanner(os.Stdin)\n\n\tfor {\n\t\tfmt.Print(\"Enter a name (or 'done' to finish): \")\n\t\tscanner.Scan()\n\t\tname := strings.TrimSpace(scanner.Text())\n\n\t\tif strings.ToLower(name) == \"done\" {\n\t\t\tbreak\n\t\t}\n\n\t\tnames = append(names, name)\n\t}\n\n\tfmt.Println(\"Names entered:\", names)\n}\n```"
  },
  {
    "task": "Create a process that keeps flipping a coin, recording results until there have been five heads.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc main() {\n\trand.Seed(time.Now().UnixNano())\n\theadsCount := 0\n\n\tfor headsCount < 5 {\n\t\tflip := rand.Intn(2) // 0 for tails, 1 for heads\n\t\tif flip == 1 {\n\t\t\theadsCount++\n\t\t}\n\t\tfmt.Printf(\"Flip: %v, Total Heads: %d\\n\", flip, headsCount)\n\t}\n}\n```"
  },
  {
    "task": "Implement a countdown that decreases by two each time, starting from 20, until it reaches zero.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tcount := 20\n\tfor count >= 0 {\n\t\tfmt.Println(count)\n\t\tcount -= 2\n\t}\n}\n```"
  },
  {
    "task": "Design a solution that repeatedly asks for user input and repeats it back until they type 'exit'.",
    "code": "```go\npackage main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n)\n\nfunc main() {\n\tscanner := bufio.NewScanner(os.Stdin)\n\tfor {\n\t\tfmt.Print(\"Enter text: \")\n\t\tscanner.Scan()\n\t\tinput := scanner.Text()\n\t\tif strings.TrimSpace(input) == \"exit\" {\n\t\t\tbreak\n\t\t}\n\t\tfmt.Println(\"You entered:\", input)\n\t}\n}\n```"
  },
  {
    "task": "Develop a loop to simulate a bank account balance, repeatedly deducting a fee until the balance is below zero.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tbalance := 100.0\n\tfee := 10.0\n\n\tfor balance >= 0 {\n\t\tfmt.Printf(\"Current balance: $%.2f\\n\", balance)\n\t\tbalance -= fee\n\t}\n\tfmt.Println(\"Balance is below zero.\")\n}\n```"
  },
  {
    "task": "Create a sequence generator that multiplies a number by three each time until it reaches or exceeds 100.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tnum := 1\n\tfor num < 100 {\n\t\tfmt.Println(num)\n\t\tnum *= 3\n\t}\n}\n```"
  },
  {
    "task": "Write a program that keeps generating random numbers between 1 and 10 until it gets a five.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc main() {\n\trand.Seed(time.Now().UnixNano())\n\tnumber := 0\n\tfor number != 5 {\n\t\tnumber = rand.Intn(10) + 1\n\t\tfmt.Println(number)\n\t}\n}\n```"
  },
  {
    "task": "Implement a system to keep checking the temperature and only stop when it falls below freezing.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc getTemperature() float64 {\n\t// Simulate a temperature reading\n\treturn rand.Float64()*100 - 30 // Random temperature between -30 and 70\n}\n\nfunc main() {\n\trand.Seed(time.Now().UnixNano())\n\n\ttemperature := getTemperature()\n\n\tfor temperature >= 0 {\n\t\tfmt.Printf(\"Current temperature: %.2f\u00b0C\\n\", temperature)\n\t\ttime.Sleep(1 * time.Second)\n\t\ttemperature = getTemperature()\n\t}\n\n\tfmt.Println(\"Temperature has fallen below freezing.\")\n}\n```"
  },
  {
    "task": "Construct a quiz game that continues asking questions until the player answers incorrectly.",
    "code": "```go\npackage main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n)\n\nfunc main() {\n\tquestions := map[string]string{\n\t\t\"What is the capital of France?\": \"Paris\",\n\t\t\"What is 2 + 2?\":                 \"4\",\n\t\t\"Name the largest planet?\":       \"Jupiter\",\n\t}\n\n\tscanner := bufio.NewScanner(os.Stdin)\n\tfor question, answer := range questions {\n\t\tfmt.Println(question)\n\t\tscanner.Scan()\n\t\tresponse := strings.TrimSpace(scanner.Text())\n\t\tif strings.EqualFold(response, answer) == false {\n\t\t\tfmt.Println(\"Wrong answer! Game Over.\")\n\t\t\tbreak\n\t\t}\n\t\tfmt.Println(\"Correct!\")\n\t}\n}\n```"
  },
  {
    "task": "Write a function that calculates factorials of a number, repeating the process for numbers 1 through 5.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc factorial(n int) int {\n\tresult := 1\n\tfor n > 0 {\n\t\tresult *= n\n\t\tn--\n\t}\n\treturn result\n}\n\nfunc main() {\n\ti := 1\n\tfor i <= 5 {\n\t\tfmt.Printf(\"Factorial of %d is %d\\n\", i, factorial(i))\n\t\ti++\n\t}\n}\n```"
  },
  {
    "task": "Create a loop that prints all even numbers between 1 and 50.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\ti := 2\n\tfor i <= 50 {\n\t\tif i%2 == 0 {\n\t\t\tfmt.Println(i)\n\t\t}\n\t\ti++\n\t}\n}\n```"
  },
  {
    "task": "Design a program that continuously asks for user input until a palindrome is entered.",
    "code": "```go\npackage main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n)\n\nfunc isPalindrome(s string) bool {\n\tfor i := 0; i < len(s)/2; i++ {\n\t\tif s[i] != s[len(s)-1-i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc main() {\n\tscanner := bufio.NewScanner(os.Stdin)\n\tfor {\n\t\tfmt.Print(\"Enter a string: \")\n\t\tscanner.Scan()\n\t\tinput := strings.TrimSpace(scanner.Text())\n\t\tif isPalindrome(input) {\n\t\t\tfmt.Println(\"Palindrome entered!\")\n\t\t\tbreak\n\t\t}\n\t}\n}\n```"
  },
  {
    "task": "Implement a countdown that decreases by one each second, starting from 100.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tcount := 100\n\tfor count > 0 {\n\t\tfmt.Println(count)\n\t\ttime.Sleep(1 * time.Second)\n\t\tcount--\n\t}\n}\n```"
  },
  {
    "task": "Write a script that repeatedly asks for a number and adds it to a total until the total exceeds 500.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\tvar total, num int\n\n\tfor total <= 500 {\n\t\tfmt.Print(\"Enter a number: \")\n\t\tfmt.Scan(&num)\n\t\ttotal += num\n\t}\n\n\tfmt.Printf(\"Total exceeded 500: %d\\n\", total)\n}\n```"
  },
  {
    "task": "Create a loop that generates random letters until the letter 'Z' appears.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc main() {\n\trand.Seed(time.Now().UnixNano())\n\tvar letter rune\n\tfor letter != 'Z' {\n\t\tletter = rune('A' + rand.Intn(26))\n\t\tfmt.Println(string(letter))\n\t}\n}\n```"
  },
  {
    "task": "Write a process that continues prompting for two numbers and prints their sum if it's even.",
    "code": "```go\npackage main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nfunc main() {\n\treader := bufio.NewReader(os.Stdin)\n\tfor {\n\t\tfmt.Print(\"Enter two numbers separated by space: \")\n\t\tinput, _ := reader.ReadString('\\n')\n\t\tinput = strings.TrimSpace(input)\n\t\tparts := strings.Split(input, \" \")\n\t\tif len(parts) != 2 {\n\t\t\tfmt.Println(\"Please enter exactly two numbers.\")\n\t\t\tcontinue\n\t\t}\n\n\t\tnum1, err1 := strconv.Atoi(parts[0])\n\t\tnum2, err2 := strconv.Atoi(parts[1])\n\t\tif err1 != nil || err2 != nil {\n\t\t\tfmt.Println(\"Invalid numbers. Please try again.\")\n\t\t\tcontinue\n\t\t}\n\n\t\tsum := num1 + num2\n\t\tif sum%2 == 0 {\n\t\t\tfmt.Printf(\"The sum %d is even.\\n\", sum)\n\t\t} else {\n\t\t\tfmt.Println(\"The sum is not even.\")\n\t\t}\n\t}\n}\n```"
  },
  {
    "task": "Develop a loop that simulates a traffic light sequence until a manual stop command is received.",
    "code": "```go\npackage main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n)\n\nfunc main() {\n\treader := bufio.NewReader(os.Stdin)\n\tlightSequence := []string{\"Green\", \"Yellow\", \"Red\"}\n\ti := 0\n\tstop := false\n\n\tfor !stop {\n\t\tfmt.Printf(\"Current Light: %s\\n\", lightSequence[i%len(lightSequence)])\n\t\tfmt.Println(\"Enter 'stop' to end the sequence or press Enter to continue:\")\n\t\tinput, _ := reader.ReadString('\\n')\n\t\tinput = strings.TrimSpace(input)\n\n\t\tif strings.ToLower(input) == \"stop\" {\n\t\t\tstop = true\n\t\t} else {\n\t\t\ti++\n\t\t}\n\t}\n\n\tfmt.Println(\"Traffic light simulation stopped.\")\n}\n```"
  },
  {
    "task": "Implement a feature that keeps printing numbers in reverse order starting from 10.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\tnum := 10\n\tfor num > 0 {\n\t\tfmt.Println(num)\n\t\tnum--\n\t}\n}\n```"
  },
  {
    "task": "Create a program that rolls two dice and continues until the sum is exactly seven.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc main() {\n\trand.Seed(time.Now().UnixNano())\n\tsum := 0\n\n\tfor sum != 7 {\n\t\tdie1 := rand.Intn(6) + 1\n\t\tdie2 := rand.Intn(6) + 1\n\t\tsum = die1 + die2\n\t\tfmt.Printf(\"Rolled: %d + %d = %d\\n\", die1, die2, sum)\n\t}\n}\n```"
  },
  {
    "task": "Design a loop that keeps asking for ages and prints the average once a negative age is entered.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\tvar age, sum, count int\n\tfor {\n\t\tfmt.Print(\"Enter age: \")\n\t\tfmt.Scan(&age)\n\t\tif age < 0 {\n\t\t\tbreak\n\t\t}\n\t\tsum += age\n\t\tcount++\n\t}\n\tif count > 0 {\n\t\tfmt.Printf(\"Average age: %.2f\\n\", float64(sum)/float64(count))\n\t} else {\n\t\tfmt.Println(\"No valid ages were entered.\")\n\t}\n}\n```"
  },
  {
    "task": "Write a routine that squares numbers starting from 1 until the square is greater than 500.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\tnum := 1\n\tfor {\n\t\tsquare := num * num\n\t\tif square > 500 {\n\t\t\tbreak\n\t\t}\n\t\tfmt.Println(square)\n\t\tnum++\n\t}\n}\n```"
  },
  {
    "task": "Implement a system to ask for a string and append it to a file until 'end' is typed.",
    "code": "```go\npackage main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n)\n\nfunc main() {\n\tfile, err := os.OpenFile(\"output.txt\", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)\n\tif err != nil {\n\t\tfmt.Println(\"Error opening file:\", err)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\tscanner := bufio.NewScanner(os.Stdin)\n\tfor {\n\t\tfmt.Print(\"Enter a string (type 'end' to stop): \")\n\t\tscanner.Scan()\n\t\ttext := scanner.Text()\n\t\tif strings.ToLower(text) == \"end\" {\n\t\t\tbreak\n\t\t}\n\t\tif _, err := file.WriteString(text + \"\\n\"); err != nil {\n\t\t\tfmt.Println(\"Error writing to file:\", err)\n\t\t\tbreak\n\t\t}\n\t}\n}\n```"
  },
  {
    "task": "Create a script that checks if a number is prime, repeating for each number entered by the user.",
    "code": "```go\npackage main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nfunc isPrime(n int) bool {\n\tif n <= 1 {\n\t\treturn false\n\t}\n\tfor i := 2; i*i <= n; i++ {\n\t\tif n%i == 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc main() {\n\tscanner := bufio.NewScanner(os.Stdin)\n\tfor {\n\t\tfmt.Print(\"Enter a number (or type 'exit' to quit): \")\n\t\tscanner.Scan()\n\t\tinput := strings.TrimSpace(scanner.Text())\n\t\tif input == \"exit\" {\n\t\t\tbreak\n\t\t}\n\t\tnumber, err := strconv.Atoi(input)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Invalid number, please try again.\")\n\t\t\tcontinue\n\t\t}\n\t\tif isPrime(number) {\n\t\t\tfmt.Println(number, \"is a prime number.\")\n\t\t} else {\n\t\t\tfmt.Println(number, \"is not a prime number.\")\n\t\t}\n\t}\n}\n```"
  },
  {
    "task": "Develop a countdown that prints numbers starting from 50 down to 1.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    num := 50\n    for num >= 1 {\n        fmt.Println(num)\n        num--\n    }\n}\n```"
  },
  {
    "task": "Write a program that keeps doubling the value of a variable until it exceeds 200.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tvalue := 1\n\tfor value <= 200 {\n\t\tvalue *= 2\n\t}\n\tfmt.Println(value)\n}\n```"
  },
  {
    "task": "Design a loop that keeps generating a random string of letters until a specific word is formed.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"strings\"\n\t\"time\"\n)\n\nfunc main() {\n\ttargetWord := \"hello\"\n\tvar generatedWord string\n\tletters := []rune(\"abcdefghijklmnopqrstuvwxyz\")\n\n\trand.Seed(time.Now().UnixNano())\n\n\tfor generatedWord != targetWord {\n\t\tvar sb strings.Builder\n\t\tfor i := 0; i < len(targetWord); i++ {\n\t\t\tsb.WriteRune(letters[rand.Intn(len(letters))])\n\t\t}\n\t\tgeneratedWord = sb.String()\n\t\tfmt.Println(\"Generated:\", generatedWord)\n\t}\n\n\tfmt.Println(\"Target word formed:\", generatedWord)\n}\n```"
  },
  {
    "task": "Implement a system that continuously fetches data from a sensor until a threshold is crossed.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc fetchDataFromSensor() int {\n\t// Simulate fetching data from a sensor\n\treturn rand.Intn(100)\n}\n\nfunc main() {\n\tthreshold := 50\n\tfor {\n\t\tdata := fetchDataFromSensor()\n\t\tfmt.Println(\"Fetched data:\", data)\n\t\tif data > threshold {\n\t\t\tfmt.Println(\"Threshold crossed, stopping.\")\n\t\t\tbreak\n\t\t}\n\t\ttime.Sleep(1 * time.Second)\n\t}\n}\n```"
  },
  {
    "task": "Create a game where a player guesses a number, and the game continues until the player guesses correctly.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc main() {\n\trand.Seed(time.Now().UnixNano())\n\ttarget := rand.Intn(100) + 1\n\tvar guess int\n\n\tfmt.Println(\"Guess the number between 1 and 100\")\n\n\tfor guess != target {\n\t\tfmt.Print(\"Enter your guess: \")\n\t\tfmt.Scan(&guess)\n\n\t\tif guess < target {\n\t\t\tfmt.Println(\"Too low!\")\n\t\t} else if guess > target {\n\t\t\tfmt.Println(\"Too high!\")\n\t\t} else {\n\t\t\tfmt.Println(\"Congratulations! You guessed the correct number.\")\n\t\t}\n\t}\n}\n```"
  },
  {
    "task": "Write a loop that continues to add random numbers to a list until the list has 10 even numbers.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc main() {\n\trand.Seed(time.Now().UnixNano())\n\tevenNumbers := []int{}\n\n\tfor len(evenNumbers) < 10 {\n\t\tnum := rand.Int()\n\t\tif num%2 == 0 {\n\t\t\tevenNumbers = append(evenNumbers, num)\n\t\t}\n\t}\n\n\tfmt.Println(evenNumbers)\n}\n```"
  },
  {
    "task": "Design a routine that keeps removing elements from a list until it is empty.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tlist := []int{1, 2, 3, 4, 5}\n\n\tfor len(list) > 0 {\n\t\tlist = list[1:]\n\t}\n\n\tfmt.Println(\"List is empty:\", list)\n}\n```"
  },
  {
    "task": "Implement a sequence that prints the alphabet repeatedly until interrupted by the user.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n)\n\nfunc main() {\n\tsigs := make(chan os.Signal, 1)\n\tsignal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)\n\n\tgo func() {\n\t\t<-sigs\n\t\tfmt.Println(\"\\nInterrupted. Exiting...\")\n\t\tos.Exit(0)\n\t}()\n\n\talphabet := \"abcdefghijklmnopqrstuvwxyz\"\n\ti := 0\n\tfor {\n\t\tif i == len(alphabet) {\n\t\t\ti = 0\n\t\t}\n\t\tfmt.Printf(\"%c\", alphabet[i])\n\t\ti++\n\t}\n}\n```"
  },
  {
    "task": "Create a program that continuously checks for updates and stops once an update is available.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc checkForUpdates() bool {\n\t// Simulate random update availability\n\treturn rand.Intn(10) == 0\n}\n\nfunc main() {\n\trand.Seed(time.Now().UnixNano())\n\tupdateAvailable := false\n\n\tfor !updateAvailable {\n\t\tfmt.Println(\"Checking for updates...\")\n\t\ttime.Sleep(1 * time.Second) // Simulate time delay for checking updates\n\t\tupdateAvailable = checkForUpdates()\n\t}\n\n\tfmt.Println(\"Update available! Stopping the check.\")\n}\n```"
  },
  {
    "task": "Write a function that keeps dividing a number by two until it results in a fractional value.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc divideUntilFractional(n int) {\n\tfor n%2 == 0 {\n\t\tn /= 2\n\t}\n\tfmt.Println(n)\n}\n\nfunc main() {\n\tdivideUntilFractional(20)\n}\n```"
  },
  {
    "task": "Develop a loop that keeps asking for student's grades and calculates the average until a grade of -1 is entered.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\tvar sum, count float64\n\tvar grade float64\n\n\tfor {\n\t\tfmt.Print(\"Enter student's grade (-1 to stop): \")\n\t\tfmt.Scan(&grade)\n\n\t\tif grade == -1 {\n\t\t\tbreak\n\t\t}\n\n\t\tsum += grade\n\t\tcount++\n\t}\n\n\tif count > 0 {\n\t\taverage := sum / count\n\t\tfmt.Printf(\"The average grade is: %.2f\\n\", average)\n\t} else {\n\t\tfmt.Println(\"No grades were entered.\")\n\t}\n}\n```"
  },
  {
    "task": "Design a feature that continuously monitors a file for changes and stops when no changes are detected for a minute.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"time\"\n)\n\nfunc main() {\n\tfilePath := \"your_file.txt\"\n\tvar lastModTime time.Time\n\tnoChangeDuration := 0 * time.Second\n\tconst checkInterval = 10 * time.Second\n\tconst stopDuration = 60 * time.Second\n\n\tfor {\n\t\tfileInfo, err := os.Stat(filePath)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error:\", err)\n\t\t\tbreak\n\t\t}\n\t\tcurrentModTime := fileInfo.ModTime()\n\n\t\tif lastModTime.IsZero() {\n\t\t\tlastModTime = currentModTime\n\t\t}\n\n\t\tif currentModTime.After(lastModTime) {\n\t\t\tlastModTime = currentModTime\n\t\t\tnoChangeDuration = 0\n\t\t} else {\n\t\t\tnoChangeDuration += checkInterval\n\t\t}\n\n\t\tif noChangeDuration >= stopDuration {\n\t\t\tfmt.Println(\"No changes detected for a minute. Stopping.\")\n\t\t\tbreak\n\t\t}\n\n\t\ttime.Sleep(checkInterval)\n\t}\n}\n```"
  },
  {
    "task": "Implement a process where a motor runs until a certain distance is reached.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\tvar distanceCovered int\n\ttargetDistance := 100 // Example target distance\n\n\tfor distanceCovered < targetDistance {\n\t\t// Simulate motor running\n\t\tdistanceCovered += 10 // Example increment\n\t\tfmt.Printf(\"Motor running... Distance covered: %d\\n\", distanceCovered)\n\t}\n\tfmt.Println(\"Target distance reached. Motor stopped.\")\n}\n```"
  },
  {
    "task": "Create a script that keeps generating random numbers and stops when it generates a prime number.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc isPrime(n int) bool {\n\tif n <= 1 {\n\t\treturn false\n\t}\n\tfor i := 2; i*i <= n; i++ {\n\t\tif n%i == 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc main() {\n\trand.Seed(time.Now().UnixNano())\n\tfor {\n\t\tnum := rand.Int()\n\t\tfmt.Println(\"Generated:\", num)\n\t\tif isPrime(num) {\n\t\t\tfmt.Println(\"Prime found:\", num)\n\t\t\tbreak\n\t\t}\n\t}\n}\n```"
  },
  {
    "task": "Write a program that asks for the user's favorite color and keeps asking until they say 'blue'.",
    "code": "```go\npackage main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n)\n\nfunc main() {\n\treader := bufio.NewReader(os.Stdin)\n\tfor {\n\t\tfmt.Print(\"Enter your favorite color: \")\n\t\tcolor, _ := reader.ReadString('\\n')\n\t\tcolor = strings.TrimSpace(color)\n\t\tif color == \"blue\" {\n\t\t\tbreak\n\t\t}\n\t}\n}\n```"
  },
  {
    "task": "Develop a loop that continuously prints the time every second until a key is pressed.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n)\n\nfunc main() {\n\tstop := make(chan os.Signal, 1)\n\tsignal.Notify(stop, syscall.SIGINT, syscall.SIGTERM)\n\n\tfor {\n\t\tselect {\n\t\tcase <-stop:\n\t\t\treturn\n\t\tdefault:\n\t\t\tfmt.Println(time.Now().Format(\"15:04:05\"))\n\t\t\ttime.Sleep(1 * time.Second)\n\t\t}\n\t}\n}\n```"
  },
  {
    "task": "Create a system to keep downloading data from a server until the connection is lost.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc downloadData() bool {\n\t// Simulate a 10% chance of losing the connection\n\treturn rand.Intn(10) != 0\n}\n\nfunc main() {\n\trand.Seed(time.Now().UnixNano())\n\tconnectionActive := true\n\n\tfor connectionActive {\n\t\tfmt.Println(\"Downloading data...\")\n\t\tconnectionActive = downloadData()\n\t\tif !connectionActive {\n\t\t\tfmt.Println(\"Connection lost.\")\n\t\t}\n\t\ttime.Sleep(1 * time.Second) // Simulate time delay for downloading\n\t}\n}\n```"
  },
  {
    "task": "Write a process to keep a light on until the ambient light level is sufficient.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc getAmbientLightLevel() int {\n\t// Placeholder for actual sensor data retrieval\n\treturn 0\n}\n\nfunc main() {\n\tsufficientLightLevel := 100\n\tlightOn := true\n\n\tfor lightOn {\n\t\tambientLightLevel := getAmbientLightLevel()\n\t\tif ambientLightLevel >= sufficientLightLevel {\n\t\t\tlightOn = false\n\t\t}\n\t}\n\n\tfmt.Println(\"Light is off, ambient light level is sufficient.\")\n}\n```"
  },
  {
    "task": "Implement a feature that continuously plays a sound until the user presses a button.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n\t\"bufio\"\n)\n\nfunc playSound() {\n\tcmd := exec.Command(\"play\", \"soundfile.wav\")\n\tcmd.Run()\n}\n\nfunc main() {\n\tplaying := true\n\treader := bufio.NewReader(os.Stdin)\n\n\tfor playing {\n\t\tgo playSound()\n\n\t\tfmt.Println(\"Press 'q' and enter to stop.\")\n\t\tinput, _ := reader.ReadString('\\n')\n\t\tif input == \"q\\n\" {\n\t\t\tplaying = false\n\t\t}\n\t}\n}\n```"
  },
  {
    "task": "Design a program that keeps multiplying a matrix by itself until its determinant is greater than 1000.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc determinant(matrix [][]float64) float64 {\n\treturn matrix[0][0]*matrix[1][1] - matrix[0][1]*matrix[1][0]\n}\n\nfunc multiplyMatrices(a, b [][]float64) [][]float64 {\n\treturn [][]float64{\n\t\t{\n\t\t\ta[0][0]*b[0][0] + a[0][1]*b[1][0],\n\t\t\ta[0][0]*b[0][1] + a[0][1]*b[1][1],\n\t\t},\n\t\t{\n\t\t\ta[1][0]*b[0][0] + a[1][1]*b[1][0],\n\t\t\ta[1][0]*b[0][1] + a[1][1]*b[1][1],\n\t\t},\n\t}\n}\n\nfunc main() {\n\tmatrix := [][]float64{\n\t\t{2, 1},\n\t\t{1, 2},\n\t}\n\n\tfor {\n\t\tif determinant(matrix) > 1000 {\n\t\t\tbreak\n\t\t}\n\t\tmatrix = multiplyMatrices(matrix, matrix)\n\t}\n\n\tfmt.Println(\"Final matrix:\", matrix)\n\tfmt.Println(\"Determinant:\", determinant(matrix))\n}\n```"
  },
  {
    "task": "Create a script that keeps prompting the user to guess a word until they get it right.",
    "code": "```go\npackage main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n)\n\nfunc main() {\n\tscanner := bufio.NewScanner(os.Stdin)\n\ttargetWord := \"magicword\"\n\tvar guessedWord string\n\n\tfor guessedWord != targetWord {\n\t\tfmt.Print(\"Guess the word: \")\n\t\tscanner.Scan()\n\t\tguessedWord = strings.TrimSpace(scanner.Text())\n\t}\n\n\tfmt.Println(\"Congratulations! You guessed the word.\")\n}\n```"
  },
  {
    "task": "Write a loop that simulates a car's fuel consumption and stops when the tank is empty.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    fuel := 10.0 // initial fuel in liters\n    consumptionRate := 0.5 // fuel consumption per loop iteration\n\n    for fuel > 0 {\n        fmt.Printf(\"Fuel: %.2f liters\\n\", fuel)\n        fuel -= consumptionRate\n    }\n    fmt.Println(\"Tank is empty.\")\n}\n```"
  },
  {
    "task": "Develop a routine that keeps checking if a file exists and stops once it does.",
    "code": "```go\npackage main\n\nimport (\n\t\"os\"\n\t\"time\"\n)\n\nfunc main() {\n\tfor {\n\t\tif _, err := os.Stat(\"filename.txt\"); err == nil {\n\t\t\tbreak\n\t\t}\n\t\ttime.Sleep(1 * time.Second)\n\t}\n}\n```"
  },
  {
    "task": "Implement a feature that continuously calculates the square root of a number until it's less than 0.1.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc main() {\n\tnumber := 16.0\n\tfor number >= 0.1 {\n\t\tnumber = math.Sqrt(number)\n\t\tfmt.Println(number)\n\t}\n}\n```"
  },
  {
    "task": "Create a system that prints 'Processing...' every second until a task is complete.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\ttaskComplete := false\n\n\tfor !taskComplete {\n\t\tfmt.Println(\"Processing...\")\n\t\ttime.Sleep(1 * time.Second)\n\t\t// In a real scenario, there would be code here to check if the task is complete.\n\t\t// For demonstration, we'll just set taskComplete to true after some time.\n\t\ttaskComplete = true\n\t}\n}\n```"
  },
  {
    "task": "Write a loop that repeatedly checks the status of a process until it reports 'complete'.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc getStatus() string {\n\t// This function simulates checking the status of a process\n\t// For demonstration purposes, it returns \"complete\" after a few seconds\n\ttime.Sleep(2 * time.Second)\n\treturn \"complete\"\n}\n\nfunc main() {\n\tstatus := \"\"\n\tfor status != \"complete\" {\n\t\tstatus = getStatus()\n\t\tfmt.Println(\"Current status:\", status)\n\t}\n\tfmt.Println(\"Process is complete.\")\n}\n```"
  },
  {
    "task": "Design a routine to keep pinging a server and alert when the connection is lost.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"time\"\n)\n\nfunc pingServer(server string) {\n\tfor {\n\t\tconn, err := net.DialTimeout(\"tcp\", server, 2*time.Second)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Alert: Connection lost!\")\n\t\t\ttime.Sleep(5 * time.Second)\n\t\t\tcontinue\n\t\t}\n\t\tconn.Close()\n\t\ttime.Sleep(5 * time.Second)\n\t}\n}\n\nfunc main() {\n\tpingServer(\"example.com:80\")\n}\n```"
  },
  {
    "task": "Implement a loop that counts down from 100 by fives until it reaches zero.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    i := 100\n    for i >= 0 {\n        fmt.Println(i)\n        i -= 5\n    }\n}\n```"
  },
  {
    "task": "Create a script that keeps track of inventory items being added or removed until an end signal is given.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc main() {\n\tinventory := make(map[string]int)\n\tvar input string\n\tfor {\n\t\tfmt.Println(\"Enter command (add <item>, remove <item>, or end):\")\n\t\tfmt.Scanln(&input)\n\t\tcommand := strings.Fields(input)\n\t\tif len(command) < 1 {\n\t\t\tcontinue\n\t\t}\n\t\tswitch command[0] {\n\t\tcase \"add\":\n\t\t\tif len(command) < 2 {\n\t\t\t\tfmt.Println(\"Specify an item to add.\")\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\titem := command[1]\n\t\t\tinventory[item]++\n\t\t\tfmt.Printf(\"Added %s. Current inventory: %v\\n\", item, inventory)\n\t\tcase \"remove\":\n\t\t\tif len(command) < 2 {\n\t\t\t\tfmt.Println(\"Specify an item to remove.\")\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\titem := command[1]\n\t\t\tif inventory[item] > 0 {\n\t\t\t\tinventory[item]--\n\t\t\t\tfmt.Printf(\"Removed %s. Current inventory: %v\\n\", item, inventory)\n\t\t\t} else {\n\t\t\t\tfmt.Printf(\"Item %s not in inventory.\\n\", item)\n\t\t\t}\n\t\tcase \"end\":\n\t\t\tfmt.Println(\"Ending inventory tracking.\")\n\t\t\treturn\n\t\tdefault:\n\t\t\tfmt.Println(\"Unknown command.\")\n\t\t}\n\t}\n}\n```"
  },
  {
    "task": "Write a program that keeps calculating the power of two for numbers until a result is greater than 1000.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\tnumber := 1\n\tpower := 0\n\n\tfor {\n\t\tresult := 1 << power\n\t\tif result > 1000 {\n\t\t\tbreak\n\t\t}\n\t\tfmt.Printf(\"2^%d = %d\\n\", power, result)\n\t\tpower++\n\t}\n}\n```"
  },
  {
    "task": "Develop a sequence that keeps appending random numbers to an array until its length is 20.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc main() {\n\trand.Seed(time.Now().UnixNano())\n\tvar numbers []int\n\n\tfor len(numbers) < 20 {\n\t\tnumbers = append(numbers, rand.Int())\n\t}\n\n\tfmt.Println(numbers)\n}\n```"
  },
  {
    "task": "Implement a routine that continuously rotates an image until it matches a reference orientation.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Dummy function to represent image rotation\nfunc rotateImage(image [][]int) [][]int {\n\t// Logic to rotate the image goes here\n\treturn image // Replace with actual image rotation logic\n}\n\n// Dummy function to check if the image matches the reference orientation\nfunc matchesReference(image, reference [][]int) bool {\n\t// Logic to compare image with reference goes here\n\treturn false // Replace with actual comparison logic\n}\n\nfunc main() {\n\t// Dummy image and reference\n\timage := [][]int{{0}, {1}, {2}}\n\treference := [][]int{{0}, {1}, {2}}\n\n\t// Continuously rotate the image until it matches the reference orientation\n\tfor !matchesReference(image, reference) {\n\t\timage = rotateImage(image)\n\t}\n\n\tfmt.Println(\"Image matches the reference orientation.\")\n}\n```"
  },
  {
    "task": "Design a loop that keeps printing random jokes until the user stops it.",
    "code": "```go\npackage main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"math/rand\"\n\t\"os\"\n\t\"strings\"\n\t\"time\"\n)\n\nfunc main() {\n\tjokes := []string{\n\t\t\"Why don't scientists trust atoms? Because they make up everything!\",\n\t\t\"I'm reading a book on anti-gravity. It's impossible to put down!\",\n\t\t\"Why did the scarecrow win an award? Because he was outstanding in his field!\",\n\t}\n\n\trand.Seed(time.Now().UnixNano())\n\treader := bufio.NewReader(os.Stdin)\n\t\n\tfor {\n\t\tfmt.Println(jokes[rand.Intn(len(jokes))])\n\t\tfmt.Print(\"Do you want to hear another joke? (yes/no): \")\n\t\ttext, _ := reader.ReadString('\\n')\n\t\ttext = strings.TrimSpace(text)\n\t\tif strings.ToLower(text) != \"yes\" {\n\t\t\tbreak\n\t\t}\n\t}\n}\n```"
  },
  {
    "task": "Create a program that accepts user feedback and continues until a positive feedback is received.",
    "code": "```go\npackage main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n)\n\nfunc main() {\n\treader := bufio.NewReader(os.Stdin)\n\tfor {\n\t\tfmt.Print(\"Please enter your feedback: \")\n\t\tfeedback, _ := reader.ReadString('\\n')\n\t\tfeedback = strings.TrimSpace(feedback)\n\t\tif strings.Contains(strings.ToLower(feedback), \"good\") || strings.Contains(strings.ToLower(feedback), \"excellent\") {\n\t\t\tfmt.Println(\"Thank you for your positive feedback!\")\n\t\t\tbreak\n\t\t}\n\t\tfmt.Println(\"Waiting for positive feedback...\")\n\t}\n}\n```"
  },
  {
    "task": "Write a loop that repeatedly reads sensor data and stops when a stable reading is observed.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc readSensor() int {\n\treturn rand.Intn(100) // Simulate reading sensor data\n}\n\nfunc isStable(reading int) bool {\n\treturn reading == 50 // Define a condition for a stable reading\n}\n\nfunc main() {\n\trand.Seed(time.Now().UnixNano())\n\tvar sensorReading int\n\t\n\tfor {\n\t\tsensorReading = readSensor()\n\t\tfmt.Println(\"Sensor reading:\", sensorReading)\n\t\tif isStable(sensorReading) {\n\t\t\tbreak\n\t\t}\n\t\ttime.Sleep(1 * time.Second) // Simulate waiting time between readings\n\t}\n\t\n\tfmt.Println(\"Stable reading observed:\", sensorReading)\n}\n```"
  },
  {
    "task": "Develop a system that simulates a stopwatch, counting seconds until stopped manually.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tvar input string\n\tseconds := 0\n\n\tfmt.Println(\"Press Enter to stop the stopwatch.\")\n\n\tgo func() {\n\t\tfor {\n\t\t\tif _, err := fmt.Scanln(&input); err == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}()\n\n\tfor {\n\t\tselect {\n\t\tcase <-time.After(1 * time.Second):\n\t\t\tseconds++\n\t\t\tfmt.Printf(\"\\rSeconds: %d\", seconds)\n\t\tdefault:\n\t\t\tif input != \"\" {\n\t\t\t\tfmt.Println(\"\\nStopwatch stopped.\")\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}\n```"
  },
  {
    "task": "Create a script that continues adding random integers to a sum until the sum exceeds 100.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc main() {\n\trand.Seed(time.Now().UnixNano())\n\tsum := 0\n\tfor sum <= 100 {\n\t\tsum += rand.Intn(10) + 1\n\t}\n\tfmt.Println(\"Final Sum:\", sum)\n}\n```"
  },
  {
    "task": "Implement a process to track a moving object until it stops.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\tposition := 0\n\tspeed := 5 // Assume the speed is constantly 5 units per iteration\n\n\tfor speed != 0 {\n\t\tposition += speed\n\t\t// Simulate the stopping condition\n\t\tif position >= 50 {\n\t\t\tspeed = 0\n\t\t}\n\t\tfmt.Println(\"Current Position:\", position)\n\t}\n\n\tfmt.Println(\"Object has stopped.\")\n}\n```"
  },
  {
    "task": "Design a routine to keep checking user login attempts until a successful login occurs.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\tcorrectUsername := \"user\"\n\tcorrectPassword := \"pass\"\n\tvar username, password string\n\tsuccess := false\n\n\tfor !success {\n\t\tfmt.Print(\"Enter username: \")\n\t\tfmt.Scanln(&username)\n\t\tfmt.Print(\"Enter password: \")\n\t\tfmt.Scanln(&password)\n\n\t\tif username == correctUsername && password == correctPassword {\n\t\t\tsuccess = true\n\t\t\tfmt.Println(\"Login successful.\")\n\t\t} else {\n\t\t\tfmt.Println(\"Invalid credentials, please try again.\")\n\t\t}\n\t}\n}\n```"
  },
  {
    "task": "Write a loop that repeatedly calculates the area of a circle for radii from 1 to 10.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc main() {\n\tradius := 1\n\tfor radius <= 10 {\n\t\tarea := math.Pi * math.Pow(float64(radius), 2)\n\t\tfmt.Printf(\"Radius: %d, Area: %.2f\\n\", radius, area)\n\t\tradius++\n\t}\n}\n```"
  },
  {
    "task": "Create a program that continues flipping a card from a deck until an ace is drawn.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc drawCard() string {\n\tcards := []string{\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"Jack\", \"Queen\", \"King\", \"Ace\"}\n\treturn cards[rand.Intn(len(cards))]\n}\n\nfunc main() {\n\trand.Seed(time.Now().UnixNano())\n\n\tcard := \"\"\n\tfor card != \"Ace\" {\n\t\tcard = drawCard()\n\t\tfmt.Println(\"Drew:\", card)\n\t}\n\tfmt.Println(\"An Ace was drawn!\")\n}\n```"
  },
  {
    "task": "Develop a loop that keeps asking for a word and stores it until a word with more than five letters is entered.",
    "code": "```go\npackage main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc main() {\n\tvar words []string\n\tscanner := bufio.NewScanner(os.Stdin)\n\n\tfor {\n\t\tfmt.Print(\"Enter a word: \")\n\t\tscanner.Scan()\n\t\tword := scanner.Text()\n\t\twords = append(words, word)\n\t\tif len(word) > 5 {\n\t\t\tbreak\n\t\t}\n\t}\n}\n```"
  },
  {
    "task": "Implement a feature that continuously calculates the exponential growth of a population until it doubles.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\tinitialPopulation := 1000.0\n\tpopulation := initialPopulation\n\tgrowthRate := 0.05 // 5% growth rate\n\ttargetPopulation := initialPopulation * 2\n\n\tfor population < targetPopulation {\n\t\tpopulation += population * growthRate\n\t}\n\n\tfmt.Printf(\"Doubled Population: %.2f\\n\", population)\n}\n```"
  },
  {
    "task": "Write a script that repeats a string a certain number of times until a limit is reached.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\tstr := \"Hello\"\n\trepeatCount := 0\n\tlimit := 5\n\tvar result string\n\n\tfor repeatCount < limit {\n\t\tresult += str\n\t\trepeatCount++\n\t}\n\n\tfmt.Println(result)\n}\n```"
  },
  {
    "task": "Create a routine that keeps accessing an API endpoint until it returns a specific result.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"strings\"\n)\n\nfunc main() {\n\turl := \"https://example.com/api/endpoint\"\n\ttargetResult := \"desiredResult\"\n\tvar result string\n\n\tfor {\n\t\tresp, err := http.Get(url)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error accessing the API:\", err)\n\t\t\tbreak\n\t\t}\n\n\t\tbody, err := ioutil.ReadAll(resp.Body)\n\t\tresp.Body.Close()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error reading the response:\", err)\n\t\t\tbreak\n\t\t}\n\n\t\tresult = string(body)\n\t\tif strings.Contains(result, targetResult) {\n\t\t\tfmt.Println(\"Target result found:\", result)\n\t\t\tbreak\n\t\t}\n\n\t\tfmt.Println(\"Target result not yet found, retrying...\")\n\t}\n}\n```"
  },
  {
    "task": "Design a loop that continues to fetch stock prices until a certain price threshold is crossed.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc fetchStockPrice() float64 {\n\t// Simulate fetching a stock price\n\treturn rand.Float64() * 100\n}\n\nfunc main() {\n\trand.Seed(time.Now().UnixNano())\n\tpriceThreshold := 50.0\n\tvar currentPrice float64\n\n\tfor {\n\t\tcurrentPrice = fetchStockPrice()\n\t\tfmt.Printf(\"Current stock price: $%.2f\\n\", currentPrice)\n\t\tif currentPrice > priceThreshold {\n\t\t\tfmt.Println(\"Price threshold crossed.\")\n\t\t\tbreak\n\t\t}\n\t}\n}\n```"
  },
  {
    "task": "Implement a process that keeps monitoring CPU usage until it drops below 10%.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc getCPUUsage() float64 {\n\t// Simulate CPU usage for demonstration purposes\n\treturn rand.Float64() * 100\n}\n\nfunc main() {\n\trand.Seed(time.Now().UnixNano())\n\n\tvar cpuUsage float64\n\tfor {\n\t\tcpuUsage = getCPUUsage()\n\t\tfmt.Printf(\"Current CPU Usage: %.2f%%\\n\", cpuUsage)\n\t\tif cpuUsage < 10 {\n\t\t\tbreak\n\t\t}\n\t\ttime.Sleep(1 * time.Second)\n\t}\n\n\tfmt.Println(\"CPU usage dropped below 10%.\")\n}\n```"
  },
  {
    "task": "Write a program that asks for a series of numbers and prints the largest once a negative number is entered.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\tvar number, largest int\n\tfmt.Println(\"Enter numbers (negative number to stop):\")\n\tfor {\n\t\tfmt.Scan(&number)\n\t\tif number < 0 {\n\t\t\tbreak\n\t\t}\n\t\tif number > largest {\n\t\t\tlargest = number\n\t\t}\n\t}\n\tfmt.Printf(\"The largest number entered is: %d\\n\", largest)\n}\n```"
  },
  {
    "task": "Develop a system that keeps a heater on until the room reaches a desired temperature.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\tcurrentTemperature := 18.0\n\tdesiredTemperature := 22.0\n\n\tfor currentTemperature < desiredTemperature {\n\t\tfmt.Println(\"Heater is on. Current temperature:\", currentTemperature)\n\t\tcurrentTemperature += 0.5 // Simulate heating process\n\t}\n\n\tfmt.Println(\"Desired temperature reached. Heater is off.\")\n}\n```"
  },
  {
    "task": "Create a loop that repeatedly checks if a door is open and alerts if it remains open for too long.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc isDoorOpen() bool {\n\t// Placeholder function to simulate door status check\n\treturn true // Assume door is open for demonstration purposes\n}\n\nfunc main() {\n\tdoorOpenDuration := 0\n\tconst alertThreshold = 5 // Alert if door is open for 5 seconds\n\n\tfor {\n\t\tif isDoorOpen() {\n\t\t\tdoorOpenDuration++\n\t\t\tif doorOpenDuration > alertThreshold {\n\t\t\t\tfmt.Println(\"Alert: The door has been open for too long!\")\n\t\t\t}\n\t\t} else {\n\t\t\tdoorOpenDuration = 0 // Reset if the door is closed\n\t\t}\n\t\ttime.Sleep(1 * time.Second) // Check every second\n\t}\n}\n```"
  },
  {
    "task": "Implement a feature that keeps adding random characters to a string until its length is 8.",
    "code": "```go\npackage main\n\nimport (\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc main() {\n\trand.Seed(time.Now().UnixNano())\n\ttargetLength := 8\n\tvar str string\n\n\tfor len(str) < targetLength {\n\t\trandomChar := rune(rand.Intn(26) + 'a')\n\t\tstr += string(randomChar)\n\t}\n\n\tprintln(str)\n}\n```"
  },
  {
    "task": "Design a routine that simulates a race and continues until a participant crosses the finish line.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc main() {\n\trand.Seed(time.Now().UnixNano())\n\tconst finishLine = 100\n\tvar position int\n\n\tfor position < finishLine {\n\t\tmove := rand.Intn(10) + 1\n\t\tposition += move\n\t\tfmt.Printf(\"Participant moved to position %d\\n\", position)\n\t\ttime.Sleep(500 * time.Millisecond)\n\t}\n\n\tfmt.Println(\"Participant has crossed the finish line!\")\n}\n```"
  },
  {
    "task": "Write a script that keeps checking an email inbox until a specific email is received.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\ntype Email struct {\n\tSubject string\n}\n\nfunc checkInbox() []Email {\n\t// Simulate checking the inbox and returning emails\n\treturn []Email{\n\t\t{\"Welcome\"},\n\t\t{\"Important Update\"},\n\t\t{\"Specific Email\"},\n\t}\n}\n\nfunc emailReceived(emails []Email, keyword string) bool {\n\tfor _, email := range emails {\n\t\tif email.Subject == keyword {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc main() {\n\tkeyword := \"Specific Email\"\n\tfor {\n\t\temails := checkInbox()\n\t\tif emailReceived(emails, keyword) {\n\t\t\tfmt.Println(\"Specific email received!\")\n\t\t\tbreak\n\t\t}\n\t\tfmt.Println(\"Checking inbox...\")\n\t\ttime.Sleep(5 * time.Second)\n\t}\n}\n```"
  },
  {
    "task": "Create a loop that continues to play a video on repeat until the user interrupts.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc playVideo() {\n\tfmt.Println(\"Playing video...\")\n\t// Simulate video playing with a sleep or dummy action\n}\n\nfunc main() {\n\tvar interrupt string\n\tfor {\n\t\tplayVideo()\n\t\tfmt.Println(\"Press 'q' to quit or any other key to replay.\")\n\t\tfmt.Scanln(&interrupt)\n\t\tif interrupt == \"q\" {\n\t\t\tbreak\n\t\t}\n\t}\n\tfmt.Println(\"Video stopped.\")\n}\n```"
  },
  {
    "task": "Develop a process that keeps scanning for Bluetooth devices until a specific device is found.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc scanForBluetoothDevice() string {\n\t// Dummy function to simulate Bluetooth device scanning\n\t// Replace with actual scanning logic\n\tdevices := []string{\"DeviceA\", \"DeviceB\", \"TargetDevice\", \"DeviceC\"}\n\treturn devices[time.Now().Second()%len(devices)]\n}\n\nfunc main() {\n\ttargetDevice := \"TargetDevice\"\n\tfound := false\n\n\tfor !found {\n\t\tdevice := scanForBluetoothDevice()\n\t\tfmt.Println(\"Scanning... Found:\", device)\n\t\tif device == targetDevice {\n\t\t\tfound = true\n\t\t\tfmt.Println(\"Target device found!\")\n\t\t}\n\t\ttime.Sleep(1 * time.Second) // Simulate delay between scans\n\t}\n}\n```"
  },
  {
    "task": "Implement a script that continuously captures images from a webcam until a motion is detected.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"gocv.io/x/gocv\"\n)\n\nfunc main() {\n\twebcam, err := gocv.OpenVideoCapture(0)\n\tif err != nil {\n\t\tfmt.Println(\"Error opening webcam:\", err)\n\t\treturn\n\t}\n\tdefer webcam.Close()\n\n\twindow := gocv.NewWindow(\"Webcam\")\n\tdefer window.Close()\n\n\timg := gocv.NewMat()\n\tdefer img.Close()\n\n\tpreviousImg := gocv.NewMat()\n\tdefer previousImg.Close()\n\n\tfor {\n\t\tif ok := webcam.Read(&img); !ok || img.Empty() {\n\t\t\tfmt.Println(\"Error reading image from webcam.\")\n\t\t\tbreak\n\t\t}\n\n\t\tif previousImg.Empty() {\n\t\t\timg.CopyTo(&previousImg)\n\t\t\tcontinue\n\t\t}\n\n\t\tdiff := gocv.NewMat()\n\t\tgocv.AbsDiff(previousImg, img, &diff)\n\t\tgocv.Threshold(diff, &diff, 25, 255, gocv.ThresholdBinary)\n\n\t\twhitePixels := gocv.CountNonZero(diff)\n\t\tif whitePixels > 1000 {\n\t\t\tbreak\n\t\t}\n\n\t\timg.CopyTo(&previousImg)\n\t\twindow.IMShow(img)\n\t\tif window.WaitKey(1) >= 0 {\n\t\t\tbreak\n\t\t}\n\t}\n}\n```"
  },
  {
    "task": "Design a program that keeps playing a sound file until the user presses a mute button.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n\t\"time\"\n)\n\nfunc playSound() {\n\tcmd := exec.Command(\"play\", \"soundfile.wav\")\n\tcmd.Run()\n}\n\nfunc main() {\n\tmute := false\n\n\tgo func() {\n\t\tfor {\n\t\t\tif _, err := os.Stdin.Read(make([]byte, 1)); err == nil {\n\t\t\t\tmute = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}()\n\n\tfor !mute {\n\t\tplaySound()\n\t\ttime.Sleep(time.Second) // prevent tight loop if playSound is non-blocking\n\t}\n\n\tfmt.Println(\"Sound muted.\")\n}\n```"
  },
  {
    "task": "Create a loop that repeatedly generates a random password until it meets certain security criteria.",
    "code": "```go\npackage main\n\nimport (\n\t\"crypto/rand\"\n\t\"fmt\"\n\t\"math/big\"\n\t\"unicode\"\n)\n\nfunc generateRandomPassword(length int) string {\n\tchars := \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()-_=+[]{}|;:,.<>?/~\"\n\tpassword := make([]byte, length)\n\tfor i := range password {\n\t\tnum, _ := rand.Int(rand.Reader, big.NewInt(int64(len(chars))))\n\t\tpassword[i] = chars[num.Int64()]\n\t}\n\treturn string(password)\n}\n\nfunc isPasswordSecure(password string) bool {\n\tvar hasUpper, hasLower, hasDigit, hasSpecial bool\n\tfor _, char := range password {\n\t\tswitch {\n\t\tcase unicode.IsUpper(char):\n\t\t\thasUpper = true\n\t\tcase unicode.IsLower(char):\n\t\t\thasLower = true\n\t\tcase unicode.IsDigit(char):\n\t\t\thasDigit = true\n\t\tcase unicode.IsPunct(char) || unicode.IsSymbol(char):\n\t\t\thasSpecial = true\n\t\t}\n\t}\n\treturn hasUpper && hasLower && hasDigit && hasSpecial && len(password) >= 8\n}\n\nfunc main() {\n\tvar password string\n\tfor {\n\t\tpassword = generateRandomPassword(12)\n\t\tif isPasswordSecure(password) {\n\t\t\tbreak\n\t\t}\n\t}\n\tfmt.Println(\"Generated secure password:\", password)\n}\n```"
  },
  {
    "task": "Write a process that keeps checking for file changes in a directory and logs them until stopped.",
    "code": "```go\npackage main\n\nimport (\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"time\"\n)\n\nfunc main() {\n\tdir := \"./watched_directory\"\n\tpreviousState := make(map[string]os.FileInfo)\n\t\n\tfor {\n\t\tcurrentState := make(map[string]os.FileInfo)\n\t\terr := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcurrentState[path] = info\n\t\t\treturn nil\n\t\t})\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\t\n\t\tfor path, info := range currentState {\n\t\t\tif prevInfo, exists := previousState[path]; !exists || prevInfo.ModTime() != info.ModTime() {\n\t\t\t\tlog.Printf(\"Change detected: %s\", path)\n\t\t\t}\n\t\t}\n\t\t\n\t\tpreviousState = currentState\n\t\ttime.Sleep(1 * time.Second)\n\t}\n}\n```"
  }
]