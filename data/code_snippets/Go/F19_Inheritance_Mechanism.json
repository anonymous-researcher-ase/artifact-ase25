[
  {
    "task": "Create a base class for a vehicle with methods for speed and fuel efficiency, then derive a car class that overrides these methods to provide specific implementations.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Vehicle base class\ntype Vehicle interface {\n\tSpeed() string\n\tFuelEfficiency() string\n}\n\n// Car derived class\ntype Car struct{}\n\nfunc (c Car) Speed() string {\n\treturn \"Car speed: 120 km/h\"\n}\n\nfunc (c Car) FuelEfficiency() string {\n\treturn \"Car fuel efficiency: 15 km/l\"\n}\n\nfunc main() {\n\tvar v Vehicle\n\tv = Car{}\n\tfmt.Println(v.Speed())\n\tfmt.Println(v.FuelEfficiency())\n}\n```"
  },
  {
    "task": "Design a base class for a multimedia file with properties like duration and format, then extend it with a video class that includes resolution and frame rate.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Base class for a multimedia file\ntype MultimediaFile struct {\n\tDuration int\n\tFormat   string\n}\n\n// Extended class for a video file\ntype VideoFile struct {\n\tMultimediaFile\n\tResolution string\n\tFrameRate  float64\n}\n\nfunc main() {\n\tvideo := VideoFile{\n\t\tMultimediaFile: MultimediaFile{\n\t\t\tDuration: 120,\n\t\t\tFormat:   \"mp4\",\n\t\t},\n\t\tResolution: \"1920x1080\",\n\t\tFrameRate:  30.0,\n\t}\n\n\tfmt.Printf(\"Video Details:\\nDuration: %d mins\\nFormat: %s\\nResolution: %s\\nFrame Rate: %.2f fps\\n\",\n\t\tvideo.Duration, video.Format, video.Resolution, video.FrameRate)\n}\n```"
  },
  {
    "task": "Develop a superclass for bank accounts with methods for deposit and withdrawal, then create a savings account subclass that overrides the withdrawal method to incorporate interest deductions.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Superclass for bank accounts\ntype BankAccount struct {\n\tbalance float64\n}\n\nfunc (b *BankAccount) Deposit(amount float64) {\n\tb.balance += amount\n}\n\nfunc (b *BankAccount) Withdraw(amount float64) {\n\tif amount <= b.balance {\n\t\tb.balance -= amount\n\t} else {\n\t\tfmt.Println(\"Insufficient funds\")\n\t}\n}\n\n// Subclass for savings account\ntype SavingsAccount struct {\n\tBankAccount\n\tinterestRate float64\n}\n\nfunc (s *SavingsAccount) Withdraw(amount float64) {\n\tinterest := amount * s.interestRate\n\ttotalWithdrawal := amount + interest\n\tif totalWithdrawal <= s.balance {\n\t\ts.balance -= totalWithdrawal\n\t} else {\n\t\tfmt.Println(\"Insufficient funds with interest\")\n\t}\n}\n\nfunc main() {\n\t// Example usage\n\tsavings := SavingsAccount{BankAccount{balance: 1000}, 0.05}\n\tsavings.Deposit(500)\n\tfmt.Println(\"Balance after deposit:\", savings.balance)\n\tsavings.Withdraw(200)\n\tfmt.Println(\"Balance after withdrawal:\", savings.balance)\n}\n```"
  },
  {
    "task": "Implement a base class for a geometric shape with methods to calculate area and perimeter, then create a rectangle subclass that provides specific calculations for these methods.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\n// Shape is a base interface for geometric shapes\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\n// Rectangle is a subclass of Shape\ntype Rectangle struct {\n\tWidth, Height float64\n}\n\n// Area calculates the area of the rectangle\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\n// Perimeter calculates the perimeter of the rectangle\nfunc (r Rectangle) Perimeter() float64 {\n\treturn 2 * (r.Width + r.Height)\n}\n\nfunc main() {\n\trect := Rectangle{Width: 3, Height: 4}\n\tfmt.Println(\"Area:\", rect.Area())\n\tfmt.Println(\"Perimeter:\", rect.Perimeter())\n}\n```"
  },
  {
    "task": "Construct a parent class for employees with a method to calculate salary, then derive a manager class that overrides this method to include bonuses.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Employee is the parent class\ntype Employee struct {\n\tBaseSalary float64\n}\n\n// CalculateSalary calculates the salary for an employee\nfunc (e *Employee) CalculateSalary() float64 {\n\treturn e.BaseSalary\n}\n\n// Manager is a derived class from Employee\ntype Manager struct {\n\tEmployee\n\tBonus float64\n}\n\n// CalculateSalary calculates the salary for a manager including bonuses\nfunc (m *Manager) CalculateSalary() float64 {\n\treturn m.BaseSalary + m.Bonus\n}\n\nfunc main() {\n\temp := Employee{BaseSalary: 50000}\n\tfmt.Printf(\"Employee Salary: %.2f\\n\", emp.CalculateSalary())\n\n\tmgr := Manager{Employee: Employee{BaseSalary: 70000}, Bonus: 15000}\n\tfmt.Printf(\"Manager Salary: %.2f\\n\", mgr.CalculateSalary())\n}\n```"
  },
  {
    "task": "Set up a base class for a library item with properties like title and author, and extend it with a book subclass that adds a number of pages property.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Base class\ntype LibraryItem struct {\n\tTitle  string\n\tAuthor string\n}\n\n// Subclass\ntype Book struct {\n\tLibraryItem\n\tPages int\n}\n\nfunc main() {\n\tbook := Book{\n\t\tLibraryItem: LibraryItem{\n\t\t\tTitle:  \"The Go Programming Language\",\n\t\t\tAuthor: \"Alan A. A. Donovan\",\n\t\t},\n\t\tPages: 380,\n\t}\n\n\tfmt.Printf(\"Title: %s, Author: %s, Pages: %d\\n\", book.Title, book.Author, book.Pages)\n}\n```"
  },
  {
    "task": "Create a foundation class for an electronic device with a method to turn on and off, and derive a smartphone class that overrides the turn on method to require a passcode.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Base class for an electronic device\ntype ElectronicDevice struct {\n\tisOn bool\n}\n\nfunc (d *ElectronicDevice) TurnOn() {\n\td.isOn = true\n\tfmt.Println(\"Device is turned on.\")\n}\n\nfunc (d *ElectronicDevice) TurnOff() {\n\td.isOn = false\n\tfmt.Println(\"Device is turned off.\")\n}\n\n// Derived class for a smartphone\ntype Smartphone struct {\n\tElectronicDevice\n}\n\nfunc (s *Smartphone) TurnOn(passcode string) {\n\tif passcode == \"1234\" {\n\t\ts.isOn = true\n\t\tfmt.Println(\"Smartphone is turned on.\")\n\t} else {\n\t\tfmt.Println(\"Incorrect passcode. Smartphone remains off.\")\n\t}\n}\n\nfunc main() {\n\tdevice := ElectronicDevice{}\n\tdevice.TurnOn()\n\tdevice.TurnOff()\n\n\tphone := Smartphone{}\n\tphone.TurnOn(\"0000\")\n\tphone.TurnOn(\"1234\")\n}\n```"
  },
  {
    "task": "Design a base class for an animal with a method to make a sound, then create a dog subclass that overrides this method to bark.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Base class\ntype Animal struct{}\n\nfunc (a Animal) MakeSound() {\n\tfmt.Println(\"Animal sound\")\n}\n\n// Subclass\ntype Dog struct {\n\tAnimal\n}\n\nfunc (d Dog) MakeSound() {\n\tfmt.Println(\"Bark\")\n}\n\nfunc main() {\n\tanimal := Animal{}\n\tanimal.MakeSound()\n\n\tdog := Dog{}\n\tdog.MakeSound()\n}\n```"
  },
  {
    "task": "Develop a superclass for meals with a method to calculate calories, then create a dessert subclass that overrides it to add extra sugar calories.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Superclass for meals\ntype Meal struct {\n\tcalories int\n}\n\n// Method to calculate calories\nfunc (m Meal) CalculateCalories() int {\n\treturn m.calories\n}\n\n// Subclass for desserts\ntype Dessert struct {\n\tMeal\n\tsugarCalories int\n}\n\n// Override method to add extra sugar calories\nfunc (d Dessert) CalculateCalories() int {\n\treturn d.calories + d.sugarCalories\n}\n\nfunc main() {\n\tdessert := Dessert{\n\t\tMeal:          Meal{calories: 200},\n\t\tsugarCalories: 100,\n\t}\n\n\tfmt.Println(\"Total calories in dessert:\", dessert.CalculateCalories())\n}\n```"
  },
  {
    "task": "Implement a base class for a transportation mode with a method to calculate travel time, then extend it with a plane subclass that overrides the method to calculate based on speed.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Base class for transportation mode\ntype TransportationMode struct {\n\tDistance float64\n\tSpeed    float64\n}\n\n// Method to calculate travel time\nfunc (t TransportationMode) CalculateTravelTime() float64 {\n\tif t.Speed == 0 {\n\t\treturn 0\n\t}\n\treturn t.Distance / t.Speed\n}\n\n// Plane subclass extending TransportationMode\ntype Plane struct {\n\tTransportationMode\n}\n\n// Override method to calculate travel time based on speed\nfunc (p Plane) CalculateTravelTime() float64 {\n\tif p.Speed == 0 {\n\t\treturn 0\n\t}\n\treturn p.Distance / p.Speed\n}\n\nfunc main() {\n\tt := TransportationMode{Distance: 500, Speed: 100}\n\tfmt.Printf(\"Travel time by generic transportation: %.2f hours\\n\", t.CalculateTravelTime())\n\n\tp := Plane{TransportationMode{Distance: 500, Speed: 600}}\n\tfmt.Printf(\"Travel time by plane: %.2f hours\\n\", p.CalculateTravelTime())\n}\n```"
  },
  {
    "task": "Construct a parent class for a musical instrument with a method to play sound, then derive a piano class that overrides the method to play specific notes.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Parent class\ntype MusicalInstrument struct{}\n\nfunc (m *MusicalInstrument) PlaySound() {\n\tfmt.Println(\"Playing a generic sound\")\n}\n\n// Derived class\ntype Piano struct {\n\tMusicalInstrument\n}\n\nfunc (p *Piano) PlaySound() {\n\tfmt.Println(\"Playing piano notes: C, E, G\")\n}\n\nfunc main() {\n\tinstrument := MusicalInstrument{}\n\tinstrument.PlaySound()\n\n\tpiano := Piano{}\n\tpiano.PlaySound()\n}\n```"
  },
  {
    "task": "Set up a base class for a user account with a method to reset password, and extend it with an admin account subclass that overrides it to include security questions.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Base class for a user account\ntype UserAccount struct {\n\tusername string\n\tpassword string\n}\n\n// Method to reset password\nfunc (u *UserAccount) ResetPassword(newPassword string) {\n\tu.password = newPassword\n\tfmt.Println(\"Password reset to:\", u.password)\n}\n\n// Admin account subclass\ntype AdminAccount struct {\n\tUserAccount\n\tsecurityQuestions map[string]string\n}\n\n// Override method to reset password with security questions\nfunc (a *AdminAccount) ResetPassword(newPassword string, securityAnswers map[string]string) {\n\t// Validate security questions\n\tfor question, correctAnswer := range a.securityQuestions {\n\t\tif answer, ok := securityAnswers[question]; !ok || answer != correctAnswer {\n\t\t\tfmt.Println(\"Security answer incorrect for:\", question)\n\t\t\treturn\n\t\t}\n\t}\n\ta.password = newPassword\n\tfmt.Println(\"Admin password reset to:\", a.password)\n}\n\nfunc main() {\n\tuser := UserAccount{username: \"user1\", password: \"userpass\"}\n\tuser.ResetPassword(\"newuserpass\")\n\n\tadmin := AdminAccount{\n\t\tUserAccount: UserAccount{username: \"admin1\", password: \"adminpass\"},\n\t\tsecurityQuestions: map[string]string{\n\t\t\t\"Your first pet's name?\": \"Fluffy\",\n\t\t\t\"Favorite color?\":        \"Blue\",\n\t\t},\n\t}\n\n\tadmin.ResetPassword(\"newadminpass\", map[string]string{\n\t\t\"Your first pet's name?\": \"Fluffy\",\n\t\t\"Favorite color?\":        \"Blue\",\n\t})\n}\n```"
  },
  {
    "task": "Create a foundational class for a beverage with properties like volume and temperature, and derive a coffee class that overrides the temperature property to be hot.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Beverage is the foundational struct with volume and temperature properties\ntype Beverage struct {\n\tVolume     int\n\tTemperature string\n}\n\n// Coffee is derived from Beverage and overrides the Temperature property\ntype Coffee struct {\n\tBeverage\n}\n\n// NewCoffee initializes a Coffee instance with a default hot temperature\nfunc NewCoffee(volume int) *Coffee {\n\treturn &Coffee{\n\t\tBeverage: Beverage{\n\t\t\tVolume:     volume,\n\t\t\tTemperature: \"hot\",\n\t\t},\n\t}\n}\n\nfunc main() {\n\tcoffee := NewCoffee(250)\n\tfmt.Printf(\"Coffee volume: %dml, temperature: %s\\n\", coffee.Volume, coffee.Temperature)\n}\n```"
  },
  {
    "task": "Design a base class for a service appointment with a method to schedule time, then create a doctor appointment subclass that overrides this method to include consultation duration.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\ntype ServiceAppointment struct {\n\tDateTime time.Time\n}\n\nfunc (sa *ServiceAppointment) ScheduleTime(t time.Time) {\n\tsa.DateTime = t\n\tfmt.Println(\"Service appointment scheduled at:\", sa.DateTime)\n}\n\ntype DoctorAppointment struct {\n\tServiceAppointment\n\tConsultationDuration time.Duration\n}\n\nfunc (da *DoctorAppointment) ScheduleTime(t time.Time, duration time.Duration) {\n\tda.DateTime = t\n\tda.ConsultationDuration = duration\n\tfmt.Printf(\"Doctor appointment scheduled at: %v for a duration of: %v\\n\", da.DateTime, da.ConsultationDuration)\n}\n\nfunc main() {\n\tbaseAppointment := &ServiceAppointment{}\n\tbaseAppointment.ScheduleTime(time.Now())\n\n\tdoctorAppointment := &DoctorAppointment{}\n\tdoctorAppointment.ScheduleTime(time.Now(), 30*time.Minute)\n}\n```"
  },
  {
    "task": "Develop a superclass for electronic gadgets with a method to calculate battery life, then extend it with a laptop class that overrides this method to consider usage patterns.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Superclass for electronic gadgets\ntype ElectronicGadget struct {\n\tbatteryCapacity int // in mAh\n}\n\n// Method to calculate battery life\nfunc (e *ElectronicGadget) CalculateBatteryLife(hoursUsed int) int {\n\treturn e.batteryCapacity / hoursUsed\n}\n\n// Laptop class extending ElectronicGadget\ntype Laptop struct {\n\tElectronicGadget\n}\n\n// Overridden method to consider usage patterns\nfunc (l *Laptop) CalculateBatteryLife(hoursUsed int, usagePattern string) int {\n\tvar efficiencyFactor int\n\tswitch usagePattern {\n\tcase \"heavy\":\n\t\tefficiencyFactor = 2\n\tcase \"moderate\":\n\t\tefficiencyFactor = 1\n\tdefault:\n\t\tefficiencyFactor = 0\n\t}\n\treturn (l.batteryCapacity / (hoursUsed * (1 + efficiencyFactor)))\n}\n\nfunc main() {\n\tgadget := ElectronicGadget{batteryCapacity: 5000}\n\tlaptop := Laptop{ElectronicGadget{batteryCapacity: 5000}}\n\n\tfmt.Println(\"Gadget battery life:\", gadget.CalculateBatteryLife(5)) // Example usage\n\tfmt.Println(\"Laptop battery life with heavy usage:\", laptop.CalculateBatteryLife(5, \"heavy\"))\n\tfmt.Println(\"Laptop battery life with moderate usage:\", laptop.CalculateBatteryLife(5, \"moderate\"))\n}\n```"
  },
  {
    "task": "Implement a base class for a website component with a method to render content, then create a blog post subclass that overrides this method to include author information.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\ntype WebsiteComponent interface {\n\tRenderContent() string\n}\n\ntype BaseComponent struct{}\n\nfunc (b BaseComponent) RenderContent() string {\n\treturn \"Base Component Content\"\n}\n\ntype BlogPost struct {\n\tBaseComponent\n\tAuthor string\n}\n\nfunc (b BlogPost) RenderContent() string {\n\treturn fmt.Sprintf(\"Blog Post Content by %s\", b.Author)\n}\n\nfunc main() {\n\tvar component WebsiteComponent = BlogPost{Author: \"John Doe\"}\n\tfmt.Println(component.RenderContent())\n}\n```"
  },
  {
    "task": "Construct a parent class for a recipe with methods for ingredients and instructions, then derive a cake recipe class that overrides these methods to add baking steps.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\ntype Recipe interface {\n\tIngredients() []string\n\tInstructions() []string\n}\n\ntype BaseRecipe struct{}\n\nfunc (r BaseRecipe) Ingredients() []string {\n\treturn []string{\"Generic Ingredient 1\", \"Generic Ingredient 2\"}\n}\n\nfunc (r BaseRecipe) Instructions() []string {\n\treturn []string{\"Generic Instruction 1\", \"Generic Instruction 2\"}\n}\n\ntype CakeRecipe struct {\n\tBaseRecipe\n}\n\nfunc (c CakeRecipe) Ingredients() []string {\n\treturn []string{\"Flour\", \"Sugar\", \"Eggs\", \"Butter\"}\n}\n\nfunc (c CakeRecipe) Instructions() []string {\n\treturn []string{\"Mix ingredients\", \"Pour into pan\", \"Bake at 350 F for 30 minutes\"}\n}\n\nfunc main() {\n\tvar recipe Recipe\n\n\trecipe = CakeRecipe{}\n\tfmt.Println(\"Cake Recipe Ingredients:\", recipe.Ingredients())\n\tfmt.Println(\"Cake Recipe Instructions:\", recipe.Instructions())\n}\n```"
  },
  {
    "task": "Set up a base class for a plant with methods for sunlight and water needs, and extend it with a cactus subclass that overrides these methods to require less water.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Plant is the base struct for plants.\ntype Plant struct{}\n\n// SunlightNeeds returns the sunlight needs for a plant.\nfunc (p Plant) SunlightNeeds() string {\n\treturn \"Regular sunlight required\"\n}\n\n// WaterNeeds returns the water needs for a plant.\nfunc (p Plant) WaterNeeds() string {\n\treturn \"Regular water required\"\n}\n\n// Cactus is a subclass of Plant with specific needs.\ntype Cactus struct {\n\tPlant\n}\n\n// WaterNeeds returns the water needs for a cactus.\nfunc (c Cactus) WaterNeeds() string {\n\treturn \"Less water required\"\n}\n\nfunc main() {\n\tplant := Plant{}\n\tcactus := Cactus{}\n\n\tfmt.Println(\"Plant Sunlight:\", plant.SunlightNeeds())\n\tfmt.Println(\"Plant Water:\", plant.WaterNeeds())\n\n\tfmt.Println(\"Cactus Sunlight:\", cactus.SunlightNeeds())\n\tfmt.Println(\"Cactus Water:\", cactus.WaterNeeds())\n}\n```"
  },
  {
    "task": "Create a foundational class for a building with properties like height and material, and derive a skyscraper class that overrides the height property to be significantly taller.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\ntype Building struct {\n\tHeight   int\n\tMaterial string\n}\n\ntype Skyscraper struct {\n\tBuilding\n}\n\nfunc NewSkyscraper(material string) *Skyscraper {\n\treturn &Skyscraper{\n\t\tBuilding: Building{\n\t\t\tHeight:   300, // Define a significantly taller height for skyscrapers\n\t\t\tMaterial: material,\n\t\t},\n\t}\n}\n\nfunc main() {\n\tb := Building{Height: 50, Material: \"Concrete\"}\n\tfmt.Printf(\"Building: Height = %d, Material = %s\\n\", b.Height, b.Material)\n\n\ts := NewSkyscraper(\"Steel\")\n\tfmt.Printf(\"Skyscraper: Height = %d, Material = %s\\n\", s.Height, s.Material)\n}\n```"
  },
  {
    "task": "Design a base class for a payment method with a method to process transactions, then create a credit card subclass that overrides this method to include credit limits.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// PaymentMethod is the base class\ntype PaymentMethod interface {\n\tProcessTransaction(amount float64) string\n}\n\n// CreditCard is a subclass that includes credit limits\ntype CreditCard struct {\n\tcreditLimit float64\n\tbalance     float64\n}\n\n// NewCreditCard is a constructor for CreditCard\nfunc NewCreditCard(creditLimit float64) *CreditCard {\n\treturn &CreditCard{creditLimit: creditLimit, balance: 0}\n}\n\n// ProcessTransaction overrides the base method to include credit limits\nfunc (cc *CreditCard) ProcessTransaction(amount float64) string {\n\tif cc.balance+amount > cc.creditLimit {\n\t\treturn \"Transaction declined: exceeds credit limit\"\n\t}\n\tcc.balance += amount\n\treturn \"Transaction approved\"\n}\n\nfunc main() {\n\tvar paymentMethod PaymentMethod\n\tpaymentMethod = NewCreditCard(1000)\n\n\tfmt.Println(paymentMethod.ProcessTransaction(500))\n\tfmt.Println(paymentMethod.ProcessTransaction(600))\n}\n```"
  },
  {
    "task": "Develop a superclass for a computer program with methods for input and output, then extend it with a game subclass that overrides these methods to include player interactions.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Superclass\ntype Program struct {}\n\nfunc (p *Program) Input() {\n\tfmt.Println(\"Program Input\")\n}\n\nfunc (p *Program) Output() {\n\tfmt.Println(\"Program Output\")\n}\n\n// Subclass\ntype Game struct {\n\tProgram\n}\n\nfunc (g *Game) Input() {\n\tfmt.Println(\"Game Player Input\")\n}\n\nfunc (g *Game) Output() {\n\tfmt.Println(\"Game Player Output\")\n}\n\nfunc main() {\n\tprogram := &Program{}\n\tprogram.Input()\n\tprogram.Output()\n\n\tgame := &Game{}\n\tgame.Input()\n\tgame.Output()\n}\n```"
  },
  {
    "task": "Implement a base class for a dining establishment with a method to calculate wait time, then create a fast food subclass that overrides this method to be shorter.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Base class for a dining establishment\ntype DiningEstablishment struct {\n\tname string\n}\n\n// Method to calculate wait time\nfunc (d *DiningEstablishment) CalculateWaitTime() int {\n\treturn 30 // default wait time in minutes\n}\n\n// Fast food subclass\ntype FastFood struct {\n\tDiningEstablishment\n}\n\n// Overridden method to calculate wait time for fast food\nfunc (f *FastFood) CalculateWaitTime() int {\n\treturn 10 // shorter wait time in minutes\n}\n\nfunc main() {\n\trestaurant := DiningEstablishment{name: \"Generic Restaurant\"}\n\tfastFood := FastFood{DiningEstablishment{name: \"Fast Food Place\"}}\n\n\tfmt.Printf(\"%s wait time: %d minutes\\n\", restaurant.name, restaurant.CalculateWaitTime())\n\tfmt.Printf(\"%s wait time: %d minutes\\n\", fastFood.name, fastFood.CalculateWaitTime())\n}\n```"
  },
  {
    "task": "Construct a parent class for a social media profile with methods for posting and liking, then derive a business profile class that overrides these methods to include promotions.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Parent class\ntype SocialMediaProfile struct {\n\tname string\n}\n\nfunc (s *SocialMediaProfile) Post(content string) {\n\tfmt.Printf(\"%s posts: %s\\n\", s.name, content)\n}\n\nfunc (s *SocialMediaProfile) Like(postID int) {\n\tfmt.Printf(\"%s likes post with ID: %d\\n\", s.name, postID)\n}\n\n// Derived class\ntype BusinessProfile struct {\n\tSocialMediaProfile\n}\n\nfunc (b *BusinessProfile) Post(content string) {\n\tfmt.Printf(\"%s posts a promotion: %s\\n\", b.name, content)\n}\n\nfunc (b *BusinessProfile) Like(postID int) {\n\tfmt.Printf(\"%s likes and promotes post with ID: %d\\n\", b.name, postID)\n}\n\nfunc main() {\n\tuserProfile := SocialMediaProfile{name: \"User123\"}\n\tbusinessProfile := BusinessProfile{SocialMediaProfile{name: \"BusinessXYZ\"}}\n\n\tuserProfile.Post(\"Hello, world!\")\n\tuserProfile.Like(101)\n\n\tbusinessProfile.Post(\"Mega Sale!\")\n\tbusinessProfile.Like(202)\n}\n```"
  },
  {
    "task": "Set up a base class for an educational course with methods for syllabus and grading, and extend it with an online course subclass that overrides these methods for remote learning.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Base class\ntype Course struct{}\n\nfunc (c *Course) Syllabus() {\n\tfmt.Println(\"General course syllabus.\")\n}\n\nfunc (c *Course) Grading() {\n\tfmt.Println(\"General course grading.\")\n}\n\n// Subclass\ntype OnlineCourse struct {\n\tCourse\n}\n\nfunc (oc *OnlineCourse) Syllabus() {\n\tfmt.Println(\"Online course syllabus with video lectures.\")\n}\n\nfunc (oc *OnlineCourse) Grading() {\n\tfmt.Println(\"Online course grading with remote submission.\")\n}\n\nfunc main() {\n\tgeneralCourse := &Course{}\n\tonlineCourse := &OnlineCourse{}\n\n\tgeneralCourse.Syllabus()\n\tgeneralCourse.Grading()\n\n\tonlineCourse.Syllabus()\n\tonlineCourse.Grading()\n}\n```"
  },
  {
    "task": "Create a foundational class for a sports team with properties like team name and coach, and derive a football team class that overrides the coach property with a specific person.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Team is the foundational struct for a sports team\ntype Team struct {\n\tTeamName string\n\tCoach    string\n}\n\n// FootballTeam is the derived struct from Team, specifically for football teams\ntype FootballTeam struct {\n\tTeam\n}\n\n// NewFootballTeam creates a new FootballTeam with a specific coach\nfunc NewFootballTeam(teamName string, coach string) FootballTeam {\n\treturn FootballTeam{\n\t\tTeam: Team{\n\t\t\tTeamName: teamName,\n\t\t\tCoach:    coach,\n\t\t},\n\t}\n}\n\nfunc main() {\n\tfootballTeam := NewFootballTeam(\"Lions\", \"John Doe\")\n\tfmt.Printf(\"Team: %s, Coach: %s\\n\", footballTeam.TeamName, footballTeam.Coach)\n}\n```"
  },
  {
    "task": "Design a base class for a document with methods for printing and saving, then create a PDF document subclass that overrides these methods to include encryption.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\ntype Document interface {\n\tPrint()\n\tSave()\n}\n\ntype BaseDocument struct{}\n\nfunc (d BaseDocument) Print() {\n\tfmt.Println(\"Printing document...\")\n}\n\nfunc (d BaseDocument) Save() {\n\tfmt.Println(\"Saving document...\")\n}\n\ntype PDFDocument struct {\n\tBaseDocument\n}\n\nfunc (p PDFDocument) Print() {\n\tfmt.Println(\"Printing PDF document with encryption...\")\n}\n\nfunc (p PDFDocument) Save() {\n\tfmt.Println(\"Saving PDF document with encryption...\")\n}\n\nfunc main() {\n\tvar doc Document\n\n\tdoc = BaseDocument{}\n\tdoc.Print()\n\tdoc.Save()\n\n\tdoc = PDFDocument{}\n\tdoc.Print()\n\tdoc.Save()\n}\n```"
  },
  {
    "task": "Develop a superclass for a retail product with methods for pricing and discount, then extend it with an electronics product class that overrides the discount method to offer more.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Superclass\ntype Product struct {\n\tName  string\n\tPrice float64\n}\n\nfunc (p Product) GetPrice() float64 {\n\treturn p.Price\n}\n\nfunc (p Product) GetDiscountedPrice(discount float64) float64 {\n\treturn p.Price * (1 - discount)\n}\n\n// Subclass\ntype Electronics struct {\n\tProduct\n}\n\nfunc (e Electronics) GetDiscountedPrice(discount float64) float64 {\n\t// Offer more discount for electronics\n\treturn e.Price * (1 - discount*1.5)\n}\n\nfunc main() {\n\tproduct := Product{Name: \"Generic Product\", Price: 100.0}\n\telectronic := Electronics{Product{Name: \"Smartphone\", Price: 200.0}}\n\n\tfmt.Printf(\"%s price: $%.2f\\n\", product.Name, product.GetPrice())\n\tfmt.Printf(\"%s discounted price: $%.2f\\n\", product.Name, product.GetDiscountedPrice(0.1))\n\n\tfmt.Printf(\"%s price: $%.2f\\n\", electronic.Name, electronic.GetPrice())\n\tfmt.Printf(\"%s discounted price: $%.2f\\n\", electronic.Name, electronic.GetDiscountedPrice(0.1))\n}\n```"
  },
  {
    "task": "Implement a base class for a subscription service with a method to renew membership, then create a monthly subscription subclass that overrides this method for automatic renewal.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Base class for subscription service\ntype SubscriptionService struct {\n\tmemberName string\n}\n\nfunc (s *SubscriptionService) RenewMembership() {\n\tfmt.Println(\"Renewing membership for\", s.memberName)\n}\n\n// Subclass for monthly subscription\ntype MonthlySubscription struct {\n\tSubscriptionService\n}\n\nfunc (m *MonthlySubscription) RenewMembership() {\n\tfmt.Println(\"Automatically renewing monthly membership for\", m.memberName)\n}\n\nfunc main() {\n\tbaseSubscription := &SubscriptionService{memberName: \"John Doe\"}\n\tbaseSubscription.RenewMembership()\n\n\tmonthlySubscription := &MonthlySubscription{SubscriptionService: SubscriptionService{memberName: \"Jane Doe\"}}\n\tmonthlySubscription.RenewMembership()\n}\n```"
  },
  {
    "task": "Construct a parent class for a language translator with a method to translate text, then derive a French translator class that overrides this method for French language specifics.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\ntype Translator interface {\n\tTranslate(text string) string\n}\n\ntype BaseTranslator struct{}\n\nfunc (bt *BaseTranslator) Translate(text string) string {\n\treturn \"Translating: \" + text\n}\n\ntype FrenchTranslator struct {\n\tBaseTranslator\n}\n\nfunc (ft *FrenchTranslator) Translate(text string) string {\n\treturn \"Traduction en fran\u00e7ais: \" + text\n}\n\nfunc main() {\n\tvar translator Translator\n\n\ttranslator = &BaseTranslator{}\n\tfmt.Println(translator.Translate(\"Hello, World!\"))\n\n\ttranslator = &FrenchTranslator{}\n\tfmt.Println(translator.Translate(\"Hello, World!\"))\n}\n```"
  },
  {
    "task": "Set up a base class for a customer order with methods for placing and tracking, and extend it with a food order subclass that overrides tracking for delivery status.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Base class for a customer order\ntype CustomerOrder struct {\n\torderID string\n}\n\nfunc (c *CustomerOrder) PlaceOrder() {\n\tfmt.Println(\"Order placed with ID:\", c.orderID)\n}\n\nfunc (c *CustomerOrder) TrackOrder() {\n\tfmt.Println(\"Tracking order with ID:\", c.orderID)\n}\n\n// Subclass for a food order\ntype FoodOrder struct {\n\tCustomerOrder\n}\n\nfunc (f *FoodOrder) TrackOrder() {\n\tfmt.Println(\"Tracking food order with ID:\", f.orderID, \"for delivery status\")\n}\n\nfunc main() {\n\t// Example usage\n\tbaseOrder := CustomerOrder{orderID: \"12345\"}\n\tbaseOrder.PlaceOrder()\n\tbaseOrder.TrackOrder()\n\n\tfoodOrder := FoodOrder{CustomerOrder{orderID: \"67890\"}}\n\tfoodOrder.PlaceOrder()\n\tfoodOrder.TrackOrder()\n}\n```"
  },
  {
    "task": "Create a foundational class for an artwork with properties like artist and medium, and derive a painting class that overrides the medium property to be 'canvas'.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Artwork is the foundational struct for an artwork\ntype Artwork struct {\n\tArtist string\n\tMedium string\n}\n\n// Painting is a derived struct from Artwork\ntype Painting struct {\n\tArtwork\n}\n\n// NewPainting initializes a new painting with medium set to 'canvas'\nfunc NewPainting(artist string) Painting {\n\treturn Painting{\n\t\tArtwork: Artwork{\n\t\t\tArtist: artist,\n\t\t\tMedium: \"canvas\",\n\t\t},\n\t}\n}\n\nfunc main() {\n\tpainting := NewPainting(\"Vincent van Gogh\")\n\tfmt.Printf(\"Artist: %s, Medium: %s\\n\", painting.Artist, painting.Medium)\n}\n```"
  },
  {
    "task": "Design a base class for a computer network with methods for connectivity and bandwidth, then create a wireless network subclass that overrides these methods for signal strength.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Base class\ntype Network struct{}\n\nfunc (n *Network) Connectivity() string {\n\treturn \"Standard connectivity\"\n}\n\nfunc (n *Network) Bandwidth() string {\n\treturn \"Standard bandwidth\"\n}\n\n// Subclass\ntype WirelessNetwork struct {\n\tNetwork\n}\n\nfunc (wn *WirelessNetwork) Connectivity() string {\n\treturn \"Wireless connectivity\"\n}\n\nfunc (wn *WirelessNetwork) Bandwidth() string {\n\treturn \"Bandwidth depends on signal strength\"\n}\n\nfunc main() {\n\tnetwork := &Network{}\n\tfmt.Println(\"Base Network Connectivity:\", network.Connectivity())\n\tfmt.Println(\"Base Network Bandwidth:\", network.Bandwidth())\n\n\twirelessNetwork := &WirelessNetwork{}\n\tfmt.Println(\"Wireless Network Connectivity:\", wirelessNetwork.Connectivity())\n\tfmt.Println(\"Wireless Network Bandwidth:\", wirelessNetwork.Bandwidth())\n}\n```"
  },
  {
    "task": "Develop a superclass for a messaging app with methods for sending and receiving messages, then extend it with a secure messaging subclass that overrides these methods for encryption.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\ntype Messenger interface {\n\tSendMessage(msg string)\n\tReceiveMessage() string\n}\n\ntype MessagingApp struct {\n\tmessage string\n}\n\nfunc (m *MessagingApp) SendMessage(msg string) {\n\tm.message = msg\n\tfmt.Println(\"Sending message:\", msg)\n}\n\nfunc (m *MessagingApp) ReceiveMessage() string {\n\tfmt.Println(\"Receiving message:\", m.message)\n\treturn m.message\n}\n\ntype SecureMessagingApp struct {\n\tMessagingApp\n}\n\nfunc (s *SecureMessagingApp) SendMessage(msg string) {\n\tencryptedMsg := encrypt(msg)\n\ts.message = encryptedMsg\n\tfmt.Println(\"Sending encrypted message:\", encryptedMsg)\n}\n\nfunc (s *SecureMessagingApp) ReceiveMessage() string {\n\tdecryptedMsg := decrypt(s.message)\n\tfmt.Println(\"Receiving decrypted message:\", decryptedMsg)\n\treturn decryptedMsg\n}\n\nfunc encrypt(msg string) string {\n\t// Simple encryption logic (for demonstration)\n\treturn \"encrypted(\" + msg + \")\"\n}\n\nfunc decrypt(msg string) string {\n\t// Simple decryption logic (for demonstration)\n\treturn msg[len(\"encrypted(\") : len(msg)-1]\n}\n\nfunc main() {\n\tm := &MessagingApp{}\n\tm.SendMessage(\"Hello World\")\n\tm.ReceiveMessage()\n\n\ts := &SecureMessagingApp{}\n\ts.SendMessage(\"Hello Secure World\")\n\ts.ReceiveMessage()\n}\n```"
  },
  {
    "task": "Implement a base class for a travel itinerary with methods for destinations and activities, then create a vacation itinerary subclass that overrides these methods for leisure activities.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Base class\ntype Itinerary struct{}\n\nfunc (i *Itinerary) Destinations() []string {\n\treturn []string{\"Destination 1\", \"Destination 2\"}\n}\n\nfunc (i *Itinerary) Activities() []string {\n\treturn []string{\"Activity 1\", \"Activity 2\"}\n}\n\n// Subclass\ntype VacationItinerary struct {\n\tItinerary\n}\n\nfunc (v *VacationItinerary) Activities() []string {\n\treturn []string{\"Leisure Activity 1\", \"Leisure Activity 2\"}\n}\n\nfunc main() {\n\tbaseItinerary := &Itinerary{}\n\tfmt.Println(\"Base Itinerary Destinations:\", baseItinerary.Destinations())\n\tfmt.Println(\"Base Itinerary Activities:\", baseItinerary.Activities())\n\n\tvacationItinerary := &VacationItinerary{}\n\tfmt.Println(\"Vacation Itinerary Destinations:\", vacationItinerary.Destinations())\n\tfmt.Println(\"Vacation Itinerary Activities:\", vacationItinerary.Activities())\n}\n```"
  },
  {
    "task": "Construct a parent class for a healthcare record with methods for patient data and treatment history, then derive a pediatric record class that overrides these methods for child-specific data.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Parent class for a healthcare record\ntype HealthcareRecord struct {\n\tPatientName     string\n\tTreatmentHistory []string\n}\n\n// Method for patient data\nfunc (hr *HealthcareRecord) PatientData() string {\n\treturn fmt.Sprintf(\"Patient Name: %s\", hr.PatientName)\n}\n\n// Method for treatment history\nfunc (hr *HealthcareRecord) TreatmentHistoryData() string {\n\treturn fmt.Sprintf(\"Treatment History: %v\", hr.TreatmentHistory)\n}\n\n// Derived class for pediatric record\ntype PediatricRecord struct {\n\tHealthcareRecord\n\tGuardianName string\n}\n\n// Overriding method for patient data\nfunc (pr *PediatricRecord) PatientData() string {\n\treturn fmt.Sprintf(\"Patient Name: %s, Guardian Name: %s\", pr.PatientName, pr.GuardianName)\n}\n\n// Overriding method for treatment history\nfunc (pr *PediatricRecord) TreatmentHistoryData() string {\n\treturn fmt.Sprintf(\"Pediatric Treatment History: %v\", pr.TreatmentHistory)\n}\n\nfunc main() {\n\tpedRec := PediatricRecord{\n\t\tHealthcareRecord: HealthcareRecord{\n\t\t\tPatientName:     \"John Doe\",\n\t\t\tTreatmentHistory: []string{\"Vaccine A\", \"Checkup B\"},\n\t\t},\n\t\tGuardianName: \"Jane Doe\",\n\t}\n\n\tfmt.Println(pedRec.PatientData())\n\tfmt.Println(pedRec.TreatmentHistoryData())\n}\n```"
  },
  {
    "task": "Set up a base class for a culinary dish with methods for preparation and serving, and extend it with an appetizer subclass that overrides these methods for smaller portions.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Base class for a culinary dish\ntype CulinaryDish struct{}\n\nfunc (d *CulinaryDish) Prepare() {\n\tfmt.Println(\"Preparing the dish.\")\n}\n\nfunc (d *CulinaryDish) Serve() {\n\tfmt.Println(\"Serving the dish.\")\n}\n\n// Appetizer subclass that overrides methods for smaller portions\ntype Appetizer struct {\n\tCulinaryDish\n}\n\nfunc (a *Appetizer) Prepare() {\n\tfmt.Println(\"Preparing a smaller portion of the appetizer.\")\n}\n\nfunc (a *Appetizer) Serve() {\n\tfmt.Println(\"Serving a smaller portion of the appetizer.\")\n}\n\nfunc main() {\n\tdish := CulinaryDish{}\n\tdish.Prepare()\n\tdish.Serve()\n\n\tappetizer := Appetizer{}\n\tappetizer.Prepare()\n\tappetizer.Serve()\n}\n```"
  },
  {
    "task": "Create a foundational class for a book collection with properties like genre and author, and derive a mystery collection class that overrides the genre property to be 'mystery'.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\ntype BookCollection struct {\n\tGenre  string\n\tAuthor string\n}\n\ntype MysteryCollection struct {\n\tBookCollection\n}\n\nfunc NewMysteryCollection(author string) MysteryCollection {\n\treturn MysteryCollection{\n\t\tBookCollection: BookCollection{\n\t\t\tGenre:  \"mystery\",\n\t\t\tAuthor: author,\n\t\t},\n\t}\n}\n\nfunc main() {\n\tmysteryBook := NewMysteryCollection(\"Agatha Christie\")\n\tfmt.Println(\"Genre:\", mysteryBook.Genre)\n\tfmt.Println(\"Author:\", mysteryBook.Author)\n}\n```"
  },
  {
    "task": "Design a base class for a file storage system with methods for saving and deleting files, then create a cloud storage subclass that overrides these methods for remote access.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Base class for file storage\ntype FileStorage struct{}\n\nfunc (fs *FileStorage) SaveFile(filename string) {\n\tfmt.Printf(\"Saving file: %s\\n\", filename)\n}\n\nfunc (fs *FileStorage) DeleteFile(filename string) {\n\tfmt.Printf(\"Deleting file: %s\\n\", filename)\n}\n\n// Subclass for cloud storage\ntype CloudStorage struct {\n\tFileStorage\n}\n\nfunc (cs *CloudStorage) SaveFile(filename string) {\n\tfmt.Printf(\"Saving file to cloud: %s\\n\", filename)\n}\n\nfunc (cs *CloudStorage) DeleteFile(filename string) {\n\tfmt.Printf(\"Deleting file from cloud: %s\\n\", filename)\n}\n\nfunc main() {\n\tlocalStorage := &FileStorage{}\n\tlocalStorage.SaveFile(\"local_file.txt\")\n\tlocalStorage.DeleteFile(\"local_file.txt\")\n\n\tcloudStorage := &CloudStorage{}\n\tcloudStorage.SaveFile(\"cloud_file.txt\")\n\tcloudStorage.DeleteFile(\"cloud_file.txt\")\n}\n```"
  },
  {
    "task": "Develop a superclass for a seasonal sale event with methods for discounts and promotions, then extend it with a summer sale subclass that overrides these methods for summer items.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\ntype SaleEvent struct{}\n\nfunc (s *SaleEvent) Discount() float64 {\n\treturn 0.0\n}\n\nfunc (s *SaleEvent) Promotion() string {\n\treturn \"No promotion\"\n}\n\ntype SummerSale struct {\n\tSaleEvent\n}\n\nfunc (s *SummerSale) Discount() float64 {\n\treturn 20.0\n}\n\nfunc (s *SummerSale) Promotion() string {\n\treturn \"Summer Special Promotion\"\n}\n\nfunc main() {\n\tgeneralSale := &SaleEvent{}\n\tsummerSale := &SummerSale{}\n\n\tfmt.Printf(\"General Sale Discount: %.2f%%\\n\", generalSale.Discount())\n\tfmt.Printf(\"General Sale Promotion: %s\\n\", generalSale.Promotion())\n\n\tfmt.Printf(\"Summer Sale Discount: %.2f%%\\n\", summerSale.Discount())\n\tfmt.Printf(\"Summer Sale Promotion: %s\\n\", summerSale.Promotion())\n}\n```"
  },
  {
    "task": "Implement a base class for a personal budget with methods for income and expenses, then create a student budget subclass that overrides these methods for tuition and fees.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// PersonalBudget is the base class with methods for income and expenses\ntype PersonalBudget struct {\n\tincome   float64\n\texpenses float64\n}\n\nfunc (pb *PersonalBudget) AddIncome(amount float64) {\n\tpb.income += amount\n}\n\nfunc (pb *PersonalBudget) AddExpense(amount float64) {\n\tpb.expenses += amount\n}\n\nfunc (pb *PersonalBudget) Balance() float64 {\n\treturn pb.income - pb.expenses\n}\n\n// StudentBudget is a subclass that overrides methods for tuition and fees\ntype StudentBudget struct {\n\tPersonalBudget\n}\n\nfunc (sb *StudentBudget) AddIncome(amount float64) {\n\tfmt.Println(\"Student income adjusted for scholarships and stipends\")\n\tsb.income += amount * 0.9 // Assuming some discount or adjustment for students\n}\n\nfunc (sb *StudentBudget) AddExpense(amount float64) {\n\tfmt.Println(\"Student expense adjusted for tuition and fees\")\n\tsb.expenses += amount * 1.1 // Assuming additional fees for students\n}\n\nfunc main() {\n\tpb := &PersonalBudget{}\n\tpb.AddIncome(1000)\n\tpb.AddExpense(200)\n\tfmt.Println(\"Personal Budget Balance:\", pb.Balance())\n\n\tsb := &StudentBudget{}\n\tsb.AddIncome(1000)\n\tsb.AddExpense(200)\n\tfmt.Println(\"Student Budget Balance:\", sb.Balance())\n}\n```"
  },
  {
    "task": "Construct a parent class for a fitness routine with methods for exercises and duration, then derive a yoga routine class that overrides these methods for flexibility exercises.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Parent class\ntype FitnessRoutine struct{}\n\nfunc (f *FitnessRoutine) Exercise() string {\n\treturn \"General Exercise\"\n}\n\nfunc (f *FitnessRoutine) Duration() int {\n\treturn 30\n}\n\n// Derived class\ntype YogaRoutine struct {\n\tFitnessRoutine\n}\n\nfunc (y *YogaRoutine) Exercise() string {\n\treturn \"Flexibility Exercises\"\n}\n\nfunc (y *YogaRoutine) Duration() int {\n\treturn 60\n}\n\nfunc main() {\n\tyoga := YogaRoutine{}\n\tfmt.Println(\"Exercise:\", yoga.Exercise())\n\tfmt.Println(\"Duration:\", yoga.Duration())\n}\n```"
  },
  {
    "task": "Set up a base class for a transportation ticket with methods for pricing and validity, and extend it with an airline ticket subclass that overrides these methods for baggage allowance.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Base class for a transportation ticket\ntype Ticket struct {\n\tprice   float64\n\tvalid   bool\n}\n\n// Method to get price of the ticket\nfunc (t *Ticket) GetPrice() float64 {\n\treturn t.price\n}\n\n// Method to check the validity of the ticket\nfunc (t *Ticket) IsValid() bool {\n\treturn t.valid\n}\n\n// Airline ticket subclass extending Ticket\ntype AirlineTicket struct {\n\tTicket\n\tbaggageAllowance int\n}\n\n// Override method to get price including baggage fee\nfunc (at *AirlineTicket) GetPrice() float64 {\n\tbaggageFee := float64(at.baggageAllowance) * 10.0\n\treturn at.Ticket.GetPrice() + baggageFee\n}\n\n// Override method to check validity and baggage allowance\nfunc (at *AirlineTicket) IsValid() bool {\n\treturn at.Ticket.IsValid() && at.baggageAllowance > 0\n}\n\nfunc main() {\n\tbaseTicket := Ticket{price: 100.0, valid: true}\n\tairlineTicket := AirlineTicket{\n\t\tTicket:           Ticket{price: 150.0, valid: true},\n\t\tbaggageAllowance: 2,\n\t}\n\n\tfmt.Printf(\"Base Ticket Price: $%.2f\\n\", baseTicket.GetPrice())\n\tfmt.Printf(\"Base Ticket Validity: %v\\n\", baseTicket.IsValid())\n\n\tfmt.Printf(\"Airline Ticket Price: $%.2f\\n\", airlineTicket.GetPrice())\n\tfmt.Printf(\"Airline Ticket Validity: %v\\n\", airlineTicket.IsValid())\n}\n```"
  },
  {
    "task": "Create a foundational class for a digital photo album with properties like album name and date, and derive a vacation album class that overrides the date property to be specific.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\n// Base class for a digital photo album\ntype PhotoAlbum struct {\n\tAlbumName string\n\tDate      time.Time\n}\n\n// Derived class for a vacation album\ntype VacationAlbum struct {\n\tPhotoAlbum\n\tDate string\n}\n\nfunc main() {\n\t// Create a photo album\n\tphotoAlbum := PhotoAlbum{\n\t\tAlbumName: \"My Album\",\n\t\tDate:      time.Now(),\n\t}\n\n\t// Create a vacation album\n\tvacationAlbum := VacationAlbum{\n\t\tPhotoAlbum: PhotoAlbum{\n\t\t\tAlbumName: \"Vacation Album\",\n\t\t},\n\t\tDate: \"2023-10-01\",\n\t}\n\n\tfmt.Printf(\"Photo Album: %s, Date: %s\\n\", photoAlbum.AlbumName, photoAlbum.Date.String())\n\tfmt.Printf(\"Vacation Album: %s, Date: %s\\n\", vacationAlbum.AlbumName, vacationAlbum.Date)\n}\n```"
  },
  {
    "task": "Design a base class for a home appliance with methods for power usage and warranty, then create a refrigerator subclass that overrides these methods for energy efficiency.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Base class for a home appliance\ntype HomeAppliance struct {\n\tbrand string\n}\n\nfunc (ha *HomeAppliance) PowerUsage() string {\n\treturn \"Standard power usage\"\n}\n\nfunc (ha *HomeAppliance) Warranty() string {\n\treturn \"1 year warranty\"\n}\n\n// Refrigerator subclass\ntype Refrigerator struct {\n\tHomeAppliance\n}\n\nfunc (r *Refrigerator) PowerUsage() string {\n\treturn \"Energy-efficient power usage\"\n}\n\nfunc (r *Refrigerator) Warranty() string {\n\treturn \"2 years warranty\"\n}\n\nfunc main() {\n\tappliance := HomeAppliance{brand: \"Generic\"}\n\trefrigerator := Refrigerator{HomeAppliance: HomeAppliance{brand: \"EcoFridge\"}}\n\n\tfmt.Println(\"Appliance Power Usage:\", appliance.PowerUsage())\n\tfmt.Println(\"Appliance Warranty:\", appliance.Warranty())\n\n\tfmt.Println(\"Refrigerator Power Usage:\", refrigerator.PowerUsage())\n\tfmt.Println(\"Refrigerator Warranty:\", refrigerator.Warranty())\n}\n```"
  },
  {
    "task": "Develop a superclass for a software update with methods for versioning and patch notes, then extend it with a security update subclass that overrides these methods for vulnerabilities.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\n// SoftwareUpdate is the superclass with methods for versioning and patch notes.\ntype SoftwareUpdate struct {\n\tVersion    string\n\tPatchNotes string\n}\n\nfunc (su *SoftwareUpdate) GetVersion() string {\n\treturn su.Version\n}\n\nfunc (su *SoftwareUpdate) GetPatchNotes() string {\n\treturn su.PatchNotes\n}\n\n// SecurityUpdate is a subclass that overrides methods for versioning and patch notes.\ntype SecurityUpdate struct {\n\tSoftwareUpdate\n\tVulnerabilities string\n}\n\nfunc (su *SecurityUpdate) GetVersion() string {\n\treturn su.Version + \" (Security Update)\"\n}\n\nfunc (su *SecurityUpdate) GetPatchNotes() string {\n\treturn su.PatchNotes + \"\\nVulnerabilities Fixed: \" + su.Vulnerabilities\n}\n\nfunc main() {\n\tregularUpdate := &SoftwareUpdate{\n\t\tVersion:    \"1.0.1\",\n\t\tPatchNotes: \"Bug fixes and performance improvements.\",\n\t}\n\n\tsecurityUpdate := &SecurityUpdate{\n\t\tSoftwareUpdate: SoftwareUpdate{\n\t\t\tVersion:    \"1.0.2\",\n\t\t\tPatchNotes: \"Security enhancements.\",\n\t\t},\n\t\tVulnerabilities: \"Fixed CVE-1234-5678, CVE-9876-5432\",\n\t}\n\n\tfmt.Println(\"Regular Update Version:\", regularUpdate.GetVersion())\n\tfmt.Println(\"Regular Update Notes:\", regularUpdate.GetPatchNotes())\n\n\tfmt.Println(\"Security Update Version:\", securityUpdate.GetVersion())\n\tfmt.Println(\"Security Update Notes:\", securityUpdate.GetPatchNotes())\n}\n```"
  },
  {
    "task": "Implement a base class for a musical performance with methods for rehearsal and execution, then create a concert performance subclass that overrides these methods for live audience.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Base class\ntype Performance struct{}\n\nfunc (p *Performance) Rehearse() {\n\tfmt.Println(\"Rehearsing performance\")\n}\n\nfunc (p *Performance) Execute() {\n\tfmt.Println(\"Executing performance\")\n}\n\n// Subclass\ntype ConcertPerformance struct {\n\tPerformance\n}\n\nfunc (c *ConcertPerformance) Rehearse() {\n\tfmt.Println(\"Rehearsing concert performance for live audience\")\n}\n\nfunc (c *ConcertPerformance) Execute() {\n\tfmt.Println(\"Executing concert performance for live audience\")\n}\n\nfunc main() {\n\tvar p Performance\n\tp.Rehearse()\n\tp.Execute()\n\n\tvar cp ConcertPerformance\n\tcp.Rehearse()\n\tcp.Execute()\n}\n```"
  },
  {
    "task": "Construct a parent class for an academic degree with methods for course requirements and credits, then derive a master's degree class that overrides these methods for advanced studies.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Parent class representing an academic degree\ntype AcademicDegree struct {\n}\n\nfunc (a *AcademicDegree) CourseRequirements() string {\n\treturn \"Basic Courses\"\n}\n\nfunc (a *AcademicDegree) Credits() int {\n\treturn 120\n}\n\n// Derived class representing a master's degree\ntype MastersDegree struct {\n\tAcademicDegree\n}\n\nfunc (m *MastersDegree) CourseRequirements() string {\n\treturn \"Advanced Courses\"\n}\n\nfunc (m *MastersDegree) Credits() int {\n\treturn 60\n}\n\nfunc main() {\n\tdegree := AcademicDegree{}\n\tmasters := MastersDegree{}\n\n\tfmt.Println(\"Academic Degree:\")\n\tfmt.Println(\"Course Requirements:\", degree.CourseRequirements())\n\tfmt.Println(\"Credits:\", degree.Credits())\n\n\tfmt.Println(\"\\nMaster's Degree:\")\n\tfmt.Println(\"Course Requirements:\", masters.CourseRequirements())\n\tfmt.Println(\"Credits:\", masters.Credits())\n}\n```"
  },
  {
    "task": "Set up a base class for a weather forecast with methods for temperature and conditions, and extend it with a winter forecast subclass that overrides these methods for snow conditions.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Base class\ntype WeatherForecast struct{}\n\nfunc (wf WeatherForecast) Temperature() string {\n\treturn \"The temperature is moderate.\"\n}\n\nfunc (wf WeatherForecast) Conditions() string {\n\treturn \"The weather conditions are clear.\"\n}\n\n// Subclass\ntype WinterForecast struct {\n\tWeatherForecast\n}\n\nfunc (wf WinterForecast) Temperature() string {\n\treturn \"The temperature is below freezing.\"\n}\n\nfunc (wf WinterForecast) Conditions() string {\n\treturn \"The weather conditions include snow.\"\n}\n\nfunc main() {\n\tforecast := WeatherForecast{}\n\tfmt.Println(forecast.Temperature())\n\tfmt.Println(forecast.Conditions())\n\n\twinterForecast := WinterForecast{}\n\tfmt.Println(winterForecast.Temperature())\n\tfmt.Println(winterForecast.Conditions())\n}\n```"
  },
  {
    "task": "Create a foundational class for a personal diary with properties like date and entries, and derive a travel diary class that overrides the date property with travel dates.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\ntype PersonalDiary struct {\n\tDate   time.Time\n\tEntries []string\n}\n\nfunc (pd *PersonalDiary) AddEntry(entry string) {\n\tpd.Entries = append(pd.Entries, entry)\n}\n\ntype TravelDiary struct {\n\tPersonalDiary\n\tTravelDate time.Time\n}\n\nfunc (td *TravelDiary) SetTravelDate(date time.Time) {\n\ttd.TravelDate = date\n}\n\nfunc (td *TravelDiary) AddEntry(entry string) {\n\ttd.Entries = append(td.Entries, fmt.Sprintf(\"Travel Entry: %s\", entry))\n}\n\nfunc main() {\n\tpd := PersonalDiary{Date: time.Now()}\n\tpd.AddEntry(\"Personal entry 1\")\n\tfmt.Println(pd)\n\n\ttd := TravelDiary{}\n\ttd.SetTravelDate(time.Date(2023, 10, 1, 0, 0, 0, 0, time.UTC))\n\ttd.AddEntry(\"Travel entry 1\")\n\tfmt.Println(td)\n}\n```"
  },
  {
    "task": "Design a base class for a pet with methods for feeding and grooming, then create a cat subclass that overrides these methods with specific food preferences.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Pet is the base class for all pets\ntype Pet struct {\n\tname string\n}\n\n// Feed method for Pet\nfunc (p *Pet) Feed() {\n\tfmt.Println(\"Feeding the pet\")\n}\n\n// Groom method for Pet\nfunc (p *Pet) Groom() {\n\tfmt.Println(\"Grooming the pet\")\n}\n\n// Cat is a subclass of Pet\ntype Cat struct {\n\tPet\n}\n\n// Feed method for Cat\nfunc (c *Cat) Feed() {\n\tfmt.Println(\"Feeding the cat with cat food\")\n}\n\n// Groom method for Cat\nfunc (c *Cat) Groom() {\n\tfmt.Println(\"Grooming the cat\")\n}\n\nfunc main() {\n\tpet := Pet{name: \"Generic Pet\"}\n\tcat := Cat{Pet{name: \"Whiskers\"}}\n\n\tpet.Feed()\n\tpet.Groom()\n\n\tcat.Feed()\n\tcat.Groom()\n}\n```"
  },
  {
    "task": "Develop a superclass for a software library with methods for installation and updates, then extend it with a graphics library subclass that overrides these methods for rendering capabilities.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\n// Superclass\ntype SoftwareLibrary struct{}\n\nfunc (s *SoftwareLibrary) Install() {\n\tfmt.Println(\"Installing software library...\")\n}\n\nfunc (s *SoftwareLibrary) Update() {\n\tfmt.Println(\"Updating software library...\")\n}\n\n// Subclass\ntype GraphicsLibrary struct {\n\tSoftwareLibrary\n}\n\nfunc (g *GraphicsLibrary) Install() {\n\tfmt.Println(\"Installing graphics library with rendering capabilities...\")\n}\n\nfunc (g *GraphicsLibrary) Update() {\n\tfmt.Println(\"Updating graphics library with rendering enhancements...\")\n}\n\nfunc main() {\n\tsoftware := SoftwareLibrary{}\n\tsoftware.Install()\n\tsoftware.Update()\n\n\tgraphics := GraphicsLibrary{}\n\tgraphics.Install()\n\tgraphics.Update()\n}\n```"
  },
  {
    "task": "Implement a base class for a political campaign with methods for fundraising and events, then create a presidential campaign subclass that overrides these methods for national scale.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Base class for a political campaign\ntype Campaign struct {\n\tname string\n}\n\nfunc (c *Campaign) Fundraise() {\n\tfmt.Println(\"Fundraising for the campaign.\")\n}\n\nfunc (c *Campaign) Event() {\n\tfmt.Println(\"Hosting a local campaign event.\")\n}\n\n// Subclass for a presidential campaign\ntype PresidentialCampaign struct {\n\tCampaign\n}\n\nfunc (p *PresidentialCampaign) Fundraise() {\n\tfmt.Println(\"Fundraising on a national scale for the presidential campaign.\")\n}\n\nfunc (p *PresidentialCampaign) Event() {\n\tfmt.Println(\"Hosting a national campaign event.\")\n}\n\nfunc main() {\n\tlocalCampaign := &Campaign{name: \"Local Campaign\"}\n\tlocalCampaign.Fundraise()\n\tlocalCampaign.Event()\n\n\tnationalCampaign := &PresidentialCampaign{Campaign{name: \"Presidential Campaign\"}}\n\tnationalCampaign.Fundraise()\n\tnationalCampaign.Event()\n}\n```"
  },
  {
    "task": "Construct a parent class for an automotive part with methods for durability and replacement, then derive an engine part class that overrides these methods for performance.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Parent class\ntype AutomotivePart struct{}\n\nfunc (a AutomotivePart) Durability() string {\n\treturn \"Standard Durability\"\n}\n\nfunc (a AutomotivePart) Replacement() string {\n\treturn \"Standard Replacement Procedure\"\n}\n\n// Derived class\ntype EnginePart struct {\n\tAutomotivePart\n}\n\nfunc (e EnginePart) Durability() string {\n\treturn \"High Performance Durability\"\n}\n\nfunc (e EnginePart) Replacement() string {\n\treturn \"Performance Engine Replacement Procedure\"\n}\n\nfunc main() {\n\tpart := AutomotivePart{}\n\tengine := EnginePart{}\n\n\tfmt.Println(\"Automotive Part Durability:\", part.Durability())\n\tfmt.Println(\"Automotive Part Replacement:\", part.Replacement())\n\n\tfmt.Println(\"Engine Part Durability:\", engine.Durability())\n\tfmt.Println(\"Engine Part Replacement:\", engine.Replacement())\n}\n```"
  },
  {
    "task": "Set up a base class for an online tutorial with methods for lessons and quizzes, and extend it with a coding tutorial subclass that overrides these methods for interactive exercises.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Base class\ntype Tutorial struct{}\n\nfunc (t *Tutorial) Lessons() {\n\tfmt.Println(\"This is a generic lesson.\")\n}\n\nfunc (t *Tutorial) Quizzes() {\n\tfmt.Println(\"This is a generic quiz.\")\n}\n\n// Subclass\ntype CodingTutorial struct {\n\tTutorial\n}\n\nfunc (c *CodingTutorial) Lessons() {\n\tfmt.Println(\"This is an interactive coding lesson.\")\n}\n\nfunc (c *CodingTutorial) Quizzes() {\n\tfmt.Println(\"This is an interactive coding quiz.\")\n}\n\nfunc main() {\n\tbase := &Tutorial{}\n\tbase.Lessons()\n\tbase.Quizzes()\n\n\tcoding := &CodingTutorial{}\n\tcoding.Lessons()\n\tcoding.Quizzes()\n}\n```"
  },
  {
    "task": "Create a foundational class for a personal collection with properties like item type and value, and derive a stamp collection class that overrides the item type property to be 'stamps'.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\ntype Collection struct {\n\tItemType string\n\tValue    float64\n}\n\ntype StampCollection struct {\n\tCollection\n}\n\nfunc NewStampCollection(value float64) *StampCollection {\n\treturn &StampCollection{\n\t\tCollection: Collection{\n\t\t\tItemType: \"stamps\",\n\t\t\tValue:    value,\n\t\t},\n\t}\n}\n\nfunc main() {\n\tstampCollection := NewStampCollection(100.0)\n\tfmt.Printf(\"Item Type: %s, Value: %.2f\\n\", stampCollection.ItemType, stampCollection.Value)\n}\n```"
  },
  {
    "task": "Design a base class for a video game character with methods for health and abilities, then create a warrior character subclass that overrides these methods for strength.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Base class for a video game character\ntype Character struct {\n\thealth int\n}\n\nfunc (c *Character) Health() int {\n\treturn c.health\n}\n\nfunc (c *Character) Abilities() string {\n\treturn \"Generic abilities\"\n}\n\n// Warrior subclass that overrides methods\ntype Warrior struct {\n\tCharacter\n}\n\nfunc (w *Warrior) Health() int {\n\treturn w.health + 50 // Warriors have extra health\n}\n\nfunc (w *Warrior) Abilities() string {\n\treturn \"Strength and combat skills\"\n}\n\nfunc main() {\n\twarrior := &Warrior{Character{health: 100}}\n\tfmt.Println(\"Warrior Health:\", warrior.Health())\n\tfmt.Println(\"Warrior Abilities:\", warrior.Abilities())\n}\n```"
  },
  {
    "task": "Develop a superclass for an event planner with methods for scheduling and budgeting, then extend it with a wedding planner subclass that overrides these methods for ceremony details.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Superclass for an event planner\ntype EventPlanner struct {\n\tname string\n}\n\n// Method for scheduling an event\nfunc (e *EventPlanner) Schedule() string {\n\treturn \"Scheduling a generic event.\"\n}\n\n// Method for budgeting an event\nfunc (e *EventPlanner) Budget() string {\n\treturn \"Budgeting a generic event.\"\n}\n\n// Subclass for a wedding planner\ntype WeddingPlanner struct {\n\tEventPlanner\n}\n\n// Overriding the Schedule method for wedding\nfunc (w *WeddingPlanner) Schedule() string {\n\treturn \"Scheduling a wedding ceremony.\"\n}\n\n// Overriding the Budget method for wedding\nfunc (w *WeddingPlanner) Budget() string {\n\treturn \"Budgeting for a wedding ceremony.\"\n}\n\nfunc main() {\n\teventPlanner := EventPlanner{name: \"Generic Event\"}\n\tfmt.Println(eventPlanner.Schedule())\n\tfmt.Println(eventPlanner.Budget())\n\n\tweddingPlanner := WeddingPlanner{EventPlanner: EventPlanner{name: \"Wedding\"}}\n\tfmt.Println(weddingPlanner.Schedule())\n\tfmt.Println(weddingPlanner.Budget())\n}\n```"
  },
  {
    "task": "Implement a base class for a software feature with methods for functionality and user feedback, then create a beta feature subclass that overrides these methods for testing.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// BaseFeature is the base class with methods for functionality and user feedback\ntype BaseFeature struct{}\n\n// Functionality provides the main feature functionality\nfunc (bf *BaseFeature) Functionality() {\n\tfmt.Println(\"Base feature functionality.\")\n}\n\n// UserFeedback provides feedback to the user\nfunc (bf *BaseFeature) UserFeedback() {\n\tfmt.Println(\"Base feature user feedback.\")\n}\n\n// BetaFeature is a subclass that overrides BaseFeature methods for testing\ntype BetaFeature struct {\n\tBaseFeature\n}\n\n// Functionality overrides the base functionality for testing\nfunc (bf *BetaFeature) Functionality() {\n\tfmt.Println(\"Beta feature functionality for testing.\")\n}\n\n// UserFeedback overrides the base user feedback for testing\nfunc (bf *BetaFeature) UserFeedback() {\n\tfmt.Println(\"Beta feature user feedback for testing.\")\n}\n\nfunc main() {\n\tbase := &BaseFeature{}\n\tbeta := &BetaFeature{}\n\n\tbase.Functionality()\n\tbase.UserFeedback()\n\n\tbeta.Functionality()\n\tbeta.UserFeedback()\n}\n```"
  },
  {
    "task": "Construct a parent class for a gardening tool with methods for usage and maintenance, then derive a lawn mower class that overrides these methods for grass cutting.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Parent class\ntype GardeningTool struct{}\n\nfunc (g GardeningTool) Usage() {\n\tfmt.Println(\"Using the gardening tool.\")\n}\n\nfunc (g GardeningTool) Maintenance() {\n\tfmt.Println(\"Performing maintenance on the gardening tool.\")\n}\n\n// Derived class\ntype LawnMower struct {\n\tGardeningTool\n}\n\nfunc (l LawnMower) Usage() {\n\tfmt.Println(\"Using the lawn mower for cutting grass.\")\n}\n\nfunc (l LawnMower) Maintenance() {\n\tfmt.Println(\"Performing maintenance on the lawn mower.\")\n}\n\nfunc main() {\n\ttool := GardeningTool{}\n\ttool.Usage()\n\ttool.Maintenance()\n\n\tmower := LawnMower{}\n\tmower.Usage()\n\tmower.Maintenance()\n}\n```"
  },
  {
    "task": "Set up a base class for a household chore with methods for time and effort, and extend it with a cleaning chore subclass that overrides these methods for dirt removal.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Base class\ntype Chore struct{}\n\nfunc (c *Chore) Time() string {\n\treturn \"Time needed: General\"\n}\n\nfunc (c *Chore) Effort() string {\n\treturn \"Effort level: General\"\n}\n\n// Subclass\ntype CleaningChore struct {\n\tChore\n}\n\nfunc (cc *CleaningChore) Time() string {\n\treturn \"Time needed: Specific to cleaning\"\n}\n\nfunc (cc *CleaningChore) Effort() string {\n\treturn \"Effort level: Specific to dirt removal\"\n}\n\nfunc main() {\n\tbaseChore := Chore{}\n\tcleaningChore := CleaningChore{}\n\n\tfmt.Println(\"Base Chore:\")\n\tfmt.Println(baseChore.Time())\n\tfmt.Println(baseChore.Effort())\n\n\tfmt.Println(\"\\nCleaning Chore:\")\n\tfmt.Println(cleaningChore.Time())\n\tfmt.Println(cleaningChore.Effort())\n}\n```"
  },
  {
    "task": "Create a foundational class for a personal project with properties like name and deadline, and derive a coding project class that overrides the deadline property for milestones.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\ntype Project struct {\n\tname     string\n\tdeadline string\n}\n\nfunc (p *Project) GetName() string {\n\treturn p.name\n}\n\nfunc (p *Project) GetDeadline() string {\n\treturn p.deadline\n}\n\ntype CodingProject struct {\n\tProject\n\tmilestoneDeadline string\n}\n\nfunc (cp *CodingProject) GetDeadline() string {\n\treturn cp.milestoneDeadline\n}\n\nfunc main() {\n\tproject := Project{name: \"General Project\", deadline: \"2023-12-31\"}\n\tcodingProject := CodingProject{\n\t\tProject:           Project{name: \"Coding Project\", deadline: \"2023-12-31\"},\n\t\tmilestoneDeadline: \"2023-11-01\",\n\t}\n\n\tfmt.Println(\"Project Name:\", project.GetName())\n\tfmt.Println(\"Project Deadline:\", project.GetDeadline())\n\n\tfmt.Println(\"Coding Project Name:\", codingProject.GetName())\n\tfmt.Println(\"Coding Project Milestone Deadline:\", codingProject.GetDeadline())\n}\n```"
  },
  {
    "task": "Design a base class for a holiday celebration with methods for traditions and activities, then create a Christmas celebration subclass that overrides these methods for gift exchange.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Base class for a holiday celebration\ntype HolidayCelebration struct{}\n\nfunc (h *HolidayCelebration) Traditions() {\n\tfmt.Println(\"General holiday traditions\")\n}\n\nfunc (h *HolidayCelebration) Activities() {\n\tfmt.Println(\"General holiday activities\")\n}\n\n// Christmas celebration subclass\ntype ChristmasCelebration struct {\n\tHolidayCelebration\n}\n\nfunc (c *ChristmasCelebration) Traditions() {\n\tfmt.Println(\"Christmas traditions: Decorating the tree, singing carols\")\n}\n\nfunc (c *ChristmasCelebration) Activities() {\n\tfmt.Println(\"Christmas activities: Gift exchange, family dinner\")\n}\n\nfunc main() {\n\tholiday := HolidayCelebration{}\n\tholiday.Traditions()\n\tholiday.Activities()\n\n\tchristmas := ChristmasCelebration{}\n\tchristmas.Traditions()\n\tchristmas.Activities()\n}\n```"
  },
  {
    "task": "Develop a superclass for a customer feedback system with methods for collecting and analyzing, then extend it with a product feedback subclass that overrides these methods for reviews.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Superclass\ntype FeedbackSystem struct{}\n\nfunc (fs *FeedbackSystem) CollectFeedback() string {\n\treturn \"Collecting general feedback.\"\n}\n\nfunc (fs *FeedbackSystem) AnalyzeFeedback(feedback string) string {\n\treturn \"Analyzing general feedback: \" + feedback\n}\n\n// Subclass\ntype ProductFeedback struct {\n\tFeedbackSystem\n}\n\nfunc (pf *ProductFeedback) CollectFeedback() string {\n\treturn \"Collecting product feedback.\"\n}\n\nfunc (pf *ProductFeedback) AnalyzeFeedback(feedback string) string {\n\treturn \"Analyzing product feedback: \" + feedback\n}\n\nfunc main() {\n\t// Using the superclass\n\tfs := &FeedbackSystem{}\n\tfmt.Println(fs.CollectFeedback())\n\tfmt.Println(fs.AnalyzeFeedback(\"Great service!\"))\n\n\t// Using the subclass\n\tpf := &ProductFeedback{}\n\tfmt.Println(pf.CollectFeedback())\n\tfmt.Println(pf.AnalyzeFeedback(\"Excellent product!\"))\n}\n```"
  },
  {
    "task": "Implement a base class for a civic service with methods for public engagement and policy, then create a community service subclass that overrides these methods for local impact.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// CivicService is the base class\ntype CivicService struct{}\n\n// PublicEngagement method for CivicService\nfunc (cs CivicService) PublicEngagement() {\n\tfmt.Println(\"Engaging with the public at a national level.\")\n}\n\n// Policy method for CivicService\nfunc (cs CivicService) Policy() {\n\tfmt.Println(\"Implementing policy at a national level.\")\n}\n\n// CommunityService is a subclass of CivicService\ntype CommunityService struct {\n\tCivicService\n}\n\n// PublicEngagement method for CommunityService\nfunc (cs CommunityService) PublicEngagement() {\n\tfmt.Println(\"Engaging with the local community.\")\n}\n\n// Policy method for CommunityService\nfunc (cs CommunityService) Policy() {\n\tfmt.Println(\"Implementing policy for local impact.\")\n}\n\nfunc main() {\n\tnationalService := CivicService{}\n\tlocalService := CommunityService{}\n\n\tnationalService.PublicEngagement()\n\tnationalService.Policy()\n\n\tlocalService.PublicEngagement()\n\tlocalService.Policy()\n}\n```"
  },
  {
    "task": "Construct a parent class for a culinary ingredient with methods for flavor and preparation, then derive a spice ingredient class that overrides these methods for seasoning.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Parent class for a culinary ingredient\ntype Ingredient struct{}\n\nfunc (i Ingredient) Flavor() string {\n\treturn \"Generic flavor\"\n}\n\nfunc (i Ingredient) Prepare() string {\n\treturn \"Generic preparation\"\n}\n\n// Derived class for a spice ingredient\ntype Spice struct {\n\tIngredient\n}\n\nfunc (s Spice) Flavor() string {\n\treturn \"Spicy flavor\"\n}\n\nfunc (s Spice) Prepare() string {\n\treturn \"Grind to powder\"\n}\n\nfunc main() {\n\tvar spice Spice\n\tfmt.Println(\"Spice flavor:\", spice.Flavor())\n\tfmt.Println(\"Spice preparation:\", spice.Prepare())\n}\n```"
  },
  {
    "task": "Set up a base class for a scientific experiment with methods for hypothesis and testing, and extend it with a chemistry experiment subclass that overrides these methods for reactions.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Base class\ntype ScientificExperiment interface {\n\tHypothesis() string\n\tTesting() string\n}\n\ntype BaseExperiment struct{}\n\nfunc (b BaseExperiment) Hypothesis() string {\n\treturn \"Base experiment hypothesis.\"\n}\n\nfunc (b BaseExperiment) Testing() string {\n\treturn \"Base experiment testing.\"\n}\n\n// Chemistry subclass\ntype ChemistryExperiment struct {\n\tBaseExperiment\n}\n\nfunc (c ChemistryExperiment) Hypothesis() string {\n\treturn \"Chemistry experiment hypothesis.\"\n}\n\nfunc (c ChemistryExperiment) Testing() string {\n\treturn \"Chemistry experiment testing for reactions.\"\n}\n\nfunc main() {\n\tvar exp ScientificExperiment\n\n\texp = BaseExperiment{}\n\tfmt.Println(exp.Hypothesis())\n\tfmt.Println(exp.Testing())\n\n\texp = ChemistryExperiment{}\n\tfmt.Println(exp.Hypothesis())\n\tfmt.Println(exp.Testing())\n}\n```"
  },
  {
    "task": "Create a foundational class for an inventory system with properties like item ID and quantity, and derive a warehouse inventory class that overrides the quantity property for bulk storage.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Base class for Inventory\ntype Inventory struct {\n\tItemID   string\n\tQuantity int\n}\n\n// Derived class for WarehouseInventory\ntype WarehouseInventory struct {\n\tInventory\n}\n\n// Method to set bulk quantity for WarehouseInventory\nfunc (w *WarehouseInventory) SetBulkQuantity(quantity int) {\n\tw.Quantity = quantity * 100 // assuming bulk means 100 times\n}\n\nfunc main() {\n\t// Creating an instance of WarehouseInventory\n\twarehouseItem := WarehouseInventory{\n\t\tInventory: Inventory{ItemID: \"ABC123\"},\n\t}\n\n\t// Set bulk quantity\n\twarehouseItem.SetBulkQuantity(5)\n\n\t// Output the details\n\tfmt.Printf(\"Item ID: %s, Quantity: %d\\n\", warehouseItem.ItemID, warehouseItem.Quantity)\n}\n```"
  },
  {
    "task": "Design a base class for a travel agency with methods for itinerary and bookings, then create a luxury travel subclass that overrides these methods for premium services.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Base class for a travel agency\ntype TravelAgency struct{}\n\nfunc (t *TravelAgency) Itinerary() {\n\tfmt.Println(\"Standard Itinerary\")\n}\n\nfunc (t *TravelAgency) Bookings() {\n\tfmt.Println(\"Standard Bookings\")\n}\n\n// Luxury travel subclass\ntype LuxuryTravel struct {\n\tTravelAgency\n}\n\nfunc (l *LuxuryTravel) Itinerary() {\n\tfmt.Println(\"Premium Itinerary\")\n}\n\nfunc (l *LuxuryTravel) Bookings() {\n\tfmt.Println(\"Premium Bookings\")\n}\n\nfunc main() {\n\tstandard := &TravelAgency{}\n\tluxury := &LuxuryTravel{}\n\n\tstandard.Itinerary()\n\tstandard.Bookings()\n\n\tluxury.Itinerary()\n\tluxury.Bookings()\n}\n```"
  },
  {
    "task": "Develop a superclass for an educational tool with methods for teaching and assessment, then extend it with a math tool subclass that overrides these methods for problem-solving.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\n// EducationalTool is the superclass for an educational tool\ntype EducationalTool struct{}\n\n// Teach method for EducationalTool\nfunc (et *EducationalTool) Teach() {\n\tfmt.Println(\"Teaching in a general way.\")\n}\n\n// Assess method for EducationalTool\nfunc (et *EducationalTool) Assess() {\n\tfmt.Println(\"Assessing in a general way.\")\n}\n\n// MathTool is a subclass of EducationalTool for math-specific tasks\ntype MathTool struct {\n\tEducationalTool\n}\n\n// Teach method overridden for MathTool\nfunc (mt *MathTool) Teach() {\n\tfmt.Println(\"Teaching math problem-solving techniques.\")\n}\n\n// Assess method overridden for MathTool\nfunc (mt *MathTool) Assess() {\n\tfmt.Println(\"Assessing math problem-solving skills.\")\n}\n\nfunc main() {\n\tgeneralTool := &EducationalTool{}\n\tgeneralTool.Teach()\n\tgeneralTool.Assess()\n\n\tmathTool := &MathTool{}\n\tmathTool.Teach()\n\tmathTool.Assess()\n}\n```"
  },
  {
    "task": "Implement a base class for a community project with methods for planning and execution, then create a park renovation subclass that overrides these methods for landscaping.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Base class\ntype CommunityProject struct{}\n\nfunc (cp *CommunityProject) Plan() {\n\tfmt.Println(\"Planning the community project...\")\n}\n\nfunc (cp *CommunityProject) Execute() {\n\tfmt.Println(\"Executing the community project...\")\n}\n\n// Subclass\ntype ParkRenovation struct {\n\tCommunityProject\n}\n\nfunc (pr *ParkRenovation) Plan() {\n\tfmt.Println(\"Planning the park renovation with landscaping details...\")\n}\n\nfunc (pr *ParkRenovation) Execute() {\n\tfmt.Println(\"Executing the park renovation with landscaping tasks...\")\n}\n\nfunc main() {\n\tvar project CommunityProject\n\tproject.Plan()\n\tproject.Execute()\n\n\tvar parkRenovation ParkRenovation\n\tparkRenovation.Plan()\n\tparkRenovation.Execute()\n}\n```"
  },
  {
    "task": "Construct a parent class for a digital marketing strategy with methods for targeting and engagement, then derive a social media strategy class that overrides these methods for platforms.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Parent class for Digital Marketing Strategy\ntype DigitalMarketingStrategy struct{}\n\nfunc (d *DigitalMarketingStrategy) Targeting() {\n\tfmt.Println(\"General targeting strategy.\")\n}\n\nfunc (d *DigitalMarketingStrategy) Engagement() {\n\tfmt.Println(\"General engagement strategy.\")\n}\n\n// Derived class for Social Media Strategy\ntype SocialMediaStrategy struct {\n\tDigitalMarketingStrategy\n}\n\nfunc (s *SocialMediaStrategy) Targeting() {\n\tfmt.Println(\"Social media specific targeting.\")\n}\n\nfunc (s *SocialMediaStrategy) Engagement() {\n\tfmt.Println(\"Social media specific engagement.\")\n}\n\nfunc main() {\n\tdigitalStrategy := DigitalMarketingStrategy{}\n\tdigitalStrategy.Targeting()\n\tdigitalStrategy.Engagement()\n\n\tsocialStrategy := SocialMediaStrategy{}\n\tsocialStrategy.Targeting()\n\tsocialStrategy.Engagement()\n}\n```"
  },
  {
    "task": "Set up a base class for a scientific publication with methods for research and review, and extend it with a journal article subclass that overrides these methods for peer review.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Base class for a scientific publication\ntype ScientificPublication struct{}\n\nfunc (sp *ScientificPublication) Research() {\n\tfmt.Println(\"Conducting research for a scientific publication.\")\n}\n\nfunc (sp *ScientificPublication) Review() {\n\tfmt.Println(\"Reviewing the scientific publication.\")\n}\n\n// Subclass for a journal article\ntype JournalArticle struct {\n\tScientificPublication\n}\n\nfunc (ja *JournalArticle) Research() {\n\tfmt.Println(\"Conducting research for a journal article.\")\n}\n\nfunc (ja *JournalArticle) Review() {\n\tfmt.Println(\"Peer reviewing the journal article.\")\n}\n\nfunc main() {\n\tsp := &ScientificPublication{}\n\tja := &JournalArticle{}\n\n\tsp.Research()\n\tsp.Review()\n\n\tja.Research()\n\tja.Review()\n}\n```"
  },
  {
    "task": "Create a foundational class for a software module with properties like name and dependencies, and derive a user interface module class that overrides the dependencies property for UI libraries.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// BaseModule represents a foundational module with name and dependencies.\ntype BaseModule struct {\n\tName         string\n\tDependencies []string\n}\n\n// UserInterfaceModule is derived from BaseModule with overridden dependencies.\ntype UserInterfaceModule struct {\n\tBaseModule\n}\n\n// NewBaseModule creates a new BaseModule.\nfunc NewBaseModule(name string, dependencies []string) *BaseModule {\n\treturn &BaseModule{Name: name, Dependencies: dependencies}\n}\n\n// NewUserInterfaceModule creates a new UserInterfaceModule with UI-specific dependencies.\nfunc NewUserInterfaceModule(name string) *UserInterfaceModule {\n\tuiDependencies := []string{\"UI Library 1\", \"UI Library 2\"}\n\treturn &UserInterfaceModule{BaseModule: *NewBaseModule(name, uiDependencies)}\n}\n\nfunc main() {\n\tbaseModule := NewBaseModule(\"Core Module\", []string{\"Library A\", \"Library B\"})\n\tuiModule := NewUserInterfaceModule(\"UI Module\")\n\t\n\tfmt.Printf(\"Base Module: %s, Dependencies: %v\\n\", baseModule.Name, baseModule.Dependencies)\n\tfmt.Printf(\"UI Module: %s, Dependencies: %v\\n\", uiModule.Name, uiModule.Dependencies)\n}\n```"
  },
  {
    "task": "Design a base class for a fashion line with methods for design and production, then create a summer collection subclass that overrides these methods for seasonal trends.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\ntype FashionLine struct{}\n\nfunc (f FashionLine) Design() {\n\tfmt.Println(\"Designing general fashion line.\")\n}\n\nfunc (f FashionLine) Production() {\n\tfmt.Println(\"Producing general fashion line.\")\n}\n\ntype SummerCollection struct {\n\tFashionLine\n}\n\nfunc (s SummerCollection) Design() {\n\tfmt.Println(\"Designing summer collection with seasonal trends.\")\n}\n\nfunc (s SummerCollection) Production() {\n\tfmt.Println(\"Producing summer collection with seasonal trends.\")\n}\n\nfunc main() {\n\tbase := FashionLine{}\n\tsummer := SummerCollection{}\n\n\tbase.Design()\n\tbase.Production()\n\n\tsummer.Design()\n\tsummer.Production()\n}\n```"
  },
  {
    "task": "Develop a superclass for a family tree with methods for ancestry and descendants, then extend it with a royal lineage subclass that overrides these methods for historical accuracy.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Person represents a node in a family tree\ntype Person struct {\n\tname       string\n\tancestors  []string\n\tdescendants []string\n}\n\n// NewPerson creates a new person with a name\nfunc NewPerson(name string) *Person {\n\treturn &Person{name: name}\n}\n\n// AddAncestor adds an ancestor to the person\nfunc (p *Person) AddAncestor(ancestor string) {\n\tp.ancestors = append(p.ancestors, ancestor)\n}\n\n// AddDescendant adds a descendant to the person\nfunc (p *Person) AddDescendant(descendant string) {\n\tp.descendants = append(p.descendants, descendant)\n}\n\n// GetAncestors returns the list of ancestors\nfunc (p *Person) GetAncestors() []string {\n\treturn p.ancestors\n}\n\n// GetDescendants returns the list of descendants\nfunc (p *Person) GetDescendants() []string {\n\treturn p.descendants\n}\n\n// RoyalPerson represents a person with royal lineage\ntype RoyalPerson struct {\n\tPerson\n\thistoricalAncestors  []string\n\thistoricalDescendants []string\n}\n\n// NewRoyalPerson creates a new royal person with a name\nfunc NewRoyalPerson(name string) *RoyalPerson {\n\treturn &RoyalPerson{Person: *NewPerson(name)}\n}\n\n// AddHistoricalAncestor adds a historical ancestor to the royal person\nfunc (rp *RoyalPerson) AddHistoricalAncestor(ancestor string) {\n\trp.historicalAncestors = append(rp.historicalAncestors, ancestor)\n}\n\n// AddHistoricalDescendant adds a historical descendant to the royal person\nfunc (rp *RoyalPerson) AddHistoricalDescendant(descendant string) {\n\trp.historicalDescendants = append(rp.historicalDescendants, descendant)\n}\n\n// GetAncestors returns the list of historical ancestors\nfunc (rp *RoyalPerson) GetAncestors() []string {\n\treturn rp.historicalAncestors\n}\n\n// GetDescendants returns the list of historical descendants\nfunc (rp *RoyalPerson) GetDescendants() []string {\n\treturn rp.historicalDescendants\n}\n\nfunc main() {\n\tjohn := NewPerson(\"John\")\n\tjohn.AddAncestor(\"Mary\")\n\tjohn.AddDescendant(\"Sam\")\n\n\tfmt.Println(\"John's ancestors:\", john.GetAncestors())\n\tfmt.Println(\"John's descendants:\", john.GetDescendants())\n\n\tqueen := NewRoyalPerson(\"Queen Elizabeth\")\n\tqueen.AddHistoricalAncestor(\"King George VI\")\n\tqueen.AddHistoricalDescendant(\"Prince Charles\")\n\n\tfmt.Println(\"Queen's historical ancestors:\", queen.GetAncestors())\n\tfmt.Println(\"Queen's historical descendants:\", queen.GetDescendants())\n}\n```"
  },
  {
    "task": "Implement a base class for a musical score with methods for composition and arrangement, then create a symphony subclass that overrides these methods for orchestration.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\ntype MusicalScore interface {\n\tCompose() string\n\tArrange() string\n}\n\ntype BaseScore struct{}\n\nfunc (b BaseScore) Compose() string {\n\treturn \"Composing base musical score\"\n}\n\nfunc (b BaseScore) Arrange() string {\n\treturn \"Arranging base musical score\"\n}\n\ntype Symphony struct {\n\tBaseScore\n}\n\nfunc (s Symphony) Compose() string {\n\treturn \"Composing symphony orchestration\"\n}\n\nfunc (s Symphony) Arrange() string {\n\treturn \"Arranging symphony orchestration\"\n}\n\nfunc main() {\n\tvar score MusicalScore\n\n\tscore = BaseScore{}\n\tfmt.Println(score.Compose())\n\tfmt.Println(score.Arrange())\n\n\tscore = Symphony{}\n\tfmt.Println(score.Compose())\n\tfmt.Println(score.Arrange())\n}\n```"
  },
  {
    "task": "Construct a parent class for a historical record with methods for events and dates, then derive a war history class that overrides these methods for battles.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\ntype HistoricalRecord struct {\n\tevent string\n\tdate  string\n}\n\nfunc (hr *HistoricalRecord) SetEvent(event string) {\n\thr.event = event\n}\n\nfunc (hr *HistoricalRecord) SetDate(date string) {\n\thr.date = date\n}\n\nfunc (hr *HistoricalRecord) GetEvent() string {\n\treturn hr.event\n}\n\nfunc (hr *HistoricalRecord) GetDate() string {\n\treturn hr.date\n}\n\ntype WarHistory struct {\n\tHistoricalRecord\n}\n\nfunc (wh *WarHistory) SetEvent(battle string) {\n\twh.event = \"Battle of \" + battle\n}\n\nfunc main() {\n\thistory := HistoricalRecord{}\n\thistory.SetEvent(\"Moon Landing\")\n\thistory.SetDate(\"1969-07-20\")\n\n\twar := WarHistory{}\n\twar.SetEvent(\"Waterloo\")\n\twar.SetDate(\"1815-06-18\")\n\n\tfmt.Println(\"Historical Event:\", history.GetEvent(), \"on\", history.GetDate())\n\tfmt.Println(\"War History Event:\", war.GetEvent(), \"on\", war.GetDate())\n}\n```"
  },
  {
    "task": "Set up a base class for a pet adoption service with methods for application and approval, and extend it with a dog adoption subclass that overrides these methods for breed compatibility.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\ntype PetAdoptionService interface {\n\tApply()\n\tApprove()\n}\n\ntype BasePetAdoption struct{}\n\nfunc (b *BasePetAdoption) Apply() {\n\tfmt.Println(\"Application submitted for pet adoption.\")\n}\n\nfunc (b *BasePetAdoption) Approve() {\n\tfmt.Println(\"Application approved for pet adoption.\")\n}\n\ntype DogAdoption struct {\n\tBasePetAdoption\n}\n\nfunc (d *DogAdoption) Apply() {\n\tfmt.Println(\"Application submitted for dog adoption with breed preferences.\")\n}\n\nfunc (d *DogAdoption) Approve() {\n\tfmt.Println(\"Dog adoption approved with breed compatibility check.\")\n}\n\nfunc main() {\n\tvar petAdoption PetAdoptionService\n\n\tpetAdoption = &BasePetAdoption{}\n\tpetAdoption.Apply()\n\tpetAdoption.Approve()\n\n\tpetAdoption = &DogAdoption{}\n\tpetAdoption.Apply()\n\tpetAdoption.Approve()\n}\n```"
  },
  {
    "task": "Create a foundational class for a financial report with properties like fiscal year and summary, and derive an annual report class that overrides the fiscal year property for yearly data.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Base class for a financial report\ntype FinancialReport struct {\n\tFiscalYear string\n\tSummary    string\n}\n\n// Derived class for an annual report\ntype AnnualReport struct {\n\tFinancialReport\n}\n\n// Override the FiscalYear property for the annual report\nfunc (a *AnnualReport) SetFiscalYear(year string) {\n\ta.FiscalYear = year\n}\n\nfunc main() {\n\tannualReport := AnnualReport{}\n\tannualReport.SetFiscalYear(\"2023\")\n\tannualReport.Summary = \"Annual financial performance overview.\"\n\n\tfmt.Printf(\"Annual Report - Fiscal Year: %s, Summary: %s\\n\", annualReport.FiscalYear, annualReport.Summary)\n}\n```"
  },
  {
    "task": "Design a base class for a movie franchise with methods for casting and production, then create a sequel subclass that overrides these methods for continuity.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Base class\ntype MovieFranchise struct {\n\ttitle     string\n\tcast      []string\n\tproduction string\n}\n\nfunc (m *MovieFranchise) Cast() string {\n\treturn fmt.Sprintf(\"Casting for %s: %v\", m.title, m.cast)\n}\n\nfunc (m *MovieFranchise) Production() string {\n\treturn fmt.Sprintf(\"Production details for %s: %s\", m.title, m.production)\n}\n\n// Sequel subclass\ntype MovieSequel struct {\n\tMovieFranchise\n}\n\nfunc (s *MovieSequel) Cast() string {\n\treturn fmt.Sprintf(\"Sequel casting for %s: %v\", s.title, s.cast)\n}\n\nfunc (s *MovieSequel) Production() string {\n\treturn fmt.Sprintf(\"Sequel production details for %s: %s\", s.title, s.production)\n}\n\nfunc main() {\n\tbaseMovie := MovieFranchise{\n\t\ttitle:     \"Original Movie\",\n\t\tcast:      []string{\"Actor A\", \"Actor B\"},\n\t\tproduction: \"Original Production Co.\",\n\t}\n\n\tsequelMovie := MovieSequel{\n\t\tMovieFranchise: MovieFranchise{\n\t\t\ttitle:     \"Sequel Movie\",\n\t\t\tcast:      []string{\"Actor A\", \"Actor C\"},\n\t\t\tproduction: \"Sequel Production Co.\",\n\t\t},\n\t}\n\n\tfmt.Println(baseMovie.Cast())\n\tfmt.Println(baseMovie.Production())\n\tfmt.Println(sequelMovie.Cast())\n\tfmt.Println(sequelMovie.Production())\n}\n```"
  },
  {
    "task": "Develop a superclass for a real estate listing with methods for pricing and description, then extend it with a luxury listing subclass that overrides these methods for high-end features.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\ntype RealEstateListing struct {\n\tAddress string\n\tPrice   float64\n}\n\nfunc (r RealEstateListing) Pricing() string {\n\treturn fmt.Sprintf(\"The price is $%.2f\", r.Price)\n}\n\nfunc (r RealEstateListing) Description() string {\n\treturn fmt.Sprintf(\"Real estate listing at %s\", r.Address)\n}\n\ntype LuxuryListing struct {\n\tRealEstateListing\n}\n\nfunc (l LuxuryListing) Pricing() string {\n\treturn fmt.Sprintf(\"The luxury price is $%.2f\", l.Price*1.2)\n}\n\nfunc (l LuxuryListing) Description() string {\n\treturn fmt.Sprintf(\"Luxury real estate listing at %s with high-end features\", l.Address)\n}\n\nfunc main() {\n\tbasicListing := RealEstateListing{\"123 Main St\", 300000}\n\tluxuryListing := LuxuryListing{RealEstateListing{\"456 Luxury Ave\", 500000}}\n\n\tfmt.Println(basicListing.Pricing())\n\tfmt.Println(basicListing.Description())\n\tfmt.Println(luxuryListing.Pricing())\n\tfmt.Println(luxuryListing.Description())\n}\n```"
  },
  {
    "task": "Implement a base class for a mobile app with methods for user interface and performance, then create a gaming app subclass that overrides these methods for graphics and speed.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Base class for a mobile app\ntype MobileApp struct{}\n\nfunc (app *MobileApp) UserInterface() {\n\tfmt.Println(\"Standard user interface\")\n}\n\nfunc (app *MobileApp) Performance() {\n\tfmt.Println(\"Standard performance\")\n}\n\n// Subclass for a gaming app\ntype GamingApp struct {\n\tMobileApp\n}\n\nfunc (gameApp *GamingApp) UserInterface() {\n\tfmt.Println(\"Advanced graphics user interface\")\n}\n\nfunc (gameApp *GamingApp) Performance() {\n\tfmt.Println(\"High-speed performance\")\n}\n\nfunc main() {\n\tapp := MobileApp{}\n\tgameApp := GamingApp{}\n\n\tfmt.Println(\"Mobile App:\")\n\tapp.UserInterface()\n\tapp.Performance()\n\n\tfmt.Println(\"\\nGaming App:\")\n\tgameApp.UserInterface()\n\tgameApp.Performance()\n}\n```"
  },
  {
    "task": "Construct a parent class for a corporate policy with methods for compliance and enforcement, then derive an HR policy class that overrides these methods for employee relations.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Parent class for a corporate policy\ntype CorporatePolicy struct{}\n\nfunc (cp *CorporatePolicy) Compliance() string {\n\treturn \"Corporate compliance guidelines.\"\n}\n\nfunc (cp *CorporatePolicy) Enforcement() string {\n\treturn \"Corporate enforcement procedures.\"\n}\n\n// Derived HR policy class\ntype HRPolicy struct {\n\tCorporatePolicy\n}\n\nfunc (hrp *HRPolicy) Compliance() string {\n\treturn \"HR compliance guidelines for employee relations.\"\n}\n\nfunc (hrp *HRPolicy) Enforcement() string {\n\treturn \"HR enforcement procedures for employee relations.\"\n}\n\nfunc main() {\n\tcorpPolicy := CorporatePolicy{}\n\thrPolicy := HRPolicy{}\n\n\tfmt.Println(\"Corporate Policy Compliance:\", corpPolicy.Compliance())\n\tfmt.Println(\"Corporate Policy Enforcement:\", corpPolicy.Enforcement())\n\tfmt.Println(\"HR Policy Compliance:\", hrPolicy.Compliance())\n\tfmt.Println(\"HR Policy Enforcement:\", hrPolicy.Enforcement())\n}\n```"
  },
  {
    "task": "Set up a base class for a scientific calculator with methods for basic operations and advanced functions, and extend it with a graphing calculator subclass that overrides these methods for plotting.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype ScientificCalculator struct{}\n\nfunc (sc ScientificCalculator) Add(a, b float64) float64 {\n\treturn a + b\n}\n\nfunc (sc ScientificCalculator) Subtract(a, b float64) float64 {\n\treturn a - b\n}\n\nfunc (sc ScientificCalculator) Multiply(a, b float64) float64 {\n\treturn a * b\n}\n\nfunc (sc ScientificCalculator) Divide(a, b float64) float64 {\n\tif b != 0 {\n\t\treturn a / b\n\t}\n\treturn math.NaN()\n}\n\nfunc (sc ScientificCalculator) Sin(x float64) float64 {\n\treturn math.Sin(x)\n}\n\nfunc (sc ScientificCalculator) Cos(x float64) float64 {\n\treturn math.Cos(x)\n}\n\ntype GraphingCalculator struct {\n\tScientificCalculator\n}\n\nfunc (gc GraphingCalculator) Add(a, b float64) float64 {\n\tfmt.Println(\"Plotting addition on graph...\")\n\treturn a + b\n}\n\nfunc (gc GraphingCalculator) Subtract(a, b float64) float64 {\n\tfmt.Println(\"Plotting subtraction on graph...\")\n\treturn a - b\n}\n\nfunc (gc GraphingCalculator) Multiply(a, b float64) float64 {\n\tfmt.Println(\"Plotting multiplication on graph...\")\n\treturn a * b\n}\n\nfunc (gc GraphingCalculator) Divide(a, b float64) float64 {\n\tfmt.Println(\"Plotting division on graph...\")\n\tif b != 0 {\n\t\treturn a / b\n\t}\n\treturn math.NaN()\n}\n\nfunc (gc GraphingCalculator) Sin(x float64) float64 {\n\tfmt.Println(\"Plotting sin on graph...\")\n\treturn math.Sin(x)\n}\n\nfunc (gc GraphingCalculator) Cos(x float64) float64 {\n\tfmt.Println(\"Plotting cos on graph...\")\n\treturn math.Cos(x)\n}\n\nfunc main() {\n\tgc := GraphingCalculator{}\n\tfmt.Println(gc.Add(1, 2))\n\tfmt.Println(gc.Sin(math.Pi / 2))\n}\n```"
  },
  {
    "task": "Create a foundational class for a children's book with properties like age group and illustrations, and derive a picture book class that overrides the illustrations property to be more prominent.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\ntype ChildrenBook struct {\n\tAgeGroup     string\n\tIllustrations string\n}\n\nfunc (cb ChildrenBook) Describe() {\n\tfmt.Printf(\"Age Group: %s, Illustrations: %s\\n\", cb.AgeGroup, cb.Illustrations)\n}\n\ntype PictureBook struct {\n\tChildrenBook\n}\n\nfunc (pb PictureBook) Describe() {\n\tfmt.Printf(\"Age Group: %s, Illustrations: %s (prominent)\\n\", pb.AgeGroup, pb.Illustrations)\n}\n\nfunc main() {\n\tcb := ChildrenBook{\n\t\tAgeGroup:     \"5-7\",\n\t\tIllustrations: \"basic\",\n\t}\n\tcb.Describe()\n\n\tpb := PictureBook{\n\t\tChildrenBook: ChildrenBook{\n\t\t\tAgeGroup:     \"5-7\",\n\t\t\tIllustrations: \"detailed\",\n\t\t},\n\t}\n\tpb.Describe()\n}\n```"
  },
  {
    "task": "Design a base class for a cooking class with methods for ingredients and techniques, then create a baking class subclass that overrides these methods for dough preparation.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\ntype CookingClass interface {\n\tIngredients() string\n\tTechniques() string\n}\n\ntype BaseCookingClass struct{}\n\nfunc (b BaseCookingClass) Ingredients() string {\n\treturn \"Generic ingredients\"\n}\n\nfunc (b BaseCookingClass) Techniques() string {\n\treturn \"Generic techniques\"\n}\n\ntype BakingClass struct {\n\tBaseCookingClass\n}\n\nfunc (b BakingClass) Ingredients() string {\n\treturn \"Flour, water, yeast, salt\"\n}\n\nfunc (b BakingClass) Techniques() string {\n\treturn \"Mixing, kneading, proofing, baking\"\n}\n\nfunc main() {\n\tvar class CookingClass\n\n\tclass = BaseCookingClass{}\n\tfmt.Println(\"Base Cooking Class:\")\n\tfmt.Println(\"Ingredients:\", class.Ingredients())\n\tfmt.Println(\"Techniques:\", class.Techniques())\n\n\tclass = BakingClass{}\n\tfmt.Println(\"\\nBaking Class:\")\n\tfmt.Println(\"Ingredients:\", class.Ingredients())\n\tfmt.Println(\"Techniques:\", class.Techniques())\n}\n```"
  },
  {
    "task": "Develop a superclass for a public transportation system with methods for routes and schedules, then extend it with a metro system subclass that overrides these methods for urban areas.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Superclass\ntype PublicTransport struct{}\n\nfunc (pt *PublicTransport) Routes() string {\n\treturn \"General routes for public transport.\"\n}\n\nfunc (pt *PublicTransport) Schedules() string {\n\treturn \"General schedules for public transport.\"\n}\n\n// Subclass\ntype MetroSystem struct {\n\tPublicTransport\n}\n\nfunc (ms *MetroSystem) Routes() string {\n\treturn \"Specific metro routes for urban areas.\"\n}\n\nfunc (ms *MetroSystem) Schedules() string {\n\treturn \"Specific metro schedules for urban areas.\"\n}\n\nfunc main() {\n\ttransport := PublicTransport{}\n\tmetro := MetroSystem{}\n\n\tfmt.Println(\"Public Transport Routes:\", transport.Routes())\n\tfmt.Println(\"Public Transport Schedules:\", transport.Schedules())\n\n\tfmt.Println(\"Metro System Routes:\", metro.Routes())\n\tfmt.Println(\"Metro System Schedules:\", metro.Schedules())\n}\n```"
  },
  {
    "task": "Implement a base class for a music store inventory with methods for stock and sales, then create a vinyl record subclass that overrides these methods for collectible items.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Base class for music store inventory\ntype InventoryItem struct {\n\tName  string\n\tStock int\n\tSales int\n}\n\nfunc (item *InventoryItem) AddStock(amount int) {\n\titem.Stock += amount\n}\n\nfunc (item *InventoryItem) Sell(amount int) {\n\tif amount <= item.Stock {\n\t\titem.Stock -= amount\n\t\titem.Sales += amount\n\t} else {\n\t\tfmt.Println(\"Not enough stock to sell\")\n\t}\n}\n\n// VinylRecord subclass\ntype VinylRecord struct {\n\tInventoryItem\n}\n\nfunc (record *VinylRecord) AddStock(amount int) {\n\tfmt.Println(\"Cannot add stock to collectible item\")\n}\n\nfunc (record *VinylRecord) Sell(amount int) {\n\tif amount <= record.Stock {\n\t\trecord.Stock -= amount\n\t\trecord.Sales += amount\n\t\tfmt.Println(\"Sold collectible item\")\n\t} else {\n\t\tfmt.Println(\"Not enough stock to sell collectible item\")\n\t}\n}\n\nfunc main() {\n\titem := InventoryItem{Name: \"CD\", Stock: 100, Sales: 0}\n\titem.AddStock(50)\n\titem.Sell(30)\n\tfmt.Printf(\"CD Stock: %d, Sales: %d\\n\", item.Stock, item.Sales)\n\n\trecord := VinylRecord{InventoryItem{Name: \"Vinyl\", Stock: 10, Sales: 0}}\n\trecord.AddStock(5)\n\trecord.Sell(5)\n\tfmt.Printf(\"Vinyl Stock: %d, Sales: %d\\n\", record.Stock, record.Sales)\n}\n```"
  },
  {
    "task": "Construct a parent class for a legal contract with methods for terms and conditions, then derive a rental agreement class that overrides these methods for tenant rights.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// LegalContract is the parent class with methods for terms and conditions.\ntype LegalContract struct{}\n\nfunc (lc LegalContract) Terms() string {\n\treturn \"General terms of the contract.\"\n}\n\nfunc (lc LegalContract) Conditions() string {\n\treturn \"General conditions of the contract.\"\n}\n\n// RentalAgreement is the derived class that overrides methods for tenant rights.\ntype RentalAgreement struct {\n\tLegalContract\n}\n\nfunc (ra RentalAgreement) Terms() string {\n\treturn \"Rental agreement terms including tenant rights.\"\n}\n\nfunc (ra RentalAgreement) Conditions() string {\n\treturn \"Rental agreement conditions including tenant rights.\"\n}\n\nfunc main() {\n\tcontract := LegalContract{}\n\trental := RentalAgreement{}\n\n\tfmt.Println(\"Contract Terms:\", contract.Terms())\n\tfmt.Println(\"Contract Conditions:\", contract.Conditions())\n\tfmt.Println(\"Rental Terms:\", rental.Terms())\n\tfmt.Println(\"Rental Conditions:\", rental.Conditions())\n}\n```"
  },
  {
    "task": "Set up a base class for a journalism piece with methods for reporting and editing, and extend it with an investigative article subclass that overrides these methods for in-depth analysis.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Base class for a journalism piece\ntype JournalismPiece struct{}\n\nfunc (jp *JournalismPiece) Report() {\n\tfmt.Println(\"Reporting the news...\")\n}\n\nfunc (jp *JournalismPiece) Edit() {\n\tfmt.Println(\"Editing the article...\")\n}\n\n// Subclass for an investigative article\ntype InvestigativeArticle struct {\n\tJournalismPiece\n}\n\nfunc (ia *InvestigativeArticle) Report() {\n\tfmt.Println(\"Reporting in-depth analysis...\")\n}\n\nfunc (ia *InvestigativeArticle) Edit() {\n\tfmt.Println(\"Editing with a focus on detail...\")\n}\n\nfunc main() {\n\tarticle := JournalismPiece{}\n\tarticle.Report()\n\tarticle.Edit()\n\n\tinvestigativeArticle := InvestigativeArticle{}\n\tinvestigativeArticle.Report()\n\tinvestigativeArticle.Edit()\n}\n```"
  },
  {
    "task": "Create a foundational class for a wildlife reserve with properties like area and species, and derive a bird sanctuary class that overrides the species property for avians.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\ntype WildlifeReserve struct {\n\tArea    float64\n\tSpecies string\n}\n\ntype BirdSanctuary struct {\n\tWildlifeReserve\n}\n\nfunc (b *BirdSanctuary) SetSpeciesForAvians() {\n\tb.Species = \"Avians\"\n}\n\nfunc main() {\n\treserve := WildlifeReserve{Area: 1000.0, Species: \"Various\"}\n\tbirdSanctuary := BirdSanctuary{WildlifeReserve: reserve}\n\tbirdSanctuary.SetSpeciesForAvians()\n\n\tfmt.Printf(\"Bird Sanctuary Area: %.2f, Species: %s\\n\", birdSanctuary.Area, birdSanctuary.Species)\n}\n```"
  },
  {
    "task": "Design a base class for a subscription box service with methods for curation and delivery, then create a gourmet food box subclass that overrides these methods for artisanal products.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// SubscriptionBox is the base class\ntype SubscriptionBox struct{}\n\nfunc (s *SubscriptionBox) Curation() string {\n\treturn \"Curating general items for the box.\"\n}\n\nfunc (s *SubscriptionBox) Delivery() string {\n\treturn \"Delivering the subscription box.\"\n}\n\n// GourmetFoodBox is a subclass that inherits from SubscriptionBox\ntype GourmetFoodBox struct {\n\tSubscriptionBox\n}\n\nfunc (g *GourmetFoodBox) Curation() string {\n\treturn \"Curating artisanal gourmet food items for the box.\"\n}\n\nfunc (g *GourmetFoodBox) Delivery() string {\n\treturn \"Delivering the gourmet food subscription box.\"\n}\n\nfunc main() {\n\tbaseBox := SubscriptionBox{}\n\tgourmetBox := GourmetFoodBox{}\n\n\tfmt.Println(baseBox.Curation())\n\tfmt.Println(baseBox.Delivery())\n\n\tfmt.Println(gourmetBox.Curation())\n\tfmt.Println(gourmetBox.Delivery())\n}\n```"
  },
  {
    "task": "Develop a superclass for a fitness app with methods for tracking and motivation, then extend it with a running app subclass that overrides these methods for pace and distance.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Superclass\ntype FitnessApp struct{}\n\nfunc (f *FitnessApp) Track() {\n\tfmt.Println(\"Tracking general fitness activities.\")\n}\n\nfunc (f *FitnessApp) Motivate() {\n\tfmt.Println(\"Stay motivated and keep up the good work!\")\n}\n\n// Subclass\ntype RunningApp struct {\n\tFitnessApp\n}\n\nfunc (r *RunningApp) Track() {\n\tfmt.Println(\"Tracking running pace and distance.\")\n}\n\nfunc (r *RunningApp) Motivate() {\n\tfmt.Println(\"Push harder and improve your running times!\")\n}\n\nfunc main() {\n\tfitnessApp := &FitnessApp{}\n\tfitnessApp.Track()\n\tfitnessApp.Motivate()\n\n\trunningApp := &RunningApp{}\n\trunningApp.Track()\n\trunningApp.Motivate()\n}\n```"
  },
  {
    "task": "Implement a base class for a digital portfolio with methods for showcasing and updating, then create an artist portfolio subclass that overrides these methods for galleries.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Base class for a digital portfolio\ntype DigitalPortfolio struct{}\n\nfunc (dp *DigitalPortfolio) Showcase() {\n\tfmt.Println(\"Showcasing digital portfolio.\")\n}\n\nfunc (dp *DigitalPortfolio) Update() {\n\tfmt.Println(\"Updating digital portfolio.\")\n}\n\n// Subclass for an artist portfolio\ntype ArtistPortfolio struct {\n\tDigitalPortfolio\n}\n\nfunc (ap *ArtistPortfolio) Showcase() {\n\tfmt.Println(\"Showcasing artist portfolio gallery.\")\n}\n\nfunc (ap *ArtistPortfolio) Update() {\n\tfmt.Println(\"Updating artist portfolio gallery.\")\n}\n\nfunc main() {\n\t// Example usage\n\tartistPortfolio := ArtistPortfolio{}\n\tartistPortfolio.Showcase()\n\tartistPortfolio.Update()\n}\n```"
  },
  {
    "task": "Construct a parent class for a gaming console with methods for performance and compatibility, then derive a next-gen console class that overrides these methods for new features.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\ntype GamingConsole interface {\n\tPerformance() string\n\tCompatibility() string\n}\n\ntype Console struct{}\n\nfunc (c *Console) Performance() string {\n\treturn \"Standard performance\"\n}\n\nfunc (c *Console) Compatibility() string {\n\treturn \"Compatible with current games\"\n}\n\ntype NextGenConsole struct {\n\tConsole\n}\n\nfunc (ngc *NextGenConsole) Performance() string {\n\treturn \"Enhanced performance with ray tracing\"\n}\n\nfunc (ngc *NextGenConsole) Compatibility() string {\n\treturn \"Compatible with current and next-gen games\"\n}\n\nfunc main() {\n\tvar console GamingConsole = &Console{}\n\tfmt.Println(console.Performance())\n\tfmt.Println(console.Compatibility())\n\n\tconsole = &NextGenConsole{}\n\tfmt.Println(console.Performance())\n\tfmt.Println(console.Compatibility())\n}\n```"
  },
  {
    "task": "Set up a base class for a cultural festival with methods for events and participation, and extend it with a music festival subclass that overrides these methods for performances.",
    "code": "```go\npackage main\n\nimport \"fmt\"\n\n// Base class\ntype CulturalFestival struct{}\n\nfunc (cf *CulturalFestival) Events() {\n\tfmt.Println(\"General cultural festival events.\")\n}\n\nfunc (cf *CulturalFestival) Participation() {\n\tfmt.Println(\"Participation in general cultural activities.\")\n}\n\n// Subclass\ntype MusicFestival struct {\n\tCulturalFestival\n}\n\nfunc (mf *MusicFestival) Events() {\n\tfmt.Println(\"Music festival events and performances.\")\n}\n\nfunc (mf *MusicFestival) Participation() {\n\tfmt.Println(\"Participation in music performances.\")\n}\n\nfunc main() {\n\tvar festival CulturalFestival\n\tfestival.Events()\n\tfestival.Participation()\n\n\tvar musicFest MusicFestival\n\tmusicFest.Events()\n\tmusicFest.Participation()\n}\n```"
  }
]