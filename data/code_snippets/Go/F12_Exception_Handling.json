[
  {
    "task": "Write a function that reads a file and handles the exception if the file is not found.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc readFile(filename string) {\n\tfile, err := os.Open(filename)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\tfmt.Println(\"File not found:\", filename)\n\t\t} else {\n\t\t\tfmt.Println(\"Error opening file:\", err)\n\t\t}\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\t// Process the file (omitted)\n\tfmt.Println(\"File opened successfully:\", filename)\n}\n\nfunc main() {\n\treadFile(\"example.txt\")\n}\n```"
  },
  {
    "task": "Create a program that divides two numbers and catches any division by zero errors.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc divide(a, b float64) (float64, error) {\n\tif b == 0 {\n\t\treturn 0, errors.New(\"division by zero\")\n\t}\n\treturn a / b, nil\n}\n\nfunc main() {\n\tnumerator := 10.0\n\tdenominator := 0.0\n\n\tresult, err := divide(numerator, denominator)\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t} else {\n\t\tfmt.Println(\"Result:\", result)\n\t}\n}\n```"
  },
  {
    "task": "Design a function to parse an integer from a string and manage invalid input exceptions.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n)\n\nfunc parseInteger(input string) (int, error) {\n\tvalue, err := strconv.Atoi(input)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"invalid input: %v\", err)\n\t}\n\treturn value, nil\n}\n\nfunc main() {\n\tinput := \"123\"\n\tif result, err := parseInteger(input); err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t} else {\n\t\tfmt.Println(\"Parsed integer:\", result)\n\t}\n\n\tinvalidInput := \"abc\"\n\tif result, err := parseInteger(invalidInput); err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t} else {\n\t\tfmt.Println(\"Parsed integer:\", result)\n\t}\n}\n```"
  },
  {
    "task": "Implement an API call and catch exceptions related to network errors or timeouts.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\nfunc main() {\n\turl := \"https://api.example.com/data\"\n\tclient := &http.Client{\n\t\tTimeout: 5 * time.Second,\n\t}\n\n\tresp, err := client.Get(url)\n\tif err != nil {\n\t\tif e, ok := err.(net.Error); ok && e.Timeout() {\n\t\t\tfmt.Println(\"Request timed out\")\n\t\t} else {\n\t\t\tfmt.Println(\"Network error:\", err)\n\t\t}\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\tfmt.Println(\"Unexpected status code:\", resp.StatusCode)\n\t\treturn\n\t}\n\n\tfmt.Println(\"API call successful\")\n}\n```"
  },
  {
    "task": "Develop a program that opens a database connection and handles any connection failure exceptions.",
    "code": "```go\npackage main\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"log\"\n\n\t_ \"github.com/lib/pq\"\n)\n\nfunc main() {\n\tconnStr := \"user=username dbname=mydb sslmode=disable\"\n\tdb, err := sql.Open(\"postgres\", connStr)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to open a DB connection: %v\", err)\n\t}\n\tdefer func() {\n\t\tif cerr := db.Close(); cerr != nil {\n\t\t\tlog.Printf(\"Failed to close DB connection: %v\", cerr)\n\t\t}\n\t}()\n\n\terr = db.Ping()\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to connect to the database: %v\", err)\n\t}\n\n\tfmt.Println(\"Database connection successful\")\n}\n```"
  },
  {
    "task": "Write a function that accesses an array by index and catches out-of-bounds exceptions.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc accessArrayElement(arr []int, index int) {\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tfmt.Println(\"Exception caught:\", r)\n\t\t}\n\t}()\n\t\n\tfmt.Println(\"Accessing element:\", arr[index])\n}\n\nfunc main() {\n\tarr := []int{1, 2, 3, 4, 5}\n\taccessArrayElement(arr, 2) // Valid index\n\taccessArrayElement(arr, 10) // Out-of-bounds index\n}\n```"
  },
  {
    "task": "Create a function that converts a string to a date object and manages format exceptions.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc stringToDate(dateStr string) (time.Time, error) {\n\tlayout := \"2006-01-02\"\n\tdate, err := time.Parse(layout, dateStr)\n\tif err != nil {\n\t\treturn time.Time{}, fmt.Errorf(\"failed to parse date: %w\", err)\n\t}\n\treturn date, nil\n}\n\nfunc main() {\n\tdateStr := \"2023-10-10\"\n\tdate, err := stringToDate(dateStr)\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t} else {\n\t\tfmt.Println(\"Parsed Date:\", date)\n\t}\n}\n```"
  },
  {
    "task": "Design a program that writes data to a file and catches any file permission exceptions.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc main() {\n\tfile, err := os.Create(\"/path/to/file.txt\")\n\tif err != nil {\n\t\tfmt.Println(\"Error creating file:\", err)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\t_, err = file.WriteString(\"Hello, World!\")\n\tif err != nil {\n\t\tfmt.Println(\"Error writing to file:\", err)\n\t}\n}\n```"
  },
  {
    "task": "Implement a module that retrieves data from a URL and handles malformed URL exceptions.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n)\n\nfunc fetchDataFromURL(urlStr string) {\n\t_, err := url.ParseRequestURI(urlStr)\n\tif err != nil {\n\t\tfmt.Println(\"Malformed URL:\", err)\n\t\treturn\n\t}\n\n\tresp, err := http.Get(urlStr)\n\tif err != nil {\n\t\tfmt.Println(\"Error fetching data:\", err)\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\n\tfmt.Println(\"Data retrieved from URL:\", urlStr)\n}\n\nfunc main() {\n\turlStr := \"http://example.com\"\n\tfetchDataFromURL(urlStr)\n}\n```"
  },
  {
    "task": "Write a function to calculate the square root of a number and catch any negative input exceptions.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc calculateSquareRoot(number float64) (float64, error) {\n\tif number < 0 {\n\t\treturn 0, errors.New(\"cannot calculate square root of a negative number\")\n\t}\n\treturn math.Sqrt(number), nil\n}\n\nfunc main() {\n\tnumber := -4.0\n\tresult, err := calculateSquareRoot(number)\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t} else {\n\t\tfmt.Printf(\"The square root of %.2f is %.2f\\n\", number, result)\n\t}\n}\n```"
  },
  {
    "task": "Develop a program that sends an email and manages exceptions for invalid email addresses.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"net/mail\"\n)\n\nfunc sendEmail(email string) error {\n\t_, err := mail.ParseAddress(email)\n\tif err != nil {\n\t\treturn errors.New(\"invalid email address\")\n\t}\n\n\t// Simulate sending email\n\tfmt.Println(\"Email sent to:\", email)\n\treturn nil\n}\n\nfunc main() {\n\temail := \"example@domain.com\"\n\n\terr := sendEmail(email)\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t} else {\n\t\tfmt.Println(\"Email sent successfully\")\n\t}\n}\n```"
  },
  {
    "task": "Create a calculator application that handles invalid operations gracefully.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc calculator(op string, a, b float64) (float64, error) {\n\tswitch op {\n\tcase \"+\":\n\t\treturn a + b, nil\n\tcase \"-\":\n\t\treturn a - b, nil\n\tcase \"*\":\n\t\treturn a * b, nil\n\tcase \"/\":\n\t\tif b == 0 {\n\t\t\treturn 0, errors.New(\"division by zero\")\n\t\t}\n\t\treturn a / b, nil\n\tdefault:\n\t\treturn 0, errors.New(\"invalid operation\")\n\t}\n}\n\nfunc main() {\n\toperations := []struct {\n\t\top    string\n\t\ta, b  float64\n\t}{\n\t\t{\"+\", 4, 2},\n\t\t{\"-\", 4, 2},\n\t\t{\"*\", 4, 2},\n\t\t{\"/\", 4, 0},\n\t\t{\"^\", 4, 2},\n\t}\n\n\tfor _, operation := range operations {\n\t\tresult, err := calculator(operation.op, operation.a, operation.b)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t\t} else {\n\t\t\tfmt.Printf(\"Result of %v %s %v = %v\\n\", operation.a, operation.op, operation.b, result)\n\t\t}\n\t}\n}\n```"
  },
  {
    "task": "Design a function that tries to parse JSON data and catches parsing errors.",
    "code": "```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n)\n\nfunc parseJSON(data string) error {\n\tvar result map[string]interface{}\n\terr := json.Unmarshal([]byte(data), &result)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to parse JSON: %w\", err)\n\t}\n\tfmt.Println(\"Parsed JSON:\", result)\n\treturn nil\n}\n\nfunc main() {\n\tjsonData := `{\"name\": \"John\", \"age\": 30}`\n\terr := parseJSON(jsonData)\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t} else {\n\t\tfmt.Println(\"JSON parsed successfully\")\n\t}\n}\n```"
  },
  {
    "task": "Implement a system that processes user input and handles any type conversion exceptions.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n)\n\nfunc main() {\n\tvar input string\n\tfmt.Print(\"Enter a number: \")\n\tfmt.Scanln(&input)\n\n\tif number, err := strconv.Atoi(input); err != nil {\n\t\tfmt.Println(\"Error: Invalid input, please enter a valid number.\")\n\t} else {\n\t\tfmt.Printf(\"You entered: %d\\n\", number)\n\t}\n}\n```"
  },
  {
    "task": "Write a function that fetches data from a database and manages exceptions for missing records.",
    "code": "```go\npackage main\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"log\"\n\n\t_ \"github.com/lib/pq\"\n)\n\nfunc fetchDataFromDB(db *sql.DB, query string) (string, error) {\n\tvar result string\n\n\terr := db.QueryRow(query).Scan(&result)\n\tif err != nil {\n\t\tif err == sql.ErrNoRows {\n\t\t\treturn \"\", fmt.Errorf(\"no records found: %w\", err)\n\t\t}\n\t\treturn \"\", fmt.Errorf(\"failed to fetch data: %w\", err)\n\t}\n\n\treturn result, nil\n}\n\nfunc main() {\n\tconnStr := \"user=username dbname=mydb sslmode=disable\"\n\tdb, err := sql.Open(\"postgres\", connStr)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\tquery := \"SELECT data FROM mytable WHERE id=1\"\n\tdata, err := fetchDataFromDB(db, query)\n\tif err != nil {\n\t\tlog.Println(\"Error:\", err)\n\t} else {\n\t\tfmt.Println(\"Fetched data:\", data)\n\t}\n}\n```"
  },
  {
    "task": "Create a program that connects to a remote server and handles authentication failure exceptions.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc connectToServer() error {\n\t// Simulating an authentication failure\n\treturn errors.New(\"authentication failed\")\n}\n\nfunc main() {\n\terr := connectToServer()\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t}\n}\n```"
  },
  {
    "task": "Develop a function to download a file from the internet and handle file not found exceptions.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n)\n\nfunc downloadFile(url string, filepath string) error {\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to make request: %v\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode == http.StatusNotFound {\n\t\treturn fmt.Errorf(\"file not found at url: %s\", url)\n\t}\n\n\tfile, err := os.Create(filepath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create file: %v\", err)\n\t}\n\tdefer file.Close()\n\n\t_, err = io.Copy(file, resp.Body)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to write file: %v\", err)\n\t}\n\n\treturn nil\n}\n\nfunc main() {\n\turl := \"http://example.com/file.txt\"\n\tfilepath := \"file.txt\"\n\n\terr := downloadFile(url, filepath)\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t} else {\n\t\tfmt.Println(\"File downloaded successfully\")\n\t}\n}\n```"
  },
  {
    "task": "Design a program that attempts to connect to an API and handles rate limit exceptions.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\nfunc main() {\n\turl := \"https://api.example.com/data\"\n\tfor {\n\t\terr := connectToAPI(url)\n\t\tif err != nil {\n\t\t\tif err == ErrRateLimited {\n\t\t\t\tfmt.Println(\"Rate limit exceeded. Retrying after some time...\")\n\t\t\t\ttime.Sleep(1 * time.Minute)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfmt.Println(\"An error occurred:\", err)\n\t\t\treturn\n\t\t}\n\t\tfmt.Println(\"Connected successfully.\")\n\t\tbreak\n\t}\n}\n\nvar ErrRateLimited = fmt.Errorf(\"rate limit exceeded\")\n\nfunc connectToAPI(url string) error {\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode == http.StatusTooManyRequests {\n\t\treturn ErrRateLimited\n\t}\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn fmt.Errorf(\"unexpected status code: %d\", resp.StatusCode)\n\t}\n\n\treturn nil\n}\n```"
  },
  {
    "task": "Write a function that reads from a configuration file and manages key not found exceptions.",
    "code": "```go\npackage main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n)\n\nfunc ReadConfig(filePath, key string) (string, error) {\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"failed to open file: %v\", err)\n\t}\n\tdefer file.Close()\n\n\tscanner := bufio.NewScanner(file)\n\tfor scanner.Scan() {\n\t\tline := scanner.Text()\n\t\tparts := strings.SplitN(line, \"=\", 2)\n\t\tif len(parts) == 2 && strings.TrimSpace(parts[0]) == key {\n\t\t\treturn strings.TrimSpace(parts[1]), nil\n\t\t}\n\t}\n\n\tif err := scanner.Err(); err != nil {\n\t\treturn \"\", fmt.Errorf(\"error reading file: %v\", err)\n\t}\n\n\treturn \"\", fmt.Errorf(\"key not found: %s\", key)\n}\n\nfunc main() {\n\tvalue, err := ReadConfig(\"config.txt\", \"desiredKey\")\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t} else {\n\t\tfmt.Println(\"Value:\", value)\n\t}\n}\n```"
  },
  {
    "task": "Create an application that processes a list of tasks and catches any task execution exceptions.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"log\"\n)\n\nfunc main() {\n\ttasks := []func() error{\n\t\tfunc() error { return nil },\n\t\tfunc() error { return errors.New(\"Task 2 failed\") },\n\t\tfunc() error { return nil },\n\t\tfunc() error { return errors.New(\"Task 4 failed\") },\n\t}\n\n\tfor i, task := range tasks {\n\t\terr := handleTask(i, task)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Error: %v\\n\", err)\n\t\t}\n\t}\n}\n\nfunc handleTask(index int, task func() error) error {\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tlog.Printf(\"Recovered from panic in task %d: %v\\n\", index, r)\n\t\t}\n\t}()\n\t\n\tif err := task(); err != nil {\n\t\treturn fmt.Errorf(\"task %d: %w\", index, err)\n\t}\n\treturn nil\n}\n```"
  },
  {
    "task": "Implement a program that performs batch processing and handles individual item processing exceptions.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc processItem(item int) error {\n\tif item%2 == 0 {\n\t\treturn errors.New(\"even number error\")\n\t}\n\treturn nil\n}\n\nfunc batchProcess(items []int) {\n\tfor _, item := range items {\n\t\terr := processItem(item)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Error processing item %d: %s\\n\", item, err)\n\t\t} else {\n\t\t\tfmt.Printf(\"Successfully processed item %d\\n\", item)\n\t\t}\n\t}\n}\n\nfunc main() {\n\titems := []int{1, 2, 3, 4, 5}\n\tbatchProcess(items)\n}\n```"
  },
  {
    "task": "Develop a function that performs mathematical operations and catches arithmetic exceptions.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc safeDivide(a, b float64) (float64, error) {\n\tif b == 0 {\n\t\treturn 0, errors.New(\"division by zero\")\n\t}\n\treturn a / b, nil\n}\n\nfunc performOperations(a, b float64, op string) (float64, error) {\n\tswitch op {\n\tcase \"+\":\n\t\treturn a + b, nil\n\tcase \"-\":\n\t\treturn a - b, nil\n\tcase \"*\":\n\t\treturn a * b, nil\n\tcase \"/\":\n\t\treturn safeDivide(a, b)\n\tdefault:\n\t\treturn 0, errors.New(\"unsupported operation\")\n\t}\n}\n\nfunc main() {\n\ta, b := 10.0, 0.0\n\top := \"/\"\n\n\tresult, err := performOperations(a, b, op)\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t} else {\n\t\tfmt.Println(\"Result:\", result)\n\t}\n}\n```"
  },
  {
    "task": "Write a program that logs error messages when exceptions occur during data processing.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n)\n\nfunc processData(data []int) (int, error) {\n\tif len(data) == 0 {\n\t\treturn 0, fmt.Errorf(\"no data to process\")\n\t}\n\tsum := 0\n\tfor _, value := range data {\n\t\tsum += value\n\t}\n\treturn sum, nil\n}\n\nfunc main() {\n\t// Set up logging to a file\n\tlogFile, err := os.OpenFile(\"error.log\", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0666)\n\tif err != nil {\n\t\tfmt.Println(\"Error opening log file:\", err)\n\t\treturn\n\t}\n\tdefer logFile.Close()\n\tlog.SetOutput(logFile)\n\n\tdataSets := [][]int{\n\t\t{1, 2, 3},\n\t\t{},\n\t\t{4, 5, 6},\n\t}\n\n\tfor _, dataSet := range dataSets {\n\t\tresult, err := processData(dataSet)\n\t\tif err != nil {\n\t\t\tlog.Println(\"Error processing data:\", err)\n\t\t} else {\n\t\t\tfmt.Println(\"Processed result:\", result)\n\t\t}\n\t}\n}\n```"
  },
  {
    "task": "Create a script that monitors system resources and handles exceptions when limits are exceeded.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"runtime\"\n\t\"time\"\n)\n\nfunc checkMemoryUsage(limit uint64) error {\n\tvar m runtime.MemStats\n\truntime.ReadMemStats(&m)\n\tif m.Alloc > limit {\n\t\treturn fmt.Errorf(\"memory usage exceeded: %d bytes\", m.Alloc)\n\t}\n\treturn nil\n}\n\nfunc checkCPUUsage(limit float64) error {\n\t// Simulates CPU usage check, replace with actual logic as needed\n\tcpuUsage := 50.0 // Example CPU usage percentage\n\tif cpuUsage > limit {\n\t\treturn fmt.Errorf(\"CPU usage exceeded: %.2f%%\", cpuUsage)\n\t}\n\treturn nil\n}\n\nfunc main() {\n\tmemoryLimit := uint64(100 * 1024 * 1024) // 100 MB\n\tcpuLimit := 80.0                        // 80%\n\n\tfor {\n\t\tif err := checkMemoryUsage(memoryLimit); err != nil {\n\t\t\tlog.Println(\"Error:\", err)\n\t\t\tos.Exit(1)\n\t\t}\n\n\t\tif err := checkCPUUsage(cpuLimit); err != nil {\n\t\t\tlog.Println(\"Error:\", err)\n\t\t\tos.Exit(1)\n\t\t}\n\n\t\tfmt.Println(\"System resources are within limits\")\n\t\ttime.Sleep(5 * time.Second)\n\t}\n}\n```"
  },
  {
    "task": "Design a function that validates user input and manages any format exceptions.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"strconv\"\n)\n\nfunc validateInput(input string) error {\n\t_, err := strconv.Atoi(input)\n\tif err != nil {\n\t\treturn errors.New(\"input is not a valid integer\")\n\t}\n\treturn nil\n}\n\nfunc main() {\n\tinput := \"123a\" // Example input\n\terr := validateInput(input)\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t} else {\n\t\tfmt.Println(\"Input is valid\")\n\t}\n}\n```"
  },
  {
    "task": "Implement a service that interacts with third-party APIs and handles unexpected response exceptions.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\turl := \"https://api.example.com/data\"\n\tdata, err := fetchData(url)\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t} else {\n\t\tfmt.Println(\"Fetched Data:\", data)\n\t}\n}\n\nfunc fetchData(url string) (string, error) {\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\treturn \"\", errors.New(\"failed to connect to the API\")\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn \"\", fmt.Errorf(\"unexpected response status: %d\", resp.StatusCode)\n\t}\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn \"\", errors.New(\"failed to read response body\")\n\t}\n\n\treturn string(body), nil\n}\n```"
  },
  {
    "task": "Write a function that uploads files to a server and handles exceptions for unsupported file types.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc uploadFile(filename string) error {\n\tsupportedFileTypes := map[string]bool{\n\t\t\".jpg\": true,\n\t\t\".png\": true,\n\t\t\".txt\": true,\n\t}\n\n\t// Simulate file extension check\n\text := getFileExtension(filename)\n\tif !supportedFileTypes[ext] {\n\t\treturn errors.New(\"unsupported file type\")\n\t}\n\n\t// Simulate upload process\n\tfmt.Println(\"Uploading\", filename)\n\n\treturn nil\n}\n\nfunc getFileExtension(filename string) string {\n\t// Simulate getting file extension\n\tif len(filename) < 4 {\n\t\treturn \"\"\n\t}\n\treturn filename[len(filename)-4:]\n}\n\nfunc main() {\n\tfiles := []string{\"photo.jpg\", \"document.pdf\", \"notes.txt\"}\n\n\tfor _, file := range files {\n\t\terr := uploadFile(file)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error:\", err)\n\t\t} else {\n\t\t\tfmt.Println(\"Successfully uploaded\", file)\n\t\t}\n\t}\n}\n```"
  },
  {
    "task": "Create a program that simulates network traffic and manages packet loss exceptions.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc simulateNetworkTraffic() error {\n\t// Simulate a random packet loss\n\tif rand.Intn(10) < 3 { // 30% chance of packet loss\n\t\treturn errors.New(\"packet loss occurred\")\n\t}\n\treturn nil\n}\n\nfunc main() {\n\trand.Seed(time.Now().UnixNano())\n\n\tfor i := 0; i < 10; i++ {\n\t\terr := simulateNetworkTraffic()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error:\", err)\n\t\t} else {\n\t\t\tfmt.Println(\"Packet successfully transmitted\")\n\t\t}\n\t\ttime.Sleep(500 * time.Millisecond)\n\t}\n}\n```"
  },
  {
    "task": "Develop a function that processes XML data and catches any structural exceptions.",
    "code": "```go\npackage main\n\nimport (\n\t\"encoding/xml\"\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc processXML(data string) error {\n\tvar result interface{}\n\terr := xml.Unmarshal([]byte(data), &result)\n\tif err != nil {\n\t\treturn errors.New(\"XML processing error: \" + err.Error())\n\t}\n\treturn nil\n}\n\nfunc main() {\n\txmlData := \"<root><name>Example</name></root>\"\n\terr := processXML(xmlData)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t} else {\n\t\tfmt.Println(\"XML processed successfully.\")\n\t}\n}\n```"
  },
  {
    "task": "Design a program that handles exceptions when accessing environment variables.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc main() {\n\tenvVar := \"MY_ENV_VAR\"\n\tvalue, err := getEnv(envVar)\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t} else {\n\t\tfmt.Println(\"Value:\", value)\n\t}\n}\n\nfunc getEnv(key string) (string, error) {\n\tvalue, exists := os.LookupEnv(key)\n\tif !exists {\n\t\treturn \"\", fmt.Errorf(\"environment variable %s not set\", key)\n\t}\n\treturn value, nil\n}\n```"
  },
  {
    "task": "Write a function that calculates factorial and manages exceptions for negative input values.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc factorial(n int) (int, error) {\n\tif n < 0 {\n\t\treturn 0, errors.New(\"negative input is not allowed\")\n\t}\n\n\tresult := 1\n\tfor i := 2; i <= n; i++ {\n\t\tresult *= i\n\t}\n\treturn result, nil\n}\n\nfunc main() {\n\tn := 5\n\tfact, err := factorial(n)\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t} else {\n\t\tfmt.Printf(\"Factorial of %d is %d\\n\", n, fact)\n\t}\n\n\tn = -3\n\tfact, err = factorial(n)\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t} else {\n\t\tfmt.Printf(\"Factorial of %d is %d\\n\", n, fact)\n\t}\n}\n```"
  },
  {
    "task": "Create a software tool that converts file formats and handles unsupported format exceptions.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc convertFileFormat(filename string, targetFormat string) error {\n\tsupportedFormats := map[string]bool{\n\t\t\"txt\": true,\n\t\t\"csv\": true,\n\t\t\"json\": true,\n\t}\n\n\tif !supportedFormats[targetFormat] {\n\t\treturn errors.New(\"unsupported format: \" + targetFormat)\n\t}\n\n\t// Placeholder for actual conversion logic\n\tfmt.Printf(\"Converting %s to %s format...\\n\", filename, targetFormat)\n\treturn nil\n}\n\nfunc main() {\n\tfilenames := []string{\"data.txt\", \"report.csv\"}\n\ttargetFormat := \"xml\"\n\n\tfor _, filename := range filenames {\n\t\terr := convertFileFormat(filename, targetFormat)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error:\", err)\n\t\t} else {\n\t\t\tfmt.Printf(\"Successfully converted %s\\n\", filename)\n\t\t}\n\t}\n}\n```"
  },
  {
    "task": "Implement a function that sends HTTP requests and catches exceptions for invalid response status codes.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc sendHTTPRequest(url string) error {\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode < 200 || resp.StatusCode >= 300 {\n\t\treturn errors.New(fmt.Sprintf(\"Invalid response status code: %d\", resp.StatusCode))\n\t}\n\n\treturn nil\n}\n\nfunc main() {\n\terr := sendHTTPRequest(\"https://example.com\")\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t} else {\n\t\tfmt.Println(\"Request successful\")\n\t}\n}\n```"
  },
  {
    "task": "Develop a program that interacts with a message queue and handles message delivery exceptions.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\ntype MessageQueue struct {\n\tmessages []string\n}\n\nfunc (mq *MessageQueue) sendMessage(message string) error {\n\tif rand.Float32() < 0.2 { // Simulate a 20% chance of failure\n\t\treturn errors.New(\"failed to send message\")\n\t}\n\tmq.messages = append(mq.messages, message)\n\treturn nil\n}\n\nfunc main() {\n\trand.Seed(time.Now().UnixNano())\n\n\tmq := &MessageQueue{}\n\n\tmessagesToSend := []string{\"Hello\", \"World\", \"Go\", \"Programming\", \"Queue\"}\n\tfor _, msg := range messagesToSend {\n\t\terr := mq.sendMessage(msg)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Error sending message '%s': %v\\n\", msg, err)\n\t\t} else {\n\t\t\tfmt.Printf(\"Message '%s' sent successfully\\n\", msg)\n\t\t}\n\t}\n}\n```"
  },
  {
    "task": "Write a function that reads user input and catches exceptions for unexpected data types.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n)\n\nfunc readUserInput() {\n\tvar input string\n\tfmt.Print(\"Enter a number: \")\n\tfmt.Scanln(&input)\n\tif _, err := strconv.Atoi(input); err != nil {\n\t\tfmt.Println(\"Error: Please enter a valid number.\")\n\t} else {\n\t\tfmt.Println(\"You entered:\", input)\n\t}\n}\n\nfunc main() {\n\treadUserInput()\n}\n```"
  },
  {
    "task": "Create a system that processes transactions and manages exceptions for insufficient funds.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\ntype Account struct {\n\tBalance float64\n}\n\nfunc (a *Account) ProcessTransaction(amount float64) error {\n\tif a.Balance < amount {\n\t\treturn errors.New(\"insufficient funds\")\n\t}\n\ta.Balance -= amount\n\treturn nil\n}\n\nfunc main() {\n\taccount := Account{Balance: 100.0}\n\ttransactions := []float64{50.0, 75.0, 25.0}\n\n\tfor _, transaction := range transactions {\n\t\terr := account.ProcessTransaction(transaction)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Transaction of %.2f failed: %s\\n\", transaction, err)\n\t\t} else {\n\t\t\tfmt.Printf(\"Transaction of %.2f succeeded. Remaining balance: %.2f\\n\", transaction, account.Balance)\n\t\t}\n\t}\n}\n```"
  },
  {
    "task": "Design a function that generates random numbers and handles exceptions when the range is invalid.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc generateRandomNumber(min, max int) (int, error) {\n\tif min > max {\n\t\treturn 0, fmt.Errorf(\"invalid range: min (%d) is greater than max (%d)\", min, max)\n\t}\n\treturn rand.Intn(max-min+1) + min, nil\n}\n\nfunc main() {\n\trand.Seed(time.Now().UnixNano())\n\n\tmin, max := 10, 5\n\tnumber, err := generateRandomNumber(min, max)\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t} else {\n\t\tfmt.Println(\"Generated number:\", number)\n\t}\n}\n```"
  },
  {
    "task": "Implement a program that performs image processing and catches exceptions for unsupported file dimensions.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc processImage(width, height int) error {\n\tif width > 10000 || height > 10000 {\n\t\treturn errors.New(\"unsupported file dimensions\")\n\t}\n\t// Image processing logic would go here\n\treturn nil\n}\n\nfunc main() {\n\twidth := 12000\n\theight := 8000\n\n\terr := processImage(width, height)\n\tif err != nil {\n\t\tfmt.Println(\"Error processing image:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"Image processed successfully\")\n}\n```"
  },
  {
    "task": "Write a function that manipulates strings and manages exceptions for invalid operations.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc manipulateString(s string, operation string) (string, error) {\n\tswitch operation {\n\tcase \"uppercase\":\n\t\treturn strings.ToUpper(s), nil\n\tcase \"lowercase\":\n\t\treturn strings.ToLower(s), nil\n\tcase \"reverse\":\n\t\trunes := []rune(s)\n\t\tfor i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\n\t\t\trunes[i], runes[j] = runes[j], runes[i]\n\t\t}\n\t\treturn string(runes), nil\n\tdefault:\n\t\treturn \"\", errors.New(\"invalid operation\")\n\t}\n}\n\nfunc main() {\n\tresult, err := manipulateString(\"Hello, World!\", \"reverse\")\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t} else {\n\t\tfmt.Println(\"Result:\", result)\n\t}\n}\n```"
  },
  {
    "task": "Create a script that automates tasks and handles exceptions for missing dependencies.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os/exec\"\n)\n\nfunc checkDependency(dependency string) error {\n\t_, err := exec.LookPath(dependency)\n\tif err != nil {\n\t\treturn errors.New(fmt.Sprintf(\"Missing dependency: %s\", dependency))\n\t}\n\treturn nil\n}\n\nfunc automateTask() error {\n\t// Example task that requires \"git\" as a dependency\n\tif err := checkDependency(\"git\"); err != nil {\n\t\treturn err\n\t}\n\n\t// Automate some tasks, e.g., clone a repository\n\tcmd := exec.Command(\"git\", \"clone\", \"https://github.com/example/repo.git\")\n\tif err := cmd.Run(); err != nil {\n\t\treturn fmt.Errorf(\"Failed to execute command: %v\", err)\n\t}\n\treturn nil\n}\n\nfunc main() {\n\tif err := automateTask(); err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t} else {\n\t\tfmt.Println(\"Task completed successfully\")\n\t}\n}\n```"
  },
  {
    "task": "Develop a function that accesses nested data structures and manages key access exceptions.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc accessNestedData(data map[string]interface{}, keys ...string) (interface{}, error) {\n\tcurrent := data\n\tfor i, key := range keys {\n\t\tif value, ok := current[key]; ok {\n\t\t\tif i == len(keys)-1 {\n\t\t\t\treturn value, nil\n\t\t\t}\n\t\t\tif nextMap, ok := value.(map[string]interface{}); ok {\n\t\t\t\tcurrent = nextMap\n\t\t\t} else {\n\t\t\t\treturn nil, errors.New(\"intermediate value is not a map\")\n\t\t\t}\n\t\t} else {\n\t\t\treturn nil, fmt.Errorf(\"key %s not found\", key)\n\t\t}\n\t}\n\treturn nil, errors.New(\"unexpected error\")\n}\n\nfunc main() {\n\tdata := map[string]interface{}{\n\t\t\"level1\": map[string]interface{}{\n\t\t\t\"level2\": map[string]interface{}{\n\t\t\t\t\"value\": 42,\n\t\t\t},\n\t\t},\n\t}\n\n\tif result, err := accessNestedData(data, \"level1\", \"level2\", \"value\"); err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t} else {\n\t\tfmt.Println(\"Result:\", result)\n\t}\n}\n```"
  },
  {
    "task": "Design a program that synchronizes data between sources and handles data mismatch exceptions.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc main() {\n\tsource1Data := []string{\"data1\", \"data2\", \"data3\"}\n\tsource2Data := []string{\"data1\", \"data2\", \"data4\"}\n\n\terr := synchronizeData(source1Data, source2Data)\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t} else {\n\t\tfmt.Println(\"Data synchronized successfully.\")\n\t}\n}\n\nfunc synchronizeData(source1, source2 []string) error {\n\tif len(source1) != len(source2) {\n\t\treturn errors.New(\"data mismatch: sources have different lengths\")\n\t}\n\n\tfor i := range source1 {\n\t\tif source1[i] != source2[i] {\n\t\t\treturn fmt.Errorf(\"data mismatch at index %d: %s != %s\", i, source1[i], source2[i])\n\t\t}\n\t}\n\n\treturn nil\n}\n```"
  },
  {
    "task": "Write a function that interacts with hardware devices and handles connection failure exceptions.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc connectToDevice() error {\n\t// Simulate a device connection failure\n\treturn errors.New(\"failed to connect to device\")\n}\n\nfunc interactWithDevice() {\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tfmt.Println(\"Recovered from panic:\", r)\n\t\t}\n\t}()\n\n\terr := connectToDevice()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Println(\"Successfully connected and interacted with the device\")\n}\n\nfunc main() {\n\tinteractWithDevice()\n}\n```"
  },
  {
    "task": "Create a tool that compresses files and manages exceptions for unsupported compression formats.",
    "code": "```go\npackage main\n\nimport (\n\t\"compress/gzip\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"strings\"\n)\n\nfunc compressFile(inputFileName, outputFileName string) error {\n\tinputFile, err := os.Open(inputFileName)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to open input file: %w\", err)\n\t}\n\tdefer inputFile.Close()\n\n\toutputFile, err := os.Create(outputFileName)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create output file: %w\", err)\n\t}\n\tdefer outputFile.Close()\n\n\tgzipWriter := gzip.NewWriter(outputFile)\n\tdefer gzipWriter.Close()\n\n\t_, err = io.Copy(gzipWriter, inputFile)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to compress file: %w\", err)\n\t}\n\n\treturn nil\n}\n\nfunc main() {\n\tinputFileName := \"example.txt\"\n\toutputFileName := \"example.txt.gz\"\n\n\tif !strings.HasSuffix(outputFileName, \".gz\") {\n\t\tfmt.Println(\"Error: Unsupported compression format\")\n\t\treturn\n\t}\n\n\terr := compressFile(inputFileName, outputFileName)\n\tif err != nil {\n\t\tfmt.Printf(\"Compression failed: %v\\n\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"File compressed successfully\")\n}\n```"
  },
  {
    "task": "Implement a function that parses command-line arguments and handles missing argument exceptions.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc parseArguments() {\n\tif len(os.Args) < 2 {\n\t\tfmt.Println(\"Error: Missing arguments\")\n\t\tos.Exit(1)\n\t}\n\n\tfor i, arg := range os.Args[1:] {\n\t\tfmt.Printf(\"Argument %d: %s\\n\", i+1, arg)\n\t}\n}\n\nfunc main() {\n\tparseArguments()\n}\n```"
  },
  {
    "task": "Develop a program that simulates user interactions and manages timing exceptions.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc simulateUserInteraction() error {\n\t// Simulate a random interaction delay\n\tdelay := time.Duration(2+time.Now().UnixNano()%4) * time.Second\n\ttime.Sleep(delay)\n\n\t// Simulating a timeout condition\n\tif delay > 3*time.Second {\n\t\treturn fmt.Errorf(\"interaction timed out after %v\", delay)\n\t}\n\treturn nil\n}\n\nfunc main() {\n\terr := simulateUserInteraction()\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t} else {\n\t\tfmt.Println(\"User interaction successful\")\n\t}\n}\n```"
  },
  {
    "task": "Write a function that encrypts data and handles exceptions for unsupported encryption algorithms.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc encryptData(algorithm string, data string) (string, error) {\n\tswitch algorithm {\n\tcase \"AES\":\n\t\treturn \"encrypted_with_AES\", nil // Placeholder for actual AES encryption logic\n\tcase \"RSA\":\n\t\treturn \"encrypted_with_RSA\", nil // Placeholder for actual RSA encryption logic\n\tdefault:\n\t\treturn \"\", errors.New(\"unsupported encryption algorithm\")\n\t}\n}\n\nfunc main() {\n\tdata := \"mySecretData\"\n\talgorithm := \"DES\"\n\n\tencryptedData, err := encryptData(algorithm, data)\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"Encrypted Data:\", encryptedData)\n}\n```"
  },
  {
    "task": "Create a system that aggregates data and manages exceptions for data inconsistency.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\ntype Data struct {\n\tID    int\n\tValue string\n}\n\nfunc aggregateData(data []Data) (map[int]string, error) {\n\tif data == nil {\n\t\treturn nil, errors.New(\"data is nil\")\n\t}\n\n\taggregatedData := make(map[int]string)\n\tfor _, d := range data {\n\t\tif _, exists := aggregatedData[d.ID]; exists {\n\t\t\treturn nil, fmt.Errorf(\"data inconsistency detected for ID: %d\", d.ID)\n\t\t}\n\t\taggregatedData[d.ID] = d.Value\n\t}\n\n\treturn aggregatedData, nil\n}\n\nfunc main() {\n\tdata := []Data{\n\t\t{ID: 1, Value: \"Value1\"},\n\t\t{ID: 2, Value: \"Value2\"},\n\t\t{ID: 1, Value: \"Value3\"}, // Inconsistent data for testing\n\t}\n\n\taggregated, err := aggregateData(data)\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"Aggregated Data:\", aggregated)\n}\n```"
  },
  {
    "task": "Design a program that processes real-time data streams and handles connection drop exceptions.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc main() {\n\tfor {\n\t\terr := processDataStream()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error:\", err)\n\t\t\tfmt.Println(\"Attempting to reconnect...\")\n\t\t\ttime.Sleep(2 * time.Second)\n\t\t}\n\t}\n}\n\nfunc processDataStream() error {\n\tif rand.Float32() < 0.1 {\n\t\treturn errors.New(\"connection dropped\")\n\t}\n\n\t// Simulate data processing\n\tfmt.Println(\"Processing data stream...\")\n\ttime.Sleep(1 * time.Second)\n\treturn nil\n}\n```"
  },
  {
    "task": "Implement a function that performs scientific calculations and manages precision exceptions.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc scientificCalculation(value float64) (float64, error) {\n\tif value < 0 {\n\t\treturn 0, errors.New(\"negative value error: square root of negative value is not defined\")\n\t}\n\n\tresult := math.Sqrt(value)\n\tif math.IsNaN(result) || math.IsInf(result, 0) {\n\t\treturn 0, errors.New(\"calculation error: result is not a finite number\")\n\t}\n\n\treturn result, nil\n}\n\nfunc main() {\n\tvalues := []float64{4, -4, math.MaxFloat64}\n\tfor _, value := range values {\n\t\tresult, err := scientificCalculation(value)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t\t} else {\n\t\t\tfmt.Printf(\"Result: %v\\n\", result)\n\t\t}\n\t}\n}\n```"
  },
  {
    "task": "Write a script that generates reports and handles exceptions for missing data sources.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc main() {\n\tdataSource := \"reportData.csv\"\n\t\n\terr := generateReport(dataSource)\n\tif err != nil {\n\t\tfmt.Println(\"Error generating report:\", err)\n\t} else {\n\t\tfmt.Println(\"Report generated successfully.\")\n\t}\n}\n\nfunc generateReport(source string) error {\n\t// Simulate missing data source\n\tif source == \"\" {\n\t\treturn errors.New(\"data source is missing\")\n\t}\n\t\n\t// Simulate file not found\n\tif source != \"reportData.csv\" {\n\t\treturn errors.New(\"data source not found\")\n\t}\n\n\t// Place logic for generating report here\n\n\treturn nil\n}\n```"
  },
  {
    "task": "Create a program that validates digital certificates and manages trust exceptions.",
    "code": "```go\npackage main\n\nimport (\n\t\"crypto/x509\"\n\t\"encoding/pem\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\tcertPEM, err := ioutil.ReadFile(\"certificate.pem\")\n\tif err != nil {\n\t\tfmt.Println(\"Error reading certificate:\", err)\n\t\treturn\n\t}\n\n\tblock, _ := pem.Decode(certPEM)\n\tif block == nil {\n\t\tfmt.Println(\"Failed to decode PEM block\")\n\t\treturn\n\t}\n\n\tcert, err := x509.ParseCertificate(block.Bytes)\n\tif err != nil {\n\t\tfmt.Println(\"Error parsing certificate:\", err)\n\t\treturn\n\t}\n\n\troots := x509.NewCertPool()\n\tok := roots.AppendCertsFromPEM(certPEM)\n\tif !ok {\n\t\tfmt.Println(\"Failed to append certificate to pool\")\n\t\treturn\n\t}\n\n\topts := x509.VerifyOptions{\n\t\tRoots: roots,\n\t}\n\n\tif _, err := cert.Verify(opts); err != nil {\n\t\thandleTrustException(err)\n\t} else {\n\t\tfmt.Println(\"Certificate verified successfully\")\n\t}\n}\n\nfunc handleTrustException(err error) {\n\tvar unknownAuthorityError x509.UnknownAuthorityError\n\tif errors.As(err, &unknownAuthorityError) {\n\t\tfmt.Println(\"Trust exception: Unknown authority\")\n\t} else {\n\t\tfmt.Println(\"Trust exception:\", err)\n\t}\n}\n```"
  },
  {
    "task": "Develop a function that schedules tasks and handles exceptions for scheduling conflicts.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\ntype Task struct {\n\tID   int\n\tTime string\n}\n\nfunc scheduleTask(tasks []Task, newTask Task) ([]Task, error) {\n\tfor _, task := range tasks {\n\t\tif task.Time == newTask.Time {\n\t\t\treturn tasks, errors.New(\"scheduling conflict: time slot already taken\")\n\t\t}\n\t}\n\ttasks = append(tasks, newTask)\n\treturn tasks, nil\n}\n\nfunc main() {\n\ttasks := []Task{\n\t\t{ID: 1, Time: \"10:00AM\"},\n\t\t{ID: 2, Time: \"11:00AM\"},\n\t}\n\n\tnewTask := Task{ID: 3, Time: \"10:00AM\"} // Change time to test conflict handling\n\n\tupdatedTasks, err := scheduleTask(tasks, newTask)\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t} else {\n\t\tfmt.Println(\"Scheduled Tasks:\", updatedTasks)\n\t}\n}\n```"
  },
  {
    "task": "Design a system that manages user sessions and handles session timeout exceptions.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"time\"\n)\n\ntype Session struct {\n\tuserID    string\n\tlastActive time.Time\n}\n\ntype SessionManager struct {\n\tsessions map[string]*Session\n\ttimeout  time.Duration\n}\n\nfunc NewSessionManager(timeout time.Duration) *SessionManager {\n\treturn &SessionManager{\n\t\tsessions: make(map[string]*Session),\n\t\ttimeout:  timeout,\n\t}\n}\n\nfunc (sm *SessionManager) CreateSession(userID string) {\n\tsm.sessions[userID] = &Session{userID: userID, lastActive: time.Now()}\n}\n\nfunc (sm *SessionManager) CheckSession(userID string) error {\n\tsession, exists := sm.sessions[userID]\n\tif !exists {\n\t\treturn errors.New(\"session does not exist\")\n\t}\n\tif time.Since(session.lastActive) > sm.timeout {\n\t\tdelete(sm.sessions, userID)\n\t\treturn errors.New(\"session timeout\")\n\t}\n\tsession.lastActive = time.Now()\n\treturn nil\n}\n\nfunc (sm *SessionManager) HandleSession(userID string) {\n\terr := sm.CheckSession(userID)\n\tif err != nil {\n\t\tfmt.Printf(\"Error for user %s: %s\\n\", userID, err.Error())\n\t} else {\n\t\tfmt.Printf(\"Session for user %s is active\\n\", userID)\n\t}\n}\n\nfunc main() {\n\tsm := NewSessionManager(5 * time.Second)\n\n\tsm.CreateSession(\"user1\")\n\n\ttime.Sleep(3 * time.Second)\n\tsm.HandleSession(\"user1\")\n\n\ttime.Sleep(3 * time.Second)\n\tsm.HandleSession(\"user1\")\n}\n```"
  },
  {
    "task": "Write a function that processes audio files and manages exceptions for unsupported audio formats.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc processAudioFile(fileName string) error {\n\tsupportedFormats := []string{\".mp3\", \".wav\", \".flac\"}\n\tfileSupported := false\n\n\tfor _, format := range supportedFormats {\n\t\tif fileNameHasExtension(fileName, format) {\n\t\t\tfileSupported = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif !fileSupported {\n\t\treturn errors.New(\"unsupported audio format\")\n\t}\n\n\tfmt.Println(\"Processing audio file:\", fileName)\n\treturn nil\n}\n\nfunc fileNameHasExtension(fileName, extension string) bool {\n\treturn len(fileName) >= len(extension) && fileName[len(fileName)-len(extension):] == extension\n}\n\nfunc main() {\n\tfiles := []string{\"song.mp3\", \"voice.wav\", \"audio.txt\"}\n\n\tfor _, file := range files {\n\t\terr := processAudioFile(file)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error:\", err)\n\t\t}\n\t}\n}\n```"
  },
  {
    "task": "Create a service that sends notifications and handles exceptions for unreachable destinations.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\ntype NotificationService struct{}\n\nfunc (ns *NotificationService) SendNotification(destination string) error {\n\tif destination == \"\" {\n\t\treturn errors.New(\"destination is unreachable\")\n\t}\n\t// Simulate sending a notification\n\tfmt.Printf(\"Notification sent to %s\\n\", destination)\n\treturn nil\n}\n\nfunc main() {\n\tservice := &NotificationService{}\n\tdestinations := []string{\"user1@example.com\", \"\", \"user3@example.com\"}\n\n\tfor _, dest := range destinations {\n\t\terr := service.SendNotification(dest)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Error: %s\\n\", err)\n\t\t}\n\t}\n}\n```"
  },
  {
    "task": "Implement a program that performs data migration and manages data transformation exceptions.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc main() {\n\tdata := []string{\"123\", \"456\", \"abc\", \"789\"}\n\tmigratedData, err := performDataMigration(data)\n\tif err != nil {\n\t\tfmt.Println(\"Data migration failed:\", err)\n\t} else {\n\t\tfmt.Println(\"Data migration succeeded:\", migratedData)\n\t}\n}\n\nfunc performDataMigration(data []string) ([]int, error) {\n\tvar result []int\n\tfor _, item := range data {\n\t\ttransformed, err := transformData(item)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"error transforming data %s: %w\", item, err)\n\t\t}\n\t\tresult = append(result, transformed)\n\t}\n\treturn result, nil\n}\n\nfunc transformData(input string) (int, error) {\n\tvar num int\n\t_, err := fmt.Sscanf(input, \"%d\", &num)\n\tif err != nil {\n\t\treturn 0, errors.New(\"invalid data format\")\n\t}\n\treturn num, nil\n}\n```"
  },
  {
    "task": "Develop a function that processes video files and handles codec compatibility exceptions.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\n// ProcessVideo processes a video file and handles codec compatibility exceptions.\nfunc ProcessVideo(fileName string) error {\n\t// Simulate checking codec compatibility\n\tif !isCodecCompatible(fileName) {\n\t\treturn errors.New(\"codec compatibility exception\")\n\t}\n\t// Simulate processing video\n\tfmt.Printf(\"Processing video file: %s\\n\", fileName)\n\treturn nil\n}\n\n// isCodecCompatible simulates checking codec compatibility.\nfunc isCodecCompatible(fileName string) bool {\n\t// Placeholder logic for codec compatibility check\n\treturn fileName != \"incompatible_codec.mp4\"\n}\n\nfunc main() {\n\terr := ProcessVideo(\"incompatible_codec.mp4\")\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t} else {\n\t\tfmt.Println(\"Video processed successfully.\")\n\t}\n}\n```"
  },
  {
    "task": "Write a function that manages memory allocation and catches out-of-memory exceptions.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"runtime\"\n)\n\nfunc allocateMemory(size int) (memory []byte, err error) {\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\terr = fmt.Errorf(\"memory allocation failed: %v\", r)\n\t\t}\n\t}()\n\t\n\tmemory = make([]byte, size)\n\treturn memory, nil\n}\n\nfunc main() {\n\tsize := 1 << 30 // 1GB\n\tif memory, err := allocateMemory(size); err != nil {\n\t\tfmt.Println(err)\n\t} else {\n\t\tfmt.Printf(\"Allocated %d bytes of memory successfully.\\n\", len(memory))\n\t}\n\n\t// Force garbage collection\n\truntime.GC()\n}\n```"
  },
  {
    "task": "Create a program that processes financial transactions and handles currency conversion exceptions.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\ntype Transaction struct {\n\tamount   float64\n\tcurrency string\n}\n\nfunc convertCurrency(amount float64, fromCurrency, toCurrency string) (float64, error) {\n\tif fromCurrency == \"USD\" && toCurrency == \"EUR\" {\n\t\treturn amount * 0.9, nil\n\t} else if fromCurrency == \"EUR\" && toCurrency == \"USD\" {\n\t\treturn amount * 1.1, nil\n\t}\n\treturn 0, errors.New(\"currency conversion not supported\")\n}\n\nfunc processTransaction(t Transaction, targetCurrency string) {\n\tconvertedAmount, err := convertCurrency(t.amount, t.currency, targetCurrency)\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t\treturn\n\t}\n\tfmt.Printf(\"Processed transaction: %.2f %s to %.2f %s\\n\", t.amount, t.currency, convertedAmount, targetCurrency)\n}\n\nfunc main() {\n\ttransactions := []Transaction{\n\t\t{100, \"USD\"},\n\t\t{200, \"EUR\"},\n\t\t{150, \"GBP\"},\n\t}\n\n\tfor _, t := range transactions {\n\t\tprocessTransaction(t, \"EUR\")\n\t}\n}\n```"
  },
  {
    "task": "Design a function that interacts with cloud storage and manages access permission exceptions.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\n// Custom error types for specific permission issues\nvar (\n\tErrPermissionDenied = errors.New(\"permission denied\")\n\tErrNotFound         = errors.New(\"resource not found\")\n)\n\n// CloudStorage represents a mock cloud storage service\ntype CloudStorage struct {\n\tpermissions map[string]bool\n}\n\n// NewCloudStorage initializes a new CloudStorage with given permissions\nfunc NewCloudStorage() *CloudStorage {\n\treturn &CloudStorage{\n\t\tpermissions: map[string]bool{\n\t\t\t\"read\":  true,\n\t\t\t\"write\": false,\n\t\t},\n\t}\n}\n\n// AccessResource attempts to access a resource with the given permission type\nfunc (cs *CloudStorage) AccessResource(permissionType string) error {\n\tif allowed, exists := cs.permissions[permissionType]; !exists {\n\t\treturn ErrNotFound\n\t} else if !allowed {\n\t\treturn ErrPermissionDenied\n\t}\n\treturn nil\n}\n\nfunc main() {\n\tstorage := NewCloudStorage()\n\n\tpermissionTypes := []string{\"read\", \"write\", \"delete\"}\n\tfor _, pt := range permissionTypes {\n\t\terr := storage.AccessResource(pt)\n\t\tif errors.Is(err, ErrPermissionDenied) {\n\t\t\tfmt.Printf(\"Access denied for permission type: %s\\n\", pt)\n\t\t} else if errors.Is(err, ErrNotFound) {\n\t\t\tfmt.Printf(\"Permission type not found: %s\\n\", pt)\n\t\t} else {\n\t\t\tfmt.Printf(\"Access granted for permission type: %s\\n\", pt)\n\t\t}\n\t}\n}\n```"
  },
  {
    "task": "Implement a script that automates deployment and handles exceptions for missing configuration files.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc loadConfig(filePath string) (string, error) {\n\tif _, err := os.Stat(filePath); os.IsNotExist(err) {\n\t\treturn \"\", errors.New(\"configuration file not found\")\n\t}\n\t// Simulated load config\n\treturn \"Config Loaded\", nil\n}\n\nfunc deploy() error {\n\tconfig, err := loadConfig(\"config.yaml\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tfmt.Println(config)\n\treturn nil\n}\n\nfunc main() {\n\terr := deploy()\n\tif err != nil {\n\t\tfmt.Println(\"Deployment failed:\", err)\n\t\treturn\n\t}\n\tfmt.Println(\"Deployment succeeded\")\n}\n```"
  },
  {
    "task": "Write a function that normalizes data and handles exceptions for invalid data ranges.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc normalizeData(data []float64) ([]float64, error) {\n\tif len(data) == 0 {\n\t\treturn nil, errors.New(\"data slice is empty\")\n\t}\n\n\tmin, max := data[0], data[0]\n\tfor _, value := range data {\n\t\tif value < min {\n\t\t\tmin = value\n\t\t}\n\t\tif value > max {\n\t\t\tmax = value\n\t\t}\n\t}\n\n\tif min == max {\n\t\treturn nil, errors.New(\"data range is zero, normalization is not possible\")\n\t}\n\n\tnormalizedData := make([]float64, len(data))\n\tfor i, value := range data {\n\t\tnormalizedData[i] = (value - min) / (max - min)\n\t}\n\n\treturn normalizedData, nil\n}\n\nfunc main() {\n\tdata := []float64{10, 20, 30, 40, 50}\n\tnormalizedData, err := normalizeData(data)\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t\treturn\n\t}\n\tfmt.Println(\"Normalized Data:\", normalizedData)\n}\n```"
  },
  {
    "task": "Create a system that monitors application performance and handles threshold breach exceptions.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\ntype PerformanceMonitor struct {\n\tthreshold int\n}\n\nfunc (pm *PerformanceMonitor) CheckPerformance(value int) error {\n\tif value > pm.threshold {\n\t\treturn errors.New(\"performance threshold breached\")\n\t}\n\treturn nil\n}\n\nfunc main() {\n\tmonitor := PerformanceMonitor{threshold: 80}\n\trand.Seed(time.Now().UnixNano())\n\n\tfor i := 0; i < 10; i++ {\n\t\tvalue := rand.Intn(100)\n\t\tfmt.Printf(\"Checking performance: %d\\n\", value)\n\t\terr := monitor.CheckPerformance(value)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error:\", err)\n\t\t} else {\n\t\t\tfmt.Println(\"Performance is within acceptable limits.\")\n\t\t}\n\t\ttime.Sleep(500 * time.Millisecond)\n\t}\n}\n```"
  },
  {
    "task": "Develop a program that processes social media data and manages API limit exceptions.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"time\"\n)\n\ntype SocialMediaAPI struct {\n\tcallCount int\n\tlimit     int\n}\n\nfunc (api *SocialMediaAPI) fetchData() (string, error) {\n\tif api.callCount >= api.limit {\n\t\treturn \"\", errors.New(\"API limit exceeded\")\n\t}\n\tapi.callCount++\n\treturn \"Sample Social Media Data\", nil\n}\n\nfunc processSocialMediaData(api *SocialMediaAPI) {\n\tfor {\n\t\tdata, err := api.fetchData()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error:\", err)\n\t\t\thandleRateLimitError()\n\t\t\tcontinue\n\t\t}\n\t\tfmt.Println(\"Data:\", data)\n\t\ttime.Sleep(1 * time.Second) // Simulate processing delay\n\t}\n}\n\nfunc handleRateLimitError() {\n\tfmt.Println(\"Handling rate limit exception, waiting before retrying...\")\n\ttime.Sleep(5 * time.Second)\n}\n\nfunc main() {\n\tapi := &SocialMediaAPI{limit: 5}\n\tprocessSocialMediaData(api)\n}\n```"
  },
  {
    "task": "Design a function that integrates with payment gateways and handles payment failure exceptions.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\ntype PaymentGateway struct{}\n\nfunc (pg *PaymentGateway) ProcessPayment(amount float64) error {\n\t// Simulate a payment failure for demonstration\n\treturn errors.New(\"payment failed due to insufficient funds\")\n}\n\nfunc HandlePayment(amount float64) {\n\tgateway := &PaymentGateway{}\n\terr := gateway.ProcessPayment(amount)\n\tif err != nil {\n\t\tfmt.Println(\"Error processing payment:\", err)\n\t} else {\n\t\tfmt.Println(\"Payment processed successfully\")\n\t}\n}\n\nfunc main() {\n\tHandlePayment(100.0)\n}\n```"
  },
  {
    "task": "Write a function that backs up data and handles exceptions for unavailable storage media.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc backupData() error {\n\t// Simulate storage media availability\n\tisStorageAvailable := false\n\n\tif !isStorageAvailable {\n\t\treturn errors.New(\"storage media unavailable\")\n\t}\n\n\t// Logic for backing up data\n\tfmt.Println(\"Data backed up successfully\")\n\treturn nil\n}\n\nfunc main() {\n\terr := backupData()\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t} else {\n\t\tfmt.Println(\"Backup completed without errors.\")\n\t}\n}\n```"
  },
  {
    "task": "Create a tool that manages software updates and handles exceptions for version conflicts.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\ntype Software struct {\n\tName    string\n\tVersion string\n}\n\nfunc (s *Software) Update(newVersion string) error {\n\tif newVersion <= s.Version {\n\t\treturn errors.New(\"version conflict: new version is not greater than current version\")\n\t}\n\n\ts.Version = newVersion\n\treturn nil\n}\n\nfunc main() {\n\tsoftware := Software{Name: \"ExampleApp\", Version: \"1.0.0\"}\n\n\terr := software.Update(\"0.9.0\")\n\tif err != nil {\n\t\tfmt.Println(\"Update failed:\", err)\n\t} else {\n\t\tfmt.Println(\"Update succeeded:\", software)\n\t}\n\n\terr = software.Update(\"1.1.0\")\n\tif err != nil {\n\t\tfmt.Println(\"Update failed:\", err)\n\t} else {\n\t\tfmt.Println(\"Update succeeded:\", software)\n\t}\n}\n```"
  },
  {
    "task": "Implement a program that performs sentiment analysis and manages exceptions for ambiguous texts.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\n// AnalyzeSentiment analyzes the sentiment of the given text.\nfunc AnalyzeSentiment(text string) (string, error) {\n\tif text == \"\" {\n\t\treturn \"\", errors.New(\"text is empty\")\n\t}\n\t// Dummy sentiment analysis logic\n\tif text == \"ambiguous\" {\n\t\treturn \"\", errors.New(\"ambiguous sentiment detected\")\n\t}\n\tif len(text)%2 == 0 {\n\t\treturn \"Positive\", nil\n\t}\n\treturn \"Negative\", nil\n}\n\nfunc main() {\n\ttexts := []string{\"happy\", \"sad\", \"ambiguous\", \"joyful\", \"\"}\n\tfor _, text := range texts {\n\t\tsentiment, err := AnalyzeSentiment(text)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Error analyzing text '%s': %s\\n\", text, err)\n\t\t\tcontinue\n\t\t}\n\t\tfmt.Printf(\"Text: '%s' Sentiment: %s\\n\", text, sentiment)\n\t}\n}\n```"
  },
  {
    "task": "Develop a function that manages user authentication and handles credential mismatch exceptions.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc authenticateUser(username, password string) error {\n\texpectedUsername := \"admin\"\n\texpectedPassword := \"password123\"\n\n\tif username != expectedUsername || password != expectedPassword {\n\t\treturn errors.New(\"credential mismatch: authentication failed\")\n\t}\n\n\treturn nil\n}\n\nfunc main() {\n\tusername := \"admin\"\n\tpassword := \"wrongpassword\" // Example of wrong password\n\n\terr := authenticateUser(username, password)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t} else {\n\t\tfmt.Println(\"Authentication successful\")\n\t}\n}\n```"
  },
  {
    "task": "Write a program that processes geographic data and handles exceptions for invalid coordinates.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\ntype Coordinate struct {\n\tLatitude  float64\n\tLongitude float64\n}\n\nfunc processCoordinates(coord Coordinate) error {\n\tif coord.Latitude < -90 || coord.Latitude > 90 {\n\t\treturn errors.New(\"invalid latitude\")\n\t}\n\tif coord.Longitude < -180 || coord.Longitude > 180 {\n\t\treturn errors.New(\"invalid longitude\")\n\t}\n\t// Simulated processing of valid coordinates\n\tfmt.Printf(\"Processing coordinates: Latitude=%.2f, Longitude=%.2f\\n\", coord.Latitude, coord.Longitude)\n\treturn nil\n}\n\nfunc main() {\n\tcoords := []Coordinate{\n\t\t{Latitude: 45.0, Longitude: 90.0},\n\t\t{Latitude: -91.0, Longitude: 45.0}, // Invalid latitude\n\t\t{Latitude: 60.0, Longitude: 200.0}, // Invalid longitude\n\t}\n\n\tfor _, coord := range coords {\n\t\terr := processCoordinates(coord)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Error processing coordinates: %v\\n\", err)\n\t\t}\n\t}\n}\n```"
  },
  {
    "task": "Create a script that manages network configurations and handles exceptions for invalid syntax.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n)\n\nfunc configureNetwork(config string) error {\n\t_, _, err := net.ParseCIDR(config)\n\tif err != nil {\n\t\treturn errors.New(\"invalid syntax in network configuration\")\n\t}\n\tfmt.Println(\"Network configured successfully with:\", config)\n\treturn nil\n}\n\nfunc main() {\n\tconfigurations := []string{\n\t\t\"192.168.1.0/24\",\n\t\t\"invalid-config\",\n\t\t\"10.0.0.0/8\",\n\t}\n\n\tfor _, config := range configurations {\n\t\terr := configureNetwork(config)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error:\", err)\n\t\t}\n\t}\n}\n```"
  },
  {
    "task": "Design a function that processes biometric data and handles exceptions for sensor errors.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\n// Custom error for sensor issues\nvar ErrSensorError = errors.New(\"sensor error occurred\")\n\n// ProcessBiometricData processes biometric data and handles sensor errors\nfunc ProcessBiometricData(data []byte) error {\n\tif len(data) == 0 {\n\t\treturn ErrSensorError\n\t}\n\n\t// Simulate data processing\n\t// ...\n\n\treturn nil\n}\n\nfunc main() {\n\tdata := []byte{} // Example of empty data to simulate a sensor error\n\n\terr := ProcessBiometricData(data)\n\tif err != nil {\n\t\tif errors.Is(err, ErrSensorError) {\n\t\t\tfmt.Println(\"Handled sensor error:\", err)\n\t\t} else {\n\t\t\tfmt.Println(\"Unhandled error:\", err)\n\t\t}\n\t} else {\n\t\tfmt.Println(\"Biometric data processed successfully.\")\n\t}\n}\n```"
  },
  {
    "task": "Implement a system that manages access control and handles exceptions for unauthorized access attempts.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\ntype AccessControl struct {\n\tauthorizedUsers map[string]bool\n}\n\nfunc NewAccessControl() *AccessControl {\n\treturn &AccessControl{authorizedUsers: make(map[string]bool)}\n}\n\nfunc (ac *AccessControl) Authorize(user string) {\n\tac.authorizedUsers[user] = true\n}\n\nfunc (ac *AccessControl) CheckAccess(user string) error {\n\tif !ac.authorizedUsers[user] {\n\t\treturn errors.New(\"unauthorized access attempt\")\n\t}\n\treturn nil\n}\n\nfunc main() {\n\tac := NewAccessControl()\n\n\tac.Authorize(\"user1\")\n\n\tusersToCheck := []string{\"user1\", \"user2\", \"user3\"}\n\n\tfor _, user := range usersToCheck {\n\t\terr := ac.CheckAccess(user)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Access denied for %s: %v\\n\", user, err)\n\t\t} else {\n\t\t\tfmt.Printf(\"Access granted for %s\\n\", user)\n\t\t}\n\t}\n}\n```"
  },
  {
    "task": "Write a function that performs load balancing and handles exceptions for unreachable nodes.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\ntype Node struct {\n\taddress string\n\tonline  bool\n}\n\nfunc loadBalance(nodes []Node) (string, error) {\n\tfor _, node := range nodes {\n\t\tif node.online {\n\t\t\treturn node.address, nil\n\t\t}\n\t}\n\treturn \"\", errors.New(\"no reachable nodes\")\n}\n\nfunc main() {\n\tnodes := []Node{\n\t\t{address: \"192.168.1.1\", online: false},\n\t\t{address: \"192.168.1.2\", online: false},\n\t\t{address: \"192.168.1.3\", online: true},\n\t}\n\n\taddress, err := loadBalance(nodes)\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t} else {\n\t\tfmt.Println(\"Node selected:\", address)\n\t}\n}\n```"
  },
  {
    "task": "Create a program that simulates virtual environments and manages resource allocation exceptions.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\ntype VirtualEnvironment struct {\n\tname     string\n\tcapacity int\n\tused     int\n}\n\nfunc NewVirtualEnvironment(name string, capacity int) *VirtualEnvironment {\n\treturn &VirtualEnvironment{name: name, capacity: capacity, used: 0}\n}\n\nfunc (ve *VirtualEnvironment) AllocateResources(amount int) error {\n\tif ve.used+amount > ve.capacity {\n\t\treturn errors.New(\"resource allocation exceeds capacity\")\n\t}\n\tve.used += amount\n\treturn nil\n}\n\nfunc (ve *VirtualEnvironment) FreeResources(amount int) error {\n\tif amount > ve.used {\n\t\treturn errors.New(\"cannot free more resources than allocated\")\n\t}\n\tve.used -= amount\n\treturn nil\n}\n\nfunc main() {\n\tenv := NewVirtualEnvironment(\"DevEnv\", 100)\n\n\terr := env.AllocateResources(50)\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t} else {\n\t\tfmt.Println(\"Allocated 50 resources\")\n\t}\n\n\terr = env.AllocateResources(60)\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t} else {\n\t\tfmt.Println(\"Allocated 60 resources\")\n\t}\n\n\terr = env.FreeResources(30)\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t} else {\n\t\tfmt.Println(\"Freed 30 resources\")\n\t}\n\n\terr = env.FreeResources(30)\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t} else {\n\t\tfmt.Println(\"Freed 30 resources\")\n\t}\n}\n```"
  },
  {
    "task": "Develop a tool that manages digital rights and handles exceptions for unauthorized content access.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\ntype DigitalRightsManager struct {\n\tauthorizedUsers map[string]bool\n}\n\nfunc NewDigitalRightsManager() *DigitalRightsManager {\n\treturn &DigitalRightsManager{\n\t\tauthorizedUsers: make(map[string]bool),\n\t}\n}\n\nfunc (drm *DigitalRightsManager) AddAuthorizedUser(user string) {\n\tdrm.authorizedUsers[user] = true\n}\n\nfunc (drm *DigitalRightsManager) AccessContent(user string) error {\n\tif !drm.isAuthorized(user) {\n\t\treturn errors.New(\"unauthorized access\")\n\t}\n\tfmt.Println(\"Access granted to content\")\n\treturn nil\n}\n\nfunc (drm *DigitalRightsManager) isAuthorized(user string) bool {\n\treturn drm.authorizedUsers[user]\n}\n\nfunc main() {\n\tdrm := NewDigitalRightsManager()\n\tdrm.AddAuthorizedUser(\"user1\")\n\n\terr := drm.AccessContent(\"user2\")\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t}\n\n\terr = drm.AccessContent(\"user1\")\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t}\n}\n```"
  },
  {
    "task": "Design a function that synchronizes clocks and handles exceptions for time drift.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc synchronizeClocks() error {\n\t// Simulate a drift check\n\tdrift := checkTimeDrift()\n\tif drift > 5 {\n\t\treturn errors.New(\"time drift is too large\")\n\t}\n\n\t// Simulate synchronization\n\tsuccess, err := performSynchronization()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !success {\n\t\treturn errors.New(\"failed to synchronize clocks\")\n\t}\n\n\treturn nil\n}\n\nfunc checkTimeDrift() int {\n\t// Simulate drift calculation\n\treturn 10 // Example drift value\n}\n\nfunc performSynchronization() (bool, error) {\n\t// Simulate a synchronization attempt\n\treturn false, nil\n}\n\nfunc main() {\n\terr := synchronizeClocks()\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t} else {\n\t\tfmt.Println(\"Clocks synchronized successfully\")\n\t}\n}\n```"
  },
  {
    "task": "Write a script that manages system backups and handles exceptions for insufficient backup space.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc main() {\n\terr := manageBackup()\n\tif err != nil {\n\t\tfmt.Printf(\"Backup error: %v\\n\", err)\n\t}\n}\n\nfunc manageBackup() error {\n\t// Simulate a check for available backup space\n\tavailableSpace := 100 // in MB\n\trequiredSpace := 150  // in MB\n\n\tif requiredSpace > availableSpace {\n\t\treturn errors.New(\"insufficient backup space\")\n\t}\n\n\t// Simulate backup process\n\tfmt.Println(\"Backup successful\")\n\treturn nil\n}\n```"
  },
  {
    "task": "Create a program that processes natural language text and handles parsing exceptions.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc processText(text string) (string, error) {\n\tif text == \"\" {\n\t\treturn \"\", errors.New(\"input text is empty\")\n\t}\n\t// Simulated parsing by converting text to uppercase\n\tparsedText := strings.ToUpper(text)\n\treturn parsedText, nil\n}\n\nfunc main() {\n\tinputText := \"This is a test string.\"\n\n\tparsedText, err := processText(inputText)\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"Parsed Text:\", parsedText)\n}\n```"
  },
  {
    "task": "Implement a function that manages thread execution and handles race condition exceptions.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\nfunc safeIncrement(wg *sync.WaitGroup, mu *sync.Mutex, count *int) {\n\tdefer wg.Done()\n\tmu.Lock()\n\t*count++\n\tmu.Unlock()\n}\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\tvar mu sync.Mutex\n\tvar count int\n\t\n\tnumThreads := 10\n\tfor i := 0; i < numThreads; i++ {\n\t\twg.Add(1)\n\t\tgo safeIncrement(&wg, &mu, &count)\n\t}\n\n\twg.Wait()\n\tfmt.Printf(\"Final count: %d\\n\", count)\n}\n```"
  },
  {
    "task": "Develop a system that integrates with IoT devices and handles connectivity exceptions.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"time\"\n)\n\n// Simulate a connection to an IoT device\nfunc connectToDevice(deviceID string) error {\n\t// Simulating a connectivity issue\n\tif deviceID == \"device123\" {\n\t\treturn errors.New(\"failed to connect to device\")\n\t}\n\treturn nil\n}\n\nfunc main() {\n\tdeviceID := \"device123\"\n\n\tfor {\n\t\terr := connectToDevice(deviceID)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Error: %s. Retrying...\\n\", err)\n\t\t\ttime.Sleep(2 * time.Second)\n\t\t\tcontinue\n\t\t}\n\t\tfmt.Println(\"Connected to device successfully!\")\n\t\tbreak\n\t}\n}\n```"
  },
  {
    "task": "Write a function that manages application logging and handles exceptions for log overflow.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n)\n\nconst maxLogSize = 1024 // Example size in bytes\n\nfunc main() {\n\terr := manageLogging()\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t}\n}\n\nfunc manageLogging() error {\n\tlogFile, err := os.OpenFile(\"app.log\", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0666)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer logFile.Close()\n\n\tlog.SetOutput(logFile)\n\n\tfileInfo, err := logFile.Stat()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif fileInfo.Size() > maxLogSize {\n\t\treturn errors.New(\"log overflow: log file size exceeded\")\n\t}\n\n\tlog.Println(\"Application started\")\n\treturn nil\n}\n```"
  },
  {
    "task": "Create a tool that visualizes data and handles exceptions for unsupported visualization types.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc visualizeData(data interface{}, visualizationType string) error {\n\tswitch visualizationType {\n\tcase \"bar\":\n\t\tfmt.Println(\"Visualizing data as a bar chart.\")\n\tcase \"line\":\n\t\tfmt.Println(\"Visualizing data as a line chart.\")\n\tdefault:\n\t\treturn errors.New(\"unsupported visualization type\")\n\t}\n\treturn nil\n}\n\nfunc main() {\n\tdata := []int{1, 2, 3, 4, 5}\n\n\terr := visualizeData(data, \"pie\")\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t}\n\n\terr = visualizeData(data, \"bar\")\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t}\n}\n```"
  },
  {
    "task": "Design a program that performs genetic algorithm simulations and manages exception for invalid mutations.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\ntype Chromosome struct {\n\tgenes string\n}\n\nfunc mutate(chromosome Chromosome) (Chromosome, error) {\n\tif rand.Float64() < 0.1 { // an arbitrary mutation chance\n\t\t// Invalid mutation scenario\n\t\treturn Chromosome{}, errors.New(\"invalid mutation occurred\")\n\t}\n\t// Simulate mutation\n\tmutatedGenes := chromosome.genes + \"A\"\n\treturn Chromosome{genes: mutatedGenes}, nil\n}\n\nfunc main() {\n\trand.Seed(time.Now().UnixNano())\n\tchromosome := Chromosome{genes: \"AAA\"}\n\n\tfor i := 0; i < 10; i++ {\n\t\tmutatedChromosome, err := mutate(chromosome)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error:\", err)\n\t\t\tcontinue\n\t\t}\n\t\tfmt.Println(\"Mutated Chromosome:\", mutatedChromosome.genes)\n\t\tchromosome = mutatedChromosome\n\t}\n}\n```"
  },
  {
    "task": "Implement a function that manages distributed transactions and handles consistency exceptions.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc manageTransaction() error {\n\t// Simulate a distributed transaction\n\terr := performDistributedTransaction()\n\n\tif err != nil {\n\t\treturn handleException(err)\n\t}\n\n\treturn nil\n}\n\nfunc performDistributedTransaction() error {\n\t// Placeholder for transaction logic\n\t// Simulate an error\n\treturn errors.New(\"consistency error\")\n}\n\nfunc handleException(err error) error {\n\t// Handle the exception\n\tif err.Error() == \"consistency error\" {\n\t\tfmt.Println(\"Handling consistency exception:\", err)\n\t\t// Example of retry logic or rollback could be implemented here\n\t\treturn nil\n\t}\n\n\t// If unable to handle the error, return it\n\treturn err\n}\n\nfunc main() {\n\terr := manageTransaction()\n\tif err != nil {\n\t\tfmt.Println(\"Transaction failed:\", err)\n\t} else {\n\t\tfmt.Println(\"Transaction succeeded\")\n\t}\n}\n```"
  },
  {
    "task": "Write a function that handles secure communications and manages encryption key exceptions.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc handleSecureCommunication() error {\n\t// Simulate fetching an encryption key\n\tencryptionKey, err := getEncryptionKey()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error fetching encryption key: %w\", err)\n\t}\n\n\t// Simulate using the encryption key\n\tif err := useEncryptionKey(encryptionKey); err != nil {\n\t\treturn fmt.Errorf(\"error using encryption key: %w\", err)\n\t}\n\n\treturn nil\n}\n\nfunc getEncryptionKey() (string, error) {\n\t// Simulate an error in fetching the encryption key\n\treturn \"\", errors.New(\"encryption key not found\")\n}\n\nfunc useEncryptionKey(key string) error {\n\t// Simulate using the encryption key successfully\n\treturn nil\n}\n\nfunc main() {\n\terr := handleSecureCommunication()\n\tif err != nil {\n\t\tfmt.Println(\"Secure communication failed:\", err)\n\t} else {\n\t\tfmt.Println(\"Secure communication succeeded\")\n\t}\n}\n```"
  },
  {
    "task": "Create a system that processes sensor data and handles out-of-range value exceptions.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\ntype SensorData struct {\n\tValue float64\n}\n\nfunc processData(data SensorData) error {\n\tif data.Value < 0 || data.Value > 100 {\n\t\treturn errors.New(\"sensor data out of range\")\n\t}\n\t// Process the data here\n\tfmt.Printf(\"Processing sensor data: %.2f\\n\", data.Value)\n\treturn nil\n}\n\nfunc main() {\n\tsensorValues := []SensorData{\n\t\t{Value: 25.5},\n\t\t{Value: -5.0},\n\t\t{Value: 110.0},\n\t\t{Value: 75.0},\n\t}\n\n\tfor _, data := range sensorValues {\n\t\terr := processData(data)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error:\", err)\n\t\t}\n\t}\n}\n```"
  },
  {
    "task": "Develop a program that simulates weather patterns and handles model prediction exceptions.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\ntype WeatherModel struct{}\n\nfunc (wm WeatherModel) Predict() (string, error) {\n\trand.Seed(time.Now().UnixNano())\n\tif rand.Float32() < 0.2 {\n\t\treturn \"\", errors.New(\"model prediction error\")\n\t}\n\tweatherPatterns := []string{\"Sunny\", \"Rainy\", \"Cloudy\", \"Stormy\"}\n\treturn weatherPatterns[rand.Intn(len(weatherPatterns))], nil\n}\n\nfunc main() {\n\tmodel := WeatherModel{}\n\tfor i := 0; i < 10; i++ {\n\t\tweather, err := model.Predict()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error predicting weather:\", err)\n\t\t} else {\n\t\t\tfmt.Println(\"Predicted weather:\", weather)\n\t\t}\n\t\ttime.Sleep(time.Second)\n\t}\n}\n```"
  },
  {
    "task": "Design a function that manages API versioning and handles backward compatibility exceptions.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\ntype APIError struct {\n\tMessage string\n}\n\nfunc (e *APIError) Error() string {\n\treturn e.Message\n}\n\nfunc handleAPIVersion(version string) (string, error) {\n\tswitch version {\n\tcase \"v1\":\n\t\treturn \"Handling version 1\", nil\n\tcase \"v2\":\n\t\treturn \"Handling version 2\", nil\n\tdefault:\n\t\treturn \"\", &APIError{Message: \"Unsupported API version: \" + version}\n\t}\n}\n\nfunc main() {\n\tversion := \"v3\"\n\tresult, err := handleAPIVersion(version)\n\tif err != nil {\n\t\tif apiErr, ok := err.(*APIError); ok {\n\t\t\tfmt.Println(\"API Error:\", apiErr.Error())\n\t\t} else {\n\t\t\tfmt.Println(\"Unknown error:\", err)\n\t\t}\n\t} else {\n\t\tfmt.Println(result)\n\t}\n}\n```"
  },
  {
    "task": "Write a tool that converts character encodings and handles unsupported encoding exceptions.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"golang.org/x/text/encoding/charmap\"\n\t\"golang.org/x/text/encoding\"\n\t\"golang.org/x/text/transform\"\n\t\"io/ioutil\"\n\t\"strings\"\n)\n\nfunc convertEncoding(input string, fromEncoding, toEncoding encoding.Encoding) (string, error) {\n\t// Decode from the source encoding\n\tdecoder := transform.NewReader(strings.NewReader(input), fromEncoding.NewDecoder())\n\tdecoded, err := ioutil.ReadAll(decoder)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"unsupported source encoding: %v\", err)\n\t}\n\n\t// Encode to the target encoding\n\tencoder := transform.NewReader(strings.NewReader(string(decoded)), toEncoding.NewEncoder())\n\tencoded, err := ioutil.ReadAll(encoder)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"unsupported target encoding: %v\", err)\n\t}\n\n\treturn string(encoded), nil\n}\n\nfunc main() {\n\tinput := \"Example text\"\n\n\t// Example: Convert from ISO 8859-1 to Windows 1252\n\tfromEncoding := charmap.ISO8859_1\n\ttoEncoding := charmap.Windows1252\n\n\tconvertedText, err := convertEncoding(input, fromEncoding, toEncoding)\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t} else {\n\t\tfmt.Println(\"Converted text:\", convertedText)\n\t}\n}\n```"
  },
  {
    "task": "Create a program that handles dynamic content generation and manages template parsing exceptions.",
    "code": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"html/template\"\n\t\"os\"\n)\n\nfunc main() {\n\ttmplStr := \"Hello, {{.Name}}!\"\n\ttmpl, err := template.New(\"greeting\").Parse(tmplStr)\n\tif err != nil {\n\t\tfmt.Println(\"Error parsing template:\", err)\n\t\treturn\n\t}\n\n\tdata := map[string]string{\n\t\t\"Name\": \"World\",\n\t}\n\n\terr = tmpl.Execute(os.Stdout, data)\n\tif err != nil {\n\t\tfmt.Println(\"Error executing template:\", err)\n\t}\n}\n```"
  },
  {
    "task": "Implement a script that schedules automated tests and handles exceptions for missing test cases.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\ttestCases := []string{\"test1\", \"test2\"} // Existing test cases\n\tscheduleTests(testCases)\n}\n\nfunc scheduleTests(testCases []string) {\n\tfor _, testCase := range testCases {\n\t\terr := runTest(testCase)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Error running %s: %v\\n\", testCase, err)\n\t\t} else {\n\t\t\tfmt.Printf(\"%s executed successfully.\\n\", testCase)\n\t\t}\n\t}\n}\n\nfunc runTest(testCase string) error {\n\tavailableTests := map[string]bool{\"test1\": true, \"test2\": true}\n\tif !availableTests[testCase] {\n\t\treturn errors.New(\"test case not found\")\n\t}\n\t// Simulate test execution\n\ttime.Sleep(time.Second)\n\treturn nil\n}\n```"
  },
  {
    "task": "Develop a system that manages virtual machine instances and handles provisioning exceptions.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\ntype VirtualMachine struct {\n\tID     string\n\tStatus string\n}\n\ntype VMManager struct {\n\tinstances map[string]VirtualMachine\n}\n\nfunc NewVMManager() *VMManager {\n\treturn &VMManager{\n\t\tinstances: make(map[string]VirtualMachine),\n\t}\n}\n\nfunc (vmm *VMManager) ProvisionVM(id string) error {\n\tif _, exists := vmm.instances[id]; exists {\n\t\treturn errors.New(\"VM already exists\")\n\t}\n\tvmm.instances[id] = VirtualMachine{ID: id, Status: \"Running\"}\n\tfmt.Printf(\"VM %s provisioned successfully.\\n\", id)\n\treturn nil\n}\n\nfunc (vmm *VMManager) HandleProvisioning(id string) {\n\terr := vmm.ProvisionVM(id)\n\tif err != nil {\n\t\tfmt.Printf(\"Error provisioning VM %s: %v\\n\", id, err)\n\t} else {\n\t\tfmt.Printf(\"VM %s is now active.\\n\", id)\n\t}\n}\n\nfunc main() {\n\tmanager := NewVMManager()\n\tmanager.HandleProvisioning(\"vm1\")\n\tmanager.HandleProvisioning(\"vm1\")\n}\n```"
  },
  {
    "task": "Write a function that processes credit scores and handles exceptions for missing credit history.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc processCreditScore(creditScores map[string]int, person string) (int, error) {\n\tscore, exists := creditScores[person]\n\tif !exists {\n\t\treturn 0, errors.New(\"missing credit history\")\n\t}\n\treturn score, nil\n}\n\nfunc main() {\n\tcreditScores := map[string]int{\n\t\t\"Alice\": 750,\n\t\t\"Bob\":   680,\n\t}\n\n\tscore, err := processCreditScore(creditScores, \"Charlie\")\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t} else {\n\t\tfmt.Println(\"Credit Score:\", score)\n\t}\n}\n```"
  },
  {
    "task": "Create a tool that manages digital certificates and handles expiration exceptions.",
    "code": "```go\npackage main\n\nimport (\n\t\"crypto/x509\"\n\t\"encoding/pem\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"time\"\n)\n\nfunc loadCertificate(certPath string) (*x509.Certificate, error) {\n\tcertPEM, err := os.ReadFile(certPath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tblock, _ := pem.Decode(certPEM)\n\tif block == nil || block.Type != \"CERTIFICATE\" {\n\t\treturn nil, errors.New(\"failed to decode PEM block containing certificate\")\n\t}\n\n\tcert, err := x509.ParseCertificate(block.Bytes)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn cert, nil\n}\n\nfunc checkCertificateExpiration(cert *x509.Certificate) error {\n\tif time.Now().After(cert.NotAfter) {\n\t\treturn errors.New(\"certificate has expired\")\n\t}\n\treturn nil\n}\n\nfunc main() {\n\tcertPath := \"path/to/certificate.pem\"\n\tcert, err := loadCertificate(certPath)\n\tif err != nil {\n\t\tfmt.Printf(\"Error loading certificate: %v\\n\", err)\n\t\treturn\n\t}\n\n\terr = checkCertificateExpiration(cert)\n\tif err != nil {\n\t\tfmt.Printf(\"Certificate error: %v\\n\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"Certificate is valid and not expired.\")\n}\n```"
  },
  {
    "task": "Design a program that processes genome sequences and handles exceptions for sequence alignment.",
    "code": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc main() {\n\tsequence1 := \"ACGTACGT\"\n\tsequence2 := \"ACGTAGCT\"\n\n\tdefer handleExceptions()\n\n\tresult, err := alignSequences(sequence1, sequence2)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Println(\"Aligned Sequences:\", result)\n}\n\nfunc alignSequences(seq1, seq2 string) (string, error) {\n\tif len(seq1) != len(seq2) {\n\t\treturn \"\", errors.New(\"sequences are not of equal length\")\n\t}\n\n\taligned := \"\"\n\tfor i := 0; i < len(seq1); i++ {\n\t\tif seq1[i] == seq2[i] {\n\t\t\taligned += string(seq1[i])\n\t\t} else {\n\t\t\taligned += \"-\"\n\t\t}\n\t}\n\treturn aligned, nil\n}\n\nfunc handleExceptions() {\n\tif r := recover(); r != nil {\n\t\tfmt.Println(\"Recovered from error:\", r)\n\t}\n}\n```"
  }
]