[
  {
    "task": "Write a function that reads a file and handles the exception if the file is not found.",
    "code": "```kotlin\nimport java.io.File\nimport java.io.FileNotFoundException\n\nfun readFile(fileName: String): String {\n    return try {\n        File(fileName).readText()\n    } catch (e: FileNotFoundException) {\n        \"File not found: $fileName\"\n    }\n}\n```"
  },
  {
    "task": "Create a program that divides two numbers and catches any division by zero errors.",
    "code": "```kotlin\nfun main() {\n    val numerator = 10\n    val denominator = 0\n\n    try {\n        val result = numerator / denominator\n        println(\"Result: $result\")\n    } catch (e: ArithmeticException) {\n        println(\"Error: Division by zero is not allowed.\")\n    }\n}\n```"
  },
  {
    "task": "Design a function to parse an integer from a string and manage invalid input exceptions.",
    "code": "```kotlin\nfun parseInteger(input: String): Int? {\n    return try {\n        input.toInt()\n    } catch (e: NumberFormatException) {\n        null\n    }\n}\n```"
  },
  {
    "task": "Implement an API call and catch exceptions related to network errors or timeouts.",
    "code": "```kotlin\nimport java.net.HttpURLConnection\nimport java.net.URL\nimport java.io.IOException\n\nfun makeApiCall(urlString: String): String {\n    return try {\n        val url = URL(urlString)\n        val connection = url.openConnection() as HttpURLConnection\n        connection.requestMethod = \"GET\"\n        \n        val responseCode = connection.responseCode\n        if (responseCode == HttpURLConnection.HTTP_OK) {\n            connection.inputStream.bufferedReader().use { it.readText() }\n        } else {\n            \"Error: $responseCode\"\n        }\n    } catch (e: IOException) {\n        \"Network error: ${e.message}\"\n    } catch (e: Exception) {\n        \"Unexpected error: ${e.message}\"\n    }\n}\n\nfun main() {\n    val response = makeApiCall(\"http://example.com/api\")\n    println(response)\n}\n```"
  },
  {
    "task": "Develop a program that opens a database connection and handles any connection failure exceptions.",
    "code": "```kotlin\nimport java.sql.Connection\nimport java.sql.DriverManager\nimport java.sql.SQLException\n\nfun openDatabaseConnection(): Connection? {\n    val url = \"jdbc:yourdatabaseurl\"\n    val user = \"yourusername\"\n    val password = \"yourpassword\"\n    var connection: Connection? = null\n\n    try {\n        connection = DriverManager.getConnection(url, user, password)\n        println(\"Database connection successful\")\n    } catch (e: SQLException) {\n        println(\"Failed to connect to the database: ${e.message}\")\n    }\n\n    return connection\n}\n\nfun main() {\n    val connection = openDatabaseConnection()\n    // Use the connection if it's not null\n    connection?.close()\n}\n```"
  },
  {
    "task": "Write a function that accesses an array by index and catches out-of-bounds exceptions.",
    "code": "```kotlin\nfun accessArrayByIndex(array: Array<Int>, index: Int): Int? {\n    return try {\n        array[index]\n    } catch (e: ArrayIndexOutOfBoundsException) {\n        println(\"Index out of bounds: $index\")\n        null\n    }\n}\n```"
  },
  {
    "task": "Create a function that converts a string to a date object and manages format exceptions.",
    "code": "```kotlin\nimport java.text.ParseException\nimport java.text.SimpleDateFormat\nimport java.util.Date\n\nfun stringToDate(dateString: String): Date? {\n    val dateFormat = SimpleDateFormat(\"yyyy-MM-dd\")\n    return try {\n        dateFormat.parse(dateString)\n    } catch (e: ParseException) {\n        null\n    }\n}\n```"
  },
  {
    "task": "Design a program that writes data to a file and catches any file permission exceptions.",
    "code": "```kotlin\nimport java.io.File\nimport java.io.IOException\n\nfun writeFile(fileName: String, data: String) {\n    try {\n        File(fileName).writeText(data)\n        println(\"Data successfully written to $fileName\")\n    } catch (e: IOException) {\n        println(\"An error occurred while writing to the file: ${e.message}\")\n    } catch (e: SecurityException) {\n        println(\"Permission denied: ${e.message}\")\n    }\n}\n\nfun main() {\n    val fileName = \"example.txt\"\n    val data = \"Hello, World!\"\n    writeFile(fileName, data)\n}\n```"
  },
  {
    "task": "Implement a module that retrieves data from a URL and handles malformed URL exceptions.",
    "code": "```kotlin\nimport java.net.MalformedURLException\nimport java.net.URL\n\nfun fetchDataFromUrl(urlString: String): String? {\n    return try {\n        val url = URL(urlString)\n        url.readText()\n    } catch (e: MalformedURLException) {\n        println(\"Malformed URL: ${e.message}\")\n        null\n    }\n}\n\nfun main() {\n    val data = fetchDataFromUrl(\"http://example.com\")\n    println(data ?: \"No data retrieved.\")\n}\n```"
  },
  {
    "task": "Write a function to calculate the square root of a number and catch any negative input exceptions.",
    "code": "```kotlin\nimport kotlin.math.sqrt\n\nfun calculateSquareRoot(value: Double): Double {\n    return try {\n        if (value < 0) {\n            throw IllegalArgumentException(\"Cannot calculate square root of a negative number\")\n        }\n        sqrt(value)\n    } catch (e: IllegalArgumentException) {\n        println(e.message)\n        Double.NaN\n    }\n}\n\nfun main() {\n    println(calculateSquareRoot(9.0))  // Output: 3.0\n    println(calculateSquareRoot(-4.0)) // Output: NaN\n}\n```"
  },
  {
    "task": "Develop a program that sends an email and manages exceptions for invalid email addresses.",
    "code": "```kotlin\nimport java.util.regex.Pattern\n\nfun sendEmail(to: String, subject: String, body: String) {\n    try {\n        if (!isValidEmail(to)) {\n            throw IllegalArgumentException(\"Invalid email address: $to\")\n        }\n        // Simulate sending email\n        println(\"Email sent to $to with subject: $subject\")\n    } catch (e: IllegalArgumentException) {\n        println(\"Error: ${e.message}\")\n    }\n}\n\nfun isValidEmail(email: String): Boolean {\n    val emailRegex = \"^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+$\"\n    val pattern = Pattern.compile(emailRegex)\n    return pattern.matcher(email).matches()\n}\n\nfun main() {\n    sendEmail(\"example@example.com\", \"Hello\", \"This is a test email.\")\n    sendEmail(\"invalid-email\", \"Hello\", \"This is a test email.\")\n}\n```"
  },
  {
    "task": "Create a calculator application that handles invalid operations gracefully.",
    "code": "```kotlin\nfun main() {\n    val calculator = Calculator()\n    \n    try {\n        println(\"Addition: ${calculator.add(10, 5)}\")\n        println(\"Subtraction: ${calculator.subtract(10, 5)}\")\n        println(\"Multiplication: ${calculator.multiply(10, 5)}\")\n        println(\"Division: ${calculator.divide(10, 0)}\")\n    } catch (e: ArithmeticException) {\n        println(\"Error: ${e.message}\")\n    } catch (e: IllegalArgumentException) {\n        println(\"Error: ${e.message}\")\n    }\n}\n\nclass Calculator {\n    \n    fun add(a: Int, b: Int): Int = a + b\n    \n    fun subtract(a: Int, b: Int): Int = a - b\n    \n    fun multiply(a: Int, b: Int): Int = a * b\n    \n    fun divide(a: Int, b: Int): Int {\n        if (b == 0) {\n            throw ArithmeticException(\"Cannot divide by zero\")\n        }\n        return a / b\n    }\n}\n```"
  },
  {
    "task": "Design a function that tries to parse JSON data and catches parsing errors.",
    "code": "```kotlin\nimport org.json.JSONException\nimport org.json.JSONObject\n\nfun parseJsonData(jsonString: String): JSONObject? {\n    return try {\n        JSONObject(jsonString)\n    } catch (e: JSONException) {\n        println(\"Failed to parse JSON data: ${e.message}\")\n        null\n    }\n}\n```"
  },
  {
    "task": "Implement a system that processes user input and handles any type conversion exceptions.",
    "code": "```kotlin\nfun main() {\n    println(\"Enter a number:\")\n    val userInput = readLine()\n\n    try {\n        val number = userInput?.toInt()\n        println(\"You entered the number: $number\")\n    } catch (e: NumberFormatException) {\n        println(\"Invalid input! Please enter a valid number.\")\n    }\n}\n```"
  },
  {
    "task": "Write a function that fetches data from a database and manages exceptions for missing records.",
    "code": "```kotlin\nfun fetchDataFromDatabase(id: Int): String {\n    return try {\n        // Simulate fetching data from a database\n        val data = fetchDataById(id)\n        data ?: throw NoSuchElementException(\"No record found for ID: $id\")\n    } catch (e: NoSuchElementException) {\n        \"Error: ${e.message}\"\n    } catch (e: Exception) {\n        \"An unexpected error occurred: ${e.message}\"\n    }\n}\n\nfun fetchDataById(id: Int): String? {\n    // Simulated database records\n    val database = mapOf(1 to \"Record 1\", 2 to \"Record 2\")\n    return database[id]\n}\n```"
  },
  {
    "task": "Create a program that connects to a remote server and handles authentication failure exceptions.",
    "code": "```kotlin\nimport java.net.HttpURLConnection\nimport java.net.URL\n\nfun connectToServer(urlString: String) {\n    try {\n        val url = URL(urlString)\n        val connection = url.openConnection() as HttpURLConnection\n        connection.requestMethod = \"GET\"\n        val responseCode = connection.responseCode\n        \n        if (responseCode == HttpURLConnection.HTTP_UNAUTHORIZED) {\n            throw AuthenticationException(\"Authentication failed with response code: $responseCode\")\n        }\n        \n        println(\"Connected successfully with response code: $responseCode\")\n    } catch (e: AuthenticationException) {\n        println(\"Error: ${e.message}\")\n    } catch (e: Exception) {\n        println(\"An error occurred: ${e.message}\")\n    }\n}\n\nclass AuthenticationException(message: String) : Exception(message)\n\nfun main() {\n    val serverUrl = \"http://example.com\"\n    connectToServer(serverUrl)\n}\n```"
  },
  {
    "task": "Develop a function to download a file from the internet and handle file not found exceptions.",
    "code": "```kotlin\nimport java.net.URL\nimport java.io.File\nimport java.io.IOException\n\nfun downloadFile(url: String, destinationPath: String) {\n    try {\n        val website = URL(url)\n        website.openStream().use { input ->\n            File(destinationPath).outputStream().use { output ->\n                input.copyTo(output)\n            }\n        }\n        println(\"File downloaded successfully.\")\n    } catch (e: IOException) {\n        println(\"An error occurred: ${e.message}\")\n    }\n}\n\nfun main() {\n    val url = \"https://example.com/file.txt\"\n    val destinationPath = \"downloadedFile.txt\"\n    downloadFile(url, destinationPath)\n}\n```"
  },
  {
    "task": "Design a program that attempts to connect to an API and handles rate limit exceptions.",
    "code": "```kotlin\nimport java.net.HttpURLConnection\nimport java.net.URL\nimport java.io.IOException\n\nfun connectToAPI(apiUrl: String) {\n    try {\n        val url = URL(apiUrl)\n        val connection = url.openConnection() as HttpURLConnection\n        connection.requestMethod = \"GET\"\n        val responseCode = connection.responseCode\n\n        if (responseCode == 429) {\n            throw RateLimitException(\"Rate limit exceeded. Please try again later.\")\n        } else {\n            println(\"Connected successfully with response code: $responseCode\")\n        }\n    } catch (e: RateLimitException) {\n        println(\"Error: ${e.message}\")\n    } catch (e: IOException) {\n        println(\"Error: Unable to connect to the API. ${e.message}\")\n    }\n}\n\nclass RateLimitException(message: String) : Exception(message)\n\nfun main() {\n    val apiUrl = \"https://api.example.com/data\"\n    connectToAPI(apiUrl)\n}\n```"
  },
  {
    "task": "Write a function that reads from a configuration file and manages key not found exceptions.",
    "code": "```kotlin\nimport java.io.File\nimport java.io.IOException\n\nfun readConfigValue(filePath: String, key: String): String? {\n    return try {\n        val lines = File(filePath).readLines()\n        val configMap = lines.mapNotNull { line ->\n            val parts = line.split(\"=\")\n            if (parts.size == 2) parts[0].trim() to parts[1].trim() else null\n        }.toMap()\n        \n        configMap[key] ?: throw KeyNotFoundException(\"Key '$key' not found in configuration.\")\n    } catch (e: IOException) {\n        println(\"Error reading file: ${e.message}\")\n        null\n    } catch (e: KeyNotFoundException) {\n        println(e.message)\n        null\n    }\n}\n\nclass KeyNotFoundException(message: String) : Exception(message)\n\n// Example usage\nfun main() {\n    val value = readConfigValue(\"config.txt\", \"desiredKey\")\n    println(\"Value: $value\")\n}\n```"
  },
  {
    "task": "Create an application that processes a list of tasks and catches any task execution exceptions.",
    "code": "```kotlin\nfun main() {\n    val tasks = listOf(\n        { println(\"Task 1 executed successfully\") },\n        { throw Exception(\"Task 2 failed\") },\n        { println(\"Task 3 executed successfully\") }\n    )\n\n    tasks.forEachIndexed { index, task ->\n        try {\n            task.invoke()\n        } catch (e: Exception) {\n            println(\"Exception caught during execution of task ${index + 1}: ${e.message}\")\n        }\n    }\n}\n```"
  },
  {
    "task": "Implement a program that performs batch processing and handles individual item processing exceptions.",
    "code": "```kotlin\nfun main() {\n    val items = listOf(\"item1\", \"item2\", \"item3\", \"badItem\", \"item4\")\n    processBatch(items)\n}\n\nfun processBatch(items: List<String>) {\n    items.forEach { item ->\n        try {\n            processItem(item)\n        } catch (e: Exception) {\n            println(\"Error processing $item: ${e.message}\")\n        }\n    }\n}\n\nfun processItem(item: String) {\n    if (item == \"badItem\") {\n        throw IllegalArgumentException(\"Invalid item encountered\")\n    }\n    println(\"Processed $item successfully\")\n}\n```"
  },
  {
    "task": "Develop a function that performs mathematical operations and catches arithmetic exceptions.",
    "code": "```kotlin\nfun performOperation(a: Int, b: Int, operation: Char): Int? {\n    return try {\n        when (operation) {\n            '+' -> a + b\n            '-' -> a - b\n            '*' -> a * b\n            '/' -> a / b\n            else -> throw IllegalArgumentException(\"Invalid operation\")\n        }\n    } catch (e: ArithmeticException) {\n        println(\"Arithmetic error: ${e.message}\")\n        null\n    } catch (e: IllegalArgumentException) {\n        println(\"Error: ${e.message}\")\n        null\n    }\n}\n\nfun main() {\n    println(performOperation(10, 0, '/'))\n    println(performOperation(10, 5, '+'))\n    println(performOperation(10, 5, 'x'))\n}\n```"
  },
  {
    "task": "Write a program that logs error messages when exceptions occur during data processing.",
    "code": "```kotlin\nimport java.io.FileWriter\nimport java.io.IOException\n\nfun processData(data: List<String>) {\n    for (item in data) {\n        try {\n            // Simulating data processing that can throw an exception\n            if (item == \"error\") {\n                throw IllegalArgumentException(\"Invalid data encountered\")\n            }\n            println(\"Processing item: $item\")\n        } catch (e: Exception) {\n            logError(\"Error processing item: ${e.message}\")\n        }\n    }\n}\n\nfun logError(message: String) {\n    try {\n        FileWriter(\"error_log.txt\", true).use { writer ->\n            writer.write(\"$message\\n\")\n        }\n    } catch (e: IOException) {\n        println(\"Failed to write to log: ${e.message}\")\n    }\n}\n\nfun main() {\n    val data = listOf(\"item1\", \"item2\", \"error\", \"item3\")\n    processData(data)\n}\n```"
  },
  {
    "task": "Create a script that monitors system resources and handles exceptions when limits are exceeded.",
    "code": "```kotlin\nimport java.lang.Exception\n\nfun checkCpuUsage(limit: Double): Double {\n    // Dummy function to simulate CPU usage retrieval\n    return Math.random() * 100\n}\n\nfun checkMemoryUsage(limit: Double): Double {\n    // Dummy function to simulate Memory usage retrieval\n    return Math.random() * 100\n}\n\nfun monitorSystemResources(cpuLimit: Double, memoryLimit: Double) {\n    try {\n        val cpuUsage = checkCpuUsage(cpuLimit)\n        if (cpuUsage > cpuLimit) {\n            throw Exception(\"CPU usage exceeded limit: $cpuUsage%\")\n        }\n        val memoryUsage = checkMemoryUsage(memoryLimit)\n        if (memoryUsage > memoryLimit) {\n            throw Exception(\"Memory usage exceeded limit: $memoryUsage%\")\n        }\n        println(\"System resources within limits: CPU $cpuUsage%, Memory $memoryUsage%\")\n    } catch (e: Exception) {\n        println(\"Exception occurred: ${e.message}\")\n    }\n}\n\nfun main() {\n    val cpuLimit = 75.0 // Set CPU usage limit\n    val memoryLimit = 75.0 // Set Memory usage limit\n\n    monitorSystemResources(cpuLimit, memoryLimit)\n}\n```"
  },
  {
    "task": "Design a function that validates user input and manages any format exceptions.",
    "code": "```kotlin\nfun validateUserInput(input: String): Boolean {\n    return try {\n        val number = input.toInt()\n        number >= 0 // example condition for validation\n    } catch (e: NumberFormatException) {\n        println(\"Invalid format: ${e.message}\")\n        false\n    }\n}\n\nfun main() {\n    val input = readLine() ?: \"\"\n    if (validateUserInput(input)) {\n        println(\"Valid input.\")\n    } else {\n        println(\"Invalid input.\")\n    }\n}\n```"
  },
  {
    "task": "Implement a service that interacts with third-party APIs and handles unexpected response exceptions.",
    "code": "```kotlin\nimport java.io.IOException\n\nclass ApiService {\n\n    fun fetchDataFromApi(apiUrl: String): String {\n        return try {\n            // Simulating an API call\n            val response = makeApiCall(apiUrl)\n            response\n        } catch (e: IOException) {\n            handleApiException(e)\n            \"Error: Unable to fetch data\"\n        }\n    }\n\n    private fun makeApiCall(apiUrl: String): String {\n        // Simulating a successful response\n        if (apiUrl == \"https://valid.api/resource\") {\n            return \"Success: Data fetched\"\n        } else {\n            throw IOException(\"Invalid API URL\")\n        }\n    }\n\n    private fun handleApiException(exception: IOException) {\n        println(\"Exception occurred: ${exception.message}\")\n        // Log the exception or perform other error handling actions here\n    }\n}\n\nfun main() {\n    val apiService = ApiService()\n    val validResponse = apiService.fetchDataFromApi(\"https://valid.api/resource\")\n    println(validResponse)\n\n    val errorResponse = apiService.fetchDataFromApi(\"https://invalid.api/resource\")\n    println(errorResponse)\n}\n```"
  },
  {
    "task": "Write a function that uploads files to a server and handles exceptions for unsupported file types.",
    "code": "```kotlin\nfun uploadFile(fileName: String): String {\n    return try {\n        if (!isSupportedFileType(fileName)) {\n            throw UnsupportedFileTypeException(\"Unsupported file type: $fileName\")\n        }\n        // Simulate file upload\n        \"File $fileName uploaded successfully\"\n    } catch (e: UnsupportedFileTypeException) {\n        e.message ?: \"An error occurred\"\n    }\n}\n\nfun isSupportedFileType(fileName: String): Boolean {\n    val supportedExtensions = listOf(\"jpg\", \"png\", \"txt\", \"pdf\")\n    val fileExtension = fileName.substringAfterLast('.', \"\")\n    return supportedExtensions.contains(fileExtension)\n}\n\nclass UnsupportedFileTypeException(message: String) : Exception(message)\n```"
  },
  {
    "task": "Create a program that simulates network traffic and manages packet loss exceptions.",
    "code": "```kotlin\nimport kotlin.random.Random\n\nclass NetworkException(message: String) : Exception(message)\n\nfun simulateNetworkTraffic() {\n    val random = Random(System.currentTimeMillis())\n    repeat(10) {\n        try {\n            if (random.nextInt(100) < 20) { // 20% chance of packet loss\n                throw NetworkException(\"Packet lost during network transmission.\")\n            } else {\n                println(\"Packet transmitted successfully.\")\n            }\n        } catch (e: NetworkException) {\n            println(\"Exception Caught: ${e.message}\")\n        }\n    }\n}\n\nfun main() {\n    simulateNetworkTraffic()\n}\n```"
  },
  {
    "task": "Develop a function that processes XML data and catches any structural exceptions.",
    "code": "```kotlin\nimport org.w3c.dom.Document\nimport javax.xml.parsers.DocumentBuilderFactory\nimport java.io.StringReader\nimport org.xml.sax.InputSource\nimport javax.xml.parsers.ParserConfigurationException\nimport org.xml.sax.SAXException\nimport java.io.IOException\n\nfun processXmlData(xmlData: String) {\n    try {\n        val factory = DocumentBuilderFactory.newInstance()\n        val builder = factory.newDocumentBuilder()\n        val inputSource = InputSource(StringReader(xmlData))\n        val document: Document = builder.parse(inputSource)\n        \n        // Process the XML document here\n        \n    } catch (e: ParserConfigurationException) {\n        println(\"Parser configuration error: ${e.message}\")\n    } catch (e: SAXException) {\n        println(\"SAX error: ${e.message}\")\n    } catch (e: IOException) {\n        println(\"IO error: ${e.message}\")\n    } catch (e: Exception) {\n        println(\"General error: ${e.message}\")\n    }\n}\n```"
  },
  {
    "task": "Design a program that handles exceptions when accessing environment variables.",
    "code": "```kotlin\nfun main() {\n    val envVarName = \"MY_ENV_VAR\"\n    try {\n        val envVarValue = System.getenv(envVarName) ?: throw Exception(\"Environment variable $envVarName not found.\")\n        println(\"Value of $envVarName: $envVarValue\")\n    } catch (e: Exception) {\n        println(\"Error accessing environment variable: ${e.message}\")\n    }\n}\n```"
  },
  {
    "task": "Write a function that calculates factorial and manages exceptions for negative input values.",
    "code": "```kotlin\nfun calculateFactorial(n: Int): Long {\n    if (n < 0) throw IllegalArgumentException(\"Negative input: $n\")\n    return if (n == 0) 1 else n * calculateFactorial(n - 1)\n}\n\nfun main() {\n    try {\n        println(calculateFactorial(5))  // Output: 120\n        println(calculateFactorial(-2)) // Throws IllegalArgumentException\n    } catch (e: IllegalArgumentException) {\n        println(\"Exception caught: ${e.message}\")\n    }\n}\n```"
  },
  {
    "task": "Create a software tool that converts file formats and handles unsupported format exceptions.",
    "code": "```kotlin\nimport java.io.File\n\nclass UnsupportedFormatException(message: String) : Exception(message)\n\nclass FileConverter {\n    fun convertFile(inputFile: File, outputFormat: String): File {\n        val supportedFormats = listOf(\"txt\", \"pdf\", \"docx\")\n        if (outputFormat !in supportedFormats) {\n            throw UnsupportedFormatException(\"Format $outputFormat is not supported.\")\n        }\n        // Dummy implementation of file conversion\n        val outputFile = File(\"converted_file.$outputFormat\")\n        // Imagine conversion logic here\n        return outputFile\n    }\n}\n\nfun main() {\n    val fileConverter = FileConverter()\n    val inputFile = File(\"example.txt\")\n\n    try {\n        val outputFile = fileConverter.convertFile(inputFile, \"pdf\")\n        println(\"File converted successfully: ${outputFile.name}\")\n    } catch (e: UnsupportedFormatException) {\n        println(\"Error: ${e.message}\")\n    }\n}\n```"
  },
  {
    "task": "Implement a function that sends HTTP requests and catches exceptions for invalid response status codes.",
    "code": "```kotlin\nimport java.net.HttpURLConnection\nimport java.net.URL\n\nfun sendHttpRequest(urlString: String) {\n    try {\n        val url = URL(urlString)\n        val connection = url.openConnection() as HttpURLConnection\n        connection.requestMethod = \"GET\"\n        val responseCode = connection.responseCode\n\n        if (responseCode != HttpURLConnection.HTTP_OK) {\n            throw Exception(\"Invalid response status code: $responseCode\")\n        }\n\n        // Process the response\n        println(\"Response Code: $responseCode\")\n\n    } catch (e: Exception) {\n        println(\"An error occurred: ${e.message}\")\n    }\n}\n```"
  },
  {
    "task": "Develop a program that interacts with a message queue and handles message delivery exceptions.",
    "code": "```kotlin\nimport java.util.concurrent.LinkedBlockingQueue\n\nclass MessageQueue {\n    private val queue = LinkedBlockingQueue<String>()\n\n    fun sendMessage(message: String) {\n        queue.offer(message)\n    }\n\n    fun receiveMessage(): String? {\n        return queue.poll()\n    }\n}\n\nfun main() {\n    val messageQueue = MessageQueue()\n\n    try {\n        messageQueue.sendMessage(\"Hello, World!\")\n        val message = messageQueue.receiveMessage() ?: throw Exception(\"Failed to receive message\")\n        println(\"Received message: $message\")\n    } catch (e: Exception) {\n        println(\"Message delivery exception: ${e.message}\")\n    }\n}\n```"
  },
  {
    "task": "Write a function that reads user input and catches exceptions for unexpected data types.",
    "code": "```kotlin\nfun readUserInput() {\n    println(\"Enter a number:\")\n    try {\n        val input = readLine()\n        val number = input?.toInt() ?: throw IllegalArgumentException(\"Input cannot be null\")\n        println(\"You entered: $number\")\n    } catch (e: NumberFormatException) {\n        println(\"Invalid input. Please enter a valid number.\")\n    } catch (e: IllegalArgumentException) {\n        println(e.message)\n    }\n}\n\nfun main() {\n    readUserInput()\n}\n```"
  },
  {
    "task": "Create a system that processes transactions and manages exceptions for insufficient funds.",
    "code": "```kotlin\nclass InsufficientFundsException(message: String) : Exception(message)\n\nclass Account(private var balance: Double) {\n    fun processTransaction(amount: Double) {\n        try {\n            if (amount > balance) {\n                throw InsufficientFundsException(\"Insufficient funds for transaction\")\n            }\n            balance -= amount\n            println(\"Transaction successful. New balance: $balance\")\n        } catch (e: InsufficientFundsException) {\n            println(\"Transaction failed: ${e.message}\")\n        }\n    }\n}\n\nfun main() {\n    val account = Account(100.0)\n    account.processTransaction(150.0)\n    account.processTransaction(50.0)\n}\n```"
  },
  {
    "task": "Design a function that generates random numbers and handles exceptions when the range is invalid.",
    "code": "```kotlin\nimport kotlin.random.Random\n\nfun generateRandomNumber(min: Int, max: Int): Int {\n    return try {\n        if (min >= max) throw IllegalArgumentException(\"Invalid range: min should be less than max.\")\n        Random.nextInt(min, max)\n    } catch (e: IllegalArgumentException) {\n        println(\"Exception caught: ${e.message}\")\n        -1\n    }\n}\n\nfun main() {\n    println(generateRandomNumber(10, 5)) // Example of invalid range\n    println(generateRandomNumber(1, 10)) // Example of valid range\n}\n```"
  },
  {
    "task": "Implement a program that performs image processing and catches exceptions for unsupported file dimensions.",
    "code": "```kotlin\nimport java.lang.Exception\n\nclass UnsupportedDimensionException(message: String) : Exception(message)\n\nfun processImage(width: Int, height: Int) {\n    if (width <= 0 || height <= 0) {\n        throw UnsupportedDimensionException(\"Unsupported file dimensions: width and height must be positive\")\n    }\n    println(\"Processing image with dimensions: $width x $height\")\n}\n\nfun main() {\n    val images = listOf(Pair(1024, 768), Pair(1920, 1080), Pair(-500, 300))\n\n    for ((width, height) in images) {\n        try {\n            processImage(width, height)\n        } catch (e: UnsupportedDimensionException) {\n            println(\"Exception caught: ${e.message}\")\n        }\n    }\n}\n```"
  },
  {
    "task": "Write a function that manipulates strings and manages exceptions for invalid operations.",
    "code": "```kotlin\nfun manipulateString(input: String): String {\n    return try {\n        // Example operation: reverse the string\n        input.reversed()\n    } catch (e: Exception) {\n        \"An error occurred: ${e.message}\"\n    }\n}\n\nfun main() {\n    val validString = \"Hello, World!\"\n    println(manipulateString(validString))\n\n    // Example of invalid operation, using null\n    val invalidString: String? = null\n    println(manipulateString(invalidString ?: \"\"))\n}\n```"
  },
  {
    "task": "Create a script that automates tasks and handles exceptions for missing dependencies.",
    "code": "```kotlin\nfun main() {\n    try {\n        executeTask()\n    } catch (e: MissingDependencyException) {\n        println(\"Error: ${e.message}\")\n    }\n}\n\nfun executeTask() {\n    if (!checkDependencies()) {\n        throw MissingDependencyException(\"Required dependencies are missing.\")\n    }\n    println(\"Task executed successfully.\")\n}\n\nfun checkDependencies(): Boolean {\n    // Simulate a dependency check. Return false to simulate a missing dependency.\n    return false\n}\n\nclass MissingDependencyException(message: String) : Exception(message)\n```"
  },
  {
    "task": "Develop a function that accesses nested data structures and manages key access exceptions.",
    "code": "```kotlin\nfun accessNestedData(structure: Map<String, Any>, keys: List<String>): Any? {\n    var currentData: Any? = structure\n\n    try {\n        for (key in keys) {\n            currentData = (currentData as? Map<*, *>)?.get(key) ?: throw KeyNotFoundException(\"Key '$key' not found\")\n        }\n    } catch (e: KeyNotFoundException) {\n        println(e.message)\n        return null\n    } catch (e: Exception) {\n        println(\"An unexpected error occurred: ${e.message}\")\n        return null\n    }\n\n    return currentData\n}\n\nclass KeyNotFoundException(message: String) : Exception(message)\n\nfun main() {\n    val data = mapOf(\n        \"user\" to mapOf(\n            \"name\" to \"Alice\",\n            \"address\" to mapOf(\n                \"city\" to \"Wonderland\"\n            )\n        )\n    )\n\n    println(accessNestedData(data, listOf(\"user\", \"address\", \"city\")))\n    println(accessNestedData(data, listOf(\"user\", \"age\")))\n}\n```"
  },
  {
    "task": "Design a program that synchronizes data between sources and handles data mismatch exceptions.",
    "code": "```kotlin\nimport java.lang.Exception\n\n// Custom exception class for data mismatch\nclass DataMismatchException(message: String) : Exception(message)\n\n// Function to simulate data synchronization between two sources\nfun synchronizeData(source1: List<String>, source2: List<String>) {\n    try {\n        if (source1.size != source2.size) {\n            throw DataMismatchException(\"Data size mismatch between sources.\")\n        }\n        for (i in source1.indices) {\n            if (source1[i] != source2[i]) {\n                throw DataMismatchException(\"Data mismatch at index $i: ${source1[i]} != ${source2[i]}\")\n            }\n        }\n        println(\"Data synchronized successfully.\")\n    } catch (e: DataMismatchException) {\n        println(\"Error: ${e.message}\")\n    }\n}\n\nfun main() {\n    val source1 = listOf(\"data1\", \"data2\", \"data3\")\n    val source2 = listOf(\"data1\", \"data2\", \"data4\") // Intentional mismatch\n\n    synchronizeData(source1, source2)\n}\n```"
  },
  {
    "task": "Write a function that interacts with hardware devices and handles connection failure exceptions.",
    "code": "```kotlin\nfun interactWithHardwareDevice() {\n    try {\n        // Simulate hardware device interaction\n        println(\"Connecting to hardware device...\")\n        // Code that may throw a connection failure exception\n        throw ConnectionFailureException(\"Failed to connect to the hardware device.\")\n    } catch (e: ConnectionFailureException) {\n        println(\"Exception caught: ${e.message}\")\n    }\n}\n\nclass ConnectionFailureException(message: String) : Exception(message)\n\nfun main() {\n    interactWithHardwareDevice()\n}\n```"
  },
  {
    "task": "Create a tool that compresses files and manages exceptions for unsupported compression formats.",
    "code": "```kotlin\nimport java.io.File\nimport java.io.IOException\nimport java.util.zip.ZipEntry\nimport java.util.zip.ZipOutputStream\n\nfun compressFile(inputFilePath: String, outputFilePath: String, format: String) {\n    try {\n        if (format != \"zip\") {\n            throw UnsupportedOperationException(\"Compression format $format is not supported.\")\n        }\n\n        val fileToZip = File(inputFilePath)\n        val fos = File(outputFilePath).outputStream()\n        val zos = ZipOutputStream(fos)\n\n        FileInputStream(fileToZip).use { fis ->\n            val zipEntry = ZipEntry(fileToZip.name)\n            zos.putNextEntry(zipEntry)\n\n            fis.copyTo(zos, 1024)\n            zos.closeEntry()\n        }\n        zos.close()\n        println(\"File compressed successfully to $outputFilePath\")\n    } catch (e: IOException) {\n        println(\"IO Exception occurred: ${e.message}\")\n    } catch (e: UnsupportedOperationException) {\n        println(\"Exception: ${e.message}\")\n    }\n}\n\nfun main() {\n    val inputFilePath = \"example.txt\"\n    val outputFilePath = \"example.zip\"\n    val format = \"zip\"\n    compressFile(inputFilePath, outputFilePath, format)\n}\n```"
  },
  {
    "task": "Implement a function that parses command-line arguments and handles missing argument exceptions.",
    "code": "```kotlin\nfun main(args: Array<String>) {\n    try {\n        if (args.isEmpty()) {\n            throw IllegalArgumentException(\"No command-line arguments provided.\")\n        }\n        for (arg in args) {\n            println(\"Argument: $arg\")\n        }\n    } catch (e: IllegalArgumentException) {\n        println(\"Error: ${e.message}\")\n    }\n}\n```"
  },
  {
    "task": "Develop a program that simulates user interactions and manages timing exceptions.",
    "code": "```kotlin\nimport java.util.*\n\nfun simulateUserInteraction() {\n    try {\n        val scanner = Scanner(System.`in`)\n        println(\"Enter a delay in milliseconds:\")\n        val delay = scanner.nextLong()\n\n        if (delay < 0) {\n            throw IllegalArgumentException(\"Delay cannot be negative\")\n        }\n\n        println(\"Simulating user interaction with a delay of $delay ms...\")\n        Thread.sleep(delay)\n        println(\"User interaction simulation complete.\")\n\n    } catch (e: IllegalArgumentException) {\n        println(\"Exception: ${e.message}\")\n    } catch (e: InterruptedException) {\n        println(\"Exception: The sleep was interrupted.\")\n    } catch (e: InputMismatchException) {\n        println(\"Exception: Invalid input. Please enter a valid number.\")\n    } finally {\n        println(\"Simulation ended.\")\n    }\n}\n\nfun main() {\n    simulateUserInteraction()\n}\n```"
  },
  {
    "task": "Write a function that encrypts data and handles exceptions for unsupported encryption algorithms.",
    "code": "```kotlin\nimport java.security.InvalidAlgorithmParameterException\nimport javax.crypto.Cipher\nimport javax.crypto.KeyGenerator\nimport javax.crypto.SecretKey\nimport javax.crypto.spec.IvParameterSpec\n\nfun encryptData(data: String, algorithm: String): ByteArray? {\n    return try {\n        // Create a KeyGenerator for the specified algorithm\n        val keyGen: KeyGenerator = KeyGenerator.getInstance(algorithm)\n        val secretKey: SecretKey = keyGen.generateKey()\n        \n        // Initialize Cipher\n        val cipher: Cipher = Cipher.getInstance(\"$algorithm/CBC/PKCS5Padding\")\n        val iv = ByteArray(cipher.blockSize)\n        val ivSpec = IvParameterSpec(iv)\n        cipher.init(Cipher.ENCRYPT_MODE, secretKey, ivSpec)\n        \n        // Encrypt data\n        cipher.doFinal(data.toByteArray())\n    } catch (e: InvalidAlgorithmParameterException) {\n        println(\"Error: Invalid algorithm parameters - ${e.message}\")\n        null\n    } catch (e: Exception) {\n        println(\"Encryption error: ${e.message}\")\n        null\n    }\n}\n```"
  },
  {
    "task": "Create a system that aggregates data and manages exceptions for data inconsistency.",
    "code": "```kotlin\nfun main() {\n    val dataAggregator = DataAggregator()\n\n    try {\n        dataAggregator.addData(\"key1\", 100)\n        dataAggregator.addData(\"key2\", 200)\n        dataAggregator.addData(\"key1\", 300) // This should cause an inconsistency error\n    } catch (e: DataInconsistencyException) {\n        println(\"Exception caught: ${e.message}\")\n    }\n\n    dataAggregator.displayData()\n}\n\nclass DataAggregator {\n    private val dataMap = mutableMapOf<String, Int>()\n\n    fun addData(key: String, value: Int) {\n        if (dataMap.containsKey(key)) {\n            throw DataInconsistencyException(\"Data inconsistency: Key $key already exists.\")\n        }\n        dataMap[key] = value\n    }\n\n    fun displayData() {\n        for ((key, value) in dataMap) {\n            println(\"$key: $value\")\n        }\n    }\n}\n\nclass DataInconsistencyException(message: String) : Exception(message)\n```"
  },
  {
    "task": "Design a program that processes real-time data streams and handles connection drop exceptions.",
    "code": "```kotlin\nimport java.io.IOException\n\nfun processDataStream() {\n    try {\n        // Simulate establishing a connection to a data stream\n        val connection = establishConnection()\n        \n        // Simulate processing real-time data\n        while (connection.isConnected) {\n            val data = connection.receiveData()\n            println(\"Received data: $data\")\n        }\n    } catch (e: ConnectionDroppedException) {\n        println(\"Connection dropped: ${e.message}\")\n        // Handle reconnection logic or cleanup\n    } catch (e: IOException) {\n        println(\"IO error occurred: ${e.message}\")\n    } finally {\n        println(\"Finalizing processing.\")\n    }\n}\n\nfun establishConnection(): Connection {\n    // Simulate connection establishment\n    return Connection()\n}\n\nclass Connection {\n    val isConnected: Boolean = true\n    \n    fun receiveData(): String {\n        // Simulate data reception\n        return \"Sample Data\"\n    }\n}\n\nclass ConnectionDroppedException(message: String) : Exception(message)\n\nfun main() {\n    processDataStream()\n}\n```"
  },
  {
    "task": "Implement a function that performs scientific calculations and manages precision exceptions.",
    "code": "```kotlin\nimport java.math.BigDecimal\nimport java.math.MathContext\n\nfun performScientificCalculation(value: String): BigDecimal {\n    return try {\n        val bigDecimalValue = BigDecimal(value)\n        val result = bigDecimalValue.pow(2, MathContext.DECIMAL128)\n        result\n    } catch (e: ArithmeticException) {\n        println(\"Precision error occurred: ${e.message}\")\n        BigDecimal.ZERO\n    } catch (e: NumberFormatException) {\n        println(\"Invalid number format: ${e.message}\")\n        BigDecimal.ZERO\n    }\n}\n\nfun main() {\n    val result = performScientificCalculation(\"123456789.123456789\")\n    println(\"Calculation result: $result\")\n}\n```"
  },
  {
    "task": "Write a script that generates reports and handles exceptions for missing data sources.",
    "code": "```kotlin\nfun generateReport(dataSource: String): String {\n    if (dataSource.isEmpty()) {\n        throw IllegalArgumentException(\"Missing data source\")\n    }\n    // Simulate report generation\n    return \"Report generated successfully for $dataSource\"\n}\n\nfun main() {\n    val dataSources = listOf(\"DataSource1\", \"\", \"DataSource3\")\n\n    for (dataSource in dataSources) {\n        try {\n            val report = generateReport(dataSource)\n            println(report)\n        } catch (e: IllegalArgumentException) {\n            println(\"Error: ${e.message}\")\n        }\n    }\n}\n```"
  },
  {
    "task": "Create a program that validates digital certificates and manages trust exceptions.",
    "code": "```kotlin\nimport java.security.cert.CertificateException\nimport java.security.cert.X509Certificate\nimport javax.net.ssl.TrustManager\nimport javax.net.ssl.X509TrustManager\n\nclass CertificateValidator : X509TrustManager {\n    @Throws(CertificateException::class)\n    override fun checkClientTrusted(chain: Array<X509Certificate>, authType: String) {\n        // Implement logic to validate client certificates\n        if (chain.isEmpty() || authType.isBlank()) {\n            throw CertificateException(\"Client certificate validation failed.\")\n        }\n    }\n\n    @Throws(CertificateException::class)\n    override fun checkServerTrusted(chain: Array<X509Certificate>, authType: String) {\n        // Implement logic to validate server certificates\n        if (chain.isEmpty() || authType.isBlank()) {\n            throw CertificateException(\"Server certificate validation failed.\")\n        }\n    }\n\n    override fun getAcceptedIssuers(): Array<X509Certificate> {\n        // Return a list of trusted certificate authorities\n        return arrayOf()\n    }\n}\n\nfun main() {\n    val trustManagers: Array<TrustManager> = arrayOf(CertificateValidator())\n\n    try {\n        // Example of how the trust manager might be used\n        val certChain = arrayOf<X509Certificate>() // Example certificate chain\n        val authType = \"RSA\" // Example auth type\n\n        trustManagers.forEach { manager ->\n            if (manager is X509TrustManager) {\n                manager.checkServerTrusted(certChain, authType)\n            }\n        }\n        println(\"Certificate validation passed.\")\n    } catch (e: CertificateException) {\n        println(\"Certificate validation failed: ${e.message}\")\n    } catch (e: Exception) {\n        println(\"Unexpected error: ${e.message}\")\n    }\n}\n```"
  },
  {
    "task": "Develop a function that schedules tasks and handles exceptions for scheduling conflicts.",
    "code": "```kotlin\nimport java.util.*\n\nclass Scheduler {\n    private val scheduledTasks = mutableListOf<String>()\n\n    fun scheduleTask(task: String): Boolean {\n        return try {\n            if (scheduledTasks.contains(task)) {\n                throw SchedulingConflictException(\"Task '$task' is already scheduled.\")\n            }\n            scheduledTasks.add(task)\n            println(\"Task '$task' scheduled successfully.\")\n            true\n        } catch (e: SchedulingConflictException) {\n            println(\"Failed to schedule task: ${e.message}\")\n            false\n        }\n    }\n}\n\nclass SchedulingConflictException(message: String) : Exception(message)\n\nfun main() {\n    val scheduler = Scheduler()\n    scheduler.scheduleTask(\"Task 1\")\n    scheduler.scheduleTask(\"Task 2\")\n    scheduler.scheduleTask(\"Task 1\") // This will raise a scheduling conflict\n}\n```"
  },
  {
    "task": "Design a system that manages user sessions and handles session timeout exceptions.",
    "code": "```kotlin\nimport java.time.LocalDateTime\nimport java.util.*\n\nclass Session(val userId: String, val sessionId: String, val startTime: LocalDateTime) {\n    var lastAccessTime: LocalDateTime = startTime\n}\n\nclass SessionTimeoutException(message: String) : Exception(message)\n\nclass SessionManager(private val sessionTimeoutMinutes: Long) {\n    private val sessions = mutableMapOf<String, Session>()\n\n    fun createSession(userId: String): String {\n        val sessionId = UUID.randomUUID().toString()\n        val session = Session(userId, sessionId, LocalDateTime.now())\n        sessions[sessionId] = session\n        return sessionId\n    }\n\n    fun getSession(sessionId: String): Session {\n        val session = sessions[sessionId] ?: throw SessionTimeoutException(\"Session not found\")\n        if (isSessionTimedOut(session)) {\n            sessions.remove(sessionId)\n            throw SessionTimeoutException(\"Session has timed out\")\n        }\n        session.lastAccessTime = LocalDateTime.now()\n        return session\n    }\n\n    private fun isSessionTimedOut(session: Session): Boolean {\n        val now = LocalDateTime.now()\n        val elapsedMinutes = java.time.Duration.between(session.lastAccessTime, now).toMinutes()\n        return elapsedMinutes >= sessionTimeoutMinutes\n    }\n\n    fun removeSession(sessionId: String) {\n        sessions.remove(sessionId)\n    }\n}\n\nfun main() {\n    val sessionManager = SessionManager(sessionTimeoutMinutes = 30)\n\n    try {\n        val sessionId = sessionManager.createSession(\"user123\")\n        println(\"Session created with ID: $sessionId\")\n\n        val session = sessionManager.getSession(sessionId)\n        println(\"Session accessed for user: ${session.userId}\")\n\n        // Simulate a delay for demonstration purposes\n        Thread.sleep(2000)\n\n        val sameSession = sessionManager.getSession(sessionId)\n        println(\"Session accessed again for user: ${sameSession.userId}\")\n\n    } catch (e: SessionTimeoutException) {\n        println(\"Exception: ${e.message}\")\n    }\n}\n```"
  },
  {
    "task": "Write a function that processes audio files and manages exceptions for unsupported audio formats.",
    "code": "```kotlin\nfun processAudioFile(fileName: String) {\n    try {\n        if (!fileName.endsWith(\".mp3\") && !fileName.endsWith(\".wav\")) {\n            throw UnsupportedAudioFormatException(\"Unsupported audio format: $fileName\")\n        }\n        // Process the audio file\n        println(\"Processing $fileName...\")\n    } catch (e: UnsupportedAudioFormatException) {\n        println(e.message)\n    }\n}\n\nclass UnsupportedAudioFormatException(message: String) : Exception(message)\n\n// Example usage\nfun main() {\n    processAudioFile(\"song.mp3\")  // Supported format\n    processAudioFile(\"video.mp4\") // Unsupported format\n}\n```"
  },
  {
    "task": "Create a service that sends notifications and handles exceptions for unreachable destinations.",
    "code": "```kotlin\nclass NotificationService {\n\n    fun sendNotification(destination: String, message: String) {\n        try {\n            if (destination.isBlank()) {\n                throw IllegalArgumentException(\"Destination cannot be blank\")\n            }\n            // Simulate sending notification\n            println(\"Sending message: '$message' to $destination\")\n            // Simulate unreachable destination\n            if (destination == \"unreachable@example.com\") {\n                throw Exception(\"Destination unreachable\")\n            }\n        } catch (e: IllegalArgumentException) {\n            println(\"Error: ${e.message}\")\n        } catch (e: Exception) {\n            println(\"Failed to send notification: ${e.message}\")\n        }\n    }\n}\n\nfun main() {\n    val service = NotificationService()\n    service.sendNotification(\"user@example.com\", \"Hello, User!\")\n    service.sendNotification(\"\", \"This will fail\")\n    service.sendNotification(\"unreachable@example.com\", \"Hello, Unreachable User!\")\n}\n```"
  },
  {
    "task": "Implement a program that performs data migration and manages data transformation exceptions.",
    "code": "```kotlin\nfun main() {\n    val data = listOf(\"123\", \"456\", \"abc\", \"789\")\n    val migratedData = mutableListOf<Int>()\n\n    for (item in data) {\n        try {\n            val number = transformData(item)\n            migratedData.add(number)\n        } catch (e: NumberFormatException) {\n            println(\"Data transformation error for item: '$item' - ${e.message}\")\n        }\n    }\n\n    println(\"Migrated Data: $migratedData\")\n}\n\nfun transformData(data: String): Int {\n    return data.toInt()\n}\n```"
  },
  {
    "task": "Develop a function that processes video files and handles codec compatibility exceptions.",
    "code": "```kotlin\nfun processVideoFile(fileName: String) {\n    try {\n        // Assume checkCodecCompatibility is a function that throws an exception if codec is not compatible\n        checkCodecCompatibility(fileName)\n        // Code to process the video file\n        println(\"Processing video file: $fileName\")\n    } catch (e: CodecCompatibilityException) {\n        println(\"Error: Codec compatibility issue for file $fileName - ${e.message}\")\n    } catch (e: Exception) {\n        println(\"An unexpected error occurred: ${e.message}\")\n    }\n}\n\n// Dummy function for illustration\nfun checkCodecCompatibility(fileName: String) {\n    // Logic to check codec compatibility\n    if (!isCodecCompatible(fileName)) {\n        throw CodecCompatibilityException(\"Incompatible codec found in $fileName\")\n    }\n}\n\n// Dummy function for illustration\nfun isCodecCompatible(fileName: String): Boolean {\n    // Logic to determine if codec is compatible\n    return fileName.endsWith(\".mp4\") // Example condition\n}\n\n// Custom exception class\nclass CodecCompatibilityException(message: String) : Exception(message)\n\nfun main() {\n    processVideoFile(\"sample.avi\")\n    processVideoFile(\"video.mp4\")\n}\n```"
  },
  {
    "task": "Write a function that manages memory allocation and catches out-of-memory exceptions.",
    "code": "```kotlin\nfun manageMemoryAllocation(size: Int): ByteArray? {\n    return try {\n        ByteArray(size)\n    } catch (e: OutOfMemoryError) {\n        println(\"Failed to allocate memory: ${e.message}\")\n        null\n    }\n}\n```"
  },
  {
    "task": "Create a program that processes financial transactions and handles currency conversion exceptions.",
    "code": "```kotlin\nfun main() {\n    val transactions = listOf(100.0, 200.0, 300.0)\n    val conversionRates = mapOf(\"USD\" to 1.0, \"EUR\" to 0.85)\n\n    for (transaction in transactions) {\n        try {\n            val amountInEur = convertCurrency(transaction, \"USD\", \"EUR\", conversionRates)\n            println(\"Transaction in EUR: $amountInEur\")\n        } catch (e: CurrencyConversionException) {\n            println(\"Error: ${e.message}\")\n        }\n    }\n}\n\nfun convertCurrency(amount: Double, fromCurrency: String, toCurrency: String, rates: Map<String, Double>): Double {\n    val fromRate = rates[fromCurrency] ?: throw CurrencyConversionException(\"Invalid from currency: $fromCurrency\")\n    val toRate = rates[toCurrency] ?: throw CurrencyConversionException(\"Invalid to currency: $toCurrency\")\n    return amount * (toRate / fromRate)\n}\n\nclass CurrencyConversionException(message: String) : Exception(message)\n```"
  },
  {
    "task": "Design a function that interacts with cloud storage and manages access permission exceptions.",
    "code": "```kotlin\nimport java.lang.Exception\n\nclass CloudStorageException(message: String) : Exception(message)\n\nfun accessCloudStorage() {\n    try {\n        // Simulate interaction with cloud storage\n        throw CloudStorageException(\"Access permission denied\")\n    } catch (e: CloudStorageException) {\n        println(\"Exception caught: ${e.message}\")\n    }\n}\n\nfun main() {\n    accessCloudStorage()\n}\n```"
  },
  {
    "task": "Implement a script that automates deployment and handles exceptions for missing configuration files.",
    "code": "```kotlin\nimport java.io.File\nimport java.io.FileNotFoundException\n\nfun main() {\n    try {\n        val config = loadConfiguration(\"config.txt\")\n        deployApplication(config)\n        println(\"Deployment successful.\")\n    } catch (e: FileNotFoundException) {\n        println(\"Error: Configuration file not found.\")\n    } catch (e: Exception) {\n        println(\"An unexpected error occurred: ${e.message}\")\n    }\n}\n\nfun loadConfiguration(filename: String): String {\n    val file = File(filename)\n    if (!file.exists()) {\n        throw FileNotFoundException(\"Configuration file $filename not found.\")\n    }\n    return file.readText()\n}\n\nfun deployApplication(config: String) {\n    // Deployment logic using the config\n    println(\"Deploying application with config: $config\")\n}\n```"
  },
  {
    "task": "Write a function that normalizes data and handles exceptions for invalid data ranges.",
    "code": "```kotlin\nfun normalizeData(value: Double, min: Double, max: Double): Double {\n    return try {\n        require(min < max) { \"Minimum value must be less than maximum value\" }\n        require(value in min..max) { \"Value must be within the range $min to $max\" }\n        (value - min) / (max - min)\n    } catch (e: IllegalArgumentException) {\n        println(\"Error: ${e.message}\")\n        Double.NaN\n    }\n}\n\nfun main() {\n    val normalizedValue1 = normalizeData(5.0, 0.0, 10.0)\n    println(\"Normalized Value 1: $normalizedValue1\")\n    \n    val normalizedValue2 = normalizeData(15.0, 0.0, 10.0) // This will cause an exception\n    println(\"Normalized Value 2: $normalizedValue2\")\n}\n```"
  },
  {
    "task": "Create a system that monitors application performance and handles threshold breach exceptions.",
    "code": "```kotlin\nclass PerformanceException(message: String) : Exception(message)\n\nclass PerformanceMonitor(private val threshold: Int) {\n    fun checkPerformance(currentValue: Int) {\n        try {\n            if (currentValue > threshold) {\n                throw PerformanceException(\"Performance threshold breached! Current value: $currentValue\")\n            }\n            println(\"Performance is within acceptable limits: $currentValue\")\n        } catch (e: PerformanceException) {\n            println(\"Exception caught: ${e.message}\")\n        }\n    }\n}\n\nfun main() {\n    val monitor = PerformanceMonitor(threshold = 100)\n    monitor.checkPerformance(90)  // Within limits\n    monitor.checkPerformance(110) // Breaches threshold\n}\n```"
  },
  {
    "task": "Develop a program that processes social media data and manages API limit exceptions.",
    "code": "```kotlin\nimport java.io.IOException\n\nclass ApiLimitException(message: String) : Exception(message)\n\nfun processSocialMediaData(data: String) {\n    println(\"Processing data: $data\")\n    // Simulate API limit exceeded\n    throw ApiLimitException(\"API limit exceeded while processing data.\")\n}\n\nfun main() {\n    val socialMediaData = \"Sample social media data\"\n\n    try {\n        processSocialMediaData(socialMediaData)\n    } catch (e: ApiLimitException) {\n        println(\"Caught an ApiLimitException: ${e.message}\")\n    } catch (e: IOException) {\n        println(\"Caught an IOException: ${e.message}\")\n    } catch (e: Exception) {\n        println(\"Caught an unexpected exception: ${e.message}\")\n    } finally {\n        println(\"Finished processing data.\")\n    }\n}\n```"
  },
  {
    "task": "Design a function that integrates with payment gateways and handles payment failure exceptions.",
    "code": "```kotlin\nclass PaymentGatewayException(message: String) : Exception(message)\n\nfun processPayment(paymentAmount: Double, paymentGateway: (Double) -> Boolean): Boolean {\n    return try {\n        val success = paymentGateway(paymentAmount)\n        if (!success) {\n            throw PaymentGatewayException(\"Payment failed due to gateway error.\")\n        }\n        true\n    } catch (e: PaymentGatewayException) {\n        println(\"Exception occurred: ${e.message}\")\n        false\n    } catch (e: Exception) {\n        println(\"An unexpected error occurred: ${e.message}\")\n        false\n    }\n}\n\nfun main() {\n    val paymentGateway: (Double) -> Boolean = { amount ->\n        // Simulate payment processing logic\n        // Return false to simulate a failure\n        false\n    }\n    \n    val paymentResult = processPayment(100.0, paymentGateway)\n    println(\"Payment successful: $paymentResult\")\n}\n```"
  },
  {
    "task": "Write a function that backs up data and handles exceptions for unavailable storage media.",
    "code": "```kotlin\nfun backupData(data: String) {\n    try {\n        // Simulate backup operation\n        performBackupOperation(data)\n    } catch (e: StorageUnavailableException) {\n        println(\"Backup failed: Storage media is unavailable.\")\n    } catch (e: Exception) {\n        println(\"An unexpected error occurred: ${e.message}\")\n    }\n}\n\nfun performBackupOperation(data: String) {\n    // Simulate a condition where storage is unavailable\n    throw StorageUnavailableException(\"Storage media is unavailable\")\n}\n\nclass StorageUnavailableException(message: String) : Exception(message)\n\n// Example usage\nfun main() {\n    backupData(\"Important data\")\n}\n```"
  },
  {
    "task": "Create a tool that manages software updates and handles exceptions for version conflicts.",
    "code": "```kotlin\nclass VersionConflictException(message: String) : Exception(message)\n\nclass SoftwareUpdateManager {\n    private val installedVersions = mutableMapOf<String, String>()\n\n    fun installUpdate(softwareName: String, version: String) {\n        try {\n            if (installedVersions.containsKey(softwareName)) {\n                val currentVersion = installedVersions[softwareName]!!\n                if (currentVersion >= version) {\n                    throw VersionConflictException(\"Version conflict: Installed version ($currentVersion) is newer or the same as $version.\")\n                }\n            }\n            installedVersions[softwareName] = version\n            println(\"Successfully updated $softwareName to version $version.\")\n        } catch (e: VersionConflictException) {\n            println(\"Error: ${e.message}\")\n        }\n    }\n\n    fun getInstalledVersion(softwareName: String): String? {\n        return installedVersions[softwareName]\n    }\n}\n\nfun main() {\n    val updateManager = SoftwareUpdateManager()\n\n    updateManager.installUpdate(\"AppA\", \"1.0\")\n    updateManager.installUpdate(\"AppA\", \"1.1\")\n    updateManager.installUpdate(\"AppA\", \"1.0\") // This should trigger a version conflict exception\n}\n```"
  },
  {
    "task": "Implement a program that performs sentiment analysis and manages exceptions for ambiguous texts.",
    "code": "```kotlin\nfun main() {\n    val texts = listOf(\n        \"I love this product!\",\n        \"This is the worst service ever.\",\n        \"I'm not sure how I feel about this.\",\n        \"Amazing experience, but could be better.\"\n    )\n\n    texts.forEach { text ->\n        try {\n            val sentiment = analyzeSentiment(text)\n            println(\"The sentiment of \\\"$text\\\" is: $sentiment\")\n        } catch (e: AmbiguousTextException) {\n            println(\"Could not determine sentiment for \\\"$text\\\": ${e.message}\")\n        }\n    }\n}\n\nfun analyzeSentiment(text: String): String {\n    return when {\n        text.contains(\"love\", ignoreCase = true) || text.contains(\"amazing\", ignoreCase = true) -> \"Positive\"\n        text.contains(\"worst\", ignoreCase = true) -> \"Negative\"\n        else -> throw AmbiguousTextException(\"Text is ambiguous for sentiment analysis.\")\n    }\n}\n\nclass AmbiguousTextException(message: String) : Exception(message)\n```"
  },
  {
    "task": "Develop a function that manages user authentication and handles credential mismatch exceptions.",
    "code": "```kotlin\nclass AuthenticationException(message: String) : Exception(message)\n\nfun authenticateUser(username: String, password: String): Boolean {\n    val storedUsername = \"user123\"\n    val storedPassword = \"pass123\"\n\n    return try {\n        if (username != storedUsername || password != storedPassword) {\n            throw AuthenticationException(\"Invalid credentials provided.\")\n        }\n        true\n    } catch (e: AuthenticationException) {\n        println(e.message)\n        false\n    }\n}\n\nfun main() {\n    val isAuthenticated = authenticateUser(\"user123\", \"wrongpass\")\n    println(\"Authentication successful: $isAuthenticated\")\n}\n```"
  },
  {
    "task": "Write a program that processes geographic data and handles exceptions for invalid coordinates.",
    "code": "```kotlin\nfun processCoordinates(latitude: Double, longitude: Double) {\n    try {\n        if (latitude !in -90.0..90.0) {\n            throw IllegalArgumentException(\"Invalid latitude: $latitude. Must be between -90 and 90.\")\n        }\n        if (longitude !in -180.0..180.0) {\n            throw IllegalArgumentException(\"Invalid longitude: $longitude. Must be between -180 and 180.\")\n        }\n        println(\"Processing coordinates: Latitude $latitude, Longitude $longitude\")\n    } catch (e: IllegalArgumentException) {\n        println(\"Error: ${e.message}\")\n    }\n}\n\nfun main() {\n    val coordinates = listOf(\n        Pair(45.0, 90.0),\n        Pair(-91.0, 45.0),\n        Pair(60.0, 190.0),\n        Pair(85.0, -170.0)\n    )\n\n    for ((lat, lon) in coordinates) {\n        processCoordinates(lat, lon)\n    }\n}\n```"
  },
  {
    "task": "Create a script that manages network configurations and handles exceptions for invalid syntax.",
    "code": "```kotlin\nfun manageNetworkConfigurations(config: String) {\n    try {\n        if (config.isBlank()) {\n            throw IllegalArgumentException(\"Configuration cannot be blank\")\n        }\n        // Simulate parsing configuration\n        if (!config.startsWith(\"net:\")) {\n            throw SyntaxException(\"Invalid syntax in network configuration\")\n        }\n        // Simulate network configuration logic\n        println(\"Network configuration applied: $config\")\n    } catch (e: IllegalArgumentException) {\n        println(\"Error: ${e.message}\")\n    } catch (e: SyntaxException) {\n        println(\"Syntax Error: ${e.message}\")\n    } catch (e: Exception) {\n        println(\"Unexpected Error: ${e.message}\")\n    }\n}\n\nclass SyntaxException(message: String) : Exception(message)\n\nfun main() {\n    val configurations = listOf(\"net:config1\", \"invalidConfig\", \"\")\n    for (config in configurations) {\n        manageNetworkConfigurations(config)\n    }\n}\n```"
  },
  {
    "task": "Design a function that processes biometric data and handles exceptions for sensor errors.",
    "code": "```kotlin\nfun processBiometricData(data: String) {\n    try {\n        if (data.isEmpty()) {\n            throw IllegalArgumentException(\"Biometric data cannot be empty\")\n        }\n        // Process the biometric data\n        println(\"Processing biometric data: $data\")\n    } catch (e: IllegalArgumentException) {\n        println(\"Exception caught: ${e.message}\")\n    } catch (e: Exception) {\n        println(\"An unexpected error occurred: ${e.message}\")\n    } finally {\n        println(\"Biometric data processing complete.\")\n    }\n}\n\nfun main() {\n    processBiometricData(\"sampleData\")\n    processBiometricData(\"\")\n}\n```"
  },
  {
    "task": "Implement a system that manages access control and handles exceptions for unauthorized access attempts.",
    "code": "```kotlin\nclass AccessControl {\n    private val authorizedUsers = setOf(\"admin\", \"user1\", \"user2\")\n\n    fun accessResource(username: String) {\n        try {\n            if (!isAuthorized(username)) {\n                throw UnauthorizedAccessException(\"Access denied for user: $username\")\n            }\n            println(\"Access granted to user: $username\")\n        } catch (e: UnauthorizedAccessException) {\n            println(e.message)\n        }\n    }\n\n    private fun isAuthorized(username: String): Boolean {\n        return authorizedUsers.contains(username)\n    }\n}\n\nclass UnauthorizedAccessException(message: String) : Exception(message)\n\nfun main() {\n    val accessControl = AccessControl()\n    accessControl.accessResource(\"admin\") // Access granted\n    accessControl.accessResource(\"guest\") // Access denied\n}\n```"
  },
  {
    "task": "Write a function that performs load balancing and handles exceptions for unreachable nodes.",
    "code": "```kotlin\nfun performLoadBalancing(nodes: List<String>): String {\n    for (node in nodes) {\n        try {\n            // Simulate checking if the node is reachable\n            if (!isNodeReachable(node)) {\n                throw UnreachableNodeException(\"Node $node is unreachable\")\n            }\n            return \"Load successfully balanced to node $node\"\n        } catch (e: UnreachableNodeException) {\n            println(\"Exception caught: ${e.message}\")\n        }\n    }\n    return \"No nodes available for load balancing\"\n}\n\nfun isNodeReachable(node: String): Boolean {\n    // Simulate node reachability check\n    return node != \"unreachable\"\n}\n\nclass UnreachableNodeException(message: String) : Exception(message)\n\nfun main() {\n    val nodes = listOf(\"node1\", \"unreachable\", \"node3\")\n    println(performLoadBalancing(nodes))\n}\n```"
  },
  {
    "task": "Create a program that simulates virtual environments and manages resource allocation exceptions.",
    "code": "```kotlin\nclass VirtualEnvironment {\n    fun allocateResources(requested: Int) {\n        try {\n            val availableResources = getAvailableResources()\n            if (requested > availableResources) {\n                throw InsufficientResourcesException(\"Requested: $requested, Available: $availableResources\")\n            }\n            println(\"Resources allocated: $requested\")\n        } catch (e: InsufficientResourcesException) {\n            println(\"Exception: ${e.message}\")\n        }\n    }\n\n    private fun getAvailableResources(): Int {\n        // Simulate available resources\n        return 10\n    }\n}\n\nclass InsufficientResourcesException(message: String) : Exception(message)\n\nfun main() {\n    val environment = VirtualEnvironment()\n    environment.allocateResources(5)  // Should succeed\n    environment.allocateResources(15) // Should throw exception\n}\n```"
  },
  {
    "task": "Develop a tool that manages digital rights and handles exceptions for unauthorized content access.",
    "code": "```kotlin\nclass DigitalRightsManager {\n    private val authorizedUsers = setOf(\"user1\", \"user2\", \"user3\")\n\n    fun accessContent(user: String) {\n        try {\n            if (!isUserAuthorized(user)) {\n                throw UnauthorizedAccessException(\"Access denied for user: $user\")\n            }\n            println(\"Access granted to user: $user\")\n        } catch (e: UnauthorizedAccessException) {\n            println(e.message)\n        }\n    }\n\n    private fun isUserAuthorized(user: String): Boolean {\n        return authorizedUsers.contains(user)\n    }\n}\n\nclass UnauthorizedAccessException(message: String) : Exception(message)\n\nfun main() {\n    val drm = DigitalRightsManager()\n    drm.accessContent(\"user1\")  // Authorized user\n    drm.accessContent(\"user4\")  // Unauthorized user\n}\n```"
  },
  {
    "task": "Design a function that synchronizes clocks and handles exceptions for time drift.",
    "code": "```kotlin\nimport java.time.LocalTime\nimport java.time.temporal.ChronoUnit\n\nfun synchronizeClocks(targetTime: LocalTime) {\n    try {\n        val localTime = LocalTime.now()\n        val drift = ChronoUnit.SECONDS.between(localTime, targetTime)\n        \n        if (drift != 0L) {\n            adjustClock(drift)\n        }\n        \n        println(\"Clocks synchronized successfully.\")\n    } catch (e: Exception) {\n        println(\"Failed to synchronize clocks: ${e.message}\")\n    }\n}\n\nfun adjustClock(drift: Long) {\n    // Implementation to adjust the clock by `drift` seconds\n    // This is a placeholder for the actual clock adjustment logic\n    println(\"Adjusting clock by $drift seconds.\")\n}\n\n// Example usage\nfun main() {\n    val targetTime = LocalTime.now().plusSeconds(10)\n    synchronizeClocks(targetTime)\n}\n```"
  },
  {
    "task": "Write a script that manages system backups and handles exceptions for insufficient backup space.",
    "code": "```kotlin\nimport java.io.IOException\n\nfun performBackup() {\n    println(\"Starting system backup...\")\n    // Simulate backup logic\n    val isSpaceAvailable = checkBackupSpace()\n    if (!isSpaceAvailable) {\n        throw IOException(\"Insufficient backup space.\")\n    }\n    println(\"Backup completed successfully.\")\n}\n\nfun checkBackupSpace(): Boolean {\n    // Simulate checking backup space\n    return false // Simulate insufficient space\n}\n\nfun main() {\n    try {\n        performBackup()\n    } catch (e: IOException) {\n        println(\"Backup failed: ${e.message}\")\n    }\n}\n```"
  },
  {
    "task": "Create a program that processes natural language text and handles parsing exceptions.",
    "code": "```kotlin\nfun processText(text: String) {\n    try {\n        // Simulate parsing natural language text\n        if (text.isBlank()) {\n            throw IllegalArgumentException(\"Input text is blank\")\n        }\n        // Further processing of the text\n        println(\"Processing text: $text\")\n    } catch (e: IllegalArgumentException) {\n        println(\"Parsing error: ${e.message}\")\n    } catch (e: Exception) {\n        println(\"An unexpected error occurred: ${e.message}\")\n    }\n}\n\nfun main() {\n    val text = \"Sample natural language text\"\n    processText(text)\n    processText(\"\")\n}\n```"
  },
  {
    "task": "Implement a function that manages thread execution and handles race condition exceptions.",
    "code": "```kotlin\nimport java.util.concurrent.locks.ReentrantLock\nimport kotlin.concurrent.thread\n\nfun manageThreads() {\n    val lock = ReentrantLock()\n    var sharedResource = 0\n\n    val threads = List(10) {\n        thread {\n            try {\n                lock.lock()\n                // Simulate some work with the shared resource\n                sharedResource++\n                println(\"Thread ${Thread.currentThread().name} incremented sharedResource to $sharedResource\")\n            } catch (e: Exception) {\n                println(\"Exception in thread ${Thread.currentThread().name}: ${e.message}\")\n            } finally {\n                lock.unlock()\n            }\n        }\n    }\n\n    threads.forEach { it.join() }\n}\n\nfun main() {\n    manageThreads()\n}\n```"
  },
  {
    "task": "Develop a system that integrates with IoT devices and handles connectivity exceptions.",
    "code": "```kotlin\nimport java.io.IOException\n\nclass IoTDevice(val id: String) {\n    fun connect() {\n        // Simulate connection logic\n        if (Math.random() < 0.5) {\n            throw IOException(\"Failed to connect to IoT device with id: $id\")\n        }\n        println(\"Connected to IoT device with id: $id\")\n    }\n}\n\nfun main() {\n    val devices = listOf(IoTDevice(\"Device1\"), IoTDevice(\"Device2\"), IoTDevice(\"Device3\"))\n\n    for (device in devices) {\n        try {\n            device.connect()\n        } catch (e: IOException) {\n            println(\"Error: ${e.message}\")\n        }\n    }\n}\n```"
  },
  {
    "task": "Write a function that manages application logging and handles exceptions for log overflow.",
    "code": "```kotlin\nclass LogOverflowException(message: String) : Exception(message)\n\nclass Logger(private val maxLogs: Int) {\n    private val logs = mutableListOf<String>()\n\n    fun log(message: String) {\n        try {\n            if (logs.size >= maxLogs) {\n                throw LogOverflowException(\"Log overflow: Maximum log entries reached\")\n            }\n            logs.add(message)\n            println(\"Log added: $message\")\n        } catch (e: LogOverflowException) {\n            println(\"Exception caught: ${e.message}\")\n        }\n    }\n}\n\nfun main() {\n    val logger = Logger(maxLogs = 5)\n    \n    for (i in 1..6) {\n        logger.log(\"Log entry #$i\")\n    }\n}\n```"
  },
  {
    "task": "Create a tool that visualizes data and handles exceptions for unsupported visualization types.",
    "code": "```kotlin\nfun main() {\n    val data = listOf(1, 2, 3, 4, 5)\n    val visualizationType = \"pie\"\n\n    try {\n        visualizeData(data, visualizationType)\n    } catch (e: UnsupportedVisualizationException) {\n        println(e.message)\n    }\n}\n\nfun visualizeData(data: List<Int>, type: String) {\n    when (type) {\n        \"bar\" -> println(\"Visualizing data as a bar chart: $data\")\n        \"line\" -> println(\"Visualizing data as a line graph: $data\")\n        else -> throw UnsupportedVisualizationException(\"Unsupported visualization type: $type\")\n    }\n}\n\nclass UnsupportedVisualizationException(message: String) : Exception(message)\n```"
  },
  {
    "task": "Design a program that performs genetic algorithm simulations and manages exception for invalid mutations.",
    "code": "```kotlin\nfun main() {\n    try {\n        val population = listOf(\"AAAA\", \"CCCC\", \"GGGG\", \"TTTT\")\n        val mutatedPopulation = population.map { mutate(it) }\n        println(\"Mutated Population: $mutatedPopulation\")\n    } catch (e: InvalidMutationException) {\n        println(\"Error: ${e.message}\")\n    }\n}\n\nfun mutate(dna: String): String {\n    val mutationChance = 0.2\n    val random = java.util.Random()\n    return dna.map { nucleotide ->\n        if (random.nextDouble() < mutationChance) {\n            mutateNucleotide(nucleotide)\n        } else {\n            nucleotide\n        }\n    }.joinToString(\"\")\n}\n\nfun mutateNucleotide(nucleotide: Char): Char {\n    val validNucleotides = listOf('A', 'C', 'G', 'T')\n    if (nucleotide !in validNucleotides) {\n        throw InvalidMutationException(\"Invalid nucleotide: $nucleotide\")\n    }\n    return validNucleotides.filter { it != nucleotide }.random()\n}\n\nclass InvalidMutationException(message: String) : Exception(message)\n```"
  },
  {
    "task": "Implement a function that manages distributed transactions and handles consistency exceptions.",
    "code": "```kotlin\nclass ConsistencyException(message: String) : Exception(message)\n\nfun manageTransaction() {\n    try {\n        beginTransaction()\n        performOperation()\n        commitTransaction()\n    } catch (e: ConsistencyException) {\n        println(\"Consistency error: ${e.message}\")\n        rollbackTransaction()\n    } catch (e: Exception) {\n        println(\"Unexpected error: ${e.message}\")\n        rollbackTransaction()\n    }\n}\n\nfun beginTransaction() {\n    // Code to begin transaction\n}\n\nfun performOperation() {\n    // Code to perform some operations\n    // Simulate a consistency exception\n    throw ConsistencyException(\"Simulated consistency failure\")\n}\n\nfun commitTransaction() {\n    // Code to commit transaction\n}\n\nfun rollbackTransaction() {\n    // Code to rollback transaction\n}\n\nfun main() {\n    manageTransaction()\n}\n```"
  },
  {
    "task": "Write a function that handles secure communications and manages encryption key exceptions.",
    "code": "```kotlin\nfun handleSecureCommunications() {\n    try {\n        val encryptionKey = obtainEncryptionKey()\n        if (encryptionKey.isEmpty()) {\n            throw IllegalArgumentException(\"Encryption key is empty\")\n        }\n        // Proceed with secure communications using the encryptionKey\n        println(\"Secure communication established with key: $encryptionKey\")\n    } catch (e: IllegalArgumentException) {\n        println(\"Error: ${e.message}\")\n    } catch (e: Exception) {\n        println(\"An unexpected error occurred: ${e.message}\")\n    }\n}\n\nfun obtainEncryptionKey(): String {\n    // Logic to obtain encryption key\n    // For demonstration, returning an empty key to trigger an exception\n    return \"\"\n}\n\nfun main() {\n    handleSecureCommunications()\n}\n```"
  },
  {
    "task": "Create a system that processes sensor data and handles out-of-range value exceptions.",
    "code": "```kotlin\nclass OutOfRangeException(message: String) : Exception(message)\n\nclass SensorDataProcessor {\n    fun processSensorData(value: Int) {\n        try {\n            validateSensorData(value)\n            println(\"Processing sensor data: $value\")\n        } catch (e: OutOfRangeException) {\n            println(\"Error: ${e.message}\")\n        }\n    }\n\n    private fun validateSensorData(value: Int) {\n        if (value < 0 || value > 100) {\n            throw OutOfRangeException(\"Sensor value $value is out of range.\")\n        }\n    }\n}\n\nfun main() {\n    val processor = SensorDataProcessor()\n    val sensorValues = listOf(10, 150, 50, -5, 60)\n\n    for (value in sensorValues) {\n        processor.processSensorData(value)\n    }\n}\n```"
  },
  {
    "task": "Develop a program that simulates weather patterns and handles model prediction exceptions.",
    "code": "```kotlin\nimport kotlin.random.Random\n\nclass WeatherPredictionException(message: String) : Exception(message)\n\nclass WeatherSimulator {\n\n    fun simulateWeather(): String {\n        val weatherPatterns = listOf(\"Sunny\", \"Rainy\", \"Cloudy\", \"Stormy\")\n        if (Random.nextBoolean()) {\n            throw WeatherPredictionException(\"Failed to predict weather due to model error.\")\n        }\n        return weatherPatterns.random()\n    }\n}\n\nfun main() {\n    val simulator = WeatherSimulator()\n\n    try {\n        val prediction = simulator.simulateWeather()\n        println(\"Weather prediction: $prediction\")\n    } catch (e: WeatherPredictionException) {\n        println(\"Error: ${e.message}\")\n    }\n}\n```"
  },
  {
    "task": "Design a function that manages API versioning and handles backward compatibility exceptions.",
    "code": "```kotlin\nclass ApiVersionException(message: String) : Exception(message)\n\nfun manageApiVersion(version: Int) {\n    try {\n        when (version) {\n            1 -> println(\"Processing API version 1\")\n            2 -> println(\"Processing API version 2\")\n            else -> throw ApiVersionException(\"Unsupported API version: $version\")\n        }\n    } catch (e: ApiVersionException) {\n        println(\"Error: ${e.message}\")\n    }\n}\n\nfun main() {\n    manageApiVersion(1) // Supported version\n    manageApiVersion(3) // Unsupported version, will throw exception\n}\n```"
  },
  {
    "task": "Write a tool that converts character encodings and handles unsupported encoding exceptions.",
    "code": "```kotlin\nimport java.nio.charset.Charset\nimport java.nio.charset.UnsupportedCharsetException\n\nfun convertEncoding(inputString: String, sourceEncoding: String, targetEncoding: String): String? {\n    return try {\n        val byteArray = inputString.toByteArray(Charset.forName(sourceEncoding))\n        String(byteArray, Charset.forName(targetEncoding))\n    } catch (e: UnsupportedCharsetException) {\n        println(\"Error: Unsupported encoding - ${e.charsetName()}\")\n        null\n    }\n}\n\nfun main() {\n    val input = \"Hello, World!\"\n    val sourceEnc = \"UTF-8\"\n    val targetEnc = \"ISO-8859-1\"\n    \n    val result = convertEncoding(input, sourceEnc, targetEnc)\n    result?.let {\n        println(\"Converted string: $it\")\n    }\n}\n```"
  },
  {
    "task": "Create a program that handles dynamic content generation and manages template parsing exceptions.",
    "code": "```kotlin\nfun main() {\n    val templates = listOf(\"Hello, {name}!\", \"Welcome, {user}!\", \"Goodbye, {name}!\")\n\n    templates.forEach { template ->\n        try {\n            val content = generateContent(template, mapOf(\"name\" to \"John\", \"user\" to \"Visitor\"))\n            println(content)\n        } catch (e: TemplateParsingException) {\n            println(\"Error parsing template: ${e.message}\")\n        }\n    }\n}\n\nfun generateContent(template: String, variables: Map<String, String>): String {\n    return try {\n        var result = template\n        variables.forEach { (key, value) ->\n            if (result.contains(\"{$key}\")) {\n                result = result.replace(\"{$key}\", value)\n            } else {\n                throw TemplateParsingException(\"Missing variable: $key\")\n            }\n        }\n        result\n    } catch (e: Exception) {\n        throw TemplateParsingException(\"Failed to generate content: ${e.message}\")\n    }\n}\n\nclass TemplateParsingException(message: String) : Exception(message)\n```"
  },
  {
    "task": "Implement a script that schedules automated tests and handles exceptions for missing test cases.",
    "code": "```kotlin\nimport java.util.Timer\nimport java.util.TimerTask\n\nclass TestScheduler {\n\n    private val timer = Timer()\n\n    fun scheduleTests(testCases: List<String>) {\n        try {\n            if (testCases.isEmpty()) {\n                throw IllegalArgumentException(\"No test cases provided\")\n            }\n            testCases.forEach { testCase ->\n                timer.schedule(object : TimerTask() {\n                    override fun run() {\n                        println(\"Running test case: $testCase\")\n                        // Simulate test execution\n                    }\n                }, 1000)\n            }\n        } catch (e: IllegalArgumentException) {\n            println(\"Exception: ${e.message}\")\n        }\n    }\n}\n\nfun main() {\n    val testScheduler = TestScheduler()\n    val testCases = listOf(\"Test1\", \"Test2\", \"Test3\") // Provide test case names here\n    testScheduler.scheduleTests(testCases)\n    \n    // Uncomment the following to test exception handling\n    // testScheduler.scheduleTests(emptyList())\n}\n```"
  },
  {
    "task": "Develop a system that manages virtual machine instances and handles provisioning exceptions.",
    "code": "```kotlin\nclass VirtualMachineManager {\n    private val vmInstances = mutableListOf<VirtualMachine>()\n\n    fun provisionInstance(vmName: String): Boolean {\n        return try {\n            val vm = VirtualMachine(vmName)\n            vmInstances.add(vm)\n            println(\"Provisioned VM: $vmName\")\n            true\n        } catch (e: Exception) {\n            println(\"Failed to provision VM: $vmName. Error: ${e.message}\")\n            false\n        }\n    }\n}\n\nclass VirtualMachine(private val name: String) {\n    init {\n        if (name.isBlank()) {\n            throw IllegalArgumentException(\"VM name cannot be blank.\")\n        }\n        // Simulate potential provisioning failure\n        if (Math.random() < 0.2) {\n            throw RuntimeException(\"Random provisioning failure.\")\n        }\n    }\n}\n\nfun main() {\n    val vmManager = VirtualMachineManager()\n    vmManager.provisionInstance(\"VM1\")\n    vmManager.provisionInstance(\"\")\n    vmManager.provisionInstance(\"VM2\")\n}\n```"
  },
  {
    "task": "Write a function that processes credit scores and handles exceptions for missing credit history.",
    "code": "```kotlin\nfun processCreditScore(creditHistory: Map<String, Int?>) {\n    for ((name, score) in creditHistory) {\n        try {\n            val validScore = score ?: throw IllegalArgumentException(\"Missing credit history for $name\")\n            println(\"Processing credit score for $name: $validScore\")\n        } catch (e: IllegalArgumentException) {\n            println(\"Error: ${e.message}\")\n        }\n    }\n}\n\nfun main() {\n    val creditData = mapOf(\n        \"Alice\" to 720,\n        \"Bob\" to null,\n        \"Charlie\" to 680\n    )\n    processCreditScore(creditData)\n}\n```"
  },
  {
    "task": "Create a tool that manages digital certificates and handles expiration exceptions.",
    "code": "```kotlin\nimport java.time.LocalDate\nimport java.time.format.DateTimeFormatter\n\nclass Certificate(val name: String, val expirationDate: String) {\n    fun checkExpiration() {\n        val formatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd\")\n        val expiration = LocalDate.parse(expirationDate, formatter)\n        val today = LocalDate.now()\n\n        if (today.isAfter(expiration)) {\n            throw CertificateExpiredException(\"Certificate '$name' has expired on $expirationDate\")\n        } else {\n            println(\"Certificate '$name' is valid until $expirationDate\")\n        }\n    }\n}\n\nclass CertificateExpiredException(message: String) : Exception(message)\n\nfun main() {\n    val certificates = listOf(\n        Certificate(\"Cert1\", \"2023-08-15\"),\n        Certificate(\"Cert2\", \"2023-12-01\")\n    )\n\n    for (cert in certificates) {\n        try {\n            cert.checkExpiration()\n        } catch (e: CertificateExpiredException) {\n            println(e.message)\n        }\n    }\n}\n```"
  },
  {
    "task": "Design a program that processes genome sequences and handles exceptions for sequence alignment.",
    "code": "```kotlin\nfun alignSequences(seq1: String, seq2: String): String {\n    try {\n        require(seq1.isNotEmpty() && seq2.isNotEmpty()) { \"Sequences must not be empty.\" }\n        if (seq1.length != seq2.length) throw IllegalArgumentException(\"Sequences must be of equal length for alignment.\")\n        \n        val aligned = StringBuilder()\n        for (i in seq1.indices) {\n            aligned.append(if (seq1[i] == seq2[i]) seq1[i] else '-')\n        }\n        return aligned.toString()\n    } catch (e: IllegalArgumentException) {\n        println(\"Error: ${e.message}\")\n        return \"\"\n    } catch (e: Exception) {\n        println(\"An unexpected error occurred: ${e.message}\")\n        return \"\"\n    }\n}\n\nfun main() {\n    val genomeSeq1 = \"AGCT\"\n    val genomeSeq2 = \"AGGT\"\n    \n    val result = alignSequences(genomeSeq1, genomeSeq2)\n    println(\"Aligned Sequence: $result\")\n}\n```"
  }
]