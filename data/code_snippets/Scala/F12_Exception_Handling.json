[
  {
    "task": "Write a function that reads a file and handles the exception if the file is not found.",
    "code": "```scala\nimport scala.io.Source\nimport java.io.{FileNotFoundException, IOException}\n\ndef readFile(fileName: String): Unit = {\n  try {\n    val source = Source.fromFile(fileName)\n    try {\n      source.getLines().foreach(println)\n    } finally {\n      source.close()\n    }\n  } catch {\n    case e: FileNotFoundException => println(s\"File not found: $fileName\")\n    case e: IOException => println(s\"An error occurred while reading the file: ${e.getMessage}\")\n  }\n}\n```"
  },
  {
    "task": "Create a program that divides two numbers and catches any division by zero errors.",
    "code": "```scala\nobject DivisionApp extends App {\n  def divideNumbers(numerator: Int, denominator: Int): Either[String, Double] = {\n    try {\n      Right(numerator.toDouble / denominator)\n    } catch {\n      case e: ArithmeticException => Left(\"Division by zero is not allowed.\")\n    }\n  }\n\n  val result = divideNumbers(10, 0)\n  result match {\n    case Right(value) => println(s\"Result: $value\")\n    case Left(error) => println(s\"Error: $error\")\n  }\n}\n```"
  },
  {
    "task": "Design a function to parse an integer from a string and manage invalid input exceptions.",
    "code": "```scala\ndef parseInteger(input: String): Option[Int] = {\n  try {\n    Some(input.toInt)\n  } catch {\n    case _: NumberFormatException => None\n  }\n}\n```"
  },
  {
    "task": "Implement an API call and catch exceptions related to network errors or timeouts.",
    "code": "```scala\nimport scala.concurrent.ExecutionContext.Implicits.global\nimport scala.concurrent.Future\nimport scala.util.{Failure, Success}\nimport scalaj.http.{Http, HttpResponse}\n\nobject ApiCaller {\n  def callApi(url: String): Future[HttpResponse[String]] = Future {\n    Http(url).timeout(connTimeoutMs = 1000, readTimeoutMs = 5000).asString\n  }\n\n  def main(args: Array[String]): Unit = {\n    val apiUrl = \"http://example.com/api\"\n\n    callApi(apiUrl).onComplete {\n      case Success(response) =>\n        println(s\"Response: ${response.body}\")\n      case Failure(exception) =>\n        exception match {\n          case e: java.net.SocketTimeoutException =>\n            println(\"Request timed out.\")\n          case e: java.net.UnknownHostException =>\n            println(\"Network error: Unknown host.\")\n          case e =>\n            println(s\"An error occurred: ${e.getMessage}\")\n        }\n    }\n  }\n}\n```"
  },
  {
    "task": "Develop a program that opens a database connection and handles any connection failure exceptions.",
    "code": "```scala\nimport java.sql.{Connection, DriverManager, SQLException}\n\nobject DatabaseConnectionApp {\n  def main(args: Array[String]): Unit = {\n    val url = \"jdbc:mysql://localhost:3306/mydb\"\n    val username = \"user\"\n    val password = \"password\"\n\n    var connection: Connection = null\n    try {\n      connection = DriverManager.getConnection(url, username, password)\n      println(\"Database connected successfully\")\n    } catch {\n      case e: SQLException =>\n        println(s\"Failed to connect to the database: ${e.getMessage}\")\n    } finally {\n      if (connection != null) {\n        try {\n          connection.close()\n        } catch {\n          case e: SQLException =>\n            println(s\"Failed to close the connection: ${e.getMessage}\")\n        }\n      }\n    }\n  }\n}\n```"
  },
  {
    "task": "Write a function that accesses an array by index and catches out-of-bounds exceptions.",
    "code": "```scala\ndef accessArrayElement(arr: Array[Int], index: Int): Option[Int] = {\n  try {\n    Some(arr(index))\n  } catch {\n    case _: ArrayIndexOutOfBoundsException => None\n  }\n}\n```"
  },
  {
    "task": "Create a function that converts a string to a date object and manages format exceptions.",
    "code": "```scala\nimport java.text.SimpleDateFormat\nimport java.util.Date\n\nobject DateConverter {\n  def stringToDate(dateString: String, format: String): Option[Date] = {\n    val dateFormat = new SimpleDateFormat(format)\n    try {\n      Some(dateFormat.parse(dateString))\n    } catch {\n      case _: java.text.ParseException => None\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val dateStr = \"2023-10-05\"\n    val format = \"yyyy-MM-dd\"\n    val dateOption = stringToDate(dateStr, format)\n\n    dateOption match {\n      case Some(date) => println(s\"Parsed date: $date\")\n      case None => println(\"Invalid date format.\")\n    }\n  }\n}\n```"
  },
  {
    "task": "Design a program that writes data to a file and catches any file permission exceptions.",
    "code": "```scala\nimport java.io.{File, FileWriter, IOException}\nimport java.nio.file.{Files, Paths}\n\nobject FileWriterApp {\n  def writeToFile(filePath: String, data: String): Unit = {\n    try {\n      val file = new File(filePath)\n      if (Files.isWritable(Paths.get(filePath))) {\n        val writer = new FileWriter(file)\n        try {\n          writer.write(data)\n        } finally {\n          writer.close()\n        }\n      } else {\n        throw new SecurityException(\"File is not writable.\")\n      }\n    } catch {\n      case e: SecurityException => println(s\"Permission denied: ${e.getMessage}\")\n      case e: IOException => println(s\"An I/O error occurred: ${e.getMessage}\")\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val filePath = \"output.txt\"\n    val data = \"Hello, Scala!\"\n    writeToFile(filePath, data)\n  }\n}\n```"
  },
  {
    "task": "Implement a module that retrieves data from a URL and handles malformed URL exceptions.",
    "code": "```scala\nimport scala.io.Source\nimport java.net.{MalformedURLException, URL}\nimport scala.util.{Try, Success, Failure}\n\nobject URLDataRetriever {\n  def fetchDataFromUrl(urlString: String): Try[String] = {\n    Try {\n      val url = new URL(urlString)\n      Source.fromURL(url).mkString\n    } match {\n      case success @ Success(_) => success\n      case Failure(e: MalformedURLException) =>\n        println(s\"Malformed URL Exception: ${e.getMessage}\")\n        Failure(e)\n      case Failure(e) =>\n        println(s\"An error occurred: ${e.getMessage}\")\n        Failure(e)\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val url = \"http://example.com\"\n    fetchDataFromUrl(url) match {\n      case Success(data) => println(s\"Data retrieved: $data\")\n      case Failure(_) => println(\"Failed to fetch data.\")\n    }\n  }\n}\n```"
  },
  {
    "task": "Write a function to calculate the square root of a number and catch any negative input exceptions.",
    "code": "```scala\nimport scala.util.{Try, Failure, Success}\n\ndef safeSqrt(x: Double): Double = {\n  Try {\n    if (x < 0) throw new IllegalArgumentException(\"Negative input not allowed\")\n    Math.sqrt(x)\n  } match {\n    case Success(value) => value\n    case Failure(exception) =>\n      println(exception.getMessage)\n      Double.NaN\n  }\n}\n```"
  },
  {
    "task": "Develop a program that sends an email and manages exceptions for invalid email addresses.",
    "code": "```scala\nimport java.util.Properties\nimport javax.mail._\nimport javax.mail.internet._\n\nobject EmailSender {\n  def main(args: Array[String]): Unit = {\n    val to = \"invalid-email.com\"\n    val from = \"sender@example.com\"\n    val host = \"smtp.example.com\"\n\n    val properties = new Properties()\n    properties.put(\"mail.smtp.host\", host)\n\n    val session = Session.getInstance(properties, new Authenticator() {\n      override protected def getPasswordAuthentication: PasswordAuthentication = {\n        new PasswordAuthentication(\"username\", \"password\")\n      }\n    })\n\n    try {\n      val message = new MimeMessage(session)\n      message.setFrom(new InternetAddress(from))\n      message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(to))\n      message.setSubject(\"Test Email\")\n      message.setText(\"This is a test email.\")\n\n      Transport.send(message)\n      println(\"Email sent successfully.\")\n    } catch {\n      case e: AddressException =>\n        println(s\"Invalid email address: ${e.getMessage}\")\n      case e: MessagingException =>\n        println(s\"Failed to send email: ${e.getMessage}\")\n    }\n  }\n}\n```"
  },
  {
    "task": "Create a calculator application that handles invalid operations gracefully.",
    "code": "```scala\nobject SimpleCalculator {\n  def main(args: Array[String]): Unit = {\n    val result = try {\n      calculate(10, 0, \"/\")\n    } catch {\n      case e: ArithmeticException => s\"Error: ${e.getMessage}\"\n      case e: IllegalArgumentException => s\"Error: ${e.getMessage}\"\n    }\n\n    println(result)\n  }\n\n  def calculate(a: Int, b: Int, op: String): String = {\n    op match {\n      case \"+\" => (a + b).toString\n      case \"-\" => (a - b).toString\n      case \"*\" => (a * b).toString\n      case \"/\" =>\n        if (b == 0) throw new ArithmeticException(\"Division by zero\")\n        else (a / b).toString\n      case _ => throw new IllegalArgumentException(\"Invalid operation\")\n    }\n  }\n}\n```"
  },
  {
    "task": "Design a function that tries to parse JSON data and catches parsing errors.",
    "code": "```scala\nimport scala.util.{Try, Success, Failure}\nimport play.api.libs.json._\n\ndef parseJson(jsonString: String): Either[String, JsValue] = {\n  Try(Json.parse(jsonString)) match {\n    case Success(json) => Right(json)\n    case Failure(exception) => Left(s\"Parsing error: ${exception.getMessage}\")\n  }\n}\n```"
  },
  {
    "task": "Implement a system that processes user input and handles any type conversion exceptions.",
    "code": "```scala\nimport scala.util.{Try, Success, Failure}\nimport scala.io.StdIn._\n\nobject UserInputProcessor {\n  def main(args: Array[String]): Unit = {\n    println(\"Please enter a number:\")\n    val input = readLine()\n    \n    val result = Try(input.toInt) match {\n      case Success(number) => s\"Successfully converted input to number: $number\"\n      case Failure(exception) => s\"Failed to convert input. Error: ${exception.getMessage}\"\n    }\n    \n    println(result)\n  }\n}\n```"
  },
  {
    "task": "Write a function that fetches data from a database and manages exceptions for missing records.",
    "code": "```scala\nimport java.sql.{Connection, DriverManager, ResultSet, SQLException}\n\nobject DatabaseFetcher {\n  def fetchData(query: String): Option[ResultSet] = {\n    var connection: Connection = null\n    try {\n      connection = DriverManager.getConnection(\"jdbc:your_database_url\", \"username\", \"password\")\n      val statement = connection.createStatement()\n      val resultSet = statement.executeQuery(query)\n      if (resultSet.next()) {\n        Some(resultSet)\n      } else {\n        None\n      }\n    } catch {\n      case e: SQLException =>\n        println(s\"SQL Exception occurred: ${e.getMessage}\")\n        None\n    } finally {\n      if (connection != null) {\n        try {\n          connection.close()\n        } catch {\n          case e: SQLException =>\n            println(s\"Failed to close connection: ${e.getMessage}\")\n        }\n      }\n    }\n  }\n}\n```"
  },
  {
    "task": "Create a program that connects to a remote server and handles authentication failure exceptions.",
    "code": "```scala\nimport scala.util.{Try, Failure, Success}\n\nobject RemoteServerConnector {\n  def connectToServer(): Unit = {\n    Try {\n      // Simulate connection and authentication process\n      val isAuthenticated = authenticate(\"username\", \"password\")\n      if (!isAuthenticated) throw new AuthenticationException(\"Authentication failed\")\n      println(\"Connected to server successfully.\")\n    } match {\n      case Success(_) => // Connection successful\n      case Failure(exception) => println(s\"Connection failed: ${exception.getMessage}\")\n    }\n  }\n\n  def authenticate(username: String, password: String): Boolean = {\n    // Simulate authentication logic\n    username == \"admin\" && password == \"secret\"\n  }\n\n  class AuthenticationException(message: String) extends Exception(message)\n\n  def main(args: Array[String]): Unit = {\n    connectToServer()\n  }\n}\n```"
  },
  {
    "task": "Develop a function to download a file from the internet and handle file not found exceptions.",
    "code": "```scala\nimport scala.io.Source\nimport java.net.{URL, MalformedURLException}\nimport java.io.{FileNotFoundException, IOException}\n\ndef downloadFile(url: String): Unit = {\n  try {\n    val source = Source.fromURL(new URL(url))\n    val content = source.mkString\n    println(\"File downloaded successfully\")\n    source.close()\n  } catch {\n    case e: MalformedURLException => \n      println(\"Invalid URL: \" + e.getMessage)\n    case e: FileNotFoundException => \n      println(\"File not found: \" + e.getMessage)\n    case e: IOException => \n      println(\"Error downloading file: \" + e.getMessage)\n  }\n}\n```"
  },
  {
    "task": "Design a program that attempts to connect to an API and handles rate limit exceptions.",
    "code": "```scala\nimport scala.util.{Try, Failure, Success}\n\n// Simulate an API connection\nobject ApiConnector {\n  class RateLimitException(message: String) extends Exception(message)\n\n  def connectToApi(): Try[String] = {\n    // Simulate a rate limit exception\n    Failure(new RateLimitException(\"Rate limit exceeded\"))\n  }\n}\n\nobject MainApp extends App {\n  val apiResponse = ApiConnector.connectToApi()\n\n  apiResponse match {\n    case Success(response) => println(s\"Successfully connected to API: $response\")\n    case Failure(exception: ApiConnector.RateLimitException) =>\n      println(s\"Failed to connect to API: ${exception.getMessage}\")\n    case Failure(exception) =>\n      println(s\"An unexpected error occurred: ${exception.getMessage}\")\n  }\n}\n```"
  },
  {
    "task": "Write a function that reads from a configuration file and manages key not found exceptions.",
    "code": "```scala\nimport scala.io.Source\nimport scala.util.{Try, Success, Failure}\n\ndef readConfigFile(filePath: String, key: String): Option[String] = {\n  Try(Source.fromFile(filePath)) match {\n    case Success(bufferedSource) =>\n      try {\n        val lines = bufferedSource.getLines().toList\n        val configMap = lines.map(line => {\n          val parts = line.split(\"=\")\n          if (parts.length == 2) parts(0).trim -> parts(1).trim else \"\" -> \"\"\n        }).toMap\n        configMap.get(key)\n      } catch {\n        case e: Exception => None\n      } finally {\n        bufferedSource.close()\n      }\n    case Failure(exception) =>\n      println(s\"Error opening file: $exception\")\n      None\n  }\n}\n```"
  },
  {
    "task": "Create an application that processes a list of tasks and catches any task execution exceptions.",
    "code": "```scala\nobject TaskProcessor {\n  def main(args: Array[String]): Unit = {\n    val tasks: List[() => Unit] = List(\n      () => println(\"Task 1 completed\"),\n      () => throw new RuntimeException(\"Task 2 failed\"),\n      () => println(\"Task 3 completed\")\n    )\n\n    tasks.foreach(task => {\n      try {\n        task()\n      } catch {\n        case e: Exception => println(s\"Exception caught: ${e.getMessage}\")\n      }\n    })\n  }\n}\n```"
  },
  {
    "task": "Implement a program that performs batch processing and handles individual item processing exceptions.",
    "code": "```scala\nobject BatchProcessor {\n  def main(args: Array[String]): Unit = {\n    val items = List(1, 2, 3, 4, 5, 0, 6)\n    processBatch(items)\n  }\n\n  def processBatch(items: List[Int]): Unit = {\n    items.foreach(item => {\n      try {\n        processItem(item)\n      } catch {\n        case e: ArithmeticException => println(s\"Failed to process item $item: ${e.getMessage}\")\n        case e: Exception => println(s\"An unexpected error occurred with item $item: ${e.getMessage}\")\n      }\n    })\n  }\n\n  def processItem(item: Int): Unit = {\n    val result = 100 / item // This will throw ArithmeticException for item 0\n    println(s\"Processed item $item: result is $result\")\n  }\n}\n```"
  },
  {
    "task": "Develop a function that performs mathematical operations and catches arithmetic exceptions.",
    "code": "```scala\ndef performOperation(operation: (Int, Int) => Int, a: Int, b: Int): Either[String, Int] = {\n  try {\n    Right(operation(a, b))\n  } catch {\n    case e: ArithmeticException => Left(s\"ArithmeticException: ${e.getMessage}\")\n  }\n}\n\nval division = (a: Int, b: Int) => a / b\n\n// Example usage\nval result1 = performOperation(division, 10, 5) // Right(2)\nval result2 = performOperation(division, 10, 0) // Left(\"ArithmeticException: / by zero\")\n```"
  },
  {
    "task": "Write a program that logs error messages when exceptions occur during data processing.",
    "code": "```scala\nimport java.io.{FileWriter, PrintWriter}\nimport scala.util.{Try, Failure, Success}\n\nobject DataProcessor {\n  def processData(data: String): Unit = {\n    // Simulating data processing that may throw an exception\n    if (data == \"bad\") throw new RuntimeException(\"Invalid data encountered!\")\n  }\n\n  def logError(errorMessage: String): Unit = {\n    val writer = new PrintWriter(new FileWriter(\"error_log.txt\", true))\n    try {\n      writer.println(errorMessage)\n    } finally {\n      writer.close()\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val dataItems = List(\"good\", \"bad\", \"good\", \"bad\")\n\n    dataItems.foreach { data =>\n      Try(processData(data)) match {\n        case Success(_) => println(s\"Processed: $data\")\n        case Failure(exception) =>\n          println(s\"Error processing: $data\")\n          logError(exception.getMessage)\n      }\n    }\n  }\n}\n```"
  },
  {
    "task": "Create a script that monitors system resources and handles exceptions when limits are exceeded.",
    "code": "```scala\nimport scala.sys.process._\nimport scala.util.{Failure, Success, Try}\n\nobject SystemResourceMonitor extends App {\n  def getCpuUsage: Double = {\n    // Simulated CPU usage retrieval\n    Try(\"top -bn1 | grep 'Cpu(s)'\".!!) match {\n      case Success(output) => output.split(\",\")(0).split(\":\")(1).trim.replace(\"%us\", \"\").toDouble\n      case Failure(_) => throw new RuntimeException(\"Failed to retrieve CPU usage\")\n    }\n  }\n\n  def getMemoryUsage: Double = {\n    // Simulated Memory usage retrieval\n    Try(\"free -m | grep Mem\".!!) match {\n      case Success(output) =>\n        val memInfo = output.split(\"\\\\s+\")\n        val usedMem = memInfo(2).toDouble\n        val totalMem = memInfo(1).toDouble\n        (usedMem / totalMem) * 100\n      case Failure(_) => throw new RuntimeException(\"Failed to retrieve Memory usage\")\n    }\n  }\n\n  def monitorResources(): Unit = {\n    Try {\n      val cpuUsage = getCpuUsage\n      println(s\"CPU Usage: $cpuUsage%\")\n      if (cpuUsage > 80) throw new RuntimeException(\"CPU usage limit exceeded\")\n\n      val memoryUsage = getMemoryUsage\n      println(s\"Memory Usage: $memoryUsage%\")\n      if (memoryUsage > 80) throw new RuntimeException(\"Memory usage limit exceeded\")\n    } match {\n      case Success(_) => println(\"Resource usage within limits.\")\n      case Failure(exception) => println(s\"Exception caught: ${exception.getMessage}\")\n    }\n  }\n\n  // Run the monitor function\n  monitorResources()\n}\n```"
  },
  {
    "task": "Design a function that validates user input and manages any format exceptions.",
    "code": "```scala\ndef validateInput(input: String): Either[String, Int] = {\n  try {\n    val number = input.toInt\n    Right(number)\n  } catch {\n    case _: NumberFormatException => Left(\"Invalid input format\")\n  }\n}\n\n// Example usage\nval userInput = \"123a\"\nvalidateInput(userInput) match {\n  case Right(value) => println(s\"Valid input: $value\")\n  case Left(error) => println(s\"Error: $error\")\n}\n```"
  },
  {
    "task": "Implement a service that interacts with third-party APIs and handles unexpected response exceptions.",
    "code": "```scala\nimport scala.util.{Try, Success, Failure}\nimport java.net.{URL, HttpURLConnection}\nimport scala.io.Source\n\nobject ApiService {\n\n  def fetchDataFromApi(apiUrl: String): String = {\n    Try {\n      val url = new URL(apiUrl)\n      val connection = url.openConnection().asInstanceOf[HttpURLConnection]\n      connection.setRequestMethod(\"GET\")\n\n      val responseCode = connection.getResponseCode\n\n      if (responseCode == 200) {\n        val source = Source.fromInputStream(connection.getInputStream)\n        val content = source.mkString\n        source.close()\n        content\n      } else {\n        throw new RuntimeException(s\"Unexpected response code: $responseCode\")\n      }\n    } match {\n      case Success(data) => data\n      case Failure(exception) =>\n        println(s\"Error while fetching data: ${exception.getMessage}\")\n        \"\"\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val apiUrl = \"https://api.example.com/data\"\n    val data = fetchDataFromApi(apiUrl)\n    println(s\"Received data: $data\")\n  }\n}\n```"
  },
  {
    "task": "Write a function that uploads files to a server and handles exceptions for unsupported file types.",
    "code": "```scala\nimport java.io.File\n\nobject FileUploader {\n  def uploadFile(filePath: String): Unit = {\n    try {\n      val file = new File(filePath)\n      val supportedFileTypes = Set(\"jpg\", \"png\", \"txt\", \"pdf\")\n      val fileType = file.getName.split(\"\\\\.\").lastOption.getOrElse(\"\")\n\n      if (!supportedFileTypes.contains(fileType)) {\n        throw new UnsupportedFileTypeException(s\"File type '$fileType' is not supported.\")\n      }\n\n      // Simulate file upload\n      println(s\"Uploading file: ${file.getName}\")\n\n    } catch {\n      case e: UnsupportedFileTypeException => \n        println(s\"Error: ${e.getMessage}\")\n      case e: Exception => \n        println(s\"An unexpected error occurred: ${e.getMessage}\")\n    }\n  }\n\n  class UnsupportedFileTypeException(message: String) extends Exception(message)\n}\n```"
  },
  {
    "task": "Create a program that simulates network traffic and manages packet loss exceptions.",
    "code": "```scala\nimport scala.util.{Try, Success, Failure}\nimport scala.util.Random\n\nobject NetworkTrafficSimulator {\n  \n  def simulateNetworkTraffic(packet: Int): Unit = {\n    Try {\n      if (Random.nextInt(100) < 20) // 20% chance to simulate packet loss\n        throw new RuntimeException(\"Packet loss occurred!\")\n      else\n        println(s\"Packet $packet transmitted successfully.\")\n    } match {\n      case Success(_) =>\n      case Failure(exception) => handlePacketLoss(exception, packet)\n    }\n  }\n\n  def handlePacketLoss(exception: Throwable, packet: Int): Unit = {\n    println(s\"Error: ${exception.getMessage} Retrying packet $packet...\")\n    simulateNetworkTraffic(packet)\n  }\n\n  def main(args: Array[String]): Unit = {\n    (1 to 10).foreach(simulateNetworkTraffic)\n  }\n}\n\nNetworkTrafficSimulator.main(Array())\n```"
  },
  {
    "task": "Develop a function that processes XML data and catches any structural exceptions.",
    "code": "```scala\nimport scala.xml.{XML, SAXParseException}\n\ndef processXmlData(xmlString: String): Unit = {\n  try {\n    val xmlData = XML.loadString(xmlString)\n    // Process the XML data here\n    println(\"XML data processed successfully.\")\n  } catch {\n    case e: SAXParseException =>\n      println(s\"Error processing XML data: ${e.getMessage}\")\n    case e: Exception =>\n      println(s\"An unexpected error occurred: ${e.getMessage}\")\n  }\n}\n```"
  },
  {
    "task": "Design a program that handles exceptions when accessing environment variables.",
    "code": "```scala\nobject EnvVarHandler {\n  def getEnvVar(varName: String): String = {\n    try {\n      val value = sys.env(varName)\n      s\"Value of $varName: $value\"\n    } catch {\n      case e: NoSuchElementException => s\"Error: Environment variable '$varName' not found.\"\n      case e: SecurityException => s\"Error: Access to environment variable '$varName' denied.\"\n      case e: Exception => s\"Error: An unexpected error occurred: ${e.getMessage}\"\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val envVarName = \"MY_ENV_VAR\"\n    println(getEnvVar(envVarName))\n  }\n}\n```"
  },
  {
    "task": "Write a function that calculates factorial and manages exceptions for negative input values.",
    "code": "```scala\nobject FactorialCalculator {\n  def factorial(n: Int): Either[String, Int] = {\n    if (n < 0) {\n      Left(\"Factorial is not defined for negative numbers.\")\n    } else {\n      try {\n        Right((1 to n).product)\n      } catch {\n        case _: Exception => Left(\"An error occurred during calculation.\")\n      }\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val inputs = List(5, -3, 0)\n    inputs.foreach { input =>\n      factorial(input) match {\n        case Right(result) => println(s\"Factorial of $input is $result\")\n        case Left(error) => println(s\"Error for input $input: $error\")\n      }\n    }\n  }\n}\n```"
  },
  {
    "task": "Create a software tool that converts file formats and handles unsupported format exceptions.",
    "code": "```scala\nimport java.io.{File, IOException}\n\ncase class UnsupportedFormatException(message: String) extends Exception(message)\n\nobject FileConverter {\n  def convertFile(inputFile: File, targetFormat: String): Unit = {\n    try {\n      val inputFormat = getFileExtension(inputFile)\n      if (!isSupportedFormat(inputFormat)) {\n        throw UnsupportedFormatException(s\"Unsupported input format: $inputFormat\")\n      }\n      if (!isSupportedFormat(targetFormat)) {\n        throw UnsupportedFormatException(s\"Unsupported target format: $targetFormat\")\n      }\n      // Conversion logic placeholder\n      println(s\"Converting ${inputFile.getName} to $targetFormat format...\")\n      // Assume conversion successful\n      println(\"Conversion successful.\")\n    } catch {\n      case e: UnsupportedFormatException => println(s\"Error: ${e.getMessage}\")\n      case e: IOException => println(s\"IO Error: ${e.getMessage}\")\n      case e: Exception => println(s\"Unexpected Error: ${e.getMessage}\")\n    }\n  }\n\n  def getFileExtension(file: File): String = {\n    val name = file.getName\n    val index = name.lastIndexOf('.')\n    if (index > 0) name.substring(index + 1) else \"\"\n  }\n\n  def isSupportedFormat(format: String): Boolean = {\n    val supportedFormats = Set(\"txt\", \"csv\", \"json\", \"xml\")\n    supportedFormats.contains(format.toLowerCase)\n  }\n\n  def main(args: Array[String]): Unit = {\n    val inputFile = new File(\"example.txt\")\n    val targetFormat = \"csv\"\n    convertFile(inputFile, targetFormat)\n  }\n}\n```"
  },
  {
    "task": "Implement a function that sends HTTP requests and catches exceptions for invalid response status codes.",
    "code": "```scala\nimport scala.util.{Try, Failure, Success}\nimport scalaj.http.{Http, HttpResponse}\n\ndef sendHttpRequest(url: String): Unit = {\n  val response: Try[HttpResponse[String]] = Try(Http(url).asString)\n\n  response match {\n    case Success(res) if res.is2xx =>\n      println(s\"Success: ${res.body}\")\n    case Success(res) =>\n      println(s\"Error: Received status code ${res.code}\")\n    case Failure(exception) =>\n      println(s\"Exception occurred: ${exception.getMessage}\")\n  }\n}\n```"
  },
  {
    "task": "Develop a program that interacts with a message queue and handles message delivery exceptions.",
    "code": "```scala\nimport scala.util.{Try, Failure, Success}\n\nobject MessageQueueApp {\n  \n  def connectToQueue(): Try[MessageQueue] = {\n    // Simulated connection to a message queue\n    Try {\n      // Assume MessageQueue is a placeholder for an actual message queue client/connection\n      new MessageQueue()\n    }\n  }\n\n  def sendMessage(queue: MessageQueue, message: String): Try[Unit] = {\n    // Simulated message sending\n    Try {\n      if (message.isEmpty) throw new Exception(\"Message cannot be empty\")\n      queue.send(message)\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val message = \"Hello, World!\"\n\n    val result = for {\n      queue <- connectToQueue()\n      _ <- sendMessage(queue, message)\n    } yield ()\n\n    result match {\n      case Success(_) => println(\"Message sent successfully.\")\n      case Failure(exception) => println(s\"Failed to send message: ${exception.getMessage}\")\n    }\n  }\n}\n\n// Placeholder class to simulate message queue operations\nclass MessageQueue {\n  def send(message: String): Unit = {\n    // Simulate message delivery\n    println(s\"Sending message: $message\")\n  }\n}\n```"
  },
  {
    "task": "Write a function that reads user input and catches exceptions for unexpected data types.",
    "code": "```scala\nimport scala.util.{Try, Success, Failure}\nimport scala.io.StdIn.readLine\n\ndef readUserInput(): Unit = {\n  println(\"Please enter a number:\")\n  val input = readLine()\n  \n  val result = Try(input.toInt) match {\n    case Success(number) => s\"You entered the number: $number\"\n    case Failure(_) => \"Invalid input. Please enter a valid number.\"\n  }\n  \n  println(result)\n}\n\nreadUserInput()\n```"
  },
  {
    "task": "Create a system that processes transactions and manages exceptions for insufficient funds.",
    "code": "```scala\nclass InsufficientFundsException(message: String) extends Exception(message)\n\nclass Account(var balance: Double) {\n  def processTransaction(amount: Double): Unit = {\n    if (amount <= balance) {\n      balance -= amount\n      println(s\"Transaction successful! New balance: $$balance\")\n    } else {\n      throw new InsufficientFundsException(\"Transaction failed: Insufficient funds.\")\n    }\n  }\n}\n\nobject TransactionSystem {\n  def main(args: Array[String]): Unit = {\n    val account = new Account(100.0)\n    \n    try {\n      account.processTransaction(50.0)\n      account.processTransaction(60.0)\n    } catch {\n      case e: InsufficientFundsException => println(e.getMessage)\n    }\n  }\n}\n```"
  },
  {
    "task": "Design a function that generates random numbers and handles exceptions when the range is invalid.",
    "code": "```scala\nimport scala.util.{Try, Random}\n\ndef generateRandomNumber(min: Int, max: Int): Option[Int] = {\n  Try {\n    if (min >= max) throw new IllegalArgumentException(\"Invalid range: min should be less than max\")\n    Random.nextInt(max - min) + min\n  }.toOption\n}\n\n// Example usage\nval randomNumber = generateRandomNumber(10, 5) match {\n  case Some(number) => s\"Generated number: $number\"\n  case None => \"Failed to generate number due to invalid range\"\n}\n\nprintln(randomNumber)\n```"
  },
  {
    "task": "Implement a program that performs image processing and catches exceptions for unsupported file dimensions.",
    "code": "```scala\nimport java.awt.image.BufferedImage\nimport javax.imageio.ImageIO\nimport java.io.File\nimport java.io.IOException\n\nobject ImageProcessor {\n  def processImage(filePath: String): Unit = {\n    try {\n      val image: BufferedImage = ImageIO.read(new File(filePath))\n      if (image.getWidth < 1 || image.getHeight < 1) {\n        throw new UnsupportedOperationException(\"Unsupported file dimensions\")\n      }\n      // Image processing logic here\n      println(\"Image processed successfully.\")\n    } catch {\n      case e: IOException =>\n        println(s\"An error occurred while reading the image: ${e.getMessage}\")\n      case e: UnsupportedOperationException =>\n        println(s\"Exception caught: ${e.getMessage}\")\n      case e: Exception =>\n        println(s\"An unexpected error occurred: ${e.getMessage}\")\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    if (args.length > 0) {\n      processImage(args(0))\n    } else {\n      println(\"Please provide the image file path as an argument.\")\n    }\n  }\n}\n```"
  },
  {
    "task": "Write a function that manipulates strings and manages exceptions for invalid operations.",
    "code": "```scala\nobject StringManipulator {\n  def manipulateString(input: String): String = {\n    try {\n      if (input == null) throw new IllegalArgumentException(\"Input cannot be null\")\n      // Example manipulation: reverse the string\n      input.reverse\n    } catch {\n      case e: IllegalArgumentException =>\n        println(s\"Exception encountered: ${e.getMessage}\")\n        \"Invalid Input\"\n      case e: Exception =>\n        println(s\"Unexpected exception: ${e.getMessage}\")\n        \"Error\"\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    println(manipulateString(\"hello\"))    // Outputs: \"olleh\"\n    println(manipulateString(null))       // Outputs: \"Invalid Input\"\n  }\n}\n```"
  },
  {
    "task": "Create a script that automates tasks and handles exceptions for missing dependencies.",
    "code": "```scala\nimport scala.sys.process._\nimport scala.util.{Try, Failure, Success}\n\nobject TaskAutomator {\n\n  def main(args: Array[String]): Unit = {\n    val dependencies = List(\"git\", \"curl\", \"java\")\n\n    dependencies.foreach { dep =>\n      try {\n        checkDependency(dep)\n        println(s\"$dep is installed.\")\n      } catch {\n        case e: Exception =>\n          println(s\"Error: ${e.getMessage}\")\n      }\n    }\n\n    // Simulate task automation\n    automateTasks()\n  }\n\n  def checkDependency(dep: String): Unit = {\n    val result = Try(s\"which $dep\".!!)\n\n    result match {\n      case Success(_) => // Dependency is installed\n      case Failure(_) => throw new Exception(s\"Missing dependency: $dep\")\n    }\n  }\n\n  def automateTasks(): Unit = {\n    // Example task automation\n    try {\n      println(\"Running automated tasks...\")\n      // Simulate a task that might fail\n      val result = Try(\"non_existent_command\".!!)\n      result match {\n        case Success(output) => println(s\"Task output: $output\")\n        case Failure(exception) => throw new Exception(\"Automated task failed\")\n      }\n    } catch {\n      case e: Exception =>\n        println(s\"Error in task automation: ${e.getMessage}\")\n    }\n  }\n}\n```"
  },
  {
    "task": "Develop a function that accesses nested data structures and manages key access exceptions.",
    "code": "```scala\nobject NestedDataAccessor {\n  def accessNestedData(data: Map[String, Any], keys: List[String]): Option[Any] = {\n    try {\n      keys.foldLeft(data: Any) {\n        case (currentData: Map[String, Any], key) => currentData(key)\n        case _ => throw new NoSuchElementException(\"Key not found\")\n      } match {\n        case result: Any => Some(result)\n        case _ => None\n      }\n    } catch {\n      case _: NoSuchElementException => None\n      case _: Throwable => None\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val nestedData = Map(\n      \"first\" -> Map(\n        \"second\" -> Map(\n          \"third\" -> \"value\"\n        )\n      )\n    )\n    println(accessNestedData(nestedData, List(\"first\", \"second\", \"third\"))) // Some(\"value\")\n    println(accessNestedData(nestedData, List(\"first\", \"second\", \"missing\"))) // None\n  }\n}\n```"
  },
  {
    "task": "Design a program that synchronizes data between sources and handles data mismatch exceptions.",
    "code": "```scala\nimport scala.util.{Try, Success, Failure}\n\n// Custom exception for data mismatch\ncase class DataMismatchException(message: String) extends Exception(message)\n\n// Sample data sources\nval source1: Map[String, String] = Map(\"key1\" -> \"value1\", \"key2\" -> \"value2\")\nval source2: Map[String, String] = Map(\"key1\" -> \"value1\", \"key2\" -> \"differentValue\")\n\ndef synchronizeData(sourceA: Map[String, String], sourceB: Map[String, String]): Unit = {\n  sourceA.keys.foreach { key =>\n    Try {\n      if (sourceA(key) != sourceB(key)) {\n        throw DataMismatchException(s\"Data mismatch for key: $key\")\n      } else {\n        println(s\"Data match for key: $key\")\n      }\n    } match {\n      case Success(_) =>\n      case Failure(ex: DataMismatchException) => println(ex.getMessage)\n      case Failure(ex) => println(s\"Unexpected error: ${ex.getMessage}\")\n    }\n  }\n}\n\nsynchronizeData(source1, source2)\n```"
  },
  {
    "task": "Write a function that interacts with hardware devices and handles connection failure exceptions.",
    "code": "```scala\nimport scala.util.{Try, Failure, Success}\n\nclass HardwareDevice {\n  def connect(): Unit = {\n    // Simulate connection logic\n    throw new RuntimeException(\"Connection failed\")\n  }\n}\n\nobject DeviceManager {\n  def connectToDevice(device: HardwareDevice): Unit = {\n    Try(device.connect()) match {\n      case Success(_) =>\n        println(\"Device connected successfully.\")\n      case Failure(exception) =>\n        println(s\"Failed to connect to device: ${exception.getMessage}\")\n    }\n  }\n}\n\n// Usage\nval device = new HardwareDevice\nDeviceManager.connectToDevice(device)\n```"
  },
  {
    "task": "Create a tool that compresses files and manages exceptions for unsupported compression formats.",
    "code": "```scala\nimport java.io.{File, FileInputStream, FileOutputStream}\nimport java.util.zip.{ZipEntry, ZipOutputStream}\n\nobject FileCompressor {\n  def compressFile(filePath: String, outputPath: String): Unit = {\n    try {\n      val fileToCompress = new File(filePath)\n      val fos = new FileOutputStream(outputPath)\n      val zos = new ZipOutputStream(fos)\n\n      val fis = new FileInputStream(fileToCompress)\n      val zipEntry = new ZipEntry(fileToCompress.getName)\n      zos.putNextEntry(zipEntry)\n\n      val buffer = new Array[Byte](1024)\n      var length = fis.read(buffer)\n      while (length > 0) {\n        zos.write(buffer, 0, length)\n        length = fis.read(buffer)\n      }\n\n      zos.closeEntry()\n      fis.close()\n      zos.close()\n      fos.close()\n    } catch {\n      case e: Exception =>\n        println(s\"An error occurred during compression: ${e.getMessage}\")\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    if (args.length != 2) {\n      println(\"Usage: FileCompressor <file-to-compress> <output-zip-file>\")\n    } else {\n      compressFile(args(0), args(1))\n    }\n  }\n}\n```"
  },
  {
    "task": "Implement a function that parses command-line arguments and handles missing argument exceptions.",
    "code": "```scala\nobject CommandLineParser {\n\n  def main(args: Array[String]): Unit = {\n    try {\n      val result = parseArguments(args)\n      println(s\"Parsed argument: $result\")\n    } catch {\n      case e: MissingArgumentException => println(e.getMessage)\n    }\n  }\n\n  def parseArguments(args: Array[String]): String = {\n    if (args.isEmpty) {\n      throw new MissingArgumentException(\"No arguments provided.\")\n    }\n    args(0)\n  }\n\n  class MissingArgumentException(message: String) extends Exception(message)\n}\n```"
  },
  {
    "task": "Develop a program that simulates user interactions and manages timing exceptions.",
    "code": "```scala\nimport scala.concurrent.{Future, Await}\nimport scala.concurrent.ExecutionContext.Implicits.global\nimport scala.concurrent.duration._\nimport scala.util.{Success, Failure, Try}\n\nobject UserInteractionSimulator {\n\n  def simulateUserInteraction(): Future[String] = Future {\n    // Simulate some user interaction\n    Thread.sleep(2000)\n    \"User interaction complete\"\n  }\n\n  def main(args: Array[String]): Unit = {\n    val userInteractionFuture = simulateUserInteraction()\n\n    try {\n      val result = Await.result(userInteractionFuture, 1.second)\n      println(result)\n    } catch {\n      case e: java.util.concurrent.TimeoutException =>\n        println(\"Exception: Interaction timed out!\")\n      case e: Exception =>\n        println(s\"Exception: ${e.getMessage}\")\n    }\n\n    // Handle potential failures\n    userInteractionFuture.onComplete {\n      case Success(message) => println(s\"Success: $message\")\n      case Failure(exception) => println(s\"Failure: ${exception.getMessage}\")\n    }\n\n    // Keep the application running to see the async result\n    Thread.sleep(3000)\n  }\n}\n```"
  },
  {
    "task": "Write a function that encrypts data and handles exceptions for unsupported encryption algorithms.",
    "code": "```scala\nimport javax.crypto.Cipher\nimport javax.crypto.spec.SecretKeySpec\nimport java.util.Base64\n\nobject Encryptor {\n  def encrypt(data: String, key: String, algorithm: String): Either[String, String] = {\n    try {\n      val secretKey = new SecretKeySpec(key.getBytes(\"UTF-8\"), algorithm)\n      val cipher = Cipher.getInstance(algorithm)\n      cipher.init(Cipher.ENCRYPT_MODE, secretKey)\n      val encryptedData = cipher.doFinal(data.getBytes(\"UTF-8\"))\n      Right(Base64.getEncoder.encodeToString(encryptedData))\n    } catch {\n      case e: java.security.NoSuchAlgorithmException => Left(\"Unsupported encryption algorithm: \" + algorithm)\n      case e: javax.crypto.NoSuchPaddingException => Left(\"Unsupported padding for algorithm: \" + algorithm)\n      case e: Exception => Left(\"Encryption failed: \" + e.getMessage)\n    }\n  }\n}\n```"
  },
  {
    "task": "Create a system that aggregates data and manages exceptions for data inconsistency.",
    "code": "```scala\nimport scala.util.{Try, Success, Failure}\n\nobject DataAggregator {\n  def aggregateData(data: List[String]): Int = {\n    data.map { item =>\n      Try(item.toInt) match {\n        case Success(value) => value\n        case Failure(exception) =>\n          println(s\"Exception caught: ${exception.getMessage}\")\n          0 // default value for inconsistent data\n      }\n    }.sum\n  }\n\n  def main(args: Array[String]): Unit = {\n    val data = List(\"1\", \"2\", \"three\", \"4\", \"five\")\n    val result = aggregateData(data)\n    println(s\"Aggregated Result: $result\")\n  }\n}\n```"
  },
  {
    "task": "Design a program that processes real-time data streams and handles connection drop exceptions.",
    "code": "```scala\nimport scala.util.Try\n\nobject RealTimeDataProcessor {\n  def main(args: Array[String]): Unit = {\n    while (true) {\n      Try(processDataStream()).recover {\n        case e: ConnectionDropException => println(s\"Connection dropped: ${e.getMessage}\")\n        case e: Exception => println(s\"An unexpected error occurred: ${e.getMessage}\")\n      }\n    }\n  }\n\n  def processDataStream(): Unit = {\n    // Simulate data processing\n    if (Math.random() < 0.1) throw new ConnectionDropException(\"Simulated connection drop\")\n    println(\"Data processed successfully\")\n  }\n}\n\nclass ConnectionDropException(message: String) extends Exception(message)\n```"
  },
  {
    "task": "Implement a function that performs scientific calculations and manages precision exceptions.",
    "code": "```scala\nobject ScientificCalculator {\n  def performCalculation(input: Double): Double = {\n    try {\n      if (input.isNaN || input.isInfinity) throw new ArithmeticException(\"Invalid input for calculation\")\n      // Example scientific calculation\n      val result = Math.pow(input, 2) / Math.sqrt(input)\n      if (result.isNaN || result.isInfinity) throw new ArithmeticException(\"Calculation resulted in an invalid number\")\n      result\n    } catch {\n      case ex: ArithmeticException =>\n        println(s\"Exception occurred: ${ex.getMessage}\")\n        Double.NaN\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val inputs = List(4.0, -1.0, Double.NaN)\n    inputs.foreach(input => println(s\"Input: $input, Result: ${performCalculation(input)}\"))\n  }\n}\n```"
  },
  {
    "task": "Write a script that generates reports and handles exceptions for missing data sources.",
    "code": "```scala\nimport scala.util.{Try, Failure, Success}\n\nobject ReportGenerator {\n\n  def generateReport(source: String): Try[String] = {\n    // Simulate report generation\n    if (source.isEmpty) Failure(new Exception(\"Data source is missing\"))\n    else Success(s\"Report generated using source: $source\")\n  }\n\n  def main(args: Array[String]): Unit = {\n    val dataSource = \"\" // Simulate a missing data source\n\n    generateReport(dataSource) match {\n      case Success(report) => println(report)\n      case Failure(exception) => println(s\"Error: ${exception.getMessage}\")\n    }\n  }\n}\n```"
  },
  {
    "task": "Create a program that validates digital certificates and manages trust exceptions.",
    "code": "```scala\nimport java.security.cert.{CertificateException, X509Certificate}\nimport javax.net.ssl.{TrustManager, X509TrustManager, SSLContext}\n\nobject CertificateValidator {\n  def main(args: Array[String]): Unit = {\n    // Create a TrustManager that trusts all certificates\n    val trustAllCerts = Array[TrustManager](\n      new X509TrustManager {\n        override def checkClientTrusted(chain: Array[X509Certificate], authType: String): Unit = {}\n\n        override def checkServerTrusted(chain: Array[X509Certificate], authType: String): Unit = {\n          try {\n            // Implement your certificate validation logic here\n            if (chain == null || chain.isEmpty) {\n              throw new CertificateException(\"Certificate chain is invalid\")\n            }\n            // Assume cert is valid if first certificate is not null\n            if (chain(0) == null) {\n              throw new CertificateException(\"Certificate is invalid\")\n            }\n          } catch {\n            case e: CertificateException =>\n              println(s\"Trust exception occurred: ${e.getMessage}\")\n          }\n        }\n\n        override def getAcceptedIssuers: Array[X509Certificate] = Array()\n      }\n    )\n\n    try {\n      // Set up an SSL context that uses the trust manager\n      val sslContext = SSLContext.getInstance(\"SSL\")\n      sslContext.init(null, trustAllCerts, new java.security.SecureRandom())\n      println(\"SSL context initialized successfully.\")\n    } catch {\n      case e: Exception =>\n        println(s\"Exception during SSL context initialization: ${e.getMessage}\")\n    }\n  }\n}\n```"
  },
  {
    "task": "Develop a function that schedules tasks and handles exceptions for scheduling conflicts.",
    "code": "```scala\nimport scala.util.{Try, Success, Failure}\n\ncase class Task(name: String, time: Int)\n\nclass Scheduler {\n  private var scheduledTasks: List[Task] = List()\n\n  def scheduleTask(task: Task): String = {\n    Try {\n      if (scheduledTasks.exists(_.time == task.time)) {\n        throw new RuntimeException(s\"Conflict: Task '${task.name}' conflicts with existing task at time ${task.time}\")\n      } else {\n        scheduledTasks = task :: scheduledTasks\n        s\"Task '${task.name}' scheduled at time ${task.time}\"\n      }\n    } match {\n      case Success(message) => message\n      case Failure(exception) => s\"Failed to schedule task: ${exception.getMessage}\"\n    }\n  }\n}\n\nobject SchedulerApp extends App {\n  val scheduler = new Scheduler()\n  println(scheduler.scheduleTask(Task(\"Task1\", 10)))\n  println(scheduler.scheduleTask(Task(\"Task2\", 10)))\n  println(scheduler.scheduleTask(Task(\"Task3\", 11)))\n}\n```"
  },
  {
    "task": "Design a system that manages user sessions and handles session timeout exceptions.",
    "code": "```scala\nimport java.time.LocalDateTime\nimport scala.collection.mutable\n\ncase class Session(userId: String, startTime: LocalDateTime, durationInMinutes: Int)\n\nclass SessionManager {\n  private val sessions: mutable.Map[String, Session] = mutable.Map()\n\n  def startSession(userId: String, durationInMinutes: Int): Unit = {\n    val session = Session(userId, LocalDateTime.now, durationInMinutes)\n    sessions(userId) = session\n  }\n\n  def checkSession(userId: String): Unit = {\n    sessions.get(userId) match {\n      case Some(session) =>\n        val currentTime = LocalDateTime.now\n        val sessionEndTime = session.startTime.plusMinutes(session.durationInMinutes)\n        if (currentTime.isAfter(sessionEndTime)) {\n          sessions.remove(userId)\n          throw new SessionTimeoutException(s\"Session for user $userId has timed out.\")\n        } else {\n          println(s\"Session for user $userId is active.\")\n        }\n      case None =>\n        throw new SessionNotFoundException(s\"No session found for user $userId.\")\n    }\n  }\n\n  def endSession(userId: String): Unit = {\n    if (sessions.contains(userId)) {\n      sessions.remove(userId)\n      println(s\"Session for user $userId ended.\")\n    } else {\n      throw new SessionNotFoundException(s\"No session found for user $userId.\")\n    }\n  }\n}\n\nclass SessionTimeoutException(message: String) extends Exception(message)\nclass SessionNotFoundException(message: String) extends Exception(message)\n\n// Example usage:\nval sessionManager = new SessionManager()\n\ntry {\n  sessionManager.startSession(\"user1\", 1) // 1 minute session\n  Thread.sleep(2000) // Simulate some delay\n  sessionManager.checkSession(\"user1\") // Check session status\n  Thread.sleep(60000) // Simulate passing time\n  sessionManager.checkSession(\"user1\") // Check session status again\n} catch {\n  case e: SessionTimeoutException => println(e.getMessage)\n  case e: SessionNotFoundException => println(e.getMessage)\n}\n```"
  },
  {
    "task": "Write a function that processes audio files and manages exceptions for unsupported audio formats.",
    "code": "```scala\nimport java.io.File\n\nobject AudioProcessor {\n  def processAudioFile(file: File): Unit = {\n    try {\n      if (!isSupportedFormat(file)) {\n        throw new UnsupportedAudioFormatException(s\"Unsupported audio format: ${file.getName}\")\n      }\n      // Process the audio file\n      println(s\"Processing audio file: ${file.getName}\")\n    } catch {\n      case e: UnsupportedAudioFormatException =>\n        println(s\"Error: ${e.getMessage}\")\n      case e: Exception =>\n        println(s\"An unexpected error occurred: ${e.getMessage}\")\n    }\n  }\n\n  def isSupportedFormat(file: File): Boolean = {\n    // Dummy check for supported formats\n    val supportedFormats = Set(\".mp3\", \".wav\", \".flac\")\n    supportedFormats.exists(file.getName.endsWith)\n  }\n\n  class UnsupportedAudioFormatException(message: String) extends Exception(message)\n\n  def main(args: Array[String]): Unit = {\n    val file1 = new File(\"song.mp3\")\n    val file2 = new File(\"track.xyz\")\n    processAudioFile(file1)\n    processAudioFile(file2)\n  }\n}\n```"
  },
  {
    "task": "Create a service that sends notifications and handles exceptions for unreachable destinations.",
    "code": "```scala\nobject NotificationService {\n  def sendNotification(destination: String, message: String): Unit = {\n    try {\n      if (destination.isEmpty) throw new IllegalArgumentException(\"Destination cannot be empty\")\n      println(s\"Sending message: '$message' to destination: $destination\")\n      // Simulate sending logic, might throw exceptions in real use case\n    } catch {\n      case ex: IllegalArgumentException =>\n        println(s\"Failed to send notification: ${ex.getMessage}\")\n      case ex: Exception =>\n        println(s\"An error occurred: ${ex.getMessage}\")\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    sendNotification(\"user@example.com\", \"Hello!\")\n    sendNotification(\"\", \"This will fail\")\n  }\n}\n```"
  },
  {
    "task": "Implement a program that performs data migration and manages data transformation exceptions.",
    "code": "```scala\nimport scala.util.{Try, Success, Failure}\n\nobject DataMigration {\n\n  def main(args: Array[String]): Unit = {\n    val dataToMigrate = List(\"123\", \"456\", \"abc\", \"789\")\n\n    dataToMigrate.foreach { data =>\n      handleDataMigration(data) match {\n        case Success(result) => println(s\"Data migrated successfully: $result\")\n        case Failure(ex) => println(s\"Data migration failed: ${ex.getMessage}\")\n      }\n    }\n  }\n\n  def handleDataMigration(data: String): Try[Int] = {\n    Try {\n      transformData(data)\n    }\n  }\n\n  def transformData(data: String): Int = {\n    data.toInt\n  }\n}\n```"
  },
  {
    "task": "Develop a function that processes video files and handles codec compatibility exceptions.",
    "code": "```scala\nimport scala.util.{Try, Failure, Success}\n\nclass CodecCompatibilityException(message: String) extends Exception(message)\n\nobject VideoProcessor {\n  def processVideo(filePath: String): Unit = {\n    Try {\n      // Simulate video processing\n      if (!isCodecCompatible(filePath)) {\n        throw new CodecCompatibilityException(s\"Codec not compatible for file: $filePath\")\n      }\n      println(s\"Processing video file: $filePath\")\n    } match {\n      case Success(_) => println(\"Video processed successfully.\")\n      case Failure(e: CodecCompatibilityException) => println(s\"Error: ${e.getMessage}\")\n      case Failure(e) => println(s\"Unexpected error: ${e.getMessage}\")\n    }\n  }\n\n  def isCodecCompatible(filePath: String): Boolean = {\n    // Simulate codec compatibility check\n    filePath.endsWith(\".mp4\")\n  }\n\n  def main(args: Array[String]): Unit = {\n    processVideo(\"example.mp4\")\n    processVideo(\"example.avi\")\n  }\n}\n```"
  },
  {
    "task": "Write a function that manages memory allocation and catches out-of-memory exceptions.",
    "code": "```scala\ndef manageMemoryAllocation(size: Int): Option[Array[Byte]] = {\n  try {\n    Some(new Array[Byte](size))\n  } catch {\n    case _: OutOfMemoryError => None\n  }\n}\n```"
  },
  {
    "task": "Create a program that processes financial transactions and handles currency conversion exceptions.",
    "code": "```scala\nobject FinancialTransactionProcessor {\n  def main(args: Array[String]): Unit = {\n    val amount = 100.0\n    val currency = \"USD\"\n\n    try {\n      val convertedAmount = convertCurrency(amount, currency)\n      println(s\"Converted amount: $convertedAmount\")\n    } catch {\n      case e: CurrencyConversionException =>\n        println(s\"Error: ${e.getMessage}\")\n    }\n  }\n\n  def convertCurrency(amount: Double, currency: String): Double = {\n    currency match {\n      case \"USD\" => amount * 0.84 // Example conversion rate\n      case \"EUR\" => amount * 1.19 // Example conversion rate\n      case _ => throw new CurrencyConversionException(s\"Unsupported currency: $currency\")\n    }\n  }\n}\n\nclass CurrencyConversionException(message: String) extends Exception(message)\n```"
  },
  {
    "task": "Design a function that interacts with cloud storage and manages access permission exceptions.",
    "code": "```scala\nimport scala.util.{Try, Success, Failure}\n\nobject CloudStorageManager {\n\n  case class AccessDeniedException(message: String) extends Exception(message)\n  case class StorageException(message: String) extends Exception(message)\n\n  def accessCloudStorage(resource: String): String = {\n    // Simulated function to access cloud storage\n    if (resource == \"restricted\") throw AccessDeniedException(\"Access Denied\")\n    else if (resource.isEmpty) throw StorageException(\"Resource not found\")\n    else \"Resource content\"\n  }\n\n  def manageAccess(resource: String): Unit = {\n    val result = Try(accessCloudStorage(resource))\n\n    result match {\n      case Success(content) =>\n        println(s\"Access granted: $content\")\n      case Failure(ex: AccessDeniedException) =>\n        println(s\"Access failed: ${ex.getMessage}\")\n      case Failure(ex) =>\n        println(s\"An error occurred: ${ex.getMessage}\")\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    manageAccess(\"restricted\")\n    manageAccess(\"validResource\")\n    manageAccess(\"\")\n  }\n}\n```"
  },
  {
    "task": "Implement a script that automates deployment and handles exceptions for missing configuration files.",
    "code": "```scala\nimport scala.io.Source\nimport java.io.FileNotFoundException\nimport java.io.IOException\n\nobject DeploymentAutomation {\n  def main(args: Array[String]): Unit = {\n    try {\n      val configFilePath = \"config.txt\"\n      val configFile = Source.fromFile(configFilePath)\n      \n      // Simulate reading configuration\n      val configData = configFile.getLines().mkString(\"\\n\")\n      configFile.close()\n\n      // Proceed with deployment using the configuration\n      deploy(configData)\n\n    } catch {\n      case e: FileNotFoundException =>\n        println(s\"Error: Configuration file not found. Details: ${e.getMessage}\")\n      case e: IOException =>\n        println(s\"Error: An IO exception occurred. Details: ${e.getMessage}\")\n      case e: Exception =>\n        println(s\"An unexpected error occurred: ${e.getMessage}\")\n    }\n  }\n\n  def deploy(configData: String): Unit = {\n    println(s\"Deploying with the following configuration:\\n$configData\")\n    // Deployment logic here\n  }\n}\n```"
  },
  {
    "task": "Write a function that normalizes data and handles exceptions for invalid data ranges.",
    "code": "```scala\ndef normalizeData(value: Double, min: Double, max: Double): Double = {\n  try {\n    if (min >= max) throw new IllegalArgumentException(\"min must be less than max\")\n    if (value < min || value > max) throw new IllegalArgumentException(\"value must be within the range\")\n\n    (value - min) / (max - min)\n  } catch {\n    case e: IllegalArgumentException => \n      println(s\"Exception: ${e.getMessage}\")\n      Double.NaN\n  }\n}\n```"
  },
  {
    "task": "Create a system that monitors application performance and handles threshold breach exceptions.",
    "code": "```scala\nimport scala.util.{Try, Success, Failure}\n\nclass PerformanceMonitor(threshold: Double) {\n  def monitorPerformance(currentPerformance: Double): Unit = {\n    try {\n      checkThreshold(currentPerformance)\n      println(s\"Performance is within acceptable limits: $currentPerformance\")\n    } catch {\n      case e: ThresholdBreachException => println(e.getMessage)\n    }\n  }\n\n  private def checkThreshold(performance: Double): Unit = {\n    if (performance > threshold) {\n      throw new ThresholdBreachException(s\"Threshold breached! Current performance: $performance\")\n    }\n  }\n}\n\nclass ThresholdBreachException(message: String) extends Exception(message)\n\nobject AppPerformance {\n  def main(args: Array[String]): Unit = {\n    val monitor = new PerformanceMonitor(80.0)\n\n    val performances = List(75.0, 82.0, 78.0, 85.0)\n\n    performances.foreach { performance =>\n      monitor.monitorPerformance(performance)\n    }\n  }\n}\n```"
  },
  {
    "task": "Develop a program that processes social media data and manages API limit exceptions.",
    "code": "```scala\nimport scala.util.{Try, Success, Failure}\n\n// Mock API class to simulate social media data fetching and API limits\nobject SocialMediaAPI {\n  private var callCount = 0\n  private val apiLimit = 5\n\n  def fetchData(): String = {\n    if (callCount >= apiLimit) {\n      throw new RuntimeException(\"API limit reached\")\n    }\n    callCount += 1\n    s\"Fetched data #$callCount\"\n  }\n}\n\nobject SocialMediaDataProcessor {\n  def processData(): Unit = {\n    Try(SocialMediaAPI.fetchData()) match {\n      case Success(data) => println(s\"Data processed: $data\")\n      case Failure(exception) => println(s\"Error occurred: ${exception.getMessage}\")\n    }\n  }\n}\n\nobject Main extends App {\n  (1 to 10).foreach(_ => SocialMediaDataProcessor.processData())\n}\n```"
  },
  {
    "task": "Design a function that integrates with payment gateways and handles payment failure exceptions.",
    "code": "```scala\nimport scala.util.{Try, Success, Failure}\n\nobject PaymentProcessor {\n  def processPayment(amount: Double): Unit = {\n    try {\n      val result = integrateWithPaymentGateway(amount)\n      println(s\"Payment of $$amount succeeded: $result\")\n    } catch {\n      case e: PaymentException =>\n        println(s\"Payment of $$amount failed: ${e.getMessage}\")\n    }\n  }\n\n  def integrateWithPaymentGateway(amount: Double): Boolean = {\n    // Simulated payment gateway integration\n    if (amount <= 0) throw new PaymentException(\"Invalid amount\")\n    if (amount > 1000) throw new PaymentException(\"Amount exceeds limit\")\n    true // Simulate successful payment\n  }\n\n  class PaymentException(message: String) extends Exception(message)\n}\n\nobject Main extends App {\n  PaymentProcessor.processPayment(500)\n  PaymentProcessor.processPayment(0)\n  PaymentProcessor.processPayment(1500)\n}\n```"
  },
  {
    "task": "Write a function that backs up data and handles exceptions for unavailable storage media.",
    "code": "```scala\nimport java.io._\n\ndef backupData(data: String, backupPath: String): Unit = {\n  try {\n    val file = new File(backupPath)\n    val writer = new BufferedWriter(new FileWriter(file))\n    writer.write(data)\n    writer.close()\n    println(\"Backup successful.\")\n  } catch {\n    case e: IOException =>\n      println(s\"Failed to backup data: ${e.getMessage}\")\n  }\n}\n\n// Example usage:\nbackupData(\"Important data\", \"backup.txt\")\n```"
  },
  {
    "task": "Create a tool that manages software updates and handles exceptions for version conflicts.",
    "code": "```scala\nobject SoftwareUpdateManager {\n  case class VersionConflictException(message: String) extends Exception(message)\n\n  def updateSoftware(currentVersion: String, newVersion: String): Unit = {\n    try {\n      if (newVersion <= currentVersion) {\n        throw VersionConflictException(s\"Version conflict: $newVersion is not newer than $currentVersion.\")\n      }\n      println(s\"Updating software from version $currentVersion to $newVersion...\")\n      // Simulate update logic here\n      println(\"Update successful.\")\n    } catch {\n      case e: VersionConflictException =>\n        println(s\"Update failed: ${e.getMessage}\")\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    updateSoftware(\"1.0.0\", \"1.0.1\")  // Successful update\n    updateSoftware(\"1.0.1\", \"1.0.0\")  // Version conflict\n  }\n}\n```"
  },
  {
    "task": "Implement a program that performs sentiment analysis and manages exceptions for ambiguous texts.",
    "code": "```scala\nimport scala.util.{Try, Success, Failure}\n\nobject SentimentAnalysisApp extends App {\n\n  def analyzeSentiment(text: String): String = {\n    // Dummy sentiment analysis logic\n    if (text.contains(\"happy\")) \"Positive\"\n    else if (text.contains(\"sad\")) \"Negative\"\n    else throw new IllegalArgumentException(\"Ambiguous sentiment in text\")\n  }\n\n  def handleSentimentAnalysis(text: String): Unit = {\n    Try(analyzeSentiment(text)) match {\n      case Success(sentiment) => println(s\"Sentiment: $sentiment\")\n      case Failure(exception) => println(s\"Error: ${exception.getMessage}\")\n    }\n  }\n\n  val texts = List(\n    \"I am very happy today!\",\n    \"This is a sad moment.\",\n    \"It is a day.\"\n  )\n\n  texts.foreach(handleSentimentAnalysis)\n}\n```"
  },
  {
    "task": "Develop a function that manages user authentication and handles credential mismatch exceptions.",
    "code": "```scala\nimport scala.util.{Try, Failure, Success}\n\nclass AuthenticationException(message: String) extends Exception(message)\n\nobject Authenticator {\n  private val storedUsername = \"admin\"\n  private val storedPassword = \"password123\"\n\n  def authenticate(username: String, password: String): Try[String] = {\n    if (username == storedUsername && password == storedPassword) {\n      Success(\"Authentication successful\")\n    } else {\n      Failure(new AuthenticationException(\"Credential mismatch\"))\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val username = \"admin\"\n    val password = \"wrongpassword\"\n\n    authenticate(username, password) match {\n      case Success(message) => println(message)\n      case Failure(exception) => println(s\"Authentication failed: ${exception.getMessage}\")\n    }\n  }\n}\n```"
  },
  {
    "task": "Write a program that processes geographic data and handles exceptions for invalid coordinates.",
    "code": "```scala\nobject GeoDataProcessor {\n\n  case class Coordinate(latitude: Double, longitude: Double)\n\n  class InvalidCoordinateException(message: String) extends Exception(message)\n\n  def validateCoordinate(coordinate: Coordinate): Unit = {\n    if (coordinate.latitude < -90 || coordinate.latitude > 90) {\n      throw new InvalidCoordinateException(s\"Invalid latitude: ${coordinate.latitude}\")\n    }\n    if (coordinate.longitude < -180 || coordinate.longitude > 180) {\n      throw new InvalidCoordinateException(s\"Invalid longitude: ${coordinate.longitude}\")\n    }\n  }\n\n  def processGeographicData(coordinates: List[Coordinate]): Unit = {\n    coordinates.foreach { coordinate =>\n      try {\n        validateCoordinate(coordinate)\n        println(s\"Processing coordinate: $coordinate\")\n      } catch {\n        case e: InvalidCoordinateException => println(s\"Error: ${e.getMessage}\")\n      }\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val coordinates = List(\n      Coordinate(34.05, -118.25),\n      Coordinate(91.0, -150.0), // Invalid latitude\n      Coordinate(40.71, -185.0) // Invalid longitude\n    )\n    processGeographicData(coordinates)\n  }\n}\n```"
  },
  {
    "task": "Create a script that manages network configurations and handles exceptions for invalid syntax.",
    "code": "```scala\nimport scala.util.{Try, Success, Failure}\n\nobject NetworkConfigManager {\n  def updateConfig(config: String): Unit = {\n    Try {\n      // Simulate parsing and updating network configuration\n      if (!isValidConfig(config)) throw new IllegalArgumentException(\"Invalid syntax in configuration\")\n      println(s\"Configuration updated: $config\")\n    } match {\n      case Success(_) => println(\"Configuration update successful.\")\n      case Failure(exception) => println(s\"Failed to update configuration: ${exception.getMessage}\")\n    }\n  }\n\n  def isValidConfig(config: String): Boolean = {\n    // Add logic to validate the network configuration syntax\n    config.nonEmpty // Placeholder for actual validation logic\n  }\n\n  def main(args: Array[String]): Unit = {\n    val configs = List(\n      \"validConfig1\",\n      \"\",\n      \"validConfig2\"\n    )\n\n    configs.foreach(updateConfig)\n  }\n}\n\nNetworkConfigManager.main(Array())\n```"
  },
  {
    "task": "Design a function that processes biometric data and handles exceptions for sensor errors.",
    "code": "```scala\nobject BiometricProcessor {\n\n  class SensorError(message: String) extends Exception(message)\n\n  def processBiometricData(data: String): Unit = {\n    try {\n      if (data == null || data.isEmpty) {\n        throw new SensorError(\"Invalid biometric data: Data is null or empty\")\n      }\n      // Process the biometric data here\n      println(s\"Processing biometric data: $data\")\n    } catch {\n      case e: SensorError =>\n        println(s\"Sensor error occurred: ${e.getMessage}\")\n      case e: Exception =>\n        println(s\"An unexpected error occurred: ${e.getMessage}\")\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    processBiometricData(\"SampleBiometricData\")\n    processBiometricData(\"\")\n  }\n}\n```"
  },
  {
    "task": "Implement a system that manages access control and handles exceptions for unauthorized access attempts.",
    "code": "```scala\nclass AccessControl {\n  private val authorizedUsers: Set[String] = Set(\"admin\", \"user1\", \"user2\")\n\n  def checkAccess(username: String): Unit = {\n    try {\n      if (!authorizedUsers.contains(username)) {\n        throw new UnauthorizedAccessException(s\"Access denied for user: $username\")\n      }\n      println(s\"Access granted for user: $username\")\n    } catch {\n      case e: UnauthorizedAccessException => println(e.getMessage)\n    }\n  }\n}\n\nclass UnauthorizedAccessException(message: String) extends Exception(message)\n\n// Example usage\nobject AccessControlTest extends App {\n  val accessControl = new AccessControl\n\n  accessControl.checkAccess(\"admin\")  // Access granted\n  accessControl.checkAccess(\"guest\")  // Access denied\n}\n```"
  },
  {
    "task": "Write a function that performs load balancing and handles exceptions for unreachable nodes.",
    "code": "```scala\nimport scala.util.{Try, Success, Failure}\n\ndef loadBalance(nodes: List[String]): Unit = {\n  nodes.foreach { node =>\n    Try {\n      connectToNode(node)\n    } match {\n      case Success(_) => println(s\"Successfully connected to $node\")\n      case Failure(exception) => println(s\"Failed to connect to $node: ${exception.getMessage}\")\n    }\n  }\n}\n\ndef connectToNode(node: String): Unit = {\n  // Simulate the possibility of an exception when connecting to a node\n  if (scala.util.Random.nextBoolean()) {\n    throw new RuntimeException(\"Node unreachable\")\n  }\n  // Otherwise, simulate successful connection\n}\n```"
  },
  {
    "task": "Create a program that simulates virtual environments and manages resource allocation exceptions.",
    "code": "```scala\nobject VirtualEnvironmentSimulator {\n\n  class ResourceAllocationException(message: String) extends Exception(message)\n\n  class VirtualEnvironment {\n    private var resources: Int = 100\n\n    def allocateResources(amount: Int): Unit = {\n      if (amount > resources) {\n        throw new ResourceAllocationException(\"Not enough resources available.\")\n      } else {\n        resources -= amount\n        println(s\"Allocated $amount resources. Remaining: $resources\")\n      }\n    }\n\n    def releaseResources(amount: Int): Unit = {\n      resources += amount\n      println(s\"Released $amount resources. Total available: $resources\")\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val environment = new VirtualEnvironment\n\n    try {\n      environment.allocateResources(50)\n      environment.allocateResources(60) // This should cause an exception\n    } catch {\n      case e: ResourceAllocationException => println(s\"Exception caught: ${e.getMessage}\")\n    } finally {\n      println(\"Resource allocation attempt complete.\")\n    }\n  }\n}\n\nVirtualEnvironmentSimulator.main(Array())\n```"
  },
  {
    "task": "Develop a tool that manages digital rights and handles exceptions for unauthorized content access.",
    "code": "```scala\nobject DigitalRightsManager {\n  class UnauthorizedAccessException(message: String) extends Exception(message)\n\n  def accessContent(userRole: String): Unit = {\n    try {\n      if (userRole != \"admin\") {\n        throw new UnauthorizedAccessException(\"Access Denied: Unauthorized user.\")\n      }\n      println(\"Access Granted: Content is available.\")\n    } catch {\n      case e: UnauthorizedAccessException => println(e.getMessage)\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    accessContent(\"user\")   // This should trigger an exception\n    accessContent(\"admin\")  // This should grant access\n  }\n}\n\nDigitalRightsManager.main(Array())\n```"
  },
  {
    "task": "Design a function that synchronizes clocks and handles exceptions for time drift.",
    "code": "```scala\nimport java.time.{LocalTime, Duration}\n\nobject ClockSynchronizer {\n  def synchronizeClocks(serverTime: LocalTime, localTime: LocalTime): LocalTime = {\n    try {\n      val drift = Duration.between(localTime, serverTime).toMillis\n      if (math.abs(drift) > 1000) {\n        throw new Exception(\"Time drift is too large to correct automatically.\")\n      }\n      serverTime\n    } catch {\n      case e: Exception =>\n        println(s\"Error synchronizing clocks: ${e.getMessage}\")\n        localTime\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val serverTime = LocalTime.now()\n    val localTime = serverTime.minusSeconds(2) // Simulate a drift\n    val synchronizedTime = synchronizeClocks(serverTime, localTime)\n    println(s\"Synchronized Time: $synchronizedTime\")\n  }\n}\n```"
  },
  {
    "task": "Write a script that manages system backups and handles exceptions for insufficient backup space.",
    "code": "```scala\nimport java.io.{File, IOException}\n\nobject BackupManager {\n  def main(args: Array[String]): Unit = {\n    try {\n      val backupPath = \"/path/to/backup\"\n      val backupSpaceRequired = 500 // in MB\n      checkBackupSpace(backupPath, backupSpaceRequired)\n      performBackup(backupPath)\n      println(\"Backup completed successfully.\")\n    } catch {\n      case e: InsufficientSpaceException =>\n        println(s\"Backup failed: ${e.getMessage}\")\n      case e: IOException =>\n        println(s\"An I/O error occurred: ${e.getMessage}\")\n    }\n  }\n\n  def checkBackupSpace(path: String, spaceRequired: Int): Unit = {\n    val availableSpace = getAvailableSpace(path)\n    if (availableSpace < spaceRequired) {\n      throw new InsufficientSpaceException(s\"Not enough space. Required: $spaceRequired MB, Available: $availableSpace MB\")\n    }\n  }\n\n  def getAvailableSpace(path: String): Int = {\n    // Placeholder for actual space checking logic\n    400 // Assume 400 MB is available for illustration\n  }\n\n  def performBackup(path: String): Unit = {\n    // Placeholder for actual backup logic\n    // Simulate potential IOException\n    if (math.random() > 0.5) throw new IOException(\"Simulated I/O error during backup.\")\n  }\n}\n\nclass InsufficientSpaceException(message: String) extends Exception(message)\n```"
  },
  {
    "task": "Create a program that processes natural language text and handles parsing exceptions.",
    "code": "```scala\nimport scala.util.{Try, Success, Failure}\n\nobject TextProcessor {\n  def main(args: Array[String]): Unit = {\n    val text = \"This is a sample text to process\"\n    processText(text) match {\n      case Success(result) => println(s\"Processed text: $result\")\n      case Failure(exception) => println(s\"Error processing text: ${exception.getMessage}\")\n    }\n  }\n\n  def processText(text: String): Try[String] = {\n    Try {\n      if (text.isEmpty) throw new IllegalArgumentException(\"Text cannot be empty\")\n      // Simulate text parsing\n      text.toUpperCase\n    }\n  }\n}\n```"
  },
  {
    "task": "Implement a function that manages thread execution and handles race condition exceptions.",
    "code": "```scala\nimport scala.concurrent.{Future, ExecutionContext}\nimport scala.util.{Failure, Success}\n\nobject ThreadManager {\n  implicit val ec: ExecutionContext = ExecutionContext.global\n\n  def manageThreads(): Unit = {\n    val task1 = Future {\n      // Simulate task work\n      Thread.sleep(100)\n      println(\"Task 1 is executing\")\n    }\n\n    val task2 = Future {\n      // Simulate task work\n      Thread.sleep(100)\n      println(\"Task 2 is executing\")\n    }\n\n    val combined = for {\n      _ <- task1\n      _ <- task2\n    } yield ()\n\n    combined.onComplete {\n      case Success(_) =>\n        println(\"Both tasks completed successfully\")\n      case Failure(exception) =>\n        println(s\"Exception occurred: ${exception.getMessage}\")\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    manageThreads()\n    Thread.sleep(500) // Wait for tasks to complete\n  }\n}\n```"
  },
  {
    "task": "Develop a system that integrates with IoT devices and handles connectivity exceptions.",
    "code": "```scala\nimport scala.util.{Try, Success, Failure}\n\ntrait IoTDevice {\n  def connect(): Unit\n  def disconnect(): Unit\n  def fetchData(): String\n}\n\nclass IoTSystem(devices: List[IoTDevice]) {\n\n  def connectToDevices(): Unit = {\n    devices.foreach { device =>\n      Try(device.connect()) match {\n        case Success(_) => println(\"Connected successfully.\")\n        case Failure(exception) => println(s\"Failed to connect: ${exception.getMessage}\")\n      }\n    }\n  }\n\n  def disconnectFromDevices(): Unit = {\n    devices.foreach { device =>\n      Try(device.disconnect()) match {\n        case Success(_) => println(\"Disconnected successfully.\")\n        case Failure(exception) => println(s\"Failed to disconnect: ${exception.getMessage}\")\n      }\n    }\n  }\n\n  def collectData(): Unit = {\n    devices.foreach { device =>\n      Try(device.fetchData()) match {\n        case Success(data) => println(s\"Data received: $data\")\n        case Failure(exception) => println(s\"Failed to fetch data: ${exception.getMessage}\")\n      }\n    }\n  }\n}\n\n// Example Usage\nobject IoTSystemApp extends App {\n  val device1 = new IoTDevice {\n    def connect(): Unit = println(\"Device 1 connected\")\n    def disconnect(): Unit = println(\"Device 1 disconnected\")\n    def fetchData(): String = \"Device 1 data\"\n  }\n\n  val device2 = new IoTDevice {\n    def connect(): Unit = throw new Exception(\"Device 2 connection error\")\n    def disconnect(): Unit = println(\"Device 2 disconnected\")\n    def fetchData(): String = throw new Exception(\"Device 2 data fetch error\")\n  }\n\n  val system = new IoTSystem(List(device1, device2))\n  system.connectToDevices()\n  system.collectData()\n  system.disconnectFromDevices()\n}\n```"
  },
  {
    "task": "Write a function that manages application logging and handles exceptions for log overflow.",
    "code": "```scala\nimport scala.collection.mutable.ListBuffer\n\nobject Logger {\n  private val maxLogSize = 100\n  private val logs = ListBuffer[String]()\n\n  def log(message: String): Unit = {\n    try {\n      if (logs.size >= maxLogSize) {\n        throw new LogOverflowException(\"Log limit exceeded\")\n      }\n      logs += message\n    } catch {\n      case e: LogOverflowException => println(s\"Exception caught: ${e.getMessage}\")\n    }\n  }\n\n  def getLogs: List[String] = logs.toList\n}\n\nclass LogOverflowException(message: String) extends Exception(message)\n\n// Example usage\nobject Main extends App {\n  (1 to 105).foreach(i => Logger.log(s\"Log entry $i\"))\n  println(Logger.getLogs.mkString(\"\\n\"))\n}\n```"
  },
  {
    "task": "Create a tool that visualizes data and handles exceptions for unsupported visualization types.",
    "code": "```scala\nimport scala.util.{Try, Success, Failure}\n\nobject DataVisualizer {\n  \n  def visualizeData(data: List[Int], visualizationType: String): Unit = {\n    Try {\n      visualizationType.toLowerCase match {\n        case \"bar\" => println(s\"Visualizing data as a bar chart: ${data.mkString(\", \")}\")\n        case \"line\" => println(s\"Visualizing data as a line chart: ${data.mkString(\", \")}\")\n        case _ => throw new UnsupportedOperationException(s\"Unsupported visualization type: $visualizationType\")\n      }\n    } match {\n      case Success(_) => println(\"Data visualized successfully.\")\n      case Failure(ex) => println(s\"Error: ${ex.getMessage}\")\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val data = List(10, 20, 30, 40, 50)\n    visualizeData(data, \"bar\")\n    visualizeData(data, \"pie\") // Unsupported type\n  }\n}\n\nDataVisualizer.main(Array.empty)\n```"
  },
  {
    "task": "Design a program that performs genetic algorithm simulations and manages exception for invalid mutations.",
    "code": "```scala\nobject GeneticAlgorithm {\n\n  case class Individual(genes: String)\n\n  class InvalidMutationException(message: String) extends Exception(message)\n\n  def mutate(individual: Individual): Individual = {\n    if (individual.genes.contains(\"X\")) {\n      throw new InvalidMutationException(\"Invalid mutation: gene contains X\")\n    }\n    // Perform mutation logic here\n    individual\n  }\n\n  def runSimulation(population: List[Individual]): Unit = {\n    population.foreach { individual =>\n      try {\n        val mutatedIndividual = mutate(individual)\n        println(s\"Mutated individual: ${mutatedIndividual.genes}\")\n      } catch {\n        case e: InvalidMutationException =>\n          println(s\"Mutation error: ${e.getMessage}\")\n      }\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val population = List(\n      Individual(\"AAAA\"),\n      Individual(\"AXXA\"),\n      Individual(\"TTTT\")\n    )\n    runSimulation(population)\n  }\n}\n```"
  },
  {
    "task": "Implement a function that manages distributed transactions and handles consistency exceptions.",
    "code": "```scala\nimport scala.util.{Try, Success, Failure}\n\nobject DistributedTransactionManager {\n\n  class ConsistencyException(message: String) extends Exception(message)\n\n  def manageTransaction(transaction: () => Unit): Try[Unit] = {\n    Try(transaction()).recoverWith {\n      case e: ConsistencyException =>\n        println(s\"Consistency exception occurred: ${e.getMessage}\")\n        Failure(e)\n      case e: Exception =>\n        println(s\"An unexpected exception occurred: ${e.getMessage}\")\n        Failure(e)\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    def transaction(): Unit = {\n      // Simulate transaction logic\n      val successful = scala.util.Random.nextBoolean()\n      if (!successful) throw new ConsistencyException(\"Transaction consistency failed\")\n      println(\"Transaction successful\")\n    }\n\n    manageTransaction(transaction) match {\n      case Success(_) => println(\"Transaction completed successfully\")\n      case Failure(_) => println(\"Transaction failed\")\n    }\n  }\n}\n```"
  },
  {
    "task": "Write a function that handles secure communications and manages encryption key exceptions.",
    "code": "```scala\nimport scala.util.{Try, Success, Failure}\n\nobject SecureCommunications {\n\n  def handleSecureCommunication(encrypt: String => String, decrypt: String => String, message: String): String = {\n    try {\n      val encryptedMessage = encrypt(message)\n      decrypt(encryptedMessage)\n    } catch {\n      case e: Exception =>\n        s\"An error occurred: ${e.getMessage}\"\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val encryptFunction: String => String = message => {\n      if (message == \"error\") throw new Exception(\"Encryption key error\")\n      s\"encrypted($message)\"\n    }\n\n    val decryptFunction: String => String = encryptedMessage => {\n      if (encryptedMessage == \"encrypted(error)\") throw new Exception(\"Decryption key error\")\n      encryptedMessage.stripPrefix(\"encrypted(\").stripSuffix(\")\")\n    }\n\n    val message = \"Hello\"\n    val result = handleSecureCommunication(encryptFunction, decryptFunction, message)\n    println(result)\n\n    val errorMessage = \"error\"\n    val errorResult = handleSecureCommunication(encryptFunction, decryptFunction, errorMessage)\n    println(errorResult)\n  }\n}\n```"
  },
  {
    "task": "Create a system that processes sensor data and handles out-of-range value exceptions.",
    "code": "```scala\nobject SensorDataProcessor {\n\n  class OutOfRangeException(message: String) extends Exception(message)\n\n  def processSensorData(data: Double): Unit = {\n    try {\n      if (data < 0.0 || data > 100.0) {\n        throw new OutOfRangeException(s\"Value $data is out of range!\")\n      }\n      println(s\"Processing sensor data: $data\")\n    } catch {\n      case e: OutOfRangeException => println(s\"Error: ${e.getMessage}\")\n      case _: Throwable => println(\"An unexpected error occurred.\")\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val sensorData = List(25.0, 102.5, -5.0, 75.0)\n    sensorData.foreach(processSensorData)\n  }\n}\n```"
  },
  {
    "task": "Develop a program that simulates weather patterns and handles model prediction exceptions.",
    "code": "```scala\nimport scala.util.{Try, Success, Failure}\n\nobject WeatherSimulation {\n  def main(args: Array[String]): Unit = {\n    val prediction = simulateWeather()\n    prediction match {\n      case Success(weather) => println(s\"Weather Prediction: $weather\")\n      case Failure(exception) => println(s\"Failed to predict weather: ${exception.getMessage}\")\n    }\n  }\n\n  def simulateWeather(): Try[String] = {\n    Try {\n      // Simulating a weather prediction model\n      if (math.random() < 0.5) throw new Exception(\"Model error: Unable to predict weather.\")\n      else \"Sunny\"\n    }\n  }\n}\n```"
  },
  {
    "task": "Design a function that manages API versioning and handles backward compatibility exceptions.",
    "code": "```scala\nobject ApiManager {\n\n  class ApiVersionException(message: String) extends Exception(message)\n\n  def manageApiVersion(version: String): Unit = {\n    try {\n      version match {\n        case \"v1\" => println(\"Handling version 1 API\")\n        case \"v2\" => println(\"Handling version 2 API\")\n        case _ => throw new ApiVersionException(s\"Unsupported API version: $version\")\n      }\n    } catch {\n      case e: ApiVersionException => println(s\"Exception: ${e.getMessage}\")\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    manageApiVersion(\"v1\")\n    manageApiVersion(\"v3\")\n  }\n}\n```"
  },
  {
    "task": "Write a tool that converts character encodings and handles unsupported encoding exceptions.",
    "code": "```scala\nimport java.nio.charset.{Charset, UnsupportedCharsetException}\nimport java.nio.file.{Files, Paths}\nimport java.io.{BufferedReader, BufferedWriter, InputStreamReader, OutputStreamWriter}\n\nobject EncodingConverter {\n  def convertEncoding(inputFile: String, outputFile: String, sourceEncoding: String, targetEncoding: String): Unit = {\n    try {\n      val sourceCharset = Charset.forName(sourceEncoding)\n      val targetCharset = Charset.forName(targetEncoding)\n\n      val reader = new BufferedReader(new InputStreamReader(Files.newInputStream(Paths.get(inputFile)), sourceCharset))\n      val writer = new BufferedWriter(new OutputStreamWriter(Files.newOutputStream(Paths.get(outputFile)), targetCharset))\n      \n      try {\n        var line: String = reader.readLine()\n        while (line != null) {\n          writer.write(line)\n          writer.newLine()\n          line = reader.readLine()\n        }\n      } finally {\n        reader.close()\n        writer.close()\n      }\n      \n    } catch {\n      case e: UnsupportedCharsetException =>\n        println(s\"Error: Unsupported character encoding - ${e.getMessage}\")\n      case e: Exception =>\n        println(s\"Error: ${e.getMessage}\")\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    if (args.length != 4) {\n      println(\"Usage: EncodingConverter <inputFile> <outputFile> <sourceEncoding> <targetEncoding>\")\n    } else {\n      convertEncoding(args(0), args(1), args(2), args(3))\n    }\n  }\n}\n```"
  },
  {
    "task": "Create a program that handles dynamic content generation and manages template parsing exceptions.",
    "code": "```scala\nobject TemplateProcessor {\n  def main(args: Array[String]): Unit = {\n    val templates = List(\n      \"Hello, {{name}}!\",\n      \"Your balance is {{balance}}.\",\n      \"Welcome to {{company}}.\"\n    )\n\n    val context = Map(\n      \"name\" -> \"Alice\",\n      \"balance\" -> \"100\",\n      \"company\" -> \"Acme Corp\"\n    )\n\n    templates.foreach(template => {\n      try {\n        val result = parseTemplate(template, context)\n        println(result)\n      } catch {\n        case ex: TemplateParseException =>\n          println(s\"Error processing template: ${ex.getMessage}\")\n      }\n    })\n  }\n\n  def parseTemplate(template: String, context: Map[String, String]): String = {\n    val placeholderPattern = \"\\\\{\\\\{(\\\\w+)\\\\}\\\\}\".r\n    placeholderPattern.replaceAllIn(template, m => {\n      val key = m.group(1)\n      context.getOrElse(key, throw new TemplateParseException(s\"Missing key: $key\"))\n    })\n  }\n\n  class TemplateParseException(message: String) extends Exception(message)\n}\n```"
  },
  {
    "task": "Implement a script that schedules automated tests and handles exceptions for missing test cases.",
    "code": "```scala\nimport scala.util.{Try, Failure, Success}\n\nobject TestScheduler {\n  \n  def scheduleTest(testName: String): Unit = {\n    Try {\n      // Simulating the retrieval of a test case\n      val testCase = getTestCase(testName)\n      println(s\"Scheduling test: $testCase\")\n      runTest(testCase)\n    } match {\n      case Success(_) => println(s\"Test $testName completed successfully.\")\n      case Failure(exception) => println(s\"Failed to schedule test $testName: ${exception.getMessage}\")\n    }\n  }\n\n  def getTestCase(testName: String): String = {\n    // Simulate a situation where certain test cases are missing\n    val availableTests = Map(\n      \"test1\" -> \"Test Case 1\",\n      \"test2\" -> \"Test Case 2\"\n    )\n    availableTests.getOrElse(testName, throw new NoSuchElementException(s\"Test case $testName not found\"))\n  }\n\n  def runTest(testCase: String): Unit = {\n    println(s\"Running: $testCase\")\n    // Simulate test execution\n  }\n\n  def main(args: Array[String]): Unit = {\n    val testsToSchedule = List(\"test1\", \"test3\", \"test2\")\n\n    testsToSchedule.foreach(scheduleTest)\n  }\n}\n```"
  },
  {
    "task": "Develop a system that manages virtual machine instances and handles provisioning exceptions.",
    "code": "```scala\nimport scala.util.{Try, Success, Failure}\n\ncase class VirtualMachine(id: String, status: String)\n\nclass VMProvisionException(message: String) extends Exception(message)\n\nobject VMManager {\n  private var vmInstances: Map[String, VirtualMachine] = Map()\n\n  def provisionVM(id: String): Try[VirtualMachine] = {\n    Try {\n      if (vmInstances.contains(id)) {\n        throw new VMProvisionException(s\"VM with id $id already exists.\")\n      }\n      val vm = VirtualMachine(id, \"Running\")\n      vmInstances += (id -> vm)\n      vm\n    }\n  }\n\n  def deprovisionVM(id: String): Try[VirtualMachine] = {\n    Try {\n      vmInstances.get(id) match {\n        case Some(vm) =>\n          vmInstances -= id\n          vm\n        case None =>\n          throw new VMProvisionException(s\"VM with id $id does not exist.\")\n      }\n    }\n  }\n}\n\nobject Main extends App {\n  val vmId = \"vm1\"\n\n  VMManager.provisionVM(vmId) match {\n    case Success(vm) => println(s\"Provisioned VM: ${vm.id}\")\n    case Failure(e) => println(s\"Failed to provision VM: ${e.getMessage}\")\n  }\n\n  VMManager.deprovisionVM(vmId) match {\n    case Success(vm) => println(s\"Deprovisioned VM: ${vm.id}\")\n    case Failure(e) => println(s\"Failed to deprovision VM: ${e.getMessage}\")\n  }\n}\n```"
  },
  {
    "task": "Write a function that processes credit scores and handles exceptions for missing credit history.",
    "code": "```scala\ndef processCreditScore(creditScores: Map[String, Option[Int]]): Unit = {\n  creditScores.foreach { case (name, scoreOpt) =>\n    try {\n      val score = scoreOpt.getOrElse(throw new NoSuchElementException(\"Missing credit history\"))\n      println(s\"Processing credit score for $name: $score\")\n    } catch {\n      case e: NoSuchElementException =>\n        println(s\"Error processing credit score for $name: ${e.getMessage}\")\n    }\n  }\n}\n\n// Example usage\nval scores = Map(\"Alice\" -> Some(750), \"Bob\" -> None, \"Charlie\" -> Some(680))\nprocessCreditScore(scores)\n```"
  },
  {
    "task": "Create a tool that manages digital certificates and handles expiration exceptions.",
    "code": "```scala\nimport java.time.LocalDate\nimport scala.util.{Try, Success, Failure}\n\ncase class Certificate(name: String, expirationDate: LocalDate)\n\nobject CertificateManager {\n  def checkExpiration(certificate: Certificate): Try[Unit] = {\n    if (certificate.expirationDate.isBefore(LocalDate.now())) {\n      Failure(new Exception(s\"Certificate ${certificate.name} has expired.\"))\n    } else {\n      Success(())\n    }\n  }\n\n  def manageCertificate(certificate: Certificate): Unit = {\n    checkExpiration(certificate) match {\n      case Success(_) => println(s\"Certificate ${certificate.name} is valid.\")\n      case Failure(exception) => println(s\"Error: ${exception.getMessage}\")\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val validCertificate = Certificate(\"ValidCert\", LocalDate.now().plusDays(10))\n    val expiredCertificate = Certificate(\"ExpiredCert\", LocalDate.now().minusDays(1))\n\n    manageCertificate(validCertificate)\n    manageCertificate(expiredCertificate)\n  }\n}\n```"
  },
  {
    "task": "Design a program that processes genome sequences and handles exceptions for sequence alignment.",
    "code": "```scala\nobject GenomeProcessor {\n  def main(args: Array[String]): Unit = {\n    val sequence1 = \"AGTACGCA\"\n    val sequence2 = \"TATGC\"\n    \n    try {\n      val alignment = alignSequences(sequence1, sequence2)\n      println(s\"Aligned Sequences: $alignment\")\n    } catch {\n      case e: IllegalArgumentException =>\n        println(s\"Error during alignment: ${e.getMessage}\")\n    }\n  }\n\n  def alignSequences(seq1: String, seq2: String): String = {\n    if (seq1.isEmpty || seq2.isEmpty) {\n      throw new IllegalArgumentException(\"Sequences must not be empty\")\n    }\n    // Dummy alignment logic for illustration\n    if (seq1.length < seq2.length) {\n      throw new IllegalArgumentException(\"Sequence 1 is shorter than Sequence 2\")\n    }\n    seq1.zipAll(seq2, '-', '-').map {\n      case (c1, c2) => s\"$c1$c2\"\n    }.mkString(\" \")\n  }\n}\n```"
  }
]