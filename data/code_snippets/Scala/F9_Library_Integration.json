[
  {
    "task": "Create a program that reads a CSV file using a library designed for parsing CSV data.",
    "code": "```scala\nimport com.github.tototoshi.csv._\n\nobject CSVReaderApp {\n  def main(args: Array[String]): Unit = {\n    val reader = CSVReader.open(new java.io.File(\"data.csv\"))\n    val allRows = reader.all()\n    reader.close()\n\n    allRows.foreach { row =>\n      println(row.mkString(\", \"))\n    }\n  }\n}\n```"
  },
  {
    "task": "Implement a function that generates a random number using a standard library for random number generation.",
    "code": "```scala\nimport scala.util.Random\n\nobject RandomNumberGenerator {\n  def generateRandomNumber(): Int = {\n    Random.nextInt()\n  }\n\n  def main(args: Array[String]): Unit = {\n    val randomNumber = generateRandomNumber()\n    println(s\"Generated random number: $randomNumber\")\n  }\n}\n```"
  },
  {
    "task": "Use a third-party library to send an HTTP GET request to a public API and print the response.",
    "code": "```scala\nimport sttp.client3._\nimport scala.concurrent.ExecutionContext.Implicits.global\n\nobject HttpClientExample extends App {\n  val backend = HttpURLConnectionBackend()\n  val request = basicRequest.get(uri\"https://api.publicapis.org/entries\")\n  val response = request.send(backend)\n\n  response.onComplete {\n    case scala.util.Success(res) => println(res.body)\n    case scala.util.Failure(exception) => println(s\"An error occurred: $exception\")\n  }\n}\n```"
  },
  {
    "task": "Write a script that extracts the text from a PDF file using a library for PDF manipulation.",
    "code": "```scala\nimport java.io.File\nimport org.apache.pdfbox.pdmodel.PDDocument\nimport org.apache.pdfbox.text.PDFTextStripper\n\nobject PDFTextExtractor {\n  def main(args: Array[String]): Unit = {\n    if (args.length != 1) {\n      println(\"Usage: PDFTextExtractor <pdf-file-path>\")\n      System.exit(1)\n    }\n\n    val pdfFilePath = args(0)\n    val pdfFile = new File(pdfFilePath)\n\n    if (!pdfFile.exists() || !pdfFile.isFile) {\n      println(s\"File not found: $pdfFilePath\")\n      System.exit(1)\n    }\n\n    val document = PDDocument.load(pdfFile)\n    try {\n      val textStripper = new PDFTextStripper()\n      val text = textStripper.getText(document)\n      println(text)\n    } finally {\n      document.close()\n    }\n  }\n}\n```"
  },
  {
    "task": "Develop a tool that resizes images by integrating an image processing library.",
    "code": "```scala\nimport java.io.File\nimport javax.imageio.ImageIO\nimport java.awt.image.BufferedImage\nimport java.awt.Graphics2D\nimport java.awt.RenderingHints\n\nobject ImageResizer {\n  def resizeImage(inputPath: String, outputPath: String, width: Int, height: Int): Unit = {\n    val inputImage: BufferedImage = ImageIO.read(new File(inputPath))\n    val outputImage: BufferedImage = new BufferedImage(width, height, inputImage.getType)\n\n    val graphics2D: Graphics2D = outputImage.createGraphics()\n    graphics2D.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR)\n    graphics2D.drawImage(inputImage, 0, 0, width, height, null)\n    graphics2D.dispose()\n\n    ImageIO.write(outputImage, \"jpg\", new File(outputPath))\n  }\n\n  def main(args: Array[String]): Unit = {\n    if (args.length < 4) {\n      println(\"Usage: ImageResizer <inputPath> <outputPath> <width> <height>\")\n      return\n    }\n    val inputPath = args(0)\n    val outputPath = args(1)\n    val width = args(2).toInt\n    val height = args(3).toInt\n\n    resizeImage(inputPath, outputPath, width, height)\n  }\n}\n```"
  },
  {
    "task": "Create a program that connects to a database using a library for database interaction.",
    "code": "```scala\nimport slick.jdbc.PostgresProfile.api._\n\nimport scala.concurrent.Await\nimport scala.concurrent.duration._\n\nobject DatabaseConnectionApp extends App {\n  // Define the database connection\n  val db = Database.forConfig(\"mydb\")\n\n  try {\n    // Run a simple query to test the connection\n    val action = sql\"SELECT 1\".as[Int]\n    val resultFuture = db.run(action)\n\n    // Await the result\n    val result = Await.result(resultFuture, 2.seconds)\n    println(s\"Query result: $result\")\n  } finally {\n    // Close the database connection\n    db.close()\n  }\n}\n```\n\n```\n// application.conf\nmydb = {\n  url = \"jdbc:postgresql://localhost:5432/mydatabase\"\n  user = \"myuser\"\n  password = \"mypassword\"\n  driver = \"org.postgresql.Driver\"\n  connectionPool = \"HikariCP\"\n}\n```"
  },
  {
    "task": "Build an application that converts Markdown text to HTML using a Markdown parsing library.",
    "code": "```scala\nimport com.vladsch.flexmark.ast._\nimport com.vladsch.flexmark.html.HtmlRenderer\nimport com.vladsch.flexmark.parser.Parser\n\nobject MarkdownToHtmlConverter {\n  def main(args: Array[String]): Unit = {\n    val markdownText = \"\"\"# Sample Markdown\n                         |This is a **bold** text and this is *italic* text.\n                         |Here is a list:\n                         |- Item 1\n                         |- Item 2\"\"\".stripMargin\n\n    val parser: Parser = Parser.builder().build()\n    val document: Node = parser.parse(markdownText)\n    val renderer: HtmlRenderer = HtmlRenderer.builder().build()\n\n    val htmlOutput: String = renderer.render(document)\n    println(htmlOutput)\n  }\n}\n```"
  },
  {
    "task": "Use a library to transform XML data into JSON format for easier manipulation.",
    "code": "```scala\nimport scala.xml.{XML, Elem}\nimport org.json4s._\nimport org.json4s.jackson.JsonMethods._\nimport org.json4s.Xml.toJson\n\nobject XmlToJsonConverter {\n  def main(args: Array[String]): Unit = {\n    val xmlString = \"\"\"<note>\n                        <to>Tove</to>\n                        <from>Jani</from>\n                        <heading>Reminder</heading>\n                        <body>Don't forget me this weekend!</body>\n                      </note>\"\"\"\n\n    val xml: Elem = XML.loadString(xmlString)\n    val json: JValue = toJson(xml)\n\n    println(pretty(render(json)))\n  }\n}\n```"
  },
  {
    "task": "Implement a feature that schedules tasks at regular intervals using a scheduler library.",
    "code": "```scala\nimport java.util.concurrent.Executors\nimport scala.concurrent.duration._\nimport scala.concurrent.ExecutionContext\n\nobject TaskScheduler {\n  implicit val ec: ExecutionContext = ExecutionContext.fromExecutor(Executors.newFixedThreadPool(1))\n\n  def scheduleTask(interval: FiniteDuration)(task: => Unit): Unit = {\n    val scheduler = Executors.newScheduledThreadPool(1)\n    val runnable = new Runnable {\n      def run(): Unit = task\n    }\n    scheduler.scheduleAtFixedRate(runnable, 0, interval.toMillis, MILLISECONDS)\n  }\n  \n  def main(args: Array[String]): Unit = {\n    scheduleTask(1.second) {\n      println(\"Task executed at: \" + java.time.LocalTime.now)\n    }\n  }\n}\n```"
  },
  {
    "task": "Develop a chat application that utilizes a library for WebSocket communication.",
    "code": "```scala\nimport akka.actor.ActorSystem\nimport akka.http.scaladsl.Http\nimport akka.http.scaladsl.model.ws.{Message, TextMessage}\nimport akka.http.scaladsl.server.Directives._\nimport akka.stream.ActorMaterializer\nimport akka.stream.scaladsl.{Flow, Sink, Source}\nimport akka.http.scaladsl.server.Route\n\nobject ChatApp extends App {\n  implicit val system: ActorSystem = ActorSystem()\n  implicit val materializer: ActorMaterializer = ActorMaterializer()\n  import system.dispatcher\n\n  def chatFlow: Flow[Message, Message, Any] = Flow[Message].collect {\n    case TextMessage.Strict(txt) => TextMessage(s\"Echo: $txt\")\n  }\n\n  val route: Route = path(\"chat\") {\n    handleWebSocketMessages(chatFlow)\n  }\n\n  val bindingFuture = Http().bindAndHandle(route, \"localhost\", 8080)\n  println(\"Server is running at ws://localhost:8080/chat\")\n}\n```"
  },
  {
    "task": "Create a game that uses a library to handle physics simulations for realistic movements.",
    "code": "```scala\nimport com.badlogic.gdx.ApplicationAdapter\nimport com.badlogic.gdx.Gdx\nimport com.badlogic.gdx.graphics.GL20\nimport com.badlogic.gdx.graphics.OrthographicCamera\nimport com.badlogic.gdx.physics.box2d._\n\nobject PhysicsGame extends ApplicationAdapter {\n  private var world: World = _\n  private var camera: OrthographicCamera = _\n  private var box: Body = _\n\n  override def create(): Unit = {\n    camera = new OrthographicCamera(Gdx.graphics.getWidth, Gdx.graphics.getHeight)\n    world = new World(new Vector2(0, -9.8f), true)\n\n    val bodyDef = new BodyDef()\n    bodyDef.`type` = BodyDef.BodyType.DynamicBody\n    bodyDef.position.set(0, 0)\n\n    box = world.createBody(bodyDef)\n\n    val boxShape = new PolygonShape()\n    boxShape.setAsBox(1, 1)\n\n    val fixtureDef = new FixtureDef()\n    fixtureDef.shape = boxShape\n    fixtureDef.density = 1.0f\n    fixtureDef.friction = 0.3f\n\n    box.createFixture(fixtureDef)\n    boxShape.dispose()\n  }\n\n  override def render(): Unit = {\n    Gdx.gl.glClearColor(0, 0, 0, 1)\n    Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT)\n    world.step(1/60f, 6, 2)\n\n    camera.update()\n\n    // Rendering logic here (e.g. using ShapeRenderer)\n    // For simplicity, not implemented in this example\n  }\n\n  override def dispose(): Unit = {\n    world.dispose()\n  }\n}\n\nimport com.badlogic.gdx.backends.lwjgl3.Lwjgl3Application\nimport com.badlogic.gdx.backends.lwjgl3.Lwjgl3ApplicationConfiguration\n\nobject PhysicsGameLauncher {\n  def main(args: Array[String]): Unit = {\n    val config = new Lwjgl3ApplicationConfiguration()\n    config.setTitle(\"Physics Game\")\n    config.setWindowedMode(800, 600)\n    new Lwjgl3Application(PhysicsGame, config)\n  }\n}\n```"
  },
  {
    "task": "Write a function that hashes a string using a cryptographic hashing library.",
    "code": "```scala\nimport java.security.MessageDigest\n\nobject Hasher {\n  def hashString(input: String): String = {\n    val digest = MessageDigest.getInstance(\"SHA-256\")\n    val hashBytes = digest.digest(input.getBytes(\"UTF-8\"))\n    hashBytes.map(\"%02x\".format(_)).mkString\n  }\n}\n```"
  },
  {
    "task": "Build a program that validates email addresses using a library for regular expression matching.",
    "code": "```scala\nimport scala.util.matching.Regex\n\nobject EmailValidator {\n  def isValidEmail(email: String): Boolean = {\n    val emailRegex: Regex = \"^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+$\".r\n    emailRegex.matches(email)\n  }\n\n  def main(args: Array[String]): Unit = {\n    val emails = List(\"test@example.com\", \"invalid-email@\", \"another.test@domain.co\")\n\n    emails.foreach { email =>\n      println(s\"$email is valid: ${isValidEmail(email)}\")\n    }\n  }\n}\n```"
  },
  {
    "task": "Implement a feature that reads and writes Excel files using a library tailored for Excel file manipulation.",
    "code": "```scala\nimport org.apache.poi.ss.usermodel.{WorkbookFactory, Workbook}\nimport org.apache.poi.xssf.usermodel.XSSFWorkbook\nimport java.io.{FileInputStream, FileOutputStream}\n\nobject ExcelHandler {\n  def readExcel(filePath: String): Unit = {\n    val inputStream = new FileInputStream(filePath)\n    val workbook = WorkbookFactory.create(inputStream)\n    val sheet = workbook.getSheetAt(0)\n\n    for (row <- sheet.rowIterator().asScala) {\n      for (cell <- row.cellIterator().asScala) {\n        print(cell.toString + \"\\t\")\n      }\n      println()\n    }\n    workbook.close()\n    inputStream.close()\n  }\n\n  def writeExcel(filePath: String, data: Seq[Seq[String]]): Unit = {\n    val workbook: Workbook = new XSSFWorkbook()\n    val sheet = workbook.createSheet(\"Sheet1\")\n\n    for ((rowData, rowIndex) <- data.zipWithIndex) {\n      val row = sheet.createRow(rowIndex)\n      for ((cellData, cellIndex) <- rowData.zipWithIndex) {\n        val cell = row.createCell(cellIndex)\n        cell.setCellValue(cellData)\n      }\n    }\n\n    val outputStream = new FileOutputStream(filePath)\n    workbook.write(outputStream)\n    workbook.close()\n    outputStream.close()\n  }\n\n  def main(args: Array[String]): Unit = {\n    val readPath = \"input.xlsx\"\n    val writePath = \"output.xlsx\"\n    readExcel(readPath)\n    val data = Seq(\n      Seq(\"Name\", \"Age\", \"City\"),\n      Seq(\"Alice\", \"30\", \"New York\"),\n      Seq(\"Bob\", \"25\", \"Los Angeles\")\n    )\n    writeExcel(writePath, data)\n  }\n}\n```"
  },
  {
    "task": "Use a library to translate text from one language to another in your application.",
    "code": "```scala\nimport com.google.cloud.translate.{Translate, TranslateOptions, Translation}\n\nobject TranslatorApp extends App {\n  // Initialize the Google Translate API client\n  val translate: Translate = TranslateOptions.getDefaultInstance.getService\n\n  // Function to translate text\n  def translateText(text: String, targetLanguage: String): String = {\n    val translation: Translation = translate.translate(\n      text,\n      Translate.TranslateOption.targetLanguage(targetLanguage)\n    )\n    translation.getTranslatedText\n  }\n\n  // Example usage\n  val originalText = \"Hello, world!\"\n  val translatedText = translateText(originalText, \"es\") // Translate to Spanish\n  println(s\"Original: $originalText\")\n  println(s\"Translated: $translatedText\")\n}\n```"
  },
  {
    "task": "Create a script that generates QR codes using a library for QR code creation.",
    "code": "```scala\nimport com.google.zxing.qrcode.QRCodeWriter\nimport com.google.zxing.BarcodeFormat\nimport com.google.zxing.client.j2se.MatrixToImageWriter\nimport java.nio.file.{Files, Paths}\nimport java.nio.file.StandardOpenOption\n\nobject QRCodeGenerator {\n  def main(args: Array[String]): Unit = {\n    val qrCodeText = \"https://example.com\"\n    val filePath = \"qrcode.png\"\n    generateQRCode(qrCodeText, filePath)\n  }\n\n  def generateQRCode(text: String, filePath: String): Unit = {\n    val qrCodeWriter = new QRCodeWriter()\n    val bitMatrix = qrCodeWriter.encode(text, BarcodeFormat.QR_CODE, 350, 350)\n    val path = Paths.get(filePath)\n    Files.write(path, new Array[Byte](0), StandardOpenOption.CREATE)\n    MatrixToImageWriter.writeToPath(bitMatrix, \"PNG\", path)\n  }\n}\n```"
  },
  {
    "task": "Build an app that plays audio files using a library for audio processing.",
    "code": "```scala\nimport javax.sound.sampled.{AudioSystem, Clip, AudioInputStream}\nimport java.io.File\n\nobject AudioPlayerApp {\n  def main(args: Array[String]): Unit = {\n    if (args.isEmpty) {\n      println(\"Please provide the path to an audio file.\")\n    } else {\n      val audioFilePath = args(0)\n      playAudio(audioFilePath)\n    }\n  }\n\n  def playAudio(filePath: String): Unit = {\n    try {\n      val file = new File(filePath)\n      val audioStream: AudioInputStream = AudioSystem.getAudioInputStream(file)\n      val clip: Clip = AudioSystem.getClip\n      clip.open(audioStream)\n      clip.start()\n      println(s\"Playing audio: $filePath\")\n      Thread.sleep(clip.getMicrosecondLength / 1000)\n    } catch {\n      case e: Exception => println(s\"An error occurred: ${e.getMessage}\")\n    }\n  }\n}\n```"
  },
  {
    "task": "Develop a tool that scrapes web pages for specific data using a web scraping library.",
    "code": "```scala\nimport net.ruippeixotog.scalascraper.browser.Browser\nimport net.ruippeixotog.scalascraper.browser.JsoupBrowser\nimport net.ruippeixotog.scalascraper.dsl.DSL._\nimport net.ruippeixotog.scalascraper.model._\n\nobject WebScraper {\n  def main(args: Array[String]): Unit = {\n    // Initialize a browser instance\n    val browser: Browser = JsoupBrowser()\n\n    // URL to scrape\n    val url = \"http://example.com\"\n\n    // Fetch the document\n    val doc: Document = browser.get(url)\n\n    // Extract specific data using CSS selectors\n    val data: List[Element] = doc >> elementList(\".specific-class\")\n\n    // Print or process the extracted data\n    data.foreach(el => println(el.text))\n  }\n}\n```"
  },
  {
    "task": "Implement a service that sends emails using a library that facilitates SMTP communication.",
    "code": "```scala\nimport courier._, Defaults._\n\nobject EmailService {\n  val mailer = Mailer(\"smtp.example.com\", 587)\n    .auth(true)\n    .as(\"username\", \"password\")\n    .startTls(true)()\n\n  def sendEmail(to: String, subject: String, body: String): Unit = {\n    val future = mailer(\n      Envelope.from(\"sender@example.com\".addr)\n        .to(to.addr)\n        .subject(subject)\n        .content(Text(body))\n    )\n    future.onComplete {\n      case scala.util.Success(_) => println(\"Email sent successfully\")\n      case scala.util.Failure(exception) => println(s\"Failed to send email: $exception\")\n    }\n  }\n}\n```"
  },
  {
    "task": "Create a program that visualizes data in charts using a charting library.",
    "code": "```scala\nimport scalafx.application.JFXApp\nimport scalafx.scene.Scene\nimport scalafx.scene.chart.{CategoryAxis, NumberAxis, BarChart, XYChart}\n\nobject DataVisualizationApp extends JFXApp {\n  stage = new JFXApp.PrimaryStage {\n    title = \"Data Visualization\"\n    scene = new Scene {\n      val xAxis = new CategoryAxis()\n      val yAxis = new NumberAxis()\n      val dataChart = new BarChart[String, Number](xAxis, yAxis)\n\n      xAxis.label = \"Category\"\n      yAxis.label = \"Value\"\n\n      val series = new XYChart.Series[String, Number] {\n        name = \"Example Data\"\n        data() ++= Seq(\n          XYChart.Data(\"A\", 23),\n          XYChart.Data(\"B\", 14),\n          XYChart.Data(\"C\", 15),\n          XYChart.Data(\"D\", 24),\n          XYChart.Data(\"E\", 34)\n        )\n      }\n\n      dataChart.getData.add(series)\n\n      root = dataChart\n    }\n  }\n}\n```"
  },
  {
    "task": "Write a script that compresses files into a zip archive using a standard library.",
    "code": "```scala\nimport java.io.{File, FileInputStream, FileOutputStream}\nimport java.util.zip.{ZipEntry, ZipOutputStream}\n\nobject ZipCompressor {\n  def compressFilesToZip(files: List[File], zipFileName: String): Unit = {\n    val zipOutputStream = new ZipOutputStream(new FileOutputStream(zipFileName))\n    try {\n      files.foreach { file =>\n        val fileInputStream = new FileInputStream(file)\n        val zipEntry = new ZipEntry(file.getName)\n        zipOutputStream.putNextEntry(zipEntry)\n        val buffer = new Array[Byte](1024)\n        Iterator.continually(fileInputStream.read(buffer))\n          .takeWhile(_ != -1)\n          .foreach(zipOutputStream.write(buffer, 0, _))\n        fileInputStream.close()\n        zipOutputStream.closeEntry()\n      }\n    } finally {\n      zipOutputStream.close()\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val filesToCompress = List(new File(\"file1.txt\"), new File(\"file2.txt\"))\n    compressFilesToZip(filesToCompress, \"archive.zip\")\n  }\n}\n```"
  },
  {
    "task": "Use a library to parse command-line arguments in your application.",
    "code": "```scala\nimport scopt.OParser\n\ncase class Config(foo: String = \"\", bar: Int = 0, xyz: Boolean = false)\n\nobject CommandLineApp {\n  def main(args: Array[String]): Unit = {\n    val builder = OParser.builder[Config]\n    val parser = {\n      import builder._\n      OParser.sequence(\n        programName(\"CommandLineApp\"),\n        head(\"CommandLineApp\", \"1.0\"),\n        opt[String]('f', \"foo\")\n          .action((x, c) => c.copy(foo = x))\n          .text(\"foo is a required string property\"),\n        opt[Int]('b', \"bar\")\n          .action((x, c) => c.copy(bar = x))\n          .text(\"bar is an optional integer property\"),\n        opt[Unit]('x', \"xyz\")\n          .action((_, c) => c.copy(xyz = true))\n          .text(\"xyz is a flag\")\n      )\n    }\n\n    OParser.parse(parser, args, Config()) match {\n      case Some(config) =>\n        println(s\"Parsed config: $config\")\n      case _ =>\n        println(\"Failed to parse command-line arguments\")\n    }\n  }\n}\n```"
  },
  {
    "task": "Build a weather application that displays data from a weather API using a library for JSON parsing.",
    "code": "```scala\nimport sttp.client3._\nimport sttp.client3.circe._\nimport io.circe.generic.auto._\n\nobject WeatherApp extends App {\n  // Define case classes to match the JSON structure of the weather API response\n  case class Weather(description: String)\n  case class WeatherData(main: String, weather: List[Weather])\n  \n  // Set up the HTTP client\n  val backend = HttpURLConnectionBackend()\n  val apiKey = \"your_api_key\" // Replace with your actual API key\n  val city = \"London\" // Replace with your desired city\n  val request = basicRequest\n    .get(uri\"https://api.openweathermap.org/data/2.5/weather?q=$city&appid=$apiKey\")\n    .response(asJson[WeatherData])\n  \n  // Make the request and handle the response\n  val response = request.send(backend)\n  response.body match {\n    case Right(weatherData) =>\n      println(s\"Weather in $city: ${weatherData.weather.map(_.description).mkString(\", \")}\")\n    case Left(error) =>\n      println(s\"Failed to fetch weather data: $error\")\n  }\n}\n```"
  },
  {
    "task": "Create a video player application using a library that handles video playback.",
    "code": "```scala\nimport javafx.application.Application\nimport javafx.scene.Scene\nimport javafx.scene.layout.StackPane\nimport javafx.stage.Stage\nimport javafx.scene.media.Media\nimport javafx.scene.media.MediaPlayer\nimport javafx.scene.media.MediaView\n\nobject VideoPlayerApp {\n  def main(args: Array[String]): Unit = {\n    Application.launch(classOf[VideoPlayerApp], args: _*)\n  }\n}\n\nclass VideoPlayerApp extends Application {\n  override def start(primaryStage: Stage): Unit = {\n    val videoPath = \"file:///path/to/your/video.mp4\"\n    val media = new Media(videoPath)\n    val mediaPlayer = new MediaPlayer(media)\n    val mediaView = new MediaView(mediaPlayer)\n\n    val root = new StackPane()\n    root.getChildren.add(mediaView)\n\n    val scene = new Scene(root, 800, 600)\n    primaryStage.setScene(scene)\n    primaryStage.setTitle(\"Video Player\")\n    primaryStage.show()\n\n    mediaPlayer.play()\n  }\n}\n```"
  },
  {
    "task": "Develop a system that logs application events using a logging library for better traceability.",
    "code": "```scala\nimport org.slf4j.LoggerFactory\n\nobject EventLogger {\n  private val logger = LoggerFactory.getLogger(this.getClass)\n\n  def logEvent(event: String): Unit = {\n    logger.info(event)\n  }\n\n  def main(args: Array[String]): Unit = {\n    logEvent(\"Application started.\")\n    logEvent(\"User logged in.\")\n    logEvent(\"Data processing completed.\")\n    logEvent(\"Application ended.\")\n  }\n}\n```"
  },
  {
    "task": "Implement a feature that encrypts and decrypts data using a library for encryption.",
    "code": "```scala\nimport javax.crypto.Cipher\nimport javax.crypto.KeyGenerator\nimport javax.crypto.SecretKey\nimport javax.crypto.spec.SecretKeySpec\nimport java.util.Base64\n\nobject EncryptionUtil {\n  private val algorithm = \"AES\"\n  \n  def generateKey(): SecretKey = {\n    val keyGen = KeyGenerator.getInstance(algorithm)\n    keyGen.init(128)\n    keyGen.generateKey()\n  }\n\n  def encrypt(data: String, secretKey: SecretKey): String = {\n    val cipher = Cipher.getInstance(algorithm)\n    cipher.init(Cipher.ENCRYPT_MODE, secretKey)\n    val encryptedBytes = cipher.doFinal(data.getBytes(\"UTF-8\"))\n    Base64.getEncoder.encodeToString(encryptedBytes)\n  }\n\n  def decrypt(encryptedData: String, secretKey: SecretKey): String = {\n    val cipher = Cipher.getInstance(algorithm)\n    cipher.init(Cipher.DECRYPT_MODE, secretKey)\n    val decodedBytes = Base64.getDecoder.decode(encryptedData)\n    new String(cipher.doFinal(decodedBytes), \"UTF-8\")\n  }\n}\n\nobject Main extends App {\n  val secretKey = EncryptionUtil.generateKey()\n  val originalData = \"Sensitive Data\"\n\n  val encryptedData = EncryptionUtil.encrypt(originalData, secretKey)\n  println(s\"Encrypted: $encryptedData\")\n\n  val decryptedData = EncryptionUtil.decrypt(encryptedData, secretKey)\n  println(s\"Decrypted: $decryptedData\")\n}\n```"
  },
  {
    "task": "Write a program that fetches and displays cryptocurrency prices using a third-party library for API interaction.",
    "code": "```scala\nimport sttp.client3._\nimport io.circe.generic.auto._\nimport io.circe.parser._\n\ncase class CryptoPrice(symbol: String, price_usd: String)\n\nobject CryptoPriceFetcher {\n\n  def main(args: Array[String]): Unit = {\n    val request = basicRequest.get(uri\"https://api.coingecko.com/api/v3/simple/price?ids=bitcoin,ethereum&vs_currencies=usd\")\n    val backend = HttpURLConnectionBackend()\n    val response = request.send(backend)\n\n    response.body match {\n      case Right(json) =>\n        val decoded = decode[Map[String, Map[String, String]]](json)\n        decoded match {\n          case Right(data) =>\n            data.foreach { case (crypto, prices) =>\n              println(s\"$crypto: ${prices(\"usd\")} USD\")\n            }\n          case Left(error) =>\n            println(s\"Failed to decode JSON: $error\")\n        }\n      case Left(error) =>\n        println(s\"API request failed: $error\")\n    }\n  }\n}\n```"
  },
  {
    "task": "Use a library to implement OAuth authentication for secure user login in your application.",
    "code": "```scala\nimport com.github.scribejava.core.builder.ServiceBuilder\nimport com.github.scribejava.core.oauth.OAuth20Service\nimport com.github.scribejava.apis.GoogleApi20\nimport java.util.Scanner\nimport scala.concurrent.ExecutionContext.Implicits.global\nimport scala.concurrent.Future\n\nobject OAuthExample {\n  private val clientId = \"your-client-id\"\n  private val clientSecret = \"your-client-secret\"\n  private val redirectUri = \"http://localhost/callback\"\n  private val scopes = \"openid profile email\"\n\n  def main(args: Array[String]): Unit = {\n    val service: OAuth20Service = new ServiceBuilder(clientId)\n      .apiSecret(clientSecret)\n      .defaultScope(scopes)\n      .callback(redirectUri)\n      .build(GoogleApi20.instance())\n\n    val authUrl = service.getAuthorizationUrl\n    println(s\"Please go to this URL and authorize: $authUrl\")\n\n    println(\"Enter the authorization code:\")\n    val scanner = new Scanner(System.in)\n    val code = scanner.nextLine()\n\n    val accessTokenFuture: Future[Unit] = Future {\n      val accessToken = service.getAccessToken(code)\n      println(s\"Access Token: ${accessToken.getAccessToken}\")\n    }\n\n    accessTokenFuture.onComplete {\n      case scala.util.Success(_) => println(\"Successfully authenticated\")\n      case scala.util.Failure(exception) => println(s\"Authentication failed: ${exception.getMessage}\")\n    }\n\n    // Keep the application running to wait for the callback\n    Thread.sleep(10000)\n  }\n}\n```"
  },
  {
    "task": "Build a calculator that evaluates mathematical expressions using a math parsing library.",
    "code": "```scala\nimport de.congrace.exp4j.Calculable\nimport de.congrace.exp4j.ExpressionBuilder\n\nobject Calculator {\n  def evaluate(expression: String): Double = {\n    val calculable: Calculable = new ExpressionBuilder(expression).build()\n    calculable.calculate()\n  }\n\n  def main(args: Array[String]): Unit = {\n    val expression = \"3 + 4 * 2 / (1 - 5) ^ 2 ^ 3\"\n    println(s\"Expression: $expression = ${evaluate(expression)}\")\n  }\n}\n```"
  },
  {
    "task": "Create a chatbot that integrates a natural language processing library for understanding user input.",
    "code": "```scala\nimport com.typesafe.config.ConfigFactory\nimport scala.io.StdIn.readLine\nimport opennlp.tools.sentdetect.{SentenceDetectorME, SentenceModel}\nimport opennlp.tools.tokenize.{TokenizerME, TokenizerModel}\nimport java.io.FileInputStream\n\nobject ChatbotApp {\n  def main(args: Array[String]): Unit = {\n    val sentenceModelIn = new FileInputStream(\"en-sent.bin\")\n    val sentenceModel = new SentenceModel(sentenceModelIn)\n    val sentenceDetector = new SentenceDetectorME(sentenceModel)\n\n    val tokenizerModelIn = new FileInputStream(\"en-token.bin\")\n    val tokenizerModel = new TokenizerModel(tokenizerModelIn)\n    val tokenizer = new TokenizerME(tokenizerModel)\n\n    println(\"Hello! I'm your friendly chatbot. How can I assist you today?\")\n    \n    while (true) {\n      val userInput = readLine(\"You: \")\n      if (userInput.toLowerCase == \"exit\") {\n        println(\"Goodbye!\")\n        System.exit(0)\n      }\n\n      val sentences = sentenceDetector.sentDetect(userInput)\n      sentences.foreach { sentence =>\n        val tokens = tokenizer.tokenize(sentence)\n        println(s\"Chatbot: I detected ${tokens.length} tokens in your sentence.\")\n      }\n    }\n  }\n}\n```"
  },
  {
    "task": "Develop a tool that detects faces in images using a computer vision library.",
    "code": "```scala\nimport org.bytedeco.javacv.CanvasFrame\nimport org.bytedeco.javacv.OpenCVFrameConverter\nimport org.bytedeco.javacv.OpenCVFrameGrabber\nimport org.bytedeco.opencv.global.opencv_core\nimport org.bytedeco.opencv.global.opencv_imgcodecs\nimport org.bytedeco.opencv.global.opencv_imgproc\nimport org.bytedeco.opencv.global.opencv_objdetect\nimport org.bytedeco.opencv.opencv_core.Mat\nimport org.bytedeco.opencv.opencv_core.RectVector\nimport org.bytedeco.opencv.opencv_objdetect.CascadeClassifier\n\nobject FaceDetectionTool {\n  def main(args: Array[String]): Unit = {\n    if (args.length != 1) {\n      println(\"Usage: FaceDetectionTool <image-path>\")\n      return\n    }\n\n    val imagePath = args(0)\n    val image = opencv_imgcodecs.imread(imagePath)\n\n    if (image.empty()) {\n      println(\"Could not open or find the image\")\n      return\n    }\n\n    val faceCascade = new CascadeClassifier()\n    faceCascade.load(\"haarcascade_frontalface_alt.xml\")\n\n    val grayImage = new Mat()\n    opencv_imgproc.cvtColor(image, grayImage, opencv_imgproc.COLOR_BGR2GRAY)\n\n    val faces = new RectVector()\n    faceCascade.detectMultiScale(grayImage, faces)\n\n    for (i <- 0 until faces.size().toInt) {\n      val face = faces.get(i)\n      opencv_imgproc.rectangle(image, face, opencv_core.Scalar.RED)\n    }\n\n    val frame = new CanvasFrame(\"Face Detection\")\n    frame.setDefaultCloseOperation(javax.swing.JFrame.EXIT_ON_CLOSE)\n    frame.showImage(new OpenCVFrameConverter.ToMat().convert(image))\n\n    while (frame.isVisible) {\n      Thread.sleep(30)\n    }\n\n    frame.dispose()\n  }\n}\n```"
  },
  {
    "task": "Implement a program that converts date and time across different time zones using a library for date manipulation.",
    "code": "```scala\nimport java.time.{ZonedDateTime, ZoneId}\nimport java.time.format.DateTimeFormatter\n\nobject TimeZoneConverter {\n  def main(args: Array[String]): Unit = {\n    val dateTimeFormat = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss z\")\n    \n    // Example date and time in a specific time zone\n    val dateTime = ZonedDateTime.now(ZoneId.of(\"America/New_York\"))\n\n    // Convert to another time zone\n    val convertedDateTime = dateTime.withZoneSameInstant(ZoneId.of(\"Europe/London\"))\n\n    println(s\"Original DateTime in New York: ${dateTime.format(dateTimeFormat)}\")\n    println(s\"Converted DateTime in London: ${convertedDateTime.format(dateTimeFormat)}\")\n  }\n}\n```"
  },
  {
    "task": "Write a utility that uploads files to a cloud storage service using a library that interfaces with the service's API.",
    "code": "```scala\nimport com.amazonaws.auth.DefaultAWSCredentialsProviderChain\nimport com.amazonaws.services.s3.AmazonS3\nimport com.amazonaws.services.s3.AmazonS3ClientBuilder\nimport java.io.File\n\nobject CloudStorageUploader {\n  def uploadFile(bucketName: String, filePath: String, keyName: String): Unit = {\n    val s3Client: AmazonS3 = AmazonS3ClientBuilder.standard()\n      .withCredentials(new DefaultAWSCredentialsProviderChain())\n      .build()\n\n    val file = new File(filePath)\n    s3Client.putObject(bucketName, keyName, file)\n  }\n\n  def main(args: Array[String]): Unit = {\n    val bucketName = \"your-bucket-name\"\n    val filePath = \"path/to/your/file.txt\"\n    val keyName = \"your/upload/key\"\n\n    uploadFile(bucketName, filePath, keyName)\n  }\n}\n```"
  },
  {
    "task": "Create a real-time chat system using a library that supports asynchronous communication.",
    "code": "```scala\nimport akka.actor.{Actor, ActorRef, ActorSystem, Props}\nimport akka.stream._\nimport akka.stream.scaladsl._\nimport akka.http.scaladsl.Http\nimport akka.http.scaladsl.model.ws.{Message, TextMessage, WebSocketRequest}\nimport akka.NotUsed\nimport scala.concurrent.duration._\nimport scala.concurrent.Future\nimport scala.io.StdIn\n\nobject ChatClient {\n  def main(args: Array[String]): Unit = {\n    implicit val system = ActorSystem(\"chat-system\")\n    implicit val materializer = ActorMaterializer()\n    import system.dispatcher\n\n    val chatServerUrl = \"ws://localhost:8080/chat\"\n\n    val messageSource: Source[Message, NotUsed] = Source.tick(1.second, 3.seconds, \"Hello!\").map(TextMessage(_))\n\n    val messageSink: Sink[Message, Future[Done]] = Sink.foreach {\n      case message: TextMessage.Strict =>\n        println(s\"Received message: ${message.text}\")\n      case _ => // ignore other message types\n    }\n\n    val flow: Flow[Message, Message, Future[WebSocketUpgradeResponse]] =\n      Http().webSocketClientFlow(WebSocketRequest(chatServerUrl))\n\n    val (upgradeResponse, closed) =\n      messageSource\n        .viaMat(flow)(Keep.right)\n        .toMat(messageSink)(Keep.both)\n        .run()\n\n    upgradeResponse.flatMap { upgrade =>\n      if (upgrade.response.status == StatusCodes.SwitchingProtocols) {\n        println(\"Connected to chat server\")\n        Future.successful(Done)\n      } else {\n        throw new RuntimeException(s\"Connection failed: ${upgrade.response.status}\")\n      }\n    }\n\n    closed.foreach(_ => println(\"Connection closed\"))\n\n    StdIn.readLine(\"Press ENTER to exit...\\n\")\n    system.terminate()\n  }\n}\n```"
  },
  {
    "task": "Use a library to generate and manipulate UUIDs for unique identification in your application.",
    "code": "```scala\nimport java.util.UUID\n\nobject UUIDExample {\n  def main(args: Array[String]): Unit = {\n    // Generate a new UUID\n    val newUUID: UUID = UUID.randomUUID()\n    println(s\"Generated UUID: $newUUID\")\n\n    // Manipulate UUID: Convert to String and back to UUID\n    val uuidString: String = newUUID.toString\n    val sameUUID: UUID = UUID.fromString(uuidString)\n    println(s\"UUID from String: $sameUUID\")\n\n    // Compare UUIDs\n    if (newUUID == sameUUID) {\n      println(\"The UUIDs are the same.\")\n    } else {\n      println(\"The UUIDs are different.\")\n    }\n  }\n}\n```"
  },
  {
    "task": "Build a desktop application that uses a library for creating graphical user interfaces.",
    "code": "```scala\nimport scala.swing._\n\nobject SimpleApp extends SimpleSwingApplication {\n  def top = new MainFrame {\n    title = \"Simple GUI\"\n    contents = new Button {\n      text = \"Click Me\"\n    }\n  }\n}\n```"
  },
  {
    "task": "Develop an algorithm that finds the shortest path in a graph using a library that provides graph algorithms.",
    "code": "```scala\nimport scalax.collection.Graph\nimport scalax.collection.GraphEdge._\nimport scalax.collection.GraphPredef._\nimport scalax.collection.edge.LDiEdge\nimport scalax.collection.edge.Implicits._\nimport scalax.collection.io.dot._\nimport scalax.collection.io.dot.implicits._\nimport scalax.collection.mutable.Graph\nimport scalax.collection.generic.Edge\n\nobject ShortestPathExample {\n  def main(args: Array[String]): Unit = {\n    val graph = Graph(\n      1 ~> 2 % 4,\n      1 ~> 3 % 2,\n      2 ~> 3 % 5,\n      2 ~> 4 % 10,\n      3 ~> 4 % 3\n    )\n\n    val shortestPath = graph.get(1).shortestPathTo(graph.get(4))\n    shortestPath match {\n      case Some(path) => println(s\"Shortest path: ${path.edges.mkString(\" -> \")}\")\n      case None => println(\"No path found\")\n    }\n  }\n}\n```"
  },
  {
    "task": "Create a digital clock application that uses a library for handling time events.",
    "code": "```scala\nimport scalafx.application.JFXApp\nimport scalafx.application.Platform\nimport scalafx.scene.Scene\nimport scalafx.scene.control.Label\nimport scalafx.scene.layout.StackPane\nimport scalafx.util.Duration\nimport scalafx.animation.{AnimationTimer, Timeline}\nimport java.time.LocalTime\nimport java.time.format.DateTimeFormatter\n\nobject DigitalClockApp extends JFXApp {\n  stage = new JFXApp.PrimaryStage {\n    title = \"Digital Clock\"\n    scene = new Scene {\n      root = new StackPane {\n        val timeLabel = new Label {\n          style = \"-fx-font-size: 48pt\"\n        }\n        children = timeLabel\n\n        val formatter = DateTimeFormatter.ofPattern(\"HH:mm:ss\")\n        val timeline = new Timeline {\n          cycleCount = Timeline.Indefinite\n          keyFrames = Seq(\n            at(Duration(1)) {\n              onFinished = _ => Platform.runLater {\n                timeLabel.text = LocalTime.now.format(formatter)\n              }\n            }\n          )\n        }\n\n        timeline.play()\n      }\n    }\n  }\n}\n```"
  },
  {
    "task": "Write a program that uses a library to convert between different units of measurement.",
    "code": "```scala\nimport squants.market._\nimport squants.space._\nimport squants.time._\n\nobject UnitConverterApp extends App {\n  // Example conversion: Length\n  val meters: Length = Meters(10)\n  val feet: Length = meters.toFeet\n  println(s\"${meters} is equal to ${feet}\")\n\n  // Example conversion: Currency\n  val usd: Money = USD(100)\n  val eur: Money = usd.in(EUR(1.1))\n  println(s\"${usd} is equal to ${eur}\")\n\n  // Example conversion: Time\n  val seconds: Time = Seconds(3600)\n  val hours: Time = seconds.toHours\n  println(s\"${seconds} is equal to ${hours}\")\n}\n```"
  },
  {
    "task": "Use a library to implement a caching mechanism for improving application performance.",
    "code": "```scala\nimport scalacache._\nimport scalacache.caffeine._\nimport scala.concurrent.duration._\n\nobject CacheExample extends App {\n  // Create a Caffeine cache\n  implicit val cache: Cache[String] = CaffeineCache[String]\n\n  def cachedComputation(key: String, computation: => String): String = {\n    // Attempt to get the cached value\n    val value = scalacache.sync.get(key)\n    value.getOrElse {\n      // If not found in cache, compute the value\n      val result = computation\n      // Cache the result for future use\n      scalacache.sync.put(key)(result, ttl = Some(10.minutes))\n      result\n    }\n  }\n\n  // Example usage\n  val result = cachedComputation(\"expensiveOp\", {\n    // Simulate an expensive operation\n    Thread.sleep(1000)\n    \"Computed Result\"\n  })\n\n  println(result)\n}\n```"
  },
  {
    "task": "Build an e-commerce platform that integrates a payment processing library for handling transactions.",
    "code": "```scala\nimport io.circe.generic.auto._\nimport io.circe.syntax._\nimport scala.concurrent.Future\nimport scala.util.{Failure, Success}\nimport akka.actor.ActorSystem\nimport akka.http.scaladsl.Http\nimport akka.http.scaladsl.model._\nimport akka.http.scaladsl.server.Directives._\nimport akka.stream.ActorMaterializer\nimport com.stripe.Stripe\nimport com.stripe.model.checkout.Session\nimport com.stripe.param.checkout.SessionCreateParams\n\nobject ECommercePlatform {\n  implicit val system: ActorSystem = ActorSystem(\"ecommerce-platform\")\n  implicit val materializer: ActorMaterializer = ActorMaterializer()\n  implicit val executionContext = system.dispatcher\n\n  // Initialize Stripe with the secret key\n  Stripe.apiKey = \"your_stripe_secret_key\"\n\n  def createCheckoutSession(amount: Long, currency: String, successUrl: String, cancelUrl: String): Future[Session] = Future {\n    val params = SessionCreateParams.builder()\n      .setPaymentMethodTypes(java.util.Arrays.asList(\"card\"))\n      .setLineItems(java.util.Arrays.asList(\n        SessionCreateParams.LineItem.builder()\n          .setPriceData(\n            SessionCreateParams.LineItem.PriceData.builder()\n              .setCurrency(currency)\n              .setUnitAmount(amount)\n              .setProductData(\n                SessionCreateParams.LineItem.PriceData.ProductData.builder()\n                  .setName(\"Sample Product\")\n                  .build())\n              .build())\n          .setQuantity(1L)\n          .build()))\n      .setMode(SessionCreateParams.Mode.PAYMENT)\n      .setSuccessUrl(successUrl)\n      .setCancelUrl(cancelUrl)\n      .build()\n\n    Session.create(params)\n  }\n\n  val route =\n    path(\"create-checkout-session\") {\n      post {\n        entity(as[String]) { body =>\n          val paymentData = io.circe.parser.decode[Map[String, String]](body).getOrElse(Map())\n          val amount = paymentData.getOrElse(\"amount\", \"0\").toLong\n          val currency = paymentData.getOrElse(\"currency\", \"usd\")\n          val successUrl = paymentData.getOrElse(\"successUrl\", \"http://localhost:8080/success\")\n          val cancelUrl = paymentData.getOrElse(\"cancelUrl\", \"http://localhost:8080/cancel\")\n\n          onComplete(createCheckoutSession(amount, currency, successUrl, cancelUrl)) {\n            case Success(session) => complete(HttpEntity(ContentTypes.`application/json`, session.toJson))\n            case Failure(exception) => complete(HttpResponse(StatusCodes.InternalServerError, entity = exception.getMessage))\n          }\n        }\n      }\n    }\n\n  def main(args: Array[String]): Unit = {\n    val bindingFuture = Http().bindAndHandle(route, \"localhost\", 8080)\n    println(\"Server online at http://localhost:8080/\")\n  }\n}\n```"
  },
  {
    "task": "Create a to-do list application that stores data locally using a library for file management.",
    "code": "```scala\nimport scala.io.Source\nimport java.io.{File, PrintWriter}\n\nobject TodoListApp {\n  val fileName = \"todolist.txt\"\n\n  def loadTasks(): List[String] = {\n    if (new File(fileName).exists()) {\n      Source.fromFile(fileName).getLines().toList\n    } else {\n      List.empty\n    }\n  }\n\n  def saveTasks(tasks: List[String]): Unit = {\n    val writer = new PrintWriter(new File(fileName))\n    tasks.foreach(writer.println)\n    writer.close()\n  }\n\n  def main(args: Array[String]): Unit = {\n    var tasks = loadTasks()\n\n    while (true) {\n      println(\"1. View tasks\")\n      println(\"2. Add task\")\n      println(\"3. Remove task\")\n      println(\"4. Exit\")\n      print(\"Choose an option: \")\n      val choice = scala.io.StdIn.readInt()\n\n      choice match {\n        case 1 =>\n          println(\"Your tasks:\")\n          tasks.zipWithIndex.foreach { case (task, index) => println(s\"${index + 1}. $task\") }\n\n        case 2 =>\n          print(\"Enter new task: \")\n          val newTask = scala.io.StdIn.readLine()\n          tasks = tasks :+ newTask\n          saveTasks(tasks)\n\n        case 3 =>\n          print(\"Enter task number to remove: \")\n          val taskNumber = scala.io.StdIn.readInt()\n          if (taskNumber > 0 && taskNumber <= tasks.length) {\n            tasks = tasks.patch(taskNumber - 1, Nil, 1)\n            saveTasks(tasks)\n          } else {\n            println(\"Invalid task number.\")\n          }\n\n        case 4 =>\n          println(\"Exiting...\")\n          System.exit(0)\n\n        case _ =>\n          println(\"Invalid option. Please try again.\")\n      }\n    }\n  }\n}\n```"
  },
  {
    "task": "Develop a system that monitors server health using a library that provides network utilities.",
    "code": "```scala\nimport com.example.network.NetworkUtils\n\nobject ServerHealthMonitor {\n  def main(args: Array[String]): Unit = {\n    val servers = List(\"192.168.1.1\", \"192.168.1.2\", \"192.168.1.3\")\n\n    servers.foreach { server =>\n      val isReachable = NetworkUtils.ping(server)\n      val responseTime = NetworkUtils.getResponseTime(server)\n\n      println(s\"Server: $server, Reachable: $isReachable, Response Time: $responseTime ms\")\n    }\n  }\n}\n```"
  },
  {
    "task": "Implement a program that detects language from a given text using a language detection library.",
    "code": "```scala\nimport com.github.pemistahl.lingua.api.{Language, LanguageDetectorBuilder}\n\nobject LanguageDetectionApp extends App {\n  val detector = LanguageDetectorBuilder.fromAllLanguages.build()\n  \n  def detectLanguage(text: String): Language = {\n    detector.detectLanguageOf(text)\n  }\n\n  val sampleText = \"Bonjour tout le monde\"\n  val detectedLanguage = detectLanguage(sampleText)\n  println(s\"The detected language is: $detectedLanguage\")\n}\n```"
  },
  {
    "task": "Write a script that sends notifications to a mobile device using a push notification library.",
    "code": "```scala\nimport com.github.pushy.sdk.PushyAPI\nimport com.github.pushy.sdk.util.exceptions.PushyException\n\nobject PushNotificationSender {\n  def main(args: Array[String]): Unit = {\n    // Replace with your Pushy API key\n    val apiKey = \"YOUR_API_KEY\"\n    \n    // Replace with the device token you wish to send to\n    val deviceToken = \"DEVICE_TOKEN\"\n    \n    // Create a notification payload\n    val payload = Map(\"message\" -> \"Hello, World!\")\n\n    try {\n      // Send the notification\n      val response = PushyAPI.sendPushNotification(apiKey, deviceToken, payload)\n      \n      // Print the response\n      println(s\"Notification sent successfully: $response\")\n    } catch {\n      case e: PushyException =>\n        println(s\"Failed to send notification: ${e.getMessage}\")\n    }\n  }\n}\n```"
  },
  {
    "task": "Use a library to generate reports in PDF format from application data.",
    "code": "```scala\nimport com.itextpdf.kernel.pdf._\nimport com.itextpdf.layout._\nimport com.itextpdf.layout.element._\n\nobject PdfReportGenerator {\n  def main(args: Array[String]): Unit = {\n    val pdfWriter = new PdfWriter(\"report.pdf\")\n    val pdfDoc = new PdfDocument(pdfWriter)\n    val document = new Document(pdfDoc)\n\n    // Example data\n    val data = List(\n      Map(\"Name\" -> \"Alice\", \"Age\" -> \"30\", \"Occupation\" -> \"Engineer\"),\n      Map(\"Name\" -> \"Bob\", \"Age\" -> \"25\", \"Occupation\" -> \"Designer\"),\n      Map(\"Name\" -> \"Charlie\", \"Age\" -> \"35\", \"Occupation\" -> \"Manager\")\n    )\n\n    val table = new Table(3)\n    table.addHeaderCell(\"Name\")\n    table.addHeaderCell(\"Age\")\n    table.addHeaderCell(\"Occupation\")\n\n    data.foreach { row =>\n      table.addCell(row(\"Name\"))\n      table.addCell(row(\"Age\"))\n      table.addCell(row(\"Occupation\"))\n    }\n\n    document.add(table)\n    document.close()\n  }\n}\n```"
  },
  {
    "task": "Build a program that performs statistical analysis on datasets using a statistical computing library.",
    "code": "```scala\nimport org.apache.commons.math3.stat.descriptive.DescriptiveStatistics\n\nobject StatisticalAnalysis {\n  def main(args: Array[String]): Unit = {\n    val data = Array(1.0, 2.5, 3.8, 4.0, 5.6, 7.2, 8.0, 9.6, 10.1)\n\n    val stats = new DescriptiveStatistics()\n\n    data.foreach(stats.addValue)\n\n    println(s\"Mean: ${stats.getMean}\")\n    println(s\"Standard Deviation: ${stats.getStandardDeviation}\")\n    println(s\"Max: ${stats.getMax}\")\n    println(s\"Min: ${stats.getMin}\")\n    println(s\"Median: ${stats.getPercentile(50)}\")\n  }\n}\n```"
  },
  {
    "task": "Create an image gallery application that uses a library for image caching and lazy loading.",
    "code": "```scala\nimport scalafx.application.JFXApp\nimport scalafx.scene.Scene\nimport scalafx.scene.layout.{Pane, VBox}\nimport scalafx.scene.image.{Image, ImageView}\nimport javafx.application.Platform\nimport javafx.collections.{FXCollections, ObservableList}\nimport javafx.scene.control.ScrollPane\n\nimport com.github.benmanes.caffeine.cache.{Cache, Caffeine}\n\nobject ImageGalleryApp extends JFXApp {\n\n  // Using Caffeine for image caching\n  val imageCache: Cache[String, Image] = Caffeine.newBuilder()\n    .maximumSize(100)\n    .build[String, Image]()\n\n  // Lazy loading function\n  def loadImage(url: String): Image = {\n    Option(imageCache.getIfPresent(url)) match {\n      case Some(img) => img\n      case None => \n        val img = new Image(url, true)\n        img.progressProperty().addListener((_, _, _) => {\n          if (img.isError) imageCache.invalidate(url)\n          else imageCache.put(url, img)\n        })\n        img\n    }\n  }\n\n  // Sample images\n  val imageUrls: ObservableList[String] = FXCollections.observableArrayList(\n    \"https://example.com/image1.jpg\",\n    \"https://example.com/image2.jpg\",\n    \"https://example.com/image3.jpg\"\n  )\n\n  // Create image views\n  val imageViews = imageUrls.map(url => new ImageView {\n    image = loadImage(url)\n    fitWidth = 200\n    preserveRatio = true\n  })\n\n  // Layout\n  val vbox = new VBox(10)\n  vbox.children.addAll(imageViews: _*)\n\n  // Scene\n  stage = new JFXApp.PrimaryStage {\n    title.value = \"Image Gallery\"\n    scene = new Scene {\n      root = new ScrollPane {\n        content = new Pane {\n          children = vbox\n        }\n      }\n    }\n  }\n}\n```"
  },
  {
    "task": "Develop a machine learning model that predicts outcomes using a machine learning library.",
    "code": "```scala\nimport org.apache.spark.ml.Pipeline\nimport org.apache.spark.ml.classification.LogisticRegression\nimport org.apache.spark.ml.feature.{IndexToString, StringIndexer, VectorIndexer}\nimport org.apache.spark.sql.SparkSession\n\nobject MachineLearningModel {\n  def main(args: Array[String]): Unit = {\n    val spark = SparkSession.builder.appName(\"MachineLearningModel\").getOrCreate()\n    \n    // Load and parse the data file, converting it to a DataFrame\n    val data = spark.read.format(\"libsvm\").load(\"data/sample_libsvm_data.txt\")\n\n    // Index labels, adding metadata to the label column.\n    val labelIndexer = new StringIndexer().setInputCol(\"label\").setOutputCol(\"indexedLabel\").fit(data)\n    \n    // Automatically identify categorical features, and index them.\n    val featureIndexer = new VectorIndexer().setInputCol(\"features\").setOutputCol(\"indexedFeatures\").setMaxCategories(4).fit(data)\n\n    // Split the data into training and test sets\n    val Array(trainingData, testData) = data.randomSplit(Array(0.7, 0.3))\n\n    // Train a LogisticRegression model\n    val lr = new LogisticRegression().setLabelCol(\"indexedLabel\").setFeaturesCol(\"indexedFeatures\")\n\n    // Convert indexed labels back to original labels\n    val labelConverter = new IndexToString().setInputCol(\"prediction\").setOutputCol(\"predictedLabel\").setLabels(labelIndexer.labels)\n\n    // Chain indexers and logistic regression in a Pipeline\n    val pipeline = new Pipeline().setStages(Array(labelIndexer, featureIndexer, lr, labelConverter))\n\n    // Train model\n    val model = pipeline.fit(trainingData)\n\n    // Make predictions\n    val predictions = model.transform(testData)\n\n    // Select example rows to display\n    predictions.select(\"predictedLabel\", \"label\", \"features\").show(5)\n\n    // Stop the session\n    spark.stop()\n  }\n}\n```"
  },
  {
    "task": "Implement a feature that automatically formats code according to style guidelines using a code formatter library.",
    "code": "```scala\nimport org.scalafmt.interfaces.Scalafmt\nimport java.nio.file.Paths\n\nobject CodeFormatter {\n  def main(args: Array[String]): Unit = {\n    val scalafmt = Scalafmt.create(this.getClass.getClassLoader)\n    val filePath = Paths.get(\"src/main/scala/Example.scala\")\n    val originalCode = scala.io.Source.fromFile(filePath.toFile).mkString\n\n    try {\n      val formattedCode = scalafmt.format(filePath, originalCode)\n      println(\"Formatted Code:\")\n      println(formattedCode)\n    } catch {\n      case e: Exception =>\n        println(s\"Error formatting code: ${e.getMessage}\")\n    }\n  }\n}\n```"
  },
  {
    "task": "Write a program that generates barcodes using a library for barcode generation.",
    "code": "```scala\nimport org.krysalis.barcode4j.impl.code128.Code128Bean\nimport org.krysalis.barcode4j.output.bitmap.BitmapCanvasProvider\nimport java.io.FileOutputStream\nimport java.io.OutputStream\nimport java.awt.image.BufferedImage\nimport javax.imageio.ImageIO\n\nobject BarcodeGenerator {\n  def main(args: Array[String]): Unit = {\n    val barcodeValue = \"123456789012\"\n    generateBarcode(barcodeValue, \"barcode.png\")\n  }\n\n  def generateBarcode(data: String, filePath: String): Unit = {\n    val bean = new Code128Bean()\n    val dpi = 150\n    bean.setModuleWidth(0.21)\n    bean.doQuietZone(true)\n\n    val outputStream: OutputStream = new FileOutputStream(filePath)\n    try {\n      val canvas = new BitmapCanvasProvider(\n        outputStream, \"image/x-png\", dpi, BufferedImage.TYPE_BYTE_BINARY, false, 0\n      )\n\n      bean.generateBarcode(canvas, data)\n      canvas.finish()\n    } finally {\n      outputStream.close()\n    }\n  }\n}\n```"
  },
  {
    "task": "Use a library to create interactive maps for displaying geographical data in your application.",
    "code": "```scala\nimport com.cibo.evilplot.plot.aesthetics.DefaultTheme._\nimport com.cibo.evilplot.plot._\nimport com.cibo.evilplot.plot.renderers.PointRenderer\nimport org.geotools.map.{MapContent, MapViewport}\nimport org.geotools.swing.JMapFrame\nimport org.geotools.swing.tool.PanTool\nimport org.geotools.swing.tool.ZoomInTool\nimport org.geotools.swing.tool.ZoomOutTool\n\nobject InteractiveMapApp extends App {\n  // Create the map content\n  val mapContent = new MapContent()\n  mapContent.setTitle(\"Interactive Map Example\")\n\n  // Create a map frame\n  val mapFrame = new JMapFrame(mapContent)\n\n  // Enable tools\n  mapFrame.enableToolBar(true)\n  mapFrame.enableStatusBar(true)\n\n  // Add tools for interaction\n  mapFrame.getToolBar.add(new PanTool())\n  mapFrame.getToolBar.add(new ZoomInTool())\n  mapFrame.getToolBar.add(new ZoomOutTool())\n\n  // Set up the map viewport\n  val viewport = new MapViewport()\n  mapContent.setViewport(viewport)\n\n  // Display the map\n  mapFrame.setSize(800, 600)\n  mapFrame.setVisible(true)\n}\n```"
  },
  {
    "task": "Build a simulation that models fluid dynamics using a library for physics simulations.",
    "code": "```scala\nimport com.badlogic.gdx.backends.lwjgl.LwjglApplication\nimport com.badlogic.gdx.backends.lwjgl.LwjglApplicationConfiguration\nimport com.badlogic.gdx.physics.box2d.{Body, BodyDef, FixtureDef, PolygonShape, World}\n\nobject FluidDynamicsSimulation extends App {\n  val config = new LwjglApplicationConfiguration()\n  config.title = \"Fluid Dynamics Simulation\"\n  config.width = 800\n  config.height = 600\n  new LwjglApplication(new FluidDynamicsGame, config)\n}\n\nclass FluidDynamicsGame extends com.badlogic.gdx.Game {\n  override def create(): Unit = {\n    val world = new World(new com.badlogic.gdx.math.Vector2(0, -9.8f), true)\n\n    createFluid(world)\n  }\n\n  def createFluid(world: World): Unit = {\n    val bodyDef = new BodyDef()\n    bodyDef.`type` = BodyDef.BodyType.DynamicBody\n    bodyDef.position.set(0, 4)\n\n    val body = world.createBody(bodyDef)\n    val shape = new PolygonShape()\n    shape.setAsBox(1, 1)\n\n    val fixtureDef = new FixtureDef()\n    fixtureDef.shape = shape\n    fixtureDef.density = 1.0f\n    fixtureDef.friction = 0.3f\n\n    body.createFixture(fixtureDef)\n    shape.dispose()\n  }\n}\n```"
  },
  {
    "task": "Create a program that reads barcodes from images using a library for barcode scanning.",
    "code": "```scala\nimport com.google.zxing._\nimport com.google.zxing.client.j2se.BufferedImageLuminanceSource\nimport com.google.zxing.common.HybridBinarizer\n\nimport java.awt.image.BufferedImage\nimport java.io.File\nimport javax.imageio.ImageIO\n\nobject BarcodeReader {\n  def readBarcode(file: File): Option[String] = {\n    val bufferedImage: BufferedImage = ImageIO.read(file)\n    val source = new BufferedImageLuminanceSource(bufferedImage)\n    val bitmap = new BinaryBitmap(new HybridBinarizer(source))\n    val reader = new MultiFormatReader()\n\n    try {\n      val result = reader.decode(bitmap)\n      Some(result.getText)\n    } catch {\n      case _: NotFoundException => None\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val file = new File(\"path_to_your_image_file\")\n    readBarcode(file) match {\n      case Some(barcode) => println(s\"Barcode read: $barcode\")\n      case None => println(\"No barcode found.\")\n    }\n  }\n}\n```"
  },
  {
    "task": "Develop a feature that performs spell checking using a library for text processing.",
    "code": "```scala\nimport org.apache.commons.text.similarity.HammingDistance\n\nobject SpellChecker {\n  def main(args: Array[String]): Unit = {\n    val dictionary = List(\"hello\", \"world\", \"scala\", \"library\", \"integration\", \"feature\")\n    val text = \"helllo worlld scaala librarry integration feateure\"\n    val correctedText = spellCheck(text, dictionary)\n    println(correctedText)\n  }\n\n  def spellCheck(text: String, dictionary: List[String]): String = {\n    val hammingDistance = new HammingDistance()\n    text.split(\" \").map(word => {\n      val closestMatch = dictionary.minBy(dictWord => hammingDistance.apply(word, dictWord))\n      if (hammingDistance.apply(word, closestMatch) <= 2) closestMatch else word\n    }).mkString(\" \")\n  }\n}\n```"
  },
  {
    "task": "Implement a service that aggregates news articles from various sources using a library for web content aggregation.",
    "code": "```scala\nimport com.rometools.rome.feed.synd.SyndFeed\nimport com.rometools.rome.io.SyndFeedInput\nimport com.rometools.rome.io.XmlReader\nimport scala.collection.JavaConverters._\nimport scala.util.{Try, Success, Failure}\n\nobject NewsAggregatorService {\n  def fetchFeed(url: String): Try[SyndFeed] = {\n    Try {\n      val input = new SyndFeedInput()\n      val feed = input.build(new XmlReader(new java.net.URL(url)))\n      feed\n    }\n  }\n\n  def aggregateFeeds(urls: List[String]): List[String] = {\n    urls.flatMap { url =>\n      fetchFeed(url) match {\n        case Success(feed) => \n          feed.getEntries.asScala.map(_.getTitle).toList\n        case Failure(_) => \n          List.empty\n      }\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val sources = List(\n      \"http://example.com/rss1.xml\",\n      \"http://example.com/rss2.xml\"\n    )\n    val articles = aggregateFeeds(sources)\n    articles.foreach(println)\n  }\n}\n```"
  },
  {
    "task": "Write a script that converts spoken language to text using a speech recognition library.",
    "code": "```scala\nimport scala.concurrent.ExecutionContext.Implicits.global\nimport scala.concurrent.Future\nimport java.io.File\nimport javax.sound.sampled.AudioSystem\nimport com.google.cloud.speech.v1.{RecognitionAudio, RecognitionConfig, SpeechClient, RecognitionConfig.AudioEncoding}\n\nobject SpeechToTextApp extends App {\n  def transcribeAudio(filePath: String): Future[String] = Future {\n    val client = SpeechClient.create()\n    val audioBytes = AudioSystem.getAudioInputStream(new File(filePath)).readAllBytes()\n\n    val audio = RecognitionAudio.newBuilder().setContent(com.google.protobuf.ByteString.copyFrom(audioBytes)).build()\n    val config = RecognitionConfig.newBuilder()\n      .setEncoding(AudioEncoding.LINEAR16)\n      .setSampleRateHertz(16000)\n      .setLanguageCode(\"en-US\")\n      .build()\n\n    val response = client.recognize(config, audio)\n    client.close()\n    \n    response.getResultsList.get(0).getAlternativesList.get(0).getTranscript\n  }\n\n  transcribeAudio(\"path/to/audio.wav\").foreach { text =>\n    println(s\"Transcribed text: $text\")\n  }\n}\n```"
  },
  {
    "task": "Use a library to implement a feature that tracks user behavior in a web application.",
    "code": "```scala\n// build.sbt\nlibraryDependencies += \"com.segment.analytics.scala\" %% \"analytics-scala\" % \"3.0.0\"\n\n// Main.scala\nimport com.segment.analytics.Analytics\nimport com.segment.analytics.messages.TrackMessage\n\nobject UserBehaviorTracker {\n  def main(args: Array[String]): Unit = {\n    val writeKey = \"YOUR_WRITE_KEY\"\n    val analytics = Analytics.builder(writeKey).build()\n\n    // Example of tracking a user action\n    val userId = \"user-123\"\n    val event = \"Button Clicked\"\n    val properties = Map(\"buttonName\" -> \"Subscribe\", \"page\" -> \"Homepage\")\n\n    analytics.enqueue(TrackMessage.builder(event)\n      .userId(userId)\n      .properties(properties))\n\n    analytics.flush()\n    println(\"User behavior tracked successfully.\")\n  }\n}\n```"
  },
  {
    "task": "Build a program that analyzes sentiment in social media posts using a sentiment analysis library.",
    "code": "```scala\nimport com.vaderSentiment.analyzer.SentimentIntensityAnalyzer\n\nobject SentimentAnalysisApp extends App {\n  val analyzer = new SentimentIntensityAnalyzer()\n\n  def analyzeSentiment(post: String): String = {\n    val sentimentScores = analyzer.polarityScores(post)\n    if (sentimentScores(\"compound\") >= 0.05) \"Positive\"\n    else if (sentimentScores(\"compound\") <= -0.05) \"Negative\"\n    else \"Neutral\"\n  }\n\n  val socialMediaPosts = List(\n    \"I love sunny weather!\",\n    \"This is the worst day ever.\",\n    \"I'm not sure how I feel about this.\"\n  )\n\n  socialMediaPosts.foreach { post =>\n    println(s\"Post: $post => Sentiment: ${analyzeSentiment(post)}\")\n  }\n}\n```"
  },
  {
    "task": "Create a utility that detects plagiarism in text using a library for text comparison.",
    "code": "```scala\nimport com.wagnerandade.coollection.Coollection\nimport com.wagnerandade.coollection.matcher.Matchers._\n\nobject PlagiarismDetector {\n  def detectPlagiarism(sourceText: String, comparisonText: String): Boolean = {\n    val sourceWords = sourceText.split(\"\\\\W+\").toSeq\n    val comparisonWords = comparisonText.split(\"\\\\W+\").toSeq\n    \n    val commonWords = Coollection(sourceWords).find(IN(comparisonWords)).fetch()\n    \n    commonWords.nonEmpty\n  }\n\n  def main(args: Array[String]): Unit = {\n    val text1 = \"This is a sample text to be checked for plagiarism.\"\n    val text2 = \"This text is a sample to check for plagiarism.\"\n\n    if (detectPlagiarism(text1, text2)) {\n      println(\"Plagiarism detected.\")\n    } else {\n      println(\"No plagiarism detected.\")\n    }\n  }\n}\n```"
  },
  {
    "task": "Develop a program that predicts weather trends using a library for time series forecasting.",
    "code": "```scala\nimport com.github.forecast.Forecast\nimport org.joda.time.LocalDate\nimport scala.collection.mutable.ArrayBuffer\n\nobject WeatherTrendPredictor {\n  def main(args: Array[String]): Unit = {\n    // Sample historical weather data (temperature readings)\n    val historicalData = ArrayBuffer(\n      (new LocalDate(2023, 1, 1), 5.0),\n      (new LocalDate(2023, 1, 2), 6.0),\n      (new LocalDate(2023, 1, 3), 5.5),\n      (new LocalDate(2023, 1, 4), 7.0),\n      (new LocalDate(2023, 1, 5), 8.0),\n      (new LocalDate(2023, 1, 6), 8.5),\n      (new LocalDate(2023, 1, 7), 9.0)\n    )\n\n    val forecastLib = new Forecast()\n\n    val temperatures = historicalData.map(_._2).toArray\n    val predictions = forecastLib.forecast(temperatures, 7)\n\n    println(\"Predicted Weather Trends for Next Week:\")\n    predictions.zipWithIndex.foreach {\n      case (prediction, index) =>\n        println(s\"Day ${index + 1}: $prediction\u00b0C\")\n    }\n  }\n}\n```"
  },
  {
    "task": "Implement a feature that performs facial recognition using a library specialized for biometric analysis.",
    "code": "```scala\nimport com.machinebox.sdk.Facebox\nimport java.io.File\nimport scala.concurrent.ExecutionContext.Implicits.global\nimport scala.concurrent.Future\n\nobject FacialRecognitionApp extends App {\n  val facebox = new Facebox(\"http://localhost:8080\")\n\n  def performFacialRecognition(imagePath: String): Future[Unit] = {\n    val imageFile = new File(imagePath)\n    facebox.check(imageFile).map { response =>\n      response.faces.foreach { face =>\n        println(s\"Detected face with confidence: ${face.confidence}\")\n      }\n    }.recover { case ex =>\n      println(s\"An error occurred: ${ex.getMessage}\")\n    }\n  }\n\n  val imagePath = \"path/to/your/image.jpg\"\n  performFacialRecognition(imagePath)\n}\n```"
  },
  {
    "task": "Write a program that interacts with blockchain networks using a library for blockchain communication.",
    "code": "```scala\nimport org.web3j.protocol.Web3j\nimport org.web3j.protocol.http.HttpService\nimport org.web3j.crypto.Credentials\nimport org.web3j.tx.gas.DefaultGasProvider\nimport org.web3j.tx.TransactionManager\nimport org.web3j.tx.RawTransactionManager\nimport org.web3j.tx.response.NoOpProcessor\n\nobject BlockchainIntegration {\n  def main(args: Array[String]): Unit = {\n    val web3j = Web3j.build(new HttpService(\"https://mainnet.infura.io/v3/YOUR_INFURA_PROJECT_ID\"))\n\n    val credentials = Credentials.create(\"YOUR_PRIVATE_KEY\")\n\n    val transactionManager: TransactionManager = new RawTransactionManager(\n      web3j,\n      credentials,\n      new NoOpProcessor(web3j)\n    )\n\n    val gasProvider = new DefaultGasProvider()\n\n    // Example function call (e.g., checking balance or sending a transaction)\n    // This is a placeholder for the actual blockchain interaction logic\n    println(\"Connected to Ethereum network\")\n\n    // Remember to close the connection after operations\n    web3j.shutdown()\n  }\n}\n```"
  },
  {
    "task": "Use a library to perform image recognition tasks in your application.",
    "code": "```scala\nimport java.io.File\nimport javax.imageio.ImageIO\nimport com.sksamuel.scrimage.Image\nimport com.sksamuel.scrimage.nio.JpegWriter\nimport com.sksamuel.scrimage.filter.GrayscaleFilter\n\nobject ImageRecognitionApp extends App {\n  val imageFile = new File(\"path/to/image.jpg\")\n  val image = Image.fromFile(imageFile)\n\n  // Convert the image to grayscale as a simple image processing task\n  val grayscaleImage = image.filter(GrayscaleFilter)\n  \n  // Save the processed image\n  implicit val writer: JpegWriter = JpegWriter.Default\n  grayscaleImage.output(new File(\"path/to/processed_image.jpg\"))\n}\n```"
  },
  {
    "task": "Build a program that converts audio files from one format to another using an audio conversion library.",
    "code": "```scala\nimport com.somelibrary.AudioConverter\n\nobject AudioFormatConverter {\n  def main(args: Array[String]): Unit = {\n    if (args.length != 3) {\n      println(\"Usage: AudioFormatConverter <inputFilePath> <outputFilePath> <outputFormat>\")\n      sys.exit(1)\n    }\n\n    val inputFilePath = args(0)\n    val outputFilePath = args(1)\n    val outputFormat = args(2)\n\n    try {\n      AudioConverter.convert(inputFilePath, outputFilePath, outputFormat)\n      println(s\"Conversion successful: $inputFilePath to $outputFilePath as $outputFormat\")\n    } catch {\n      case ex: Exception =>\n        println(s\"Error during conversion: ${ex.getMessage}\")\n    }\n  }\n}\n```"
  },
  {
    "task": "Create a web application that uses a library for rendering 3D graphics.",
    "code": "```scala\nimport org.scalajs.dom\nimport org.denigma.threejs._\n\nobject MainApp {\n  def main(args: Array[String]): Unit = {\n    val container = dom.document.createElement(\"div\")\n    dom.document.body.appendChild(container)\n\n    val scene = new Scene()\n    val camera = new PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000)\n    val renderer = new WebGLRenderer()\n    renderer.setSize(window.innerWidth, window.innerHeight)\n    container.appendChild(renderer.domElement)\n\n    val geometry = new BoxGeometry(1, 1, 1)\n    val material = new MeshBasicMaterial(js.Dynamic.literal(color = 0x00ff00))\n    val cube = new Mesh(geometry, material)\n    scene.add(cube)\n\n    camera.position.z = 5\n\n    def render(): Unit = {\n      dom.window.requestAnimationFrame((_: Double) => render())\n      cube.rotation.x += 0.01\n      cube.rotation.y += 0.01\n      renderer.render(scene, camera)\n    }\n\n    render()\n  }\n}\n```"
  },
  {
    "task": "Develop a feature that performs currency conversion using a library for financial calculations.",
    "code": "```scala\nimport org.javamoney.moneta.Money\nimport javax.money.convert.MonetaryConversions\nimport javax.money.Monetary\nimport javax.money.CurrencyUnit\n\nobject CurrencyConverter {\n  def convertCurrency(amount: BigDecimal, fromCurrencyCode: String, toCurrencyCode: String): BigDecimal = {\n    val fromCurrency: CurrencyUnit = Monetary.getCurrency(fromCurrencyCode)\n    val toCurrency: CurrencyUnit = Monetary.getCurrency(toCurrencyCode)\n    val conversion: javax.money.convert.CurrencyConversion = MonetaryConversions.getConversion(toCurrency)\n    val money: Money = Money.of(amount.bigDecimal, fromCurrency)\n\n    val convertedMoney = money.with(conversion)\n    BigDecimal(convertedMoney.getNumberStripped)\n  }\n\n  def main(args: Array[String]): Unit = {\n    val amount = BigDecimal(100)\n    val fromCurrencyCode = \"USD\"\n    val toCurrencyCode = \"EUR\"\n\n    val convertedAmount = convertCurrency(amount, fromCurrencyCode, toCurrencyCode)\n    println(s\"$amount $fromCurrencyCode is $convertedAmount $toCurrencyCode\")\n  }\n}\n```"
  },
  {
    "task": "Implement a program that manages user sessions using a library for session handling.",
    "code": "```scala\nimport com.softwaremill.session._\nimport akka.http.scaladsl.server.Directives._\nimport akka.http.scaladsl.server.Route\n\nobject SessionManager extends App {\n  implicit val ec = scala.concurrent.ExecutionContext.global\n\n  case class UserSession(userId: String)\n\n  implicit val serializer: SessionSerializer[UserSession, String] = new SingleValueSessionSerializer[UserSession, String](\n    _.userId, // serialize\n    userId => Right(UserSession(userId)) // deserialize\n  )\n\n  val sessionConfig = SessionConfig.default(\"your-secret-key\")\n  val sessionManager = new SessionManager[UserSession](sessionConfig)\n\n  val route: Route = path(\"login\") {\n    get {\n      setSession(sessionManager.oneOff, UserSession(\"1234\")) {\n        complete(\"Session started\")\n      }\n    }\n  } ~ path(\"logout\") {\n    get {\n      invalidateSession(sessionManager.oneOff) {\n        complete(\"Session invalidated\")\n      }\n    }\n  } ~ path(\"protected\") {\n    get {\n      requiredSession(sessionManager.oneOff) { session =>\n        complete(s\"Welcome user ${session.userId}\")\n      }\n    }\n  }\n\n  // Insert code to start your HTTP server with the defined route\n}\n```"
  },
  {
    "task": "Write a script that automates browser actions using a browser automation library.",
    "code": "```scala\nimport org.openqa.selenium.WebDriver\nimport org.openqa.selenium.chrome.ChromeDriver\nimport org.openqa.selenium.WebElement\nimport org.openqa.selenium.By\n\nobject BrowserAutomation {\n  def main(args: Array[String]): Unit = {\n    // Set the path to the chromedriver executable\n    System.setProperty(\"webdriver.chrome.driver\", \"/path/to/chromedriver\")\n\n    // Initialize the ChromeDriver\n    val driver: WebDriver = new ChromeDriver()\n\n    try {\n      // Open a webpage\n      driver.get(\"http://example.com\")\n\n      // Find an element by its name attribute\n      val element: WebElement = driver.findElement(By.name(\"q\"))\n\n      // Type a query in the search box\n      element.sendKeys(\"Scala programming\")\n\n      // Submit the form\n      element.submit()\n\n      // Wait for the page to load\n      Thread.sleep(2000)\n\n      // Print the title of the page\n      println(\"Page title is: \" + driver.getTitle)\n    } finally {\n      // Close the browser\n      driver.quit()\n    }\n  }\n}\n```"
  },
  {
    "task": "Use a library to implement data serialization and deserialization in your application.",
    "code": "```scala\nimport com.fasterxml.jackson.module.scala.DefaultScalaModule\nimport com.fasterxml.jackson.databind.ObjectMapper\n\nobject SerializationApp extends App {\n  case class Person(name: String, age: Int)\n\n  val mapper = new ObjectMapper()\n  mapper.registerModule(DefaultScalaModule)\n\n  // Serialize\n  val person = Person(\"John Doe\", 30)\n  val jsonString = mapper.writeValueAsString(person)\n  println(s\"Serialized JSON: $jsonString\")\n\n  // Deserialize\n  val deserializedPerson = mapper.readValue(jsonString, classOf[Person])\n  println(s\"Deserialized Object: $deserializedPerson\")\n}\n```"
  },
  {
    "task": "Build an application that generates interactive reports using a library for data visualization.",
    "code": "```scala\nimport com.cibo.evilplot.plot._\nimport com.cibo.evilplot.plot.aesthetics.DefaultTheme._\nimport com.cibo.evilplot.geometry.Extent\nimport com.cibo.evilplot.plot.renderers.PlotRenderer\n\nobject InteractiveReportApp extends App {\n\n  // Sample data for the report\n  val data = Seq(\n    (1.0, 2.0),\n    (2.0, 3.0),\n    (3.0, 5.0),\n    (4.0, 7.0),\n    (5.0, 11.0)\n  )\n\n  // Create a line plot using the EvilPlot library\n  val plot = LinePlot.series(data, \"Sample Data\", HSL(210, 100, 56))\n    .xAxis()\n    .yAxis()\n    .frame()\n    .xLabel(\"X Axis\")\n    .yLabel(\"Y Axis\")\n    .render()\n\n  // Render the plot to an SVG file\n  PlotRenderer.renderToFile(plot, Extent(600, 400), \"interactive_report.svg\")\n}\n```"
  },
  {
    "task": "Create a system that backs up and restores data using a library for file system operations.",
    "code": "```scala\nimport better.files._\nimport java.nio.file.{Paths, StandardCopyOption}\n\nobject BackupSystem {\n  def backupData(sourceDir: String, backupDir: String): Unit = {\n    val source = File(sourceDir)\n    val backup = File(backupDir)\n\n    if (!backup.exists) {\n      backup.createDirectories()\n    }\n\n    source.listRecursively.foreach { file =>\n      val target = backup / source.relativize(file).toString\n      if (file.isDirectory) {\n        target.createDirectories()\n      } else {\n        file.copyTo(target, overwrite = true)\n      }\n    }\n  }\n\n  def restoreData(backupDir: String, restoreDir: String): Unit = {\n    val backup = File(backupDir)\n    val restore = File(restoreDir)\n\n    if (!restore.exists) {\n      restore.createDirectories()\n    }\n\n    backup.listRecursively.foreach { file =>\n      val target = restore / backup.relativize(file).toString\n      if (file.isDirectory) {\n        target.createDirectories()\n      } else {\n        file.copyTo(target, overwrite = true)\n      }\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val sourceDir = \"source_data\"\n    val backupDir = \"backup_data\"\n    val restoreDir = \"restore_data\"\n\n    backupData(sourceDir, backupDir)\n    restoreData(backupDir, restoreDir)\n  }\n}\n```"
  },
  {
    "task": "Develop a feature that performs real-time language translation using a translation library.",
    "code": "```scala\nimport com.google.cloud.translate.{Translate, TranslateOptions, Translation}\n\nobject RealTimeTranslator {\n  def main(args: Array[String]): Unit = {\n    val translate: Translate = TranslateOptions.getDefaultInstance.getService\n\n    val textToTranslate = \"Hello, how are you?\"\n    val targetLanguage = \"es\" // Spanish\n\n    val translation: Translation = translate.translate(\n      textToTranslate,\n      Translate.TranslateOption.targetLanguage(targetLanguage),\n      Translate.TranslateOption.model(\"nmt\")\n    )\n\n    println(s\"Original: $textToTranslate\")\n    println(s\"Translated: ${translation.getTranslatedText}\")\n  }\n}\n```"
  },
  {
    "task": "Implement a program that tracks stock market prices using a library for financial data retrieval.",
    "code": "```scala\nimport com.github.seratch.yahoo_finance_api._  // Assuming a library for financial data retrieval\n\nobject StockMarketTracker extends App {\n  val yahooFinance = YahooFinanceApi.newYahooFinance\n  val symbols = List(\"AAPL\", \"GOOGL\", \"AMZN\")\n  \n  symbols.foreach { symbol =>\n    val stockPrice = yahooFinance.getQuote(symbol).get().price\n    println(s\"The current price of $symbol is $$${stockPrice}\")\n  }\n}\n```"
  },
  {
    "task": "Write a script that generates and validates JSON Web Tokens using a library for JWT handling.",
    "code": "```scala\nimport pdi.jwt.{Jwt, JwtAlgorithm, JwtClaim}\nimport scala.util.{Success, Failure}\n\nobject JwtExample extends App {\n  // Secret key for signing the JWT\n  val secretKey = \"yourSecretKey\"\n\n  // Create a claim for the token\n  val claim = JwtClaim(\n    issuer = Some(\"yourIssuer\"),\n    expiration = Some(System.currentTimeMillis / 1000 + 3600), // 1 hour expiration\n    issuedAt = Some(System.currentTimeMillis / 1000)\n  )\n\n  // Encode the token\n  val token = Jwt.encode(claim, secretKey, JwtAlgorithm.HS256)\n\n  // Print the generated token\n  println(s\"Generated Token: $token\")\n\n  // Validate the token\n  Jwt.decode(token, secretKey, Seq(JwtAlgorithm.HS256)) match {\n    case Success(decoded) => println(s\"Decoded JWT: $decoded\")\n    case Failure(ex) => println(s\"Token validation failed: ${ex.getMessage}\")\n  }\n}\n```"
  },
  {
    "task": "Use a library to build a feature that synchronizes data across multiple devices.",
    "code": "```scala\nimport akka.actor.ActorSystem\nimport akka.stream.ActorMaterializer\nimport akka.stream.alpakka.sqs.scaladsl.{SqsSource, SqsSink}\nimport akka.stream.scaladsl.{Flow, Keep, Sink}\nimport akka.stream.alpakka.sqs.MessageAction\nimport com.amazonaws.services.sqs.AmazonSQSAsyncClientBuilder\nimport com.amazonaws.services.sqs.model.Message\n\nimport scala.concurrent.Future\n\nobject DeviceDataSynchronizer extends App {\n  implicit val system: ActorSystem = ActorSystem(\"DeviceDataSynchronizer\")\n  implicit val materializer: ActorMaterializer = ActorMaterializer()\n\n  val sqsClient = AmazonSQSAsyncClientBuilder.defaultClient()\n  val queueUrl = \"https://sqs.us-east-1.amazonaws.com/your-account-id/your-queue-name\"\n\n  val sqsSource = SqsSource(queueUrl)(sqsClient)\n  val sqsSink = SqsSink(queueUrl)(sqsClient)\n\n  val synchronizationFlow: Flow[Message, MessageAction, _] = Flow[Message].mapAsync(1) { message =>\n    Future {\n      // Simulate data synchronization process\n      println(s\"Synchronizing data: ${message.getBody}\")\n      // Acknowledge message after processing\n      MessageAction.delete(message)\n    }\n  }\n\n  sqsSource\n    .via(synchronizationFlow)\n    .toMat(Sink.ignore)(Keep.both)\n    .run()\n}\n```"
  },
  {
    "task": "Build a program that implements pattern recognition using a library for machine learning.",
    "code": "```scala\nimport org.apache.spark.ml.{Pipeline, PipelineModel}\nimport org.apache.spark.ml.classification.LogisticRegression\nimport org.apache.spark.ml.feature.{HashingTF, Tokenizer}\nimport org.apache.spark.sql.SparkSession\n\nobject PatternRecognitionApp {\n\n  def main(args: Array[String]): Unit = {\n    val spark = SparkSession.builder\n      .appName(\"Pattern Recognition\")\n      .master(\"local[*]\")\n      .getOrCreate()\n\n    // Sample data for pattern recognition\n    val trainingData = spark.createDataFrame(Seq(\n      (0L, \"spark hadoop spark\", 1.0),\n      (1L, \"apache hadoop\", 0.0),\n      (2L, \"spark mllib\", 1.0),\n      (3L, \"apple orange\", 0.0)\n    )).toDF(\"id\", \"text\", \"label\")\n\n    // Configure an ML pipeline, which consists of three stages: tokenizer, hashingTF, and lr.\n    val tokenizer = new Tokenizer().setInputCol(\"text\").setOutputCol(\"words\")\n    val hashingTF = new HashingTF().setInputCol(tokenizer.getOutputCol).setOutputCol(\"features\")\n    val lr = new LogisticRegression().setMaxIter(10).setRegParam(0.001)\n\n    val pipeline = new Pipeline().setStages(Array(tokenizer, hashingTF, lr))\n\n    // Fit the pipeline to training documents.\n    val model = pipeline.fit(trainingData)\n\n    // Prepare test data\n    val testData = spark.createDataFrame(Seq(\n      (4L, \"spark hadoop\"),\n      (5L, \"apache spark\"),\n      (6L, \"orange\")\n    )).toDF(\"id\", \"text\")\n\n    // Make predictions on test documents.\n    val predictions = model.transform(testData)\n    predictions.select(\"id\", \"text\", \"probability\", \"prediction\").show()\n\n    spark.stop()\n  }\n}\n```"
  },
  {
    "task": "Create an email client that uses a library for IMAP and POP3 communication.",
    "code": "```scala\nimport com.sun.mail.imap.IMAPStore\nimport com.sun.mail.pop3.POP3Store\nimport java.util.Properties\nimport javax.mail.{Session, Folder, Message}\n\nobject EmailClient {\n  def main(args: Array[String]): Unit = {\n    val imapProps = new Properties()\n    imapProps.put(\"mail.store.protocol\", \"imap\")\n    imapProps.put(\"mail.imap.host\", \"imap.example.com\")\n    imapProps.put(\"mail.imap.port\", \"993\")\n    imapProps.put(\"mail.imap.ssl.enable\", \"true\")\n\n    val pop3Props = new Properties()\n    pop3Props.put(\"mail.store.protocol\", \"pop3\")\n    pop3Props.put(\"mail.pop3.host\", \"pop3.example.com\")\n    pop3Props.put(\"mail.pop3.port\", \"995\")\n    pop3Props.put(\"mail.pop3.ssl.enable\", \"true\")\n\n    val email = \"user@example.com\"\n    val password = \"password\"\n\n    // IMAP Email Retrieval\n    val imapSession = Session.getInstance(imapProps)\n    val imapStore = imapSession.getStore(\"imap\").asInstanceOf[IMAPStore]\n    imapStore.connect(email, password)\n    val inbox = imapStore.getFolder(\"INBOX\")\n    inbox.open(Folder.READ_ONLY)\n    val messages = inbox.getMessages\n    messages.foreach { msg => println(s\"IMAP - Subject: ${msg.getSubject}\") }\n    inbox.close(false)\n    imapStore.close()\n\n    // POP3 Email Retrieval\n    val pop3Session = Session.getInstance(pop3Props)\n    val pop3Store = pop3Session.getStore(\"pop3\").asInstanceOf[POP3Store]\n    pop3Store.connect(email, password)\n    val pop3Inbox = pop3Store.getFolder(\"INBOX\")\n    pop3Inbox.open(Folder.READ_ONLY)\n    val pop3Messages = pop3Inbox.getMessages\n    pop3Messages.foreach { msg => println(s\"POP3 - Subject: ${msg.getSubject}\") }\n    pop3Inbox.close(false)\n    pop3Store.close()\n  }\n}\n```"
  },
  {
    "task": "Develop a feature that analyzes network traffic using a library for network monitoring.",
    "code": "```scala\nimport io.pkts.Pcap\nimport io.pkts.packet.Packet\nimport io.pkts.packet.TCPPacket\n\nobject NetworkTrafficAnalyzer {\n  def main(args: Array[String]): Unit = {\n    val pathToPcapFile = \"network_traffic.pcap\"\n\n    val pcap = Pcap.openStream(pathToPcapFile)\n    pcap.loop((packet: Packet) => {\n      packet match {\n        case tcpPacket: TCPPacket =>\n          val srcIp = tcpPacket.getSourceIP\n          val dstIp = tcpPacket.getDestinationIP\n          val srcPort = tcpPacket.getSourcePort\n          val dstPort = tcpPacket.getDestinationPort\n          println(s\"TCP Packet: $srcIp:$srcPort -> $dstIp:$dstPort\")\n        case _ =>\n      }\n      true\n    })\n  }\n}\n```"
  },
  {
    "task": "Implement a program that manages user authentication and authorization using a security library.",
    "code": "```scala\nimport com.example.security.{AuthenticationManager, AuthorizationManager, User}\n\nobject SecurityApp extends App {\n  // Initialize the security library managers\n  val authManager = new AuthenticationManager()\n  val authzManager = new AuthorizationManager()\n\n  // Sample user data\n  val users = List(\n    User(\"alice\", \"password123\"),\n    User(\"bob\", \"securePass\")\n  )\n\n  // Authenticate users\n  users.foreach { user =>\n    val isAuthenticated = authManager.authenticate(user.username, user.password)\n    println(s\"User ${user.username} authenticated: $isAuthenticated\")\n\n    if (isAuthenticated) {\n      // Check user authorization\n      val isAuthorized = authzManager.isAuthorized(user.username, \"read_data\")\n      println(s\"User ${user.username} authorized for read_data: $isAuthorized\")\n    }\n  }\n}\n```"
  },
  {
    "task": "Write a script that generates word clouds from text data using a library for text visualization.",
    "code": "```scala\nimport io.github.cloudify.scala.spdf._\nimport org.apache.spark.sql.SparkSession\nimport org.apache.spark.ml.feature._\nimport org.apache.spark.ml.linalg._\nimport scala.collection.mutable\n\nobject WordCloudGenerator extends App {\n  // Initialize Spark session\n  val spark = SparkSession.builder.appName(\"WordCloudGenerator\").getOrCreate()\n  \n  // Sample text data\n  val textData = Seq(\n    \"Scala is a great programming language\",\n    \"Word clouds are a fun way to visualize text data\",\n    \"Libraries make integration easy\"\n  )\n\n  // Create DataFrame\n  import spark.implicits._\n  val df = textData.toDF(\"text\")\n\n  // Tokenization\n  val tokenizer = new Tokenizer().setInputCol(\"text\").setOutputCol(\"words\")\n  val wordsData = tokenizer.transform(df)\n\n  // Count word frequencies\n  val cvModel = new CountVectorizer()\n    .setInputCol(\"words\")\n    .setOutputCol(\"features\")\n    .fit(wordsData)\n  val featurizedData = cvModel.transform(wordsData)\n\n  // Convert features to list of words with frequencies\n  val wordFrequencies = featurizedData.select(\"features\")\n    .rdd\n    .flatMap(row => {\n      val vector = row.getAs[SparseVector](0)\n      vector.indices.zip(vector.values)\n    })\n    .reduceByKey(_ + _)\n    .collect()\n\n  // Generate word cloud\n  val wordCloud = new PDFBuilder()\n    .addPage(new PDFPage().add(\n      new WordCloud(wordFrequencies.map {\n        case (index, freq) => cvModel.vocabulary(index) -> freq.toInt\n      }.toSeq)\n    ))\n    .build()\n  \n  // Save word cloud to a file\n  wordCloud.saveAsFile(\"/path/to/wordcloud.pdf\")\n\n  // Stop Spark session\n  spark.stop()\n}\n```"
  },
  {
    "task": "Use a library to create a feature that schedules and sends automated emails.",
    "code": "```scala\nimport courier._\nimport scala.concurrent.ExecutionContext.Implicits.global\nimport scala.concurrent.Await\nimport scala.concurrent.duration._\n\nobject EmailScheduler {\n  def main(args: Array[String]): Unit = {\n    val mailer = Mailer(\"smtp.gmail.com\", 587)\n      .auth(true)\n      .as(\"<your-email>@gmail.com\", \"<your-password>\")\n      .startTls(true)()\n\n    val email = Envelope.from(\"<your-email>@gmail.com\".addr)\n      .to(\"<recipient-email>@example.com\".addr)\n      .subject(\"Automated Email\")\n      .content(Text(\"This is an automated email.\"))\n\n    val sendEmail = mailer(email)\n    \n    // Schedule the email to be sent after a delay\n    // In a real-world scenario, you might use a library like Quartz\n    // Here, we simply use a Future with a delay for demonstration\n    val scheduledEmail = Future {\n      Thread.sleep(5000) // Delay of 5 seconds\n      sendEmail\n    }\n\n    Await.result(scheduledEmail, 10.seconds)\n    println(\"Email sent successfully\")\n  }\n}\n```"
  },
  {
    "task": "Build a mobile application that accesses device sensors using a library for hardware interaction.",
    "code": "```scala\nimport android.app.Activity\nimport android.os.Bundle\nimport android.widget.TextView\nimport android.hardware.Sensor\nimport android.hardware.SensorManager\nimport android.hardware.SensorEvent\nimport android.hardware.SensorEventListener\n\nclass MainActivity extends Activity with SensorEventListener {\n  private var sensorManager: SensorManager = _\n  private var accelerometer: Sensor = _\n\n  override def onCreate(savedInstanceState: Bundle): Unit = {\n    super.onCreate(savedInstanceState)\n    setContentView(R.layout.activity_main)\n\n    val infoTextView = findViewById(R.id.infoTextView).asInstanceOf[TextView]\n\n    sensorManager = getSystemService(SENSOR_SERVICE).asInstanceOf[SensorManager]\n    accelerometer = sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER)\n    sensorManager.registerListener(this, accelerometer, SensorManager.SENSOR_DELAY_NORMAL)\n  }\n\n  override def onAccuracyChanged(sensor: Sensor, accuracy: Int): Unit = {\n    // Not implemented\n  }\n\n  override def onSensorChanged(event: SensorEvent): Unit = {\n    val infoTextView = findViewById(R.id.infoTextView).asInstanceOf[TextView]\n    val x = event.values(0)\n    val y = event.values(1)\n    val z = event.values(2)\n    infoTextView.setText(s\"Acceleration\\nX: $x\\nY: $y\\nZ: $z\")\n  }\n\n  override def onPause(): Unit = {\n    super.onPause()\n    sensorManager.unregisterListener(this)\n  }\n\n  override def onResume(): Unit = {\n    super.onResume()\n    sensorManager.registerListener(this, accelerometer, SensorManager.SENSOR_DELAY_NORMAL)\n  }\n}\n```"
  },
  {
    "task": "Create a system that audits and logs file system changes using a library for filesystem monitoring.",
    "code": "```scala\nimport java.nio.file._\nimport java.nio.file.StandardWatchEventKinds._\nimport scala.jdk.CollectionConverters._\n\nobject FileSystemAuditor extends App {\n  val watcher: WatchService = FileSystems.getDefault.newWatchService()\n  val path: Path = Paths.get(\".\")\n  path.register(watcher, ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY)\n\n  println(\"Monitoring the file system for changes...\")\n\n  while (true) {\n    val key = watcher.take()\n\n    for (event <- key.pollEvents().asScala) {\n      val kind = event.kind()\n      val fileName = event.context().asInstanceOf[Path]\n\n      kind match {\n        case ENTRY_CREATE => println(s\"File created: $fileName\")\n        case ENTRY_DELETE => println(s\"File deleted: $fileName\")\n        case ENTRY_MODIFY => println(s\"File modified: $fileName\")\n        case _ => println(\"Unknown event\")\n      }\n    }\n\n    key.reset()\n  }\n}\n```"
  },
  {
    "task": "Develop a feature that visualizes geospatial data using a library for geographic information systems.",
    "code": "```scala\nimport com.esri.core.geometry._\nimport com.esri.core.map._\nimport com.esri.core.symbol._\nimport com.esri.map._\n\nobject GeospatialVisualization {\n  def main(args: Array[String]): Unit = {\n    // Create a map with a basemap\n    val map = new JMap()\n    map.setBasemap(Basemap.createStreets())\n\n    // Setup the map view\n    val mapView = new JMapView()\n    mapView.setMap(map)\n\n    // Create a point graphic\n    val point = new Point(-118.15, 34.20)\n    val pointSymbol = new SimpleMarkerSymbol(Color.RED, 10, SimpleMarkerSymbol.Style.CIRCLE)\n    val pointGraphic = new Graphic(point, pointSymbol)\n\n    // Create a graphics layer and add the point graphic\n    val graphicsLayer = new GraphicsLayer()\n    graphicsLayer.addGraphic(pointGraphic)\n    map.getLayers.add(graphicsLayer)\n\n    // Setup and show the map window\n    val mapWindow = new JMapFrame()\n    mapWindow.setSize(800, 600)\n    mapWindow.setMapView(mapView)\n    mapWindow.setVisible(true)\n  }\n}\n```"
  },
  {
    "task": "Implement a program that performs clustering analysis using a library for statistical computing.",
    "code": "```scala\nimport org.apache.spark.ml.clustering.KMeans\nimport org.apache.spark.ml.linalg.Vectors\nimport org.apache.spark.sql.SparkSession\n\nobject ClusteringExample {\n  def main(args: Array[String]): Unit = {\n    val spark = SparkSession.builder\n      .appName(\"ClusteringExample\")\n      .master(\"local[*]\")\n      .getOrCreate()\n\n    val data = Seq(\n      (0, Vectors.dense(1.0, 2.0)),\n      (1, Vectors.dense(2.0, 3.0)),\n      (2, Vectors.dense(3.0, 4.0)),\n      (3, Vectors.dense(8.0, 9.0)),\n      (4, Vectors.dense(9.0, 10.0)),\n      (5, Vectors.dense(10.0, 11.0))\n    )\n\n    val dataset = spark.createDataFrame(data).toDF(\"id\", \"features\")\n\n    val kmeans = new KMeans().setK(2).setSeed(1L)\n    val model = kmeans.fit(dataset)\n\n    val predictions = model.transform(dataset)\n    predictions.show()\n\n    spark.stop()\n  }\n}\n```"
  },
  {
    "task": "Write a script that monitors and analyzes CPU and memory usage using a library for system diagnostics.",
    "code": "```scala\nimport scala.sys.process._\nimport com.github.oshi._\nimport com.github.oshi.hardware._\nimport com.github.oshi.software.os._\nimport com.github.oshi.util._\n\nobject SystemMonitor {\n  def main(args: Array[String]): Unit = {\n    val systemInfo = new SystemInfo()\n    val hardware = systemInfo.getHardware()\n    val os = systemInfo.getOperatingSystem()\n\n    val cpu = hardware.getProcessor()\n    val memory = hardware.getMemory()\n\n    while (true) {\n      val cpuLoad = cpu.getSystemCpuLoadBetweenTicks() * 100\n      val availableMemory = memory.getAvailable() / (1024 * 1024)\n      val totalMemory = memory.getTotal() / (1024 * 1024)\n\n      println(f\"CPU Load: $cpuLoad%.2f%%\")\n      println(f\"Memory Usage: ${totalMemory - availableMemory} MB / $totalMemory MB\")\n\n      Thread.sleep(5000)\n    }\n  }\n}\n```"
  },
  {
    "task": "Use a library to implement a feature that provides voice commands in your application.",
    "code": "```scala\nimport com.amazonaws.auth.AWSStaticCredentialsProvider\nimport com.amazonaws.auth.BasicAWSCredentials\nimport com.amazonaws.services.lexruntime.AmazonLexRuntime\nimport com.amazonaws.services.lexruntime.AmazonLexRuntimeClientBuilder\nimport com.amazonaws.services.lexruntime.model._\n\nobject VoiceCommandApp extends App {\n\n  val accessKeyId = \"your-access-key-id\"\n  val secretAccessKey = \"your-secret-access-key\"\n  val botName = \"YourBotName\"\n  val botAlias = \"YourBotAlias\"\n  val userId = \"YourUserId\"\n  \n  val credentials = new BasicAWSCredentials(accessKeyId, secretAccessKey)\n  val lexClient: AmazonLexRuntime = AmazonLexRuntimeClientBuilder.standard()\n    .withCredentials(new AWSStaticCredentialsProvider(credentials))\n    .withRegion(\"us-west-2\")\n    .build()\n  \n  def processVoiceCommand(audioInputStream: Array[Byte]): PostContentResult = {\n    val request = new PostContentRequest()\n      .withBotName(botName)\n      .withBotAlias(botAlias)\n      .withUserId(userId)\n      .withContentType(\"audio/l16; rate=16000; channels=1\")\n      .withInputStream(new java.io.ByteArrayInputStream(audioInputStream))\n    \n    lexClient.postContent(request)\n  }\n  \n  // Example usage\n  val audioInput = Array[Byte](/* your audio byte array here */)\n  val result = processVoiceCommand(audioInput)\n  println(s\"Message: ${result.getMessage}\")\n}\n```"
  },
  {
    "task": "Build a tool that converts video files to different resolutions using a video processing library.",
    "code": "```scala\nimport com.sksamuel.scrimage.ImmutableImage\nimport com.sksamuel.scrimage.nio.JpegWriter\nimport com.sksamuel.scrimage.nio.PngWriter\n\nobject VideoConverter {\n  def main(args: Array[String]): Unit = {\n    if (args.length < 3) {\n      println(\"Usage: VideoConverter <input_video> <output_resolution> <output_format>\")\n      System.exit(1)\n    }\n\n    val inputVideo = args(0)\n    val outputResolution = args(1)\n    val outputFormat = args(2)\n\n    val ffmpeg = new net.bramp.ffmpeg.FFmpeg(\"/path/to/ffmpeg\")\n    val ffprobe = new net.bramp.ffmpeg.FFprobe(\"/path/to/ffprobe\")\n\n    val builder = new net.bramp.ffmpeg.builder.FFmpegBuilder()\n      .setInput(inputVideo)\n      .addOutput(s\"output.$outputFormat\")\n      .setVideoResolution(outputResolution.split(\"x\")(0).toInt, outputResolution.split(\"x\")(1).toInt)\n      .done()\n\n    val executor = new net.bramp.ffmpeg.FFmpegExecutor(ffmpeg, ffprobe)\n    executor.createJob(builder).run()\n\n    println(s\"Video converted to $outputResolution and format $outputFormat successfully!\")\n  }\n}\n```"
  },
  {
    "task": "Create a program that detects and classifies objects in images using a library for image recognition.",
    "code": "```scala\nimport java.io.File\nimport org.tensorflow.TensorFlow\nimport org.tensorflow.Graph\nimport org.tensorflow.Session\nimport org.tensorflow.Tensor\nimport org.tensorflow.types.UInt8\nimport org.tensorflow.framework.GraphDef\nimport org.tensorflow.framework.Session.Runner\n\nobject ImageRecognition {\n  def main(args: Array[String]): Unit = {\n    val modelFile = \"path/to/model.pb\"\n    val labelFile = \"path/to/labels.txt\"\n    val imageFile = \"path/to/image.jpg\"\n\n    val labels = scala.io.Source.fromFile(labelFile).getLines().toArray\n\n    val imageBytes = java.nio.file.Files.readAllBytes(java.nio.file.Paths.get(imageFile))\n    val graphDef = java.nio.file.Files.readAllBytes(java.nio.file.Paths.get(modelFile))\n\n    val graph = new Graph()\n    graph.importGraphDef(graphDef)\n\n    val session = new Session(graph)\n    val runner = session.runner()\n\n    val imageTensor = Tensor.create(UInt8.DTYPE, Array(1L, imageBytes.length), java.nio.ByteBuffer.wrap(imageBytes))\n    runner.feed(\"input_tensor_name\", imageTensor)\n    runner.fetch(\"output_tensor_name\")\n\n    val output = runner.run()\n    val result = output.get(0).copyTo(Array.ofDim[Float](1, labels.length))\n    output.get(0).close()\n    imageTensor.close()\n    session.close()\n    graph.close()\n\n    val bestMatchIdx = result(0).zipWithIndex.maxBy(_._1)._2\n    println(s\"Detected object: ${labels(bestMatchIdx)}\")\n  }\n}\n```"
  },
  {
    "task": "Develop a feature that generates synthetic test data using a data generation library.",
    "code": "```scala\nimport com.github.javafaker.Faker\n\nobject SyntheticDataGenerator {\n  def main(args: Array[String]): Unit = {\n    val faker = new Faker()\n\n    // Example: Generate synthetic test data\n    val name = faker.name().fullName()\n    val address = faker.address().fullAddress()\n    val email = faker.internet().emailAddress()\n\n    println(s\"Name: $name\")\n    println(s\"Address: $address\")\n    println(s\"Email: $email\")\n  }\n}\n```"
  },
  {
    "task": "Implement a script that interacts with IoT devices using a library for IoT communication.",
    "code": "```scala\nimport com.example.iotlibrary.{IoTDevice, IoTManager}\n\nobject IoTIntegrationApp extends App {\n  val iotManager = new IoTManager()\n\n  val devices: List[IoTDevice] = iotManager.discoverDevices()\n\n  devices.foreach { device =>\n    if (device.isOnline) {\n      println(s\"Device ${device.id} is online. Sending command...\")\n      device.sendCommand(\"TurnOn\")\n      println(s\"Command sent to Device ${device.id}.\")\n    } else {\n      println(s\"Device ${device.id} is offline.\")\n    }\n  }\n}\n```"
  },
  {
    "task": "Write a program that compresses and decompresses data using a data compression library.",
    "code": "```scala\nimport java.util.zip.{Deflater, Inflater}\n\nobject CompressionDemo {\n  def compress(data: Array[Byte]): Array[Byte] = {\n    val deflater = new Deflater()\n    deflater.setInput(data)\n    deflater.finish()\n    val buffer = new Array[Byte](1024)\n    val outputStream = new java.io.ByteArrayOutputStream()\n    while (!deflater.finished()) {\n      val count = deflater.deflate(buffer)\n      outputStream.write(buffer, 0, count)\n    }\n    outputStream.toByteArray\n  }\n\n  def decompress(data: Array[Byte]): Array[Byte] = {\n    val inflater = new Inflater()\n    inflater.setInput(data)\n    val buffer = new Array[Byte](1024)\n    val outputStream = new java.io.ByteArrayOutputStream()\n    while (!inflater.finished()) {\n      val count = inflater.inflate(buffer)\n      outputStream.write(buffer, 0, count)\n    }\n    outputStream.toByteArray\n  }\n\n  def main(args: Array[String]): Unit = {\n    val originalData = \"This is a test string for compression\".getBytes(\"UTF-8\")\n    val compressedData = compress(originalData)\n    val decompressedData = decompress(compressedData)\n    println(s\"Original: ${new String(originalData, \"UTF-8\")}\")\n    println(s\"Decompressed: ${new String(decompressedData, \"UTF-8\")}\")\n  }\n}\n```"
  },
  {
    "task": "Use a library to implement a feature that generates dynamic web content from templates.",
    "code": "```scala\nimport scalate._\nimport org.fusesource.scalate.TemplateEngine\n\nobject DynamicContentGenerator {\n  def main(args: Array[String]): Unit = {\n    val engine = new TemplateEngine\n\n    val template = \"\"\"\n      |<html>\n      |<head>\n      |  <title>$title</title>\n      |</head>\n      |<body>\n      |  <h1>$heading</h1>\n      |  <p>$message</p>\n      |</body>\n      |</html>\n    \"\"\".stripMargin\n\n    val bindings = Map(\n      \"title\" -> \"Welcome Page\",\n      \"heading\" -> \"Hello, World!\",\n      \"message\" -> \"This is a dynamically generated page.\"\n    )\n\n    val output = engine.layout(\"template.ssp\", bindings, template)\n    println(output)\n  }\n}\n```"
  },
  {
    "task": "Build an application that integrates with social media platforms using a library for API communication.",
    "code": "```scala\nimport com.github.scribejava.core.builder.ServiceBuilder\nimport com.github.scribejava.core.model.{OAuthRequest, Verb, Response}\nimport com.github.scribejava.core.oauth.OAuth10aService\nimport com.github.scribejava.apis.TwitterApi\n\nobject SocialMediaIntegrationApp extends App {\n  val apiKey = \"your_api_key\"\n  val apiSecret = \"your_api_secret\"\n  val accessToken = \"your_access_token\"\n  val accessTokenSecret = \"your_access_token_secret\"\n\n  val service: OAuth10aService = new ServiceBuilder(apiKey)\n    .apiSecret(apiSecret)\n    .build(TwitterApi.instance())\n\n  val requestToken = service.getRequestToken\n  val authUrl = service.getAuthorizationUrl(requestToken)\n  println(s\"Authorization URL: $authUrl\")\n\n  val request = new OAuthRequest(Verb.GET, \"https://api.twitter.com/1.1/statuses/home_timeline.json\")\n  service.signRequest(accessToken, accessTokenSecret, request)\n  val response: Response = service.execute(request)\n\n  println(s\"Response Code: ${response.getCode}\")\n  println(s\"Response Body: ${response.getBody}\")\n}\n```"
  }
]