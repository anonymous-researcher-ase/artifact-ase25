[
  {
    "task": "Create a program that continuously asks the user to enter a number until they input a negative number.",
    "code": "```rust\nuse std::io;\n\nfn main() {\n    let mut input = String::new();\n\n    loop {\n        println!(\"Please enter a number:\");\n\n        input.clear();\n        io::stdin().read_line(&mut input).expect(\"Failed to read line\");\n\n        let number: i32 = match input.trim().parse() {\n            Ok(num) => num,\n            Err(_) => continue,\n        };\n\n        if number < 0 {\n            break;\n        }\n    }\n}\n```"
  },
  {
    "task": "Write a function that doubles a number and repeats the process until the number is greater than 1000.",
    "code": "```rust\nfn double_until_greater_than_1000(mut num: i32) -> i32 {\n    while num <= 1000 {\n        num *= 2;\n    }\n    num\n}\n```"
  },
  {
    "task": "Develop a routine to keep printing 'Hello, World!' until a counter reaches 10.",
    "code": "```rust\nfn main() {\n    let mut counter = 0;\n    while counter < 10 {\n        println!(\"Hello, World!\");\n        counter += 1;\n    }\n}\n```"
  },
  {
    "task": "Construct a loop that checks if a randomly generated number is even, repeating until an odd number is found.",
    "code": "```rust\nuse rand::Rng;\n\nfn main() {\n    let mut rng = rand::thread_rng();\n    let mut number;\n\n    while {\n        number = rng.gen_range(0..100);\n        number % 2 == 0\n    } {}\n\n    println!(\"Found an odd number: {}\", number);\n}\n```"
  },
  {
    "task": "Design a countdown timer that prints each second until it reaches zero.",
    "code": "```rust\nuse std::{thread, time};\n\nfn countdown(mut seconds: u32) {\n    while seconds > 0 {\n        println!(\"{} seconds remaining\", seconds);\n        thread::sleep(time::Duration::from_secs(1));\n        seconds -= 1;\n    }\n    println!(\"Time's up!\");\n}\n\nfn main() {\n    countdown(10);\n}\n```"
  },
  {
    "task": "Implement a system where a user can keep adding items to a list until they type 'stop'.",
    "code": "```rust\nuse std::io::{self, Write};\n\nfn main() {\n    let mut items = Vec::new();\n    let mut input = String::new();\n\n    loop {\n        print!(\"Enter an item (or type 'stop' to finish): \");\n        io::stdout().flush().unwrap();\n        input.clear();\n        io::stdin().read_line(&mut input).expect(\"Failed to read line\");\n        let item = input.trim();\n\n        if item.eq_ignore_ascii_case(\"stop\") {\n            break;\n        }\n\n        items.push(item.to_string());\n    }\n\n    println!(\"Items entered: {:?}\", items);\n}\n```"
  },
  {
    "task": "Write a script that simulates rolling a die and continues until a six is rolled.",
    "code": "```rust\nuse rand::Rng;\n\nfn main() {\n    let mut rng = rand::thread_rng();\n    let mut roll = 0;\n\n    while roll != 6 {\n        roll = rng.gen_range(1..=6);\n        println!(\"Rolled: {}\", roll);\n    }\n}\n```"
  },
  {
    "task": "Create a program that asks for a password and keeps prompting until the correct password is entered.",
    "code": "```rust\nuse std::io::{self, Write};\n\nfn main() {\n    let correct_password = \"secret\";\n    let mut input = String::new();\n\n    while input.trim() != correct_password {\n        print!(\"Enter password: \");\n        io::stdout().flush().unwrap();\n        input.clear();\n        io::stdin().read_line(&mut input).unwrap();\n    }\n\n    println!(\"Access granted.\");\n}\n```"
  },
  {
    "task": "Design a loop that calculates the sum of entered numbers until the user enters zero.",
    "code": "```rust\nuse std::io;\n\nfn main() {\n    let mut sum = 0;\n    loop {\n        let mut input = String::new();\n        io::stdin().read_line(&mut input).expect(\"Failed to read line\");\n        let number: i32 = input.trim().parse().expect(\"Please enter a number\");\n        if number == 0 {\n            break;\n        }\n        sum += number;\n    }\n    println!(\"The sum is: {}\", sum);\n}\n```"
  },
  {
    "task": "Implement a feature that prints Fibonacci numbers until a number exceeds 100.",
    "code": "```rust\nfn main() {\n    let (mut a, mut b) = (0, 1);\n    while a <= 100 {\n        println!(\"{}\", a);\n        let temp = a;\n        a = b;\n        b = temp + b;\n    }\n}\n```"
  },
  {
    "task": "Develop a loop that keeps halving a number until it becomes less than one.",
    "code": "```rust\nfn main() {\n    let mut number = 100.0;\n    while number >= 1.0 {\n        number /= 2.0;\n    }\n    println!(\"Final number: {}\", number);\n}\n```"
  },
  {
    "task": "Write a program that asks for names and keeps storing them until the user enters 'done'.",
    "code": "```rust\nuse std::io;\n\nfn main() {\n    let mut names = Vec::new();\n    loop {\n        println!(\"Enter a name (or 'done' to finish):\");\n        let mut input = String::new();\n        io::stdin().read_line(&mut input).expect(\"Failed to read line\");\n        let input = input.trim();\n        if input.eq_ignore_ascii_case(\"done\") {\n            break;\n        }\n        names.push(input.to_string());\n    }\n    println!(\"Names entered: {:?}\", names);\n}\n```"
  },
  {
    "task": "Create a process that keeps flipping a coin, recording results until there have been five heads.",
    "code": "```rust\nfn main() {\n    let mut heads_count = 0;\n    let mut rng = rand::thread_rng();\n\n    while heads_count < 5 {\n        let flip: bool = rand::Rng::gen(&mut rng);\n        if flip {\n            heads_count += 1;\n            println!(\"Heads! Current count: {}\", heads_count);\n        } else {\n            println!(\"Tails!\");\n        }\n    }\n}\n```"
  },
  {
    "task": "Implement a countdown that decreases by two each time, starting from 20, until it reaches zero.",
    "code": "```rust\nfn main() {\n    let mut count = 20;\n    while count >= 0 {\n        println!(\"{}\", count);\n        count -= 2;\n    }\n}\n```"
  },
  {
    "task": "Design a solution that repeatedly asks for user input and repeats it back until they type 'exit'.",
    "code": "```rust\nuse std::io::{self, Write};\n\nfn main() {\n    let mut input = String::new();\n\n    loop {\n        print!(\"Enter something: \");\n        io::stdout().flush().unwrap(); // Ensure prompt is displayed\n\n        input.clear();\n        io::stdin().read_line(&mut input).unwrap();\n        let trimmed_input = input.trim();\n\n        if trimmed_input.eq_ignore_ascii_case(\"exit\") {\n            break;\n        }\n\n        println!(\"You entered: {}\", trimmed_input);\n    }\n}\n```"
  },
  {
    "task": "Develop a loop to simulate a bank account balance, repeatedly deducting a fee until the balance is below zero.",
    "code": "```rust\nfn main() {\n    let mut balance: f64 = 100.0; // Initial balance\n    let fee: f64 = 10.0; // Fee to be deducted\n\n    while balance >= 0.0 {\n        println!(\"Current balance: ${:.2}\", balance);\n        balance -= fee;\n    }\n\n    println!(\"Final balance: ${:.2}\", balance);\n}\n```"
  },
  {
    "task": "Create a sequence generator that multiplies a number by three each time until it reaches or exceeds 100.",
    "code": "```rust\nfn main() {\n    let mut number = 1;\n    while number < 100 {\n        println!(\"{}\", number);\n        number *= 3;\n    }\n}\n```"
  },
  {
    "task": "Write a program that keeps generating random numbers between 1 and 10 until it gets a five.",
    "code": "```rust\nuse rand::Rng;\n\nfn main() {\n    let mut rng = rand::thread_rng();\n    let mut number = rng.gen_range(1..=10);\n    \n    while number != 5 {\n        number = rng.gen_range(1..=10);\n    }\n}\n```"
  },
  {
    "task": "Implement a system to keep checking the temperature and only stop when it falls below freezing.",
    "code": "```rust\nfn main() {\n    let mut temperature = 10; // Example initial temperature\n\n    while temperature >= 0 {\n        println!(\"Current temperature: {}\u00b0C\", temperature);\n        \n        // Simulate temperature change\n        temperature -= 1;\n    }\n\n    println!(\"Temperature has fallen below freezing.\");\n}\n```"
  },
  {
    "task": "Construct a quiz game that continues asking questions until the player answers incorrectly.",
    "code": "```rust\nuse std::io;\n\nfn main() {\n    let questions = vec![\n        (\"What is the capital of France?\", \"Paris\"),\n        (\"What is 2 + 2?\", \"4\"),\n        (\"What is the capital of Italy?\", \"Rome\"),\n    ];\n\n    let mut index = 0;\n    let mut correct = true;\n    let mut input = String::new();\n\n    while correct && index < questions.len() {\n        println!(\"{}\", questions[index].0);\n        \n        input.clear();\n        io::stdin().read_line(&mut input).expect(\"Failed to read line\");\n        let answer = input.trim();\n\n        if answer.eq_ignore_ascii_case(questions[index].1) {\n            println!(\"Correct!\\n\");\n        } else {\n            println!(\"Incorrect! Game over.\\n\");\n            correct = false;\n        }\n\n        index += 1;\n    }\n}\n```"
  },
  {
    "task": "Write a function that calculates factorials of a number, repeating the process for numbers 1 through 5.",
    "code": "```rust\nfn factorial(n: u32) -> u32 {\n    let mut result = 1;\n    let mut i = 1;\n    while i <= n {\n        result *= i;\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let mut num = 1;\n    while num <= 5 {\n        println!(\"Factorial of {} is {}\", num, factorial(num));\n        num += 1;\n    }\n}\n```"
  },
  {
    "task": "Create a loop that prints all even numbers between 1 and 50.",
    "code": "```rust\nfn main() {\n    let mut number = 2;\n    while number <= 50 {\n        println!(\"{}\", number);\n        number += 2;\n    }\n}\n```"
  },
  {
    "task": "Design a program that continuously asks for user input until a palindrome is entered.",
    "code": "```rust\nuse std::io::{self, Write};\n\nfn main() {\n    loop {\n        print!(\"Enter a string: \");\n        io::stdout().flush().unwrap();\n\n        let mut input = String::new();\n        io::stdin().read_line(&mut input).unwrap();\n        let input = input.trim();\n\n        if is_palindrome(input) {\n            println!(\"You entered a palindrome!\");\n            break;\n        } else {\n            println!(\"Not a palindrome, try again!\");\n        }\n    }\n}\n\nfn is_palindrome(s: &str) -> bool {\n    let reversed: String = s.chars().rev().collect();\n    s == reversed\n}\n```"
  },
  {
    "task": "Implement a countdown that decreases by one each second, starting from 100.",
    "code": "```rust\nuse std::{thread, time};\n\nfn main() {\n    let mut count = 100;\n    while count > 0 {\n        println!(\"{}\", count);\n        count -= 1;\n        thread::sleep(time::Duration::from_secs(1));\n    }\n}\n```"
  },
  {
    "task": "Write a script that repeatedly asks for a number and adds it to a total until the total exceeds 500.",
    "code": "```rust\nuse std::io;\n\nfn main() {\n    let mut total = 0;\n\n    while total <= 500 {\n        let mut input = String::new();\n        println!(\"Enter a number:\");\n        \n        io::stdin().read_line(&mut input).expect(\"Failed to read line\");\n        \n        if let Ok(number) = input.trim().parse::<i32>() {\n            total += number;\n        } else {\n            println!(\"Please enter a valid number\");\n        }\n    }\n    \n    println!(\"Total exceeded 500: {}\", total);\n}\n```"
  },
  {
    "task": "Create a loop that generates random letters until the letter 'Z' appears.",
    "code": "```rust\nuse rand::Rng;\n\nfn main() {\n    let mut rng = rand::thread_rng();\n    let mut ch = 'A';\n\n    while ch != 'Z' {\n        ch = rng.gen_range(b'A'..=b'Z') as char;\n        println!(\"{}\", ch);\n    }\n}\n```"
  },
  {
    "task": "Write a process that continues prompting for two numbers and prints their sum if it's even.",
    "code": "```rust\nuse std::io;\n\nfn main() {\n    let mut input = String::new();\n\n    loop {\n        input.clear();\n        println!(\"Enter the first number:\");\n        io::stdin().read_line(&mut input).expect(\"Failed to read line\");\n        let num1: i32 = match input.trim().parse() {\n            Ok(num) => num,\n            Err(_) => continue,\n        };\n\n        input.clear();\n        println!(\"Enter the second number:\");\n        io::stdin().read_line(&mut input).expect(\"Failed to read line\");\n        let num2: i32 = match input.trim().parse() {\n            Ok(num) => num,\n            Err(_) => continue,\n        };\n\n        let sum = num1 + num2;\n        if sum % 2 == 0 {\n            println!(\"The sum is even: {}\", sum);\n        }\n    }\n}\n```"
  },
  {
    "task": "Develop a loop that simulates a traffic light sequence until a manual stop command is received.",
    "code": "```rust\nuse std::io::{self, Write};\n\nfn main() {\n    let mut input = String::new();\n    while input.trim() != \"stop\" {\n        println!(\"Red\");\n        std::thread::sleep(std::time::Duration::from_secs(5));\n\n        println!(\"Green\");\n        std::thread::sleep(std::time::Duration::from_secs(5));\n\n        println!(\"Yellow\");\n        std::thread::sleep(std::time::Duration::from_secs(2));\n\n        print!(\"Type 'stop' to end the simulation: \");\n        io::stdout().flush().unwrap();\n        input.clear();\n        io::stdin().read_line(&mut input).expect(\"Failed to read line\");\n    }\n}\n```"
  },
  {
    "task": "Implement a feature that keeps printing numbers in reverse order starting from 10.",
    "code": "```rust\nfn main() {\n    let mut number = 10;\n    while number >= 1 {\n        println!(\"{}\", number);\n        number -= 1;\n    }\n}\n```"
  },
  {
    "task": "Create a program that rolls two dice and continues until the sum is exactly seven.",
    "code": "```rust\nuse rand::Rng;\n\nfn main() {\n    let mut rng = rand::thread_rng();\n    let mut sum = 0;\n\n    while sum != 7 {\n        let die1 = rng.gen_range(1..=6);\n        let die2 = rng.gen_range(1..=6);\n        sum = die1 + die2;\n        println!(\"Rolled: {} + {} = {}\", die1, die2, sum);\n    }\n}\n```"
  },
  {
    "task": "Design a loop that keeps asking for ages and prints the average once a negative age is entered.",
    "code": "```rust\nuse std::io;\n\nfn main() {\n    let mut sum = 0;\n    let mut count = 0;\n\n    loop {\n        println!(\"Enter age:\");\n\n        let mut input = String::new();\n        io::stdin().read_line(&mut input).expect(\"Failed to read line\");\n        let age: i32 = match input.trim().parse() {\n            Ok(num) => num,\n            Err(_) => continue,\n        };\n\n        if age < 0 {\n            break;\n        }\n\n        sum += age;\n        count += 1;\n    }\n\n    if count > 0 {\n        let average = sum as f64 / count as f64;\n        println!(\"The average age is: {:.2}\", average);\n    } else {\n        println!(\"No ages were entered.\");\n    }\n}\n```"
  },
  {
    "task": "Write a routine that squares numbers starting from 1 until the square is greater than 500.",
    "code": "```rust\nfn main() {\n    let mut num = 1;\n    while num * num <= 500 {\n        println!(\"{}\", num * num);\n        num += 1;\n    }\n}\n```"
  },
  {
    "task": "Implement a system to ask for a string and append it to a file until 'end' is typed.",
    "code": "```rust\nuse std::fs::OpenOptions;\nuse std::io::{self, Write};\n\nfn main() {\n    let mut input = String::new();\n    let mut file = OpenOptions::new()\n        .append(true)\n        .create(true)\n        .open(\"output.txt\")\n        .expect(\"Unable to open file\");\n\n    while input.trim() != \"end\" {\n        input.clear();\n        println!(\"Enter a string to append to the file (type 'end' to finish):\");\n        io::stdin().read_line(&mut input).expect(\"Failed to read line\");\n        \n        if input.trim() != \"end\" {\n            writeln!(file, \"{}\", input.trim()).expect(\"Failed to write to file\");\n        }\n    }\n}\n```"
  },
  {
    "task": "Create a script that checks if a number is prime, repeating for each number entered by the user.",
    "code": "```rust\nuse std::io;\n\nfn is_prime(n: u32) -> bool {\n    if n <= 1 {\n        return false;\n    }\n    let mut i = 2;\n    while i * i <= n {\n        if n % i == 0 {\n            return false;\n        }\n        i += 1;\n    }\n    true\n}\n\nfn main() {\n    let mut input = String::new();\n    let stdin = io::stdin();\n    loop {\n        input.clear();\n        println!(\"Enter a number (or type 'exit' to quit):\");\n        stdin.read_line(&mut input).expect(\"Failed to read line\");\n        let input = input.trim();\n        if input.eq_ignore_ascii_case(\"exit\") {\n            break;\n        }\n        match input.parse::<u32>() {\n            Ok(number) => {\n                if is_prime(number) {\n                    println!(\"{} is a prime number.\", number);\n                } else {\n                    println!(\"{} is not a prime number.\", number);\n                }\n            }\n            Err(_) => println!(\"Please enter a valid number.\"),\n        }\n    }\n}\n```"
  },
  {
    "task": "Develop a countdown that prints numbers starting from 50 down to 1.",
    "code": "```rust\nfn main() {\n    let mut number = 50;\n    while number > 0 {\n        println!(\"{}\", number);\n        number -= 1;\n    }\n}\n```"
  },
  {
    "task": "Write a program that keeps doubling the value of a variable until it exceeds 200.",
    "code": "```rust\nfn main() {\n    let mut value = 1;\n    while value <= 200 {\n        value *= 2;\n    }\n    println!(\"Final value: {}\", value);\n}\n```"
  },
  {
    "task": "Design a loop that keeps generating a random string of letters until a specific word is formed.",
    "code": "```rust\nuse rand::Rng;\n\nfn main() {\n    let target = \"rustacean\";\n    let mut rng = rand::thread_rng();\n    let letters = b\"abcdefghijklmnopqrstuvwxyz\";\n    let mut result = String::new();\n\n    while result != target {\n        result.clear();\n        for _ in 0..target.len() {\n            let idx = rng.gen_range(0..letters.len());\n            result.push(letters[idx] as char);\n        }\n        println!(\"{}\", result);\n    }\n    println!(\"Target word formed: {}\", result);\n}\n```"
  },
  {
    "task": "Implement a system that continuously fetches data from a sensor until a threshold is crossed.",
    "code": "```rust\nfn main() {\n    let mut sensor_value = 0;\n    let threshold = 100;\n\n    while sensor_value <= threshold {\n        sensor_value = fetch_sensor_data();\n        println!(\"Current sensor value: {}\", sensor_value);\n    }\n\n    println!(\"Threshold crossed with sensor value: {}\", sensor_value);\n}\n\nfn fetch_sensor_data() -> i32 {\n    // Simulate fetching data from a sensor\n    // In a real-world scenario, replace this with actual sensor data fetching logic\n    10 // Example fixed value increment\n}\n```"
  },
  {
    "task": "Create a game where a player guesses a number, and the game continues until the player guesses correctly.",
    "code": "```rust\nuse std::io;\nuse rand::Rng;\n\nfn main() {\n    let secret_number = rand::thread_rng().gen_range(1..101);\n    let mut guess = String::new();\n\n    while guess.trim().parse::<u32>().unwrap_or(0) != secret_number {\n        println!(\"Guess the number:\");\n        guess.clear();\n        io::stdin().read_line(&mut guess).expect(\"Failed to read line\");\n        \n        match guess.trim().parse::<u32>() {\n            Ok(num) if num == secret_number => println!(\"You guessed correctly!\"),\n            Ok(num) => println!(\"Try again!\"),\n            Err(_) => println!(\"Please enter a valid number!\"),\n        }\n    }\n}\n```"
  },
  {
    "task": "Write a loop that continues to add random numbers to a list until the list has 10 even numbers.",
    "code": "```rust\nuse rand::Rng;\n\nfn main() {\n    let mut rng = rand::thread_rng();\n    let mut evens = Vec::new();\n\n    while evens.len() < 10 {\n        let num = rng.gen_range(0..100);\n        if num % 2 == 0 {\n            evens.push(num);\n        }\n    }\n\n    println!(\"{:?}\", evens);\n}\n```"
  },
  {
    "task": "Design a routine that keeps removing elements from a list until it is empty.",
    "code": "```rust\nfn remove_elements_until_empty(mut list: Vec<i32>) {\n    while !list.is_empty() {\n        list.pop();\n    }\n}\n```"
  },
  {
    "task": "Implement a sequence that prints the alphabet repeatedly until interrupted by the user.",
    "code": "```rust\nfn main() {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n    while !std::process::Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(\"read -t 0.1 -n 1\")\n        .status()\n        .unwrap()\n        .success()\n    {\n        for c in alphabet.chars() {\n            print!(\"{}\", c);\n        }\n    }\n}\n```"
  },
  {
    "task": "Create a program that continuously checks for updates and stops once an update is available.",
    "code": "```rust\nfn main() {\n    let mut update_available = false;\n\n    while !update_available {\n        update_available = check_for_updates();\n    }\n\n    println!(\"Update available!\");\n}\n\nfn check_for_updates() -> bool {\n    // Simulate checking for updates\n    // Replace with actual update checking logic\n    // Returning true to simulate an update being found\n    true\n}\n```"
  },
  {
    "task": "Write a function that keeps dividing a number by two until it results in a fractional value.",
    "code": "```rust\nfn divide_until_fractional(mut number: f64) -> f64 {\n    while number.fract() == 0.0 {\n        number /= 2.0;\n    }\n    number\n}\n```"
  },
  {
    "task": "Develop a loop that keeps asking for student's grades and calculates the average until a grade of -1 is entered.",
    "code": "```rust\nuse std::io;\n\nfn main() {\n    let mut sum = 0.0;\n    let mut count = 0;\n\n    loop {\n        println!(\"Enter a student's grade (or -1 to finish): \");\n        \n        let mut input = String::new();\n        io::stdin().read_line(&mut input).expect(\"Failed to read line\");\n        \n        let grade: f64 = match input.trim().parse() {\n            Ok(num) => num,\n            Err(_) => continue,\n        };\n\n        if grade == -1.0 {\n            break;\n        }\n\n        sum += grade;\n        count += 1;\n    }\n\n    if count > 0 {\n        let average = sum / count as f64;\n        println!(\"The average grade is: {:.2}\", average);\n    } else {\n        println!(\"No grades were entered.\");\n    }\n}\n```"
  },
  {
    "task": "Design a feature that continuously monitors a file for changes and stops when no changes are detected for a minute.",
    "code": "```rust\nuse std::fs;\nuse std::time::{Duration, Instant};\nuse std::thread;\n\nfn monitor_file(file_path: &str) {\n    let mut last_modified = fs::metadata(file_path).unwrap().modified().unwrap();\n    let mut no_change_duration = Duration::new(0, 0);\n\n    while no_change_duration < Duration::from_secs(60) {\n        thread::sleep(Duration::from_secs(1));\n\n        let current_modified = fs::metadata(file_path).unwrap().modified().unwrap();\n        if current_modified != last_modified {\n            last_modified = current_modified;\n            no_change_duration = Duration::new(0, 0);\n        } else {\n            no_change_duration += Duration::from_secs(1);\n        }\n    }\n}\n\nfn main() {\n    let file_path = \"path/to/your/file.txt\";\n    monitor_file(file_path);\n}\n```"
  },
  {
    "task": "Implement a process where a motor runs until a certain distance is reached.",
    "code": "```rust\nfn main() {\n    let target_distance = 100; // Example target distance\n    let mut current_distance = 0;\n\n    while current_distance < target_distance {\n        // Simulate motor running and increasing distance\n        current_distance += 10; // Example increment\n        println!(\"Current distance: {}\", current_distance);\n    }\n\n    println!(\"Target distance reached.\");\n}\n```"
  },
  {
    "task": "Create a script that keeps generating random numbers and stops when it generates a prime number.",
    "code": "```rust\nuse rand::Rng;\n\nfn is_prime(n: u32) -> bool {\n    if n <= 1 {\n        return false;\n    }\n    if n <= 3 {\n        return true;\n    }\n    if n % 2 == 0 || n % 3 == 0 {\n        return false;\n    }\n    let mut i = 5;\n    while i * i <= n {\n        if n % i == 0 || n % (i + 2) == 0 {\n            return false;\n        }\n        i += 6;\n    }\n    true\n}\n\nfn main() {\n    let mut rng = rand::thread_rng();\n    let mut number = 0;\n\n    while !is_prime(number) {\n        number = rng.gen_range(1..u32::MAX);\n        println!(\"Generated: {}\", number);\n    }\n\n    println!(\"Prime number found: {}\", number);\n}\n```"
  },
  {
    "task": "Write a program that asks for the user's favorite color and keeps asking until they say 'blue'.",
    "code": "```rust\nuse std::io::{self, Write};\n\nfn main() {\n    let mut input = String::new();\n\n    while input.trim() != \"blue\" {\n        print!(\"What is your favorite color? \");\n        io::stdout().flush().unwrap();\n        input.clear();\n        io::stdin().read_line(&mut input).unwrap();\n    }\n}\n```"
  },
  {
    "task": "Develop a loop that continuously prints the time every second until a key is pressed.",
    "code": "```rust\nuse std::io;\nuse std::io::Read;\nuse std::thread::sleep;\nuse std::time::{Duration, SystemTime};\n\nfn main() {\n    let stdin = io::stdin();\n    let mut handle = stdin.lock();\n\n    loop {\n        let now = SystemTime::now();\n        match now.duration_since(SystemTime::UNIX_EPOCH) {\n            Ok(n) => println!(\"Current time: {:?}\", n),\n            Err(_) => eprintln!(\"SystemTime before UNIX EPOCH!\"),\n        }\n\n        sleep(Duration::from_secs(1));\n\n        if handle.bytes().next().is_some() {\n            break;\n        }\n    }\n}\n```"
  },
  {
    "task": "Create a system to keep downloading data from a server until the connection is lost.",
    "code": "```rust\nuse std::io::{self, Read};\nuse std::net::TcpStream;\n\nfn main() {\n    let mut buffer = [0; 512];\n    let mut stream = TcpStream::connect(\"example.com:80\").expect(\"Could not connect to server\");\n\n    while let Ok(_) = stream.read(&mut buffer) {\n        // Process the data here\n    }\n\n    println!(\"Connection lost.\");\n}\n```"
  },
  {
    "task": "Write a process to keep a light on until the ambient light level is sufficient.",
    "code": "```rust\nfn main() {\n    let mut light_on = true;\n    while light_on {\n        let ambient_light_level = get_ambient_light_level();\n        if ambient_light_level > SUFFICIENT_LIGHT_LEVEL {\n            light_on = false;\n        } else {\n            keep_light_on();\n        }\n    }\n}\n\nfn get_ambient_light_level() -> u32 {\n    // Placeholder for actual ambient light level reading\n    0\n}\n\nfn keep_light_on() {\n    // Placeholder for actual process to keep light on\n}\n\nconst SUFFICIENT_LIGHT_LEVEL: u32 = 100;\n```"
  },
  {
    "task": "Implement a feature that continuously plays a sound until the user presses a button.",
    "code": "```rust\nuse std::io;\nuse std::thread;\nuse std::time::Duration;\n\nfn play_sound() {\n    // Placeholder for sound playing logic\n    println!(\"Playing sound...\");\n}\n\nfn main() {\n    println!(\"Press Enter to stop the sound.\");\n    \n    let mut input = String::new();\n    let mut playing = true;\n\n    while playing {\n        play_sound();\n        thread::sleep(Duration::from_secs(1));\n\n        if io::stdin().read_line(&mut input).is_ok() {\n            playing = false;\n        }\n    }\n\n    println!(\"Sound stopped.\");\n}\n```"
  },
  {
    "task": "Design a program that keeps multiplying a matrix by itself until its determinant is greater than 1000.",
    "code": "```rust\nextern crate nalgebra as na;\n\nuse na::{DMatrix, Matrix3};\n\nfn main() {\n    let mut matrix = DMatrix::from_row_slice(3, 3, &[1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0]);\n    while matrix.determinant() <= 1000.0 {\n        matrix = &matrix * &matrix;\n    }\n}\n```"
  },
  {
    "task": "Create a script that keeps prompting the user to guess a word until they get it right.",
    "code": "```rust\nuse std::io::{self, Write};\n\nfn main() {\n    let secret_word = \"rustacean\";\n    let mut guessed = false;\n\n    while !guessed {\n        print!(\"Guess the word: \");\n        io::stdout().flush().unwrap();\n\n        let mut input = String::new();\n        io::stdin().read_line(&mut input).unwrap();\n        let input = input.trim();\n\n        if input == secret_word {\n            println!(\"Congratulations, you guessed the word!\");\n            guessed = true;\n        } else {\n            println!(\"Try again!\");\n        }\n    }\n}\n```"
  },
  {
    "task": "Write a loop that simulates a car's fuel consumption and stops when the tank is empty.",
    "code": "```rust\nfn main() {\n    let mut fuel = 50; // Initial fuel level\n\n    while fuel > 0 {\n        println!(\"Driving... Fuel level: {}\", fuel);\n        fuel -= 5; // Consume fuel\n    }\n\n    println!(\"Tank is empty. Stopping the car.\");\n}\n```"
  },
  {
    "task": "Develop a routine that keeps checking if a file exists and stops once it does.",
    "code": "```rust\nuse std::path::Path;\nuse std::thread::sleep;\nuse std::time::Duration;\n\nfn main() {\n    let file_path = \"your_file.txt\";\n    \n    while !Path::new(file_path).exists() {\n        sleep(Duration::from_secs(1));\n    }\n    \n    println!(\"File found!\");\n}\n```"
  },
  {
    "task": "Implement a feature that continuously calculates the square root of a number until it's less than 0.1.",
    "code": "```rust\nfn main() {\n    let mut num = 256.0;\n    \n    while num >= 0.1 {\n        num = num.sqrt();\n        println!(\"{}\", num);\n    }\n}\n```"
  },
  {
    "task": "Create a system that prints 'Processing...' every second until a task is complete.",
    "code": "```rust\nuse std::{thread, time::Duration};\n\nfn main() {\n    let mut task_complete = false;\n\n    while !task_complete {\n        println!(\"Processing...\");\n        thread::sleep(Duration::from_secs(1));\n\n        // Example condition to stop the loop, replace with actual task logic\n        task_complete = check_task_complete();\n    }\n}\n\nfn check_task_complete() -> bool {\n    // Placeholder for task completion logic\n    false\n}\n```"
  },
  {
    "task": "Write a loop that repeatedly checks the status of a process until it reports 'complete'.",
    "code": "```rust\nfn main() {\n    let mut status = String::from(\"incomplete\");\n\n    while status != \"complete\" {\n        // Simulate checking the status\n        status = check_process_status();\n    }\n}\n\nfn check_process_status() -> String {\n    // This is just a placeholder for the actual status-checking logic\n    // Assume the status becomes \"complete\" after some condition is met\n    String::from(\"complete\")\n}\n```"
  },
  {
    "task": "Design a routine to keep pinging a server and alert when the connection is lost.",
    "code": "```rust\nuse std::net::TcpStream;\nuse std::thread::sleep;\nuse std::time::Duration;\n\nfn main() {\n    let server_address = \"127.0.0.1:80\"; // Replace with actual server address\n\n    while ping_server(server_address) {\n        sleep(Duration::from_secs(5)); // Wait for 5 seconds before the next ping\n    }\n\n    alert_connection_lost();\n}\n\nfn ping_server(address: &str) -> bool {\n    TcpStream::connect(address).is_ok()\n}\n\nfn alert_connection_lost() {\n    println!(\"Alert: Connection to server lost!\");\n}\n```"
  },
  {
    "task": "Implement a loop that counts down from 100 by fives until it reaches zero.",
    "code": "```rust\nfn main() {\n    let mut count = 100;\n    while count >= 0 {\n        println!(\"{}\", count);\n        count -= 5;\n    }\n}\n```"
  },
  {
    "task": "Create a script that keeps track of inventory items being added or removed until an end signal is given.",
    "code": "```rust\nuse std::io;\n\nfn main() {\n    let mut inventory = 0;\n    let mut input = String::new();\n\n    println!(\"Enter 'add' to increase inventory, 'remove' to decrease, or 'end' to stop:\");\n\n    loop {\n        input.clear();\n        io::stdin().read_line(&mut input).expect(\"Failed to read line\");\n        let command = input.trim();\n\n        match command {\n            \"add\" => {\n                inventory += 1;\n                println!(\"Item added. Current inventory: {}\", inventory);\n            }\n            \"remove\" => {\n                if inventory > 0 {\n                    inventory -= 1;\n                    println!(\"Item removed. Current inventory: {}\", inventory);\n                } else {\n                    println!(\"No items to remove. Current inventory: {}\", inventory);\n                }\n            }\n            \"end\" => {\n                println!(\"Ending the inventory update. Final inventory: {}\", inventory);\n                break;\n            }\n            _ => {\n                println!(\"Invalid command. Please enter 'add', 'remove', or 'end'.\");\n            }\n        }\n    }\n}\n```"
  },
  {
    "task": "Write a program that keeps calculating the power of two for numbers until a result is greater than 1000.",
    "code": "```rust\nfn main() {\n    let mut num = 1;\n    let mut power_of_two = 1;\n\n    while power_of_two <= 1000 {\n        power_of_two = 2_i32.pow(num);\n        println!(\"2^{} = {}\", num, power_of_two);\n        num += 1;\n    }\n}\n```"
  },
  {
    "task": "Develop a sequence that keeps appending random numbers to an array until its length is 20.",
    "code": "```rust\nuse rand::Rng;\n\nfn main() {\n    let mut rng = rand::thread_rng();\n    let mut numbers = Vec::new();\n    \n    while numbers.len() < 20 {\n        let num: i32 = rng.gen();\n        numbers.push(num);\n    }\n}\n```"
  },
  {
    "task": "Implement a routine that continuously rotates an image until it matches a reference orientation.",
    "code": "```rust\nfn rotate_image(mut image: Vec<Vec<u8>>, reference: Vec<Vec<u8>>) -> Vec<Vec<u8>> {\n    while image != reference {\n        image = rotate_90_degrees(image);\n    }\n    image\n}\n\nfn rotate_90_degrees(image: Vec<Vec<u8>>) -> Vec<Vec<u8>> {\n    let rows = image.len();\n    let cols = image[0].len();\n    let mut rotated = vec![vec![0; rows]; cols];\n    \n    for r in 0..rows {\n        for c in 0..cols {\n            rotated[c][rows - r - 1] = image[r][c];\n        }\n    }\n    rotated\n}\n\nfn main() {\n    let image = vec![\n        vec![1, 2, 3],\n        vec![4, 5, 6],\n        vec![7, 8, 9],\n    ];\n    let reference = vec![\n        vec![7, 4, 1],\n        vec![8, 5, 2],\n        vec![9, 6, 3],\n    ];\n    \n    let result = rotate_image(image, reference);\n    for row in result {\n        println!(\"{:?}\", row);\n    }\n}\n```"
  },
  {
    "task": "Design a loop that keeps printing random jokes until the user stops it.",
    "code": "```rust\nuse std::io;\nuse rand::Rng;\n\nfn main() {\n    let jokes = [\n        \"Why don't scientists trust atoms? Because they make up everything!\",\n        \"What do you get if you cross a cat with a dark horse? Kitty Perry!\",\n        \"Why was the math book sad? Because it had too many problems.\",\n        \"Why don't programmers like nature? It has too many bugs.\",\n        \"What do you call fake spaghetti? An impasta!\"\n    ];\n\n    let mut rng = rand::thread_rng();\n    let mut input = String::new();\n\n    while input.trim().to_lowercase() != \"stop\" {\n        let joke = jokes[rng.gen_range(0..jokes.len())];\n        println!(\"{}\", joke);\n        println!(\"Type 'stop' to stop or press Enter to get another joke:\");\n        input.clear();\n        io::stdin().read_line(&mut input).expect(\"Failed to read line\");\n    }\n}\n```"
  },
  {
    "task": "Create a program that accepts user feedback and continues until a positive feedback is received.",
    "code": "```rust\nuse std::io;\n\nfn main() {\n    let mut feedback = String::new();\n    let positive_feedbacks = [\"good\", \"great\", \"excellent\", \"positive\", \"awesome\"];\n\n    while !positive_feedbacks.contains(&feedback.trim()) {\n        println!(\"Please enter your feedback:\");\n        feedback.clear();\n        io::stdin().read_line(&mut feedback).expect(\"Failed to read line\");\n    }\n\n    println!(\"Thank you for your positive feedback!\");\n}\n```"
  },
  {
    "task": "Write a loop that repeatedly reads sensor data and stops when a stable reading is observed.",
    "code": "```rust\nfn main() {\n    let mut last_reading = None;\n    let mut stable = false;\n\n    while !stable {\n        let current_reading = read_sensor_data();\n        \n        if let Some(last) = last_reading {\n            stable = current_reading == last;\n        }\n        \n        last_reading = Some(current_reading);\n    }\n}\n\nfn read_sensor_data() -> i32 {\n    // Placeholder for actual sensor data reading logic\n    42\n}\n```"
  },
  {
    "task": "Develop a system that simulates a stopwatch, counting seconds until stopped manually.",
    "code": "```rust\nuse std::io;\nuse std::thread;\nuse std::time::{Duration, Instant};\n\nfn main() {\n    let mut input = String::new();\n    let mut seconds = 0;\n\n    println!(\"Press Enter to stop the stopwatch.\");\n\n    let handle = thread::spawn(move || {\n        let start = Instant::now();\n        while input.is_empty() {\n            thread::sleep(Duration::from_secs(1));\n            seconds = start.elapsed().as_secs();\n            println!(\"Elapsed seconds: {}\", seconds);\n        }\n    });\n\n    io::stdin().read_line(&mut input).unwrap();\n    handle.join().unwrap();\n}\n```"
  },
  {
    "task": "Create a script that continues adding random integers to a sum until the sum exceeds 100.",
    "code": "```rust\nuse rand::Rng;\n\nfn main() {\n    let mut sum = 0;\n    let mut rng = rand::thread_rng();\n\n    while sum <= 100 {\n        let random_number: i32 = rng.gen_range(1..=10); // Random number between 1 and 10\n        sum += random_number;\n    }\n\n    println!(\"The sum is: {}\", sum);\n}\n```"
  },
  {
    "task": "Implement a process to track a moving object until it stops.",
    "code": "```rust\nfn main() {\n    let mut position = 0;\n    let mut velocity = 10; // Initial velocity, adjust as necessary\n\n    while velocity != 0 {\n        position += velocity;\n        velocity -= 1; // Simulate deceleration until the object stops\n    }\n\n    println!(\"Object stopped at position: {}\", position);\n}\n```"
  },
  {
    "task": "Design a routine to keep checking user login attempts until a successful login occurs.",
    "code": "```rust\nuse std::io;\n\nfn main() {\n    let correct_username = \"admin\";\n    let correct_password = \"password\";\n\n    let mut username = String::new();\n    let mut password = String::new();\n\n    let stdin = io::stdin();\n\n    loop {\n        println!(\"Enter username:\");\n        username.clear();\n        stdin.read_line(&mut username).expect(\"Failed to read line\");\n        let username = username.trim();\n\n        println!(\"Enter password:\");\n        password.clear();\n        stdin.read_line(&mut password).expect(\"Failed to read line\");\n        let password = password.trim();\n\n        if username == correct_username && password == correct_password {\n            println!(\"Login successful!\");\n            break;\n        } else {\n            println!(\"Incorrect username or password. Please try again.\");\n        }\n    }\n}\n```"
  },
  {
    "task": "Write a loop that repeatedly calculates the area of a circle for radii from 1 to 10.",
    "code": "```rust\nfn main() {\n    let mut radius = 1;\n    while radius <= 10 {\n        let area = std::f64::consts::PI * (radius as f64).powi(2);\n        println!(\"Radius: {}, Area: {:.2}\", radius, area);\n        radius += 1;\n    }\n}\n```"
  },
  {
    "task": "Create a program that continues flipping a card from a deck until an ace is drawn.",
    "code": "```rust\nuse rand::seq::SliceRandom;\nuse rand::thread_rng;\n\nfn main() {\n    let mut deck = vec![\n        \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\",\n        \"Jack\", \"Queen\", \"King\", \"Ace\"\n    ];\n\n    let mut rng = thread_rng();\n    let mut drawn_card = \"\";\n\n    while drawn_card != \"Ace\" {\n        drawn_card = deck.choose(&mut rng).unwrap();\n        println!(\"Drawn card: {}\", drawn_card);\n    }\n\n    println!(\"An Ace was drawn!\");\n}\n```"
  },
  {
    "task": "Develop a loop that keeps asking for a word and stores it until a word with more than five letters is entered.",
    "code": "```rust\nuse std::io::{self, Write};\n\nfn main() {\n    let mut words = Vec::new();\n    loop {\n        print!(\"Enter a word: \");\n        io::stdout().flush().unwrap();\n        let mut word = String::new();\n        io::stdin().read_line(&mut word).unwrap();\n        let word = word.trim().to_string();\n        words.push(word.clone());\n        if word.len() > 5 {\n            break;\n        }\n    }\n}\n```"
  },
  {
    "task": "Implement a feature that continuously calculates the exponential growth of a population until it doubles.",
    "code": "```rust\nfn main() {\n    let mut population = 100.0;\n    let growth_rate = 0.05;\n    let mut time = 0;\n\n    while population < 200.0 {\n        population *= 1.0 + growth_rate;\n        time += 1;\n    }\n\n    println!(\"Time taken for population to double: {} units\", time);\n}\n```"
  },
  {
    "task": "Write a script that repeats a string a certain number of times until a limit is reached.",
    "code": "```rust\nfn main() {\n    let mut count = 0;\n    let limit = 5;\n    let string_to_repeat = \"Hello\";\n\n    while count < limit {\n        println!(\"{}\", string_to_repeat);\n        count += 1;\n    }\n}\n```"
  },
  {
    "task": "Create a routine that keeps accessing an API endpoint until it returns a specific result.",
    "code": "```rust\nuse reqwest::Error;\n\nasync fn fetch_until_target(url: &str, target: &str) -> Result<(), Error> {\n    let client = reqwest::Client::new();\n\n    loop {\n        let response = client.get(url).send().await?;\n        let body = response.text().await?;\n\n        if body.contains(target) {\n            break;\n        }\n    }\n\n    Ok(())\n}\n\n#[tokio::main]\nasync fn main() {\n    let url = \"https://example.com/api/endpoint\";\n    let target = \"desired_result\";\n\n    if let Err(e) = fetch_until_target(url, target).await {\n        eprintln!(\"Error accessing API: {:?}\", e);\n    }\n}\n```"
  },
  {
    "task": "Design a loop that continues to fetch stock prices until a certain price threshold is crossed.",
    "code": "```rust\nfn fetch_stock_price() -> f64 {\n    // Placeholder function to mimic fetching stock prices\n    // Replace this with actual logic to fetch the stock price\n    100.0\n}\n\nfn main() {\n    let price_threshold = 150.0;\n    let mut current_price = fetch_stock_price();\n    \n    while current_price < price_threshold {\n        println!(\"Current stock price: {}\", current_price);\n        current_price = fetch_stock_price();\n    }\n    \n    println!(\"Price threshold crossed. Current stock price: {}\", current_price);\n}\n```"
  },
  {
    "task": "Implement a process that keeps monitoring CPU usage until it drops below 10%.",
    "code": "```rust\nuse sysinfo::{System, SystemExt, ProcessorExt};\n\nfn main() {\n    let mut sys = System::new_all();\n    \n    loop {\n        sys.refresh_all();\n        let cpu_usage = sys.global_processor_info().cpu_usage();\n        \n        if cpu_usage < 10.0 {\n            break;\n        }\n    }\n}\n```"
  },
  {
    "task": "Write a program that asks for a series of numbers and prints the largest once a negative number is entered.",
    "code": "```rust\nuse std::io;\n\nfn main() {\n    let mut largest = i32::MIN;\n\n    loop {\n        println!(\"Enter a number:\");\n\n        let mut input = String::new();\n        io::stdin().read_line(&mut input).expect(\"Failed to read line\");\n\n        let number: i32 = match input.trim().parse() {\n            Ok(num) => num,\n            Err(_) => continue,\n        };\n\n        if number < 0 {\n            break;\n        }\n\n        if number > largest {\n            largest = number;\n        }\n    }\n\n    println!(\"The largest number entered is: {}\", largest);\n}\n```"
  },
  {
    "task": "Develop a system that keeps a heater on until the room reaches a desired temperature.",
    "code": "```rust\nfn main() {\n    let desired_temperature = 22.0;\n    let mut current_temperature = 18.0;\n\n    while current_temperature < desired_temperature {\n        println!(\"Heater is ON. Current temperature: {}\", current_temperature);\n        current_temperature += 0.5; // Simulate the temperature rising\n    }\n\n    println!(\"Desired temperature reached. Heater is OFF. Current temperature: {}\", current_temperature);\n}\n```"
  },
  {
    "task": "Create a loop that repeatedly checks if a door is open and alerts if it remains open for too long.",
    "code": "```rust\nfn main() {\n    let mut is_door_open = true;\n    let mut open_duration = 0;\n    let alert_threshold = 5;\n\n    while is_door_open {\n        // Simulate checking door status\n        is_door_open = check_door_status();\n\n        if is_door_open {\n            open_duration += 1;\n            if open_duration > alert_threshold {\n                println!(\"Alert: The door has been open for too long!\");\n                break;\n            }\n        } else {\n            open_duration = 0;\n        }\n    }\n}\n\nfn check_door_status() -> bool {\n    // Placeholder for the actual door status check\n    // Returns true if the door is open, false otherwise\n    true // Simulating an open door for demonstration\n}\n```"
  },
  {
    "task": "Implement a feature that keeps adding random characters to a string until its length is 8.",
    "code": "```rust\nuse rand::Rng;\n\nfn main() {\n    let mut rng = rand::thread_rng();\n    let mut s = String::new();\n    \n    while s.len() < 8 {\n        let c = rng.gen_range(b'a', b'z' + 1) as char;\n        s.push(c);\n    }\n\n    println!(\"{}\", s);\n}\n```"
  },
  {
    "task": "Design a routine that simulates a race and continues until a participant crosses the finish line.",
    "code": "```rust\nfn main() {\n    let mut positions = vec![0, 0, 0];\n    let finish_line = 10;\n    let mut winner = None;\n\n    while winner.is_none() {\n        for (i, position) in positions.iter_mut().enumerate() {\n            *position += rand::random::<u8>() % 3; // Simulate movement\n            if *position >= finish_line {\n                winner = Some(i);\n                break;\n            }\n        }\n    }\n\n    if let Some(winner) = winner {\n        println!(\"Participant {} wins the race!\", winner + 1);\n    }\n}\n```"
  },
  {
    "task": "Write a script that keeps checking an email inbox until a specific email is received.",
    "code": "```rust\nuse std::thread::sleep;\nuse std::time::Duration;\n\nfn check_inbox_for_email() -> bool {\n    // This is a placeholder for actual email checking logic\n    // Return true if the specific email is found\n    false\n}\n\nfn main() {\n    let mut email_received = false;\n    \n    while !email_received {\n        email_received = check_inbox_for_email();\n        if !email_received {\n            sleep(Duration::from_secs(10)); // Wait for 10 seconds before checking again\n        }\n    }\n\n    println!(\"Specific email received!\");\n}\n```"
  },
  {
    "task": "Create a loop that continues to play a video on repeat until the user interrupts.",
    "code": "```rust\nuse std::io;\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    let mut input = String::new();\n    while input.trim() != \"q\" {\n        play_video();\n        println!(\"Press 'q' and Enter to stop the video.\");\n        io::stdin().read_line(&mut input).expect(\"Failed to read line\");\n    }\n}\n\nfn play_video() {\n    println!(\"Playing video...\");\n    thread::sleep(Duration::from_secs(2)); // Simulating video play time\n}\n```"
  },
  {
    "task": "Develop a process that keeps scanning for Bluetooth devices until a specific device is found.",
    "code": "```rust\nuse std::thread::sleep;\nuse std::time::Duration;\n\n// Mock function to simulate scanning for Bluetooth devices\nfn scan_bluetooth_devices() -> Vec<String> {\n    vec![\n        String::from(\"Device_A\"),\n        String::from(\"Device_B\"),\n        String::from(\"Target_Device\"),\n        String::from(\"Device_C\"),\n    ]\n}\n\nfn main() {\n    let target_device = \"Target_Device\";\n    let mut device_found = false;\n\n    while !device_found {\n        let devices = scan_bluetooth_devices();\n        \n        for device in devices {\n            if device == target_device {\n                println!(\"Found target device: {}\", device);\n                device_found = true;\n                break;\n            }\n        }\n\n        if !device_found {\n            println!(\"Target device not found, scanning again...\");\n            sleep(Duration::from_secs(2));\n        }\n    }\n}\n```"
  },
  {
    "task": "Implement a script that continuously captures images from a webcam until a motion is detected.",
    "code": "```rust\nuse opencv::{\n    prelude::*,\n    videoio::{self, VideoCapture, CAP_ANY},\n    objdetect,\n    types,\n    core,\n    imgproc,\n};\n\nfn main() -> opencv::Result<()> {\n    let mut cap = VideoCapture::new(0, CAP_ANY)?;\n    if !cap.is_opened()? {\n        panic!(\"Unable to open default camera!\");\n    }\n\n    let mut prev_frame = Mat::default();\n    let mut current_frame = Mat::default();\n    let mut gray_frame = Mat::default();\n    let mut diff_frame = Mat::default();\n\n    while cap.read(&mut current_frame)? {\n        imgproc::cvt_color(&current_frame, &mut gray_frame, imgproc::COLOR_BGR2GRAY, 0)?;\n        if prev_frame.empty()? {\n            gray_frame.copy_to(&mut prev_frame)?;\n            continue;\n        }\n        core::absdiff(&prev_frame, &gray_frame, &mut diff_frame)?;\n        let mut thresh = Mat::default();\n        imgproc::threshold(&diff_frame, &mut thresh, 25.0, 255.0, imgproc::THRESH_BINARY)?;\n\n        let mut contours = types::VectorOfMat::new();\n        imgproc::find_contours(\n            &thresh,\n            &mut contours,\n            imgproc::RETR_EXTERNAL,\n            imgproc::CHAIN_APPROX_SIMPLE,\n            core::Point::new(0, 0),\n        )?;\n\n        if !contours.is_empty() {\n            println!(\"Motion detected!\");\n            break;\n        }\n        gray_frame.copy_to(&mut prev_frame)?;\n    }\n    Ok(())\n}\n```"
  },
  {
    "task": "Design a program that keeps playing a sound file until the user presses a mute button.",
    "code": "```rust\nuse std::sync::atomic::{AtomicBool, Ordering};\nuse std::sync::Arc;\nuse std::thread;\nuse rodio::{Decoder, OutputStream, Sink};\nuse std::io::BufReader;\nuse std::fs::File;\n\nfn main() {\n    let mute = Arc::new(AtomicBool::new(false));\n    let mute_clone = Arc::clone(&mute);\n\n    thread::spawn(move || {\n        // Simulate a button press to mute the sound\n        // In a real application, this would be replaced with event handling code\n        std::thread::sleep(std::time::Duration::from_secs(5));\n        mute_clone.store(true, Ordering::SeqCst);\n    });\n\n    let (_stream, stream_handle) = OutputStream::try_default().unwrap();\n\n    while !mute.load(Ordering::SeqCst) {\n        let file = BufReader::new(File::open(\"sound.wav\").unwrap());\n        let source = Decoder::new(file).unwrap();\n        let sink = Sink::try_new(&stream_handle).unwrap();\n        sink.append(source);\n        sink.sleep_until_end();\n    }\n}\n```"
  },
  {
    "task": "Create a loop that repeatedly generates a random password until it meets certain security criteria.",
    "code": "```rust\nuse rand::Rng;\nuse rand::distributions::Alphanumeric;\n\nfn generate_random_password() -> String {\n    rand::thread_rng()\n        .sample_iter(&Alphanumeric)\n        .take(12)\n        .map(char::from)\n        .collect()\n}\n\nfn is_password_secure(password: &str) -> bool {\n    if password.len() < 8 {\n        return false;\n    }\n    let has_uppercase = password.chars().any(|c| c.is_uppercase());\n    let has_lowercase = password.chars().any(|c| c.is_lowercase());\n    let has_digit = password.chars().any(|c| c.is_digit(10));\n    has_uppercase && has_lowercase && has_digit\n}\n\nfn main() {\n    let mut password;\n    loop {\n        password = generate_random_password();\n        if is_password_secure(&password) {\n            break;\n        }\n    }\n    println!(\"Generated secure password: {}\", password);\n}\n```"
  },
  {
    "task": "Write a process that keeps checking for file changes in a directory and logs them until stopped.",
    "code": "```rust\nuse std::fs;\nuse std::time::Duration;\nuse std::collections::HashMap;\nuse std::thread::sleep;\nuse notify::{watcher, DebouncedEvent, RecursiveMode, Watcher};\nuse std::sync::mpsc::channel;\nuse std::path::PathBuf;\n\nfn main() {\n    let (tx, rx) = channel();\n    let mut watcher = watcher(tx, Duration::from_secs(2)).unwrap();\n    let dir_to_watch = \"/path/to/directory\";\n    watcher.watch(dir_to_watch, RecursiveMode::Recursive).unwrap();\n\n    let mut file_timestamps = HashMap::new();\n\n    while let Ok(event) = rx.recv() {\n        match event {\n            DebouncedEvent::Write(path) | DebouncedEvent::Create(path) | DebouncedEvent::Remove(path) => {\n                if let Some(modified_time) = get_modified_time(&path) {\n                    if let Some(last_modified_time) = file_timestamps.get(&path) {\n                        if &modified_time > last_modified_time {\n                            println!(\"File changed: {:?}\", path);\n                            file_timestamps.insert(path, modified_time);\n                        }\n                    } else {\n                        println!(\"File changed: {:?}\", path);\n                        file_timestamps.insert(path.clone(), modified_time);\n                    }\n                }\n            }\n            _ => {}\n        }\n    }\n}\n\nfn get_modified_time(path: &PathBuf) -> Option<std::time::SystemTime> {\n    fs::metadata(path).and_then(|metadata| metadata.modified()).ok()\n}\n```"
  }
]