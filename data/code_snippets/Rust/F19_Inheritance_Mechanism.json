[
  {
    "task": "Create a base class for a vehicle with methods for speed and fuel efficiency, then derive a car class that overrides these methods to provide specific implementations.",
    "code": "```rust\ntrait Vehicle {\n    fn speed(&self) -> f64;\n    fn fuel_efficiency(&self) -> f64;\n}\n\nstruct Car {\n    speed: f64,\n    fuel_efficiency: f64,\n}\n\nimpl Vehicle for Car {\n    fn speed(&self) -> f64 {\n        self.speed\n    }\n\n    fn fuel_efficiency(&self) -> f64 {\n        self.fuel_efficiency\n    }\n}\n\nfn main() {\n    let my_car = Car {\n        speed: 120.0,\n        fuel_efficiency: 15.0,\n    };\n\n    println!(\"Car speed: {} km/h\", my_car.speed());\n    println!(\"Car fuel efficiency: {} km/l\", my_car.fuel_efficiency());\n}\n```"
  },
  {
    "task": "Design a base class for a multimedia file with properties like duration and format, then extend it with a video class that includes resolution and frame rate.",
    "code": "```rust\nstruct MultimediaFile {\n    duration: u32, // duration in seconds\n    format: String,\n}\n\nstruct VideoFile {\n    multimedia: MultimediaFile,\n    resolution: (u32, u32), // width x height\n    frame_rate: f32,\n}\n\nimpl MultimediaFile {\n    fn new(duration: u32, format: String) -> Self {\n        MultimediaFile { duration, format }\n    }\n}\n\nimpl VideoFile {\n    fn new(duration: u32, format: String, resolution: (u32, u32), frame_rate: f32) -> Self {\n        VideoFile {\n            multimedia: MultimediaFile::new(duration, format),\n            resolution,\n            frame_rate,\n        }\n    }\n}\n```"
  },
  {
    "task": "Develop a superclass for bank accounts with methods for deposit and withdrawal, then create a savings account subclass that overrides the withdrawal method to incorporate interest deductions.",
    "code": "```rust\nstruct BankAccount {\n    balance: f64,\n}\n\nimpl BankAccount {\n    fn new(balance: f64) -> Self {\n        BankAccount { balance }\n    }\n    \n    fn deposit(&mut self, amount: f64) {\n        self.balance += amount;\n    }\n    \n    fn withdraw(&mut self, amount: f64) {\n        if self.balance >= amount {\n            self.balance -= amount;\n        }\n    }\n}\n\nstruct SavingsAccount {\n    account: BankAccount,\n    interest_rate: f64,\n}\n\nimpl SavingsAccount {\n    fn new(balance: f64, interest_rate: f64) -> Self {\n        SavingsAccount {\n            account: BankAccount::new(balance),\n            interest_rate,\n        }\n    }\n    \n    fn deposit(&mut self, amount: f64) {\n        self.account.deposit(amount);\n    }\n    \n    fn withdraw(&mut self, amount: f64) {\n        let interest = amount * self.interest_rate;\n        let total_amount = amount + interest;\n        self.account.withdraw(total_amount);\n    }\n}\n```"
  },
  {
    "task": "Implement a base class for a geometric shape with methods to calculate area and perimeter, then create a rectangle subclass that provides specific calculations for these methods.",
    "code": "```rust\ntrait Shape {\n    fn area(&self) -> f64;\n    fn perimeter(&self) -> f64;\n}\n\nstruct Rectangle {\n    width: f64,\n    height: f64,\n}\n\nimpl Shape for Rectangle {\n    fn area(&self) -> f64 {\n        self.width * self.height\n    }\n    \n    fn perimeter(&self) -> f64 {\n        2.0 * (self.width + self.height)\n    }\n}\n\nfn main() {\n    let rect = Rectangle { width: 3.0, height: 4.0 };\n    println!(\"Area: {}\", rect.area());\n    println!(\"Perimeter: {}\", rect.perimeter());\n}\n```"
  },
  {
    "task": "Construct a parent class for employees with a method to calculate salary, then derive a manager class that overrides this method to include bonuses.",
    "code": "```rust\ntrait Employee {\n    fn calculate_salary(&self) -> f64;\n}\n\nstruct RegularEmployee {\n    base_salary: f64,\n}\n\nimpl Employee for RegularEmployee {\n    fn calculate_salary(&self) -> f64 {\n        self.base_salary\n    }\n}\n\nstruct Manager {\n    base_salary: f64,\n    bonus: f64,\n}\n\nimpl Employee for Manager {\n    fn calculate_salary(&self) -> f64 {\n        self.base_salary + self.bonus\n    }\n}\n\nfn main() {\n    let employee = RegularEmployee { base_salary: 50000.0 };\n    let manager = Manager { base_salary: 60000.0, bonus: 10000.0 };\n\n    println!(\"Employee salary: {}\", employee.calculate_salary());\n    println!(\"Manager salary: {}\", manager.calculate_salary());\n}\n```"
  },
  {
    "task": "Set up a base class for a library item with properties like title and author, and extend it with a book subclass that adds a number of pages property.",
    "code": "```rust\nstruct LibraryItem {\n    title: String,\n    author: String,\n}\n\nimpl LibraryItem {\n    pub fn new(title: &str, author: &str) -> Self {\n        LibraryItem {\n            title: title.to_string(),\n            author: author.to_string(),\n        }\n    }\n}\n\nstruct Book {\n    library_item: LibraryItem,\n    number_of_pages: u32,\n}\n\nimpl Book {\n    pub fn new(title: &str, author: &str, number_of_pages: u32) -> Self {\n        Book {\n            library_item: LibraryItem::new(title, author),\n            number_of_pages,\n        }\n    }\n}\n```"
  },
  {
    "task": "Create a foundation class for an electronic device with a method to turn on and off, and derive a smartphone class that overrides the turn on method to require a passcode.",
    "code": "```rust\ntrait ElectronicDevice {\n    fn turn_on(&mut self);\n    fn turn_off(&mut self);\n}\n\nstruct BasicDevice {\n    is_on: bool,\n}\n\nimpl ElectronicDevice for BasicDevice {\n    fn turn_on(&mut self) {\n        self.is_on = true;\n        println!(\"Device is now on.\");\n    }\n    \n    fn turn_off(&mut self) {\n        self.is_on = false;\n        println!(\"Device is now off.\");\n    }\n}\n\nstruct Smartphone {\n    is_on: bool,\n    passcode: String,\n}\n\nimpl ElectronicDevice for Smartphone {\n    fn turn_on(&mut self) {\n        println!(\"Enter passcode:\");\n        let mut input = String::new();\n        std::io::stdin().read_line(&mut input).unwrap();\n        let trimmed = input.trim();\n\n        if trimmed == self.passcode {\n            self.is_on = true;\n            println!(\"Smartphone is now on.\");\n        } else {\n            println!(\"Incorrect passcode.\");\n        }\n    }\n    \n    fn turn_off(&mut self) {\n        self.is_on = false;\n        println!(\"Smartphone is now off.\");\n    }\n}\n\nfn main() {\n    let mut device = BasicDevice { is_on: false };\n    device.turn_on();\n    device.turn_off();\n\n    let mut phone = Smartphone { is_on: false, passcode: \"1234\".to_string() };\n    phone.turn_on();\n    phone.turn_off();\n}\n```"
  },
  {
    "task": "Design a base class for an animal with a method to make a sound, then create a dog subclass that overrides this method to bark.",
    "code": "```rust\ntrait Animal {\n    fn make_sound(&self);\n}\n\nstruct Dog;\n\nimpl Animal for Dog {\n    fn make_sound(&self) {\n        println!(\"Bark\");\n    }\n}\n\nfn main() {\n    let my_dog = Dog;\n    my_dog.make_sound();\n}\n```"
  },
  {
    "task": "Develop a superclass for meals with a method to calculate calories, then create a dessert subclass that overrides it to add extra sugar calories.",
    "code": "```rust\nstruct Meal {\n    calories: u32,\n}\n\nimpl Meal {\n    fn calculate_calories(&self) -> u32 {\n        self.calories\n    }\n}\n\nstruct Dessert {\n    base: Meal,\n    sugar_calories: u32,\n}\n\nimpl Dessert {\n    fn calculate_calories(&self) -> u32 {\n        self.base.calculate_calories() + self.sugar_calories\n    }\n}\n\nfn main() {\n    let meal = Meal { calories: 500 };\n    let dessert = Dessert {\n        base: meal,\n        sugar_calories: 200,\n    };\n\n    println!(\"Meal calories: {}\", meal.calculate_calories());\n    println!(\"Dessert calories: {}\", dessert.calculate_calories());\n}\n```"
  },
  {
    "task": "Implement a base class for a transportation mode with a method to calculate travel time, then extend it with a plane subclass that overrides the method to calculate based on speed.",
    "code": "```rust\ntrait TransportationMode {\n    fn calculate_travel_time(&self, distance: f64) -> f64;\n}\n\nstruct Plane {\n    speed: f64, // Speed in km/h\n}\n\nimpl TransportationMode for Plane {\n    fn calculate_travel_time(&self, distance: f64) -> f64 {\n        if self.speed > 0.0 {\n            distance / self.speed\n        } else {\n            f64::INFINITY // If speed is not positive, travel time is infinite\n        }\n    }\n}\n\nfn main() {\n    let plane = Plane { speed: 900.0 };\n    let distance = 1800.0; // Example distance in km\n    let travel_time = plane.calculate_travel_time(distance);\n    println!(\"Travel time by plane: {:.2} hours\", travel_time);\n}\n```"
  },
  {
    "task": "Construct a parent class for a musical instrument with a method to play sound, then derive a piano class that overrides the method to play specific notes.",
    "code": "```rust\ntrait MusicalInstrument {\n    fn play_sound(&self);\n}\n\nstruct Piano;\n\nimpl MusicalInstrument for Piano {\n    fn play_sound(&self) {\n        println!(\"Playing piano notes: C E G\");\n    }\n}\n\nfn main() {\n    let piano = Piano;\n    piano.play_sound();\n}\n```"
  },
  {
    "task": "Set up a base class for a user account with a method to reset password, and extend it with an admin account subclass that overrides it to include security questions.",
    "code": "```rust\nstruct UserAccount {\n    username: String,\n    password: String,\n}\n\nimpl UserAccount {\n    fn new(username: &str, password: &str) -> Self {\n        UserAccount {\n            username: username.to_string(),\n            password: password.to_string(),\n        }\n    }\n\n    fn reset_password(&mut self, new_password: &str) {\n        self.password = new_password.to_string();\n    }\n}\n\nstruct AdminAccount {\n    user_account: UserAccount,\n    security_question: String,\n    security_answer: String,\n}\n\nimpl AdminAccount {\n    fn new(username: &str, password: &str, security_question: &str, security_answer: &str) -> Self {\n        AdminAccount {\n            user_account: UserAccount::new(username, password),\n            security_question: security_question.to_string(),\n            security_answer: security_answer.to_string(),\n        }\n    }\n\n    fn reset_password(&mut self, new_password: &str, provided_answer: &str) {\n        if provided_answer == self.security_answer {\n            self.user_account.reset_password(new_password);\n        } else {\n            println!(\"Security answer incorrect. Cannot reset password.\");\n        }\n    }\n}\n```"
  },
  {
    "task": "Create a foundational class for a beverage with properties like volume and temperature, and derive a coffee class that overrides the temperature property to be hot.",
    "code": "```rust\nstruct Beverage {\n    volume: f32,\n    temperature: String,\n}\n\nimpl Beverage {\n    fn new(volume: f32, temperature: &str) -> Self {\n        Beverage {\n            volume,\n            temperature: temperature.to_string(),\n        }\n    }\n\n    fn get_temperature(&self) -> &str {\n        &self.temperature\n    }\n}\n\nstruct Coffee {\n    beverage: Beverage,\n}\n\nimpl Coffee {\n    fn new(volume: f32) -> Self {\n        Coffee {\n            beverage: Beverage::new(volume, \"hot\"),\n        }\n    }\n\n    fn get_volume(&self) -> f32 {\n        self.beverage.volume\n    }\n\n    fn get_temperature(&self) -> &str {\n        self.beverage.get_temperature()\n    }\n}\n```"
  },
  {
    "task": "Design a base class for a service appointment with a method to schedule time, then create a doctor appointment subclass that overrides this method to include consultation duration.",
    "code": "```rust\nstruct ServiceAppointment {\n    time: String,\n}\n\nimpl ServiceAppointment {\n    fn new(time: &str) -> Self {\n        ServiceAppointment {\n            time: time.to_string(),\n        }\n    }\n\n    fn schedule_time(&self) -> String {\n        format!(\"Service scheduled at {}\", self.time)\n    }\n}\n\nstruct DoctorAppointment {\n    base: ServiceAppointment,\n    duration: u32,\n}\n\nimpl DoctorAppointment {\n    fn new(time: &str, duration: u32) -> Self {\n        DoctorAppointment {\n            base: ServiceAppointment::new(time),\n            duration,\n        }\n    }\n\n    fn schedule_time(&self) -> String {\n        format!(\n            \"Doctor appointment scheduled at {} for {} minutes\",\n            self.base.time, self.duration\n        )\n    }\n}\n\nfn main() {\n    let service_appointment = ServiceAppointment::new(\"10:00 AM\");\n    println!(\"{}\", service_appointment.schedule_time());\n\n    let doctor_appointment = DoctorAppointment::new(\"11:00 AM\", 30);\n    println!(\"{}\", doctor_appointment.schedule_time());\n}\n```"
  },
  {
    "task": "Develop a superclass for electronic gadgets with a method to calculate battery life, then extend it with a laptop class that overrides this method to consider usage patterns.",
    "code": "```rust\ntrait Gadget {\n    fn calculate_battery_life(&self) -> u32;\n}\n\nstruct ElectronicGadget {\n    battery_capacity: u32,\n    power_consumption: u32,\n}\n\nimpl Gadget for ElectronicGadget {\n    fn calculate_battery_life(&self) -> u32 {\n        self.battery_capacity / self.power_consumption\n    }\n}\n\nstruct Laptop {\n    base: ElectronicGadget,\n    usage_pattern_factor: f32,\n}\n\nimpl Gadget for Laptop {\n    fn calculate_battery_life(&self) -> u32 {\n        (self.base.battery_capacity as f32 / self.base.power_consumption as f32 * self.usage_pattern_factor) as u32\n    }\n}\n\nfn main() {\n    let gadget = ElectronicGadget {\n        battery_capacity: 5000,\n        power_consumption: 500,\n    };\n    let laptop = Laptop {\n        base: ElectronicGadget {\n            battery_capacity: 5000,\n            power_consumption: 500,\n        },\n        usage_pattern_factor: 0.8,\n    };\n\n    println!(\"Gadget battery life: {} hours\", gadget.calculate_battery_life());\n    println!(\"Laptop battery life: {} hours\", laptop.calculate_battery_life());\n}\n```"
  },
  {
    "task": "Implement a base class for a website component with a method to render content, then create a blog post subclass that overrides this method to include author information.",
    "code": "```rust\ntrait Component {\n    fn render(&self) -> String;\n}\n\nstruct WebComponent;\n\nimpl Component for WebComponent {\n    fn render(&self) -> String {\n        String::from(\"Rendering base component content\")\n    }\n}\n\nstruct BlogPost {\n    author: String,\n}\n\nimpl Component for BlogPost {\n    fn render(&self) -> String {\n        format!(\"Rendering blog post content by {}\", self.author)\n    }\n}\n\nfn main() {\n    let base_component = WebComponent;\n    let blog_post = BlogPost {\n        author: String::from(\"John Doe\"),\n    };\n\n    println!(\"{}\", base_component.render());\n    println!(\"{}\", blog_post.render());\n}\n```"
  },
  {
    "task": "Construct a parent class for a recipe with methods for ingredients and instructions, then derive a cake recipe class that overrides these methods to add baking steps.",
    "code": "```rust\ntrait Recipe {\n    fn ingredients(&self) -> String;\n    fn instructions(&self) -> String;\n}\n\nstruct BasicRecipe;\n\nimpl Recipe for BasicRecipe {\n    fn ingredients(&self) -> String {\n        \"Basic ingredients\".to_string()\n    }\n\n    fn instructions(&self) -> String {\n        \"Basic instructions\".to_string()\n    }\n}\n\nstruct CakeRecipe;\n\nimpl Recipe for CakeRecipe {\n    fn ingredients(&self) -> String {\n        \"Flour, Sugar, Eggs, Butter\".to_string()\n    }\n\n    fn instructions(&self) -> String {\n        \"Mix ingredients, bake at 350\u00b0F for 30 minutes\".to_string()\n    }\n}\n\nfn main() {\n    let cake = CakeRecipe;\n    println!(\"Cake Ingredients: {}\", cake.ingredients());\n    println!(\"Cake Instructions: {}\", cake.instructions());\n}\n```"
  },
  {
    "task": "Set up a base class for a plant with methods for sunlight and water needs, and extend it with a cactus subclass that overrides these methods to require less water.",
    "code": "```rust\ntrait Plant {\n    fn sunlight_needs(&self) -> &'static str;\n    fn water_needs(&self) -> &'static str;\n}\n\nstruct BasePlant;\n\nimpl Plant for BasePlant {\n    fn sunlight_needs(&self) -> &'static str {\n        \"Needs full sunlight\"\n    }\n\n    fn water_needs(&self) -> &'static str {\n        \"Needs regular watering\"\n    }\n}\n\nstruct Cactus;\n\nimpl Plant for Cactus {\n    fn sunlight_needs(&self) -> &'static str {\n        \"Needs full sunlight\"\n    }\n\n    fn water_needs(&self) -> &'static str {\n        \"Needs minimal watering\"\n    }\n}\n\nfn main() {\n    let plant = BasePlant;\n    let cactus = Cactus;\n    \n    println!(\"Base Plant: Sunlight - {}, Water - {}\", plant.sunlight_needs(), plant.water_needs());\n    println!(\"Cactus: Sunlight - {}, Water - {}\", cactus.sunlight_needs(), cactus.water_needs());\n}\n```"
  },
  {
    "task": "Create a foundational class for a building with properties like height and material, and derive a skyscraper class that overrides the height property to be significantly taller.",
    "code": "```rust\nstruct Building {\n    height: u32,\n    material: String,\n}\n\nimpl Building {\n    fn new(height: u32, material: &str) -> Self {\n        Building {\n            height,\n            material: material.to_string(),\n        }\n    }\n\n    fn height(&self) -> u32 {\n        self.height\n    }\n\n    fn material(&self) -> &str {\n        &self.material\n    }\n}\n\nstruct Skyscraper {\n    building: Building,\n}\n\nimpl Skyscraper {\n    fn new(material: &str) -> Self {\n        Skyscraper {\n            building: Building::new(300, material),\n        }\n    }\n\n    fn height(&self) -> u32 {\n        self.building.height\n    }\n\n    fn material(&self) -> &str {\n        self.building.material()\n    }\n}\n\nfn main() {\n    let building = Building::new(50, \"Concrete\");\n    let skyscraper = Skyscraper::new(\"Steel\");\n\n    println!(\"Building: Height = {}, Material = {}\", building.height(), building.material());\n    println!(\"Skyscraper: Height = {}, Material = {}\", skyscraper.height(), skyscraper.material());\n}\n```"
  },
  {
    "task": "Design a base class for a payment method with a method to process transactions, then create a credit card subclass that overrides this method to include credit limits.",
    "code": "```rust\nstruct Transaction {\n    amount: f64,\n}\n\ntrait PaymentMethod {\n    fn process_transaction(&self, transaction: &Transaction) -> bool;\n}\n\nstruct CreditCard {\n    credit_limit: f64,\n    current_balance: f64,\n}\n\nimpl PaymentMethod for CreditCard {\n    fn process_transaction(&self, transaction: &Transaction) -> bool {\n        if self.current_balance + transaction.amount <= self.credit_limit {\n            println!(\"Transaction approved.\");\n            true\n        } else {\n            println!(\"Transaction denied: over credit limit.\");\n            false\n        }\n    }\n}\n\nfn main() {\n    let transaction = Transaction { amount: 50.0 };\n    let credit_card = CreditCard {\n        credit_limit: 100.0,\n        current_balance: 30.0,\n    };\n\n    credit_card.process_transaction(&transaction);\n}\n```"
  },
  {
    "task": "Develop a superclass for a computer program with methods for input and output, then extend it with a game subclass that overrides these methods to include player interactions.",
    "code": "```rust\ntrait Program {\n    fn input(&self);\n    fn output(&self);\n}\n\nstruct Game;\n\nimpl Program for Game {\n    fn input(&self) {\n        println!(\"Player input received\");\n    }\n\n    fn output(&self) {\n        println!(\"Displaying game output\");\n    }\n}\n\nfn main() {\n    let game = Game;\n    game.input();\n    game.output();\n}\n```"
  },
  {
    "task": "Implement a base class for a dining establishment with a method to calculate wait time, then create a fast food subclass that overrides this method to be shorter.",
    "code": "```rust\ntrait DiningEstablishment {\n    fn calculate_wait_time(&self) -> u32;\n}\n\nstruct Restaurant;\n\nimpl DiningEstablishment for Restaurant {\n    fn calculate_wait_time(&self) -> u32 {\n        30 // default wait time in minutes\n    }\n}\n\nstruct FastFood;\n\nimpl DiningEstablishment for FastFood {\n    fn calculate_wait_time(&self) -> u32 {\n        10 // shorter wait time for fast food\n    }\n}\n\nfn main() {\n    let restaurant = Restaurant;\n    let fast_food = FastFood;\n\n    println!(\"Restaurant wait time: {} minutes\", restaurant.calculate_wait_time());\n    println!(\"Fast food wait time: {} minutes\", fast_food.calculate_wait_time());\n}\n```"
  },
  {
    "task": "Construct a parent class for a social media profile with methods for posting and liking, then derive a business profile class that overrides these methods to include promotions.",
    "code": "```rust\ntrait Profile {\n    fn post(&self, content: &str);\n    fn like(&self, post_id: u32);\n}\n\nstruct SocialMediaProfile;\n\nimpl Profile for SocialMediaProfile {\n    fn post(&self, content: &str) {\n        println!(\"Posting: {}\", content);\n    }\n\n    fn like(&self, post_id: u32) {\n        println!(\"Liking post with ID: {}\", post_id);\n    }\n}\n\nstruct BusinessProfile;\n\nimpl Profile for BusinessProfile {\n    fn post(&self, content: &str) {\n        println!(\"Business posting with promotion: {}\", content);\n    }\n\n    fn like(&self, post_id: u32) {\n        println!(\"Business liking post with ID: {}\", post_id);\n    }\n}\n\nfn main() {\n    let personal_profile = SocialMediaProfile;\n    let business_profile = BusinessProfile;\n\n    personal_profile.post(\"Hello, world!\");\n    personal_profile.like(10);\n\n    business_profile.post(\"Check out our new product!\");\n    business_profile.like(20);\n}\n```"
  },
  {
    "task": "Set up a base class for an educational course with methods for syllabus and grading, and extend it with an online course subclass that overrides these methods for remote learning.",
    "code": "```rust\ntrait Course {\n    fn syllabus(&self) -> String;\n    fn grading(&self) -> String;\n}\n\nstruct BaseCourse;\n\nimpl Course for BaseCourse {\n    fn syllabus(&self) -> String {\n        \"Base course syllabus\".to_string()\n    }\n\n    fn grading(&self) -> String {\n        \"Base course grading\".to_string()\n    }\n}\n\nstruct OnlineCourse;\n\nimpl Course for OnlineCourse {\n    fn syllabus(&self) -> String {\n        \"Online course syllabus with remote learning\".to_string()\n    }\n\n    fn grading(&self) -> String {\n        \"Online course grading, adapted for remote learning\".to_string()\n    }\n}\n\nfn main() {\n    let base_course = BaseCourse;\n    let online_course = OnlineCourse;\n\n    println!(\"Base Course Syllabus: {}\", base_course.syllabus());\n    println!(\"Base Course Grading: {}\", base_course.grading());\n\n    println!(\"Online Course Syllabus: {}\", online_course.syllabus());\n    println!(\"Online Course Grading: {}\", online_course.grading());\n}\n```"
  },
  {
    "task": "Create a foundational class for a sports team with properties like team name and coach, and derive a football team class that overrides the coach property with a specific person.",
    "code": "```rust\nstruct SportsTeam {\n    team_name: String,\n    coach: String,\n}\n\nstruct FootballTeam {\n    team_name: String,\n    coach: String,\n}\n\nimpl SportsTeam {\n    fn new(team_name: &str, coach: &str) -> Self {\n        SportsTeam {\n            team_name: team_name.to_string(),\n            coach: coach.to_string(),\n        }\n    }\n}\n\nimpl FootballTeam {\n    fn new(team_name: &str, specific_coach: &str) -> Self {\n        FootballTeam {\n            team_name: team_name.to_string(),\n            coach: specific_coach.to_string(),\n        }\n    }\n}\n\nfn main() {\n    let general_team = SportsTeam::new(\"Generic Team\", \"Coach A\");\n    let football_team = FootballTeam::new(\"Football Team\", \"Coach B\");\n}\n```"
  },
  {
    "task": "Design a base class for a document with methods for printing and saving, then create a PDF document subclass that overrides these methods to include encryption.",
    "code": "```rust\ntrait Document {\n    fn print(&self);\n    fn save(&self);\n}\n\nstruct BaseDocument;\n\nimpl Document for BaseDocument {\n    fn print(&self) {\n        println!(\"Printing document...\");\n    }\n\n    fn save(&self) {\n        println!(\"Saving document...\");\n    }\n}\n\nstruct PdfDocument;\n\nimpl Document for PdfDocument {\n    fn print(&self) {\n        println!(\"Printing PDF document with encryption...\");\n    }\n\n    fn save(&self) {\n        println!(\"Saving PDF document with encryption...\");\n    }\n}\n\nfn main() {\n    let base_doc = BaseDocument;\n    base_doc.print();\n    base_doc.save();\n\n    let pdf_doc = PdfDocument;\n    pdf_doc.print();\n    pdf_doc.save();\n}\n```"
  },
  {
    "task": "Develop a superclass for a retail product with methods for pricing and discount, then extend it with an electronics product class that overrides the discount method to offer more.",
    "code": "```rust\nstruct Product {\n    price: f64,\n}\n\nimpl Product {\n    fn new(price: f64) -> Self {\n        Product { price }\n    }\n\n    fn get_price(&self) -> f64 {\n        self.price\n    }\n\n    fn discount(&self) -> f64 {\n        self.price * 0.9 // 10% discount\n    }\n}\n\nstruct ElectronicsProduct {\n    base: Product,\n}\n\nimpl ElectronicsProduct {\n    fn new(price: f64) -> Self {\n        ElectronicsProduct { base: Product::new(price) }\n    }\n\n    fn get_price(&self) -> f64 {\n        self.base.get_price()\n    }\n\n    fn discount(&self) -> f64 {\n        self.base.get_price() * 0.8 // 20% discount\n    }\n}\n\nfn main() {\n    let generic_product = Product::new(100.0);\n    println!(\"Generic Product Price: ${}\", generic_product.get_price());\n    println!(\"Generic Product Discounted Price: ${}\", generic_product.discount());\n\n    let electronic_product = ElectronicsProduct::new(100.0);\n    println!(\"Electronics Product Price: ${}\", electronic_product.get_price());\n    println!(\"Electronics Product Discounted Price: ${}\", electronic_product.discount());\n}\n```"
  },
  {
    "task": "Implement a base class for a subscription service with a method to renew membership, then create a monthly subscription subclass that overrides this method for automatic renewal.",
    "code": "```rust\ntrait Subscription {\n    fn renew_membership(&self) -> String;\n}\n\nstruct BaseSubscription {\n    name: String,\n}\n\nimpl Subscription for BaseSubscription {\n    fn renew_membership(&self) -> String {\n        format!(\"Renewing membership for {}\", self.name)\n    }\n}\n\nstruct MonthlySubscription {\n    base: BaseSubscription,\n}\n\nimpl Subscription for MonthlySubscription {\n    fn renew_membership(&self) -> String {\n        format!(\n            \"Automatically renewing monthly membership for {}\",\n            self.base.name\n        )\n    }\n}\n\nfn main() {\n    let base_subscription = BaseSubscription {\n        name: String::from(\"Alice\"),\n    };\n    let monthly_subscription = MonthlySubscription {\n        base: base_subscription,\n    };\n\n    println!(\"{}\", monthly_subscription.renew_membership());\n}\n```"
  },
  {
    "task": "Construct a parent class for a language translator with a method to translate text, then derive a French translator class that overrides this method for French language specifics.",
    "code": "```rust\ntrait Translator {\n    fn translate(&self, text: &str) -> String;\n}\n\nstruct LanguageTranslator;\n\nimpl Translator for LanguageTranslator {\n    fn translate(&self, text: &str) -> String {\n        format!(\"Translating text: {}\", text)\n    }\n}\n\nstruct FrenchTranslator;\n\nimpl Translator for FrenchTranslator {\n    fn translate(&self, text: &str) -> String {\n        format!(\"Traduction (fran\u00e7ais): {}\", text)\n    }\n}\n\nfn main() {\n    let english_translator = LanguageTranslator;\n    let french_translator = FrenchTranslator;\n\n    let text = \"Hello, world!\";\n    \n    println!(\"{}\", english_translator.translate(text));\n    println!(\"{}\", french_translator.translate(text));\n}\n```"
  },
  {
    "task": "Set up a base class for a customer order with methods for placing and tracking, and extend it with a food order subclass that overrides tracking for delivery status.",
    "code": "```rust\ntrait Order {\n    fn place(&self);\n    fn track(&self) -> String;\n}\n\nstruct CustomerOrder;\n\nimpl Order for CustomerOrder {\n    fn place(&self) {\n        println!(\"Placing a customer order.\");\n    }\n\n    fn track(&self) -> String {\n        String::from(\"Tracking customer order status.\")\n    }\n}\n\nstruct FoodOrder;\n\nimpl Order for FoodOrder {\n    fn place(&self) {\n        println!(\"Placing a food order.\");\n    }\n\n    fn track(&self) -> String {\n        String::from(\"Tracking food order delivery status.\")\n    }\n}\n\nfn main() {\n    let order = CustomerOrder;\n    order.place();\n    println!(\"{}\", order.track());\n\n    let food_order = FoodOrder;\n    food_order.place();\n    println!(\"{}\", food_order.track());\n}\n```"
  },
  {
    "task": "Create a foundational class for an artwork with properties like artist and medium, and derive a painting class that overrides the medium property to be 'canvas'.",
    "code": "```rust\nstruct Artwork {\n    artist: String,\n    medium: String,\n}\n\nimpl Artwork {\n    fn new(artist: &str, medium: &str) -> Artwork {\n        Artwork {\n            artist: artist.to_string(),\n            medium: medium.to_string(),\n        }\n    }\n}\n\nstruct Painting {\n    artwork: Artwork,\n}\n\nimpl Painting {\n    fn new(artist: &str) -> Painting {\n        Painting {\n            artwork: Artwork {\n                artist: artist.to_string(),\n                medium: \"canvas\".to_string(),\n            },\n        }\n    }\n}\n```"
  },
  {
    "task": "Design a base class for a computer network with methods for connectivity and bandwidth, then create a wireless network subclass that overrides these methods for signal strength.",
    "code": "```rust\nstruct Network {\n    connectivity: f64,\n    bandwidth: f64,\n}\n\nimpl Network {\n    fn new(connectivity: f64, bandwidth: f64) -> Self {\n        Network { connectivity, bandwidth }\n    }\n\n    fn connectivity(&self) -> f64 {\n        self.connectivity\n    }\n\n    fn bandwidth(&self) -> f64 {\n        self.bandwidth\n    }\n}\n\nstruct WirelessNetwork {\n    network: Network,\n    signal_strength: f64,\n}\n\nimpl WirelessNetwork {\n    fn new(connectivity: f64, bandwidth: f64, signal_strength: f64) -> Self {\n        WirelessNetwork {\n            network: Network::new(connectivity, bandwidth),\n            signal_strength,\n        }\n    }\n\n    fn connectivity(&self) -> f64 {\n        self.network.connectivity * self.signal_strength\n    }\n\n    fn bandwidth(&self) -> f64 {\n        self.network.bandwidth * self.signal_strength\n    }\n}\n```"
  },
  {
    "task": "Develop a superclass for a messaging app with methods for sending and receiving messages, then extend it with a secure messaging subclass that overrides these methods for encryption.",
    "code": "```rust\nstruct Message {\n    content: String,\n}\n\nimpl Message {\n    fn new(content: &str) -> Self {\n        Message {\n            content: content.to_string(),\n        }\n    }\n}\n\nstruct MessagingApp;\n\nimpl MessagingApp {\n    fn send_message(&self, message: &Message) {\n        println!(\"Sending message: {}\", message.content);\n    }\n\n    fn receive_message(&self) -> Message {\n        let received_content = \"Received message content\";\n        println!(\"Receiving message: {}\", received_content);\n        Message::new(received_content)\n    }\n}\n\nstruct SecureMessagingApp;\n\nimpl SecureMessagingApp {\n    fn encrypt(&self, content: &str) -> String {\n        format!(\"Encrypted({})\", content)\n    }\n\n    fn decrypt(&self, content: &str) -> String {\n        content.trim_start_matches(\"Encrypted(\").trim_end_matches(')').to_string()\n    }\n}\n\nimpl MessagingApp for SecureMessagingApp {\n    fn send_message(&self, message: &Message) {\n        let encrypted_content = self.encrypt(&message.content);\n        println!(\"Sending encrypted message: {}\", encrypted_content);\n    }\n\n    fn receive_message(&self) -> Message {\n        let received_content = \"Encrypted(Received message content)\";\n        let decrypted_content = self.decrypt(received_content);\n        println!(\"Receiving decrypted message: {}\", decrypted_content);\n        Message::new(&decrypted_content)\n    }\n}\n\nfn main() {\n    let app = MessagingApp;\n    let secure_app = SecureMessagingApp;\n\n    let message = Message::new(\"Hello, World!\");\n\n    app.send_message(&message);\n    let received_message = app.receive_message();\n\n    secure_app.send_message(&message);\n    let secure_received_message = secure_app.receive_message();\n}\n```"
  },
  {
    "task": "Implement a base class for a travel itinerary with methods for destinations and activities, then create a vacation itinerary subclass that overrides these methods for leisure activities.",
    "code": "```rust\ntrait Itinerary {\n    fn destinations(&self) -> Vec<String>;\n    fn activities(&self) -> Vec<String>;\n}\n\nstruct TravelItinerary;\n\nimpl Itinerary for TravelItinerary {\n    fn destinations(&self) -> Vec<String> {\n        vec![\"Paris\".to_string(), \"New York\".to_string()]\n    }\n\n    fn activities(&self) -> Vec<String> {\n        vec![\"Sightseeing\".to_string(), \"Business Meetings\".to_string()]\n    }\n}\n\nstruct VacationItinerary;\n\nimpl Itinerary for VacationItinerary {\n    fn destinations(&self) -> Vec<String> {\n        vec![\"Hawaii\".to_string(), \"Bahamas\".to_string()]\n    }\n\n    fn activities(&self) -> Vec<String> {\n        vec![\"Beach\".to_string(), \"Spa\".to_string()]\n    }\n}\n\nfn main() {\n    let travel = TravelItinerary;\n    let vacation = VacationItinerary;\n\n    println!(\"Travel Destinations: {:?}\", travel.destinations());\n    println!(\"Travel Activities: {:?}\", travel.activities());\n\n    println!(\"Vacation Destinations: {:?}\", vacation.destinations());\n    println!(\"Vacation Activities: {:?}\", vacation.activities());\n}\n```"
  },
  {
    "task": "Construct a parent class for a healthcare record with methods for patient data and treatment history, then derive a pediatric record class that overrides these methods for child-specific data.",
    "code": "```rust\nstruct HealthcareRecord {\n    patient_name: String,\n    age: u32,\n}\n\nimpl HealthcareRecord {\n    fn get_patient_data(&self) -> String {\n        format!(\"Patient Name: {}, Age: {}\", self.patient_name, self.age)\n    }\n\n    fn get_treatment_history(&self) -> String {\n        String::from(\"General treatment history\")\n    }\n}\n\nstruct PediatricRecord {\n    healthcare_record: HealthcareRecord,\n    guardian_name: String,\n}\n\nimpl PediatricRecord {\n    fn new(patient_name: String, age: u32, guardian_name: String) -> Self {\n        PediatricRecord {\n            healthcare_record: HealthcareRecord { patient_name, age },\n            guardian_name,\n        }\n    }\n}\n\nimpl HealthcareRecord for PediatricRecord {\n    fn get_patient_data(&self) -> String {\n        format!(\n            \"Patient Name: {}, Age: {}, Guardian: {}\",\n            self.healthcare_record.patient_name,\n            self.healthcare_record.age,\n            self.guardian_name\n        )\n    }\n\n    fn get_treatment_history(&self) -> String {\n        String::from(\"Child-specific treatment history\")\n    }\n}\n```"
  },
  {
    "task": "Set up a base class for a culinary dish with methods for preparation and serving, and extend it with an appetizer subclass that overrides these methods for smaller portions.",
    "code": "```rust\ntrait CulinaryDish {\n    fn prepare(&self);\n    fn serve(&self);\n}\n\nstruct Dish;\n\nimpl CulinaryDish for Dish {\n    fn prepare(&self) {\n        println!(\"Preparing the dish.\");\n    }\n\n    fn serve(&self) {\n        println!(\"Serving the dish.\");\n    }\n}\n\nstruct Appetizer;\n\nimpl CulinaryDish for Appetizer {\n    fn prepare(&self) {\n        println!(\"Preparing a small portion of the appetizer.\");\n    }\n\n    fn serve(&self) {\n        println!(\"Serving a small portion of the appetizer.\");\n    }\n}\n\nfn main() {\n    let dish = Dish;\n    dish.prepare();\n    dish.serve();\n\n    let appetizer = Appetizer;\n    appetizer.prepare();\n    appetizer.serve();\n}\n```"
  },
  {
    "task": "Create a foundational class for a book collection with properties like genre and author, and derive a mystery collection class that overrides the genre property to be 'mystery'.",
    "code": "```rust\nstruct BookCollection {\n    genre: String,\n    author: String,\n}\n\nimpl BookCollection {\n    fn new(genre: &str, author: &str) -> Self {\n        BookCollection {\n            genre: genre.to_string(),\n            author: author.to_string(),\n        }\n    }\n}\n\nstruct MysteryCollection {\n    base: BookCollection,\n}\n\nimpl MysteryCollection {\n    fn new(author: &str) -> Self {\n        MysteryCollection {\n            base: BookCollection::new(\"mystery\", author),\n        }\n    }\n}\n\nfn main() {\n    let mystery_book = MysteryCollection::new(\"Agatha Christie\");\n    println!(\"Genre: {}, Author: {}\", mystery_book.base.genre, mystery_book.base.author);\n}\n```"
  },
  {
    "task": "Design a base class for a file storage system with methods for saving and deleting files, then create a cloud storage subclass that overrides these methods for remote access.",
    "code": "```rust\ntrait FileStorage {\n    fn save_file(&self, file_name: &str, data: &str);\n    fn delete_file(&self, file_name: &str);\n}\n\nstruct LocalStorage;\n\nimpl FileStorage for LocalStorage {\n    fn save_file(&self, file_name: &str, data: &str) {\n        println!(\"Saving file '{}' locally with data: {}\", file_name, data);\n    }\n\n    fn delete_file(&self, file_name: &str) {\n        println!(\"Deleting file '{}' locally\", file_name);\n    }\n}\n\nstruct CloudStorage;\n\nimpl FileStorage for CloudStorage {\n    fn save_file(&self, file_name: &str, data: &str) {\n        println!(\"Uploading file '{}' to cloud with data: {}\", file_name, data);\n    }\n\n    fn delete_file(&self, file_name: &str) {\n        println!(\"Deleting file '{}' from cloud\", file_name);\n    }\n}\n\nfn main() {\n    let local_storage = LocalStorage;\n    let cloud_storage = CloudStorage;\n\n    local_storage.save_file(\"local.txt\", \"Local data\");\n    local_storage.delete_file(\"local.txt\");\n\n    cloud_storage.save_file(\"cloud.txt\", \"Cloud data\");\n    cloud_storage.delete_file(\"cloud.txt\");\n}\n```"
  },
  {
    "task": "Develop a superclass for a seasonal sale event with methods for discounts and promotions, then extend it with a summer sale subclass that overrides these methods for summer items.",
    "code": "```rust\ntrait SaleEvent {\n    fn discount(&self) -> f64;\n    fn promotion(&self) -> String;\n}\n\nstruct SeasonalSale {\n    base_discount: f64,\n    base_promotion: String,\n}\n\nimpl SaleEvent for SeasonalSale {\n    fn discount(&self) -> f64 {\n        self.base_discount\n    }\n\n    fn promotion(&self) -> String {\n        self.base_promotion.clone()\n    }\n}\n\nstruct SummerSale {\n    seasonal_sale: SeasonalSale,\n    summer_discount: f64,\n    summer_promotion: String,\n}\n\nimpl SaleEvent for SummerSale {\n    fn discount(&self) -> f64 {\n        self.summer_discount\n    }\n\n    fn promotion(&self) -> String {\n        self.summer_promotion.clone()\n    }\n}\n\nfn main() {\n    let seasonal_sale = SeasonalSale {\n        base_discount: 10.0,\n        base_promotion: String::from(\"Regular Promotion\"),\n    };\n\n    let summer_sale = SummerSale {\n        seasonal_sale,\n        summer_discount: 15.0,\n        summer_promotion: String::from(\"Summer Special Promotion\"),\n    };\n\n    println!(\"Seasonal Sale Discount: {}\", summer_sale.seasonal_sale.discount());\n    println!(\"Seasonal Sale Promotion: {}\", summer_sale.seasonal_sale.promotion());\n    println!(\"Summer Sale Discount: {}\", summer_sale.discount());\n    println!(\"Summer Sale Promotion: {}\", summer_sale.promotion());\n}\n```"
  },
  {
    "task": "Implement a base class for a personal budget with methods for income and expenses, then create a student budget subclass that overrides these methods for tuition and fees.",
    "code": "```rust\ntrait Budget {\n    fn income(&self) -> f64;\n    fn expenses(&self) -> f64;\n}\n\nstruct PersonalBudget {\n    salary: f64,\n    expenses: f64,\n}\n\nimpl Budget for PersonalBudget {\n    fn income(&self) -> f64 {\n        self.salary\n    }\n\n    fn expenses(&self) -> f64 {\n        self.expenses\n    }\n}\n\nstruct StudentBudget {\n    salary: f64,\n    expenses: f64,\n    tuition: f64,\n    fees: f64,\n}\n\nimpl Budget for StudentBudget {\n    fn income(&self) -> f64 {\n        self.salary\n    }\n\n    fn expenses(&self) -> f64 {\n        self.expenses + self.tuition + self.fees\n    }\n}\n\nfn main() {\n    let personal_budget = PersonalBudget {\n        salary: 5000.0,\n        expenses: 2000.0,\n    };\n\n    let student_budget = StudentBudget {\n        salary: 3000.0,\n        expenses: 1000.0,\n        tuition: 1500.0,\n        fees: 300.0,\n    };\n\n    println!(\"Personal Budget: Income = {}, Expenses = {}\", personal_budget.income(), personal_budget.expenses());\n    println!(\"Student Budget: Income = {}, Expenses = {}\", student_budget.income(), student_budget.expenses());\n}\n```"
  },
  {
    "task": "Construct a parent class for a fitness routine with methods for exercises and duration, then derive a yoga routine class that overrides these methods for flexibility exercises.",
    "code": "```rust\ntrait FitnessRoutine {\n    fn exercises(&self) -> String;\n    fn duration(&self) -> u32;\n}\n\nstruct BasicRoutine;\n\nimpl FitnessRoutine for BasicRoutine {\n    fn exercises(&self) -> String {\n        String::from(\"General Fitness Exercises\")\n    }\n\n    fn duration(&self) -> u32 {\n        60\n    }\n}\n\nstruct YogaRoutine;\n\nimpl FitnessRoutine for YogaRoutine {\n    fn exercises(&self) -> String {\n        String::from(\"Flexibility Exercises\")\n    }\n\n    fn duration(&self) -> u32 {\n        45\n    }\n}\n\nfn main() {\n    let basic = BasicRoutine;\n    let yoga = YogaRoutine;\n\n    println!(\"Basic Routine: {}, Duration: {} mins\", basic.exercises(), basic.duration());\n    println!(\"Yoga Routine: {}, Duration: {} mins\", yoga.exercises(), yoga.duration());\n}\n```"
  },
  {
    "task": "Set up a base class for a transportation ticket with methods for pricing and validity, and extend it with an airline ticket subclass that overrides these methods for baggage allowance.",
    "code": "```rust\ntrait Ticket {\n    fn price(&self) -> f64;\n    fn is_valid(&self) -> bool;\n}\n\nstruct TransportationTicket {\n    base_price: f64,\n    valid: bool,\n}\n\nimpl Ticket for TransportationTicket {\n    fn price(&self) -> f64 {\n        self.base_price\n    }\n\n    fn is_valid(&self) -> bool {\n        self.valid\n    }\n}\n\nstruct AirlineTicket {\n    base_ticket: TransportationTicket,\n    baggage_allowance: u32,\n}\n\nimpl Ticket for AirlineTicket {\n    fn price(&self) -> f64 {\n        // Assume baggage allowance affects the price\n        self.base_ticket.price() + (self.baggage_allowance as f64 * 10.0)\n    }\n\n    fn is_valid(&self) -> bool {\n        self.base_ticket.is_valid()\n    }\n}\n\nfn main() {\n    let transport_ticket = TransportationTicket {\n        base_price: 50.0,\n        valid: true,\n    };\n\n    let airline_ticket = AirlineTicket {\n        base_ticket: transport_ticket,\n        baggage_allowance: 2,\n    };\n\n    println!(\"Airline Ticket Price: {}\", airline_ticket.price());\n    println!(\"Airline Ticket Valid: {}\", airline_ticket.is_valid());\n}\n```"
  },
  {
    "task": "Create a foundational class for a digital photo album with properties like album name and date, and derive a vacation album class that overrides the date property to be specific.",
    "code": "```rust\ntrait PhotoAlbum {\n    fn album_name(&self) -> &str;\n    fn date(&self) -> &str;\n}\n\nstruct BasicAlbum {\n    name: String,\n    date: String,\n}\n\nimpl PhotoAlbum for BasicAlbum {\n    fn album_name(&self) -> &str {\n        &self.name\n    }\n\n    fn date(&self) -> &str {\n        &self.date\n    }\n}\n\nstruct VacationAlbum {\n    name: String,\n    vacation_date: String,\n}\n\nimpl PhotoAlbum for VacationAlbum {\n    fn album_name(&self) -> &str {\n        &self.name\n    }\n\n    fn date(&self) -> &str {\n        &self.vacation_date\n    }\n}\n```"
  },
  {
    "task": "Design a base class for a home appliance with methods for power usage and warranty, then create a refrigerator subclass that overrides these methods for energy efficiency.",
    "code": "```rust\ntrait HomeAppliance {\n    fn power_usage(&self) -> f32;\n    fn warranty(&self) -> u32;\n}\n\nstruct Refrigerator {\n    energy_efficiency: f32,\n    warranty_years: u32,\n}\n\nimpl HomeAppliance for Refrigerator {\n    fn power_usage(&self) -> f32 {\n        100.0 * self.energy_efficiency\n    }\n\n    fn warranty(&self) -> u32 {\n        self.warranty_years\n    }\n}\n\nfn main() {\n    let fridge = Refrigerator {\n        energy_efficiency: 0.8,\n        warranty_years: 2,\n    };\n\n    println!(\"Refrigerator power usage: {} watts\", fridge.power_usage());\n    println!(\"Refrigerator warranty: {} years\", fridge.warranty());\n}\n```"
  },
  {
    "task": "Develop a superclass for a software update with methods for versioning and patch notes, then extend it with a security update subclass that overrides these methods for vulnerabilities.",
    "code": "```rust\nstruct SoftwareUpdate {\n    version: String,\n    patch_notes: String,\n}\n\nimpl SoftwareUpdate {\n    fn new(version: &str, patch_notes: &str) -> Self {\n        SoftwareUpdate {\n            version: version.to_string(),\n            patch_notes: patch_notes.to_string(),\n        }\n    }\n\n    fn get_version(&self) -> &str {\n        &self.version\n    }\n\n    fn get_patch_notes(&self) -> &str {\n        &self.patch_notes\n    }\n}\n\nstruct SecurityUpdate {\n    base: SoftwareUpdate,\n    vulnerabilities: String,\n}\n\nimpl SecurityUpdate {\n    fn new(version: &str, patch_notes: &str, vulnerabilities: &str) -> Self {\n        SecurityUpdate {\n            base: SoftwareUpdate::new(version, patch_notes),\n            vulnerabilities: vulnerabilities.to_string(),\n        }\n    }\n\n    fn get_version(&self) -> &str {\n        self.base.get_version()\n    }\n\n    fn get_patch_notes(&self) -> &str {\n        &self.vulnerabilities\n    }\n}\n```"
  },
  {
    "task": "Implement a base class for a musical performance with methods for rehearsal and execution, then create a concert performance subclass that overrides these methods for live audience.",
    "code": "```rust\ntrait Performance {\n    fn rehearsal(&self);\n    fn execution(&self);\n}\n\nstruct MusicalPerformance;\n\nimpl Performance for MusicalPerformance {\n    fn rehearsal(&self) {\n        println!(\"Rehearsing the musical performance.\");\n    }\n\n    fn execution(&self) {\n        println!(\"Executing the musical performance.\");\n    }\n}\n\nstruct ConcertPerformance;\n\nimpl Performance for ConcertPerformance {\n    fn rehearsal(&self) {\n        println!(\"Rehearsing the concert performance.\");\n    }\n\n    fn execution(&self) {\n        println!(\"Performing the concert for a live audience.\");\n    }\n}\n\nfn main() {\n    let musical = MusicalPerformance;\n    let concert = ConcertPerformance;\n\n    musical.rehearsal();\n    musical.execution();\n\n    concert.rehearsal();\n    concert.execution();\n}\n```"
  },
  {
    "task": "Construct a parent class for an academic degree with methods for course requirements and credits, then derive a master's degree class that overrides these methods for advanced studies.",
    "code": "```rust\ntrait Degree {\n    fn course_requirements(&self) -> String;\n    fn credits(&self) -> u32;\n}\n\nstruct AcademicDegree;\n\nimpl Degree for AcademicDegree {\n    fn course_requirements(&self) -> String {\n        String::from(\"Basic course requirements\")\n    }\n\n    fn credits(&self) -> u32 {\n        120\n    }\n}\n\nstruct MastersDegree;\n\nimpl Degree for MastersDegree {\n    fn course_requirements(&self) -> String {\n        String::from(\"Advanced course requirements\")\n    }\n\n    fn credits(&self) -> u32 {\n        180\n    }\n}\n```"
  },
  {
    "task": "Set up a base class for a weather forecast with methods for temperature and conditions, and extend it with a winter forecast subclass that overrides these methods for snow conditions.",
    "code": "```rust\ntrait WeatherForecast {\n    fn temperature(&self) -> String;\n    fn conditions(&self) -> String;\n}\n\nstruct BaseForecast;\n\nimpl WeatherForecast for BaseForecast {\n    fn temperature(&self) -> String {\n        \"Base temperature\".to_string()\n    }\n\n    fn conditions(&self) -> String {\n        \"Base conditions\".to_string()\n    }\n}\n\nstruct WinterForecast;\n\nimpl WeatherForecast for WinterForecast {\n    fn temperature(&self) -> String {\n        \"Winter temperature\".to_string()\n    }\n\n    fn conditions(&self) -> String {\n        \"Snow conditions\".to_string()\n    }\n}\n\nfn main() {\n    let base_forecast = BaseForecast;\n    let winter_forecast = WinterForecast;\n\n    println!(\"Base Forecast: Temperature - {}, Conditions - {}\", base_forecast.temperature(), base_forecast.conditions());\n    println!(\"Winter Forecast: Temperature - {}, Conditions - {}\", winter_forecast.temperature(), winter_forecast.conditions());\n}\n```"
  },
  {
    "task": "Create a foundational class for a personal diary with properties like date and entries, and derive a travel diary class that overrides the date property with travel dates.",
    "code": "```rust\nstruct PersonalDiary {\n    date: String,\n    entries: Vec<String>,\n}\n\nimpl PersonalDiary {\n    fn new(date: &str) -> Self {\n        PersonalDiary {\n            date: date.to_string(),\n            entries: Vec::new(),\n        }\n    }\n\n    fn add_entry(&mut self, entry: &str) {\n        self.entries.push(entry.to_string());\n    }\n}\n\nstruct TravelDiary {\n    personal_diary: PersonalDiary,\n    travel_dates: String,\n}\n\nimpl TravelDiary {\n    fn new(travel_dates: &str) -> Self {\n        TravelDiary {\n            personal_diary: PersonalDiary::new(\"\"),\n            travel_dates: travel_dates.to_string(),\n        }\n    }\n\n    fn add_travel_entry(&mut self, entry: &str) {\n        self.personal_diary.add_entry(entry);\n    }\n}\n```"
  },
  {
    "task": "Design a base class for a pet with methods for feeding and grooming, then create a cat subclass that overrides these methods with specific food preferences.",
    "code": "```rust\ntrait Pet {\n    fn feed(&self);\n    fn groom(&self);\n}\n\nstruct Cat;\n\nimpl Pet for Cat {\n    fn feed(&self) {\n        println!(\"Feeding the cat with fish.\");\n    }\n    \n    fn groom(&self) {\n        println!(\"Grooming the cat with a brush.\");\n    }\n}\n\nfn main() {\n    let my_cat = Cat;\n    my_cat.feed();\n    my_cat.groom();\n}\n```"
  },
  {
    "task": "Develop a superclass for a software library with methods for installation and updates, then extend it with a graphics library subclass that overrides these methods for rendering capabilities.",
    "code": "```rust\ntrait Library {\n    fn install(&self);\n    fn update(&self);\n}\n\nstruct SoftwareLibrary;\n\nimpl Library for SoftwareLibrary {\n    fn install(&self) {\n        println!(\"Installing software library...\");\n    }\n\n    fn update(&self) {\n        println!(\"Updating software library...\");\n    }\n}\n\nstruct GraphicsLibrary;\n\nimpl Library for GraphicsLibrary {\n    fn install(&self) {\n        println!(\"Installing graphics library with rendering capabilities...\");\n    }\n\n    fn update(&self) {\n        println!(\"Updating graphics library with rendering enhancements...\");\n    }\n}\n\nfn main() {\n    let software_lib = SoftwareLibrary;\n    let graphics_lib = GraphicsLibrary;\n\n    software_lib.install();\n    software_lib.update();\n    graphics_lib.install();\n    graphics_lib.update();\n}\n```"
  },
  {
    "task": "Implement a base class for a political campaign with methods for fundraising and events, then create a presidential campaign subclass that overrides these methods for national scale.",
    "code": "```rust\ntrait Campaign {\n    fn fundraising(&self) -> String;\n    fn events(&self) -> String;\n}\n\nstruct PoliticalCampaign;\n\nimpl Campaign for PoliticalCampaign {\n    fn fundraising(&self) -> String {\n        \"Local fundraising strategy\".to_string()\n    }\n\n    fn events(&self) -> String {\n        \"Local events strategy\".to_string()\n    }\n}\n\nstruct PresidentialCampaign;\n\nimpl Campaign for PresidentialCampaign {\n    fn fundraising(&self) -> String {\n        \"National fundraising strategy\".to_string()\n    }\n\n    fn events(&self) -> String {\n        \"National events strategy\".to_string()\n    }\n}\n\nfn main() {\n    let local_campaign = PoliticalCampaign;\n    let national_campaign = PresidentialCampaign;\n\n    println!(\"Local Campaign Fundraising: {}\", local_campaign.fundraising());\n    println!(\"Local Campaign Events: {}\", local_campaign.events());\n\n    println!(\"Presidential Campaign Fundraising: {}\", national_campaign.fundraising());\n    println!(\"Presidential Campaign Events: {}\", national_campaign.events());\n}\n```"
  },
  {
    "task": "Construct a parent class for an automotive part with methods for durability and replacement, then derive an engine part class that overrides these methods for performance.",
    "code": "```rust\ntrait AutomotivePart {\n    fn durability(&self) -> String;\n    fn replacement(&self) -> String;\n}\n\nstruct GenericPart;\n\nimpl AutomotivePart for GenericPart {\n    fn durability(&self) -> String {\n        String::from(\"Generic part durability\")\n    }\n\n    fn replacement(&self) -> String {\n        String::from(\"Generic part replacement\")\n    }\n}\n\nstruct EnginePart;\n\nimpl AutomotivePart for EnginePart {\n    fn durability(&self) -> String {\n        String::from(\"Engine part high durability\")\n    }\n\n    fn replacement(&self) -> String {\n        String::from(\"Engine part requires specialized replacement\")\n    }\n}\n\nfn main() {\n    let generic_part = GenericPart;\n    let engine_part = EnginePart;\n\n    println!(\"{}\", generic_part.durability());\n    println!(\"{}\", generic_part.replacement());\n    println!(\"{}\", engine_part.durability());\n    println!(\"{}\", engine_part.replacement());\n}\n```"
  },
  {
    "task": "Set up a base class for an online tutorial with methods for lessons and quizzes, and extend it with a coding tutorial subclass that overrides these methods for interactive exercises.",
    "code": "```rust\ntrait Tutorial {\n    fn lesson(&self) -> String;\n    fn quiz(&self) -> String;\n}\n\nstruct OnlineTutorial;\n\nimpl Tutorial for OnlineTutorial {\n    fn lesson(&self) -> String {\n        String::from(\"Standard lesson content\")\n    }\n\n    fn quiz(&self) -> String {\n        String::from(\"Standard quiz content\")\n    }\n}\n\nstruct CodingTutorial;\n\nimpl Tutorial for CodingTutorial {\n    fn lesson(&self) -> String {\n        String::from(\"Interactive coding lesson\")\n    }\n\n    fn quiz(&self) -> String {\n        String::from(\"Interactive coding quiz\")\n    }\n}\n\nfn main() {\n    let standard_tutorial = OnlineTutorial;\n    let coding_tutorial = CodingTutorial;\n\n    println!(\"Online Tutorial Lesson: {}\", standard_tutorial.lesson());\n    println!(\"Online Tutorial Quiz: {}\", standard_tutorial.quiz());\n\n    println!(\"Coding Tutorial Lesson: {}\", coding_tutorial.lesson());\n    println!(\"Coding Tutorial Quiz: {}\", coding_tutorial.quiz());\n}\n```"
  },
  {
    "task": "Create a foundational class for a personal collection with properties like item type and value, and derive a stamp collection class that overrides the item type property to be 'stamps'.",
    "code": "```rust\nstruct Collection {\n    item_type: String,\n    value: f64,\n}\n\nimpl Collection {\n    fn new(item_type: &str, value: f64) -> Self {\n        Self {\n            item_type: item_type.to_string(),\n            value,\n        }\n    }\n}\n\nstruct StampCollection {\n    collection: Collection,\n}\n\nimpl StampCollection {\n    fn new(value: f64) -> Self {\n        Self {\n            collection: Collection::new(\"stamps\", value),\n        }\n    }\n}\n```"
  },
  {
    "task": "Design a base class for a video game character with methods for health and abilities, then create a warrior character subclass that overrides these methods for strength.",
    "code": "```rust\ntrait Character {\n    fn health(&self) -> u32;\n    fn abilities(&self) -> String;\n}\n\nstruct BaseCharacter {\n    health: u32,\n    abilities: String,\n}\n\nimpl Character for BaseCharacter {\n    fn health(&self) -> u32 {\n        self.health\n    }\n\n    fn abilities(&self) -> String {\n        self.abilities.clone()\n    }\n}\n\nstruct WarriorCharacter {\n    base: BaseCharacter,\n    strength: u32,\n}\n\nimpl Character for WarriorCharacter {\n    fn health(&self) -> u32 {\n        self.base.health + self.strength\n    }\n\n    fn abilities(&self) -> String {\n        format!(\"{}, Strength: {}\", self.base.abilities, self.strength)\n    }\n}\n\nfn main() {\n    let base_character = BaseCharacter {\n        health: 100,\n        abilities: String::from(\"Basic Attack\"),\n    };\n\n    let warrior = WarriorCharacter {\n        base: base_character,\n        strength: 50,\n    };\n\n    println!(\"Warrior Health: {}\", warrior.health());\n    println!(\"Warrior Abilities: {}\", warrior.abilities());\n}\n```"
  },
  {
    "task": "Develop a superclass for an event planner with methods for scheduling and budgeting, then extend it with a wedding planner subclass that overrides these methods for ceremony details.",
    "code": "```rust\ntrait EventPlanner {\n    fn schedule(&self) -> String;\n    fn budget(&self) -> f64;\n}\n\nstruct BasicEventPlanner;\n\nimpl EventPlanner for BasicEventPlanner {\n    fn schedule(&self) -> String {\n        \"Generic event schedule\".to_string()\n    }\n\n    fn budget(&self) -> f64 {\n        1000.0\n    }\n}\n\nstruct WeddingPlanner;\n\nimpl EventPlanner for WeddingPlanner {\n    fn schedule(&self) -> String {\n        \"Wedding ceremony schedule with detailed itinerary\".to_string()\n    }\n\n    fn budget(&self) -> f64 {\n        5000.0\n    }\n}\n\nfn main() {\n    let general_event = BasicEventPlanner;\n    let wedding_event = WeddingPlanner;\n\n    println!(\"General Event Schedule: {}\", general_event.schedule());\n    println!(\"General Event Budget: ${}\", general_event.budget());\n\n    println!(\"Wedding Event Schedule: {}\", wedding_event.schedule());\n    println!(\"Wedding Event Budget: ${}\", wedding_event.budget());\n}\n```"
  },
  {
    "task": "Implement a base class for a software feature with methods for functionality and user feedback, then create a beta feature subclass that overrides these methods for testing.",
    "code": "```rust\ntrait Feature {\n    fn functionality(&self) -> String;\n    fn user_feedback(&self) -> String;\n}\n\nstruct BaseFeature;\n\nimpl Feature for BaseFeature {\n    fn functionality(&self) -> String {\n        String::from(\"Base feature functionality\")\n    }\n    \n    fn user_feedback(&self) -> String {\n        String::from(\"Base feature feedback\")\n    }\n}\n\nstruct BetaFeature;\n\nimpl Feature for BetaFeature {\n    fn functionality(&self) -> String {\n        String::from(\"Beta feature functionality\")\n    }\n    \n    fn user_feedback(&self) -> String {\n        String::from(\"Beta feature feedback\")\n    }\n}\n\nfn main() {\n    let base = BaseFeature;\n    let beta = BetaFeature;\n\n    println!(\"{}\", base.functionality());\n    println!(\"{}\", base.user_feedback());\n    \n    println!(\"{}\", beta.functionality());\n    println!(\"{}\", beta.user_feedback());\n}\n```"
  },
  {
    "task": "Construct a parent class for a gardening tool with methods for usage and maintenance, then derive a lawn mower class that overrides these methods for grass cutting.",
    "code": "```rust\ntrait GardeningTool {\n    fn usage(&self) -> String;\n    fn maintenance(&self) -> String;\n}\n\nstruct LawnMower;\n\nimpl GardeningTool for LawnMower {\n    fn usage(&self) -> String {\n        String::from(\"Use the lawn mower to cut the grass.\")\n    }\n\n    fn maintenance(&self) -> String {\n        String::from(\"Ensure the lawn mower blades are sharp and clean.\")\n    }\n}\n\nfn main() {\n    let lawn_mower = LawnMower;\n    println!(\"{}\", lawn_mower.usage());\n    println!(\"{}\", lawn_mower.maintenance());\n}\n```"
  },
  {
    "task": "Set up a base class for a household chore with methods for time and effort, and extend it with a cleaning chore subclass that overrides these methods for dirt removal.",
    "code": "```rust\ntrait HouseholdChore {\n    fn time(&self) -> u32;\n    fn effort(&self) -> u32;\n}\n\nstruct CleaningChore;\n\nimpl HouseholdChore for CleaningChore {\n    fn time(&self) -> u32 {\n        // Custom logic for cleaning chore time\n        30\n    }\n    \n    fn effort(&self) -> u32 {\n        // Custom logic for cleaning chore effort\n        20\n    }\n}\n```"
  },
  {
    "task": "Create a foundational class for a personal project with properties like name and deadline, and derive a coding project class that overrides the deadline property for milestones.",
    "code": "```rust\ntrait Project {\n    fn name(&self) -> &str;\n    fn deadline(&self) -> &str;\n}\n\nstruct BaseProject {\n    name: String,\n    deadline: String,\n}\n\nimpl Project for BaseProject {\n    fn name(&self) -> &str {\n        &self.name\n    }\n\n    fn deadline(&self) -> &str {\n        &self.deadline\n    }\n}\n\nstruct CodingProject {\n    base: BaseProject,\n    milestone_deadline: String,\n}\n\nimpl Project for CodingProject {\n    fn name(&self) -> &str {\n        self.base.name()\n    }\n\n    fn deadline(&self) -> &str {\n        &self.milestone_deadline\n    }\n}\n```"
  },
  {
    "task": "Design a base class for a holiday celebration with methods for traditions and activities, then create a Christmas celebration subclass that overrides these methods for gift exchange.",
    "code": "```rust\ntrait Celebration {\n    fn traditions(&self) -> String;\n    fn activities(&self) -> String;\n}\n\nstruct Holiday;\n\nimpl Celebration for Holiday {\n    fn traditions(&self) -> String {\n        \"General traditions\".to_string()\n    }\n\n    fn activities(&self) -> String {\n        \"General activities\".to_string()\n    }\n}\n\nstruct Christmas;\n\nimpl Celebration for Christmas {\n    fn traditions(&self) -> String {\n        \"Christmas traditions\".to_string()\n    }\n\n    fn activities(&self) -> String {\n        \"Gift exchange\".to_string()\n    }\n}\n```"
  },
  {
    "task": "Develop a superclass for a customer feedback system with methods for collecting and analyzing, then extend it with a product feedback subclass that overrides these methods for reviews.",
    "code": "```rust\ntrait Feedback {\n    fn collect(&self);\n    fn analyze(&self);\n}\n\nstruct CustomerFeedback;\n\nimpl Feedback for CustomerFeedback {\n    fn collect(&self) {\n        println!(\"Collecting customer feedback...\");\n    }\n\n    fn analyze(&self) {\n        println!(\"Analyzing customer feedback...\");\n    }\n}\n\nstruct ProductFeedback;\n\nimpl Feedback for ProductFeedback {\n    fn collect(&self) {\n        println!(\"Collecting product feedback reviews...\");\n    }\n\n    fn analyze(&self) {\n        println!(\"Analyzing product feedback reviews...\");\n    }\n}\n\nfn main() {\n    let customer_feedback = CustomerFeedback;\n    customer_feedback.collect();\n    customer_feedback.analyze();\n\n    let product_feedback = ProductFeedback;\n    product_feedback.collect();\n    product_feedback.analyze();\n}\n```"
  },
  {
    "task": "Implement a base class for a civic service with methods for public engagement and policy, then create a community service subclass that overrides these methods for local impact.",
    "code": "```rust\ntrait CivicService {\n    fn public_engagement(&self);\n    fn policy(&self);\n}\n\nstruct CommunityService;\n\nimpl CivicService for CommunityService {\n    fn public_engagement(&self) {\n        println!(\"Engaging with the local community.\");\n    }\n\n    fn policy(&self) {\n        println!(\"Implementing local policies.\");\n    }\n}\n\nfn main() {\n    let service = CommunityService;\n    service.public_engagement();\n    service.policy();\n}\n```"
  },
  {
    "task": "Construct a parent class for a culinary ingredient with methods for flavor and preparation, then derive a spice ingredient class that overrides these methods for seasoning.",
    "code": "```rust\ntrait Ingredient {\n    fn flavor(&self) -> String;\n    fn preparation(&self) -> String;\n}\n\nstruct CulinaryIngredient;\n\nimpl Ingredient for CulinaryIngredient {\n    fn flavor(&self) -> String {\n        String::from(\"Generic flavor\")\n    }\n\n    fn preparation(&self) -> String {\n        String::from(\"Generic preparation\")\n    }\n}\n\nstruct SpiceIngredient;\n\nimpl Ingredient for SpiceIngredient {\n    fn flavor(&self) -> String {\n        String::from(\"Spicy flavor\")\n    }\n\n    fn preparation(&self) -> String {\n        String::from(\"Ground and sprinkled\")\n    }\n}\n```"
  },
  {
    "task": "Set up a base class for a scientific experiment with methods for hypothesis and testing, and extend it with a chemistry experiment subclass that overrides these methods for reactions.",
    "code": "```rust\ntrait Experiment {\n    fn hypothesis(&self) -> String;\n    fn testing(&self) -> String;\n}\n\nstruct BaseExperiment;\n\nimpl Experiment for BaseExperiment {\n    fn hypothesis(&self) -> String {\n        String::from(\"General hypothesis for an experiment.\")\n    }\n\n    fn testing(&self) -> String {\n        String::from(\"General testing procedure for an experiment.\")\n    }\n}\n\nstruct ChemistryExperiment;\n\nimpl Experiment for ChemistryExperiment {\n    fn hypothesis(&self) -> String {\n        String::from(\"Hypothesis specific to a chemistry reaction.\")\n    }\n\n    fn testing(&self) -> String {\n        String::from(\"Testing procedure specific to a chemistry reaction.\")\n    }\n}\n\nfn main() {\n    let base_experiment = BaseExperiment;\n    let chemistry_experiment = ChemistryExperiment;\n\n    println!(\"Base Experiment Hypothesis: {}\", base_experiment.hypothesis());\n    println!(\"Base Experiment Testing: {}\", base_experiment.testing());\n    println!(\"Chemistry Experiment Hypothesis: {}\", chemistry_experiment.hypothesis());\n    println!(\"Chemistry Experiment Testing: {}\", chemistry_experiment.testing());\n}\n```"
  },
  {
    "task": "Create a foundational class for an inventory system with properties like item ID and quantity, and derive a warehouse inventory class that overrides the quantity property for bulk storage.",
    "code": "```rust\nstruct InventoryItem {\n    item_id: u32,\n    quantity: u32,\n}\n\nimpl InventoryItem {\n    fn new(item_id: u32, quantity: u32) -> Self {\n        InventoryItem { item_id, quantity }\n    }\n\n    fn get_quantity(&self) -> u32 {\n        self.quantity\n    }\n}\n\nstruct WarehouseInventory {\n    base: InventoryItem,\n    bulk_quantity: u32,\n}\n\nimpl WarehouseInventory {\n    fn new(item_id: u32, bulk_quantity: u32) -> Self {\n        WarehouseInventory {\n            base: InventoryItem::new(item_id, 0),\n            bulk_quantity,\n        }\n    }\n\n    fn get_quantity(&self) -> u32 {\n        self.bulk_quantity\n    }\n}\n```"
  },
  {
    "task": "Design a base class for a travel agency with methods for itinerary and bookings, then create a luxury travel subclass that overrides these methods for premium services.",
    "code": "```rust\ntrait TravelAgency {\n    fn itinerary(&self) -> String;\n    fn bookings(&self) -> String;\n}\n\nstruct BaseTravelAgency;\n\nimpl TravelAgency for BaseTravelAgency {\n    fn itinerary(&self) -> String {\n        String::from(\"Standard itinerary\")\n    }\n\n    fn bookings(&self) -> String {\n        String::from(\"Standard bookings\")\n    }\n}\n\nstruct LuxuryTravelAgency;\n\nimpl TravelAgency for LuxuryTravelAgency {\n    fn itinerary(&self) -> String {\n        String::from(\"Premium itinerary with exclusive destinations\")\n    }\n\n    fn bookings(&self) -> String {\n        String::from(\"Premium bookings with luxury accommodations\")\n    }\n}\n```"
  },
  {
    "task": "Develop a superclass for an educational tool with methods for teaching and assessment, then extend it with a math tool subclass that overrides these methods for problem-solving.",
    "code": "```rust\ntrait EducationalTool {\n    fn teach(&self);\n    fn assess(&self);\n}\n\nstruct MathTool;\n\nimpl EducationalTool for MathTool {\n    fn teach(&self) {\n        println!(\"Teaching math problems...\");\n    }\n\n    fn assess(&self) {\n        println!(\"Assessing math solutions...\");\n    }\n}\n\nfn main() {\n    let math_tool = MathTool;\n    math_tool.teach();\n    math_tool.assess();\n}\n```"
  },
  {
    "task": "Implement a base class for a community project with methods for planning and execution, then create a park renovation subclass that overrides these methods for landscaping.",
    "code": "```rust\ntrait Project {\n    fn plan(&self);\n    fn execute(&self);\n}\n\nstruct CommunityProject;\n\nimpl Project for CommunityProject {\n    fn plan(&self) {\n        println!(\"Planning the community project.\");\n    }\n\n    fn execute(&self) {\n        println!(\"Executing the community project.\");\n    }\n}\n\nstruct ParkRenovation;\n\nimpl Project for ParkRenovation {\n    fn plan(&self) {\n        println!(\"Planning the park renovation with landscaping.\");\n    }\n\n    fn execute(&self) {\n        println!(\"Executing the park renovation with landscaping.\");\n    }\n}\n\nfn main() {\n    let community_project = CommunityProject;\n    community_project.plan();\n    community_project.execute();\n\n    let park_renovation = ParkRenovation;\n    park_renovation.plan();\n    park_renovation.execute();\n}\n```"
  },
  {
    "task": "Construct a parent class for a digital marketing strategy with methods for targeting and engagement, then derive a social media strategy class that overrides these methods for platforms.",
    "code": "```rust\ntrait MarketingStrategy {\n    fn targeting(&self) -> String;\n    fn engagement(&self) -> String;\n}\n\nstruct DigitalMarketingStrategy;\n\nimpl MarketingStrategy for DigitalMarketingStrategy {\n    fn targeting(&self) -> String {\n        String::from(\"Generic targeting strategy\")\n    }\n    \n    fn engagement(&self) -> String {\n        String::from(\"Generic engagement strategy\")\n    }\n}\n\nstruct SocialMediaStrategy;\n\nimpl MarketingStrategy for SocialMediaStrategy {\n    fn targeting(&self) -> String {\n        String::from(\"Social media targeting strategy\")\n    }\n    \n    fn engagement(&self) -> String {\n        String::from(\"Social media engagement strategy\")\n    }\n}\n\nfn main() {\n    let digital_strategy = DigitalMarketingStrategy;\n    let social_media_strategy = SocialMediaStrategy;\n\n    println!(\"Digital Strategy Targeting: {}\", digital_strategy.targeting());\n    println!(\"Digital Strategy Engagement: {}\", digital_strategy.engagement());\n    println!(\"Social Media Strategy Targeting: {}\", social_media_strategy.targeting());\n    println!(\"Social Media Strategy Engagement: {}\", social_media_strategy.engagement());\n}\n```"
  },
  {
    "task": "Set up a base class for a scientific publication with methods for research and review, and extend it with a journal article subclass that overrides these methods for peer review.",
    "code": "```rust\ntrait ScientificPublication {\n    fn research(&self);\n    fn review(&self);\n}\n\nstruct JournalArticle;\n\nimpl ScientificPublication for JournalArticle {\n    fn research(&self) {\n        println!(\"Conducting research for journal article.\");\n    }\n\n    fn review(&self) {\n        println!(\"Peer reviewing journal article.\");\n    }\n}\n\nfn main() {\n    let article = JournalArticle;\n    article.research();\n    article.review();\n}\n```"
  },
  {
    "task": "Create a foundational class for a software module with properties like name and dependencies, and derive a user interface module class that overrides the dependencies property for UI libraries.",
    "code": "```rust\ntrait Module {\n    fn name(&self) -> &str;\n    fn dependencies(&self) -> Vec<String>;\n}\n\nstruct BaseModule {\n    module_name: String,\n    module_dependencies: Vec<String>,\n}\n\nimpl Module for BaseModule {\n    fn name(&self) -> &str {\n        &self.module_name\n    }\n\n    fn dependencies(&self) -> Vec<String> {\n        self.module_dependencies.clone()\n    }\n}\n\nstruct UIModule {\n    base: BaseModule,\n    ui_dependencies: Vec<String>,\n}\n\nimpl Module for UIModule {\n    fn name(&self) -> &str {\n        &self.base.module_name\n    }\n\n    fn dependencies(&self) -> Vec<String> {\n        let mut deps = self.base.dependencies();\n        deps.extend(self.ui_dependencies.clone());\n        deps\n    }\n}\n\nfn main() {\n    let base_module = BaseModule {\n        module_name: String::from(\"Core\"),\n        module_dependencies: vec![String::from(\"lib1\"), String::from(\"lib2\")],\n    };\n\n    let ui_module = UIModule {\n        base: base_module,\n        ui_dependencies: vec![String::from(\"ui-lib1\"), String::from(\"ui-lib2\")],\n    };\n\n    println!(\"Module Name: {}\", ui_module.name());\n    println!(\"Dependencies: {:?}\", ui_module.dependencies());\n}\n```"
  },
  {
    "task": "Design a base class for a fashion line with methods for design and production, then create a summer collection subclass that overrides these methods for seasonal trends.",
    "code": "```rust\ntrait FashionLine {\n    fn design(&self) -> String;\n    fn production(&self) -> String;\n}\n\nstruct BaseCollection;\n\nimpl FashionLine for BaseCollection {\n    fn design(&self) -> String {\n        String::from(\"BaseCollection design\")\n    }\n\n    fn production(&self) -> String {\n        String::from(\"BaseCollection production\")\n    }\n}\n\nstruct SummerCollection;\n\nimpl FashionLine for SummerCollection {\n    fn design(&self) -> String {\n        String::from(\"SummerCollection design: Light fabrics and bright colors\")\n    }\n\n    fn production(&self) -> String {\n        String::from(\"SummerCollection production: Quick turnaround for seasonal demand\")\n    }\n}\n\nfn main() {\n    let base = BaseCollection;\n    println!(\"{}\", base.design());\n    println!(\"{}\", base.production());\n\n    let summer = SummerCollection;\n    println!(\"{}\", summer.design());\n    println!(\"{}\", summer.production());\n}\n```"
  },
  {
    "task": "Develop a superclass for a family tree with methods for ancestry and descendants, then extend it with a royal lineage subclass that overrides these methods for historical accuracy.",
    "code": "```rust\ntrait FamilyTree {\n    fn ancestry(&self) -> Vec<String>;\n    fn descendants(&self) -> Vec<String>;\n}\n\nstruct GeneralFamily {\n    ancestors: Vec<String>,\n    descendants: Vec<String>,\n}\n\nimpl FamilyTree for GeneralFamily {\n    fn ancestry(&self) -> Vec<String> {\n        self.ancestors.clone()\n    }\n\n    fn descendants(&self) -> Vec<String> {\n        self.descendants.clone()\n    }\n}\n\nstruct RoyalLineage {\n    ancestors: Vec<String>,\n    descendants: Vec<String>,\n}\n\nimpl FamilyTree for RoyalLineage {\n    fn ancestry(&self) -> Vec<String> {\n        let mut royal_ancestors = self.ancestors.clone();\n        royal_ancestors.insert(0, String::from(\"Historical King\"));\n        royal_ancestors\n    }\n\n    fn descendants(&self) -> Vec<String> {\n        let mut royal_descendants = self.descendants.clone();\n        royal_descendants.push(String::from(\"Future Heir\"));\n        royal_descendants\n    }\n}\n\nfn main() {\n    let general_family = GeneralFamily {\n        ancestors: vec![String::from(\"Parent\"), String::from(\"Grandparent\")],\n        descendants: vec![String::from(\"Child\"), String::from(\"Grandchild\")],\n    };\n\n    let royal_lineage = RoyalLineage {\n        ancestors: vec![String::from(\"King\"), String::from(\"Queen\")],\n        descendants: vec![String::from(\"Prince\"), String::from(\"Princess\")],\n    };\n\n    println!(\"General Family Ancestors: {:?}\", general_family.ancestry());\n    println!(\"General Family Descendants: {:?}\", general_family.descendants());\n\n    println!(\"Royal Lineage Ancestors: {:?}\", royal_lineage.ancestry());\n    println!(\"Royal Lineage Descendants: {:?}\", royal_lineage.descendants());\n}\n```"
  },
  {
    "task": "Implement a base class for a musical score with methods for composition and arrangement, then create a symphony subclass that overrides these methods for orchestration.",
    "code": "```rust\ntrait MusicalScore {\n    fn composition(&self) -> String;\n    fn arrangement(&self) -> String;\n}\n\nstruct Symphony;\n\nimpl MusicalScore for Symphony {\n    fn composition(&self) -> String {\n        String::from(\"Symphony composition with orchestration\")\n    }\n\n    fn arrangement(&self) -> String {\n        String::from(\"Symphony arrangement with orchestration\")\n    }\n}\n\nfn main() {\n    let symphony = Symphony;\n    println!(\"{}\", symphony.composition());\n    println!(\"{}\", symphony.arrangement());\n}\n```"
  },
  {
    "task": "Construct a parent class for a historical record with methods for events and dates, then derive a war history class that overrides these methods for battles.",
    "code": "```rust\ntrait HistoricalRecord {\n    fn events(&self) -> String;\n    fn dates(&self) -> String;\n}\n\nstruct GeneralHistory;\n\nimpl HistoricalRecord for GeneralHistory {\n    fn events(&self) -> String {\n        \"General historical events\".to_string()\n    }\n\n    fn dates(&self) -> String {\n        \"General historical dates\".to_string()\n    }\n}\n\nstruct WarHistory;\n\nimpl HistoricalRecord for WarHistory {\n    fn events(&self) -> String {\n        \"Battle events\".to_string()\n    }\n\n    fn dates(&self) -> String {\n        \"Battle dates\".to_string()\n    }\n}\n\nfn main() {\n    let general_history = GeneralHistory;\n    let war_history = WarHistory;\n\n    println!(\"General History Events: {}\", general_history.events());\n    println!(\"General History Dates: {}\", general_history.dates());\n    println!(\"War History Events: {}\", war_history.events());\n    println!(\"War History Dates: {}\", war_history.dates());\n}\n```"
  },
  {
    "task": "Set up a base class for a pet adoption service with methods for application and approval, and extend it with a dog adoption subclass that overrides these methods for breed compatibility.",
    "code": "```rust\nstruct PetAdoption {\n    pet_type: String,\n}\n\nimpl PetAdoption {\n    fn new(pet_type: &str) -> Self {\n        PetAdoption {\n            pet_type: pet_type.to_string(),\n        }\n    }\n\n    fn apply(&self) {\n        println!(\"Application received for adopting a {}.\", self.pet_type);\n    }\n\n    fn approve(&self) {\n        println!(\"Application approved for adopting a {}.\", self.pet_type);\n    }\n}\n\nstruct DogAdoption {\n    breed: String,\n    base: PetAdoption,\n}\n\nimpl DogAdoption {\n    fn new(breed: &str) -> Self {\n        DogAdoption {\n            breed: breed.to_string(),\n            base: PetAdoption::new(\"dog\"),\n        }\n    }\n\n    fn apply(&self) {\n        println!(\n            \"Application received for adopting a {} of breed {}.\",\n            self.base.pet_type, self.breed\n        );\n    }\n\n    fn approve(&self) {\n        println!(\n            \"Application approved for adopting a {} of breed {}.\",\n            self.base.pet_type, self.breed\n        );\n    }\n}\n\nfn main() {\n    let pet_adoption = PetAdoption::new(\"cat\");\n    pet_adoption.apply();\n    pet_adoption.approve();\n\n    let dog_adoption = DogAdoption::new(\"Labrador\");\n    dog_adoption.apply();\n    dog_adoption.approve();\n}\n```"
  },
  {
    "task": "Create a foundational class for a financial report with properties like fiscal year and summary, and derive an annual report class that overrides the fiscal year property for yearly data.",
    "code": "```rust\ntrait Report {\n    fn fiscal_year(&self) -> u32;\n    fn summary(&self) -> &str;\n}\n\nstruct FinancialReport {\n    year: u32,\n    summary: String,\n}\n\nimpl Report for FinancialReport {\n    fn fiscal_year(&self) -> u32 {\n        self.year\n    }\n\n    fn summary(&self) -> &str {\n        &self.summary\n    }\n}\n\nstruct AnnualReport {\n    report: FinancialReport,\n}\n\nimpl Report for AnnualReport {\n    fn fiscal_year(&self) -> u32 {\n        self.report.year + 1 // Example of overriding for a new year\n    }\n\n    fn summary(&self) -> &str {\n        &self.report.summary\n    }\n}\n```"
  },
  {
    "task": "Design a base class for a movie franchise with methods for casting and production, then create a sequel subclass that overrides these methods for continuity.",
    "code": "```rust\ntrait MovieFranchise {\n    fn casting(&self) -> String;\n    fn production(&self) -> String;\n}\n\nstruct BaseMovie;\n\nimpl MovieFranchise for BaseMovie {\n    fn casting(&self) -> String {\n        String::from(\"Base movie casting process\")\n    }\n\n    fn production(&self) -> String {\n        String::from(\"Base movie production process\")\n    }\n}\n\nstruct SequelMovie;\n\nimpl MovieFranchise for SequelMovie {\n    fn casting(&self) -> String {\n        String::from(\"Sequel movie casting process for continuity\")\n    }\n\n    fn production(&self) -> String {\n        String::from(\"Sequel movie production process for continuity\")\n    }\n}\n\nfn main() {\n    let base_movie = BaseMovie;\n    let sequel_movie = SequelMovie;\n\n    println!(\"{}\", base_movie.casting());\n    println!(\"{}\", base_movie.production());\n\n    println!(\"{}\", sequel_movie.casting());\n    println!(\"{}\", sequel_movie.production());\n}\n```"
  },
  {
    "task": "Develop a superclass for a real estate listing with methods for pricing and description, then extend it with a luxury listing subclass that overrides these methods for high-end features.",
    "code": "```rust\nstruct RealEstateListing {\n    price: f64,\n    description: String,\n}\n\nimpl RealEstateListing {\n    fn new(price: f64, description: &str) -> Self {\n        RealEstateListing {\n            price,\n            description: description.to_string(),\n        }\n    }\n\n    fn pricing(&self) -> String {\n        format!(\"Price: ${}\", self.price)\n    }\n\n    fn description(&self) -> String {\n        format!(\"Description: {}\", self.description)\n    }\n}\n\nstruct LuxuryListing {\n    base: RealEstateListing,\n    luxury_features: Vec<String>,\n}\n\nimpl LuxuryListing {\n    fn new(price: f64, description: &str, luxury_features: Vec<String>) -> Self {\n        LuxuryListing {\n            base: RealEstateListing::new(price, description),\n            luxury_features,\n        }\n    }\n}\n\nimpl RealEstateListing for LuxuryListing {\n    fn pricing(&self) -> String {\n        format!(\"Luxury Price: ${}\", self.base.price * 1.2)\n    }\n\n    fn description(&self) -> String {\n        let base_description = self.base.description();\n        let features = self.luxury_features.join(\", \");\n        format!(\"{} with luxury features: {}\", base_description, features)\n    }\n}\n```"
  },
  {
    "task": "Implement a base class for a mobile app with methods for user interface and performance, then create a gaming app subclass that overrides these methods for graphics and speed.",
    "code": "```rust\nstruct MobileApp;\n\nimpl MobileApp {\n    fn user_interface(&self) {\n        println!(\"Default mobile app interface\");\n    }\n\n    fn performance(&self) {\n        println!(\"Default mobile app performance\");\n    }\n}\n\nstruct GamingApp;\n\nimpl MobileApp for GamingApp {\n    fn user_interface(&self) {\n        println!(\"Enhanced graphics for gaming app interface\");\n    }\n\n    fn performance(&self) {\n        println!(\"Optimized performance for gaming app speed\");\n    }\n}\n\nfn main() {\n    let app = MobileApp;\n    app.user_interface();\n    app.performance();\n\n    let game_app = GamingApp;\n    game_app.user_interface();\n    game_app.performance();\n}\n```"
  },
  {
    "task": "Construct a parent class for a corporate policy with methods for compliance and enforcement, then derive an HR policy class that overrides these methods for employee relations.",
    "code": "```rust\ntrait CorporatePolicy {\n    fn compliance(&self) -> String {\n        String::from(\"General compliance rules\")\n    }\n\n    fn enforcement(&self) -> String {\n        String::from(\"General enforcement rules\")\n    }\n}\n\nstruct HRPolicy;\n\nimpl CorporatePolicy for HRPolicy {\n    fn compliance(&self) -> String {\n        String::from(\"HR-specific compliance rules for employee relations\")\n    }\n\n    fn enforcement(&self) -> String {\n        String::from(\"HR-specific enforcement rules for employee relations\")\n    }\n}\n\nfn main() {\n    let hr_policy = HRPolicy;\n    println!(\"{}\", hr_policy.compliance());\n    println!(\"{}\", hr_policy.enforcement());\n}\n```"
  },
  {
    "task": "Set up a base class for a scientific calculator with methods for basic operations and advanced functions, and extend it with a graphing calculator subclass that overrides these methods for plotting.",
    "code": "```rust\ntrait Calculator {\n    fn add(&self, a: f64, b: f64) -> f64;\n    fn subtract(&self, a: f64, b: f64) -> f64;\n    fn multiply(&self, a: f64, b: f64) -> f64;\n    fn divide(&self, a: f64, b: f64) -> f64;\n    fn advanced_function(&self, x: f64) -> f64;\n}\n\nstruct ScientificCalculator;\n\nimpl Calculator for ScientificCalculator {\n    fn add(&self, a: f64, b: f64) -> f64 {\n        a + b\n    }\n\n    fn subtract(&self, a: f64, b: f64) -> f64 {\n        a - b\n    }\n\n    fn multiply(&self, a: f64, b: f64) -> f64 {\n        a * b\n    }\n\n    fn divide(&self, a: f64, b: f64) -> f64 {\n        if b != 0.0 { a / b } else { f64::NAN }\n    }\n\n    fn advanced_function(&self, x: f64) -> f64 {\n        x.sin() + x.cos()\n    }\n}\n\nstruct GraphingCalculator;\n\nimpl Calculator for GraphingCalculator {\n    fn add(&self, a: f64, b: f64) -> f64 {\n        // Custom implementation for graphing\n        a + b // Placeholder\n    }\n\n    fn subtract(&self, a: f64, b: f64) -> f64 {\n        // Custom implementation for graphing\n        a - b // Placeholder\n    }\n\n    fn multiply(&self, a: f64, b: f64) -> f64 {\n        // Custom implementation for graphing\n        a * b // Placeholder\n    }\n\n    fn divide(&self, a: f64, b: f64) -> f64 {\n        // Custom implementation for graphing\n        if b != 0.0 { a / b } else { f64::NAN }\n    }\n\n    fn advanced_function(&self, x: f64) -> f64 {\n        // Custom implementation for graphing\n        x.tan() // Placeholder\n    }\n}\n```"
  },
  {
    "task": "Create a foundational class for a children's book with properties like age group and illustrations, and derive a picture book class that overrides the illustrations property to be more prominent.",
    "code": "```rust\ntrait Book {\n    fn age_group(&self) -> &str;\n    fn illustrations(&self) -> &str;\n}\n\nstruct ChildrensBook {\n    age_group: String,\n    illustrations: String,\n}\n\nimpl Book for ChildrensBook {\n    fn age_group(&self) -> &str {\n        &self.age_group\n    }\n\n    fn illustrations(&self) -> &str {\n        &self.illustrations\n    }\n}\n\nstruct PictureBook {\n    age_group: String,\n    illustrations: String,\n}\n\nimpl Book for PictureBook {\n    fn age_group(&self) -> &str {\n        &self.age_group\n    }\n\n    fn illustrations(&self) -> &str {\n        &format!(\"Prominent Illustrations: {}\", &self.illustrations)\n    }\n}\n\nfn main() {\n    let basic_book = ChildrensBook {\n        age_group: String::from(\"3-5 years\"),\n        illustrations: String::from(\"Basic illustrations\"),\n    };\n\n    let picture_book = PictureBook {\n        age_group: String::from(\"3-5 years\"),\n        illustrations: String::from(\"Rich illustrations\"),\n    };\n\n    println!(\"Children's Book: Age Group: {}, Illustrations: {}\", basic_book.age_group(), basic_book.illustrations());\n    println!(\"Picture Book: Age Group: {}, Illustrations: {}\", picture_book.age_group(), picture_book.illustrations());\n}\n```"
  },
  {
    "task": "Design a base class for a cooking class with methods for ingredients and techniques, then create a baking class subclass that overrides these methods for dough preparation.",
    "code": "```rust\ntrait Cooking {\n    fn ingredients(&self) -> String;\n    fn techniques(&self) -> String;\n}\n\nstruct Baking;\n\nimpl Cooking for Baking {\n    fn ingredients(&self) -> String {\n        String::from(\"Flour, Water, Yeast, Salt\")\n    }\n\n    fn techniques(&self) -> String {\n        String::from(\"Kneading, Fermenting, Shaping, Baking\")\n    }\n}\n\nfn main() {\n    let baking_class = Baking;\n    println!(\"Baking Ingredients: {}\", baking_class.ingredients());\n    println!(\"Baking Techniques: {}\", baking_class.techniques());\n}\n```"
  },
  {
    "task": "Develop a superclass for a public transportation system with methods for routes and schedules, then extend it with a metro system subclass that overrides these methods for urban areas.",
    "code": "```rust\nstruct PublicTransport {\n    routes: Vec<String>,\n    schedules: Vec<String>,\n}\n\nimpl PublicTransport {\n    fn new(routes: Vec<String>, schedules: Vec<String>) -> Self {\n        PublicTransport { routes, schedules }\n    }\n\n    fn get_routes(&self) -> &Vec<String> {\n        &self.routes\n    }\n\n    fn get_schedules(&self) -> &Vec<String> {\n        &self.schedules\n    }\n}\n\nstruct MetroSystem {\n    urban_routes: Vec<String>,\n    urban_schedules: Vec<String>,\n}\n\nimpl MetroSystem {\n    fn new(urban_routes: Vec<String>, urban_schedules: Vec<String>) -> Self {\n        MetroSystem {\n            urban_routes,\n            urban_schedules,\n        }\n    }\n}\n\nimpl MetroSystem {\n    fn get_routes(&self) -> &Vec<String> {\n        &self.urban_routes\n    }\n\n    fn get_schedules(&self) -> &Vec<String> {\n        &self.urban_schedules\n    }\n}\n```"
  },
  {
    "task": "Implement a base class for a music store inventory with methods for stock and sales, then create a vinyl record subclass that overrides these methods for collectible items.",
    "code": "```rust\nstruct InventoryItem {\n    name: String,\n    stock: u32,\n}\n\nimpl InventoryItem {\n    fn new(name: &str, stock: u32) -> Self {\n        InventoryItem {\n            name: name.to_string(),\n            stock,\n        }\n    }\n\n    fn sales(&mut self, amount: u32) {\n        if self.stock >= amount {\n            self.stock -= amount;\n        }\n    }\n\n    fn restock(&mut self, amount: u32) {\n        self.stock += amount;\n    }\n}\n\nstruct VinylRecord {\n    base: InventoryItem,\n    collectible: bool,\n}\n\nimpl VinylRecord {\n    fn new(name: &str, stock: u32, collectible: bool) -> Self {\n        VinylRecord {\n            base: InventoryItem::new(name, stock),\n            collectible,\n        }\n    }\n\n    fn sales(&mut self, amount: u32) {\n        if self.collectible {\n            println!(\"Cannot sell collectible vinyl records.\");\n        } else {\n            self.base.sales(amount);\n        }\n    }\n\n    fn restock(&mut self, amount: u32) {\n        if self.collectible {\n            println!(\"Cannot restock collectible vinyl records.\");\n        } else {\n            self.base.restock(amount);\n        }\n    }\n}\n```"
  },
  {
    "task": "Construct a parent class for a legal contract with methods for terms and conditions, then derive a rental agreement class that overrides these methods for tenant rights.",
    "code": "```rust\ntrait Contract {\n    fn terms_and_conditions(&self) -> String;\n}\n\nstruct LegalContract;\n\nimpl Contract for LegalContract {\n    fn terms_and_conditions(&self) -> String {\n        \"General terms and conditions of a legal contract.\".to_string()\n    }\n}\n\nstruct RentalAgreement;\n\nimpl Contract for RentalAgreement {\n    fn terms_and_conditions(&self) -> String {\n        \"Specific terms and conditions including tenant rights.\".to_string()\n    }\n}\n\nfn main() {\n    let legal_contract = LegalContract;\n    let rental_agreement = RentalAgreement;\n\n    println!(\"Legal Contract: {}\", legal_contract.terms_and_conditions());\n    println!(\"Rental Agreement: {}\", rental_agreement.terms_and_conditions());\n}\n```"
  },
  {
    "task": "Set up a base class for a journalism piece with methods for reporting and editing, and extend it with an investigative article subclass that overrides these methods for in-depth analysis.",
    "code": "```rust\ntrait JournalismPiece {\n    fn report(&self) -> String;\n    fn edit(&self) -> String;\n}\n\nstruct Article;\n\nimpl JournalismPiece for Article {\n    fn report(&self) -> String {\n        String::from(\"Reporting article...\")\n    }\n\n    fn edit(&self) -> String {\n        String::from(\"Editing article...\")\n    }\n}\n\nstruct InvestigativeArticle;\n\nimpl JournalismPiece for InvestigativeArticle {\n    fn report(&self) -> String {\n        String::from(\"Reporting investigative article in detail...\")\n    }\n\n    fn edit(&self) -> String {\n        String::from(\"Editing investigative article for in-depth analysis...\")\n    }\n}\n```"
  },
  {
    "task": "Create a foundational class for a wildlife reserve with properties like area and species, and derive a bird sanctuary class that overrides the species property for avians.",
    "code": "```rust\nstruct WildlifeReserve {\n    area: f64,\n    species: String,\n}\n\nimpl WildlifeReserve {\n    fn new(area: f64, species: &str) -> Self {\n        WildlifeReserve {\n            area,\n            species: species.to_string(),\n        }\n    }\n\n    fn species(&self) -> &str {\n        &self.species\n    }\n}\n\nstruct BirdSanctuary {\n    reserve: WildlifeReserve,\n}\n\nimpl BirdSanctuary {\n    fn new(area: f64) -> Self {\n        BirdSanctuary {\n            reserve: WildlifeReserve::new(area, \"Avians\"),\n        }\n    }\n}\n\nfn main() {\n    let bird_sanctuary = BirdSanctuary::new(150.0);\n    println!(\"Bird Sanctuary Area: {}\", bird_sanctuary.reserve.area);\n    println!(\"Bird Sanctuary Species: {}\", bird_sanctuary.reserve.species());\n}\n```"
  },
  {
    "task": "Design a base class for a subscription box service with methods for curation and delivery, then create a gourmet food box subclass that overrides these methods for artisanal products.",
    "code": "```rust\ntrait SubscriptionBox {\n    fn curate(&self) -> String;\n    fn deliver(&self) -> String;\n}\n\nstruct GourmetFoodBox;\n\nimpl SubscriptionBox for GourmetFoodBox {\n    fn curate(&self) -> String {\n        String::from(\"Curating artisanal gourmet food products.\")\n    }\n\n    fn deliver(&self) -> String {\n        String::from(\"Delivering gourmet food box.\")\n    }\n}\n\nfn main() {\n    let gourmet_box = GourmetFoodBox;\n    println!(\"{}\", gourmet_box.curate());\n    println!(\"{}\", gourmet_box.deliver());\n}\n```"
  },
  {
    "task": "Develop a superclass for a fitness app with methods for tracking and motivation, then extend it with a running app subclass that overrides these methods for pace and distance.",
    "code": "```rust\ntrait FitnessTracker {\n    fn track(&self);\n    fn motivate(&self);\n}\n\nstruct FitnessApp;\n\nimpl FitnessTracker for FitnessApp {\n    fn track(&self) {\n        println!(\"Tracking general fitness activities...\");\n    }\n\n    fn motivate(&self) {\n        println!(\"Keep going, you're doing great!\");\n    }\n}\n\nstruct RunningApp;\n\nimpl FitnessTracker for RunningApp {\n    fn track(&self) {\n        println!(\"Tracking running pace and distance...\");\n    }\n\n    fn motivate(&self) {\n        println!(\"Push your pace, you're almost there!\");\n    }\n}\n\nfn main() {\n    let fitness_app = FitnessApp;\n    let running_app = RunningApp;\n\n    fitness_app.track();\n    fitness_app.motivate();\n\n    running_app.track();\n    running_app.motivate();\n}\n```"
  },
  {
    "task": "Implement a base class for a digital portfolio with methods for showcasing and updating, then create an artist portfolio subclass that overrides these methods for galleries.",
    "code": "```rust\ntrait Portfolio {\n    fn showcase(&self);\n    fn update(&mut self);\n}\n\nstruct DigitalPortfolio {\n    content: String,\n}\n\nimpl Portfolio for DigitalPortfolio {\n    fn showcase(&self) {\n        println!(\"Showcasing digital portfolio: {}\", self.content);\n    }\n\n    fn update(&mut self) {\n        self.content.push_str(\" (updated)\");\n    }\n}\n\nstruct ArtistPortfolio {\n    art_pieces: Vec<String>,\n}\n\nimpl Portfolio for ArtistPortfolio {\n    fn showcase(&self) {\n        println!(\"Showcasing artist portfolio:\");\n        for piece in &self.art_pieces {\n            println!(\"Art piece: {}\", piece);\n        }\n    }\n\n    fn update(&mut self) {\n        self.art_pieces.push(\"New art piece\".to_string());\n    }\n}\n\nfn main() {\n    let mut digital_portfolio = DigitalPortfolio {\n        content: \"Initial digital content\".to_string(),\n    };\n    digital_portfolio.showcase();\n    digital_portfolio.update();\n    digital_portfolio.showcase();\n\n    let mut artist_portfolio = ArtistPortfolio {\n        art_pieces: vec![\"Art piece 1\".to_string()],\n    };\n    artist_portfolio.showcase();\n    artist_portfolio.update();\n    artist_portfolio.showcase();\n}\n```"
  },
  {
    "task": "Construct a parent class for a gaming console with methods for performance and compatibility, then derive a next-gen console class that overrides these methods for new features.",
    "code": "```rust\nstruct GamingConsole;\n\nimpl GamingConsole {\n    fn performance(&self) -> &str {\n        \"Standard Performance\"\n    }\n\n    fn compatibility(&self) -> &str {\n        \"Standard Compatibility\"\n    }\n}\n\nstruct NextGenConsole;\n\nimpl NextGenConsole {\n    fn performance(&self) -> &str {\n        \"Enhanced Performance\"\n    }\n\n    fn compatibility(&self) -> &str {\n        \"Advanced Compatibility\"\n    }\n}\n```"
  },
  {
    "task": "Set up a base class for a cultural festival with methods for events and participation, and extend it with a music festival subclass that overrides these methods for performances.",
    "code": "```rust\ntrait Festival {\n    fn events(&self) -> String;\n    fn participation(&self) -> String;\n}\n\nstruct CulturalFestival;\n\nimpl Festival for CulturalFestival {\n    fn events(&self) -> String {\n        \"Various cultural events\".to_string()\n    }\n\n    fn participation(&self) -> String {\n        \"Open to all participants\".to_string()\n    }\n}\n\nstruct MusicFestival;\n\nimpl Festival for MusicFestival {\n    fn events(&self) -> String {\n        \"Live music performances\".to_string()\n    }\n\n    fn participation(&self) -> String {\n        \"Musicians and bands\".to_string()\n    }\n}\n\nfn main() {\n    let cultural_festival = CulturalFestival;\n    let music_festival = MusicFestival;\n\n    println!(\"Cultural Festival Events: {}\", cultural_festival.events());\n    println!(\"Cultural Festival Participation: {}\", cultural_festival.participation());\n\n    println!(\"Music Festival Events: {}\", music_festival.events());\n    println!(\"Music Festival Participation: {}\", music_festival.participation());\n}\n```"
  }
]