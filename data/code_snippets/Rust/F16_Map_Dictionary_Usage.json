[
  {
    "task": "Create a map to store student names as keys and their grades as values, then calculate the average grade.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let mut student_grades: HashMap<&str, f32> = HashMap::new();\n\n    student_grades.insert(\"Alice\", 85.0);\n    student_grades.insert(\"Bob\", 92.0);\n    student_grades.insert(\"Charlie\", 78.0);\n    student_grades.insert(\"Diana\", 88.0);\n\n    let total: f32 = student_grades.values().sum();\n    let count = student_grades.len() as f32;\n    let average = total / count;\n\n    println!(\"Average grade: {}\", average);\n}\n```"
  },
  {
    "task": "Develop a function that takes a dictionary of product names and prices, and returns the total cost of all products.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn total_cost(products: HashMap<&str, f64>) -> f64 {\n    products.values().sum()\n}\n\nfn main() {\n    let mut products = HashMap::new();\n    products.insert(\"Apple\", 1.2);\n    products.insert(\"Banana\", 0.5);\n    products.insert(\"Orange\", 0.8);\n    \n    let cost = total_cost(products);\n    println!(\"Total cost: ${:.2}\", cost);\n}\n```"
  },
  {
    "task": "Implement a program that counts the frequency of each word in a given text using a dictionary.",
    "code": "```rust\nuse std::collections::HashMap;\nuse std::io::{self, Read};\n\nfn main() {\n    let mut input = String::new();\n    io::stdin().read_to_string(&mut input).expect(\"Failed to read input\");\n\n    let mut word_count: HashMap<&str, usize> = HashMap::new();\n\n    for word in input.split_whitespace() {\n        *word_count.entry(word).or_insert(0) += 1;\n    }\n\n    for (word, count) in word_count {\n        println!(\"{}: {}\", word, count);\n    }\n}\n```"
  },
  {
    "task": "Write a function that takes a dictionary of employee IDs and their work hours, and returns the ID of the employee with the most hours.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn employee_with_most_hours(work_hours: HashMap<String, u32>) -> Option<String> {\n    work_hours.into_iter().max_by_key(|&(_, hours)| hours).map(|(id, _)| id)\n}\n\nfn main() {\n    let mut work_hours = HashMap::new();\n    work_hours.insert(String::from(\"emp1\"), 40);\n    work_hours.insert(String::from(\"emp2\"), 45);\n    work_hours.insert(String::from(\"emp3\"), 38);\n\n    if let Some(employee_id) = employee_with_most_hours(work_hours) {\n        println!(\"Employee with most hours: {}\", employee_id);\n    } else {\n        println!(\"No employee data available.\");\n    }\n}\n```"
  },
  {
    "task": "Design a system that uses a map to store users' login attempts and timestamps, then locks the account after three failed attempts.",
    "code": "```rust\nuse std::collections::HashMap;\nuse std::time::{SystemTime, Duration};\n\nstruct UserManager {\n    login_attempts: HashMap<String, Vec<SystemTime>>,\n    lockout_duration: Duration,\n}\n\nimpl UserManager {\n    fn new(lockout_minutes: u64) -> Self {\n        UserManager {\n            login_attempts: HashMap::new(),\n            lockout_duration: Duration::from_secs(lockout_minutes * 60),\n        }\n    }\n\n    fn record_login_attempt(&mut self, username: &str) -> bool {\n        let now = SystemTime::now();\n        let attempts = self.login_attempts.entry(username.to_string()).or_insert(Vec::new());\n\n        // Remove outdated attempts\n        attempts.retain(|&timestamp| now.duration_since(timestamp).unwrap_or(Duration::ZERO) < self.lockout_duration);\n\n        if attempts.len() >= 3 {\n            return false; // Account is locked\n        }\n\n        attempts.push(now);\n        true\n    }\n}\n\nfn main() {\n    let mut user_manager = UserManager::new(15);\n\n    let username = \"user1\";\n    \n    // Simulating login attempts\n    if user_manager.record_login_attempt(username) {\n        println!(\"Login attempt for {}: Allowed\", username);\n    } else {\n        println!(\"Login attempt for {}: Account locked\", username);\n    }\n    \n    // Simulate further attempts...\n}\n```"
  },
  {
    "task": "Create a dictionary to represent a phonebook, allowing users to add, remove, and look up contacts by name.",
    "code": "```rust\nuse std::collections::HashMap;\nuse std::io;\n\nfn main() {\n    let mut phonebook: HashMap<String, String> = HashMap::new();\n\n    loop {\n        println!(\"Phonebook Menu:\");\n        println!(\"1. Add Contact\");\n        println!(\"2. Remove Contact\");\n        println!(\"3. Look Up Contact\");\n        println!(\"4. Exit\");\n        println!(\"Enter your choice:\");\n\n        let mut choice = String::new();\n        io::stdin().read_line(&mut choice).expect(\"Failed to read line\");\n\n        match choice.trim() {\n            \"1\" => {\n                let (name, number) = get_contact_details();\n                phonebook.insert(name, number);\n            }\n            \"2\" => {\n                println!(\"Enter the name of the contact to remove:\");\n                let mut name = String::new();\n                io::stdin().read_line(&mut name).expect(\"Failed to read line\");\n                phonebook.remove(name.trim());\n            }\n            \"3\" => {\n                println!(\"Enter the name of the contact to look up:\");\n                let mut name = String::new();\n                io::stdin().read_line(&mut name).expect(\"Failed to read line\");\n                match phonebook.get(name.trim()) {\n                    Some(number) => println!(\"The number for {} is {}\", name.trim(), number),\n                    None => println!(\"Contact not found\"),\n                }\n            }\n            \"4\" => break,\n            _ => println!(\"Invalid choice, please try again\"),\n        }\n    }\n}\n\nfn get_contact_details() -> (String, String) {\n    println!(\"Enter contact name:\");\n    let mut name = String::new();\n    io::stdin().read_line(&mut name).expect(\"Failed to read line\");\n\n    println!(\"Enter contact number:\");\n    let mut number = String::new();\n    io::stdin().read_line(&mut number).expect(\"Failed to read line\");\n\n    (name.trim().to_string(), number.trim().to_string())\n}\n```"
  },
  {
    "task": "Build a map that associates city names with their population, then find the city with the highest population.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let mut city_population = HashMap::new();\n    \n    city_population.insert(\"New York\", 8_336_817);\n    city_population.insert(\"Los Angeles\", 3_979_576);\n    city_population.insert(\"Chicago\", 2_693_976);\n    city_population.insert(\"Houston\", 2_320_268);\n    city_population.insert(\"Phoenix\", 1_680_992);\n\n    if let Some((city, &population)) = city_population.iter().max_by_key(|entry| entry.1) {\n        println!(\"The city with the highest population is {} with a population of {}.\", city, population);\n    }\n}\n```"
  },
  {
    "task": "Write a program that translates English words to another language using a provided dictionary, and translates a given sentence.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let mut dictionary = HashMap::new();\n    dictionary.insert(\"hello\", \"hola\");\n    dictionary.insert(\"world\", \"mundo\");\n    dictionary.insert(\"good\", \"bueno\");\n    dictionary.insert(\"morning\", \"ma\u00f1ana\");\n\n    let sentence = \"hello world good morning\";\n    let translated_sentence = translate_sentence(&sentence, &dictionary);\n    println!(\"{}\", translated_sentence);\n}\n\nfn translate_sentence(sentence: &str, dictionary: &HashMap<&str, &str>) -> String {\n    sentence\n        .split_whitespace()\n        .map(|word| dictionary.get(word).unwrap_or(&word))\n        .cloned()\n        .collect::<Vec<&str>>()\n        .join(\" \")\n}\n```"
  },
  {
    "task": "Construct a dictionary to map book titles to their authors, and implement a search function to find all books by a given author.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let mut book_map: HashMap<&str, &str> = HashMap::new();\n\n    book_map.insert(\"To Kill a Mockingbird\", \"Harper Lee\");\n    book_map.insert(\"1984\", \"George Orwell\");\n    book_map.insert(\"The Great Gatsby\", \"F. Scott Fitzgerald\");\n    book_map.insert(\"Animal Farm\", \"George Orwell\");\n    book_map.insert(\"Brave New World\", \"Aldous Huxley\");\n\n    let author = \"George Orwell\";\n    let books_by_author = find_books_by_author(&book_map, author);\n\n    println!(\"Books by {}: {:?}\", author, books_by_author);\n}\n\nfn find_books_by_author<'a>(\n    book_map: &'a HashMap<&str, &str>, \n    author: &str\n) -> Vec<&'a str> {\n    book_map.iter()\n        .filter_map(|(title, &author_name)| {\n            if author_name == author {\n                Some(*title)\n            } else {\n                None\n            }\n        })\n        .collect()\n}\n```"
  },
  {
    "task": "Create a map to store product IDs and their stock levels, then implement a function to update stock levels after a sale.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn update_stock(mut stock: &mut HashMap<u32, u32>, product_id: u32, quantity_sold: u32) {\n    if let Some(stock_level) = stock.get_mut(&product_id) {\n        if *stock_level >= quantity_sold {\n            *stock_level -= quantity_sold;\n        }\n    }\n}\n\nfn main() {\n    let mut stock = HashMap::new();\n    stock.insert(101, 50);\n    stock.insert(102, 30);\n    stock.insert(103, 20);\n\n    update_stock(&mut stock, 101, 5);\n    update_stock(&mut stock, 102, 10);\n\n    println!(\"{:?}\", stock);\n}\n```"
  },
  {
    "task": "Write a script that uses a dictionary to convert country codes to country names and prints the full name for a given code.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let mut country_codes = HashMap::new();\n    country_codes.insert(\"US\", \"United States\");\n    country_codes.insert(\"CA\", \"Canada\");\n    country_codes.insert(\"MX\", \"Mexico\");\n    country_codes.insert(\"FR\", \"France\");\n    country_codes.insert(\"DE\", \"Germany\");\n\n    let code = \"CA\";\n    match country_codes.get(code) {\n        Some(country_name) => println!(\"The country name for code {} is {}\", code, country_name),\n        None => println!(\"Country code {} not found\", code),\n    }\n}\n```"
  },
  {
    "task": "Design a program that stores student IDs and names in a dictionary, and allows retrieval of names by ID.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let mut students = HashMap::new();\n    \n    // Add some students\n    students.insert(101, \"Alice\");\n    students.insert(102, \"Bob\");\n    students.insert(103, \"Carol\");\n\n    // Retrieve and print student names by ID\n    let ids_to_check = [101, 104, 102];\n\n    for &id in &ids_to_check {\n        match students.get(&id) {\n            Some(name) => println!(\"ID {}: {}\", id, name),\n            None => println!(\"ID {}: Not found\", id),\n        }\n    }\n}\n```"
  },
  {
    "task": "Implement a dictionary to store configuration settings for a software application, allowing updates and retrieval of settings.",
    "code": "```rust\nuse std::collections::HashMap;\n\nstruct Config {\n    settings: HashMap<String, String>,\n}\n\nimpl Config {\n    fn new() -> Self {\n        Config {\n            settings: HashMap::new(),\n        }\n    }\n\n    fn set(&mut self, key: String, value: String) {\n        self.settings.insert(key, value);\n    }\n\n    fn get(&self, key: &str) -> Option<&String> {\n        self.settings.get(key)\n    }\n}\n\nfn main() {\n    let mut config = Config::new();\n    config.set(\"theme\".to_string(), \"dark\".to_string());\n    config.set(\"timeout\".to_string(), \"30\".to_string());\n\n    if let Some(theme) = config.get(\"theme\") {\n        println!(\"Theme: {}\", theme);\n    }\n\n    if let Some(timeout) = config.get(\"timeout\") {\n        println!(\"Timeout: {}\", timeout);\n    }\n}\n```"
  },
  {
    "task": "Create a map that stores words as keys and their definitions as values, and write a function to display all words starting with a given letter.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let mut dictionary = HashMap::new();\n    dictionary.insert(\"apple\", \"A fruit that is typically red, green, or yellow.\");\n    dictionary.insert(\"banana\", \"A long curved fruit that grows in clusters.\");\n    dictionary.insert(\"carrot\", \"An orange root vegetable.\");\n    dictionary.insert(\"date\", \"A sweet fruit from the date palm tree.\");\n    dictionary.insert(\"apricot\", \"A small, soft fruit with a stone.\");\n\n    display_words_starting_with(&dictionary, 'a');\n}\n\nfn display_words_starting_with(dictionary: &HashMap<&str, &str>, letter: char) {\n    for (word, definition) in dictionary.iter() {\n        if word.starts_with(letter) {\n            println!(\"{}: {}\", word, definition);\n        }\n    }\n}\n```"
  },
  {
    "task": "Write a program that uses a dictionary to store usernames and passwords, and verifies login attempts.",
    "code": "```rust\nuse std::collections::HashMap;\nuse std::io;\n\nfn main() {\n    let mut credentials = HashMap::new();\n    credentials.insert(\"user1\", \"password123\");\n    credentials.insert(\"user2\", \"securepass\");\n    credentials.insert(\"admin\", \"adminpass\");\n\n    let mut input_username = String::new();\n    let mut input_password = String::new();\n\n    println!(\"Enter username:\");\n    io::stdin().read_line(&mut input_username).expect(\"Failed to read line\");\n    let input_username = input_username.trim();\n\n    println!(\"Enter password:\");\n    io::stdin().read_line(&mut input_password).expect(\"Failed to read line\");\n    let input_password = input_password.trim();\n\n    match credentials.get(input_username) {\n        Some(&stored_password) if stored_password == input_password => {\n            println!(\"Login successful!\");\n        }\n        _ => {\n            println!(\"Invalid username or password.\");\n        }\n    }\n}\n```"
  },
  {
    "task": "Design a map to track the number of times each item is purchased in a store, then find the most popular item.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let purchases = vec![\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"apple\"];\n    let mut purchase_count: HashMap<&str, i32> = HashMap::new();\n\n    for item in purchases {\n        *purchase_count.entry(item).or_insert(0) += 1;\n    }\n\n    let most_popular_item = purchase_count.iter().max_by_key(|&(_, count)| count);\n\n    if let Some((item, count)) = most_popular_item {\n        println!(\"Most popular item: {} with {} purchases\", item, count);\n    } else {\n        println!(\"No purchases found\");\n    }\n}\n```"
  },
  {
    "task": "Build a dictionary that associates file extensions with their corresponding application types and uses it to determine how to open a given file.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let mut file_associations: HashMap<&str, &str> = HashMap::new();\n    file_associations.insert(\"txt\", \"Text Editor\");\n    file_associations.insert(\"jpg\", \"Image Viewer\");\n    file_associations.insert(\"png\", \"Image Viewer\");\n    file_associations.insert(\"mp3\", \"Music Player\");\n    file_associations.insert(\"mp4\", \"Video Player\");\n    file_associations.insert(\"pdf\", \"PDF Reader\");\n\n    let filename = \"example.txt\";\n    let extension = filename.split('.').last().unwrap_or(\"\");\n    \n    if let Some(application) = file_associations.get(extension) {\n        println!(\"Open '{}' with '{}'\", filename, application);\n    } else {\n        println!(\"No associated application found for '{}'\", filename);\n    }\n}\n```"
  },
  {
    "task": "Create a program that uses a map to store menu items and their prices, and allows customers to calculate their total bill.",
    "code": "```rust\nuse std::collections::HashMap;\nuse std::io;\n\nfn main() {\n    let mut menu = HashMap::new();\n    menu.insert(\"Burger\", 5.99);\n    menu.insert(\"Fries\", 2.99);\n    menu.insert(\"Soda\", 1.50);\n    menu.insert(\"Salad\", 4.50);\n\n    let mut total_bill = 0.0;\n\n    println!(\"Menu items and their prices:\");\n    for (item, price) in &menu {\n        println!(\"{} - ${:.2}\", item, price);\n    }\n\n    println!(\"Enter the name of the item you want to order, or type 'done' to finish:\");\n\n    loop {\n        let mut input = String::new();\n        io::stdin().read_line(&mut input).expect(\"Failed to read line\");\n        let input = input.trim();\n\n        if input.eq_ignore_ascii_case(\"done\") {\n            break;\n        }\n\n        match menu.get(input) {\n            Some(&price) => {\n                total_bill += price;\n                println!(\"Added {} to your order. Current total: ${:.2}\", input, total_bill);\n            }\n            None => println!(\"Item not found in menu, please try again.\"),\n        }\n    }\n\n    println!(\"Your total bill is: ${:.2}\", total_bill);\n}\n```"
  },
  {
    "task": "Implement a dictionary to track the inventory of a warehouse, allowing additions, removals, and inventory checks.",
    "code": "```rust\nuse std::collections::HashMap;\n\nstruct Warehouse {\n    inventory: HashMap<String, u32>,\n}\n\nimpl Warehouse {\n    fn new() -> Self {\n        Warehouse {\n            inventory: HashMap::new(),\n        }\n    }\n\n    fn add_item(&mut self, item: String, quantity: u32) {\n        *self.inventory.entry(item).or_insert(0) += quantity;\n    }\n\n    fn remove_item(&mut self, item: &str, quantity: u32) -> bool {\n        if let Some(stock) = self.inventory.get_mut(item) {\n            if *stock >= quantity {\n                *stock -= quantity;\n                if *stock == 0 {\n                    self.inventory.remove(item);\n                }\n                return true;\n            }\n        }\n        false\n    }\n\n    fn check_inventory(&self, item: &str) -> Option<u32> {\n        self.inventory.get(item).copied()\n    }\n}\n\nfn main() {\n    let mut warehouse = Warehouse::new();\n    \n    warehouse.add_item(\"Widget\".to_string(), 100);\n    warehouse.add_item(\"Gadget\".to_string(), 50);\n    \n    if warehouse.remove_item(\"Widget\", 30) {\n        println!(\"30 Widgets removed. Remaining: {:?}\", warehouse.check_inventory(\"Widget\"));\n    } else {\n        println!(\"Failed to remove Widgets.\");\n    }\n    \n    println!(\"Current inventory for Gadget: {:?}\", warehouse.check_inventory(\"Gadget\"));\n}\n```"
  },
  {
    "task": "Write a function that uses a map to convert Roman numerals to integers.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn roman_to_integer(s: &str) -> i32 {\n    let roman_map: HashMap<char, i32> = [\n        ('I', 1),\n        ('V', 5),\n        ('X', 10),\n        ('L', 50),\n        ('C', 100),\n        ('D', 500),\n        ('M', 1000),\n    ].iter().cloned().collect();\n\n    let mut total = 0;\n    let mut prev_value = 0;\n\n    for c in s.chars().rev() {\n        if let Some(&value) = roman_map.get(&c) {\n            if value < prev_value {\n                total -= value;\n            } else {\n                total += value;\n            }\n            prev_value = value;\n        }\n    }\n\n    total\n}\n```"
  },
  {
    "task": "Develop a program that uses a dictionary to track the number of occurrences of each letter in a string.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn count_letter_occurrences(s: &str) -> HashMap<char, usize> {\n    let mut occurrences = HashMap::new();\n    for c in s.chars() {\n        let counter = occurrences.entry(c).or_insert(0);\n        *counter += 1;\n    }\n    occurrences\n}\n\nfn main() {\n    let input = \"example string\";\n    let letter_counts = count_letter_occurrences(input);\n    \n    for (letter, count) in letter_counts {\n        println!(\"{}: {}\", letter, count);\n    }\n}\n```"
  },
  {
    "task": "Create a map to store team names and their scores, then determine the team with the highest score.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let mut scores = HashMap::new();\n    \n    scores.insert(\"Team A\", 42);\n    scores.insert(\"Team B\", 58);\n    scores.insert(\"Team C\", 36);\n\n    let mut highest_score = 0;\n    let mut best_team = \"\";\n\n    for (team, &score) in &scores {\n        if score > highest_score {\n            highest_score = score;\n            best_team = team;\n        }\n    }\n\n    println!(\"The team with the highest score is {} with {} points.\", best_team, highest_score);\n}\n```"
  },
  {
    "task": "Write a function that takes a dictionary of item weights and calculates the total weight of all items.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn calculate_total_weight(weights: &HashMap<String, f64>) -> f64 {\n    weights.values().sum()\n}\n\nfn main() {\n    let mut item_weights = HashMap::new();\n    item_weights.insert(String::from(\"item1\"), 2.5);\n    item_weights.insert(String::from(\"item2\"), 3.0);\n    item_weights.insert(String::from(\"item3\"), 1.5);\n\n    let total_weight = calculate_total_weight(&item_weights);\n    println!(\"Total weight: {}\", total_weight);\n}\n```"
  },
  {
    "task": "Implement a map to store website URLs and their respective visit counts, then find the most visited website.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let mut website_visits: HashMap<&str, u32> = HashMap::new();\n\n    // Example data: adding some URLs with visit counts\n    website_visits.insert(\"https://example.com\", 150);\n    website_visits.insert(\"https://rust-lang.org\", 300);\n    website_visits.insert(\"https://stackoverflow.com\", 275);\n\n    // Determine the most visited website\n    let most_visited = website_visits.iter().max_by_key(|&(_, count)| count);\n\n    if let Some((url, count)) = most_visited {\n        println!(\"Most visited website is {} with {} visits.\", url, count);\n    }\n}\n```"
  },
  {
    "task": "Create a script that uses a dictionary to map error codes to error messages, and prints the message for a given code.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let mut error_map = HashMap::new();\n    error_map.insert(404, \"Not Found\");\n    error_map.insert(500, \"Internal Server Error\");\n    error_map.insert(403, \"Forbidden\");\n    error_map.insert(401, \"Unauthorized\");\n\n    let code = 404;\n    if let Some(message) = error_map.get(&code) {\n        println!(\"Error {}: {}\", code, message);\n    } else {\n        println!(\"Error code not found\");\n    }\n}\n```"
  },
  {
    "task": "Design a dictionary to store contact information with names as keys and phone numbers as values, allowing updates and lookups.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let mut contacts = HashMap::new();\n\n    // Adding contacts\n    contacts.insert(\"Alice\".to_string(), \"123-456-7890\".to_string());\n    contacts.insert(\"Bob\".to_string(), \"987-654-3210\".to_string());\n\n    // Updating a contact\n    if let Some(contact) = contacts.get_mut(\"Alice\") {\n        *contact = \"111-222-3333\".to_string();\n    }\n\n    // Lookup a contact\n    if let Some(number) = contacts.get(\"Bob\") {\n        println!(\"Bob's phone number is: {}\", number);\n    } else {\n        println!(\"Bob's contact not found.\");\n    }\n}\n```"
  },
  {
    "task": "Write a program that uses a map to assign tasks to employees based on their skill levels.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn main() {\n    // Define a map with employee names as keys and their skill levels as values.\n    let mut employee_skills: HashMap<&str, u32> = HashMap::new();\n    employee_skills.insert(\"Alice\", 5);\n    employee_skills.insert(\"Bob\", 3);\n    employee_skills.insert(\"Charlie\", 4);\n\n    // Define a map with tasks as keys and required skill levels as values.\n    let mut tasks: HashMap<&str, u32> = HashMap::new();\n    tasks.insert(\"Task1\", 5);\n    tasks.insert(\"Task2\", 3);\n    tasks.insert(\"Task3\", 4);\n\n    // Assign tasks to employees based on their skill levels.\n    let mut task_assignments: HashMap<&str, &str> = HashMap::new();\n\n    for (task, required_skill) in &tasks {\n        for (employee, skill_level) in &employee_skills {\n            if skill_level >= required_skill && task_assignments.get(*task).is_none() {\n                task_assignments.insert(*task, *employee);\n                break;\n            }\n        }\n    }\n\n    // Print the task assignments.\n    for (task, employee) in &task_assignments {\n        println!(\"{} is assigned to {}\", task, employee);\n    }\n}\n```"
  },
  {
    "task": "Create a dictionary that maps airport codes to their respective city names, and allows retrieval of city names by code.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let mut airport_codes = HashMap::new();\n    \n    airport_codes.insert(\"JFK\", \"New York\");\n    airport_codes.insert(\"LAX\", \"Los Angeles\");\n    airport_codes.insert(\"ORD\", \"Chicago\");\n    airport_codes.insert(\"ATL\", \"Atlanta\");\n    airport_codes.insert(\"DFW\", \"Dallas\");\n\n    let code = \"LAX\";\n    if let Some(city) = airport_codes.get(code) {\n        println!(\"The city for airport code {} is {}.\", code, city);\n    } else {\n        println!(\"Airport code {} not found.\", code);\n    }\n}\n```"
  },
  {
    "task": "Build a map to store movie titles and their release years, then find all movies released in a given decade.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let mut movies: HashMap<&str, i32> = HashMap::new();\n    movies.insert(\"The Shawshank Redemption\", 1994);\n    movies.insert(\"The Godfather\", 1972);\n    movies.insert(\"The Dark Knight\", 2008);\n    movies.insert(\"Pulp Fiction\", 1994);\n    movies.insert(\"The Lord of the Rings: The Return of the King\", 2003);\n\n    let decade = 1990;\n    let decade_end = decade + 9;\n\n    let movies_in_decade: Vec<&str> = movies.iter()\n        .filter(|&(_, &year)| year >= decade && year <= decade_end)\n        .map(|(&title, _)| title)\n        .collect();\n\n    println!(\"Movies released in the {}s: {:?}\", decade, movies_in_decade);\n}\n```"
  },
  {
    "task": "Write a function that uses a dictionary to group students by their grades.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn group_students_by_grades(students: Vec<(&str, char)>) -> HashMap<char, Vec<String>> {\n    let mut grade_map: HashMap<char, Vec<String>> = HashMap::new();\n    \n    for (name, grade) in students {\n        grade_map.entry(grade).or_insert(Vec::new()).push(name.to_string());\n    }\n    \n    grade_map\n}\n\nfn main() {\n    let students = vec![\n        (\"Alice\", 'A'),\n        (\"Bob\", 'B'),\n        (\"Charlie\", 'A'),\n        (\"David\", 'C'),\n        (\"Eve\", 'B'),\n    ];\n    \n    let grouped_students = group_students_by_grades(students);\n    \n    for (grade, names) in grouped_students {\n        println!(\"Grade {}: {:?}\", grade, names);\n    }\n}\n```"
  },
  {
    "task": "Create a dictionary to store the number of visitors to different sections of a website, and determine the most visited section.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let mut visitors: HashMap<&str, u32> = HashMap::new();\n\n    // Example data: sections with their respective visitor counts\n    visitors.insert(\"Home\", 1200);\n    visitors.insert(\"About\", 300);\n    visitors.insert(\"Contact\", 450);\n    visitors.insert(\"Blog\", 800);\n    visitors.insert(\"Services\", 600);\n\n    let most_visited_section = visitors.iter().max_by_key(|&(_, count)| count);\n\n    if let Some((section, count)) = most_visited_section {\n        println!(\"The most visited section is '{}' with {} visitors.\", section, count);\n    }\n}\n```"
  },
  {
    "task": "Design a program that uses a map to assign project deadlines to team members, allowing for deadline extensions.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn main() {\n    // Create a map to store project deadlines\n    let mut project_deadlines: HashMap<&str, &str> = HashMap::new();\n\n    // Assign deadlines to team members\n    project_deadlines.insert(\"Alice\", \"2023-12-01\");\n    project_deadlines.insert(\"Bob\", \"2023-12-05\");\n    project_deadlines.insert(\"Charlie\", \"2023-12-10\");\n\n    // Function to extend a deadline\n    fn extend_deadline(\n        deadlines: &mut HashMap<&str, &str>,\n        member: &str,\n        new_deadline: &str,\n    ) {\n        if let Some(deadline) = deadlines.get_mut(member) {\n            *deadline = new_deadline;\n        }\n    }\n\n    // Extend deadline for a team member\n    extend_deadline(&mut project_deadlines, \"Alice\", \"2023-12-15\");\n\n    // Print the updated deadlines\n    for (member, deadline) in &project_deadlines {\n        println!(\"{}: {}\", member, deadline);\n    }\n}\n```"
  },
  {
    "task": "Implement a dictionary that keeps track of borrowed books in a library, allowing users to check available books.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let mut library = HashMap::new();\n\n    // Add some books to the library\n    library.insert(\"1984\", true);\n    library.insert(\"To Kill a Mockingbird\", true);\n    library.insert(\"The Great Gatsby\", false);\n\n    // Function to check if a book is available\n    fn is_book_available(library: &HashMap<&str, bool>, book_title: &str) -> bool {\n        match library.get(book_title) {\n            Some(&is_available) => is_available,\n            None => false,\n        }\n    }\n\n    // Check if a book is available\n    let book_title = \"1984\";\n    if is_book_available(&library, book_title) {\n        println!(\"The book '{}' is available.\", book_title);\n    } else {\n        println!(\"The book '{}' is not available.\", book_title);\n    }\n}\n```"
  },
  {
    "task": "Create a map to store the names of planets and their distances from the sun, then find the closest planet to Earth.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let mut planet_distances = HashMap::new();\n    planet_distances.insert(\"Mercury\", 57.91);\n    planet_distances.insert(\"Venus\", 108.2);\n    planet_distances.insert(\"Earth\", 149.6);\n    planet_distances.insert(\"Mars\", 227.9);\n    planet_distances.insert(\"Jupiter\", 778.5);\n    planet_distances.insert(\"Saturn\", 1434.0);\n    planet_distances.insert(\"Uranus\", 2871.0);\n    planet_distances.insert(\"Neptune\", 4495.1);\n\n    let earth_distance = planet_distances.get(\"Earth\").unwrap_or(&0.0);\n\n    let closest_planet = planet_distances.iter()\n        .filter(|&(planet, _)| *planet != \"Earth\")\n        .min_by(|a, b| {\n            let distance_a = (a.1 - earth_distance).abs();\n            let distance_b = (b.1 - earth_distance).abs();\n            distance_a.partial_cmp(&distance_b).unwrap()\n        });\n\n    if let Some((planet, _)) = closest_planet {\n        println!(\"The closest planet to Earth is {}.\", planet);\n    } else {\n        println!(\"No planets found.\");\n    }\n}\n```"
  },
  {
    "task": "Write a script that uses a dictionary to translate Morse code into plain text.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn morse_to_text(morse_code: &str) -> String {\n    let morse_dict: HashMap<&str, &str> = [\n        (\".-\", \"A\"), (\"-...\", \"B\"), (\"-.-.\", \"C\"), (\"-..\", \"D\"), (\".\", \"E\"),\n        (\"..-.\", \"F\"), (\"--.\", \"G\"), (\"....\", \"H\"), (\"..\", \"I\"), (\".---\", \"J\"),\n        (\"-.-\", \"K\"), (\".-..\", \"L\"), (\"--\", \"M\"), (\"-.\", \"N\"), (\"---\", \"O\"),\n        (\".--.\", \"P\"), (\"--.-\", \"Q\"), (\".-.\", \"R\"), (\"...\", \"S\"), (\"-\", \"T\"),\n        (\"..-\", \"U\"), (\"...-\", \"V\"), (\".--\", \"W\"), (\"-..-\", \"X\"), (\"-.--\", \"Y\"),\n        (\"--..\", \"Z\"), (\"-----\", \"0\"), (\".----\", \"1\"), (\"..---\", \"2\"), (\"...--\", \"3\"),\n        (\"....-\", \"4\"), (\".....\", \"5\"), (\"-....\", \"6\"), (\"--...\", \"7\"), (\"---..\", \"8\"),\n        (\"----.\", \"9\"), (\"/\", \" \")\n    ].iter().cloned().collect();\n\n    morse_code.split_whitespace()\n        .map(|code| morse_dict.get(code).unwrap_or(&\"\"))\n        .collect()\n}\n\nfn main() {\n    let morse_code = \"... --- ... / -- --- .-. ... .\";\n    let text = morse_to_text(morse_code);\n    println!(\"{}\", text);\n}\n```"
  },
  {
    "task": "Develop a program that uses a map to store vehicle registration numbers and their corresponding owner's name.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let mut vehicle_registry = HashMap::new();\n\n    vehicle_registry.insert(\"ABC123\", \"John Doe\");\n    vehicle_registry.insert(\"XYZ789\", \"Jane Smith\");\n    vehicle_registry.insert(\"LMN456\", \"Alice Johnson\");\n\n    for (registration_number, owner_name) in &vehicle_registry {\n        println!(\"Vehicle: {}, Owner: {}\", registration_number, owner_name);\n    }\n}\n```"
  },
  {
    "task": "Create a dictionary that maps sports teams to their win-loss records, and find the team with the best record.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let mut team_records = HashMap::new();\n    \n    // Example data: Team name mapped to a tuple of (wins, losses)\n    team_records.insert(\"Team A\", (10, 2));\n    team_records.insert(\"Team B\", (8, 4));\n    team_records.insert(\"Team C\", (12, 1));\n    team_records.insert(\"Team D\", (6, 6));\n    \n    let best_team = team_records.iter().max_by_key(|&(_, &(wins, losses))| wins - losses);\n    \n    if let Some((team, &(wins, losses))) = best_team {\n        println!(\"The team with the best record is {} with a record of {}-{}\", team, wins, losses);\n    }\n}\n```"
  },
  {
    "task": "Write a function that uses a map to convert currency codes to full currency names.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn currency_code_to_name(code: &str) -> Option<&'static str> {\n    let mut currency_map = HashMap::new();\n    currency_map.insert(\"USD\", \"United States Dollar\");\n    currency_map.insert(\"EUR\", \"Euro\");\n    currency_map.insert(\"JPY\", \"Japanese Yen\");\n    currency_map.insert(\"GBP\", \"British Pound\");\n    currency_map.insert(\"AUD\", \"Australian Dollar\");\n    currency_map.insert(\"CAD\", \"Canadian Dollar\");\n    currency_map.insert(\"CHF\", \"Swiss Franc\");\n    currency_map.insert(\"CNY\", \"Chinese Yuan\");\n    currency_map.insert(\"SEK\", \"Swedish Krona\");\n    currency_map.insert(\"NZD\", \"New Zealand Dollar\");\n\n    currency_map.get(code).copied()\n}\n\nfn main() {\n    let code = \"USD\";\n    match currency_code_to_name(code) {\n        Some(name) => println!(\"Currency name: {}\", name),\n        None => println!(\"Currency code not found\"),\n    }\n}\n```"
  },
  {
    "task": "Build a dictionary to store student names and their attendance counts, and determine the student with the highest attendance.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let mut attendance: HashMap<&str, u32> = HashMap::new();\n\n    // Sample data\n    attendance.insert(\"Alice\", 8);\n    attendance.insert(\"Bob\", 10);\n    attendance.insert(\"Charlie\", 7);\n\n    let mut highest_attendance_student = \"\";\n    let mut highest_attendance_count = 0;\n\n    for (student, &count) in &attendance {\n        if count > highest_attendance_count {\n            highest_attendance_count = count;\n            highest_attendance_student = student;\n        }\n    }\n\n    println!(\n        \"Student with the highest attendance: {} with {} days\",\n        highest_attendance_student, highest_attendance_count\n    );\n}\n```"
  },
  {
    "task": "Implement a map to store the names of countries and their capitals, allowing lookups by country name.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let mut countries_and_capitals = HashMap::new();\n\n    countries_and_capitals.insert(\"France\", \"Paris\");\n    countries_and_capitals.insert(\"Germany\", \"Berlin\");\n    countries_and_capitals.insert(\"Japan\", \"Tokyo\");\n    countries_and_capitals.insert(\"Canada\", \"Ottawa\");\n    countries_and_capitals.insert(\"Brazil\", \"Bras\u00edlia\");\n\n    let country_name = \"Germany\";\n    if let Some(&capital) = countries_and_capitals.get(country_name) {\n        println!(\"The capital of {} is {}.\", country_name, capital);\n    } else {\n        println!(\"Country not found.\");\n    }\n}\n```"
  },
  {
    "task": "Create a program that uses a dictionary to keep track of recipe ingredients and their quantities.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let mut recipe: HashMap<&str, f32> = HashMap::new();\n\n    recipe.insert(\"flour\", 2.5); // cups\n    recipe.insert(\"sugar\", 1.0); // cups\n    recipe.insert(\"eggs\", 3.0); // units\n    recipe.insert(\"milk\", 1.5); // cups\n    recipe.insert(\"butter\", 0.5); // cups\n\n    for (ingredient, quantity) in &recipe {\n        println!(\"{}: {}\", ingredient, quantity);\n    }\n}\n```"
  },
  {
    "task": "Design a system that uses a map to associate social media usernames with user profiles.",
    "code": "```rust\nuse std::collections::HashMap;\n\n#[derive(Debug)]\nstruct UserProfile {\n    username: String,\n    email: String,\n    age: u32,\n}\n\nfn main() {\n    let mut user_profiles: HashMap<String, UserProfile> = HashMap::new();\n\n    let profile1 = UserProfile {\n        username: String::from(\"user1\"),\n        email: String::from(\"user1@example.com\"),\n        age: 25,\n    };\n\n    let profile2 = UserProfile {\n        username: String::from(\"user2\"),\n        email: String::from(\"user2@example.com\"),\n        age: 30,\n    };\n\n    user_profiles.insert(profile1.username.clone(), profile1);\n    user_profiles.insert(profile2.username.clone(), profile2);\n\n    if let Some(profile) = user_profiles.get(\"user1\") {\n        println!(\"{:?}\", profile);\n    }\n}\n```"
  },
  {
    "task": "Write a function that takes a dictionary of product categories and lists all products in a given category.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn list_products_in_category(\n    categories: &HashMap<String, Vec<String>>,\n    category: &str,\n) -> Vec<String> {\n    match categories.get(category) {\n        Some(products) => products.clone(),\n        None => Vec::new(),\n    }\n}\n\nfn main() {\n    let mut categories = HashMap::new();\n    categories.insert(\"Electronics\".to_string(), vec![\"Laptop\".to_string(), \"Smartphone\".to_string()]);\n    categories.insert(\"Furniture\".to_string(), vec![\"Chair\".to_string(), \"Table\".to_string()]);\n\n    let category = \"Electronics\";\n    let products = list_products_in_category(&categories, category);\n\n    for product in products {\n        println!(\"{}\", product);\n    }\n}\n```"
  },
  {
    "task": "Create a dictionary to store shopping list items and their quantities, and implement a function to update quantities.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let mut shopping_list: HashMap<String, u32> = HashMap::new();\n    \n    // Initialize with some items\n    shopping_list.insert(\"Apples\".to_string(), 5);\n    shopping_list.insert(\"Bananas\".to_string(), 3);\n    shopping_list.insert(\"Carrots\".to_string(), 10);\n    \n    // Update quantities\n    update_quantity(&mut shopping_list, \"Apples\", 2);\n    update_quantity(&mut shopping_list, \"Bananas\", 5);\n    \n    // Print the updated shopping list\n    for (item, quantity) in &shopping_list {\n        println!(\"{}: {}\", item, quantity);\n    }\n}\n\nfn update_quantity(shopping_list: &mut HashMap<String, u32>, item: &str, quantity: u32) {\n    shopping_list.insert(item.to_string(), quantity);\n}\n```"
  },
  {
    "task": "Build a program that uses a map to store historical events and their dates, and finds events that occurred in a given year.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let mut events = HashMap::new();\n    events.insert(\"Moon Landing\", 1969);\n    events.insert(\"Fall of the Berlin Wall\", 1989);\n    events.insert(\"Y2K\", 2000);\n\n    let year_to_search = 1989;\n    let events_in_year: Vec<_> = events.iter()\n        .filter(|&(_, &year)| year == year_to_search)\n        .map(|(event, _)| event)\n        .collect();\n\n    if events_in_year.is_empty() {\n        println!(\"No events found in the year {}.\", year_to_search);\n    } else {\n        println!(\"Events in the year {}: {:?}\", year_to_search, events_in_year);\n    }\n}\n```"
  },
  {
    "task": "Implement a dictionary to manage user roles and permissions within an application.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn main() {\n    // Define roles and permissions\n    let mut roles_permissions: HashMap<&str, Vec<&str>> = HashMap::new();\n\n    // Add roles and their associated permissions\n    roles_permissions.insert(\"admin\", vec![\"create\", \"read\", \"update\", \"delete\"]);\n    roles_permissions.insert(\"editor\", vec![\"read\", \"update\"]);\n    roles_permissions.insert(\"viewer\", vec![\"read\"]);\n\n    // Function to check if a role has a specific permission\n    fn has_permission(roles_permissions: &HashMap<&str, Vec<&str>>, role: &str, permission: &str) -> bool {\n        match roles_permissions.get(role) {\n            Some(permissions) => permissions.contains(&permission),\n            None => false,\n        }\n    }\n\n    // Example usage\n    let role = \"editor\";\n    let permission = \"update\";\n\n    if has_permission(&roles_permissions, role, permission) {\n        println!(\"The {} role has {} permission.\", role, permission);\n    } else {\n        println!(\"The {} role does not have {} permission.\", role, permission);\n    }\n}\n```"
  },
  {
    "task": "Write a script that uses a map to convert numeric grades to letter grades.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let mut grade_map = HashMap::new();\n    grade_map.insert(90..=100, \"A\");\n    grade_map.insert(80..=89, \"B\");\n    grade_map.insert(70..=79, \"C\");\n    grade_map.insert(60..=69, \"D\");\n    grade_map.insert(0..=59, \"F\");\n\n    let numeric_grades = vec![95, 82, 76, 58, 63];\n    let mut letter_grades = Vec::new();\n\n    for num_grade in numeric_grades {\n        let letter_grade = grade_map.iter()\n            .find(|&(range, _)| range.contains(&num_grade))\n            .map(|(_, &grade)| grade)\n            .unwrap_or(\"Invalid grade\");\n        \n        letter_grades.push(letter_grade);\n    }\n\n    for (num_grade, letter_grade) in numeric_grades.iter().zip(letter_grades.iter()) {\n        println!(\"Numeric Grade: {}, Letter Grade: {}\", num_grade, letter_grade);\n    }\n}\n```"
  },
  {
    "task": "Create a dictionary that maps holiday names to their corresponding dates, and allows lookup by holiday name.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let mut holidays = HashMap::new();\n    \n    holidays.insert(\"New Year's Day\", \"January 1\");\n    holidays.insert(\"Valentine's Day\", \"February 14\");\n    holidays.insert(\"Independence Day\", \"July 4\");\n    holidays.insert(\"Halloween\", \"October 31\");\n    holidays.insert(\"Christmas\", \"December 25\");\n    \n    let holiday_name = \"Christmas\";\n    if let Some(date) = holidays.get(holiday_name) {\n        println!(\"{} is on {}\", holiday_name, date);\n    } else {\n        println!(\"Holiday not found.\");\n    }\n}\n```"
  },
  {
    "task": "Design a system that uses a map to track the status of online orders, allowing updates to order status.",
    "code": "```rust\nuse std::collections::HashMap;\n\n#[derive(Debug)]\nenum OrderStatus {\n    Pending,\n    Processing,\n    Shipped,\n    Delivered,\n    Cancelled,\n}\n\nstruct OrderTracker {\n    orders: HashMap<u32, OrderStatus>,\n}\n\nimpl OrderTracker {\n    fn new() -> Self {\n        OrderTracker {\n            orders: HashMap::new(),\n        }\n    }\n\n    fn add_order(&mut self, order_id: u32, status: OrderStatus) {\n        self.orders.insert(order_id, status);\n    }\n\n    fn update_order_status(&mut self, order_id: u32, status: OrderStatus) {\n        if let Some(order) = self.orders.get_mut(&order_id) {\n            *order = status;\n        }\n    }\n\n    fn get_order_status(&self, order_id: u32) -> Option<&OrderStatus> {\n        self.orders.get(&order_id)\n    }\n}\n\nfn main() {\n    let mut tracker = OrderTracker::new();\n\n    tracker.add_order(1, OrderStatus::Pending);\n    tracker.add_order(2, OrderStatus::Processing);\n\n    tracker.update_order_status(1, OrderStatus::Shipped);\n\n    if let Some(status) = tracker.get_order_status(1) {\n        println!(\"Order 1 status: {:?}\", status);\n    }\n\n    if let Some(status) = tracker.get_order_status(2) {\n        println!(\"Order 2 status: {:?}\", status);\n    }\n}\n```"
  },
  {
    "task": "Develop a program that uses a dictionary to associate food items with their nutritional information.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let mut food_nutrition: HashMap<&str, HashMap<&str, f32>> = HashMap::new();\n\n    // Define nutritional information for an apple\n    let mut apple_info = HashMap::new();\n    apple_info.insert(\"calories\", 52.0);\n    apple_info.insert(\"protein\", 0.3);\n    apple_info.insert(\"carbohydrates\", 14.0);\n    apple_info.insert(\"fat\", 0.2);\n\n    // Define nutritional information for a banana\n    let mut banana_info = HashMap::new();\n    banana_info.insert(\"calories\", 89.0);\n    banana_info.insert(\"protein\", 1.1);\n    banana_info.insert(\"carbohydrates\", 23.0);\n    banana_info.insert(\"fat\", 0.3);\n\n    // Insert the food items and their nutritional information into the dictionary\n    food_nutrition.insert(\"apple\", apple_info);\n    food_nutrition.insert(\"banana\", banana_info);\n\n    // Example of accessing nutritional information for an apple\n    if let Some(nutrition) = food_nutrition.get(\"apple\") {\n        println!(\"Nutritional information for apple:\");\n        for (key, value) in nutrition {\n            println!(\"{}: {}\", key, value);\n        }\n    }\n}\n```"
  },
  {
    "task": "Create a map to store book genres and lists of book titles, allowing retrieval of all books in a given genre.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let mut book_genres: HashMap<&str, Vec<&str>> = HashMap::new();\n\n    // Example data\n    book_genres.insert(\"Science Fiction\", vec![\"Dune\", \"Neuromancer\"]);\n    book_genres.insert(\"Fantasy\", vec![\"The Hobbit\", \"Harry Potter and the Sorcerer's Stone\"]);\n    book_genres.insert(\"Mystery\", vec![\"The Da Vinci Code\", \"Gone Girl\"]);\n\n    // Retrieve all books in a given genre\n    if let Some(books) = book_genres.get(\"Fantasy\") {\n        println!(\"Books in Fantasy genre: {:?}\", books);\n    } else {\n        println!(\"No books found in the specified genre.\");\n    }\n}\n```"
  },
  {
    "task": "Write a function that uses a dictionary to convert state abbreviations to full state names.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn state_abbreviation_to_name(abbreviation: &str) -> Option<&'static str> {\n    let mut states = HashMap::new();\n    states.insert(\"AL\", \"Alabama\");\n    states.insert(\"AK\", \"Alaska\");\n    states.insert(\"AZ\", \"Arizona\");\n    states.insert(\"AR\", \"Arkansas\");\n    states.insert(\"CA\", \"California\");\n    states.insert(\"CO\", \"Colorado\");\n    states.insert(\"CT\", \"Connecticut\");\n    states.insert(\"DE\", \"Delaware\");\n    states.insert(\"FL\", \"Florida\");\n    states.insert(\"GA\", \"Georgia\");\n    states.insert(\"HI\", \"Hawaii\");\n    states.insert(\"ID\", \"Idaho\");\n    states.insert(\"IL\", \"Illinois\");\n    states.insert(\"IN\", \"Indiana\");\n    states.insert(\"IA\", \"Iowa\");\n    states.insert(\"KS\", \"Kansas\");\n    states.insert(\"KY\", \"Kentucky\");\n    states.insert(\"LA\", \"Louisiana\");\n    states.insert(\"ME\", \"Maine\");\n    states.insert(\"MD\", \"Maryland\");\n    states.insert(\"MA\", \"Massachusetts\");\n    states.insert(\"MI\", \"Michigan\");\n    states.insert(\"MN\", \"Minnesota\");\n    states.insert(\"MS\", \"Mississippi\");\n    states.insert(\"MO\", \"Missouri\");\n    states.insert(\"MT\", \"Montana\");\n    states.insert(\"NE\", \"Nebraska\");\n    states.insert(\"NV\", \"Nevada\");\n    states.insert(\"NH\", \"New Hampshire\");\n    states.insert(\"NJ\", \"New Jersey\");\n    states.insert(\"NM\", \"New Mexico\");\n    states.insert(\"NY\", \"New York\");\n    states.insert(\"NC\", \"North Carolina\");\n    states.insert(\"ND\", \"North Dakota\");\n    states.insert(\"OH\", \"Ohio\");\n    states.insert(\"OK\", \"Oklahoma\");\n    states.insert(\"OR\", \"Oregon\");\n    states.insert(\"PA\", \"Pennsylvania\");\n    states.insert(\"RI\", \"Rhode Island\");\n    states.insert(\"SC\", \"South Carolina\");\n    states.insert(\"SD\", \"South Dakota\");\n    states.insert(\"TN\", \"Tennessee\");\n    states.insert(\"TX\", \"Texas\");\n    states.insert(\"UT\", \"Utah\");\n    states.insert(\"VT\", \"Vermont\");\n    states.insert(\"VA\", \"Virginia\");\n    states.insert(\"WA\", \"Washington\");\n    states.insert(\"WV\", \"West Virginia\");\n    states.insert(\"WI\", \"Wisconsin\");\n    states.insert(\"WY\", \"Wyoming\");\n\n    states.get(abbreviation).copied()\n}\n```"
  },
  {
    "task": "Build a dictionary to store customer names and their order histories.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let mut customer_orders: HashMap<String, Vec<String>> = HashMap::new();\n\n    // Example data: Adding customers and their order histories\n    customer_orders.insert(\n        String::from(\"Alice\"),\n        vec![String::from(\"Order1\"), String::from(\"Order2\")],\n    );\n    customer_orders.insert(\n        String::from(\"Bob\"),\n        vec![String::from(\"Order3\")],\n    );\n\n    // Accessing the data\n    if let Some(orders) = customer_orders.get(\"Alice\") {\n        println!(\"Alice's orders: {:?}\", orders);\n    } else {\n        println!(\"No orders found for Alice.\");\n    }\n}\n```"
  },
  {
    "task": "Implement a map to manage parking lot spaces, tracking which spaces are occupied.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let mut parking_lot: HashMap<u32, bool> = HashMap::new();\n\n    // Example of adding spaces and their occupancy status\n    parking_lot.insert(1, true);  // Space 1 is occupied\n    parking_lot.insert(2, false); // Space 2 is free\n    parking_lot.insert(3, true);  // Space 3 is occupied\n\n    // Check occupancy of a specific space\n    let space_number = 2;\n    if let Some(&occupied) = parking_lot.get(&space_number) {\n        if occupied {\n            println!(\"Space {} is occupied.\", space_number);\n        } else {\n            println!(\"Space {} is free.\", space_number);\n        }\n    } else {\n        println!(\"Space {} does not exist.\", space_number);\n    }\n}\n```"
  },
  {
    "task": "Create a program that uses a dictionary to track the scores of players in a game.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let mut scores: HashMap<&str, i32> = HashMap::new();\n\n    // Adding scores for players\n    scores.insert(\"Alice\", 10);\n    scores.insert(\"Bob\", 20);\n    scores.insert(\"Charlie\", 15);\n\n    // Accessing and printing scores\n    for (player, score) in &scores {\n        println!(\"{}: {}\", player, score);\n    }\n}\n```"
  },
  {
    "task": "Design a dictionary to store scientific terms and their definitions, allowing users to look up definitions.",
    "code": "```rust\nuse std::collections::HashMap;\nuse std::io;\n\nfn main() {\n    let mut scientific_terms = HashMap::new();\n\n    scientific_terms.insert(\"Gravity\", \"The force that attracts a body toward the center of the earth, or toward any other physical body having mass.\");\n    scientific_terms.insert(\"Atom\", \"The basic unit of a chemical element.\");\n    scientific_terms.insert(\"Photosynthesis\", \"The process by which green plants and some other organisms use sunlight to synthesize foods with the help of chlorophyll.\");\n\n    let mut input = String::new();\n    println!(\"Enter a scientific term to look up its definition:\");\n\n    io::stdin().read_line(&mut input).expect(\"Failed to read line\");\n    let term = input.trim();\n\n    match scientific_terms.get(term) {\n        Some(definition) => println!(\"Definition of {}: {}\", term, definition),\n        None => println!(\"Term not found.\"),\n    }\n}\n```"
  },
  {
    "task": "Write a function that uses a map to convert temperature scales (e.g., Celsius to Fahrenheit).",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn convert_temperature(value: f64, from_scale: &str, to_scale: &str) -> Option<f64> {\n    let mut conversion_map: HashMap<(&str, &str), Box<dyn Fn(f64) -> f64>> = HashMap::new();\n    \n    conversion_map.insert((\"Celsius\", \"Fahrenheit\"), Box::new(|c| c * 9.0 / 5.0 + 32.0));\n    conversion_map.insert((\"Fahrenheit\", \"Celsius\"), Box::new(|f| (f - 32.0) * 5.0 / 9.0));\n    conversion_map.insert((\"Celsius\", \"Kelvin\"), Box::new(|c| c + 273.15));\n    conversion_map.insert((\"Kelvin\", \"Celsius\"), Box::new(|k| k - 273.15));\n    conversion_map.insert((\"Fahrenheit\", \"Kelvin\"), Box::new(|f| (f - 32.0) * 5.0 / 9.0 + 273.15));\n    conversion_map.insert((\"Kelvin\", \"Fahrenheit\"), Box::new(|k| (k - 273.15) * 9.0 / 5.0 + 32.0));\n    \n    conversion_map.get(&(from_scale, to_scale)).map(|conversion_fn| conversion_fn(value))\n}\n\nfn main() {\n    let value_c_to_f = convert_temperature(25.0, \"Celsius\", \"Fahrenheit\");\n    let value_f_to_c = convert_temperature(77.0, \"Fahrenheit\", \"Celsius\");\n    \n    if let Some(v) = value_c_to_f {\n        println!(\"25 Celsius is {} Fahrenheit\", v);\n    } else {\n        println!(\"Conversion not supported\");\n    }\n    \n    if let Some(v) = value_f_to_c {\n        println!(\"77 Fahrenheit is {} Celsius\", v);\n    } else {\n        println!(\"Conversion not supported\");\n    }\n}\n```"
  },
  {
    "task": "Create a dictionary to store employee names and their respective departments.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let mut employee_departments = HashMap::new();\n\n    employee_departments.insert(\"Alice\", \"Engineering\");\n    employee_departments.insert(\"Bob\", \"Marketing\");\n    employee_departments.insert(\"Charlie\", \"Human Resources\");\n\n    // Example usage\n    for (employee, department) in &employee_departments {\n        println!(\"{} works in {}\", employee, department);\n    }\n}\n```"
  },
  {
    "task": "Build a program that uses a map to store tourist attractions and their locations.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let mut attractions = HashMap::new();\n\n    attractions.insert(\"Eiffel Tower\", \"Paris, France\");\n    attractions.insert(\"Statue of Liberty\", \"New York City, USA\");\n    attractions.insert(\"Colosseum\", \"Rome, Italy\");\n    attractions.insert(\"Great Wall of China\", \"China\");\n    attractions.insert(\"Machu Picchu\", \"Cusco Region, Peru\");\n\n    for (attraction, location) in &attractions {\n        println!(\"The {} is located in {}\", attraction, location);\n    }\n}\n```"
  },
  {
    "task": "Implement a dictionary to manage a collection of music albums, allowing additions and removals.",
    "code": "```rust\nuse std::collections::HashMap;\n\nstruct MusicCollection {\n    albums: HashMap<String, String>,\n}\n\nimpl MusicCollection {\n    fn new() -> Self {\n        MusicCollection {\n            albums: HashMap::new(),\n        }\n    }\n\n    fn add_album(&mut self, title: &str, artist: &str) {\n        self.albums.insert(title.to_string(), artist.to_string());\n    }\n\n    fn remove_album(&mut self, title: &str) -> Option<String> {\n        self.albums.remove(title)\n    }\n}\n\nfn main() {\n    let mut collection = MusicCollection::new();\n    collection.add_album(\"The Wall\", \"Pink Floyd\");\n    collection.add_album(\"Abbey Road\", \"The Beatles\");\n    \n    collection.remove_album(\"The Wall\");\n}\n```"
  },
  {
    "task": "Write a script that uses a map to track the inventory of a small retail store.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let mut inventory = HashMap::new();\n\n    // Add items to the inventory\n    inventory.insert(\"Apples\", 50);\n    inventory.insert(\"Bananas\", 30);\n    inventory.insert(\"Oranges\", 20);\n\n    // Function to display inventory\n    fn display_inventory(inventory: &HashMap<&str, i32>) {\n        for (item, quantity) in inventory {\n            println!(\"Item: {}, Quantity: {}\", item, quantity);\n        }\n    }\n\n    // Display the current inventory\n    display_inventory(&inventory);\n\n    // Update the inventory\n    if let Some(quantity) = inventory.get_mut(\"Apples\") {\n        *quantity += 10;\n    }\n\n    // Remove an item from the inventory\n    inventory.remove(\"Bananas\");\n\n    // Display the updated inventory\n    display_inventory(&inventory);\n}\n```"
  },
  {
    "task": "Create a dictionary to store the names of rivers and their lengths, allowing length lookups by river name.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let mut river_lengths = HashMap::new();\n    \n    river_lengths.insert(\"Nile\", 6650);\n    river_lengths.insert(\"Amazon\", 6400);\n    river_lengths.insert(\"Yangtze\", 6300);\n    \n    let river_name = \"Nile\";\n    if let Some(length) = river_lengths.get(river_name) {\n        println!(\"The length of the {} is {} km.\", river_name, length);\n    } else {\n        println!(\"River not found.\");\n    }\n}\n```"
  },
  {
    "task": "Design a system that uses a map to track the availability of conference rooms in an office building.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let mut conference_rooms: HashMap<&str, bool> = HashMap::new();\n\n    // Initialize the conference rooms with their availability\n    conference_rooms.insert(\"Room A\", true); // true indicates available\n    conference_rooms.insert(\"Room B\", false);\n    conference_rooms.insert(\"Room C\", true);\n\n    // Function to book a room\n    fn book_room(rooms: &mut HashMap<&str, bool>, room_name: &str) -> bool {\n        if let Some(available) = rooms.get_mut(room_name) {\n            if *available {\n                *available = false;\n                return true;\n            }\n        }\n        false\n    }\n\n    // Function to release a room\n    fn release_room(rooms: &mut HashMap<&str, bool>, room_name: &str) -> bool {\n        if let Some(available) = rooms.get_mut(room_name) {\n            if !*available {\n                *available = true;\n                return true;\n            }\n        }\n        false\n    }\n\n    // Example usage\n    if book_room(&mut conference_rooms, \"Room A\") {\n        println!(\"Room A booked successfully.\");\n    } else {\n        println!(\"Room A is already booked or does not exist.\");\n    }\n\n    if release_room(&mut conference_rooms, \"Room B\") {\n        println!(\"Room B released successfully.\");\n    } else {\n        println!(\"Room B is already available or does not exist.\");\n    }\n}\n```"
  },
  {
    "task": "Develop a program that uses a dictionary to associate animal species with their habitats.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let mut animal_habitats = HashMap::new();\n\n    animal_habitats.insert(\"Lion\", \"Savannah\");\n    animal_habitats.insert(\"Polar Bear\", \"Arctic\");\n    animal_habitats.insert(\"Kangaroo\", \"Australian Outback\");\n    animal_habitats.insert(\"Penguin\", \"Antarctica\");\n    animal_habitats.insert(\"Eagle\", \"Mountains\");\n\n    for (animal, habitat) in &animal_habitats {\n        println!(\"The {} lives in the {}.\", animal, habitat);\n    }\n}\n```"
  },
  {
    "task": "Create a map to store the names of mountains and their elevations, then find the tallest mountain.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let mut mountains = HashMap::new();\n    mountains.insert(\"Mount Everest\", 8848);\n    mountains.insert(\"K2\", 8611);\n    mountains.insert(\"Kangchenjunga\", 8586);\n    mountains.insert(\"Lhotse\", 8516);\n    mountains.insert(\"Makalu\", 8485);\n\n    let tallest_mountain = mountains\n        .iter()\n        .max_by_key(|&(_, elevation)| elevation)\n        .map(|(name, _)| name);\n\n    if let Some(name) = tallest_mountain {\n        println!(\"The tallest mountain is: {}\", name);\n    }\n}\n```"
  },
  {
    "task": "Write a function that uses a dictionary to convert time zones to their respective UTC offsets.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn time_zone_to_utc_offset(zone: &str) -> Option<&'static str> {\n    let mut time_zone_map: HashMap<&str, &str> = HashMap::new();\n    time_zone_map.insert(\"EST\", \"-05:00\");\n    time_zone_map.insert(\"CST\", \"-06:00\");\n    time_zone_map.insert(\"MST\", \"-07:00\");\n    time_zone_map.insert(\"PST\", \"-08:00\");\n    time_zone_map.insert(\"GMT\", \"+00:00\");\n    time_zone_map.insert(\"CET\", \"+01:00\");\n    time_zone_map.insert(\"IST\", \"+05:30\");\n    \n    time_zone_map.get(zone).copied()\n}\n\nfn main() {\n    if let Some(offset) = time_zone_to_utc_offset(\"EST\") {\n        println!(\"The UTC offset for EST is {}\", offset);\n    } else {\n        println!(\"Time zone not found.\");\n    }\n}\n```"
  },
  {
    "task": "Build a dictionary to store the names of programming languages and their creators.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let mut programming_languages = HashMap::new();\n    \n    programming_languages.insert(\"Python\", \"Guido van Rossum\");\n    programming_languages.insert(\"Java\", \"James Gosling\");\n    programming_languages.insert(\"C\", \"Dennis Ritchie\");\n    programming_languages.insert(\"C++\", \"Bjarne Stroustrup\");\n    programming_languages.insert(\"Rust\", \"Graydon Hoare\");\n    \n    for (language, creator) in &programming_languages {\n        println!(\"{} was created by {}\", language, creator);\n    }\n}\n```"
  },
  {
    "task": "Implement a map to manage a list of subscribers to a newsletter, allowing subscriptions and cancellations.",
    "code": "```rust\nuse std::collections::HashMap;\n\nstruct Newsletter {\n    subscribers: HashMap<String, String>,\n}\n\nimpl Newsletter {\n    fn new() -> Self {\n        Newsletter {\n            subscribers: HashMap::new(),\n        }\n    }\n\n    fn subscribe(&mut self, email: &str, name: &str) {\n        self.subscribers.insert(email.to_string(), name.to_string());\n    }\n\n    fn unsubscribe(&mut self, email: &str) {\n        self.subscribers.remove(email);\n    }\n\n    fn list_subscribers(&self) -> Vec<String> {\n        self.subscribers\n            .iter()\n            .map(|(email, name)| format!(\"{}: {}\", name, email))\n            .collect()\n    }\n}\n\nfn main() {\n    let mut newsletter = Newsletter::new();\n    \n    newsletter.subscribe(\"alice@example.com\", \"Alice\");\n    newsletter.subscribe(\"bob@example.com\", \"Bob\");\n    \n    println!(\"Subscribers: {:?}\", newsletter.list_subscribers());\n    \n    newsletter.unsubscribe(\"alice@example.com\");\n    \n    println!(\"Subscribers after unsubscribe: {:?}\", newsletter.list_subscribers());\n}\n```"
  },
  {
    "task": "Create a program that uses a dictionary to track the number of likes for social media posts.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let mut likes: HashMap<&str, i32> = HashMap::new();\n\n    // Example social media posts\n    let posts = vec![\"post1\", \"post2\", \"post3\"];\n\n    // Initialize likes for each post\n    for &post in &posts {\n        likes.insert(post, 0);\n    }\n\n    // Simulate liking posts\n    like_post(&mut likes, \"post1\");\n    like_post(&mut likes, \"post2\");\n    like_post(&mut likes, \"post1\");\n\n    // Print the number of likes for each post\n    for post in &posts {\n        if let Some(&count) = likes.get(post) {\n            println!(\"{} has {} likes\", post, count);\n        }\n    }\n}\n\nfn like_post(likes: &mut HashMap<&str, i32>, post: &str) {\n    if let Some(count) = likes.get_mut(post) {\n        *count += 1;\n    }\n}\n```"
  },
  {
    "task": "Design a dictionary to store the names of elements and their atomic numbers, allowing lookups by element name.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let mut elements = HashMap::new();\n\n    elements.insert(\"Hydrogen\", 1);\n    elements.insert(\"Helium\", 2);\n    elements.insert(\"Lithium\", 3);\n    elements.insert(\"Beryllium\", 4);\n    elements.insert(\"Boron\", 5);\n    elements.insert(\"Carbon\", 6);\n    elements.insert(\"Nitrogen\", 7);\n    elements.insert(\"Oxygen\", 8);\n    elements.insert(\"Fluorine\", 9);\n    elements.insert(\"Neon\", 10);\n\n    if let Some(atomic_number) = elements.get(\"Oxygen\") {\n        println!(\"The atomic number of Oxygen is {}\", atomic_number);\n    }\n}\n```"
  },
  {
    "task": "Write a function that uses a map to group movies by their directors.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn group_movies_by_director(movies: Vec<(String, String)>) -> HashMap<String, Vec<String>> {\n    let mut director_map: HashMap<String, Vec<String>> = HashMap::new();\n\n    for (movie, director) in movies {\n        director_map.entry(director).or_insert_with(Vec::new).push(movie);\n    }\n\n    director_map\n}\n\nfn main() {\n    let movies = vec![\n        (\"Inception\".to_string(), \"Christopher Nolan\".to_string()),\n        (\"Interstellar\".to_string(), \"Christopher Nolan\".to_string()),\n        (\"Dunkirk\".to_string(), \"Christopher Nolan\".to_string()),\n        (\"Pulp Fiction\".to_string(), \"Quentin Tarantino\".to_string()),\n        (\"The Hateful Eight\".to_string(), \"Quentin Tarantino\".to_string()),\n    ];\n\n    let grouped_movies = group_movies_by_director(movies);\n    for (director, movies) in grouped_movies {\n        println!(\"{}: {:?}\", director, movies);\n    }\n}\n```"
  },
  {
    "task": "Create a dictionary to store the names of historical figures and their birth years.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let mut historical_figures = HashMap::new();\n    \n    historical_figures.insert(\"Albert Einstein\", 1879);\n    historical_figures.insert(\"Isaac Newton\", 1643);\n    historical_figures.insert(\"Marie Curie\", 1867);\n    historical_figures.insert(\"Leonardo da Vinci\", 1452);\n    historical_figures.insert(\"Galileo Galilei\", 1564);\n\n    for (name, birth_year) in &historical_figures {\n        println!(\"{} was born in {}\", name, birth_year);\n    }\n}\n```"
  },
  {
    "task": "Build a program that uses a map to store the names of planets and their diameters.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let mut planets: HashMap<&str, u64> = HashMap::new();\n\n    planets.insert(\"Mercury\", 4879);\n    planets.insert(\"Venus\", 12104);\n    planets.insert(\"Earth\", 12742);\n    planets.insert(\"Mars\", 6779);\n    planets.insert(\"Jupiter\", 139820);\n    planets.insert(\"Saturn\", 116460);\n    planets.insert(\"Uranus\", 50724);\n    planets.insert(\"Neptune\", 49244);\n\n    for (planet, diameter) in &planets {\n        println!(\"The diameter of {} is {} kilometers.\", planet, diameter);\n    }\n}\n```"
  },
  {
    "task": "Implement a dictionary to track the ratings of restaurants, allowing updates to ratings.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let mut restaurant_ratings: HashMap<String, u32> = HashMap::new();\n\n    // Adding initial ratings\n    restaurant_ratings.insert(\"Pasta Palace\".to_string(), 5);\n    restaurant_ratings.insert(\"Burger Bistro\".to_string(), 4);\n\n    // Update a rating\n    let restaurant = \"Pasta Palace\".to_string();\n    if let Some(rating) = restaurant_ratings.get_mut(&restaurant) {\n        *rating = 4;  // Update the rating\n    }\n\n    // Example of adding a new restaurant\n    restaurant_ratings.insert(\"Sushi Spot\".to_string(), 5);\n\n    // Printing all ratings\n    for (restaurant, rating) in &restaurant_ratings {\n        println!(\"{}: {}\", restaurant, rating);\n    }\n}\n```"
  },
  {
    "task": "Write a script that uses a map to translate binary numbers to decimal.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn binary_to_decimal(binary: &str) -> Option<i32> {\n    let binary_map: HashMap<char, i32> = [('0', 0), ('1', 1)].iter().cloned().collect();\n    binary.chars().rev().enumerate().try_fold(0, |acc, (i, c)| {\n        binary_map.get(&c).map(|&val| acc + val * (1 << i))\n    })\n}\n\nfn main() {\n    let binary_numbers = vec![\"101\", \"111\", \"1001\", \"invalid\"];\n    \n    for binary in binary_numbers {\n        match binary_to_decimal(binary) {\n            Some(decimal) => println!(\"Binary: {} -> Decimal: {}\", binary, decimal),\n            None => println!(\"Binary: {} is invalid\", binary),\n        }\n    }\n}\n```"
  },
  {
    "task": "Create a dictionary to store the names of artists and their famous works.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let mut artists_works = HashMap::new();\n\n    artists_works.insert(\"Vincent van Gogh\", \"Starry Night\");\n    artists_works.insert(\"Leonardo da Vinci\", \"Mona Lisa\");\n    artists_works.insert(\"Pablo Picasso\", \"Guernica\");\n    artists_works.insert(\"Claude Monet\", \"Water Lilies\");\n\n    for (artist, work) in &artists_works {\n        println!(\"{}: {}\", artist, work);\n    }\n}\n```"
  },
  {
    "task": "Design a system that uses a map to track the maintenance schedules of vehicles.",
    "code": "```rust\nuse std::collections::HashMap;\n\nstruct MaintenanceSchedule {\n    vehicle_id: String,\n    schedule: String,\n}\n\nstruct MaintenanceTracker {\n    schedules: HashMap<String, MaintenanceSchedule>,\n}\n\nimpl MaintenanceTracker {\n    fn new() -> Self {\n        MaintenanceTracker {\n            schedules: HashMap::new(),\n        }\n    }\n\n    fn add_schedule(&mut self, vehicle_id: String, schedule: String) {\n        let maintenance_schedule = MaintenanceSchedule {\n            vehicle_id: vehicle_id.clone(),\n            schedule,\n        };\n        self.schedules.insert(vehicle_id, maintenance_schedule);\n    }\n\n    fn get_schedule(&self, vehicle_id: &str) -> Option<&MaintenanceSchedule> {\n        self.schedules.get(vehicle_id)\n    }\n\n    fn remove_schedule(&mut self, vehicle_id: &str) {\n        self.schedules.remove(vehicle_id);\n    }\n}\n\nfn main() {\n    let mut tracker = MaintenanceTracker::new();\n\n    tracker.add_schedule(\"V123\".to_string(), \"2023-10-01\".to_string());\n    tracker.add_schedule(\"V456\".to_string(), \"2023-11-15\".to_string());\n\n    if let Some(schedule) = tracker.get_schedule(\"V123\") {\n        println!(\"Vehicle ID: {}, Schedule: {}\", schedule.vehicle_id, schedule.schedule);\n    }\n\n    tracker.remove_schedule(\"V456\");\n}\n```"
  },
  {
    "task": "Develop a program that uses a dictionary to associate languages with their number of speakers worldwide.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let mut language_speakers = HashMap::new();\n\n    language_speakers.insert(\"English\", 1500_000_000);\n    language_speakers.insert(\"Mandarin\", 1100_000_000);\n    language_speakers.insert(\"Hindi\", 600_000_000);\n    language_speakers.insert(\"Spanish\", 500_000_000);\n    language_speakers.insert(\"French\", 280_000_000);\n\n    for (language, speakers) in &language_speakers {\n        println!(\"{}: {} speakers\", language, speakers);\n    }\n}\n```"
  },
  {
    "task": "Create a map to store the names of cities and their average annual temperatures.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let mut city_temperatures = HashMap::new();\n\n    city_temperatures.insert(\"New York\", 12.5);\n    city_temperatures.insert(\"Los Angeles\", 18.7);\n    city_temperatures.insert(\"Chicago\", 10.3);\n    city_temperatures.insert(\"Houston\", 20.8);\n    city_temperatures.insert(\"Phoenix\", 23.7);\n\n    for (city, temperature) in &city_temperatures {\n        println!(\"The average annual temperature in {} is {}\u00b0C\", city, temperature);\n    }\n}\n```"
  },
  {
    "task": "Write a function that uses a dictionary to convert metric units to imperial units.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn convert_metric_to_imperial(unit: &str, value: f64) -> Option<f64> {\n    let conversion_factors: HashMap<&str, f64> = [\n        (\"meter\", 3.28084),         // meters to feet\n        (\"kilogram\", 2.20462),      // kilograms to pounds\n        (\"liter\", 0.264172),        // liters to gallons\n    ].iter().cloned().collect();\n\n    conversion_factors.get(unit).map(|factor| value * factor)\n}\n\nfn main() {\n    let unit = \"meter\";\n    let value = 10.0;\n    if let Some(converted_value) = convert_metric_to_imperial(unit, value) {\n        println!(\"{} {} is {} in imperial units.\", value, unit, converted_value);\n    } else {\n        println!(\"Conversion for '{}' is not available.\", unit);\n    }\n}\n```"
  },
  {
    "task": "Build a dictionary to store the names of sports and their respective world records.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let mut world_records = HashMap::new();\n\n    world_records.insert(\"100m Sprint\", \"9.58 seconds\");\n    world_records.insert(\"Marathon\", \"2:01:39\");\n    world_records.insert(\"Long Jump\", \"8.95 meters\");\n    world_records.insert(\"High Jump\", \"2.45 meters\");\n    world_records.insert(\"Pole Vault\", \"6.18 meters\");\n\n    for (sport, record) in &world_records {\n        println!(\"{}: {}\", sport, record);\n    }\n}\n```"
  },
  {
    "task": "Implement a map to manage a list of favorite movies, allowing additions and deletions.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let mut favorite_movies: HashMap<String, String> = HashMap::new();\n\n    // Add movies\n    favorite_movies.insert(\"Alice\".to_string(), \"Inception\".to_string());\n    favorite_movies.insert(\"Bob\".to_string(), \"The Matrix\".to_string());\n    favorite_movies.insert(\"Charlie\".to_string(), \"Interstellar\".to_string());\n\n    // Remove a movie\n    favorite_movies.remove(\"Bob\");\n\n    // Print all favorite movies\n    for (person, movie) in &favorite_movies {\n        println!(\"{}'s favorite movie is {}\", person, movie);\n    }\n}\n```"
  },
  {
    "task": "Create a program that uses a dictionary to track the distances between pairs of cities.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let mut city_distances = HashMap::new();\n\n    city_distances.insert((\"New York\", \"Los Angeles\"), 2790);\n    city_distances.insert((\"Chicago\", \"Houston\"), 1084);\n    city_distances.insert((\"San Francisco\", \"Seattle\"), 807);\n    city_distances.insert((\"Miami\", \"Atlanta\"), 661);\n\n    // Accessing the distance between New York and Los Angeles\n    if let Some(distance) = city_distances.get(&(\"New York\", \"Los Angeles\")) {\n        println!(\"Distance between New York and Los Angeles: {} miles\", distance);\n    } else {\n        println!(\"Distance not found\");\n    }\n\n    // Iterating over all city pairs\n    for ((city1, city2), distance) in &city_distances {\n        println!(\"Distance between {} and {}: {} miles\", city1, city2, distance);\n    }\n}\n```"
  },
  {
    "task": "Design a dictionary to store the names of planets and their orbital periods.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let mut planet_orbital_periods = HashMap::new();\n\n    planet_orbital_periods.insert(\"Mercury\", 87.97);\n    planet_orbital_periods.insert(\"Venus\", 224.70);\n    planet_orbital_periods.insert(\"Earth\", 365.25);\n    planet_orbital_periods.insert(\"Mars\", 686.98);\n    planet_orbital_periods.insert(\"Jupiter\", 4332.59);\n    planet_orbital_periods.insert(\"Saturn\", 10759.22);\n    planet_orbital_periods.insert(\"Uranus\", 30688.5);\n    planet_orbital_periods.insert(\"Neptune\", 60182.0);\n\n    for (planet, period) in &planet_orbital_periods {\n        println!(\"{}: {}\", planet, period);\n    }\n}\n```"
  },
  {
    "task": "Write a function that uses a map to convert HTML color codes to their respective color names.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn color_code_to_name(code: &str) -> Option<&'static str> {\n    let mut color_map = HashMap::new();\n    color_map.insert(\"#FFFFFF\", \"White\");\n    color_map.insert(\"#000000\", \"Black\");\n    color_map.insert(\"#FF0000\", \"Red\");\n    color_map.insert(\"#00FF00\", \"Green\");\n    color_map.insert(\"#0000FF\", \"Blue\");\n    // Add more mappings as needed\n\n    color_map.get(code).copied()\n}\n\nfn main() {\n    let color_code = \"#FF0000\";\n    match color_code_to_name(color_code) {\n        Some(name) => println!(\"The color name for {} is {}.\", color_code, name),\n        None => println!(\"Color code {} not found.\", color_code),\n    }\n}\n```"
  },
  {
    "task": "Create a dictionary to store the names of composers and their famous compositions.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let mut composers: HashMap<&str, &str> = HashMap::new();\n    \n    composers.insert(\"Ludwig van Beethoven\", \"Symphony No. 9\");\n    composers.insert(\"Wolfgang Amadeus Mozart\", \"The Magic Flute\");\n    composers.insert(\"Johann Sebastian Bach\", \"Brandenburg Concertos\");\n    composers.insert(\"Fr\u00e9d\u00e9ric Chopin\", \"Nocturne in E-flat major, Op. 9, No. 2\");\n    composers.insert(\"Pyotr Ilyich Tchaikovsky\", \"Swan Lake\");\n    \n    // Example of accessing the dictionary\n    if let Some(composition) = composers.get(\"Ludwig van Beethoven\") {\n        println!(\"Ludwig van Beethoven's famous composition: {}\", composition);\n    }\n}\n```"
  },
  {
    "task": "Build a program that uses a map to store the names of bridges and their lengths.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let mut bridges = HashMap::new();\n\n    bridges.insert(\"Golden Gate Bridge\", 2737);\n    bridges.insert(\"Brooklyn Bridge\", 1595);\n    bridges.insert(\"Tower Bridge\", 801);\n    bridges.insert(\"Sydney Harbour Bridge\", 1149);\n\n    for (name, length) in &bridges {\n        println!(\"{}: {} meters\", name, length);\n    }\n}\n```"
  },
  {
    "task": "Implement a dictionary to manage a list of personal goals, allowing updates to goals.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let mut goals: HashMap<String, String> = HashMap::new();\n\n    // Adding goals\n    goals.insert(\"Fitness\".to_string(), \"Run a marathon\".to_string());\n    goals.insert(\"Education\".to_string(), \"Learn Rust\".to_string());\n\n    // Updating a goal\n    if let Some(goal) = goals.get_mut(\"Fitness\") {\n        *goal = \"Run a half-marathon\".to_string();\n    }\n\n    // Display goals\n    for (category, goal) in &goals {\n        println!(\"{}: {}\", category, goal);\n    }\n}\n```"
  },
  {
    "task": "Write a script that uses a map to convert hexadecimal numbers to binary.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let mut hex_to_bin = HashMap::new();\n    hex_to_bin.insert('0', \"0000\");\n    hex_to_bin.insert('1', \"0001\");\n    hex_to_bin.insert('2', \"0010\");\n    hex_to_bin.insert('3', \"0011\");\n    hex_to_bin.insert('4', \"0100\");\n    hex_to_bin.insert('5', \"0101\");\n    hex_to_bin.insert('6', \"0110\");\n    hex_to_bin.insert('7', \"0111\");\n    hex_to_bin.insert('8', \"1000\");\n    hex_to_bin.insert('9', \"1001\");\n    hex_to_bin.insert('A', \"1010\");\n    hex_to_bin.insert('B', \"1011\");\n    hex_to_bin.insert('C', \"1100\");\n    hex_to_bin.insert('D', \"1101\");\n    hex_to_bin.insert('E', \"1110\");\n    hex_to_bin.insert('F', \"1111\");\n\n    let hex_string = \"1A3F\";\n    let binary_string: String = hex_string.chars().filter_map(|c| hex_to_bin.get(&c)).collect();\n    println!(\"Hex: {} -> Binary: {}\", hex_string, binary_string);\n}\n```"
  },
  {
    "task": "Create a dictionary to store the names of trees and their average heights.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let mut tree_heights: HashMap<&str, f32> = HashMap::new();\n    tree_heights.insert(\"Oak\", 20.0);\n    tree_heights.insert(\"Pine\", 30.0);\n    tree_heights.insert(\"Maple\", 15.0);\n    tree_heights.insert(\"Birch\", 18.0);\n    tree_heights.insert(\"Willow\", 12.5);\n\n    for (tree, height) in &tree_heights {\n        println!(\"The average height of a {} is {} meters.\", tree, height);\n    }\n}\n```"
  }
]