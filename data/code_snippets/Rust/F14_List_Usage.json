[
  {
    "task": "Create a list of the first ten positive integers and calculate their sum.",
    "code": "```rust\nfn main() {\n    let numbers: Vec<i32> = (1..=10).collect();\n    let sum: i32 = numbers.iter().sum();\n    println!(\"The sum is: {}\", sum);\n}\n```"
  },
  {
    "task": "Write a program to reverse the order of elements in a given list.",
    "code": "```rust\nfn main() {\n    let mut list = vec![1, 2, 3, 4, 5];\n    list.reverse();\n    println!(\"{:?}\", list);\n}\n```"
  },
  {
    "task": "Implement a function that takes a list and returns the list with duplicates removed.",
    "code": "```rust\nfn remove_duplicates<T: std::hash::Hash + Eq + Clone>(list: &[T]) -> Vec<T> {\n    use std::collections::HashSet;\n    let mut seen = HashSet::new();\n    list.iter().cloned().filter(|item| seen.insert(item.clone())).collect()\n}\n\nfn main() {\n    let list = vec![1, 2, 2, 3, 4, 4, 5];\n    let result = remove_duplicates(&list);\n    println!(\"{:?}\", result);\n}\n```"
  },
  {
    "task": "Create a list of names and sort them in alphabetical order.",
    "code": "```rust\nfn main() {\n    let mut names = vec![\"Alice\", \"Bob\", \"Charlie\", \"David\"];\n    names.sort();\n    println!(\"{:?}\", names);\n}\n```"
  },
  {
    "task": "Write a function that appends a new element to an existing list.",
    "code": "```rust\nfn append_to_list<T>(list: &mut Vec<T>, element: T) {\n    list.push(element);\n}\n```"
  },
  {
    "task": "Generate a list of the first 20 even numbers.",
    "code": "```rust\nfn main() {\n    let even_numbers: Vec<u32> = (1..=20).map(|x| x * 2).collect();\n    println!(\"{:?}\", even_numbers);\n}\n```"
  },
  {
    "task": "Create a nested list (a list of lists) and access an element from the inner list.",
    "code": "```rust\nfn main() {\n    let nested_list = vec![\n        vec![1, 2, 3],\n        vec![4, 5, 6],\n        vec![7, 8, 9],\n    ];\n    \n    let element = nested_list[1][2];\n    \n    println!(\"The accessed element is: {}\", element);\n}\n```"
  },
  {
    "task": "Write a program that finds the maximum value in a list of integers.",
    "code": "```rust\nfn main() {\n    let numbers = vec![34, 56, 23, 89, 12];\n    let max_value = numbers.iter().max().unwrap();\n    println!(\"The maximum value is: {}\", max_value);\n}\n```"
  },
  {
    "task": "Implement a function to merge two lists into a single list without duplicates.",
    "code": "```rust\nuse std::collections::HashSet;\n\nfn merge_lists<T: Clone + std::cmp::Eq + std::hash::Hash>(list1: &[T], list2: &[T]) -> Vec<T> {\n    let mut set = HashSet::new();\n    list1.iter().chain(list2.iter()).for_each(|item| {\n        set.insert(item.clone());\n    });\n    set.into_iter().collect()\n}\n\nfn main() {\n    let list1 = vec![1, 2, 3, 4, 5];\n    let list2 = vec![4, 5, 6, 7, 8];\n    let merged_list = merge_lists(&list1, &list2);\n    println!(\"{:?}\", merged_list);\n}\n```"
  },
  {
    "task": "Create a list from user input, then display the list in reverse order.",
    "code": "```rust\nuse std::io::{self, Write};\n\nfn main() {\n    let mut input = String::new();\n    let mut list = Vec::new();\n\n    loop {\n        print!(\"Enter a value (or 'done' to finish): \");\n        io::stdout().flush().unwrap();\n        input.clear();\n        io::stdin().read_line(&mut input).unwrap();\n        let input = input.trim();\n        if input.eq_ignore_ascii_case(\"done\") {\n            break;\n        }\n        list.push(input.to_string());\n    }\n\n    list.reverse();\n    println!(\"Reversed list: {:?}\", list);\n}\n```"
  },
  {
    "task": "Write a function that takes a list and returns a new list containing only the even numbers.",
    "code": "```rust\nfn filter_even_numbers(numbers: &[i32]) -> Vec<i32> {\n    numbers.iter().cloned().filter(|&x| x % 2 == 0).collect()\n}\n```"
  },
  {
    "task": "Generate a list of squares for the numbers 1 through 10.",
    "code": "```rust\nfn main() {\n    let squares: Vec<i32> = (1..=10).map(|x| x * x).collect();\n    println!(\"{:?}\", squares);\n}\n```"
  },
  {
    "task": "Create a list of floating-point numbers and find their average.",
    "code": "```rust\nfn main() {\n    let numbers: Vec<f64> = vec![2.5, 3.0, 4.5, 5.5, 7.0];\n    let sum: f64 = numbers.iter().sum();\n    let average = sum / numbers.len() as f64;\n    println!(\"The average is: {}\", average);\n}\n```"
  },
  {
    "task": "Implement a program to rotate the elements of a list to the right by a given number of steps.",
    "code": "```rust\nfn rotate_right<T>(list: &mut Vec<T>, steps: usize) {\n    if list.is_empty() {\n        return;\n    }\n    let len = list.len();\n    let steps = steps % len;\n    if steps == 0 {\n        return;\n    }\n    list.reverse();\n    list[..steps].reverse();\n    list[steps..].reverse();\n}\n\nfn main() {\n    let mut list = vec![1, 2, 3, 4, 5];\n    let steps = 2;\n    rotate_right(&mut list, steps);\n    println!(\"{:?}\", list);\n}\n```"
  },
  {
    "task": "Write a function that checks if a list is a palindrome (reads the same forwards and backwards).",
    "code": "```rust\nfn is_palindrome<T: PartialEq>(list: &[T]) -> bool {\n    let len = list.len();\n    for i in 0..len / 2 {\n        if list[i] != list[len - i - 1] {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let list1 = vec![1, 2, 3, 2, 1];\n    let list2 = vec![1, 2, 3, 4, 5];\n    println!(\"{}\", is_palindrome(&list1)); // true\n    println!(\"{}\", is_palindrome(&list2)); // false\n}\n```"
  },
  {
    "task": "Create a list of random integers and count how many are greater than 50.",
    "code": "```rust\nuse rand::Rng;\n\nfn main() {\n    let mut rng = rand::thread_rng();\n    let list: Vec<i32> = (0..10).map(|_| rng.gen_range(0..100)).collect();\n    let count = list.iter().filter(|&&x| x > 50).count();\n    println!(\"List: {:?}\", list);\n    println!(\"Count of numbers greater than 50: {}\", count);\n}\n```"
  },
  {
    "task": "Write a program that removes the first occurrence of a specified element from a list.",
    "code": "```rust\nfn remove_first_occurrence<T: PartialEq>(list: &mut Vec<T>, element: T) {\n    if let Some(pos) = list.iter().position(|x| *x == element) {\n        list.remove(pos);\n    }\n}\n\nfn main() {\n    let mut list = vec![1, 2, 3, 4, 2, 5];\n    remove_first_occurrence(&mut list, 2);\n    println!(\"{:?}\", list);\n}\n```"
  },
  {
    "task": "Implement a function that takes two lists and returns a list containing their intersection.",
    "code": "```rust\nfn intersection<T: PartialEq + Clone>(list1: &[T], list2: &[T]) -> Vec<T> {\n    list1.iter()\n         .filter(|&item| list2.contains(item))\n         .cloned()\n         .collect()\n}\n\nfn main() {\n    let list1 = vec![1, 2, 3, 4, 5];\n    let list2 = vec![4, 5, 6, 7, 8];\n    let result = intersection(&list1, &list2);\n    println!(\"{:?}\", result); // Output: [4, 5]\n}\n```"
  },
  {
    "task": "Create a list of prime numbers less than 100.",
    "code": "```rust\nfn is_prime(n: u32) -> bool {\n    if n <= 1 {\n        return false;\n    }\n    for i in 2..=((n as f32).sqrt() as u32) {\n        if n % i == 0 {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let primes: Vec<u32> = (2..100).filter(|&x| is_prime(x)).collect();\n    println!(\"{:?}\", primes);\n}\n```"
  },
  {
    "task": "Write a function to split a list into two lists: one with even numbers and one with odd numbers.",
    "code": "```rust\nfn split_even_odd(numbers: &[i32]) -> (Vec<i32>, Vec<i32>) {\n    let mut evens = Vec::new();\n    let mut odds = Vec::new();\n    for &number in numbers {\n        if number % 2 == 0 {\n            evens.push(number);\n        } else {\n            odds.push(number);\n        }\n    }\n    (evens, odds)\n}\n\nfn main() {\n    let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    let (evens, odds) = split_even_odd(&numbers);\n    println!(\"Evens: {:?}\", evens);\n    println!(\"Odds: {:?}\", odds);\n}\n```"
  },
  {
    "task": "Create a list of strings and convert all the strings to uppercase.",
    "code": "```rust\nfn main() {\n    let strings = vec![\"hello\", \"world\", \"rust\"];\n    let uppercased_strings: Vec<String> = strings.iter().map(|s| s.to_uppercase()).collect();\n    println!(\"{:?}\", uppercased_strings);\n}\n```"
  },
  {
    "task": "Implement a program that removes all elements from a list that are less than a specified value.",
    "code": "```rust\nfn remove_less_than(values: &mut Vec<i32>, threshold: i32) {\n    values.retain(|&x| x >= threshold);\n}\n\nfn main() {\n    let mut numbers = vec![10, 20, 5, 30, 15];\n    let threshold = 15;\n    remove_less_than(&mut numbers, threshold);\n    println!(\"{:?}\", numbers);\n}\n```"
  },
  {
    "task": "Write a function that takes a list and returns a new list with elements in random order.",
    "code": "```rust\nuse rand::seq::SliceRandom;\nuse rand::thread_rng;\n\nfn shuffle_list<T: Clone>(list: &[T]) -> Vec<T> {\n    let mut shuffled_list = list.to_vec();\n    let mut rng = thread_rng();\n    shuffled_list.shuffle(&mut rng);\n    shuffled_list\n}\n```"
  },
  {
    "task": "Create a list of tuples where each tuple contains a number and its square.",
    "code": "```rust\nfn main() {\n    let numbers_and_squares: Vec<(i32, i32)> = (1..=10).map(|x| (x, x * x)).collect();\n    println!(\"{:?}\", numbers_and_squares);\n}\n```"
  },
  {
    "task": "Write a program to multiply all elements in a list by a given factor.",
    "code": "```rust\nfn multiply_elements_by_factor(list: &mut Vec<i32>, factor: i32) {\n    for element in list.iter_mut() {\n        *element *= factor;\n    }\n}\n\nfn main() {\n    let mut list = vec![1, 2, 3, 4, 5];\n    let factor = 3;\n    multiply_elements_by_factor(&mut list, factor);\n    println!(\"{:?}\", list);\n}\n```"
  },
  {
    "task": "Implement a function that flattens a nested list.",
    "code": "```rust\nfn flatten<T: Clone>(nested: &[Vec<T>]) -> Vec<T> {\n    nested.iter().flat_map(|v| v.clone()).collect()\n}\n\nfn main() {\n    let nested = vec![vec![1, 2], vec![3, 4, 5], vec![6]];\n    let flat = flatten(&nested);\n    println!(\"{:?}\", flat);\n}\n```"
  },
  {
    "task": "Create a list of dates and sort them chronologically.",
    "code": "```rust\nuse chrono::NaiveDate;\n\nfn main() {\n    let mut dates = vec![\n        NaiveDate::from_ymd(2023, 10, 5),\n        NaiveDate::from_ymd(2022, 9, 14),\n        NaiveDate::from_ymd(2023, 1, 30),\n    ];\n    \n    dates.sort();\n    \n    for date in dates {\n        println!(\"{}\", date);\n    }\n}\n```"
  },
  {
    "task": "Write a function that finds the index of the first occurrence of a given element in a list.",
    "code": "```rust\nfn find_index_of_first_occurrence<T: PartialEq>(list: &[T], element: T) -> Option<usize> {\n    list.iter().position(|x| *x == element)\n}\n\nfn main() {\n    let list = vec![1, 2, 3, 4, 5, 3];\n    let element = 3;\n    if let Some(index) = find_index_of_first_occurrence(&list, element) {\n        println!(\"Element found at index: {}\", index);\n    } else {\n        println!(\"Element not found\");\n    }\n}\n```"
  },
  {
    "task": "Generate a list of Fibonacci numbers up to a specified limit.",
    "code": "```rust\nfn fibonacci_up_to(limit: u32) -> Vec<u32> {\n    let mut fib_list = vec![0, 1];\n    while let [&last, &second_last] = fib_list.iter().rev().take(2).collect::<Vec<_>>().as_slice() {\n        let next = last + second_last;\n        if next > limit {\n            break;\n        }\n        fib_list.push(next);\n    }\n    fib_list\n}\n\nfn main() {\n    let limit = 100;\n    let fib_numbers = fibonacci_up_to(limit);\n    println!(\"{:?}\", fib_numbers);\n}\n```"
  },
  {
    "task": "Create a list of booleans and determine if all are True.",
    "code": "```rust\nfn main() {\n    let bool_list = vec![true, true, true, false];\n    let all_true = bool_list.iter().all(|&x| x);\n    println!(\"All elements are true: {}\", all_true);\n}\n```"
  },
  {
    "task": "Write a program to concatenate two lists.",
    "code": "```rust\nfn main() {\n    let list1 = vec![1, 2, 3];\n    let list2 = vec![4, 5, 6];\n    \n    let mut concatenated_list = list1.clone();\n    concatenated_list.extend(list2.iter());\n    \n    println!(\"{:?}\", concatenated_list);\n}\n```"
  },
  {
    "task": "Implement a function that returns the length of a list without using built-in functions.",
    "code": "```rust\nfn list_length<T>(list: &[T]) -> usize {\n    let mut length = 0;\n    for _ in list {\n        length += 1;\n    }\n    length\n}\n```"
  },
  {
    "task": "Create a list of words and find the longest word.",
    "code": "```rust\nfn main() {\n    let words = vec![\"apple\", \"banana\", \"cherry\", \"date\"];\n    let longest_word = words.iter().max_by_key(|word| word.len()).unwrap();\n    println!(\"The longest word is: {}\", longest_word);\n}\n```"
  },
  {
    "task": "Write a function that takes a list and a predicate function, returning a list of elements that satisfy the predicate.",
    "code": "```rust\nfn filter_list<T, F>(list: Vec<T>, predicate: F) -> Vec<T>\nwhere\n    F: Fn(&T) -> bool,\n{\n    list.into_iter().filter(predicate).collect()\n}\n\nfn main() {\n    let numbers = vec![1, 2, 3, 4, 5];\n    let even_numbers = filter_list(numbers, |&x| x % 2 == 0);\n    println!(\"{:?}\", even_numbers);\n}\n```"
  },
  {
    "task": "Generate a list of strings and filter out those with less than 5 characters.",
    "code": "```rust\nfn main() {\n    let strings = vec![\n        String::from(\"apple\"),\n        String::from(\"cat\"),\n        String::from(\"banana\"),\n        String::from(\"dog\"),\n        String::from(\"elephant\"),\n    ];\n\n    let filtered_strings: Vec<String> = strings\n        .into_iter()\n        .filter(|s| s.len() >= 5)\n        .collect();\n\n    println!(\"{:?}\", filtered_strings);\n}\n```"
  },
  {
    "task": "Create a list of mixed data types and separate them into lists by type.",
    "code": "```rust\nfn main() {\n    enum MixedType {\n        Integer(i32),\n        Float(f64),\n        Text(String),\n    }\n\n    let mixed_list = vec![\n        MixedType::Integer(42),\n        MixedType::Float(3.14),\n        MixedType::Text(String::from(\"Hello\")),\n        MixedType::Integer(7),\n        MixedType::Float(2.71),\n        MixedType::Text(String::from(\"World\")),\n    ];\n\n    let mut integers = Vec::new();\n    let mut floats = Vec::new();\n    let mut texts = Vec::new();\n\n    for item in mixed_list {\n        match item {\n            MixedType::Integer(val) => integers.push(val),\n            MixedType::Float(val) => floats.push(val),\n            MixedType::Text(val) => texts.push(val),\n        }\n    }\n\n    println!(\"Integers: {:?}\", integers);\n    println!(\"Floats: {:?}\", floats);\n    println!(\"Texts: {:?}\", texts);\n}\n```"
  },
  {
    "task": "Write a program to find the common elements between two lists.",
    "code": "```rust\nfn main() {\n    let list1 = vec![1, 2, 3, 4, 5];\n    let list2 = vec![3, 4, 5, 6, 7];\n\n    let common_elements: Vec<i32> = list1\n        .iter()\n        .filter(|&item| list2.contains(item))\n        .copied()\n        .collect();\n\n    println!(\"{:?}\", common_elements);\n}\n```"
  },
  {
    "task": "Implement a function to rotate the elements of a list to the left by a given number of steps.",
    "code": "```rust\nfn rotate_left<T: Clone>(list: &mut Vec<T>, steps: usize) {\n    let len = list.len();\n    if len == 0 { return; }\n    let steps = steps % len;\n    list.rotate_left(steps);\n}\n\nfn main() {\n    let mut list = vec![1, 2, 3, 4, 5];\n    rotate_left(&mut list, 2);\n    println!(\"{:?}\", list);\n}\n```"
  },
  {
    "task": "Create a list of numbers and find the product of all the elements.",
    "code": "```rust\nfn main() {\n    let numbers = vec![1, 2, 3, 4, 5];\n    let product: i32 = numbers.iter().product();\n    println!(\"The product of all elements is: {}\", product);\n}\n```"
  },
  {
    "task": "Write a function that removes all occurrences of a specified element from a list.",
    "code": "```rust\nfn remove_occurrences<T: PartialEq>(list: &mut Vec<T>, element: T) {\n    list.retain(|x| x != &element);\n}\n\nfn main() {\n    let mut numbers = vec![1, 2, 3, 4, 2, 5];\n    remove_occurrences(&mut numbers, 2);\n    println!(\"{:?}\", numbers); // Output: [1, 3, 4, 5]\n}\n```"
  },
  {
    "task": "Generate a list of random numbers and find the median value.",
    "code": "```rust\nuse rand::Rng;\n\nfn main() {\n    let mut rng = rand::thread_rng();\n    let mut numbers: Vec<i32> = (0..10).map(|_| rng.gen_range(1..101)).collect();\n    \n    numbers.sort();\n    \n    let median = if numbers.len() % 2 == 0 {\n        let mid = numbers.len() / 2;\n        (numbers[mid - 1] + numbers[mid]) as f64 / 2.0\n    } else {\n        numbers[numbers.len() / 2] as f64\n    };\n\n    println!(\"Numbers: {:?}\", numbers);\n    println!(\"Median: {}\", median);\n}\n```"
  },
  {
    "task": "Create a list of dictionaries and sort them by a specific key.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let mut list_of_dicts: Vec<HashMap<&str, i32>> = vec![\n        [(\"key\", 3)].iter().cloned().collect(),\n        [(\"key\", 1)].iter().cloned().collect(),\n        [(\"key\", 2)].iter().cloned().collect(),\n    ];\n\n    list_of_dicts.sort_by_key(|dict| dict.get(\"key\").cloned().unwrap_or_default());\n\n    println!(\"{:?}\", list_of_dicts);\n}\n```"
  },
  {
    "task": "Write a program to split a list into chunks of a specified size.",
    "code": "```rust\nfn split_into_chunks<T: Clone>(list: &[T], chunk_size: usize) -> Vec<Vec<T>> {\n    list.chunks(chunk_size).map(|chunk| chunk.to_vec()).collect()\n}\n\nfn main() {\n    let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let chunk_size = 3;\n    let chunks = split_into_chunks(&numbers, chunk_size);\n    for chunk in chunks {\n        println!(\"{:?}\", chunk);\n    }\n}\n```"
  },
  {
    "task": "Implement a function that takes a list and returns a dictionary with the frequency of each element.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn frequency<T: std::hash::Hash + Eq>(list: &[T]) -> HashMap<&T, usize> {\n    let mut freq_map = HashMap::new();\n    for item in list {\n        *freq_map.entry(item).or_insert(0) += 1;\n    }\n    freq_map\n}\n\nfn main() {\n    let list = vec![1, 2, 2, 3, 3, 3];\n    let freq = frequency(&list);\n    for (key, value) in &freq {\n        println!(\"{}: {}\", key, value);\n    }\n}\n```"
  },
  {
    "task": "Create a list of integers and replace all negative numbers with zero.",
    "code": "```rust\nfn main() {\n    let mut numbers = vec![3, -2, 5, -8, 4, -1, 0, 7];\n    for num in numbers.iter_mut() {\n        if *num < 0 {\n            *num = 0;\n        }\n    }\n    println!(\"{:?}\", numbers);\n}\n```"
  },
  {
    "task": "Write a function that returns the first n elements of a list.",
    "code": "```rust\nfn first_n_elements<T: Clone>(list: &[T], n: usize) -> Vec<T> {\n    list.iter().cloned().take(n).collect()\n}\n```"
  },
  {
    "task": "Generate a list of strings and join them into a single string with spaces.",
    "code": "```rust\nfn main() {\n    let words = vec![\"Hello\", \"world\", \"from\", \"Rust\"];\n    let sentence = words.join(\" \");\n    println!(\"{}\", sentence);\n}\n```"
  },
  {
    "task": "Create a list of lists and find the sum of each inner list.",
    "code": "```rust\nfn main() {\n    let lists = vec![\n        vec![1, 2, 3],\n        vec![4, 5, 6],\n        vec![7, 8, 9],\n    ];\n\n    let sums: Vec<i32> = lists.iter()\n        .map(|inner_list| inner_list.iter().sum())\n        .collect();\n\n    for sum in sums {\n        println!(\"{}\", sum);\n    }\n}\n```"
  },
  {
    "task": "Write a function that finds the second largest number in a list.",
    "code": "```rust\nfn second_largest(numbers: &[i32]) -> Option<i32> {\n    if numbers.len() < 2 {\n        return None;\n    }\n    let mut largest = i32::MIN;\n    let mut second_largest = i32::MIN;\n    for &num in numbers {\n        if num > largest {\n            second_largest = largest;\n            largest = num;\n        } else if num > second_largest && num < largest {\n            second_largest = num;\n        }\n    }\n    if second_largest == i32::MIN {\n        None\n    } else {\n        Some(second_largest)\n    }\n}\n\nfn main() {\n    let numbers = vec![3, 4, 5, 1, 2];\n    match second_largest(&numbers) {\n        Some(value) => println!(\"The second largest number is {}\", value),\n        None => println!(\"There is no second largest number\"),\n    }\n}\n```"
  },
  {
    "task": "Generate a list of numbers and remove the duplicates while maintaining order.",
    "code": "```rust\nfn main() {\n    let numbers = vec![1, 3, 5, 3, 7, 1, 9, 5];\n    let mut unique_numbers = Vec::new();\n    let mut seen = std::collections::HashSet::new();\n\n    for &num in &numbers {\n        if seen.insert(num) {\n            unique_numbers.push(num);\n        }\n    }\n\n    println!(\"{:?}\", unique_numbers);\n}\n```"
  },
  {
    "task": "Create a list of integers and partition it into two lists: one with numbers above the average and one below.",
    "code": "```rust\nfn main() {\n    let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\n    let sum: i32 = numbers.iter().sum();\n    let average = sum as f32 / numbers.len() as f32;\n\n    let (below_average, above_average): (Vec<i32>, Vec<i32>) = numbers.into_iter().partition(|&n| n < average as i32);\n\n    println!(\"Below average: {:?}\", below_average);\n    println!(\"Above average: {:?}\", above_average);\n}\n```"
  },
  {
    "task": "Write a program to find the longest increasing subsequence in a list of numbers.",
    "code": "```rust\nfn longest_increasing_subsequence(nums: Vec<i32>) -> Vec<i32> {\n    if nums.is_empty() {\n        return vec![];\n    }\n\n    let mut dp: Vec<i32> = vec![1; nums.len()];\n    let mut prev: Vec<i32> = vec![-1; nums.len()];\n    let mut max_len = 1;\n    let mut max_index = 0;\n\n    for i in 1..nums.len() {\n        for j in 0..i {\n            if nums[i] > nums[j] && dp[i] < dp[j] + 1 {\n                dp[i] = dp[j] + 1;\n                prev[i] = j as i32;\n            }\n        }\n        if dp[i] > max_len {\n            max_len = dp[i];\n            max_index = i;\n        }\n    }\n\n    let mut lis = Vec::new();\n    let mut current = max_index as i32;\n    while current != -1 {\n        lis.push(nums[current as usize]);\n        current = prev[current as usize];\n    }\n    lis.reverse();\n    lis\n}\n\nfn main() {\n    let numbers = vec![10, 9, 2, 5, 3, 7, 101, 18];\n    let lis = longest_increasing_subsequence(numbers);\n    println!(\"{:?}\", lis);\n}\n```"
  },
  {
    "task": "Implement a function to zip two lists into a single list of tuples.",
    "code": "```rust\nfn zip_lists<T: Clone, U: Clone>(list1: &[T], list2: &[U]) -> Vec<(T, U)> {\n    list1.iter().cloned().zip(list2.iter().cloned()).collect()\n}\n\nfn main() {\n    let list1 = vec![1, 2, 3];\n    let list2 = vec!['a', 'b', 'c'];\n    let zipped = zip_lists(&list1, &list2);\n    println!(\"{:?}\", zipped);\n}\n```"
  },
  {
    "task": "Create a list of characters and count the vowels.",
    "code": "```rust\nfn main() {\n    let chars = vec!['a', 'b', 'c', 'e', 'i', 'o', 'u', 'x', 'y', 'z'];\n    let vowels = ['a', 'e', 'i', 'o', 'u'];\n    \n    let vowel_count = chars.iter().filter(|&&c| vowels.contains(&c)).count();\n    \n    println!(\"Number of vowels: {}\", vowel_count);\n}\n```"
  },
  {
    "task": "Write a function that returns the last n elements of a list.",
    "code": "```rust\nfn last_n_elements<T: Clone>(list: &[T], n: usize) -> Vec<T> {\n    let len = list.len();\n    if n > len {\n        list.to_vec()\n    } else {\n        list[len - n..].to_vec()\n    }\n}\n\nfn main() {\n    let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let last_three = last_n_elements(&numbers, 3);\n    println!(\"{:?}\", last_three);\n}\n```"
  },
  {
    "task": "Generate a list of numbers and split it into two lists: one with positive numbers and one with negative numbers.",
    "code": "```rust\nfn main() {\n    let numbers = vec![3, -1, 4, -2, 5, -3, 6];\n    let (positive_numbers, negative_numbers): (Vec<i32>, Vec<i32>) = numbers.into_iter().partition(|&x| x > 0);\n\n    println!(\"Positive numbers: {:?}\", positive_numbers);\n    println!(\"Negative numbers: {:?}\", negative_numbers);\n}\n```"
  },
  {
    "task": "Create a list of random integers and find the mode.",
    "code": "```rust\nuse rand::Rng;\nuse std::collections::HashMap;\n\nfn main() {\n    let mut rng = rand::thread_rng();\n    let list: Vec<i32> = (0..100).map(|_| rng.gen_range(0..10)).collect();\n    \n    let mut occurrences = HashMap::new();\n    \n    for &num in &list {\n        *occurrences.entry(num).or_insert(0) += 1;\n    }\n\n    let mode = occurrences\n        .into_iter()\n        .max_by_key(|&(_, count)| count)\n        .map(|(num, _)| num);\n    \n    if let Some(mode_value) = mode {\n        println!(\"Mode: {}\", mode_value);\n    } else {\n        println!(\"No mode found.\");\n    }\n}\n```"
  },
  {
    "task": "Write a program to find the shortest path in a grid using a list to represent the path.",
    "code": "```rust\nuse std::collections::{VecDeque, HashSet};\n\nfn shortest_path(grid: Vec<Vec<i32>>, start: (usize, usize), end: (usize, usize)) -> Option<Vec<(usize, usize)>> {\n    let directions = [(0, 1), (1, 0), (0, -1), (-1, 0)];\n    let mut queue = VecDeque::new();\n    let mut visited = HashSet::new();\n\n    queue.push_back((start, vec![start]));\n    visited.insert(start);\n\n    while let Some((current_pos, path)) = queue.pop_front() {\n        if current_pos == end {\n            return Some(path);\n        }\n\n        for dir in &directions {\n            let new_pos = (\n                (current_pos.0 as isize + dir.0 as isize) as usize,\n                (current_pos.1 as isize + dir.1 as isize) as usize,\n            );\n\n            if new_pos.0 < grid.len() && new_pos.1 < grid[0].len() && grid[new_pos.0][new_pos.1] == 0 && !visited.contains(&new_pos) {\n                let mut new_path = path.clone();\n                new_path.push(new_pos);\n                queue.push_back((new_pos, new_path));\n                visited.insert(new_pos);\n            }\n        }\n    }\n\n    None\n}\n\nfn main() {\n    let grid = vec![\n        vec![0, 0, 0, 1],\n        vec![0, 1, 0, 0],\n        vec![0, 0, 0, 0],\n        vec![1, 1, 0, 0],\n    ];\n\n    let start = (0, 0);\n    let end = (2, 3);\n\n    match shortest_path(grid, start, end) {\n        Some(path) => {\n            println!(\"Shortest path found:\");\n            for step in path {\n                println!(\"{:?}\", step);\n            }\n        }\n        None => println!(\"No path found\"),\n    }\n}\n```"
  },
  {
    "task": "Implement a function that takes a list and returns a list with elements doubled.",
    "code": "```rust\nfn double_elements(input: Vec<i32>) -> Vec<i32> {\n    input.iter().map(|&x| x * 2).collect()\n}\n\nfn main() {\n    let numbers = vec![1, 2, 3, 4, 5];\n    let doubled = double_elements(numbers);\n    println!(\"{:?}\", doubled);\n}\n```"
  },
  {
    "task": "Create a list of integers and sort them in descending order.",
    "code": "```rust\nfn main() {\n    let mut numbers = vec![3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5];\n    numbers.sort_by(|a, b| b.cmp(a));\n    println!(\"{:?}\", numbers);\n}\n```"
  },
  {
    "task": "Write a function that takes a list of intervals and merges overlapping intervals.",
    "code": "```rust\nfn merge_intervals(mut intervals: Vec<(i32, i32)>) -> Vec<(i32, i32)> {\n    if intervals.is_empty() {\n        return intervals;\n    }\n\n    intervals.sort_by_key(|&(start, _)| start);\n    let mut merged = vec![intervals[0]];\n\n    for &(start, end) in &intervals[1..] {\n        let last = merged.last_mut().unwrap();\n        if start <= last.1 {\n            last.1 = last.1.max(end);\n        } else {\n            merged.push((start, end));\n        }\n    }\n\n    merged\n}\n```"
  },
  {
    "task": "Generate a list of random numbers and find the range (difference between max and min).",
    "code": "```rust\nuse rand::Rng;\n\nfn main() {\n    let mut rng = rand::thread_rng();\n    let list: Vec<i32> = (0..10).map(|_| rng.gen_range(0..100)).collect();\n    \n    if let (Some(&min), Some(&max)) = (list.iter().min(), list.iter().max()) {\n        let range = max - min;\n        println!(\"List: {:?}\", list);\n        println!(\"Range: {}\", range);\n    }\n}\n```"
  },
  {
    "task": "Create a list of strings and remove any that are palindromes.",
    "code": "```rust\nfn main() {\n    let words = vec![\"level\", \"world\", \"radar\", \"rust\", \"deified\", \"example\"];\n    let filtered_words: Vec<&str> = words\n        .into_iter()\n        .filter(|word| !is_palindrome(word))\n        .collect();\n    println!(\"{:?}\", filtered_words);\n}\n\nfn is_palindrome(s: &str) -> bool {\n    let reversed: String = s.chars().rev().collect();\n    s == reversed\n}\n```"
  },
  {
    "task": "Write a program to cyclically permute the elements of a list.",
    "code": "```rust\nfn cyclic_permute<T: Clone>(list: &mut Vec<T>) {\n    if !list.is_empty() {\n        let last = list.pop().unwrap();\n        list.insert(0, last);\n    }\n}\n\nfn main() {\n    let mut list = vec![1, 2, 3, 4, 5];\n    cyclic_permute(&mut list);\n    println!(\"{:?}\", list);\n}\n```"
  },
  {
    "task": "Implement a function to create a list of cumulative sums from a list of numbers.",
    "code": "```rust\nfn cumulative_sums(numbers: &[i32]) -> Vec<i32> {\n    let mut sums = Vec::new();\n    let mut current_sum = 0;\n    for &num in numbers {\n        current_sum += num;\n        sums.push(current_sum);\n    }\n    sums\n}\n\nfn main() {\n    let numbers = vec![1, 2, 3, 4, 5];\n    let result = cumulative_sums(&numbers);\n    println!(\"{:?}\", result);\n}\n```"
  },
  {
    "task": "Create a list of numbers and shift all zeros to the end.",
    "code": "```rust\nfn shift_zeros_to_end(mut nums: Vec<i32>) -> Vec<i32> {\n    let mut non_zero_index = 0;\n    for i in 0..nums.len() {\n        if nums[i] != 0 {\n            nums[non_zero_index] = nums[i];\n            non_zero_index += 1;\n        }\n    }\n    for i in non_zero_index..nums.len() {\n        nums[i] = 0;\n    }\n    nums\n}\n\nfn main() {\n    let numbers = vec![0, 1, 0, 3, 12];\n    let result = shift_zeros_to_end(numbers);\n    println!(\"{:?}\", result);\n}\n```"
  },
  {
    "task": "Write a program to simulate a queue using a list.",
    "code": "```rust\nfn main() {\n    let mut queue: Vec<i32> = Vec::new();\n\n    // Enqueue elements\n    queue.push(1);\n    queue.push(2);\n    queue.push(3);\n\n    // Dequeue elements\n    if let Some(front) = queue.first() {\n        println!(\"Front of the queue: {}\", front);\n    }\n    queue.remove(0);\n\n    if let Some(front) = queue.first() {\n        println!(\"Front of the queue: {}\", front);\n    }\n    queue.remove(0);\n\n    if let Some(front) = queue.first() {\n        println!(\"Front of the queue: {}\", front);\n    }\n    queue.remove(0);\n}\n```"
  },
  {
    "task": "Generate a list of numbers and identify all prime numbers.",
    "code": "```rust\nfn is_prime(n: u32) -> bool {\n    if n <= 1 {\n        return false;\n    }\n    for i in 2..=((n as f64).sqrt() as u32) {\n        if n % i == 0 {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let numbers: Vec<u32> = (2..=100).collect();\n    let primes: Vec<u32> = numbers.into_iter().filter(|&x| is_prime(x)).collect();\n    println!(\"{:?}\", primes);\n}\n```"
  },
  {
    "task": "Create a list of strings and group them by their starting letter.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn group_strings_by_starting_letter(strings: Vec<&str>) -> HashMap<char, Vec<&str>> {\n    let mut grouped: HashMap<char, Vec<&str>> = HashMap::new();\n\n    for s in strings {\n        if let Some(first_char) = s.chars().next() {\n            grouped.entry(first_char).or_insert(Vec::new()).push(s);\n        }\n    }\n\n    grouped\n}\n\nfn main() {\n    let strings = vec![\"apple\", \"apricot\", \"banana\", \"blueberry\", \"cherry\", \"cranberry\"];\n    let grouped = group_strings_by_starting_letter(strings);\n\n    for (key, group) in grouped {\n        println!(\"{}: {:?}\", key, group);\n    }\n}\n```"
  },
  {
    "task": "Write a function that takes a list and returns a new list with all elements squared.",
    "code": "```rust\nfn square_elements(input: &[i32]) -> Vec<i32> {\n    input.iter().map(|&x| x * x).collect()\n}\n\nfn main() {\n    let numbers = vec![1, 2, 3, 4, 5];\n    let squared_numbers = square_elements(&numbers);\n    println!(\"{:?}\", squared_numbers);\n}\n```"
  },
  {
    "task": "Generate a list of timestamps and find the time difference between consecutive elements.",
    "code": "```rust\nuse chrono::{Duration, Utc};\n\nfn main() {\n    let timestamps: Vec<_> = (0..5)\n        .map(|i| Utc::now() + Duration::seconds(i * 60))\n        .collect();\n\n    let differences: Vec<_> = timestamps.windows(2)\n        .map(|pair| pair[1].signed_duration_since(pair[0]))\n        .collect();\n\n    for diff in differences {\n        println!(\"Difference: {} seconds\", diff.num_seconds());\n    }\n}\n```"
  },
  {
    "task": "Create a list of numbers and rotate it such that the smallest number is first.",
    "code": "```rust\nfn main() {\n    let mut numbers = vec![3, 8, 1, 7, 5];\n    if let Some(min_index) = numbers.iter().enumerate().min_by_key(|&(_, &val)| val).map(|(idx, _)| idx) {\n        numbers.rotate_left(min_index);\n    }\n    println!(\"{:?}\", numbers);\n}\n```"
  },
  {
    "task": "Write a program to find all unique pairs in a list that sum up to a specific target.",
    "code": "```rust\nuse std::collections::HashSet;\n\nfn find_pairs_with_sum(nums: Vec<i32>, target: i32) -> Vec<(i32, i32)> {\n    let mut seen = HashSet::new();\n    let mut output = HashSet::new();\n\n    for &num in &nums {\n        let complement = target - num;\n        if seen.contains(&complement) {\n            let pair = if num < complement {\n                (num, complement)\n            } else {\n                (complement, num)\n            };\n            output.insert(pair);\n        }\n        seen.insert(num);\n    }\n\n    output.into_iter().collect()\n}\n\nfn main() {\n    let nums = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    let target = 10;\n    let pairs = find_pairs_with_sum(nums, target);\n    for pair in pairs {\n        println!(\"{:?}\", pair);\n    }\n}\n```"
  },
  {
    "task": "Implement a function that returns true if a list contains a cycle.",
    "code": "```rust\nuse std::collections::HashSet;\n\nfn contains_cycle<T>(list: &[T]) -> bool {\n    let mut seen = HashSet::new();\n    for item in list {\n        if !seen.insert(item as *const T) {\n            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let list_with_cycle = vec![1, 2, 3, 4, 5];\n    println!(\"Contains cycle: {}\", contains_cycle(&list_with_cycle));\n}\n```"
  },
  {
    "task": "Create a list of numbers and find the contiguous subarray with the maximum sum.",
    "code": "```rust\nfn max_subarray_sum(nums: &[i32]) -> i32 {\n    let mut max_sum = nums[0];\n    let mut current_sum = nums[0];\n\n    for &num in nums.iter().skip(1) {\n        current_sum = current_sum.max(num);\n        current_sum = current_sum + num;\n        max_sum = max_sum.max(current_sum);\n    }\n\n    max_sum\n}\n\nfn main() {\n    let numbers = vec![1, -3, 2, 1, -1, 3, 4, -2];\n    let max_sum = max_subarray_sum(&numbers);\n    println!(\"Maximum subarray sum is: {}\", max_sum);\n}\n```"
  },
  {
    "task": "Write a function that takes a list and a number, and finds two numbers in the list that sum to the given number.",
    "code": "```rust\nfn find_two_sum(nums: &[i32], target: i32) -> Option<(i32, i32)> {\n    for (i, &num1) in nums.iter().enumerate() {\n        for &num2 in &nums[i + 1..] {\n            if num1 + num2 == target {\n                return Some((num1, num2));\n            }\n        }\n    }\n    None\n}\n\nfn main() {\n    let numbers = vec![2, 7, 11, 15];\n    let target = 9;\n    if let Some((num1, num2)) = find_two_sum(&numbers, target) {\n        println!(\"Found numbers: {} and {}\", num1, num2);\n    } else {\n        println!(\"No pair found.\");\n    }\n}\n```"
  },
  {
    "task": "Generate a list of even numbers and filter out those that are greater than a specific value.",
    "code": "```rust\nfn main() {\n    let specific_value = 10;\n    let even_numbers: Vec<i32> = (0..20).filter(|x| x % 2 == 0).collect();\n    let filtered_numbers: Vec<i32> = even_numbers.into_iter().filter(|&x| x <= specific_value).collect();\n    println!(\"{:?}\", filtered_numbers);\n}\n```"
  },
  {
    "task": "Create a list of characters and reverse the vowels only.",
    "code": "```rust\nfn reverse_vowels(s: &mut Vec<char>) {\n    let vowels = \"aeiouAEIOU\".chars().collect::<Vec<char>>();\n    let mut i = 0;\n    let mut j = s.len() - 1;\n\n    while i < j {\n        while i < j && !vowels.contains(&s[i]) {\n            i += 1;\n        }\n        while i < j && !vowels.contains(&s[j]) {\n            j -= 1;\n        }\n        if i < j {\n            s.swap(i, j);\n            i += 1;\n            j -= 1;\n        }\n    }\n}\n\nfn main() {\n    let mut chars = vec!['h', 'e', 'l', 'l', 'o'];\n    reverse_vowels(&mut chars);\n    println!(\"{:?}\", chars);\n}\n```"
  },
  {
    "task": "Write a program to find all permutations of a list of elements.",
    "code": "```rust\nfn permutations<T: Clone>(elements: Vec<T>) -> Vec<Vec<T>> {\n    fn permute<T: Clone>(list: &mut Vec<T>, start: usize, result: &mut Vec<Vec<T>>) {\n        if start == list.len() {\n            result.push(list.clone());\n        } else {\n            for i in start..list.len() {\n                list.swap(start, i);\n                permute(list, start + 1, result);\n                list.swap(start, i);\n            }\n        }\n    }\n\n    let mut result = Vec::new();\n    let mut elements = elements.clone();\n    permute(&mut elements, 0, &mut result);\n    result\n}\n\nfn main() {\n    let elements = vec![1, 2, 3];\n    let perms = permutations(elements);\n    for perm in perms {\n        println!(\"{:?}\", perm);\n    }\n}\n```"
  },
  {
    "task": "Implement a function that takes a list and returns the most frequently occurring element.",
    "code": "```rust\nuse std::collections::HashMap;\n\nfn most_frequent<T: std::hash::Hash + Eq + Clone>(list: &[T]) -> Option<T> {\n    let mut frequency_map = HashMap::new();\n    for item in list {\n        *frequency_map.entry(item).or_insert(0) += 1;\n    }\n    frequency_map.into_iter().max_by_key(|&(_, count)| count).map(|(item, _)| item.clone())\n}\n\nfn main() {\n    let list = vec![1, 2, 2, 3, 3, 3, 4, 4, 4, 4];\n    match most_frequent(&list) {\n        Some(value) => println!(\"Most frequent: {}\", value),\n        None => println!(\"List is empty\"),\n    }\n}\n```"
  },
  {
    "task": "Create a list of numbers and calculate the variance.",
    "code": "```rust\nfn calculate_variance(numbers: &Vec<f64>) -> f64 {\n    let mean: f64 = numbers.iter().sum::<f64>() / numbers.len() as f64;\n    let variance: f64 = numbers.iter().map(|&num| (num - mean).powi(2)).sum::<f64>() / numbers.len() as f64;\n    variance\n}\n\nfn main() {\n    let numbers = vec![1.0, 2.0, 3.0, 4.0, 5.0];\n    let variance = calculate_variance(&numbers);\n    println!(\"Variance: {}\", variance);\n}\n```"
  },
  {
    "task": "Write a function to concatenate a list of lists into a single list.",
    "code": "```rust\nfn concatenate_lists<T: Clone>(lists: Vec<Vec<T>>) -> Vec<T> {\n    lists.into_iter().flat_map(|list| list.into_iter()).collect()\n}\n\nfn main() {\n    let list_of_lists = vec![vec![1, 2], vec![3, 4], vec![5, 6]];\n    let concatenated_list = concatenate_lists(list_of_lists);\n    println!(\"{:?}\", concatenated_list);\n}\n```"
  },
  {
    "task": "Generate a list of numbers and replace each element with the product of all other elements.",
    "code": "```rust\nfn replace_with_product_of_others(nums: Vec<i32>) -> Vec<i32> {\n    let total_product: i32 = nums.iter().product();\n    nums.into_iter().map(|num| total_product / num).collect()\n}\n\nfn main() {\n    let nums = vec![1, 2, 3, 4];\n    let result = replace_with_product_of_others(nums);\n    println!(\"{:?}\", result);\n}\n```"
  },
  {
    "task": "Create a list of strings and find the common prefix.",
    "code": "```rust\nfn common_prefix(strings: &[String]) -> String {\n    if strings.is_empty() {\n        return \"\".to_string();\n    }\n\n    let mut prefix = strings[0].clone();\n\n    for s in strings.iter().skip(1) {\n        while !s.starts_with(&prefix) {\n            if prefix.is_empty() {\n                return \"\".to_string();\n            }\n            prefix.pop();\n        }\n    }\n\n    prefix\n}\n\nfn main() {\n    let strings = vec![\n        String::from(\"flower\"),\n        String::from(\"flow\"),\n        String::from(\"flight\"),\n    ];\n    let prefix = common_prefix(&strings);\n    println!(\"Common prefix: {}\", prefix);\n}\n```"
  },
  {
    "task": "Write a program to partition a list into two lists based on a predicate function.",
    "code": "```rust\nfn partition<T, F>(list: &[T], predicate: F) -> (Vec<T>, Vec<T>)\nwhere\n    F: Fn(&T) -> bool,\n    T: Clone,\n{\n    let mut true_list = Vec::new();\n    let mut false_list = Vec::new();\n    \n    for item in list {\n        if predicate(item) {\n            true_list.push(item.clone());\n        } else {\n            false_list.push(item.clone());\n        }\n    }\n    \n    (true_list, false_list)\n}\n\nfn main() {\n    let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let (evens, odds) = partition(&numbers, |&x| x % 2 == 0);\n    \n    println!(\"Evens: {:?}\", evens);\n    println!(\"Odds: {:?}\", odds);\n}\n```"
  },
  {
    "task": "Implement a function to find the kth smallest element in a list.",
    "code": "```rust\nfn kth_smallest_element(lst: &mut Vec<i32>, k: usize) -> Option<i32> {\n    if k == 0 || k > lst.len() {\n        return None;\n    }\n    lst.sort();\n    Some(lst[k - 1])\n}\n\nfn main() {\n    let mut numbers = vec![3, 1, 2, 5, 4];\n    let k = 3;\n    if let Some(value) = kth_smallest_element(&mut numbers, k) {\n        println!(\"The {}th smallest element is {}\", k, value);\n    } else {\n        println!(\"Invalid k\");\n    }\n}\n```"
  },
  {
    "task": "Create a list of integers and find the length of the longest contiguous sequence.",
    "code": "```rust\nfn longest_contiguous_sequence(nums: &[i32]) -> usize {\n    if nums.is_empty() {\n        return 0;\n    }\n\n    let mut max_len = 1;\n    let mut current_len = 1;\n\n    for i in 1..nums.len() {\n        if nums[i] == nums[i - 1] + 1 {\n            current_len += 1;\n        } else {\n            if current_len > max_len {\n                max_len = current_len;\n            }\n            current_len = 1;\n        }\n    }\n\n    if current_len > max_len {\n        max_len = current_len;\n    }\n\n    max_len\n}\n\nfn main() {\n    let nums = vec![1, 2, 3, 5, 6, 7, 8, 10, 11];\n    let length = longest_contiguous_sequence(&nums);\n    println!(\"Length of longest contiguous sequence: {}\", length);\n}\n```"
  },
  {
    "task": "Write a function that rotates elements in a list while maintaining the relative order of non-rotated elements.",
    "code": "```rust\nfn rotate_list<T: Clone>(list: &mut Vec<T>, k: usize) {\n    let len = list.len();\n    if len == 0 || k % len == 0 {\n        return;\n    }\n    let k = k % len;\n    list.reverse();\n    list[..k].reverse();\n    list[k..].reverse();\n}\n\nfn main() {\n    let mut list = vec![1, 2, 3, 4, 5];\n    rotate_list(&mut list, 2);\n    println!(\"{:?}\", list); // Output should be: [4, 5, 1, 2, 3]\n}\n```"
  },
  {
    "task": "Generate a list of random numbers and sort them while maintaining the original index positions.",
    "code": "```rust\nuse rand::Rng;\n\nfn main() {\n    let mut rng = rand::thread_rng();\n    let mut numbers: Vec<(usize, i32)> = (0..10)\n        .map(|i| (i, rng.gen_range(0..100)))\n        .collect();\n\n    numbers.sort_by_key(|&(_, num)| num);\n\n    let sorted_numbers: Vec<i32> = numbers.iter().map(|&(_, num)| num).collect();\n    let original_indices: Vec<usize> = numbers.iter().map(|&(index, _)| index).collect();\n\n    println!(\"Sorted numbers: {:?}\", sorted_numbers);\n    println!(\"Original indices: {:?}\", original_indices);\n}\n```"
  },
  {
    "task": "Create a list of numbers and find all subsets that sum up to a specific target.",
    "code": "```rust\nfn find_subsets(nums: Vec<i32>, target: i32) -> Vec<Vec<i32>> {\n    fn backtrack(start: usize, nums: &Vec<i32>, target: i32, current: &mut Vec<i32>, result: &mut Vec<Vec<i32>>) {\n        if target == 0 {\n            result.push(current.clone());\n            return;\n        }\n        for i in start..nums.len() {\n            if nums[i] <= target {\n                current.push(nums[i]);\n                backtrack(i + 1, nums, target - nums[i], current, result);\n                current.pop();\n            }\n        }\n    }\n    \n    let mut result = Vec::new();\n    let mut current = Vec::new();\n    backtrack(0, &nums, target, &mut current, &mut result);\n    result\n}\n\nfn main() {\n    let nums = vec![1, 2, 3, 4, 5];\n    let target = 5;\n    let subsets = find_subsets(nums, target);\n    for subset in subsets {\n        println!(\"{:?}\", subset);\n    }\n}\n```"
  },
  {
    "task": "Write a program to simulate a stack using a list.",
    "code": "```rust\nfn main() {\n    let mut stack: Vec<i32> = Vec::new();\n\n    // Push elements onto the stack\n    stack.push(1);\n    stack.push(2);\n    stack.push(3);\n\n    // Pop elements from the stack\n    if let Some(top) = stack.pop() {\n        println!(\"Popped: {}\", top);\n    }\n\n    if let Some(top) = stack.pop() {\n        println!(\"Popped: {}\", top);\n    }\n\n    if let Some(top) = stack.pop() {\n        println!(\"Popped: {}\", top);\n    }\n}\n```"
  }
]