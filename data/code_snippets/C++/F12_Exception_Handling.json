[
  {
    "task": "Write a function that reads a file and handles the exception if the file is not found.",
    "code": "```cpp\n#include <iostream>\n#include <fstream>\n#include <string>\n\nvoid readFile(const std::string& filename) {\n    std::ifstream file;\n    try {\n        file.open(filename);\n        if (!file.is_open()) {\n            throw std::ios_base::failure(\"File not found\");\n        }\n        std::string line;\n        while (std::getline(file, line)) {\n            std::cout << line << std::endl;\n        }\n        file.close();\n    } catch (const std::ios_base::failure& e) {\n        std::cerr << \"Exception: \" << e.what() << std::endl;\n    }\n}\n\nint main() {\n    readFile(\"example.txt\");\n    return 0;\n}\n```"
  },
  {
    "task": "Create a program that divides two numbers and catches any division by zero errors.",
    "code": "```cpp\n#include <iostream>\n#include <exception>\n\nint main() {\n    double numerator, denominator, result;\n    \n    std::cout << \"Enter numerator: \";\n    std::cin >> numerator;\n    std::cout << \"Enter denominator: \";\n    std::cin >> denominator;\n\n    try {\n        if (denominator == 0) {\n            throw std::runtime_error(\"Division by zero error\");\n        }\n        result = numerator / denominator;\n        std::cout << \"Result: \" << result << std::endl;\n    } catch (const std::runtime_error& e) {\n        std::cerr << \"Exception caught: \" << e.what() << std::endl;\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Design a function to parse an integer from a string and manage invalid input exceptions.",
    "code": "```cpp\n#include <iostream>\n#include <string>\n#include <stdexcept>\n\nint parseInteger(const std::string& str) {\n    try {\n        size_t pos;\n        int number = std::stoi(str, &pos);\n        if (pos != str.length()) {\n            throw std::invalid_argument(\"Invalid input: contains non-digit characters\");\n        }\n        return number;\n    } catch (const std::invalid_argument& e) {\n        std::cerr << \"Invalid input: \" << e.what() << std::endl;\n        throw;\n    } catch (const std::out_of_range& e) {\n        std::cerr << \"Number out of range: \" << e.what() << std::endl;\n        throw;\n    }\n}\n\nint main() {\n    try {\n        std::string input = \"123a\";\n        int value = parseInteger(input);\n        std::cout << \"Parsed value: \" << value << std::endl;\n    } catch (...) {\n        std::cerr << \"An error occurred while parsing the integer.\" << std::endl;\n    }\n    return 0;\n}\n```"
  },
  {
    "task": "Implement an API call and catch exceptions related to network errors or timeouts.",
    "code": "```cpp\n#include <iostream>\n#include <stdexcept>\n#include <string>\n\n// Simulated API call function\nvoid apiCall() {\n    // Simulate a network error or timeout\n    throw std::runtime_error(\"Network error: Unable to connect to the server.\");\n}\n\nint main() {\n    try {\n        apiCall();\n    } catch (const std::runtime_error& e) {\n        std::cerr << \"Exception caught: \" << e.what() << std::endl;\n    } catch (...) {\n        std::cerr << \"An unknown exception occurred.\" << std::endl;\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a program that opens a database connection and handles any connection failure exceptions.",
    "code": "```cpp\n#include <iostream>\n#include <stdexcept>\n\n// Mock class to simulate database connection\nclass DatabaseConnection {\npublic:\n    void open() {\n        // Simulate a failure\n        throw std::runtime_error(\"Failed to connect to the database.\");\n    }\n};\n\nint main() {\n    DatabaseConnection db;\n    try {\n        db.open();\n        std::cout << \"Database connection successful.\" << std::endl;\n    } catch (const std::exception &e) {\n        std::cerr << \"Exception: \" << e.what() << std::endl;\n        std::cerr << \"Database connection failed.\" << std::endl;\n    }\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that accesses an array by index and catches out-of-bounds exceptions.",
    "code": "```cpp\n#include <iostream>\n#include <stdexcept>\n\nvoid accessArrayElement(int* array, int size, int index) {\n    try {\n        if (index < 0 || index >= size) {\n            throw std::out_of_range(\"Index out of bounds\");\n        }\n        std::cout << \"Element at index \" << index << \" is: \" << array[index] << std::endl;\n    } catch (const std::out_of_range& e) {\n        std::cerr << \"Exception caught: \" << e.what() << std::endl;\n    }\n}\n\nint main() {\n    int myArray[] = {10, 20, 30, 40, 50};\n    int size = sizeof(myArray) / sizeof(myArray[0]);\n\n    accessArrayElement(myArray, size, 2);  // Valid index\n    accessArrayElement(myArray, size, 5);  // Out-of-bounds index\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a function that converts a string to a date object and manages format exceptions.",
    "code": "```cpp\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <stdexcept>\n#include <ctime>\n\nstd::tm stringToDate(const std::string& dateStr) {\n    std::tm tm = {};\n    std::istringstream ss(dateStr);\n    ss >> std::get_time(&tm, \"%Y-%m-%d\");\n\n    if (ss.fail()) {\n        throw std::invalid_argument(\"Invalid date format\");\n    }\n\n    return tm;\n}\n\nint main() {\n    try {\n        std::string dateStr = \"2023-10-15\";\n        std::tm date = stringToDate(dateStr);\n        std::cout << \"Date converted successfully: \" << std::asctime(&date);\n    } catch (const std::invalid_argument& e) {\n        std::cerr << e.what() << std::endl;\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Design a program that writes data to a file and catches any file permission exceptions.",
    "code": "```cpp\n#include <iostream>\n#include <fstream>\n#include <exception>\n\nint main() {\n    std::ofstream file;\n    try {\n        file.open(\"output.txt\");\n        if (!file.is_open()) {\n            throw std::runtime_error(\"Unable to open file for writing.\");\n        }\n        file << \"Writing some data to the file.\" << std::endl;\n        file.close();\n    } catch (const std::exception &e) {\n        std::cerr << \"An error occurred: \" << e.what() << std::endl;\n    }\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a module that retrieves data from a URL and handles malformed URL exceptions.",
    "code": "```cpp\n#include <iostream>\n#include <stdexcept>\n#include <regex>\n\nclass MalformedURLException : public std::runtime_error {\npublic:\n    MalformedURLException(const std::string& message)\n        : std::runtime_error(message) {}\n};\n\nbool isValidURL(const std::string& url) {\n    const std::regex url_regex(\n        R\"((http|https)://([\\w.-]+)(:\\d+)?(/[\\w./-]*)?)\",\n        std::regex::extended\n    );\n    return std::regex_match(url, url_regex);\n}\n\nstd::string retrieveDataFromURL(const std::string& url) {\n    if (!isValidURL(url)) {\n        throw MalformedURLException(\"Malformed URL: \" + url);\n    }\n    // Simulated data retrieval\n    return \"Data retrieved from \" + url;\n}\n\nint main() {\n    try {\n        std::string url = \"http://example.com/data\";\n        std::string data = retrieveDataFromURL(url);\n        std::cout << data << std::endl;\n    } catch (const MalformedURLException& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function to calculate the square root of a number and catch any negative input exceptions.",
    "code": "```cpp\n#include <iostream>\n#include <stdexcept>\n#include <cmath>\n\ndouble calculateSquareRoot(double number) {\n    if (number < 0) {\n        throw std::invalid_argument(\"Negative input exception\");\n    }\n    return std::sqrt(number);\n}\n\nint main() {\n    double number;\n    std::cout << \"Enter a number to calculate its square root: \";\n    std::cin >> number;\n\n    try {\n        double result = calculateSquareRoot(number);\n        std::cout << \"The square root of \" << number << \" is \" << result << std::endl;\n    } catch (const std::invalid_argument& e) {\n        std::cout << e.what() << std::endl;\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a program that sends an email and manages exceptions for invalid email addresses.",
    "code": "```cpp\n#include <iostream>\n#include <regex>\n#include <stdexcept>\n\nclass EmailException : public std::runtime_error {\npublic:\n    explicit EmailException(const std::string& message)\n        : std::runtime_error(message) {}\n};\n\nbool isValidEmail(const std::string& email) {\n    const std::regex pattern(R\"((\\w+)(\\.{1}\\w+)*@(\\w+)(\\.\\w{2,})+)\");\n    return std::regex_match(email, pattern);\n}\n\nvoid sendEmail(const std::string& email) {\n    if (!isValidEmail(email)) {\n        throw EmailException(\"Invalid email address: \" + email);\n    }\n    std::cout << \"Email sent to \" << email << std::endl;\n}\n\nint main() {\n    try {\n        std::string email = \"invalid-email@\";\n        sendEmail(email);\n    } catch (const EmailException& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a calculator application that handles invalid operations gracefully.",
    "code": "```cpp\n#include <iostream>\n#include <stdexcept>\n\ndouble calculate(double a, double b, char op) {\n    switch (op) {\n        case '+': return a + b;\n        case '-': return a - b;\n        case '*': return a * b;\n        case '/':\n            if (b == 0) throw std::invalid_argument(\"Division by zero\");\n            return a / b;\n        default:\n            throw std::invalid_argument(\"Invalid operation\");\n    }\n}\n\nint main() {\n    double num1, num2;\n    char operation;\n    std::cout << \"Enter first number: \";\n    std::cin >> num1;\n    std::cout << \"Enter operation (+, -, *, /): \";\n    std::cin >> operation;\n    std::cout << \"Enter second number: \";\n    std::cin >> num2;\n\n    try {\n        double result = calculate(num1, num2, operation);\n        std::cout << \"Result: \" << result << std::endl;\n    } catch (const std::invalid_argument& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Design a function that tries to parse JSON data and catches parsing errors.",
    "code": "```cpp\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <nlohmann/json.hpp> // You need to include the nlohmann json library\n\nvoid parseJson(const std::string& jsonData) {\n    try {\n        auto jsonObject = nlohmann::json::parse(jsonData);\n        std::cout << \"Parsed JSON successfully: \" << jsonObject.dump() << std::endl;\n    } catch (const nlohmann::json::parse_error& e) {\n        std::cerr << \"JSON parsing error: \" << e.what() << std::endl;\n    }\n}\n\nint main() {\n    std::string jsonString = R\"({\"name\": \"John\", \"age\": 30})\";\n    parseJson(jsonString);\n\n    std::string invalidJsonString = R\"({\"name\": \"John\", \"age\": )\";\n    parseJson(invalidJsonString);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a system that processes user input and handles any type conversion exceptions.",
    "code": "```cpp\n#include <iostream>\n#include <string>\n#include <exception>\n\nint main() {\n    std::string input;\n    std::cout << \"Enter a number: \";\n    std::cin >> input;\n\n    try {\n        int number = std::stoi(input);\n        std::cout << \"You entered the number: \" << number << std::endl;\n    } catch (const std::invalid_argument& e) {\n        std::cerr << \"Invalid input: not a valid number.\" << std::endl;\n    } catch (const std::out_of_range& e) {\n        std::cerr << \"Invalid input: number out of range.\" << std::endl;\n    } catch (const std::exception& e) {\n        std::cerr << \"An error occurred: \" << e.what() << std::endl;\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that fetches data from a database and manages exceptions for missing records.",
    "code": "```cpp\n#include <iostream>\n#include <stdexcept>\n#include <string>\n\nclass Database {\npublic:\n    std::string fetchData(int id) {\n        // Simulating database behavior: throw an exception if id is not found\n        if (id > 10) {\n            throw std::runtime_error(\"Record not found\");\n        }\n        return \"Record data for id: \" + std::to_string(id);\n    }\n};\n\nvoid fetchDataFromDatabase(int id) {\n    Database db;\n    try {\n        std::string data = db.fetchData(id);\n        std::cout << \"Fetched data: \" << data << std::endl;\n    } catch (const std::runtime_error& e) {\n        std::cerr << \"Exception caught: \" << e.what() << std::endl;\n    }\n}\n\nint main() {\n    fetchDataFromDatabase(5);\n    fetchDataFromDatabase(15);\n    return 0;\n}\n```"
  },
  {
    "task": "Create a program that connects to a remote server and handles authentication failure exceptions.",
    "code": "```cpp\n#include <iostream>\n#include <stdexcept>\n\nclass ServerConnection {\npublic:\n    void connect(const std::string& server) {\n        if (server != \"valid_server\") {\n            throw std::runtime_error(\"Failed to connect: Invalid server address\");\n        }\n    }\n\n    void authenticate(const std::string& username, const std::string& password) {\n        if (username != \"admin\" || password != \"password\") {\n            throw std::runtime_error(\"Authentication failed: Invalid credentials\");\n        }\n    }\n};\n\nint main() {\n    ServerConnection conn;\n    try {\n        conn.connect(\"valid_server\");\n        conn.authenticate(\"admin\", \"wrongpassword\");\n        std::cout << \"Connected and authenticated successfully\" << std::endl;\n    } catch (const std::runtime_error& e) {\n        std::cerr << e.what() << std::endl;\n    }\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a function to download a file from the internet and handle file not found exceptions.",
    "code": "```cpp\n#include <iostream>\n#include <stdexcept>\n\nvoid downloadFile(const std::string& url) {\n    try {\n        // Simulate checking if the file exists at the given URL\n        bool fileExists = false; // Simulated result of file existence check\n\n        if (!fileExists) {\n            throw std::runtime_error(\"File not found at the specified URL\");\n        }\n\n        // Simulate file download\n        std::cout << \"Downloading file from \" << url << std::endl;\n\n    } catch (const std::runtime_error& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n}\n\nint main() {\n    std::string url = \"http://example.com/file\";\n    downloadFile(url);\n    return 0;\n}\n```"
  },
  {
    "task": "Design a program that attempts to connect to an API and handles rate limit exceptions.",
    "code": "```cpp\n#include <iostream>\n#include <stdexcept>\n\nclass RateLimitException : public std::runtime_error {\npublic:\n    RateLimitException(const std::string& message) : std::runtime_error(message) {}\n};\n\nclass APIConnector {\npublic:\n    void connect() {\n        // Simulating API connection logic with a rate limit exception\n        throw RateLimitException(\"Rate limit exceeded. Please try again later.\");\n    }\n};\n\nint main() {\n    APIConnector api;\n    try {\n        api.connect();\n    } catch (const RateLimitException& e) {\n        std::cerr << \"Exception caught: \" << e.what() << std::endl;\n    } catch (const std::exception& e) {\n        std::cerr << \"An unexpected exception occurred: \" << e.what() << std::endl;\n    }\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that reads from a configuration file and manages key not found exceptions.",
    "code": "```cpp\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <map>\n#include <stdexcept>\n\nstd::map<std::string, std::string> readConfigFile(const std::string& filename) {\n    std::map<std::string, std::string> config;\n    std::ifstream file(filename);\n    if (!file.is_open()) {\n        throw std::runtime_error(\"Unable to open configuration file\");\n    }\n    \n    std::string line;\n    while (std::getline(file, line)) {\n        std::size_t pos = line.find('=');\n        if (pos == std::string::npos) {\n            continue;\n        }\n        std::string key = line.substr(0, pos);\n        std::string value = line.substr(pos + 1);\n        config[key] = value;\n    }\n    \n    file.close();\n    return config;\n}\n\nstd::string getConfigValue(const std::map<std::string, std::string>& config, const std::string& key) {\n    try {\n        return config.at(key);\n    } catch (const std::out_of_range&) {\n        throw std::runtime_error(\"Key not found in configuration: \" + key);\n    }\n}\n\nint main() {\n    try {\n        auto config = readConfigFile(\"config.txt\");\n        std::string value = getConfigValue(config, \"someKey\");\n        std::cout << \"Value: \" << value << std::endl;\n    } catch (const std::runtime_error& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Create an application that processes a list of tasks and catches any task execution exceptions.",
    "code": "```cpp\n#include <iostream>\n#include <vector>\n#include <stdexcept>\n\nclass Task {\npublic:\n    void execute() {\n        if (rand() % 2 == 0) {\n            throw std::runtime_error(\"Task execution failed.\");\n        }\n        std::cout << \"Task executed successfully.\" << std::endl;\n    }\n};\n\nint main() {\n    std::vector<Task> tasks(5);\n    for (size_t i = 0; i < tasks.size(); ++i) {\n        try {\n            tasks[i].execute();\n        } catch (const std::exception& e) {\n            std::cerr << \"Exception caught: \" << e.what() << std::endl;\n        }\n    }\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a program that performs batch processing and handles individual item processing exceptions.",
    "code": "```cpp\n#include <iostream>\n#include <vector>\n#include <stdexcept>\n\nvoid processItem(int item) {\n    if (item < 0) {\n        throw std::runtime_error(\"Negative item processing error\");\n    }\n    std::cout << \"Processing item: \" << item << std::endl;\n}\n\nvoid batchProcess(const std::vector<int>& items) {\n    for (const int& item : items) {\n        try {\n            processItem(item);\n        } catch (const std::exception& e) {\n            std::cerr << \"Error processing item \" << item << \": \" << e.what() << std::endl;\n        }\n    }\n}\n\nint main() {\n    std::vector<int> items = {10, -5, 20, 0, -1, 15};\n    batchProcess(items);\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a function that performs mathematical operations and catches arithmetic exceptions.",
    "code": "```cpp\n#include <iostream>\n#include <stdexcept>\n\ndouble performOperation(double a, double b, char op) {\n    try {\n        switch (op) {\n            case '+':\n                return a + b;\n            case '-':\n                return a - b;\n            case '*':\n                return a * b;\n            case '/':\n                if (b == 0) throw std::runtime_error(\"Division by zero\");\n                return a / b;\n            default:\n                throw std::invalid_argument(\"Invalid operation\");\n        }\n    } catch (const std::exception &e) {\n        std::cerr << \"Exception: \" << e.what() << std::endl;\n        return 0;\n    }\n}\n\nint main() {\n    double result = performOperation(10, 0, '/');\n    std::cout << \"Result: \" << result << std::endl;\n    return 0;\n}\n```"
  },
  {
    "task": "Write a program that logs error messages when exceptions occur during data processing.",
    "code": "```cpp\n#include <iostream>\n#include <stdexcept>\n#include <fstream>\n\nvoid processData(int data) {\n    if (data < 0) {\n        throw std::invalid_argument(\"Negative data is not allowed.\");\n    }\n    if (data == 0) {\n        throw std::runtime_error(\"Data cannot be zero.\");\n    }\n    // Simulate data processing\n    std::cout << \"Processing data: \" << data << std::endl;\n}\n\nvoid logError(const std::string& message) {\n    std::ofstream logFile(\"error_log.txt\", std::ios::app);\n    if (logFile.is_open()) {\n        logFile << message << std::endl;\n        logFile.close();\n    }\n}\n\nint main() {\n    int dataSamples[] = {10, -5, 0, 15};\n    \n    for (int data : dataSamples) {\n        try {\n            processData(data);\n        } catch (const std::exception& e) {\n            std::cerr << \"Error: \" << e.what() << std::endl;\n            logError(e.what());\n        }\n    }\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Create a script that monitors system resources and handles exceptions when limits are exceeded.",
    "code": "```cpp\n#include <iostream>\n#include <stdexcept>\n\nclass ResourceMonitor {\npublic:\n    void checkResources() {\n        // Simulating resource usage values\n        int cpuUsage = 85;   // Example CPU usage percentage\n        int memoryUsage = 95; // Example Memory usage percentage\n\n        try {\n            if (cpuUsage > 80) {\n                throw std::runtime_error(\"CPU usage limit exceeded!\");\n            }\n            if (memoryUsage > 90) {\n                throw std::runtime_error(\"Memory usage limit exceeded!\");\n            }\n        } catch (const std::runtime_error& e) {\n            std::cerr << \"Exception: \" << e.what() << std::endl;\n        }\n    }\n};\n\nint main() {\n    ResourceMonitor monitor;\n    monitor.checkResources();\n    return 0;\n}\n```"
  },
  {
    "task": "Design a function that validates user input and manages any format exceptions.",
    "code": "```cpp\n#include <iostream>\n#include <string>\n#include <stdexcept>\n\nbool validateInput(const std::string& input) {\n    try {\n        // Attempt to convert the input to an integer\n        int value = std::stoi(input);\n        return true; // If conversion is successful, input is valid\n    } catch (const std::invalid_argument& e) {\n        std::cerr << \"Invalid format: input is not a number.\" << std::endl;\n    } catch (const std::out_of_range& e) {\n        std::cerr << \"Invalid format: number out of range.\" << std::endl;\n    }\n    return false; // If any exception occurs, input is invalid\n}\n\nint main() {\n    std::string userInput;\n    std::cout << \"Enter a number: \";\n    std::cin >> userInput;\n\n    if (validateInput(userInput)) {\n        std::cout << \"Valid input!\" << std::endl;\n    } else {\n        std::cout << \"Invalid input.\" << std::endl;\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a service that interacts with third-party APIs and handles unexpected response exceptions.",
    "code": "```cpp\n#include <iostream>\n#include <stdexcept>\n#include <string>\n\nclass ThirdPartyAPI {\npublic:\n    std::string requestData() {\n        // Simulate an API call which might throw an exception\n        throw std::runtime_error(\"Unexpected response from API\");\n    }\n};\n\nclass APIService {\npublic:\n    void fetchData() {\n        ThirdPartyAPI api;\n        try {\n            std::string data = api.requestData();\n            std::cout << \"Data received: \" << data << std::endl;\n        } catch (const std::runtime_error& e) {\n            std::cerr << \"API error: \" << e.what() << std::endl;\n        } catch (const std::exception& e) {\n            std::cerr << \"General error: \" << e.what() << std::endl;\n        }\n    }\n};\n\nint main() {\n    APIService service;\n    service.fetchData();\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that uploads files to a server and handles exceptions for unsupported file types.",
    "code": "```cpp\n#include <iostream>\n#include <stdexcept>\n#include <string>\n#include <set>\n\nclass UnsupportedFileTypeException : public std::runtime_error {\npublic:\n    explicit UnsupportedFileTypeException(const std::string& message)\n        : std::runtime_error(message) {}\n};\n\nvoid uploadFileToServer(const std::string& fileName) {\n    std::set<std::string> supportedFileTypes = {\".txt\", \".jpg\", \".png\"};\n    std::string fileExtension = fileName.substr(fileName.find_last_of('.'));\n\n    if (supportedFileTypes.find(fileExtension) == supportedFileTypes.end()) {\n        throw UnsupportedFileTypeException(\"Unsupported file type: \" + fileExtension);\n    }\n\n    // Simulate file upload process\n    std::cout << \"Uploading \" << fileName << \" to server...\" << std::endl;\n    // Assume successful upload\n    std::cout << \"Upload successful.\" << std::endl;\n}\n\nint main() {\n    try {\n        uploadFileToServer(\"example.doc\");\n    } catch (const UnsupportedFileTypeException& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n\n    try {\n        uploadFileToServer(\"image.png\");\n    } catch (const UnsupportedFileTypeException& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a program that simulates network traffic and manages packet loss exceptions.",
    "code": "```cpp\n#include <iostream>\n#include <stdexcept>\n#include <cstdlib>\n#include <ctime>\n\nclass PacketLossException : public std::exception {\npublic:\n    const char* what() const noexcept override {\n        return \"Packet loss occurred!\";\n    }\n};\n\nvoid simulateNetworkTraffic(int packetCount) {\n    srand(static_cast<unsigned>(time(0)));\n    for (int i = 0; i < packetCount; ++i) {\n        try {\n            if (rand() % 10 < 2) { // 20% chance of packet loss\n                throw PacketLossException();\n            }\n            std::cout << \"Packet \" << i + 1 << \" sent successfully.\" << std::endl;\n        } catch (const PacketLossException& e) {\n            std::cout << \"Error: \" << e.what() << \" Packet \" << i + 1 << std::endl;\n        }\n    }\n}\n\nint main() {\n    int packetCount = 10; // Simulate 10 packets\n    simulateNetworkTraffic(packetCount);\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a function that processes XML data and catches any structural exceptions.",
    "code": "```cpp\n#include <iostream>\n#include <stdexcept>\n#include <string>\n\nclass XMLParseException : public std::runtime_error {\npublic:\n    explicit XMLParseException(const std::string& message)\n        : std::runtime_error(message) {}\n};\n\nvoid processXMLData(const std::string& data) {\n    try {\n        if (data.empty()) {\n            throw XMLParseException(\"XML data is empty\");\n        }\n        \n        // Simulate processing XML data\n        if (data.find(\"<\") == std::string::npos || data.find(\">\") == std::string::npos) {\n            throw XMLParseException(\"Malformed XML data\");\n        }\n\n        std::cout << \"XML data processed successfully.\" << std::endl;\n    } catch (const XMLParseException& e) {\n        std::cerr << \"Error processing XML: \" << e.what() << std::endl;\n    }\n}\n\nint main() {\n    std::string xmlData = \"<tag>Data</tag>\";\n    processXMLData(xmlData);\n\n    std::string malformedData = \"No tags\";\n    processXMLData(malformedData);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Design a program that handles exceptions when accessing environment variables.",
    "code": "```cpp\n#include <iostream>\n#include <cstdlib>\n#include <stdexcept>\n\nstd::string getEnvVar(const std::string& key) {\n    const char* val = std::getenv(key.c_str());\n    if (val == nullptr) {\n        throw std::runtime_error(\"Environment variable not found: \" + key);\n    }\n    return std::string(val);\n}\n\nint main() {\n    try {\n        std::string path = getEnvVar(\"PATH\");\n        std::cout << \"PATH: \" << path << std::endl;\n    } catch (const std::runtime_error& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that calculates factorial and manages exceptions for negative input values.",
    "code": "```cpp\n#include <iostream>\n#include <stdexcept>\n\nint factorial(int n) {\n    if (n < 0) {\n        throw std::invalid_argument(\"Negative input is not allowed\");\n    }\n\n    int result = 1;\n    for (int i = 1; i <= n; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\nint main() {\n    try {\n        int num = -5;\n        std::cout << \"Factorial of \" << num << \" is \" << factorial(num) << std::endl;\n    } catch (const std::invalid_argument& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n    return 0;\n}\n```"
  },
  {
    "task": "Create a software tool that converts file formats and handles unsupported format exceptions.",
    "code": "```cpp\n#include <iostream>\n#include <string>\n#include <stdexcept>\n\nclass UnsupportedFormatException : public std::runtime_error {\npublic:\n    UnsupportedFormatException(const std::string& message)\n        : std::runtime_error(message) {}\n};\n\nclass FileConverter {\npublic:\n    void convert(const std::string& filename, const std::string& fromFormat, const std::string& toFormat) {\n        if (!isSupportedFormat(fromFormat) || !isSupportedFormat(toFormat)) {\n            throw UnsupportedFormatException(\"Unsupported file format: \" + fromFormat + \" or \" + toFormat);\n        }\n        // Conversion logic (omitted for simplicity)\n        std::cout << \"Successfully converted \" << filename \n                  << \" from \" << fromFormat << \" to \" << toFormat << std::endl;\n    }\n\nprivate:\n    bool isSupportedFormat(const std::string& format) {\n        // Let's assume only \"txt\" and \"csv\" are supported formats\n        return format == \"txt\" || format == \"csv\";\n    }\n};\n\nint main() {\n    FileConverter converter;\n    try {\n        converter.convert(\"example.txt\", \"txt\", \"csv\");\n        converter.convert(\"example.doc\", \"doc\", \"pdf\");\n    } catch (const UnsupportedFormatException& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a function that sends HTTP requests and catches exceptions for invalid response status codes.",
    "code": "```cpp\n#include <iostream>\n#include <stdexcept>\n#include <string>\n\nclass HttpException : public std::runtime_error {\npublic:\n    HttpException(const std::string& message) : std::runtime_error(message) {}\n};\n\nvoid sendHttpRequest(const std::string& url) {\n    // Simulating HTTP request and response\n    int responseStatusCode = 404;  // Example: Invalid status code for demonstration\n\n    if (responseStatusCode != 200) {\n        throw HttpException(\"Invalid response status code: \" + std::to_string(responseStatusCode));\n    }\n\n    std::cout << \"Request to \" << url << \" was successful.\" << std::endl;\n}\n\nint main() {\n    try {\n        sendHttpRequest(\"http://example.com\");\n    } catch (const HttpException& e) {\n        std::cerr << \"HTTP error occurred: \" << e.what() << std::endl;\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a program that interacts with a message queue and handles message delivery exceptions.",
    "code": "```cpp\n#include <iostream>\n#include <queue>\n#include <stdexcept>\n\nclass MessageQueue {\npublic:\n    void sendMessage(const std::string &message) {\n        if (message.empty()) {\n            throw std::runtime_error(\"Cannot send an empty message\");\n        }\n        queue.push(message);\n        std::cout << \"Message sent: \" << message << std::endl;\n    }\n\n    std::string receiveMessage() {\n        if (queue.empty()) {\n            throw std::runtime_error(\"No messages to receive\");\n        }\n        std::string message = queue.front();\n        queue.pop();\n        return message;\n    }\n\nprivate:\n    std::queue<std::string> queue;\n};\n\nint main() {\n    MessageQueue mq;\n\n    try {\n        mq.sendMessage(\"Hello, World!\");\n        std::cout << \"Received message: \" << mq.receiveMessage() << std::endl;\n    } catch (const std::exception &e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n\n    try {\n        mq.sendMessage(\"\");\n    } catch (const std::exception &e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n\n    try {\n        mq.receiveMessage();\n    } catch (const std::exception &e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that reads user input and catches exceptions for unexpected data types.",
    "code": "```cpp\n#include <iostream>\n#include <stdexcept>\n#include <string>\n\nvoid readInput() {\n    try {\n        int number;\n        std::cout << \"Enter a number: \";\n        std::cin >> number;\n\n        if (std::cin.fail()) {\n            throw std::invalid_argument(\"Invalid input type. Expected an integer.\");\n        }\n\n        std::cout << \"You entered: \" << number << std::endl;\n    } catch (const std::invalid_argument& e) {\n        std::cout << \"Exception: \" << e.what() << std::endl;\n        std::cin.clear(); // clear the error flags\n        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n'); // discard invalid input\n    }\n}\n\nint main() {\n    readInput();\n    return 0;\n}\n```"
  },
  {
    "task": "Create a system that processes transactions and manages exceptions for insufficient funds.",
    "code": "```cpp\n#include <iostream>\n#include <stdexcept>\n#include <string>\n\nclass InsufficientFundsException : public std::runtime_error {\npublic:\n    InsufficientFundsException(const std::string &message)\n        : std::runtime_error(message) {}\n};\n\nclass Account {\nprivate:\n    double balance;\n\npublic:\n    Account(double initialBalance) : balance(initialBalance) {}\n\n    void processTransaction(double amount) {\n        if (amount > balance) {\n            throw InsufficientFundsException(\"Insufficient funds for transaction.\");\n        }\n        balance -= amount;\n    }\n\n    double getBalance() const {\n        return balance;\n    }\n};\n\nint main() {\n    Account account(100.0);\n\n    try {\n        account.processTransaction(150.0);\n    } catch (const InsufficientFundsException &e) {\n        std::cerr << \"Transaction failed: \" << e.what() << std::endl;\n    }\n\n    std::cout << \"Current balance: $\" << account.getBalance() << std::endl;\n    return 0;\n}\n```"
  },
  {
    "task": "Design a function that generates random numbers and handles exceptions when the range is invalid.",
    "code": "```cpp\n#include <iostream>\n#include <cstdlib>\n#include <ctime>\n#include <stdexcept>\n\nint generateRandomNumber(int min, int max) {\n    if (min > max) {\n        throw std::invalid_argument(\"Invalid range: min should not be greater than max.\");\n    }\n    return min + std::rand() % (max - min + 1);\n}\n\nint main() {\n    std::srand(std::time(nullptr)); // Seed the random number generator\n    int min = 10;\n    int max = 5;\n\n    try {\n        int randomNumber = generateRandomNumber(min, max);\n        std::cout << \"Generated random number: \" << randomNumber << std::endl;\n    } catch (const std::invalid_argument& e) {\n        std::cerr << \"Exception caught: \" << e.what() << std::endl;\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a program that performs image processing and catches exceptions for unsupported file dimensions.",
    "code": "```cpp\n#include <iostream>\n#include <stdexcept>\n\nclass ImageProcessor {\npublic:\n    void processImage(int width, int height) {\n        if (width <= 0 || height <= 0 || width > 10000 || height > 10000) {\n            throw std::invalid_argument(\"Unsupported file dimensions\");\n        }\n        // Image processing logic here\n        std::cout << \"Processing image with dimensions: \" \n                  << width << \"x\" << height << std::endl;\n    }\n};\n\nint main() {\n    ImageProcessor processor;\n    try {\n        processor.processImage(12000, 8000);\n    } catch (const std::invalid_argument& e) {\n        std::cerr << \"Exception caught: \" << e.what() << std::endl;\n    }\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that manipulates strings and manages exceptions for invalid operations.",
    "code": "```cpp\n#include <iostream>\n#include <string>\n#include <stdexcept>\n\nvoid manipulateString(const std::string& input) {\n    try {\n        if (input.empty()) {\n            throw std::invalid_argument(\"String cannot be empty.\");\n        }\n        \n        std::string reversed(input.rbegin(), input.rend());\n        std::cout << \"Reversed string: \" << reversed << std::endl;\n        \n        // Example operation that may cause an out_of_range exception\n        char charAtPosition = input.at(100);\n        std::cout << \"Character at position 100: \" << charAtPosition << std::endl;\n        \n    } catch (const std::invalid_argument& e) {\n        std::cerr << \"Invalid argument exception: \" << e.what() << std::endl;\n    } catch (const std::out_of_range& e) {\n        std::cerr << \"Out of range exception: \" << e.what() << std::endl;\n    } catch (...) {\n        std::cerr << \"An unknown exception occurred.\" << std::endl;\n    }\n}\n\nint main() {\n    std::string testString = \"Hello, World!\";\n    manipulateString(testString);\n    manipulateString(\"\");\n    return 0;\n}\n```"
  },
  {
    "task": "Create a script that automates tasks and handles exceptions for missing dependencies.",
    "code": "```cpp\n#include <iostream>\n#include <stdexcept>\n\nvoid checkDependency(bool isAvailable, const std::string& dependencyName) {\n    if (!isAvailable) {\n        throw std::runtime_error(\"Missing dependency: \" + dependencyName);\n    }\n}\n\nint main() {\n    try {\n        // Example dependencies\n        bool isLibraryAAvailable = false; // Simulating missing dependency\n        bool isLibraryBAvailable = true;\n\n        checkDependency(isLibraryAAvailable, \"LibraryA\");\n        checkDependency(isLibraryBAvailable, \"LibraryB\");\n\n        std::cout << \"All dependencies are available. Automating tasks...\" << std::endl;\n        // Automate tasks here\n\n    } catch (const std::exception& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n        return 1;\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a function that accesses nested data structures and manages key access exceptions.",
    "code": "```cpp\n#include <iostream>\n#include <map>\n#include <string>\n#include <stdexcept>\n\nint accessNestedData(const std::map<std::string, std::map<std::string, int>>& data, const std::string& key1, const std::string& key2) {\n    try {\n        auto it1 = data.find(key1);\n        if (it1 == data.end()) {\n            throw std::out_of_range(\"Key1 not found\");\n        }\n        auto it2 = it1->second.find(key2);\n        if (it2 == it1->second.end()) {\n            throw std::out_of_range(\"Key2 not found\");\n        }\n        return it2->second;\n    } catch (const std::out_of_range& e) {\n        std::cerr << \"Exception: \" << e.what() << std::endl;\n        throw;  // Re-throw the exception for further handling if needed\n    }\n}\n\nint main() {\n    std::map<std::string, std::map<std::string, int>> data = {\n        {\"outer1\", {{\"inner1\", 10}, {\"inner2\", 20}}},\n        {\"outer2\", {{\"inner3\", 30}, {\"inner4\", 40}}}\n    };\n\n    try {\n        int value = accessNestedData(data, \"outer1\", \"inner1\");\n        std::cout << \"Value: \" << value << std::endl;\n        value = accessNestedData(data, \"outer1\", \"inner3\");  // This will throw an exception\n    } catch (const std::out_of_range&) {\n        std::cerr << \"Handled exception in main.\" << std::endl;\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Design a program that synchronizes data between sources and handles data mismatch exceptions.",
    "code": "```cpp\n#include <iostream>\n#include <stdexcept>\n#include <string>\n\n// Custom exception for data mismatch\nclass DataMismatchException : public std::runtime_error {\npublic:\n    explicit DataMismatchException(const std::string& message)\n        : std::runtime_error(message) {}\n};\n\n// Function to simulate data synchronization\nvoid synchronizeData(const std::string& sourceData, const std::string& targetData) {\n    if (sourceData != targetData) {\n        throw DataMismatchException(\"Data mismatch between source and target.\");\n    }\n    std::cout << \"Data synchronized successfully.\" << std::endl;\n}\n\nint main() {\n    std::string sourceData = \"DataFromSource\";\n    std::string targetData = \"DataFromTarget\";\n\n    try {\n        synchronizeData(sourceData, targetData);\n    } catch (const DataMismatchException& e) {\n        std::cerr << \"Exception caught: \" << e.what() << std::endl;\n        // Handle data mismatch exception, e.g., log the error, retry, etc.\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that interacts with hardware devices and handles connection failure exceptions.",
    "code": "```cpp\n#include <iostream>\n#include <stdexcept>\n\nclass HardwareConnectionException : public std::runtime_error {\npublic:\n    explicit HardwareConnectionException(const std::string& message)\n        : std::runtime_error(message) {}\n};\n\nvoid connectToHardware() {\n    // Simulate a failure in hardware connection\n    bool connectionSuccess = false;\n\n    if (!connectionSuccess) {\n        throw HardwareConnectionException(\"Failed to connect to hardware device.\");\n    }\n\n    std::cout << \"Connected to hardware successfully.\" << std::endl;\n}\n\nvoid interactWithHardware() {\n    try {\n        connectToHardware();\n        // Interaction with hardware would occur here\n    } catch (const HardwareConnectionException& e) {\n        std::cerr << \"Exception: \" << e.what() << std::endl;\n        // Handle connection failure (e.g., retry, log, etc.)\n    }\n}\n\nint main() {\n    interactWithHardware();\n    return 0;\n}\n```"
  },
  {
    "task": "Create a tool that compresses files and manages exceptions for unsupported compression formats.",
    "code": "```cpp\n#include <iostream>\n#include <stdexcept>\n#include <string>\n\nclass UnsupportedFormatException : public std::runtime_error {\npublic:\n    UnsupportedFormatException(const std::string& message)\n        : std::runtime_error(message) {}\n};\n\nvoid compressFile(const std::string& fileName, const std::string& format) {\n    if (format != \"zip\" && format != \"gzip\") {\n        throw UnsupportedFormatException(\"Unsupported compression format: \" + format);\n    }\n    std::cout << \"Compressing \" << fileName << \" as \" << format << \"...\\n\";\n    // Compression logic would go here\n}\n\nint main() {\n    std::string fileName = \"example.txt\";\n    std::string format = \"rar\";\n\n    try {\n        compressFile(fileName, format);\n    } catch (const UnsupportedFormatException& e) {\n        std::cerr << \"Error: \" << e.what() << '\\n';\n    } catch (const std::exception& e) {\n        std::cerr << \"An unexpected error occurred: \" << e.what() << '\\n';\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a function that parses command-line arguments and handles missing argument exceptions.",
    "code": "```cpp\n#include <iostream>\n#include <stdexcept>\n#include <string>\n\nvoid parseArguments(int argc, char* argv[]) {\n    try {\n        if (argc < 2) {\n            throw std::runtime_error(\"Missing command-line arguments.\");\n        }\n        for (int i = 1; i < argc; ++i) {\n            std::cout << \"Argument \" << i << \": \" << argv[i] << std::endl;\n        }\n    } catch (const std::runtime_error& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n}\n\nint main(int argc, char* argv[]) {\n    parseArguments(argc, argv);\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a program that simulates user interactions and manages timing exceptions.",
    "code": "```cpp\n#include <iostream>\n#include <stdexcept>\n#include <chrono>\n#include <thread>\n\nclass TimingException : public std::runtime_error {\npublic:\n    TimingException(const std::string& message) : std::runtime_error(message) {}\n};\n\nvoid simulateInteraction(int duration) {\n    if (duration > 5) {\n        throw TimingException(\"Interaction time exceeded the limit of 5 seconds.\");\n    }\n    std::cout << \"Simulating user interaction for \" << duration << \" seconds.\" << std::endl;\n    std::this_thread::sleep_for(std::chrono::seconds(duration));\n    std::cout << \"User interaction completed successfully.\" << std::endl;\n}\n\nint main() {\n    try {\n        simulateInteraction(3);\n        simulateInteraction(7);\n    } catch (const TimingException& ex) {\n        std::cerr << \"Caught timing exception: \" << ex.what() << std::endl;\n    } catch (const std::exception& ex) {\n        std::cerr << \"An unexpected error occurred: \" << ex.what() << std::endl;\n    }\n\n    std::cout << \"Program ended.\" << std::endl;\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that encrypts data and handles exceptions for unsupported encryption algorithms.",
    "code": "```cpp\n#include <iostream>\n#include <stdexcept>\n#include <string>\n\nstd::string encryptData(const std::string& data, const std::string& algorithm) {\n    if (algorithm != \"AES\" && algorithm != \"RSA\") {\n        throw std::invalid_argument(\"Unsupported encryption algorithm: \" + algorithm);\n    }\n    // Dummy encryption logic for demonstration\n    std::string encryptedData = \"encrypted_\" + data;\n    return encryptedData;\n}\n\nint main() {\n    try {\n        std::string data = \"SensitiveData\";\n        std::string algorithm = \"UnsupportedAlgorithm\";\n        std::string encryptedData = encryptData(data, algorithm);\n        std::cout << \"Encrypted Data: \" << encryptedData << std::endl;\n    } catch (const std::invalid_argument& e) {\n        std::cerr << \"Exception: \" << e.what() << std::endl;\n    }\n    return 0;\n}\n```"
  },
  {
    "task": "Create a system that aggregates data and manages exceptions for data inconsistency.",
    "code": "```cpp\n#include <iostream>\n#include <vector>\n#include <stdexcept>\n\nclass DataAggregator {\npublic:\n    void addData(int data) {\n        if (data < 0) {\n            throw std::invalid_argument(\"Data cannot be negative\");\n        }\n        aggregatedData.push_back(data);\n    }\n\n    int getTotal() const {\n        if (aggregatedData.empty()) {\n            throw std::runtime_error(\"No data to aggregate\");\n        }\n        int total = 0;\n        for (int data : aggregatedData) {\n            total += data;\n        }\n        return total;\n    }\n\nprivate:\n    std::vector<int> aggregatedData;\n};\n\nint main() {\n    DataAggregator aggregator;\n\n    try {\n        aggregator.addData(10);\n        aggregator.addData(20);\n        aggregator.addData(-5); // This will throw an exception\n    } catch (const std::invalid_argument& e) {\n        std::cerr << \"Invalid data error: \" << e.what() << '\\n';\n    }\n\n    try {\n        std::cout << \"Total: \" << aggregator.getTotal() << '\\n';\n    } catch (const std::runtime_error& e) {\n        std::cerr << \"Runtime error: \" << e.what() << '\\n';\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Design a program that processes real-time data streams and handles connection drop exceptions.",
    "code": "```cpp\n#include <iostream>\n#include <stdexcept>\n#include <thread>\n#include <chrono>\n\nclass ConnectionDropException : public std::runtime_error {\npublic:\n    ConnectionDropException() : std::runtime_error(\"Connection dropped\") {}\n};\n\nclass DataStreamProcessor {\npublic:\n    void processDataStream() {\n        try {\n            while (true) {\n                if (checkConnection()) {\n                    std::cout << \"Processing data...\" << std::endl;\n                } else {\n                    throw ConnectionDropException();\n                }\n                std::this_thread::sleep_for(std::chrono::seconds(1));\n            }\n        } catch (const ConnectionDropException& ex) {\n            std::cerr << \"Error: \" << ex.what() << std::endl;\n            handleReconnection();\n        }\n    }\n\nprivate:\n    bool checkConnection() {\n        // Simulate random connection drop\n        return rand() % 10 != 0;\n    }\n\n    void handleReconnection() {\n        std::cout << \"Attempting to reconnect...\" << std::endl;\n        std::this_thread::sleep_for(std::chrono::seconds(2));\n        std::cout << \"Reconnected successfully.\" << std::endl;\n        processDataStream();\n    }\n};\n\nint main() {\n    srand(time(0));\n    DataStreamProcessor processor;\n    processor.processDataStream();\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a function that performs scientific calculations and manages precision exceptions.",
    "code": "```cpp\n#include <iostream>\n#include <stdexcept>\n#include <cmath>\n\nclass PrecisionException : public std::runtime_error {\npublic:\n    explicit PrecisionException(const std::string& message)\n        : std::runtime_error(message) {}\n};\n\ndouble performScientificCalculation(double value) {\n    try {\n        if (value < 0) {\n            throw PrecisionException(\"Negative value leads to precision issue.\");\n        }\n        double result = std::sqrt(value);\n        if (std::isinf(result) || std::isnan(result)) {\n            throw PrecisionException(\"Result is not a finite number.\");\n        }\n        return result;\n    } catch (const PrecisionException& e) {\n        std::cerr << \"PrecisionException: \" << e.what() << std::endl;\n        throw; // rethrow exception for further handling if needed\n    }\n}\n\nint main() {\n    try {\n        double result = performScientificCalculation(-1.0);\n        std::cout << \"Result: \" << result << std::endl;\n    } catch (const PrecisionException&) {\n        std::cerr << \"Calculation failed due to precision issues.\" << std::endl;\n    }\n    return 0;\n}\n```"
  },
  {
    "task": "Write a script that generates reports and handles exceptions for missing data sources.",
    "code": "```cpp\n#include <iostream>\n#include <stdexcept>\n#include <string>\n\nclass ReportGenerator {\npublic:\n    void generateReport(const std::string& dataSource) {\n        if (dataSource.empty()) {\n            throw std::runtime_error(\"Missing data source\");\n        }\n        // Simulate report generation\n        std::cout << \"Report generated using data source: \" << dataSource << std::endl;\n    }\n};\n\nint main() {\n    ReportGenerator reportGenerator;\n    std::string dataSource = \"\"; // Simulate missing data source\n\n    try {\n        reportGenerator.generateReport(dataSource);\n    } catch (const std::runtime_error& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a program that validates digital certificates and manages trust exceptions.",
    "code": "```cpp\n#include <iostream>\n#include <stdexcept>\n#include <string>\n#include <unordered_set>\n\nclass Certificate {\npublic:\n    explicit Certificate(std::string name) : name(std::move(name)) {}\n    const std::string& getName() const { return name; }\n\nprivate:\n    std::string name;\n};\n\nclass CertificateException : public std::runtime_error {\npublic:\n    explicit CertificateException(const std::string& message)\n        : std::runtime_error(message) {}\n};\n\nclass CertificateManager {\npublic:\n    void addTrustedCertificate(const Certificate& cert) {\n        trustedCertificates.insert(cert.getName());\n    }\n\n    void validateCertificate(const Certificate& cert) {\n        if (trustedCertificates.find(cert.getName()) == trustedCertificates.end()) {\n            throw CertificateException(\"Untrusted Certificate: \" + cert.getName());\n        }\n    }\n\n    void manageTrustException(const Certificate& cert) {\n        try {\n            validateCertificate(cert);\n            std::cout << \"Certificate \" << cert.getName() << \" is trusted.\\n\";\n        } catch (const CertificateException& e) {\n            std::cerr << \"Exception: \" << e.what() << '\\n';\n            // Handle exception, for example, ask user if they want to trust this certificate\n            std::cout << \"Would you like to trust this certificate? (yes/no): \";\n            std::string response;\n            std::cin >> response;\n            if (response == \"yes\") {\n                addTrustedCertificate(cert);\n                std::cout << \"Certificate \" << cert.getName() << \" has been added to trusted list.\\n\";\n            } else {\n                std::cout << \"Certificate \" << cert.getName() << \" remains untrusted.\\n\";\n            }\n        }\n    }\n\nprivate:\n    std::unordered_set<std::string> trustedCertificates;\n};\n\nint main() {\n    CertificateManager manager;\n    Certificate cert1(\"CertA\");\n    Certificate cert2(\"CertB\");\n\n    manager.addTrustedCertificate(cert1);\n\n    manager.manageTrustException(cert1); // Should pass without exception\n    manager.manageTrustException(cert2); // Should handle exception\n\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a function that schedules tasks and handles exceptions for scheduling conflicts.",
    "code": "```cpp\n#include <iostream>\n#include <vector>\n#include <exception>\n\nclass SchedulingConflictException : public std::exception {\npublic:\n    const char* what() const noexcept override {\n        return \"Scheduling conflict encountered.\";\n    }\n};\n\nclass TaskScheduler {\npublic:\n    void scheduleTask(int startTime, int endTime) {\n        for (const auto& task : tasks) {\n            if ((startTime < task.second && startTime >= task.first) ||\n                (endTime > task.first && endTime <= task.second) ||\n                (startTime <= task.first && endTime >= task.second)) {\n                throw SchedulingConflictException();\n            }\n        }\n        tasks.emplace_back(startTime, endTime);\n        std::cout << \"Task scheduled from \" << startTime << \" to \" << endTime << \".\\n\";\n    }\n\nprivate:\n    std::vector<std::pair<int, int>> tasks;\n};\n\nint main() {\n    TaskScheduler scheduler;\n    \n    try {\n        scheduler.scheduleTask(9, 10);\n        scheduler.scheduleTask(10, 11);\n        scheduler.scheduleTask(9, 10);  // This will throw an exception\n    } catch (const SchedulingConflictException& e) {\n        std::cerr << e.what() << std::endl;\n    }\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Design a system that manages user sessions and handles session timeout exceptions.",
    "code": "```cpp\n#include <iostream>\n#include <stdexcept>\n#include <chrono>\n#include <thread>\n#include <unordered_map>\n\nclass SessionTimeoutException : public std::runtime_error {\npublic:\n    SessionTimeoutException(const std::string& message) : std::runtime_error(message) {}\n};\n\nclass UserSession {\n    std::chrono::time_point<std::chrono::steady_clock> start_time;\n    int timeout_duration; // in seconds\n\npublic:\n    UserSession(int timeout) : timeout_duration(timeout) {\n        start_time = std::chrono::steady_clock::now();\n    }\n\n    void checkTimeout() {\n        auto now = std::chrono::steady_clock::now();\n        auto elapsed = std::chrono::duration_cast<std::chrono::seconds>(now - start_time).count();\n        if (elapsed > timeout_duration) {\n            throw SessionTimeoutException(\"Session has timed out.\");\n        }\n    }\n\n    void reset() {\n        start_time = std::chrono::steady_clock::now();\n    }\n};\n\nclass SessionManager {\n    std::unordered_map<std::string, UserSession> sessions;\n    int default_timeout;\n\npublic:\n    SessionManager(int timeout) : default_timeout(timeout) {}\n\n    void createSession(const std::string& user_id) {\n        sessions[user_id] = UserSession(default_timeout);\n    }\n\n    void accessSession(const std::string& user_id) {\n        try {\n            if (sessions.find(user_id) != sessions.end()) {\n                sessions[user_id].checkTimeout();\n                std::cout << \"Session for user \" << user_id << \" is active.\\n\";\n            } else {\n                std::cout << \"No session found for user \" << user_id << \".\\n\";\n            }\n        } catch (const SessionTimeoutException& e) {\n            std::cerr << \"Error: \" << e.what() << \"\\n\";\n            sessions.erase(user_id);\n        }\n    }\n};\n\nint main() {\n    SessionManager manager(5); // 5 seconds timeout\n    manager.createSession(\"user1\");\n\n    std::this_thread::sleep_for(std::chrono::seconds(3));\n    manager.accessSession(\"user1\");\n\n    std::this_thread::sleep_for(std::chrono::seconds(3));\n    manager.accessSession(\"user1\");\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that processes audio files and manages exceptions for unsupported audio formats.",
    "code": "```cpp\n#include <iostream>\n#include <stdexcept>\n#include <string>\n\nclass UnsupportedAudioFormatException : public std::runtime_error {\npublic:\n    UnsupportedAudioFormatException(const std::string& message)\n        : std::runtime_error(message) {}\n};\n\nvoid processAudioFile(const std::string& filePath) {\n    // Simulate checking the file format\n    if (filePath.substr(filePath.find_last_of(\".\") + 1) != \"wav\") {\n        throw UnsupportedAudioFormatException(\"Unsupported audio format: \" + filePath);\n    }\n    std::cout << \"Processing audio file: \" << filePath << std::endl;\n}\n\nint main() {\n    try {\n        processAudioFile(\"song.mp3\");\n    } catch (const UnsupportedAudioFormatException& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n\n    try {\n        processAudioFile(\"podcast.wav\");\n    } catch (const UnsupportedAudioFormatException& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a service that sends notifications and handles exceptions for unreachable destinations.",
    "code": "```cpp\n#include <iostream>\n#include <stdexcept>\n#include <string>\n\nclass NotificationService {\npublic:\n    void sendNotification(const std::string& destination) {\n        try {\n            if (!isDestinationReachable(destination)) {\n                throw std::runtime_error(\"Destination unreachable: \" + destination);\n            }\n            std::cout << \"Notification sent to \" << destination << std::endl;\n        } catch (const std::exception& e) {\n            handleException(e);\n        }\n    }\n\nprivate:\n    bool isDestinationReachable(const std::string& destination) {\n        // Simulate the destination being unreachable\n        return false;\n    }\n\n    void handleException(const std::exception& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n};\n\nint main() {\n    NotificationService service;\n    service.sendNotification(\"example@example.com\");\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a program that performs data migration and manages data transformation exceptions.",
    "code": "```cpp\n#include <iostream>\n#include <vector>\n#include <stdexcept>\n\nclass DataTransformationException : public std::runtime_error {\npublic:\n    DataTransformationException(const std::string& message)\n        : std::runtime_error(message) {}\n};\n\nvoid transformData(int& data) {\n    if (data < 0) {\n        throw DataTransformationException(\"Negative data encountered\");\n    }\n    data *= 2; // Example transformation\n}\n\nvoid migrateData(const std::vector<int>& source, std::vector<int>& destination) {\n    for (int data : source) {\n        try {\n            transformData(data);\n            destination.push_back(data);\n        } catch (const DataTransformationException& e) {\n            std::cerr << \"Transformation error: \" << e.what() << std::endl;\n        }\n    }\n}\n\nint main() {\n    std::vector<int> sourceData = {1, 2, -3, 4, 5};\n    std::vector<int> destinationData;\n\n    migrateData(sourceData, destinationData);\n\n    std::cout << \"Migrated Data: \";\n    for (int data : destinationData) {\n        std::cout << data << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a function that processes video files and handles codec compatibility exceptions.",
    "code": "```cpp\n#include <iostream>\n#include <stdexcept>\n\nclass CodecCompatibilityException : public std::runtime_error {\npublic:\n    CodecCompatibilityException(const std::string& message)\n        : std::runtime_error(\"Codec Compatibility Error: \" + message) {}\n};\n\nvoid processVideoFile(const std::string& fileName) {\n    try {\n        // Simulate codec compatibility check\n        bool isCompatible = false; // Assume the codec is not compatible\n\n        if (!isCompatible) {\n            throw CodecCompatibilityException(\"Incompatible codec found in file: \" + fileName);\n        }\n\n        // Process the video file (details omitted)\n        std::cout << \"Processing video file: \" << fileName << std::endl;\n\n    } catch (const CodecCompatibilityException& e) {\n        std::cerr << e.what() << std::endl;\n    }\n}\n\nint main() {\n    processVideoFile(\"example_video.mp4\");\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that manages memory allocation and catches out-of-memory exceptions.",
    "code": "```cpp\n#include <iostream>\n#include <new>\n\nvoid manageMemory() {\n    try {\n        // Attempt to allocate a large block of memory\n        int* largeArray = new int[1000000000];\n        \n        // Use the allocated memory for some operation\n        // ...\n\n        // Free the allocated memory\n        delete[] largeArray;\n    } catch (const std::bad_alloc& e) {\n        std::cerr << \"Memory allocation failed: \" << e.what() << std::endl;\n    }\n}\n\nint main() {\n    manageMemory();\n    return 0;\n}\n```"
  },
  {
    "task": "Create a program that processes financial transactions and handles currency conversion exceptions.",
    "code": "```cpp\n#include <iostream>\n#include <stdexcept>\n#include <string>\n\nclass CurrencyConversionException : public std::runtime_error {\npublic:\n    CurrencyConversionException(const std::string& message)\n        : std::runtime_error(message) {}\n};\n\ndouble convertCurrency(double amount, const std::string& fromCurrency, const std::string& toCurrency) {\n    if (fromCurrency == \"USD\" && toCurrency == \"EUR\") {\n        return amount * 0.85; // Example conversion rate\n    } else if (fromCurrency == \"EUR\" && toCurrency == \"USD\") {\n        return amount * 1.15; // Example conversion rate\n    } else {\n        throw CurrencyConversionException(\"Unsupported currency conversion from \" + fromCurrency + \" to \" + toCurrency);\n    }\n}\n\nvoid processTransaction(double amount, const std::string& fromCurrency, const std::string& toCurrency) {\n    try {\n        double convertedAmount = convertCurrency(amount, fromCurrency, toCurrency);\n        std::cout << \"Converted amount: \" << convertedAmount << \" \" << toCurrency << std::endl;\n    } catch (const CurrencyConversionException& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n}\n\nint main() {\n    processTransaction(100, \"USD\", \"EUR\");\n    processTransaction(100, \"USD\", \"JPY\");\n\n    return 0;\n}\n```"
  },
  {
    "task": "Design a function that interacts with cloud storage and manages access permission exceptions.",
    "code": "```cpp\n#include <iostream>\n#include <stdexcept>\n\n// Custom exception class for AccessPermissionException\nclass AccessPermissionException : public std::runtime_error {\npublic:\n    AccessPermissionException(const std::string& message)\n        : std::runtime_error(message) {}\n};\n\n// Function to interact with cloud storage\nvoid interactWithCloudStorage() {\n    // Simulate an access permission error\n    bool hasPermission = false;\n\n    if (!hasPermission) {\n        throw AccessPermissionException(\"Access denied: insufficient permissions.\");\n    }\n\n    // Simulated cloud storage interaction logic\n    std::cout << \"Interacting with cloud storage...\" << std::endl;\n}\n\nint main() {\n    try {\n        interactWithCloudStorage();\n    } catch (const AccessPermissionException& e) {\n        std::cerr << \"Caught exception: \" << e.what() << std::endl;\n    } catch (const std::exception& e) {\n        std::cerr << \"Caught a general exception: \" << e.what() << std::endl;\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a script that automates deployment and handles exceptions for missing configuration files.",
    "code": "```cpp\n#include <iostream>\n#include <fstream>\n#include <stdexcept>\n\nvoid deploy() {\n    // Simulated deployment logic\n    std::cout << \"Deployment started...\" << std::endl;\n    // Deployment logic would go here\n    std::cout << \"Deployment successful!\" << std::endl;\n}\n\nvoid checkConfigurationFile(const std::string& filepath) {\n    std::ifstream configFile(filepath);\n    if (!configFile.is_open()) {\n        throw std::runtime_error(\"Missing configuration file: \" + filepath);\n    }\n}\n\nint main() {\n    const std::string configFilePath = \"config.txt\";\n    \n    try {\n        checkConfigurationFile(configFilePath);\n        deploy();\n    }\n    catch (const std::runtime_error& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n        return EXIT_FAILURE;\n    }\n    \n    return EXIT_SUCCESS;\n}\n```"
  },
  {
    "task": "Write a function that normalizes data and handles exceptions for invalid data ranges.",
    "code": "```cpp\n#include <iostream>\n#include <stdexcept>\n#include <vector>\n\ndouble normalize(double value, double min, double max) {\n    if (min >= max) {\n        throw std::invalid_argument(\"Invalid range: min must be less than max.\");\n    }\n    if (value < min || value > max) {\n        throw std::out_of_range(\"Value is out of the valid range.\");\n    }\n    return (value - min) / (max - min);\n}\n\nint main() {\n    std::vector<double> data = {10, 20, 30, 40, 50};\n    double min = 10;\n    double max = 50;\n\n    for (double value : data) {\n        try {\n            double normalizedValue = normalize(value, min, max);\n            std::cout << \"Normalized value: \" << normalizedValue << std::endl;\n        } catch (const std::exception &e) {\n            std::cerr << \"Error: \" << e.what() << std::endl;\n        }\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a system that monitors application performance and handles threshold breach exceptions.",
    "code": "```cpp\n#include <iostream>\n#include <stdexcept>\n#include <string>\n\nclass ThresholdBreachException : public std::runtime_error {\npublic:\n    explicit ThresholdBreachException(const std::string& message)\n        : std::runtime_error(message) {}\n};\n\nclass PerformanceMonitor {\npublic:\n    void checkPerformance(int value, int threshold) {\n        if (value > threshold) {\n            throw ThresholdBreachException(\"Performance threshold breached!\");\n        } else {\n            std::cout << \"Performance is within acceptable limits.\" << std::endl;\n        }\n    }\n};\n\nint main() {\n    PerformanceMonitor monitor;\n    int performanceValue = 85;\n    int threshold = 80;\n\n    try {\n        monitor.checkPerformance(performanceValue, threshold);\n    } catch (const ThresholdBreachException& e) {\n        std::cerr << \"Exception: \" << e.what() << std::endl;\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a program that processes social media data and manages API limit exceptions.",
    "code": "```cpp\n#include <iostream>\n#include <stdexcept>\n#include <string>\n\n// Custom exception class for API limit\nclass ApiLimitException : public std::runtime_error {\npublic:\n    explicit ApiLimitException(const std::string& message)\n        : std::runtime_error(message) {}\n};\n\n// Function to simulate API call and throw exception on limit\nvoid fetchDataFromApi(int callCount) {\n    const int apiLimit = 5;\n    if (callCount > apiLimit) {\n        throw ApiLimitException(\"API call limit exceeded\");\n    }\n    std::cout << \"API call \" << callCount << \" successful.\" << std::endl;\n}\n\nint main() {\n    int callCount = 0;\n    while (true) {\n        try {\n            callCount++;\n            fetchDataFromApi(callCount);\n        } catch (const ApiLimitException& e) {\n            std::cerr << \"Error: \" << e.what() << std::endl;\n            break;\n        }\n    }\n    return 0;\n}\n```"
  },
  {
    "task": "Design a function that integrates with payment gateways and handles payment failure exceptions.",
    "code": "```cpp\n#include <iostream>\n#include <stdexcept>\n#include <string>\n\n// Custom exception for payment failures\nclass PaymentException : public std::runtime_error {\npublic:\n    PaymentException(const std::string& message)\n        : std::runtime_error(message) {}\n};\n\n// Mock function that simulates payment processing\nbool processPayment(const std::string& paymentGateway, double amount) {\n    if (paymentGateway == \"GatewayA\") {\n        // Simulate a failure for demonstration\n        throw PaymentException(\"Payment failed with GatewayA\");\n    }\n    // Simulate success for other gateways\n    return true;\n}\n\n// Function to handle payment process\nvoid handlePayment(const std::string& paymentGateway, double amount) {\n    try {\n        if (processPayment(paymentGateway, amount)) {\n            std::cout << \"Payment processed successfully with \" << paymentGateway << std::endl;\n        }\n    } catch (const PaymentException& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n        // Handle the payment failure (e.g., log the error, retry, etc.)\n    }\n}\n\nint main() {\n    handlePayment(\"GatewayA\", 100.0);\n    handlePayment(\"GatewayB\", 200.0);\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that backs up data and handles exceptions for unavailable storage media.",
    "code": "```cpp\n#include <iostream>\n#include <stdexcept>\n\nvoid backupData() {\n    try {\n        // Simulate checking for storage media availability\n        bool storageAvailable = false; // Change to true to simulate available media\n\n        if (!storageAvailable) {\n            throw std::runtime_error(\"Storage media unavailable\");\n        }\n\n        // Simulate data backup process\n        std::cout << \"Backing up data...\" << std::endl;\n        // Backup logic goes here\n\n        std::cout << \"Data backup successful.\" << std::endl;\n    } catch (const std::runtime_error& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n        // Handle the exception, e.g., retry logic, alerting, etc.\n    }\n}\n\nint main() {\n    backupData();\n    return 0;\n}\n```"
  },
  {
    "task": "Create a tool that manages software updates and handles exceptions for version conflicts.",
    "code": "```cpp\n#include <iostream>\n#include <stdexcept>\n#include <string>\n\nclass VersionConflictException : public std::runtime_error {\npublic:\n    explicit VersionConflictException(const std::string& message)\n        : std::runtime_error(message) {}\n};\n\nclass SoftwareUpdateManager {\n    std::string currentVersion;\n\npublic:\n    SoftwareUpdateManager(const std::string& version) : currentVersion(version) {}\n\n    void updateToVersion(const std::string& newVersion) {\n        try {\n            if (isVersionConflict(newVersion)) {\n                throw VersionConflictException(\"Version conflict detected: \" + newVersion);\n            }\n            applyUpdate(newVersion);\n            std::cout << \"Updated to version: \" << newVersion << std::endl;\n        } catch (const VersionConflictException& e) {\n            std::cerr << \"Update failed: \" << e.what() << std::endl;\n        }\n    }\n\nprivate:\n    bool isVersionConflict(const std::string& newVersion) {\n        // Simulated conflict check\n        return newVersion <= currentVersion;\n    }\n\n    void applyUpdate(const std::string& newVersion) {\n        currentVersion = newVersion;\n    }\n};\n\nint main() {\n    SoftwareUpdateManager manager(\"1.0.0\");\n    manager.updateToVersion(\"1.0.1\"); // Successful update\n    manager.updateToVersion(\"0.9.9\"); // Version conflict\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a program that performs sentiment analysis and manages exceptions for ambiguous texts.",
    "code": "```cpp\n#include <iostream>\n#include <string>\n#include <stdexcept>\n\nclass SentimentAnalyzer {\npublic:\n    std::string analyze(const std::string &text) {\n        if (text.empty()) {\n            throw std::invalid_argument(\"Input text is empty\");\n        }\n        // Placeholder logic: check for ambiguous words\n        if (text.find(\"maybe\") != std::string::npos) {\n            throw std::runtime_error(\"Ambiguous sentiment detected\");\n        }\n        \n        // Dummy sentiment analysis logic\n        if (text.find(\"good\") != std::string::npos) {\n            return \"Positive sentiment\";\n        } else if (text.find(\"bad\") != std::string::npos) {\n            return \"Negative sentiment\";\n        } else {\n            return \"Neutral sentiment\";\n        }\n    }\n};\n\nint main() {\n    SentimentAnalyzer analyzer;\n    std::string text;\n\n    std::cout << \"Enter text for sentiment analysis: \";\n    std::getline(std::cin, text);\n\n    try {\n        std::string result = analyzer.analyze(text);\n        std::cout << \"Sentiment Analysis Result: \" << result << std::endl;\n    } catch (const std::invalid_argument &e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    } catch (const std::runtime_error &e) {\n        std::cerr << \"Warning: \" << e.what() << std::endl;\n    } catch (...) {\n        std::cerr << \"An unexpected error occurred.\" << std::endl;\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a function that manages user authentication and handles credential mismatch exceptions.",
    "code": "```cpp\n#include <iostream>\n#include <string>\n#include <stdexcept>\n\nclass AuthenticationException : public std::runtime_error {\npublic:\n    explicit AuthenticationException(const std::string& message)\n        : std::runtime_error(message) {}\n};\n\nbool authenticateUser(const std::string& username, const std::string& password) {\n    const std::string correctUsername = \"user\";\n    const std::string correctPassword = \"pass\";\n\n    if (username != correctUsername || password != correctPassword) {\n        throw AuthenticationException(\"Credential mismatch: Authentication failed.\");\n    }\n    return true;\n}\n\nint main() {\n    std::string username, password;\n    std::cout << \"Enter username: \";\n    std::cin >> username;\n    std::cout << \"Enter password: \";\n    std::cin >> password;\n\n    try {\n        if (authenticateUser(username, password)) {\n            std::cout << \"Authentication successful.\" << std::endl;\n        }\n    } catch (const AuthenticationException& e) {\n        std::cerr << e.what() << std::endl;\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a program that processes geographic data and handles exceptions for invalid coordinates.",
    "code": "```cpp\n#include <iostream>\n#include <stdexcept>\n\nclass InvalidCoordinateException : public std::runtime_error {\npublic:\n    InvalidCoordinateException(const std::string& message) : std::runtime_error(message) {}\n};\n\nclass GeographicDataProcessor {\npublic:\n    void processCoordinate(double latitude, double longitude) {\n        if (latitude < -90.0 || latitude > 90.0) {\n            throw InvalidCoordinateException(\"Invalid latitude: \" + std::to_string(latitude));\n        }\n        if (longitude < -180.0 || longitude > 180.0) {\n            throw InvalidCoordinateException(\"Invalid longitude: \" + std::to_string(longitude));\n        }\n        // Process the valid coordinate\n        std::cout << \"Processing coordinate: (\" << latitude << \", \" << longitude << \")\" << std::endl;\n    }\n};\n\nint main() {\n    GeographicDataProcessor processor;\n    double latitudes[] = {45.0, 100.0, -91.0};\n    double longitudes[] = {120.0, 200.0, -180.1};\n    \n    for (int i = 0; i < 3; ++i) {\n        try {\n            processor.processCoordinate(latitudes[i], longitudes[i]);\n        } catch (const InvalidCoordinateException& e) {\n            std::cerr << \"Error: \" << e.what() << std::endl;\n        }\n    }\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Create a script that manages network configurations and handles exceptions for invalid syntax.",
    "code": "```cpp\n#include <iostream>\n#include <stdexcept>\n#include <string>\n\nclass NetworkConfigException : public std::runtime_error {\npublic:\n    explicit NetworkConfigException(const std::string& message) : std::runtime_error(message) {}\n};\n\nvoid configureNetwork(const std::string& config) {\n    if (config.empty() || config.find(\"invalid_syntax\") != std::string::npos) {\n        throw NetworkConfigException(\"Invalid syntax in network configuration\");\n    }\n    std::cout << \"Network configured with: \" << config << std::endl;\n}\n\nint main() {\n    try {\n        std::string config = \"valid_network_config\";\n        configureNetwork(config);\n        \n        config = \"invalid_syntax_config\";\n        configureNetwork(config);\n    } catch (const NetworkConfigException& e) {\n        std::cerr << \"Configuration error: \" << e.what() << std::endl;\n    } catch (const std::exception& e) {\n        std::cerr << \"An unexpected error occurred: \" << e.what() << std::endl;\n    }\n    return 0;\n}\n```"
  },
  {
    "task": "Design a function that processes biometric data and handles exceptions for sensor errors.",
    "code": "```cpp\n#include <iostream>\n#include <stdexcept>\n#include <string>\n\nclass SensorError : public std::runtime_error {\npublic:\n    explicit SensorError(const std::string& message)\n        : std::runtime_error(message) {}\n};\n\nvoid processBiometricData() {\n    try {\n        // Simulating a sensor error\n        throw SensorError(\"Sensor failed to read data\");\n\n        // Process biometric data here\n        std::cout << \"Processing biometric data...\" << std::endl;\n\n    } catch (const SensorError& e) {\n        std::cerr << \"An error occurred: \" << e.what() << std::endl;\n    }\n}\n\nint main() {\n    processBiometricData();\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a system that manages access control and handles exceptions for unauthorized access attempts.",
    "code": "```cpp\n#include <iostream>\n#include <string>\n#include <exception>\n#include <unordered_set>\n\nclass UnauthorizedAccessException : public std::exception {\npublic:\n    const char* what() const noexcept override {\n        return \"Unauthorized access attempt detected.\";\n    }\n};\n\nclass AccessControlSystem {\nprivate:\n    std::unordered_set<std::string> authorizedUsers;\n\npublic:\n    AccessControlSystem() {\n        // Add some authorized users for demonstration\n        authorizedUsers.insert(\"user1\");\n        authorizedUsers.insert(\"user2\");\n        authorizedUsers.insert(\"admin\");\n    }\n\n    void requestAccess(const std::string& username) {\n        if (authorizedUsers.find(username) == authorizedUsers.end()) {\n            throw UnauthorizedAccessException();\n        } else {\n            std::cout << \"Access granted to \" << username << \".\" << std::endl;\n        }\n    }\n};\n\nint main() {\n    AccessControlSystem acs;\n    std::string users[] = {\"user1\", \"user3\", \"admin\", \"guest\"};\n\n    for (const auto& user : users) {\n        try {\n            acs.requestAccess(user);\n        } catch (const UnauthorizedAccessException& e) {\n            std::cerr << \"Error: \" << e.what() << \" User: \" << user << std::endl;\n        }\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that performs load balancing and handles exceptions for unreachable nodes.",
    "code": "```cpp\n#include <iostream>\n#include <vector>\n#include <stdexcept>\n\nclass NodeUnreachableException : public std::exception {\npublic:\n    const char* what() const noexcept override {\n        return \"Node is unreachable\";\n    }\n};\n\nvoid performLoadBalancing(const std::vector<int>& nodes) {\n    for (const int& node : nodes) {\n        try {\n            if (node == -1) { // Assuming -1 represents an unreachable node\n                throw NodeUnreachableException();\n            }\n            std::cout << \"Balancing load on node: \" << node << std::endl;\n        } catch (const NodeUnreachableException& e) {\n            std::cerr << \"Error: \" << e.what() << \" (Node: \" << node << \")\" << std::endl;\n        }\n    }\n}\n\nint main() {\n    std::vector<int> nodes = {1, 2, -1, 3, 4, -1, 5};\n    performLoadBalancing(nodes);\n    return 0;\n}\n```"
  },
  {
    "task": "Create a program that simulates virtual environments and manages resource allocation exceptions.",
    "code": "```cpp\n#include <iostream>\n#include <stdexcept>\n\nclass VirtualEnvironment {\npublic:\n    VirtualEnvironment() {\n        std::cout << \"Virtual Environment Created\\n\";\n    }\n\n    void allocateResources() {\n        throw std::runtime_error(\"Resource Allocation Failed\");\n    }\n\n    ~VirtualEnvironment() {\n        std::cout << \"Virtual Environment Destroyed\\n\";\n    }\n};\n\nint main() {\n    try {\n        VirtualEnvironment env;\n        env.allocateResources();\n    } catch (const std::runtime_error& e) {\n        std::cerr << \"Exception Caught: \" << e.what() << '\\n';\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a tool that manages digital rights and handles exceptions for unauthorized content access.",
    "code": "```cpp\n#include <iostream>\n#include <string>\n#include <exception>\n\nclass UnauthorizedAccessException : public std::exception {\npublic:\n    const char* what() const noexcept override {\n        return \"Unauthorized access to content.\";\n    }\n};\n\nclass DigitalRightsManager {\npublic:\n    bool hasAccess(const std::string& user) {\n        // Simulating access check\n        return user == \"authorized_user\";\n    }\n\n    void accessContent(const std::string& user) {\n        if (!hasAccess(user)) {\n            throw UnauthorizedAccessException();\n        }\n        std::cout << \"Access granted to content for user: \" << user << std::endl;\n    }\n};\n\nint main() {\n    DigitalRightsManager drm;\n    std::string user = \"unauthorized_user\";\n    \n    try {\n        drm.accessContent(user);\n    } catch (const UnauthorizedAccessException& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Design a function that synchronizes clocks and handles exceptions for time drift.",
    "code": "```cpp\n#include <iostream>\n#include <stdexcept>\n#include <ctime>\n\nclass TimeDriftException : public std::runtime_error {\npublic:\n    TimeDriftException(const std::string& message) : std::runtime_error(message) {}\n};\n\nvoid synchronizeClocks() {\n    try {\n        std::time_t currentTime = std::time(nullptr);\n        \n        if (currentTime == -1) {\n            throw TimeDriftException(\"Failed to retrieve current time.\");\n        }\n\n        // Simulate a condition where time drift is detected\n        bool timeDriftDetected = false; // This should be determined by some logic\n\n        if (timeDriftDetected) {\n            throw TimeDriftException(\"Time drift detected.\");\n        }\n\n        std::cout << \"Clocks synchronized successfully at: \" << std::ctime(&currentTime);\n    }\n    catch (const TimeDriftException& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n}\n\nint main() {\n    synchronizeClocks();\n    return 0;\n}\n```"
  },
  {
    "task": "Write a script that manages system backups and handles exceptions for insufficient backup space.",
    "code": "```cpp\n#include <iostream>\n#include <stdexcept>\n#include <string>\n\nclass BackupException : public std::runtime_error {\npublic:\n    BackupException(const std::string& message) : std::runtime_error(message) {}\n};\n\nbool hasSufficientSpace() {\n    // Dummy function to simulate space check\n    return false; // Simulating insufficient space for the backup\n}\n\nvoid performBackup() {\n    if (!hasSufficientSpace()) {\n        throw BackupException(\"Insufficient backup space.\");\n    }\n    std::cout << \"Backup completed successfully.\" << std::endl;\n}\n\nint main() {\n    try {\n        performBackup();\n    } catch (const BackupException& e) {\n        std::cerr << \"Backup failed: \" << e.what() << std::endl;\n    } catch (const std::exception& e) {\n        std::cerr << \"An unexpected error occurred: \" << e.what() << std::endl;\n    }\n    return 0;\n}\n```"
  },
  {
    "task": "Create a program that processes natural language text and handles parsing exceptions.",
    "code": "```cpp\n#include <iostream>\n#include <string>\n#include <stdexcept>\n\nclass TextParser {\npublic:\n    void parse(const std::string& text) {\n        try {\n            if (text.empty()) {\n                throw std::invalid_argument(\"The text cannot be empty.\");\n            }\n            // Simulate parsing logic\n            if (text.find(\"error\") != std::string::npos) {\n                throw std::runtime_error(\"Parsing error encountered.\");\n            }\n            std::cout << \"Text parsed successfully: \" << text << std::endl;\n        } catch (const std::invalid_argument& e) {\n            std::cerr << \"Invalid argument: \" << e.what() << std::endl;\n        } catch (const std::runtime_error& e) {\n            std::cerr << \"Runtime error: \" << e.what() << std::endl;\n        } catch (...) {\n            std::cerr << \"An unknown error occurred during parsing.\" << std::endl;\n        }\n    }\n};\n\nint main() {\n    TextParser parser;\n    parser.parse(\"This is a test string.\");\n    parser.parse(\"\");\n    parser.parse(\"This string contains an error.\");\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a function that manages thread execution and handles race condition exceptions.",
    "code": "```cpp\n#include <iostream>\n#include <thread>\n#include <mutex>\n#include <vector>\n#include <exception>\n\nclass RaceConditionException : public std::exception {\npublic:\n    const char* what() const noexcept override {\n        return \"Race condition detected!\";\n    }\n};\n\nstd::mutex mtx;\nint sharedResource = 0;\n\nvoid accessResource(int id) {\n    try {\n        std::lock_guard<std::mutex> lock(mtx);\n        if (sharedResource != 0) {\n            throw RaceConditionException();\n        }\n        sharedResource = id;\n        std::cout << \"Thread \" << id << \" is accessing the resource.\" << std::endl;\n        std::this_thread::sleep_for(std::chrono::milliseconds(100));\n        sharedResource = 0;\n    } catch (const RaceConditionException& e) {\n        std::cerr << \"Exception in thread \" << id << \": \" << e.what() << std::endl;\n    }\n}\n\nvoid manageThreads() {\n    const int numThreads = 5;\n    std::vector<std::thread> threads;\n    for (int i = 0; i < numThreads; ++i) {\n        threads.emplace_back(accessResource, i + 1);\n    }\n    for (auto& th : threads) {\n        if (th.joinable()) {\n            th.join();\n        }\n    }\n}\n\nint main() {\n    manageThreads();\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a system that integrates with IoT devices and handles connectivity exceptions.",
    "code": "```cpp\n#include <iostream>\n#include <stdexcept>\n\nclass IoTDevice {\npublic:\n    void connect() {\n        // Simulate connectivity attempt\n        bool connectionSuccessful = false; // Simulate a failed connection\n\n        if (!connectionSuccessful) {\n            throw std::runtime_error(\"Failed to connect to IoT device.\");\n        }\n    }\n};\n\nint main() {\n    IoTDevice device;\n\n    try {\n        device.connect();\n        std::cout << \"Connected to IoT device successfully.\" << std::endl;\n    } catch (const std::runtime_error& e) {\n        std::cerr << \"Exception: \" << e.what() << std::endl;\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that manages application logging and handles exceptions for log overflow.",
    "code": "```cpp\n#include <iostream>\n#include <stdexcept>\n#include <vector>\n#include <string>\n\nclass LogOverflowException : public std::runtime_error {\npublic:\n    LogOverflowException(const std::string& message)\n        : std::runtime_error(message) {}\n};\n\nclass Logger {\npublic:\n    Logger(size_t maxSize) : maxSize(maxSize) {}\n\n    void log(const std::string& message) {\n        if (logs.size() >= maxSize) {\n            throw LogOverflowException(\"Log overflow: Maximum log size exceeded\");\n        }\n        logs.push_back(message);\n    }\n\n    void displayLogs() const {\n        for (const auto& log : logs) {\n            std::cout << log << std::endl;\n        }\n    }\n\nprivate:\n    std::vector<std::string> logs;\n    size_t maxSize;\n};\n\nint main() {\n    Logger logger(3);\n\n    try {\n        logger.log(\"Log entry 1\");\n        logger.log(\"Log entry 2\");\n        logger.log(\"Log entry 3\");\n        logger.log(\"Log entry 4\"); // This will cause an exception\n    } catch (const LogOverflowException& e) {\n        std::cerr << \"Exception caught: \" << e.what() << std::endl;\n    }\n\n    logger.displayLogs();\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a tool that visualizes data and handles exceptions for unsupported visualization types.",
    "code": "```cpp\n#include <iostream>\n#include <string>\n#include <stdexcept>\n\nclass UnsupportedVisualizationType : public std::runtime_error {\npublic:\n    UnsupportedVisualizationType(const std::string& type)\n        : std::runtime_error(\"Unsupported visualization type: \" + type) {}\n};\n\nvoid visualizeData(const std::string& type) {\n    if (type == \"bar\" || type == \"line\" || type == \"pie\") {\n        std::cout << \"Visualizing data as \" << type << \" chart.\" << std::endl;\n    } else {\n        throw UnsupportedVisualizationType(type);\n    }\n}\n\nint main() {\n    try {\n        visualizeData(\"bar\");\n        visualizeData(\"scatter\");\n    } catch (const UnsupportedVisualizationType& e) {\n        std::cerr << e.what() << std::endl;\n    }\n    return 0;\n}\n```"
  },
  {
    "task": "Design a program that performs genetic algorithm simulations and manages exception for invalid mutations.",
    "code": "```cpp\n#include <iostream>\n#include <vector>\n#include <stdexcept>\n#include <cstdlib>\n#include <ctime>\n\nclass GeneticAlgorithm {\npublic:\n    GeneticAlgorithm() {\n        std::srand(std::time(nullptr));\n    }\n\n    void runSimulation() {\n        try {\n            for (int i = 0; i < 100; ++i) {\n                int mutation = performMutation();\n                if (mutation < 0) {\n                    throw std::runtime_error(\"Invalid mutation detected.\");\n                }\n                std::cout << \"Mutation \" << i << \": \" << mutation << std::endl;\n            }\n        } catch (const std::runtime_error &e) {\n            std::cerr << \"Exception caught: \" << e.what() << std::endl;\n        }\n    }\n\nprivate:\n    int performMutation() {\n        // Simulate a mutation, which sometimes could be invalid\n        int mutation = std::rand() % 20 - 10; // Results range from -10 to 9\n        return mutation;\n    }\n};\n\nint main() {\n    GeneticAlgorithm ga;\n    ga.runSimulation();\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a function that manages distributed transactions and handles consistency exceptions.",
    "code": "```cpp\n#include <iostream>\n#include <stdexcept>\n\nclass ConsistencyException : public std::exception {\npublic:\n    const char* what() const noexcept override {\n        return \"Consistency exception occurred\";\n    }\n};\n\nvoid performTransactionPart1() {\n    // Simulate a transaction part, could throw an exception\n    // For demonstration, we'll assume this part succeeds\n    std::cout << \"Transaction part 1 succeeded.\" << std::endl;\n}\n\nvoid performTransactionPart2() {\n    // Simulate a transaction part, throw an exception for demonstration\n    throw ConsistencyException();\n}\n\nvoid manageDistributedTransaction() {\n    try {\n        performTransactionPart1();\n        performTransactionPart2();\n    } catch (const ConsistencyException& e) {\n        std::cerr << e.what() << std::endl;\n        // Handle the exception, rollback or log as necessary\n    } catch (const std::exception& e) {\n        std::cerr << \"An unexpected error occurred: \" << e.what() << std::endl;\n    }\n}\n\nint main() {\n    manageDistributedTransaction();\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that handles secure communications and manages encryption key exceptions.",
    "code": "```cpp\n#include <iostream>\n#include <string>\n#include <stdexcept>\n\nclass EncryptionKeyError : public std::runtime_error {\npublic:\n    explicit EncryptionKeyError(const std::string& message)\n        : std::runtime_error(message) {}\n};\n\nvoid handleSecureCommunication() {\n    try {\n        // Simulate the process of obtaining an encryption key\n        bool keyObtained = false; // Replace with actual key obtaining logic\n\n        if (!keyObtained) {\n            throw EncryptionKeyError(\"Failed to obtain encryption key.\");\n        }\n\n        // Proceed with secure communication using the encryption key\n        std::cout << \"Secure communication established.\" << std::endl;\n\n    } catch (const EncryptionKeyError& e) {\n        std::cerr << \"Encryption Key Error: \" << e.what() << std::endl;\n        // Handle the exception, e.g., retry, log the error, or abort\n    } catch (const std::exception& e) {\n        std::cerr << \"General Error: \" << e.what() << std::endl;\n        // Handle any other exceptions\n    }\n}\n\nint main() {\n    handleSecureCommunication();\n    return 0;\n}\n```"
  },
  {
    "task": "Create a system that processes sensor data and handles out-of-range value exceptions.",
    "code": "```cpp\n#include <iostream>\n#include <stdexcept>\n#include <vector>\n\n// Custom exception for out-of-range sensor values\nclass OutOfRangeException : public std::runtime_error {\npublic:\n    OutOfRangeException(const std::string& message)\n        : std::runtime_error(message) {}\n};\n\n// Function to process sensor data\nvoid processSensorData(const std::vector<int>& sensorData) {\n    const int MIN_VALUE = 0;\n    const int MAX_VALUE = 100;\n\n    for (int value : sensorData) {\n        if (value < MIN_VALUE || value > MAX_VALUE) {\n            throw OutOfRangeException(\"Sensor value out of range: \" + std::to_string(value));\n        }\n        std::cout << \"Processing value: \" << value << std::endl;\n    }\n}\n\nint main() {\n    std::vector<int> sensorData = {25, 50, 110, 30};\n\n    try {\n        processSensorData(sensorData);\n    } catch (const OutOfRangeException& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a program that simulates weather patterns and handles model prediction exceptions.",
    "code": "```cpp\n#include <iostream>\n#include <stdexcept>\n#include <cstdlib>\n#include <ctime>\n\nclass WeatherPredictionException : public std::runtime_error {\npublic:\n    explicit WeatherPredictionException(const std::string& message)\n        : std::runtime_error(message) {}\n};\n\nclass WeatherSimulator {\npublic:\n    void simulateWeather() {\n        // Simulate weather data and throw exception for invalid predictions\n        int randomValue = std::rand() % 100;\n        if (randomValue < 20) {\n            throw WeatherPredictionException(\"Weather prediction model failed to converge.\");\n        } else {\n            std::cout << \"Weather prediction successful: \" << randomValue << std::endl;\n        }\n    }\n};\n\nint main() {\n    std::srand(std::time(nullptr));\n    WeatherSimulator simulator;\n\n    try {\n        simulator.simulateWeather();\n    } catch (const WeatherPredictionException& e) {\n        std::cerr << \"Exception caught: \" << e.what() << std::endl;\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Design a function that manages API versioning and handles backward compatibility exceptions.",
    "code": "```cpp\n#include <iostream>\n#include <stdexcept>\n#include <string>\n\nclass VersionException : public std::runtime_error {\npublic:\n    explicit VersionException(const std::string& message)\n        : std::runtime_error(message) {}\n};\n\nvoid manageApiVersion(int currentVersion, int requestVersion) {\n    try {\n        if (requestVersion > currentVersion) {\n            throw VersionException(\"Requested version is not supported.\");\n        }\n        if (requestVersion < currentVersion) {\n            std::cout << \"Handling backward compatibility for version: \" << requestVersion << std::endl;\n        } else {\n            std::cout << \"Handling current version: \" << currentVersion << std::endl;\n        }\n    } catch (const VersionException& e) {\n        std::cerr << \"Version error: \" << e.what() << std::endl;\n    }\n}\n\nint main() {\n    int currentVersion = 3;\n    manageApiVersion(currentVersion, 2); // Test with backward version\n    manageApiVersion(currentVersion, 3); // Test with current version\n    manageApiVersion(currentVersion, 4); // Test with unsupported version\n    return 0;\n}\n```"
  },
  {
    "task": "Write a tool that converts character encodings and handles unsupported encoding exceptions.",
    "code": "```cpp\n#include <iostream>\n#include <locale>\n#include <codecvt>\n#include <string>\n#include <stdexcept>\n\nstd::wstring convertToUtf16(const std::string& input, const std::string& encoding) {\n    try {\n        if (encoding == \"UTF-8\") {\n            std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> converter;\n            return converter.from_bytes(input);\n        } else if (encoding == \"ISO-8859-1\") {\n            std::wstring_convert<std::codecvt_utf8<wchar_t>, wchar_t> converter;\n            std::string utf8 = converter.to_bytes(input);\n            return converter.from_bytes(utf8);\n        } else {\n            throw std::invalid_argument(\"Unsupported encoding\");\n        }\n    } catch (const std::range_error& e) {\n        throw std::runtime_error(\"Range error during conversion\");\n    }\n}\n\nint main() {\n    std::string input = \"Example text\";\n    std::string encoding = \"UTF-8\";\n\n    try {\n        std::wstring result = convertToUtf16(input, encoding);\n        std::wcout << L\"Converted text: \" << result << std::endl;\n    } catch (const std::invalid_argument& e) {\n        std::cerr << \"Exception: \" << e.what() << std::endl;\n    } catch (const std::runtime_error& e) {\n        std::cerr << \"Exception: \" << e.what() << std::endl;\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a program that handles dynamic content generation and manages template parsing exceptions.",
    "code": "```cpp\n#include <iostream>\n#include <string>\n#include <stdexcept>\n\nclass TemplateParseException : public std::runtime_error {\npublic:\n    explicit TemplateParseException(const std::string& message)\n        : std::runtime_error(message) {}\n};\n\nstd::string parseTemplate(const std::string& templateStr) {\n    if (templateStr.empty()) {\n        throw TemplateParseException(\"Template string is empty.\");\n    }\n    // Simulate template parsing logic\n    if (templateStr == \"INVALID\") {\n        throw TemplateParseException(\"Invalid template format.\");\n    }\n    return \"Parsed Content: \" + templateStr;\n}\n\nint main() {\n    std::string templates[] = {\"Hello, World!\", \"INVALID\", \"\"};\n\n    for (const auto& tmpl : templates) {\n        try {\n            std::string result = parseTemplate(tmpl);\n            std::cout << result << std::endl;\n        } catch (const TemplateParseException& ex) {\n            std::cerr << \"Template parsing error: \" << ex.what() << std::endl;\n        } catch (const std::exception& ex) {\n            std::cerr << \"An unexpected error occurred: \" << ex.what() << std::endl;\n        }\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a script that schedules automated tests and handles exceptions for missing test cases.",
    "code": "```cpp\n#include <iostream>\n#include <stdexcept>\n#include <vector>\n#include <string>\n\nclass TestScheduler {\npublic:\n    void scheduleTests(const std::vector<std::string>& tests) {\n        for (const auto& test : tests) {\n            try {\n                if (test.empty()) {\n                    throw std::invalid_argument(\"Missing test case.\");\n                }\n                std::cout << \"Scheduling test: \" << test << std::endl;\n                // Assume some logic here to schedule the test\n            } catch (const std::invalid_argument& e) {\n                std::cerr << \"Error: \" << e.what() << std::endl;\n            }\n        }\n    }\n};\n\nint main() {\n    TestScheduler scheduler;\n    std::vector<std::string> testCases = {\"Test1\", \"\", \"Test3\"};\n    scheduler.scheduleTests(testCases);\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a system that manages virtual machine instances and handles provisioning exceptions.",
    "code": "```cpp\n#include <iostream>\n#include <stdexcept>\n#include <string>\n#include <vector>\n\nclass VMProvisionException : public std::runtime_error {\npublic:\n    VMProvisionException(const std::string& message)\n        : std::runtime_error(\"VM Provisioning Error: \" + message) {}\n};\n\nclass VirtualMachine {\npublic:\n    VirtualMachine(const std::string& id) : id(id), running(false) {}\n\n    void provision() {\n        if (running) {\n            throw VMProvisionException(\"VM \" + id + \" is already running.\");\n        }\n        // Simulate provisioning process, which might fail\n        if (id == \"fail\") {\n            throw VMProvisionException(\"Provisioning failed for VM \" + id + \".\");\n        }\n        running = true;\n        std::cout << \"VM \" << id << \" provisioned successfully.\" << std::endl;\n    }\n\n    void terminate() {\n        if (!running) {\n            throw VMProvisionException(\"VM \" + id + \" is not running.\");\n        }\n        running = false;\n        std::cout << \"VM \" << id << \" terminated successfully.\" << std::endl;\n    }\n\nprivate:\n    std::string id;\n    bool running;\n};\n\nclass VMManager {\npublic:\n    void addVM(const std::string& id) {\n        vms.emplace_back(id);\n    }\n\n    void provisionAll() {\n        for (auto& vm : vms) {\n            try {\n                vm.provision();\n            } catch (const VMProvisionException& e) {\n                std::cerr << e.what() << std::endl;\n            }\n        }\n    }\n\n    void terminateAll() {\n        for (auto& vm : vms) {\n            try {\n                vm.terminate();\n            } catch (const VMProvisionException& e) {\n                std::cerr << e.what() << std::endl;\n            }\n        }\n    }\n\nprivate:\n    std::vector<VirtualMachine> vms;\n};\n\nint main() {\n    VMManager manager;\n    manager.addVM(\"vm1\");\n    manager.addVM(\"vm2\");\n    manager.addVM(\"fail\");\n\n    manager.provisionAll();\n    manager.terminateAll();\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that processes credit scores and handles exceptions for missing credit history.",
    "code": "```cpp\n#include <iostream>\n#include <stdexcept>\n#include <vector>\n\nclass CreditHistoryException : public std::runtime_error {\npublic:\n    CreditHistoryException() : std::runtime_error(\"Missing credit history\") {}\n};\n\nint processCreditScore(const std::vector<int>& creditScores) {\n    if (creditScores.empty()) {\n        throw CreditHistoryException();\n    }\n    int sum = 0;\n    for (int score : creditScores) {\n        sum += score;\n    }\n    return sum / creditScores.size();\n}\n\nint main() {\n    try {\n        std::vector<int> creditScores = {}; // For testing, this is empty\n        int averageScore = processCreditScore(creditScores);\n        std::cout << \"Average Credit Score: \" << averageScore << std::endl;\n    } catch (const CreditHistoryException& e) {\n        std::cerr << \"Exception: \" << e.what() << std::endl;\n    }\n    return 0;\n}\n```"
  },
  {
    "task": "Create a tool that manages digital certificates and handles expiration exceptions.",
    "code": "```cpp\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <ctime>\n\nclass CertificateExpiredException : public std::runtime_error {\npublic:\n    explicit CertificateExpiredException(const std::string& message)\n        : std::runtime_error(message) {}\n};\n\nclass DigitalCertificate {\nprivate:\n    std::string owner;\n    std::time_t expirationDate;\n\npublic:\n    DigitalCertificate(const std::string& owner, std::time_t expirationDate)\n        : owner(owner), expirationDate(expirationDate) {}\n\n    void checkValidity() const {\n        std::time_t now = std::time(nullptr);\n        if (now > expirationDate) {\n            throw CertificateExpiredException(\"Certificate for \" + owner + \" has expired.\");\n        } else {\n            std::cout << \"Certificate for \" << owner << \" is valid.\" << std::endl;\n        }\n    }\n};\n\nint main() {\n    try {\n        std::time_t pastDate = std::time(nullptr) - 10000;  // Simulate an expired certificate\n        DigitalCertificate cert(\"John Doe\", pastDate);\n        cert.checkValidity();\n    } catch (const CertificateExpiredException& e) {\n        std::cerr << \"Exception: \" << e.what() << std::endl;\n    }\n\n    try {\n        std::time_t futureDate = std::time(nullptr) + 10000;  // Simulate a valid certificate\n        DigitalCertificate cert(\"Jane Smith\", futureDate);\n        cert.checkValidity();\n    } catch (const CertificateExpiredException& e) {\n        std::cerr << \"Exception: \" << e.what() << std::endl;\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Design a program that processes genome sequences and handles exceptions for sequence alignment.",
    "code": "```cpp\n#include <iostream>\n#include <string>\n#include <stdexcept>\n\nclass GenomeSequenceProcessor {\npublic:\n    void processSequence(const std::string& sequence1, const std::string& sequence2) {\n        try {\n            alignSequences(sequence1, sequence2);\n            std::cout << \"Sequences aligned successfully.\" << std::endl;\n        } catch (const std::invalid_argument& e) {\n            std::cerr << \"Error: \" << e.what() << std::endl;\n        }\n    }\n\nprivate:\n    void alignSequences(const std::string& seq1, const std::string& seq2) {\n        if (seq1.empty() || seq2.empty()) {\n            throw std::invalid_argument(\"Sequences must not be empty.\");\n        }\n        if (seq1.length() != seq2.length()) {\n            throw std::invalid_argument(\"Sequences must be of the same length for alignment.\");\n        }\n        // Alignment logic would go here\n    }\n};\n\nint main() {\n    GenomeSequenceProcessor processor;\n    std::string seq1 = \"AGCT\";\n    std::string seq2 = \"TCGA\";\n    processor.processSequence(seq1, seq2);\n\n    std::string seq3 = \"AGCT\";\n    std::string seq4 = \"TCA\";\n    processor.processSequence(seq3, seq4);\n\n    return 0;\n}\n```"
  }
]