[
  {
    "task": "Create a function that modifies the first element of an array passed to it. Explain how the changes are reflected in the original array.",
    "code": "```cpp\n#include <iostream>\n\nvoid modifyFirstElement(int* arr) {\n    arr[0] = 42;\n}\n\nint main() {\n    int myArray[] = {1, 2, 3, 4, 5};\n    modifyFirstElement(myArray);\n    std::cout << \"First element after modification: \" << myArray[0] << std::endl;\n    return 0;\n}\n```"
  },
  {
    "task": "Design a function that swaps the values of two variables using pass-by-reference. Demonstrate how the swap affects the original variables.",
    "code": "```cpp\n#include <iostream>\n\nvoid swap(int &a, int &b) {\n    int temp = a;\n    a = b;\n    b = temp;\n}\n\nint main() {\n    int x = 5, y = 10;\n    std::cout << \"Before swap: x = \" << x << \", y = \" << y << std::endl;\n    swap(x, y);\n    std::cout << \"After swap: x = \" << x << \", y = \" << y << std::endl;\n    return 0;\n}\n```"
  },
  {
    "task": "Write a program that passes a large data structure to a function by value and by reference. Compare the performance and memory usage for both approaches.",
    "code": "```cpp\n#include <iostream>\n#include <vector>\n#include <chrono>\n\nstruct LargeData {\n    std::vector<int> data;\n    LargeData(size_t size) : data(size, 1) {} // Initialize with 1s\n};\n\n// Function passing by value\nvoid processByValue(LargeData data) {\n    // Simulate work by summing the elements\n    int sum = 0;\n    for (const auto& elem : data.data) {\n        sum += elem;\n    }\n}\n\n// Function passing by reference\nvoid processByReference(const LargeData& data) {\n    // Simulate work by summing the elements\n    int sum = 0;\n    for (const auto& elem : data.data) {\n        sum += elem;\n    }\n}\n\nint main() {\n    const size_t dataSize = 1000000;\n    LargeData largeData(dataSize);\n\n    auto start = std::chrono::high_resolution_clock::now();\n    processByValue(largeData);\n    auto end = std::chrono::high_resolution_clock::now();\n    std::chrono::duration<double> durationValue = end - start;\n    std::cout << \"Time taken for processByValue: \" << durationValue.count() << \" seconds\\n\";\n\n    start = std::chrono::high_resolution_clock::now();\n    processByReference(largeData);\n    end = std::chrono::high_resolution_clock::now();\n    std::chrono::duration<double> durationReference = end - start;\n    std::cout << \"Time taken for processByReference: \" << durationReference.count() << \" seconds\\n\";\n\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a function that accepts an integer and doubles its value. Show the difference in the original variable when using pass-by-value versus pass-by-reference.",
    "code": "```cpp\n#include <iostream>\n\n// Function to double the value using pass-by-value\nvoid doubleByValue(int num) {\n    num *= 2;\n}\n\n// Function to double the value using pass-by-reference\nvoid doubleByReference(int &num) {\n    num *= 2;\n}\n\nint main() {\n    int originalValue = 5;\n    \n    // Pass-by-value\n    int valueCopy = originalValue;\n    doubleByValue(valueCopy);\n    std::cout << \"Original after pass-by-value: \" << originalValue << std::endl;\n    std::cout << \"Value copy after pass-by-value: \" << valueCopy << std::endl;\n\n    // Pass-by-reference\n    doubleByReference(originalValue);\n    std::cout << \"Original after pass-by-reference: \" << originalValue << std::endl;\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a function that takes a list and returns a new list with elements doubled. Ensure the original list remains unchanged.",
    "code": "```cpp\n#include <vector>\n\nstd::vector<int> doubleElements(const std::vector<int>& inputList) {\n    std::vector<int> doubledList;\n    for (int element : inputList) {\n        doubledList.push_back(element * 2);\n    }\n    return doubledList;\n}\n\nint main() {\n    std::vector<int> originalList = {1, 2, 3, 4, 5};\n    std::vector<int> newList = doubleElements(originalList);\n    return 0;\n}\n```"
  },
  {
    "task": "Design a function that takes a string argument and appends a character to it. Illustrate the result when the string is passed by value.",
    "code": "```cpp\n#include <iostream>\n#include <string>\n\nvoid appendCharByValue(std::string str, char c) {\n    str += c;\n    std::cout << \"Inside function (by value): \" << str << std::endl;\n}\n\nint main() {\n    std::string original = \"Hello\";\n    char toAppend = '!';\n    \n    appendCharByValue(original, toAppend);\n    \n    std::cout << \"After function call: \" << original << std::endl;\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that increments a counter variable. Pass the variable by reference to see changes in the original variable.",
    "code": "```cpp\n#include <iostream>\n\nvoid incrementCounter(int& counter) {\n    counter++;\n}\n\nint main() {\n    int counter = 0;\n    std::cout << \"Counter before: \" << counter << std::endl;\n    incrementCounter(counter);\n    std::cout << \"Counter after: \" << counter << std::endl;\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a function that removes an item from a dictionary passed to it. Demonstrate how pass-by-reference affects the original dictionary.",
    "code": "```cpp\n#include <iostream>\n#include <unordered_map>\n#include <string>\n\nvoid removeItem(std::unordered_map<std::string, int>& dict, const std::string& key) {\n    dict.erase(key);\n}\n\nint main() {\n    std::unordered_map<std::string, int> myDict = {{\"apple\", 3}, {\"banana\", 5}, {\"cherry\", 2}};\n    \n    std::cout << \"Original dictionary:\" << std::endl;\n    for (const auto& item : myDict) {\n        std::cout << item.first << \": \" << item.second << std::endl;\n    }\n\n    removeItem(myDict, \"banana\");\n\n    std::cout << \"\\nDictionary after removal:\" << std::endl;\n    for (const auto& item : myDict) {\n        std::cout << item.first << \": \" << item.second << std::endl;\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a program that passes a matrix to a function, which transposes it. Explain how the transposition affects the original matrix with pass-by-reference.",
    "code": "```cpp\n#include <iostream>\n#include <vector>\n\nvoid transpose(std::vector<std::vector<int>>& matrix) {\n    int n = matrix.size();\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            std::swap(matrix[i][j], matrix[j][i]);\n        }\n    }\n}\n\nvoid printMatrix(const std::vector<std::vector<int>>& matrix) {\n    for (const auto& row : matrix) {\n        for (int val : row) {\n            std::cout << val << \" \";\n        }\n        std::cout << std::endl;\n    }\n}\n\nint main() {\n    std::vector<std::vector<int>> matrix = {\n        {1, 2, 3},\n        {4, 5, 6},\n        {7, 8, 9}\n    };\n    \n    std::cout << \"Original matrix:\" << std::endl;\n    printMatrix(matrix);\n    \n    transpose(matrix);\n    \n    std::cout << \"Transposed matrix:\" << std::endl;\n    printMatrix(matrix);\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Implement a function that takes a float number and rounds it. Discuss the implications of passing the number by value.",
    "code": "```cpp\n#include <iostream>\n#include <cmath>\n\nfloat roundNumberByValue(float num) {\n    return std::round(num);\n}\n\nint main() {\n    float number = 3.14f;\n    float rounded = roundNumberByValue(number);\n    std::cout << \"Original: \" << number << \", Rounded: \" << rounded << std::endl;\n    return 0;\n}\n```"
  },
  {
    "task": "Design a function that accepts a dictionary and adds a key-value pair to it. Show the changes when the dictionary is passed by reference.",
    "code": "```cpp\n#include <iostream>\n#include <map>\n#include <string>\n\n// Function that accepts a dictionary and adds a key-value pair to it\nvoid addKeyValuePair(std::map<std::string, std::string>& dict, const std::string& key, const std::string& value) {\n    dict[key] = value;\n}\n\nint main() {\n    std::map<std::string, std::string> myDict;\n\n    // Add a key-value pair\n    addKeyValuePair(myDict, \"key1\", \"value1\");\n\n    // Show the changes\n    for (const auto& pair : myDict) {\n        std::cout << pair.first << \": \" << pair.second << std::endl;\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a program that passes a string to a function that converts it to uppercase. Explain how this affects the original string with pass-by-value.",
    "code": "```cpp\n#include <iostream>\n#include <string>\n#include <algorithm>\n\nvoid toUpperCase(std::string s) {\n    std::transform(s.begin(), s.end(), s.begin(), ::toupper);\n    std::cout << \"Inside function: \" << s << std::endl;\n}\n\nint main() {\n    std::string original = \"hello, world!\";\n    toUpperCase(original);\n    std::cout << \"Outside function: \" << original << std::endl;\n    return 0;\n}\n```"
  },
  {
    "task": "Create a function that receives a tuple and attempts to modify one of its elements. Discuss the outcome of using pass-by-value.",
    "code": "```cpp\n#include <iostream>\n#include <tuple>\n\nvoid modifyTuple(std::tuple<int, int, int> t) {\n    // Attempt to modify the first element of the tuple\n    std::get<0>(t) = 100;\n    std::cout << \"Inside function, modified tuple element: \" << std::get<0>(t) << std::endl;\n}\n\nint main() {\n    std::tuple<int, int, int> myTuple = std::make_tuple(1, 2, 3);\n    \n    std::cout << \"Before function call, first element: \" << std::get<0>(myTuple) << std::endl;\n    modifyTuple(myTuple);\n    std::cout << \"After function call, first element: \" << std::get<0>(myTuple) << std::endl;\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Develop a function that accepts an object and modifies one of its attributes. Illustrate how pass-by-reference alters the original object.",
    "code": "```cpp\n#include <iostream>\n#include <string>\n\nclass SampleObject {\npublic:\n    int value;\n    SampleObject(int val) : value(val) {}\n};\n\nvoid modifyObject(SampleObject &obj) {\n    obj.value += 10; // Modify the object's attribute\n}\n\nint main() {\n    SampleObject obj(5);\n    std::cout << \"Before modification: \" << obj.value << std::endl;\n    modifyObject(obj);\n    std::cout << \"After modification: \" << obj.value << std::endl;\n    return 0;\n}\n```"
  },
  {
    "task": "Design a function that outputs the sum of all elements in an array passed by value. Confirm the original array remains unchanged.",
    "code": "```cpp\n#include <iostream>\n#include <vector>\n\nint sumArray(std::vector<int> arr) {\n    int sum = 0;\n    for (int value : arr) {\n        sum += value;\n    }\n    return sum;\n}\n\nint main() {\n    std::vector<int> numbers = {1, 2, 3, 4, 5};\n    int result = sumArray(numbers);\n    std::cout << \"Sum: \" << result << std::endl;\n\n    std::cout << \"Original array: \";\n    for (int value : numbers) {\n        std::cout << value << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that takes a boolean flag and toggles its value. Demonstrate the effect of pass-by-reference on the original flag.",
    "code": "```cpp\n#include <iostream>\n\nvoid toggleFlag(bool &flag) {\n    flag = !flag;\n}\n\nint main() {\n    bool myFlag = true;\n    std::cout << \"Original flag: \" << myFlag << std::endl;\n    toggleFlag(myFlag);\n    std::cout << \"Toggled flag: \" << myFlag << std::endl;\n    return 0;\n}\n```"
  },
  {
    "task": "Create a function that takes an object and clones it. Modify the clone and show that the original object remains unaffected.",
    "code": "```cpp\n#include <iostream>\n#include <string>\n\nclass MyObject {\npublic:\n    int value;\n    std::string name;\n\n    MyObject(int v, const std::string &n) : value(v), name(n) {}\n\n    void display() const {\n        std::cout << \"Value: \" << value << \", Name: \" << name << std::endl;\n    }\n};\n\nMyObject cloneAndModify(MyObject obj) {\n    obj.value += 10;\n    obj.name += \"_clone\";\n    return obj;\n}\n\nint main() {\n    MyObject original(1, \"original\");\n    std::cout << \"Original object before cloning: \";\n    original.display();\n\n    MyObject cloned = cloneAndModify(original);\n    std::cout << \"Cloned and modified object: \";\n    cloned.display();\n\n    std::cout << \"Original object after cloning: \";\n    original.display();\n\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a function that accepts a list of integers and removes all even numbers. Describe the difference in behavior when using pass-by-value and pass-by-reference.",
    "code": "```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\n// Pass-by-value\nstd::vector<int> removeEvensByValue(std::vector<int> nums) {\n    nums.erase(std::remove_if(nums.begin(), nums.end(), [](int n){ return n % 2 == 0; }), nums.end());\n    return nums;\n}\n\n// Pass-by-reference\nvoid removeEvensByReference(std::vector<int>& nums) {\n    nums.erase(std::remove_if(nums.begin(), nums.end(), [](int n){ return n % 2 == 0; }), nums.end());\n}\n\nint main() {\n    std::vector<int> numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\n    // Using pass-by-value\n    std::vector<int> resultByValue = removeEvensByValue(numbers);\n    std::cout << \"After removeEvensByValue, original: \";\n    for (int n : numbers) std::cout << n << ' ';\n    std::cout << \"\\nResult: \";\n    for (int n : resultByValue) std::cout << n << ' ';\n    std::cout << '\\n';\n\n    // Using pass-by-reference\n    removeEvensByReference(numbers);\n    std::cout << \"After removeEvensByReference, original: \";\n    for (int n : numbers) std::cout << n << ' ';\n    std::cout << '\\n';\n\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a function that takes a complex number and returns its conjugate. Explain how pass-by-value affects the original complex number.",
    "code": "```cpp\n#include <iostream>\n\nclass Complex {\npublic:\n    double real;\n    double imag;\n\n    Complex(double r, double i) : real(r), imag(i) {}\n};\n\nComplex conjugate(Complex c) {\n    return Complex(c.real, -c.imag);\n}\n\nint main() {\n    Complex num(3.0, 4.0);\n    Complex conj = conjugate(num);\n\n    std::cout << \"Original: (\" << num.real << \", \" << num.imag << \"i)\" << std::endl;\n    std::cout << \"Conjugate: (\" << conj.real << \", \" << conj.imag << \"i)\" << std::endl;\n\n    return 0;\n}\n```"
  },
  {
    "task": "Design a program where a function receives a binary tree and inverts it. Discuss how pass-by-reference impacts the original tree structure.",
    "code": "```cpp\n#include <iostream>\n\n// Define a binary tree node\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n};\n\n// Function to invert a binary tree\nvoid invertTree(TreeNode*& root) {\n    if (root == nullptr) return;\n    // Swap the left and right children\n    std::swap(root->left, root->right);\n    // Recursively invert the subtrees\n    invertTree(root->left);\n    invertTree(root->right);\n}\n\n// Helper function to print the tree (in-order traversal)\nvoid printTree(TreeNode* root) {\n    if (root == nullptr) return;\n    printTree(root->left);\n    std::cout << root->val << \" \";\n    printTree(root->right);\n}\n\nint main() {\n    // Create a simple binary tree: 1 -> 2, 3\n    TreeNode* root = new TreeNode(1);\n    root->left = new TreeNode(2);\n    root->right = new TreeNode(3);\n\n    std::cout << \"Original tree (in-order): \";\n    printTree(root);\n    std::cout << std::endl;\n\n    // Invert the binary tree\n    invertTree(root);\n\n    std::cout << \"Inverted tree (in-order): \";\n    printTree(root);\n    std::cout << std::endl;\n\n    // Free allocated memory (not shown for brevity)\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that adds an element to a set passed to it. Show how pass-by-reference affects the original set.",
    "code": "```cpp\n#include <iostream>\n#include <set>\n\nvoid addElementToSet(std::set<int>& s, int element) {\n    s.insert(element);\n}\n\nint main() {\n    std::set<int> mySet = {1, 2, 3};\n    std::cout << \"Original set: \";\n    for (int elem : mySet) {\n        std::cout << elem << \" \";\n    }\n    std::cout << std::endl;\n\n    addElementToSet(mySet, 4);\n\n    std::cout << \"Set after adding an element: \";\n    for (int elem : mySet) {\n        std::cout << elem << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a function that accepts an integer array and sorts it. Demonstrate the difference when the array is passed by value.",
    "code": "```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\n// Function to sort array passed by value\nvoid sortByValue(std::vector<int> arr) {\n    std::sort(arr.begin(), arr.end());\n}\n\n// Function to sort array passed by reference\nvoid sortByReference(std::vector<int>& arr) {\n    std::sort(arr.begin(), arr.end());\n}\n\nvoid printArray(const std::vector<int>& arr) {\n    for (int num : arr) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n}\n\nint main() {\n    std::vector<int> arr = {5, 3, 8, 6, 2};\n\n    std::cout << \"Original array: \";\n    printArray(arr);\n\n    sortByValue(arr);\n    std::cout << \"After sortByValue (no change): \";\n    printArray(arr);\n\n    sortByReference(arr);\n    std::cout << \"After sortByReference: \";\n    printArray(arr);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a function that takes a configuration object and toggles a setting. Illustrate the changes with pass-by-reference.",
    "code": "```cpp\n#include <iostream>\n#include <string>\n\nclass Config {\npublic:\n    bool setting;\n    std::string name;\n\n    Config(bool s, const std::string& n) : setting(s), name(n) {}\n};\n\nvoid toggleSetting(Config& config) {\n    config.setting = !config.setting;\n}\n\nint main() {\n    Config config(false, \"ExampleSetting\");\n    std::cout << \"Before toggle: \" << config.setting << std::endl;\n    toggleSetting(config);\n    std::cout << \"After toggle: \" << config.setting << std::endl;\n    return 0;\n}\n```"
  },
  {
    "task": "Design a function that receives a file path and reads its content. Explain how passing the path by value affects the outcome.",
    "code": "```cpp\n#include <iostream>\n#include <fstream>\n#include <string>\n\nvoid readFileByValue(std::string filePath) {\n    std::ifstream file(filePath);\n    if (file.is_open()) {\n        std::string line;\n        while (std::getline(file, line)) {\n            std::cout << line << std::endl;\n        }\n        file.close();\n    } else {\n        std::cerr << \"Unable to open file\" << std::endl;\n    }\n}\n\nint main() {\n    std::string path = \"example.txt\";\n    readFileByValue(path);\n    return 0;\n}\n```"
  },
  {
    "task": "Write a program in which a function takes a stack and reverses its elements. Discuss the impact of pass-by-reference on the stack.",
    "code": "```cpp\n#include <iostream>\n#include <stack>\n\nvoid reverseStack(std::stack<int>& s) {\n    std::stack<int> tempStack;\n    while (!s.empty()) {\n        tempStack.push(s.top());\n        s.pop();\n    }\n    s = tempStack;\n}\n\nint main() {\n    std::stack<int> s;\n    s.push(1);\n    s.push(2);\n    s.push(3);\n    s.push(4);\n    s.push(5);\n    \n    reverseStack(s);\n    \n    while (!s.empty()) {\n        std::cout << s.top() << \" \";\n        s.pop();\n    }\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Create a function that takes a queue and dequeues an element. Show the result when the queue is passed by reference.",
    "code": "```cpp\n#include <iostream>\n#include <queue>\n\nvoid dequeueElement(std::queue<int>& q) {\n    if (!q.empty()) {\n        q.pop();\n    }\n}\n\nint main() {\n    std::queue<int> myQueue;\n    myQueue.push(1);\n    myQueue.push(2);\n    myQueue.push(3);\n\n    std::cout << \"Queue size before dequeue: \" << myQueue.size() << std::endl;\n    dequeueElement(myQueue);\n    std::cout << \"Queue size after dequeue: \" << myQueue.size() << std::endl;\n\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a function that accepts a hashmap and updates a value for a specific key. Illustrate the effects of pass-by-reference.",
    "code": "```cpp\n#include <iostream>\n#include <unordered_map>\n#include <string>\n\nvoid updateValue(std::unordered_map<std::string, int>& hashmap, const std::string& key, int newValue) {\n    if (hashmap.find(key) != hashmap.end()) {\n        hashmap[key] = newValue;\n    }\n}\n\nint main() {\n    std::unordered_map<std::string, int> myMap;\n    myMap[\"apple\"] = 1;\n    myMap[\"banana\"] = 2;\n\n    std::cout << \"Before update: \" << myMap[\"apple\"] << std::endl;\n\n    updateValue(myMap, \"apple\", 5);\n\n    std::cout << \"After update: \" << myMap[\"apple\"] << std::endl;\n\n    return 0;\n}\n```"
  },
  {
    "task": "Design a function that receives a JSON object and adds a new property. Discuss the implications of modifying the object by reference.",
    "code": "```cpp\n#include <iostream>\n#include <string>\n#include <nlohmann/json.hpp>\n\nusing json = nlohmann::json;\n\nvoid addPropertyByReference(json& jsonObject, const std::string& newKey, const std::string& newValue) {\n    jsonObject[newKey] = newValue;\n}\n\nint main() {\n    json obj = {{\"name\", \"John\"}, {\"age\", 30}};\n    addPropertyByReference(obj, \"city\", \"New York\");\n    std::cout << obj.dump(4) << std::endl;\n    return 0;\n}\n```"
  },
  {
    "task": "Write a program where a function accepts a graph and adds a node. Explain how pass-by-reference affects the original graph structure.",
    "code": "```cpp\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <string>\n\nusing Graph = std::unordered_map<std::string, std::vector<std::string>>;\n\nvoid addNode(Graph& graph, const std::string& newNode) {\n    if (graph.find(newNode) == graph.end()) {\n        graph[newNode] = {};\n    }\n}\n\nint main() {\n    Graph graph = {\n        {\"node1\", {\"node2\", \"node3\"}},\n        {\"node2\", {\"node1\"}},\n        {\"node3\", {\"node1\"}}\n    };\n\n    std::cout << \"Graph before adding node:\\n\";\n    for (const auto& node : graph) {\n        std::cout << node.first << \": \";\n        for (const auto& neighbor : node.second) {\n            std::cout << neighbor << \" \";\n        }\n        std::cout << \"\\n\";\n    }\n\n    addNode(graph, \"node4\");\n\n    std::cout << \"\\nGraph after adding node:\\n\";\n    for (const auto& node : graph) {\n        std::cout << node.first << \": \";\n        for (const auto& neighbor : node.second) {\n            std::cout << neighbor << \" \";\n        }\n        std::cout << \"\\n\";\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a function that accepts a set of coordinates and shifts them. Demonstrate how pass-by-value ensures the original set is unchanged.",
    "code": "```cpp\n#include <iostream>\n#include <vector>\n\nstruct Coordinate {\n    int x;\n    int y;\n};\n\nCoordinate shiftCoordinatesByValue(Coordinate coord, int dx, int dy) {\n    coord.x += dx;\n    coord.y += dy;\n    return coord;\n}\n\nint main() {\n    Coordinate original = {10, 20};\n    Coordinate shifted = shiftCoordinatesByValue(original, 5, 10);\n\n    std::cout << \"Original coordinates: (\" << original.x << \", \" << original.y << \")\\n\";\n    std::cout << \"Shifted coordinates: (\" << shifted.x << \", \" << shifted.y << \")\\n\";\n\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a function that takes a date object and sets it to the next day. Discuss the effects of pass-by-reference on the date object.",
    "code": "```cpp\n#include <iostream>\n\nstruct Date {\n    int day;\n    int month;\n    int year;\n};\n\nbool isLeapYear(int year) {\n    if (year % 4 != 0) return false;\n    if (year % 100 != 0) return true;\n    return year % 400 == 0;\n}\n\nint daysInMonth(int month, int year) {\n    switch (month) {\n        case 4: case 6: case 9: case 11: return 30;\n        case 2: return isLeapYear(year) ? 29 : 28;\n        default: return 31;\n    }\n}\n\nvoid setToNextDay(Date &date) {\n    int daysInCurrentMonth = daysInMonth(date.month, date.year);\n    if (date.day < daysInCurrentMonth) {\n        date.day++;\n    } else {\n        date.day = 1;\n        if (date.month == 12) {\n            date.month = 1;\n            date.year++;\n        } else {\n            date.month++;\n        }\n    }\n}\n\nint main() {\n    Date today = {31, 12, 2023};\n    setToNextDay(today);\n    std::cout << today.day << \"/\" << today.month << \"/\" << today.year << std::endl;\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a function that receives a polynomial represented as a list of coefficients and differentiates it. Show how the original list remains unchanged with pass-by-value.",
    "code": "```cpp\n#include <iostream>\n#include <vector>\n\nstd::vector<int> differentiate(const std::vector<int>& poly) {\n    std::vector<int> derivative;\n    for (size_t i = 1; i < poly.size(); ++i) {\n        derivative.push_back(poly[i] * static_cast<int>(i));\n    }\n    return derivative;\n}\n\nint main() {\n    std::vector<int> polynomial = {3, 4, 5}; // Represents 3 + 4x + 5x^2\n    std::vector<int> derivative = differentiate(polynomial);\n\n    std::cout << \"Original polynomial coefficients: \";\n    for (int coeff : polynomial) {\n        std::cout << coeff << \" \";\n    }\n    std::cout << \"\\n\";\n\n    std::cout << \"Derivative coefficients: \";\n    for (int coeff : derivative) {\n        std::cout << coeff << \" \";\n    }\n    std::cout << \"\\n\";\n\n    return 0;\n}\n```"
  },
  {
    "task": "Design a function that accepts a stack and clears it. Explain how pass-by-reference affects the original stack.",
    "code": "```cpp\n#include <stack>\n\nvoid clearStack(std::stack<int>& s) {\n    while (!s.empty()) {\n        s.pop();\n    }\n}\n\nint main() {\n    std::stack<int> myStack;\n    myStack.push(1);\n    myStack.push(2);\n    myStack.push(3);\n\n    clearStack(myStack);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that takes a linked list and appends a new node. Demonstrate the impact of pass-by-reference on the list.",
    "code": "```cpp\n#include <iostream>\n\nstruct Node {\n    int data;\n    Node* next;\n    Node(int val) : data(val), next(nullptr) {}\n};\n\nvoid appendNode(Node*& head, int newData) {\n    Node* newNode = new Node(newData);\n    if (!head) {\n        head = newNode;\n        return;\n    }\n    Node* temp = head;\n    while (temp->next) {\n        temp = temp->next;\n    }\n    temp->next = newNode;\n}\n\nvoid printList(Node* head) {\n    Node* current = head;\n    while (current) {\n        std::cout << current->data << \" \";\n        current = current->next;\n    }\n    std::cout << std::endl;\n}\n\nint main() {\n    Node* head = nullptr;\n    appendNode(head, 1);\n    appendNode(head, 2);\n    appendNode(head, 3);\n    printList(head);\n    return 0;\n}\n```"
  },
  {
    "task": "Create a function that receives a URL and extracts the domain name. Discuss the effects of pass-by-value on the URL string.",
    "code": "```cpp\n#include <iostream>\n#include <string>\n\nstd::string extractDomain(std::string url) {\n    size_t start = url.find(\"://\");\n    if (start != std::string::npos) {\n        start += 3;\n    } else {\n        start = 0;\n    }\n    \n    size_t end = url.find('/', start);\n    if (end == std::string::npos) {\n        end = url.length();\n    }\n    \n    return url.substr(start, end - start);\n}\n\nint main() {\n    std::string url = \"http://www.example.com/path\";\n    std::string domain = extractDomain(url);\n    std::cout << \"Domain: \" << domain << std::endl;\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a function that takes a priority queue and changes the priority of an element. Illustrate the effects using pass-by-reference.",
    "code": "```cpp\n#include <queue>\n#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nvoid changePriority(priority_queue<int>& pq, int oldPriority, int newPriority) {\n    vector<int> temp;\n    bool found = false;\n\n    // Transfer elements to a temporary vector\n    while (!pq.empty()) {\n        if (!found && pq.top() == oldPriority) {\n            temp.push_back(newPriority);\n            found = true;\n        } else {\n            temp.push_back(pq.top());\n        }\n        pq.pop();\n    }\n\n    // Rebuild the priority queue with updated priorities\n    for (int val : temp) {\n        pq.push(val);\n    }\n}\n\nint main() {\n    priority_queue<int> pq;\n    pq.push(10);\n    pq.push(20);\n    pq.push(15);\n\n    cout << \"Original priority queue: \";\n    priority_queue<int> copy = pq; // make a copy to display\n    while (!copy.empty()) {\n        cout << copy.top() << \" \";\n        copy.pop();\n    }\n    cout << endl;\n\n    changePriority(pq, 15, 25);\n\n    cout << \"Modified priority queue: \";\n    while (!pq.empty()) {\n        cout << pq.top() << \" \";\n        pq.pop();\n    }\n    cout << endl;\n\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a function that accepts a circular buffer and reads an element. Explain how pass-by-reference influences the buffer.",
    "code": "```cpp\n#include <iostream>\n#include <vector>\n\nclass CircularBuffer {\nprivate:\n    std::vector<int> buffer;\n    int head;\n    int tail;\n    int maxSize;\n    int currentSize;\n\npublic:\n    CircularBuffer(int size) : buffer(size), head(0), tail(0), maxSize(size), currentSize(0) {}\n\n    bool isEmpty() const {\n        return currentSize == 0;\n    }\n\n    bool isFull() const {\n        return currentSize == maxSize;\n    }\n\n    void add(int value) {\n        if (isFull()) {\n            head = (head + 1) % maxSize;\n        } else {\n            currentSize++;\n        }\n        buffer[tail] = value;\n        tail = (tail + 1) % maxSize;\n    }\n\n    int read() {\n        if (isEmpty()) {\n            throw std::runtime_error(\"Buffer is empty\");\n        }\n        int value = buffer[head];\n        head = (head + 1) % maxSize;\n        currentSize--;\n        return value;\n    }\n};\n\nvoid readElement(CircularBuffer& cb) {\n    try {\n        int element = cb.read();\n        std::cout << \"Read element: \" << element << std::endl;\n    } catch (std::runtime_error& e) {\n        std::cout << e.what() << std::endl;\n    }\n}\n\nint main() {\n    CircularBuffer cb(3);\n    cb.add(1);\n    cb.add(2);\n    cb.add(3);\n    \n    readElement(cb);\n    readElement(cb);\n    readElement(cb);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Design a program where a function receives a record and updates a field. Show how pass-by-reference affects the original record.",
    "code": "```cpp\n#include <iostream>\n#include <string>\n\nstruct Record {\n    std::string name;\n    int age;\n};\n\nvoid updateRecord(Record &rec, const std::string &newName) {\n    rec.name = newName;\n}\n\nint main() {\n    Record myRecord = {\"Alice\", 30};\n    \n    std::cout << \"Before update: \" << myRecord.name << \", \" << myRecord.age << std::endl;\n    \n    updateRecord(myRecord, \"Bob\");\n    \n    std::cout << \"After update: \" << myRecord.name << \", \" << myRecord.age << std::endl;\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that takes a frequency list and normalizes it. Describe how pass-by-value ensures the original list remains unchanged.",
    "code": "```cpp\n#include <iostream>\n#include <vector>\n#include <numeric>\n\nstd::vector<double> normalizeFrequencyList(std::vector<int> frequencies) {\n    // Calculate the sum of all frequencies\n    int total = std::accumulate(frequencies.begin(), frequencies.end(), 0);\n    \n    // Normalize the frequencies\n    std::vector<double> normalizedFrequencies;\n    for (int frequency : frequencies) {\n        normalizedFrequencies.push_back(static_cast<double>(frequency) / total);\n    }\n    \n    return normalizedFrequencies;\n}\n\nint main() {\n    std::vector<int> frequencies = {10, 20, 30, 40};\n    std::vector<double> normalized = normalizeFrequencyList(frequencies);\n    \n    // Output the normalized frequencies\n    for (double value : normalized) {\n        std::cout << value << \" \";\n    }\n    std::cout << std::endl;\n    \n    // Output the original frequencies to show it remains unchanged\n    for (int frequency : frequencies) {\n        std::cout << frequency << \" \";\n    }\n    std::cout << std::endl;\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Create a function that accepts a chessboard and makes a move. Discuss how pass-by-reference alters the original board setup.",
    "code": "```cpp\n#include <iostream>\n#include <vector>\n\nusing Chessboard = std::vector<std::vector<char>>;\n\nvoid makeMove(Chessboard& board, int startX, int startY, int endX, int endY) {\n    char piece = board[startX][startY];\n    board[startX][startY] = '.';\n    board[endX][endY] = piece;\n}\n\nvoid printBoard(const Chessboard& board) {\n    for (const auto& row : board) {\n        for (char cell : row) {\n            std::cout << cell << ' ';\n        }\n        std::cout << '\\n';\n    }\n}\n\nint main() {\n    Chessboard board = {\n        {'r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'},\n        {'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'},\n        {'.', '.', '.', '.', '.', '.', '.', '.'},\n        {'.', '.', '.', '.', '.', '.', '.', '.'},\n        {'.', '.', '.', '.', '.', '.', '.', '.'},\n        {'.', '.', '.', '.', '.', '.', '.', '.'},\n        {'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'},\n        {'R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R'}\n    };\n\n    std::cout << \"Original Board:\\n\";\n    printBoard(board);\n\n    makeMove(board, 6, 4, 4, 4); // Move pawn from e2 to e4\n\n    std::cout << \"\\nBoard after move:\\n\";\n    printBoard(board);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a function that takes a decimal number and converts it to binary. Explain the effects of pass-by-value on the original number.",
    "code": "```cpp\n#include <iostream>\n#include <string>\n\nstd::string decimalToBinary(int decimalNumber) {\n    if (decimalNumber == 0) return \"0\";\n    \n    std::string binaryNumber = \"\";\n    while (decimalNumber > 0) {\n        binaryNumber = std::to_string(decimalNumber % 2) + binaryNumber;\n        decimalNumber = decimalNumber / 2;\n    }\n    return binaryNumber;\n}\n\nint main() {\n    int originalNumber = 10;\n    std::string binary = decimalToBinary(originalNumber);\n    std::cout << \"Binary representation: \" << binary << std::endl;\n    std::cout << \"Original number after function call: \" << originalNumber << std::endl;\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a function that receives a DNA sequence and counts nucleotides. Illustrate how pass-by-value ensures the original sequence remains intact.",
    "code": "```cpp\n#include <iostream>\n#include <map>\n#include <string>\n\nstd::map<char, int> countNucleotides(std::string dnaSequence) {\n    std::map<char, int> nucleotideCount;\n    for (char nucleotide : dnaSequence) {\n        nucleotideCount[nucleotide]++;\n    }\n    return nucleotideCount;\n}\n\nint main() {\n    std::string dnaSequence = \"AGCTTAGC\";\n    std::map<char, int> counts = countNucleotides(dnaSequence);\n\n    std::cout << \"Nucleotide counts:\\n\";\n    for (const auto &pair : counts) {\n        std::cout << pair.first << \": \" << pair.second << \"\\n\";\n    }\n\n    std::cout << \"Original DNA sequence: \" << dnaSequence << \"\\n\";\n    return 0;\n}\n```"
  },
  {
    "task": "Design a function that accepts a shopping cart object and applies a discount. Show the changes with pass-by-reference.",
    "code": "```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n\nstruct Item {\n    std::string name;\n    double price;\n};\n\nstruct ShoppingCart {\n    std::vector<Item> items;\n};\n\nvoid applyDiscount(ShoppingCart& cart, double discount) {\n    for (auto& item : cart.items) {\n        item.price *= (1 - discount);\n    }\n}\n\nint main() {\n    ShoppingCart cart = {{{\"Apple\", 1.0}, {\"Banana\", 0.5}, {\"Milk\", 2.5}}};\n    double discount = 0.1; // 10% discount\n\n    applyDiscount(cart, discount);\n\n    for (const auto& item : cart.items) {\n        std::cout << item.name << \": $\" << item.price << std::endl;\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a program where a function receives a playlist and adds a song. Discuss how pass-by-reference affects the original playlist.",
    "code": "```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n\n// Function to add a song to the playlist\nvoid addSong(std::vector<std::string>& playlist, const std::string& song) {\n    playlist.push_back(song);\n}\n\nint main() {\n    std::vector<std::string> playlist = {\"Song1\", \"Song2\", \"Song3\"};\n    \n    std::cout << \"Original Playlist:\" << std::endl;\n    for (const auto& song : playlist) {\n        std::cout << song << std::endl;\n    }\n\n    // Add a new song to the playlist\n    addSong(playlist, \"NewSong\");\n\n    std::cout << \"\\nUpdated Playlist:\" << std::endl;\n    for (const auto& song : playlist) {\n        std::cout << song << std::endl;\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a function that takes a sprite in a game and moves it. Demonstrate the result when the sprite is passed by reference.",
    "code": "```cpp\n#include <iostream>\n\nstruct Sprite {\n    int x;\n    int y;\n};\n\nvoid moveSprite(Sprite& sprite, int dx, int dy) {\n    sprite.x += dx;\n    sprite.y += dy;\n}\n\nint main() {\n    Sprite mySprite = {10, 20};\n    std::cout << \"Original position: (\" << mySprite.x << \", \" << mySprite.y << \")\" << std::endl;\n    \n    moveSprite(mySprite, 5, -3);\n    std::cout << \"New position: (\" << mySprite.x << \", \" << mySprite.y << \")\" << std::endl;\n\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a function that accepts a book object and updates the title. Illustrate the impact of pass-by-reference on the original object.",
    "code": "```cpp\n#include <iostream>\n#include <string>\n\nclass Book {\npublic:\n    std::string title;\n\n    Book(const std::string& title) : title(title) {}\n};\n\nvoid updateTitle(Book& book, const std::string& newTitle) {\n    book.title = newTitle;\n}\n\nint main() {\n    Book myBook(\"Original Title\");\n    \n    std::cout << \"Before update: \" << myBook.title << std::endl;\n    updateTitle(myBook, \"Updated Title\");\n    std::cout << \"After update: \" << myBook.title << std::endl;\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Develop a function that receives a sound wave and normalizes it. Explain how pass-by-value affects the original sound wave.",
    "code": "```cpp\n#include <vector>\n#include <algorithm>\n#include <iostream>\n\nstd::vector<double> normalizeSoundWave(std::vector<double> soundWave) {\n    double maxAmplitude = *std::max_element(soundWave.begin(), soundWave.end());\n    if (maxAmplitude == 0) return soundWave;\n    \n    for (auto& sample : soundWave) {\n        sample /= maxAmplitude;\n    }\n    \n    return soundWave;\n}\n\nint main() {\n    std::vector<double> originalWave = {0.2, -0.3, 0.5, -0.1, 0.4};\n    std::vector<double> normalizedWave = normalizeSoundWave(originalWave);\n\n    std::cout << \"Original Wave: \";\n    for (double sample : originalWave) {\n        std::cout << sample << \" \";\n    }\n    std::cout << \"\\nNormalized Wave: \";\n    for (double sample : normalizedWave) {\n        std::cout << sample << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n```"
  },
  {
    "task": "Design a program where a function receives a bank account object and credits an amount. Discuss the effects of pass-by-reference.",
    "code": "```cpp\n#include <iostream>\n\nclass BankAccount {\npublic:\n    double balance;\n    BankAccount(double initial_balance) : balance(initial_balance) {}\n};\n\nvoid creditAmount(BankAccount& account, double amount) {\n    account.balance += amount;\n}\n\nint main() {\n    BankAccount myAccount(100.0);\n    std::cout << \"Initial balance: \" << myAccount.balance << std::endl;\n\n    creditAmount(myAccount, 50.0);\n    std::cout << \"Balance after credit: \" << myAccount.balance << std::endl;\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that takes an email list and filters out invalid addresses. Show the difference in the list when using pass-by-value.",
    "code": "```cpp\n#include <iostream>\n#include <vector>\n#include <regex>\n\nstd::vector<std::string> filterInvalidEmails(std::vector<std::string> emailList) {\n    std::regex emailPattern(R\"((\\w+)(\\.\\w+)*@(\\w+)(\\.\\w+)+)\");\n    std::vector<std::string> validEmails;\n\n    for (const auto& email : emailList) {\n        if (std::regex_match(email, emailPattern)) {\n            validEmails.push_back(email);\n        }\n    }\n\n    emailList = validEmails; // Shows difference in the list when using pass-by-value\n    return validEmails;\n}\n\nint main() {\n    std::vector<std::string> emails = {\n        \"valid.email@example.com\",\n        \"invalid-email\",\n        \"another.valid@example.co.uk\",\n        \"@missingusername.com\"\n    };\n\n    std::vector<std::string> filteredEmails = filterInvalidEmails(emails);\n\n    std::cout << \"Original list: \" << std::endl;\n    for (const auto& email : emails) {\n        std::cout << email << std::endl;\n    }\n\n    std::cout << \"\\nFiltered list: \" << std::endl;\n    for (const auto& email : filteredEmails) {\n        std::cout << email << std::endl;\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a function that accepts a 3D model and scales it. Demonstrate how pass-by-reference affects the original model.",
    "code": "```cpp\n#include <iostream>\n#include <vector>\n\nstruct Vertex {\n    float x, y, z;\n};\n\nstruct Model {\n    std::vector<Vertex> vertices;\n};\n\nvoid scaleModel(Model& model, float scaleFactor) {\n    for (auto& vertex : model.vertices) {\n        vertex.x *= scaleFactor;\n        vertex.y *= scaleFactor;\n        vertex.z *= scaleFactor;\n    }\n}\n\nvoid printModel(const Model& model) {\n    for (const auto& vertex : model.vertices) {\n        std::cout << \"Vertex: (\" << vertex.x << \", \" << vertex.y << \", \" << vertex.z << \")\\n\";\n    }\n}\n\nint main() {\n    Model myModel = {{{1.0f, 2.0f, 3.0f}, {4.0f, 5.0f, 6.0f}, {7.0f, 8.0f, 9.0f}}};\n    \n    std::cout << \"Original Model:\\n\";\n    printModel(myModel);\n    \n    scaleModel(myModel, 2.0f);\n    \n    std::cout << \"\\nScaled Model:\\n\";\n    printModel(myModel);\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Implement a function that receives a text document and redacts sensitive information. Explain the impact of pass-by-reference.",
    "code": "```cpp\n#include <iostream>\n#include <string>\n\nvoid redactSensitiveInfo(std::string& document) {\n    std::string sensitiveWord = \"SECRET\";\n    size_t pos = document.find(sensitiveWord);\n    while (pos != std::string::npos) {\n        document.replace(pos, sensitiveWord.length(), \"REDACTED\");\n        pos = document.find(sensitiveWord, pos + 1);\n    }\n}\n\nint main() {\n    std::string document = \"This is a SECRET document. Do not disclose the SECRET information.\";\n    redactSensitiveInfo(document);\n    std::cout << document << std::endl;\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a function that takes a temperature reading and adjusts for calibration. Discuss how pass-by-value ensures the original reading is unchanged.",
    "code": "```cpp\n#include <iostream>\n\ndouble adjustForCalibration(double temperatureReading, double calibrationOffset) {\n    return temperatureReading + calibrationOffset;\n}\n\nint main() {\n    double originalReading = 25.0;\n    double calibrationOffset = 1.5;\n\n    double adjustedReading = adjustForCalibration(originalReading, calibrationOffset);\n\n    std::cout << \"Original Reading: \" << originalReading << std::endl;\n    std::cout << \"Adjusted Reading: \" << adjustedReading << std::endl;\n\n    return 0;\n}\n```"
  },
  {
    "task": "Design a function that accepts a bug report and updates its status. Show the changes with pass-by-reference.",
    "code": "```cpp\n#include <iostream>\n#include <string>\n\nstruct BugReport {\n    std::string description;\n    std::string status;\n};\n\nvoid updateBugStatus(BugReport &report, const std::string &newStatus) {\n    report.status = newStatus;\n}\n\nint main() {\n    BugReport report = {\"Critical bug in authentication module\", \"Open\"};\n    \n    std::cout << \"Before update: \" << report.status << std::endl;\n    \n    updateBugStatus(report, \"Resolved\");\n    \n    std::cout << \"After update: \" << report.status << std::endl;\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Write a program where a function receives a sensor array and calibrates it. Demonstrate the effect of pass-by-reference on the array.",
    "code": "```cpp\n#include <iostream>\n#include <vector>\n\n// Function to calibrate the sensor array\nvoid calibrateSensorArray(std::vector<int> &sensorArray) {\n    for (auto &sensor : sensorArray) {\n        sensor += 10; // Example calibration increment\n    }\n}\n\nint main() {\n    std::vector<int> sensorArray = {100, 150, 200, 250};\n\n    std::cout << \"Sensor array before calibration: \";\n    for (const auto &sensor : sensorArray) {\n        std::cout << sensor << \" \";\n    }\n    std::cout << std::endl;\n\n    // Calibrate the sensor array\n    calibrateSensorArray(sensorArray);\n\n    std::cout << \"Sensor array after calibration: \";\n    for (const auto &sensor : sensorArray) {\n        std::cout << sensor << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a function that takes a vector and rotates it. Explain how pass-by-value ensures the original vector remains unchanged.",
    "code": "```cpp\n#include <iostream>\n#include <vector>\n\nstd::vector<int> rotateVector(std::vector<int> vec) {\n    if (!vec.empty()) {\n        int firstElement = vec.front();\n        vec.erase(vec.begin());\n        vec.push_back(firstElement);\n    }\n    return vec;\n}\n\nint main() {\n    std::vector<int> originalVector = {1, 2, 3, 4, 5};\n    std::vector<int> rotatedVector = rotateVector(originalVector);\n\n    std::cout << \"Original Vector: \";\n    for (int num : originalVector) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    std::cout << \"Rotated Vector: \";\n    for (int num : rotatedVector) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a function that accepts an operation log and compresses it. Discuss the impact of pass-by-reference on the log.",
    "code": "```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n\nvoid compressLog(std::vector<std::string>& log) {\n    std::unordered_map<std::string, int> operationCount;\n    for (const auto& op : log) {\n        operationCount[op]++;\n    }\n    log.clear();\n    for (const auto& entry : operationCount) {\n        log.push_back(entry.first + \": \" + std::to_string(entry.second));\n    }\n}\n\nint main() {\n    std::vector<std::string> operationLog = {\"op1\", \"op2\", \"op1\", \"op3\", \"op2\", \"op1\"};\n    compressLog(operationLog);\n    for (const auto& entry : operationLog) {\n        std::cout << entry << std::endl;\n    }\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a function that receives a neural network model and updates its weights. Illustrate the effects of pass-by-reference.",
    "code": "```cpp\n#include <iostream>\n#include <vector>\n\nclass NeuralNetwork {\npublic:\n    std::vector<double> weights;\n    \n    NeuralNetwork(const std::vector<double>& initial_weights) : weights(initial_weights) {}\n\n    void displayWeights() const {\n        for (const auto& weight : weights) {\n            std::cout << weight << \" \";\n        }\n        std::cout << std::endl;\n    }\n};\n\nvoid updateWeights(NeuralNetwork& model) {\n    for (auto& weight : model.weights) {\n        weight += 0.1;  // Example update\n    }\n}\n\nint main() {\n    std::vector<double> initial_weights = {0.5, 0.3, 0.2};\n    NeuralNetwork model(initial_weights);\n    \n    std::cout << \"Original weights: \";\n    model.displayWeights();\n\n    updateWeights(model);\n\n    std::cout << \"Updated weights: \";\n    model.displayWeights();\n\n    return 0;\n}\n```"
  },
  {
    "task": "Design a function that accepts a command history and reverts the last command. Show the changes with pass-by-reference.",
    "code": "```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n\nvoid revertLastCommand(std::vector<std::string>& commandHistory) {\n    if (!commandHistory.empty()) {\n        commandHistory.pop_back();\n    }\n}\n\nint main() {\n    std::vector<std::string> commandHistory = {\"open\", \"save\", \"close\"};\n    \n    std::cout << \"Original Command History:\" << std::endl;\n    for (const auto& command : commandHistory) {\n        std::cout << command << std::endl;\n    }\n    \n    revertLastCommand(commandHistory);\n    \n    std::cout << \"\\nCommand History after reverting last command:\" << std::endl;\n    for (const auto& command : commandHistory) {\n        std::cout << command << std::endl;\n    }\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that takes a user profile and anonymizes it. Discuss how pass-by-reference affects the original profile.",
    "code": "```cpp\n#include <iostream>\n#include <string>\n\nstruct UserProfile {\n    std::string name;\n    std::string email;\n};\n\nvoid anonymizeUserProfile(UserProfile &profile) {\n    profile.name = \"Anonymous\";\n    profile.email = \"anonymous@example.com\";\n}\n\nint main() {\n    UserProfile user = {\"John Doe\", \"john.doe@example.com\"};\n    anonymizeUserProfile(user);\n\n    std::cout << \"Name: \" << user.name << \"\\n\";\n    std::cout << \"Email: \" << user.email << \"\\n\";\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a function that accepts a polynomial and evaluates it at a given point. Explain how pass-by-value ensures the polynomial remains unchanged.",
    "code": "```cpp\n#include <iostream>\n#include <vector>\n\ndouble evaluatePolynomial(const std::vector<double>& coefficients, double x) {\n    double result = 0.0;\n    double power = 1.0;\n    for (double coefficient : coefficients) {\n        result += coefficient * power;\n        power *= x;\n    }\n    return result;\n}\n\nint main() {\n    std::vector<double> polynomial = {1.0, -3.0, 2.0}; // Represents 1 - 3x + 2x^2\n    double x = 5.0;\n    double result = evaluatePolynomial(polynomial, x);\n    std::cout << \"The polynomial evaluated at x = \" << x << \" is \" << result << std::endl;\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a function that receives a video stream and applies a filter. Demonstrate the effects of pass-by-reference on the stream.",
    "code": "```cpp\n#include <iostream>\n#include <string>\n\n// Simulated video stream class\nclass VideoStream {\npublic:\n    std::string content;\n    \n    VideoStream(const std::string& data) : content(data) {}\n    \n    void display() const {\n        std::cout << \"VideoStream Content: \" << content << std::endl;\n    }\n};\n\n// Filter function that modifies the stream by reference\nvoid applyFilter(VideoStream& stream) {\n    stream.content += \" [Filtered]\";\n}\n\nint main() {\n    // Create a video stream object\n    VideoStream stream(\"Original Video Data\");\n    \n    // Display original stream content\n    std::cout << \"Before applying filter:\" << std::endl;\n    stream.display();\n    \n    // Apply filter to the stream\n    applyFilter(stream);\n    \n    // Display modified stream content\n    std::cout << \"After applying filter:\" << std::endl;\n    stream.display();\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Develop a function that takes a task queue and reorders tasks based on priority. Illustrate the impact of pass-by-reference.",
    "code": "```cpp\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <algorithm>\n\nstruct Task {\n    int priority;\n    std::string description;\n\n    bool operator<(const Task &other) const {\n        return priority < other.priority;\n    }\n};\n\nvoid reorderTasks(std::priority_queue<Task> &taskQueue) {\n    std::vector<Task> tasks;\n    \n    while (!taskQueue.empty()) {\n        tasks.push_back(taskQueue.top());\n        taskQueue.pop();\n    }\n    \n    std::sort(tasks.begin(), tasks.end(), std::greater<Task>());\n    \n    for (const auto &task : tasks) {\n        taskQueue.push(task);\n    }\n}\n\nvoid printTasks(std::priority_queue<Task> taskQueue) {\n    while (!taskQueue.empty()) {\n        Task task = taskQueue.top();\n        std::cout << \"Priority: \" << task.priority << \", Description: \" << task.description << std::endl;\n        taskQueue.pop();\n    }\n}\n\nint main() {\n    std::priority_queue<Task> taskQueue;\n    \n    taskQueue.push({2, \"Write report\"});\n    taskQueue.push({5, \"Fix bug\"});\n    taskQueue.push({3, \"Develop feature\"});\n    taskQueue.push({1, \"Attend meeting\"});\n    \n    std::cout << \"Tasks before reordering:\\n\";\n    printTasks(taskQueue);\n\n    reorderTasks(taskQueue);\n\n    std::cout << \"\\nTasks after reordering:\\n\";\n    printTasks(taskQueue);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Design a program where a function receives a blockchain and verifies a transaction. Discuss how pass-by-reference affects the blockchain.",
    "code": "```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n\nstruct Transaction {\n    std::string sender;\n    std::string receiver;\n    double amount;\n    std::string signature;\n};\n\ntypedef std::vector<Transaction> Blockchain;\n\nbool verifyTransaction(const Transaction &tx) {\n    // Simulated verification logic\n    return !tx.signature.empty() && tx.amount > 0;\n}\n\nvoid verifyTransactionInBlockchain(Blockchain &blockchain, const Transaction &tx) {\n    if (verifyTransaction(tx)) {\n        blockchain.push_back(tx);\n        std::cout << \"Transaction verified and added to blockchain.\\n\";\n    } else {\n        std::cout << \"Transaction verification failed.\\n\";\n    }\n}\n\nint main() {\n    Blockchain blockchain;\n    Transaction tx1 = {\"Alice\", \"Bob\", 50.0, \"signature1\"};\n    Transaction tx2 = {\"Charlie\", \"Dave\", 0.0, \"signature2\"};\n    \n    verifyTransactionInBlockchain(blockchain, tx1);\n    verifyTransactionInBlockchain(blockchain, tx2);\n    \n    std::cout << \"Blockchain size: \" << blockchain.size() << std::endl;\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that takes a game leaderboard and updates scores. Show the changes with pass-by-reference.",
    "code": "```cpp\n#include <iostream>\n#include <unordered_map>\n#include <string>\n\n// Function to update scores on the leaderboard\nvoid updateScores(std::unordered_map<std::string, int>& leaderboard, const std::string& player, int score) {\n    leaderboard[player] += score;\n}\n\nint main() {\n    std::unordered_map<std::string, int> leaderboard = {{\"Alice\", 50}, {\"Bob\", 30}, {\"Charlie\", 20}};\n\n    std::cout << \"Leaderboard before update:\" << std::endl;\n    for (const auto& entry : leaderboard) {\n        std::cout << entry.first << \": \" << entry.second << std::endl;\n    }\n\n    // Update the scores\n    updateScores(leaderboard, \"Alice\", 10);\n    updateScores(leaderboard, \"Bob\", -5);\n    updateScores(leaderboard, \"Charlie\", 15);\n\n    std::cout << \"\\nLeaderboard after update:\" << std::endl;\n    for (const auto& entry : leaderboard) {\n        std::cout << entry.first << \": \" << entry.second << std::endl;\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a function that accepts a project timeline and adjusts for delays. Explain how pass-by-reference influences the timeline.",
    "code": "```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n\n// Function to adjust project timeline for delays\nvoid adjustTimeline(std::vector<std::string>& timeline, int delayDays) {\n    for (auto& milestone : timeline) {\n        milestone += \" + \" + std::to_string(delayDays) + \" days delay\";\n    }\n}\n\nint main() {\n    std::vector<std::string> projectTimeline = {\n        \"Design Phase\",\n        \"Development Phase\",\n        \"Testing Phase\",\n        \"Deployment Phase\"\n    };\n\n    int delay = 5; // Example delay in days\n\n    std::cout << \"Original Timeline:\\n\";\n    for (const auto& milestone : projectTimeline) {\n        std::cout << milestone << std::endl;\n    }\n\n    adjustTimeline(projectTimeline, delay);\n\n    std::cout << \"\\nAdjusted Timeline:\\n\";\n    for (const auto& milestone : projectTimeline) {\n        std::cout << milestone << std::endl;\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a function that receives a to-do list and completes a task. Demonstrate the effect of pass-by-reference on the list.",
    "code": "```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n\n// Function to complete a task by index\nvoid completeTask(std::vector<std::string>& todoList, int taskIndex) {\n    if (taskIndex >= 0 && taskIndex < todoList.size()) {\n        todoList.erase(todoList.begin() + taskIndex);\n    }\n}\n\nint main() {\n    std::vector<std::string> todoList = {\"Task 1\", \"Task 2\", \"Task 3\", \"Task 4\"};\n\n    std::cout << \"Original To-Do List:\" << std::endl;\n    for (const auto& task : todoList) {\n        std::cout << task << std::endl;\n    }\n\n    // Complete the second task (index 1)\n    completeTask(todoList, 1);\n\n    std::cout << \"\\nUpdated To-Do List after completing a task:\" << std::endl;\n    for (const auto& task : todoList) {\n        std::cout << task << std::endl;\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a function that takes a paint canvas and adds a layer. Discuss the impact of pass-by-reference on the canvas.",
    "code": "```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n\nclass Canvas {\npublic:\n    std::vector<std::string> layers;\n\n    void display() const {\n        for (const auto& layer : layers) {\n            std::cout << layer << std::endl;\n        }\n    }\n};\n\nvoid addLayer(Canvas& canvas, const std::string& newLayer) {\n    canvas.layers.push_back(newLayer);\n}\n\nint main() {\n    Canvas myCanvas;\n    myCanvas.layers.push_back(\"Background\");\n\n    std::cout << \"Before adding new layer:\" << std::endl;\n    myCanvas.display();\n\n    addLayer(myCanvas, \"Foreground\");\n\n    std::cout << \"After adding new layer:\" << std::endl;\n    myCanvas.display();\n\n    return 0;\n}\n```"
  },
  {
    "task": "Design a function that accepts a URL list and fetches content. Show the difference in the list when using pass-by-value.",
    "code": "```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n\nvoid fetchContentByValue(std::vector<std::string> urls) {\n    // Simulate fetching content by appending \"_fetched\" to each URL\n    for (auto& url : urls) {\n        url += \"_fetched\";\n    }\n}\n\nint main() {\n    std::vector<std::string> urlList = {\"http://example.com\", \"http://test.com\", \"http://sample.com\"};\n    \n    // Before fetching content\n    std::cout << \"Before fetchContentByValue:\" << std::endl;\n    for (const auto& url : urlList) {\n        std::cout << url << std::endl;\n    }\n    \n    // Call function with pass-by-value\n    fetchContentByValue(urlList);\n    \n    // After fetching content\n    std::cout << \"\\nAfter fetchContentByValue:\" << std::endl;\n    for (const auto& url : urlList) {\n        std::cout << url << std::endl;\n    }\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Write a program where a function receives a game board and resets it. Illustrate the effects of pass-by-reference.",
    "code": "```cpp\n#include <iostream>\n#include <vector>\n\nvoid resetBoard(std::vector<std::vector<char>> &board) {\n    for (auto &row : board) {\n        for (auto &tile : row) {\n            tile = '-';\n        }\n    }\n}\n\nvoid printBoard(const std::vector<std::vector<char>> &board) {\n    for (const auto &row : board) {\n        for (const auto &tile : row) {\n            std::cout << tile << ' ';\n        }\n        std::cout << '\\n';\n    }\n}\n\nint main() {\n    std::vector<std::vector<char>> gameBoard = {\n        {'X', 'O', 'X'},\n        {'O', 'X', 'O'},\n        {'X', 'O', 'X'}\n    };\n\n    std::cout << \"Original Board:\\n\";\n    printBoard(gameBoard);\n\n    resetBoard(gameBoard);\n\n    std::cout << \"\\nReset Board:\\n\";\n    printBoard(gameBoard);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a function that takes a sound effect and increases its volume. Explain how pass-by-reference affects the original sound.",
    "code": "```cpp\n#include <iostream>\n\nvoid increaseVolume(int& soundEffect) {\n    soundEffect += 10; // Increase the volume by 10 units\n}\n\nint main() {\n    int originalSoundEffect = 50;\n    std::cout << \"Original sound volume: \" << originalSoundEffect << std::endl;\n\n    increaseVolume(originalSoundEffect);\n\n    std::cout << \"Increased sound volume: \" << originalSoundEffect << std::endl;\n\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a function that accepts a weather forecast and updates temperature predictions. Discuss the impact of pass-by-reference.",
    "code": "```cpp\n#include <iostream>\n#include <vector>\n\nvoid updateTemperaturePredictions(std::vector<double>& forecast) {\n    for (auto& temperature : forecast) {\n        temperature += 1.0; // Simulate some update to the forecast\n    }\n}\n\nint main() {\n    std::vector<double> weatherForecast = {22.5, 23.0, 24.5, 25.0};\n    \n    std::cout << \"Original Forecast: \";\n    for (const auto& temp : weatherForecast) {\n        std::cout << temp << \" \";\n    }\n    std::cout << std::endl;\n\n    updateTemperaturePredictions(weatherForecast);\n\n    std::cout << \"Updated Forecast: \";\n    for (const auto& temp : weatherForecast) {\n        std::cout << temp << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a function that receives a system log and extracts error messages. Show how pass-by-value ensures the original log remains unchanged.",
    "code": "```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n\n// Function to extract error messages, receiving the log by value\nstd::vector<std::string> extractErrorMessages(std::vector<std::string> log) {\n    std::vector<std::string> errors;\n    for (const auto& entry : log) {\n        if (entry.find(\"ERROR\") != std::string::npos) {\n            errors.push_back(entry);\n        }\n    }\n    return errors;\n}\n\nint main() {\n    std::vector<std::string> systemLog = {\n        \"INFO: System started successfully.\",\n        \"ERROR: Failed to connect to server.\",\n        \"INFO: Checking for updates.\",\n        \"ERROR: Disk space is low.\",\n        \"INFO: System shutting down.\"\n    };\n\n    std::vector<std::string> errorMessages = extractErrorMessages(systemLog);\n\n    std::cout << \"Error Messages:\" << std::endl;\n    for (const auto& error : errorMessages) {\n        std::cout << error << std::endl;\n    }\n\n    std::cout << \"\\nOriginal Log:\" << std::endl;\n    for (const auto& entry : systemLog) {\n        std::cout << entry << std::endl;\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Design a function that accepts a data packet and encrypts it. Demonstrate the effect of pass-by-value on the packet.",
    "code": "```cpp\n#include <iostream>\n#include <string>\n\nstd::string encryptPacket(std::string packet) {\n    for (char &c : packet) {\n        c += 1; // Simple encryption by incrementing ASCII value\n    }\n    return packet;\n}\n\nint main() {\n    std::string dataPacket = \"Data123\";\n    std::cout << \"Original Packet: \" << dataPacket << std::endl;\n    \n    std::string encryptedPacket = encryptPacket(dataPacket);\n    std::cout << \"Encrypted Packet: \" << encryptedPacket << std::endl;\n    \n    std::cout << \"Packet after encryption function: \" << dataPacket << std::endl;\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that takes a website theme and applies a color change. Explain how pass-by-reference affects the original theme.",
    "code": "```cpp\n#include <iostream>\n#include <string>\n\nstruct Theme {\n    std::string color;\n};\n\nvoid applyColorChange(Theme &theme, const std::string &newColor) {\n    theme.color = newColor;\n}\n\nint main() {\n    Theme websiteTheme;\n    websiteTheme.color = \"blue\";\n    \n    std::cout << \"Original color: \" << websiteTheme.color << std::endl;\n    \n    applyColorChange(websiteTheme, \"red\");\n    \n    std::cout << \"Updated color: \" << websiteTheme.color << std::endl;\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Create a function that accepts a digital signature and verifies it. Discuss the implications of pass-by-value on the signature.",
    "code": "```cpp\n#include <iostream>\n#include <string>\n\nbool verifySignature(std::string signature) {\n    // Placeholder for signature verification logic\n    if (signature == \"valid_signature\") {\n        return true;\n    }\n    return false;\n}\n\nint main() {\n    std::string signature = \"valid_signature\";\n    if (verifySignature(signature)) {\n        std::cout << \"Signature is valid.\" << std::endl;\n    } else {\n        std::cout << \"Signature is invalid.\" << std::endl;\n    }\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a function that receives a robot's path and optimizes it. Illustrate the effects of pass-by-reference on the path.",
    "code": "```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n\nvoid optimizePath(std::vector<std::string>& path) {\n    if (path.empty()) return;\n    std::vector<std::string> optimizedPath;\n    std::string lastDirection = path.front();\n    optimizedPath.push_back(lastDirection);\n    \n    for (const std::string& direction : path) {\n        if (direction != lastDirection) {\n            optimizedPath.push_back(direction);\n            lastDirection = direction;\n        }\n    }\n    path = optimizedPath;\n}\n\nvoid printPath(const std::vector<std::string>& path) {\n    for (const auto& step : path) {\n        std::cout << step << \" \";\n    }\n    std::cout << std::endl;\n}\n\nint main() {\n    std::vector<std::string> robotPath = {\"N\", \"N\", \"E\", \"E\", \"E\", \"S\", \"S\", \"W\", \"W\", \"W\", \"N\", \"N\"};\n    std::cout << \"Original Path: \";\n    printPath(robotPath);\n\n    optimizePath(robotPath);\n    \n    std::cout << \"Optimized Path: \";\n    printPath(robotPath);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a function that takes a music playlist and shuffles it. Demonstrate the impact of pass-by-reference on the playlist.",
    "code": "```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <ctime>\n\nvoid shufflePlaylist(std::vector<std::string>& playlist) {\n    std::srand(std::time(0));\n    std::random_shuffle(playlist.begin(), playlist.end());\n}\n\nint main() {\n    std::vector<std::string> playlist = {\"Song A\", \"Song B\", \"Song C\", \"Song D\", \"Song E\"};\n    \n    std::cout << \"Original Playlist:\" << std::endl;\n    for (const auto& song : playlist) {\n        std::cout << song << std::endl;\n    }\n\n    shufflePlaylist(playlist);\n    \n    std::cout << \"\\nShuffled Playlist:\" << std::endl;\n    for (const auto& song : playlist) {\n        std::cout << song << std::endl;\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Design a program where a function receives a social media feed and removes duplicates. Show the changes with pass-by-reference.",
    "code": "```cpp\n#include <iostream>\n#include <vector>\n#include <unordered_set>\n\nvoid removeDuplicates(std::vector<std::string>& feed) {\n    std::unordered_set<std::string> seen;\n    std::vector<std::string> uniqueFeed;\n    \n    for (const auto& post : feed) {\n        if (seen.find(post) == seen.end()) {\n            uniqueFeed.push_back(post);\n            seen.insert(post);\n        }\n    }\n    \n    feed = std::move(uniqueFeed);\n}\n\nint main() {\n    std::vector<std::string> socialMediaFeed = {\n        \"Post 1\", \"Post 2\", \"Post 1\", \"Post 3\", \"Post 2\", \"Post 4\"\n    };\n    \n    std::cout << \"Original Feed:\" << std::endl;\n    for (const auto& post : socialMediaFeed) {\n        std::cout << post << std::endl;\n    }\n    \n    removeDuplicates(socialMediaFeed);\n    \n    std::cout << \"\\nFeed after removing duplicates:\" << std::endl;\n    for (const auto& post : socialMediaFeed) {\n        std::cout << post << std::endl;\n    }\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that takes a coding challenge and adds test cases. Discuss the effects of pass-by-reference on the challenge.",
    "code": "```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n\n// Function prototype\nvoid addTestCases(std::string &challenge);\n\n// Main function\nint main() {\n    std::string codingChallenge = \"Implement a function to reverse a string.\";\n    addTestCases(codingChallenge);\n    std::cout << \"Updated Challenge: \" << codingChallenge << std::endl;\n    return 0;\n}\n\n// Function definition\nvoid addTestCases(std::string &challenge) {\n    challenge += \" Test Cases: (1) Input: 'hello', Output: 'olleh'. (2) Input: 'C++', Output: '++C'.\";\n}\n```"
  },
  {
    "task": "Create a function that accepts an animation sequence and reverses it. Explain how pass-by-value ensures the sequence remains unchanged.",
    "code": "```cpp\n#include <vector>\n#include <algorithm>\n#include <iostream>\n\n// Function to reverse the animation sequence\nstd::vector<int> reverseAnimationSequence(std::vector<int> sequence) {\n    std::reverse(sequence.begin(), sequence.end());\n    return sequence;\n}\n\nint main() {\n    std::vector<int> animationSequence = {1, 2, 3, 4, 5};\n    std::vector<int> reversedSequence = reverseAnimationSequence(animationSequence);\n\n    std::cout << \"Original sequence: \";\n    for(int frame : animationSequence) {\n        std::cout << frame << \" \";\n    }\n    std::cout << std::endl;\n\n    std::cout << \"Reversed sequence: \";\n    for(int frame : reversedSequence) {\n        std::cout << frame << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a function that receives a GPS route and recalculates it. Illustrate the impact of pass-by-reference on the route.",
    "code": "```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n\nvoid recalculateRoute(std::vector<std::string>& route) {\n    // Simulate recalculation by appending a new point to the route\n    route.push_back(\"New Point\");\n}\n\nvoid printRoute(const std::vector<std::string>& route) {\n    for (const auto& point : route) {\n        std::cout << point << \" \";\n    }\n    std::cout << std::endl;\n}\n\nint main() {\n    std::vector<std::string> gpsRoute = {\"Point A\", \"Point B\", \"Point C\"};\n    \n    std::cout << \"Original Route: \";\n    printRoute(gpsRoute);\n    \n    recalculateRoute(gpsRoute);\n    \n    std::cout << \"Recalculated Route: \";\n    printRoute(gpsRoute);\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Develop a function that takes a chat history and censors inappropriate language. Show the effect of pass-by-reference on the history.",
    "code": "```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nvoid censorInappropriateLanguage(std::vector<std::string>& chatHistory) {\n    std::vector<std::string> inappropriateWords = {\"badword1\", \"badword2\"};\n    for (std::string& message : chatHistory) {\n        for (const std::string& badWord : inappropriateWords) {\n            size_t pos = 0;\n            while ((pos = message.find(badWord, pos)) != std::string::npos) {\n                message.replace(pos, badWord.length(), std::string(badWord.length(), '*'));\n                pos += badWord.length();\n            }\n        }\n    }\n}\n\nint main() {\n    std::vector<std::string> chatHistory = {\n        \"This is a message with badword1.\",\n        \"Another message with badword2.\",\n        \"Clean message.\"\n    };\n\n    censorInappropriateLanguage(chatHistory);\n\n    for (const auto& message : chatHistory) {\n        std::cout << message << std::endl;\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Design a function that accepts a lighting setup and adjusts brightness. Discuss the changes when the setup is passed by reference.",
    "code": "```cpp\n#include <iostream>\n\nstruct LightingSetup {\n    int brightness;\n    // Additional properties can be added here\n};\n\nvoid adjustBrightness(LightingSetup &setup, int newBrightness) {\n    setup.brightness = newBrightness;\n}\n\nint main() {\n    LightingSetup setup = {50}; // Initial brightness\n    std::cout << \"Initial Brightness: \" << setup.brightness << std::endl;\n    \n    adjustBrightness(setup, 75);\n    std::cout << \"Adjusted Brightness: \" << setup.brightness << std::endl;\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Write a program where a function receives a VR environment and changes the scenery. Demonstrate the effects of pass-by-reference.",
    "code": "```cpp\n#include <iostream>\n#include <string>\n\nstruct VREnvironment {\n    std::string scenery;\n};\n\nvoid changeScenery(VREnvironment& env) {\n    env.scenery = \"Futuristic City\";\n}\n\nint main() {\n    VREnvironment vrEnv;\n    vrEnv.scenery = \"Forest\";\n\n    std::cout << \"Before change: \" << vrEnv.scenery << std::endl;\n    changeScenery(vrEnv);\n    std::cout << \"After change: \" << vrEnv.scenery << std::endl;\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a function that takes a blockchain ledger and adds a block. Explain how pass-by-reference affects the ledger.",
    "code": "```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n\nstruct Block {\n    std::string data;\n    std::string previousHash;\n    std::string hash;\n};\n\ntypedef std::vector<Block> Ledger;\n\nvoid addBlock(Ledger &ledger, const Block &newBlock) {\n    ledger.push_back(newBlock);\n}\n\nint main() {\n    Ledger ledger;\n    Block block1 = {\"Block 1 Data\", \"0\", \"hash1\"};\n    Block block2 = {\"Block 2 Data\", \"hash1\", \"hash2\"};\n    \n    addBlock(ledger, block1);\n    addBlock(ledger, block2);\n    \n    for (const auto &block : ledger) {\n        std::cout << \"Data: \" << block.data << \"\\n\";\n        std::cout << \"Previous Hash: \" << block.previousHash << \"\\n\";\n        std::cout << \"Hash: \" << block.hash << \"\\n\\n\";\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a function that accepts a network packet and alters its headers. Discuss the implications of pass-by-value on the packet.",
    "code": "```cpp\n#include <iostream>\n#include <string>\n\nstruct NetworkPacket {\n    std::string header;\n    std::string data;\n};\n\nvoid alterPacketHeader(NetworkPacket packet) {\n    packet.header = \"NewHeader\";\n    std::cout << \"Inside function - Header: \" << packet.header << std::endl;\n}\n\nint main() {\n    NetworkPacket packet;\n    packet.header = \"OriginalHeader\";\n    packet.data = \"SomeData\";\n\n    std::cout << \"Before function call - Header: \" << packet.header << std::endl;\n    alterPacketHeader(packet);\n    std::cout << \"After function call - Header: \" << packet.header << std::endl;\n\n    return 0;\n}\n```"
  }
]