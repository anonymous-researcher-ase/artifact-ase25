[
  {
    "task": "Write a function that reads a file and handles the exception if the file is not found.",
    "code": "```dart\nimport 'dart:io';\n\nvoid readFile(String filePath) {\n  try {\n    final file = File(filePath);\n    String contents = file.readAsStringSync();\n    print(contents);\n  } on FileSystemException catch (e) {\n    print('File not found: $e');\n  }\n}\n\nvoid main() {\n  readFile('example.txt');\n}\n```"
  },
  {
    "task": "Create a program that divides two numbers and catches any division by zero errors.",
    "code": "```dart\nvoid main() {\n  double num1 = 10;\n  double num2 = 0;\n\n  try {\n    double result = divide(num1, num2);\n    print('Result: $result');\n  } catch (e) {\n    print('Error: $e');\n  }\n}\n\ndouble divide(double a, double b) {\n  if (b == 0) {\n    throw Exception('Cannot divide by zero');\n  }\n  return a / b;\n}\n```"
  },
  {
    "task": "Design a function to parse an integer from a string and manage invalid input exceptions.",
    "code": "```dart\nint parseInteger(String input) {\n  try {\n    return int.parse(input);\n  } on FormatException {\n    throw Exception('Invalid input: not a valid integer');\n  }\n}\n```"
  },
  {
    "task": "Implement an API call and catch exceptions related to network errors or timeouts.",
    "code": "```dart\nimport 'dart:async';\nimport 'dart:convert';\nimport 'package:http/http.dart' as http;\n\nFuture<void> fetchData() async {\n  final url = Uri.parse('https://api.example.com/data');\n  \n  try {\n    final response = await http.get(url).timeout(Duration(seconds: 5));\n\n    if (response.statusCode == 200) {\n      var data = jsonDecode(response.body);\n      print('Data received: $data');\n    } else {\n      print('Error: ${response.statusCode}');\n    }\n  } on TimeoutException catch (_) {\n    print('Request timed out. Please try again later.');\n  } on http.ClientException catch (e) {\n    print('Network error: $e');\n  } catch (e) {\n    print('An unexpected error occurred: $e');\n  }\n}\n\nvoid main() {\n  fetchData();\n}\n```"
  },
  {
    "task": "Develop a program that opens a database connection and handles any connection failure exceptions.",
    "code": "```dart\nimport 'dart:async';\n\nclass DatabaseConnectionException implements Exception {\n  final String message;\n  DatabaseConnectionException(this.message);\n}\n\nclass Database {\n  Future<void> openConnection() async {\n    // Simulating a connection failure\n    throw DatabaseConnectionException('Failed to connect to the database.');\n  }\n}\n\nvoid main() async {\n  var database = Database();\n  try {\n    await database.openConnection();\n    print('Database connection opened successfully.');\n  } on DatabaseConnectionException catch (e) {\n    print('Connection error: ${e.message}');\n  } catch (e) {\n    print('An unexpected error occurred: $e');\n  }\n}\n```"
  },
  {
    "task": "Write a function that accesses an array by index and catches out-of-bounds exceptions.",
    "code": "```dart\nvoid accessArray(List<dynamic> array, int index) {\n  try {\n    var element = array[index];\n    print('Element at index $index: $element');\n  } on RangeError {\n    print('Index $index is out of bounds for the array.');\n  }\n}\n\nvoid main() {\n  var myArray = [10, 20, 30, 40, 50];\n  accessArray(myArray, 2);  // Valid access\n  accessArray(myArray, 10); // Out-of-bounds access\n}\n```"
  },
  {
    "task": "Create a function that converts a string to a date object and manages format exceptions.",
    "code": "```dart\nimport 'package:intl/intl.dart';\n\nDateTime? stringToDate(String dateString) {\n  try {\n    DateFormat format = DateFormat('yyyy-MM-dd');\n    return format.parseStrict(dateString);\n  } on FormatException {\n    return null;\n  }\n}\n\nvoid main() {\n  print(stringToDate('2023-10-15')); // Valid date\n  print(stringToDate('invalid-date')); // Invalid date\n}\n```"
  },
  {
    "task": "Design a program that writes data to a file and catches any file permission exceptions.",
    "code": "```dart\nimport 'dart:io';\n\nvoid main() {\n  final filePath = 'output.txt';\n  final content = 'Hello, Dart!';\n\n  try {\n    File file = File(filePath);\n    file.writeAsStringSync(content);\n    print('Data written to file successfully.');\n  } on FileSystemException catch (e) {\n    print('Failed to write to file: ${e.message}');\n  }\n}\n```"
  },
  {
    "task": "Implement a module that retrieves data from a URL and handles malformed URL exceptions.",
    "code": "```dart\nimport 'dart:io';\nimport 'dart:convert';\n\nFuture<void> fetchDataFromUrl(String urlString) async {\n  try {\n    final uri = Uri.parse(urlString);\n    final response = await HttpClient().getUrl(uri).then((request) => request.close());\n\n    if (response.statusCode == HttpStatus.ok) {\n      final data = await response.transform(utf8.decoder).join();\n      print('Data retrieved: $data');\n    } else {\n      print('Error: ${response.statusCode}');\n    }\n  } on FormatException {\n    print('Malformed URL: $urlString');\n  } catch (e) {\n    print('An error occurred: $e');\n  } finally {\n    HttpClient().close();\n  }\n}\n```"
  },
  {
    "task": "Write a function to calculate the square root of a number and catch any negative input exceptions.",
    "code": "```dart\nimport 'dart:math';\n\ndouble calculateSquareRoot(double number) {\n  try {\n    if (number < 0) {\n      throw ArgumentError('Negative input is not allowed');\n    }\n    return sqrt(number);\n  } catch (e) {\n    print('Exception caught: $e');\n    return double.nan;\n  }\n}\n\nvoid main() {\n  double result = calculateSquareRoot(-4);\n  print('Result: $result');\n}\n```"
  },
  {
    "task": "Develop a program that sends an email and manages exceptions for invalid email addresses.",
    "code": "```dart\nimport 'dart:async';\n\nclass EmailSender {\n  void sendEmail(String email) {\n    try {\n      if (!_isValidEmail(email)) {\n        throw FormatException('Invalid email address: $email');\n      }\n      // Simulate email sending\n      print('Email sent to $email');\n    } on FormatException catch (e) {\n      print('Error: ${e.message}');\n    } catch (e) {\n      print('An unexpected error occurred: $e');\n    }\n  }\n\n  bool _isValidEmail(String email) {\n    // Basic regex for email validation\n    final emailRegex = RegExp(r'^[^@]+@[^@]+\\.[^@]+');\n    return emailRegex.hasMatch(email);\n  }\n}\n\nvoid main() {\n  final emailSender = EmailSender();\n  emailSender.sendEmail('test@example.com'); // Valid email\n  emailSender.sendEmail('invalid-email');    // Invalid email\n}\n```"
  },
  {
    "task": "Create a calculator application that handles invalid operations gracefully.",
    "code": "```dart\nimport 'dart:io';\n\nclass Calculator {\n  double add(double a, double b) => a + b;\n  double subtract(double a, double b) => a - b;\n  double multiply(double a, double b) => a * b;\n\n  double divide(double a, double b) {\n    if (b == 0) {\n      throw ArgumentError('Division by zero is not allowed.');\n    }\n    return a / b;\n  }\n}\n\nvoid main() {\n  var calculator = Calculator();\n\n  try {\n    print('Enter first number:');\n    double num1 = double.parse(stdin.readLineSync()!);\n\n    print('Enter second number:');\n    double num2 = double.parse(stdin.readLineSync()!);\n\n    print('Enter operation (+, -, *, /):');\n    String operation = stdin.readLineSync()!;\n\n    double result;\n\n    switch (operation) {\n      case '+':\n        result = calculator.add(num1, num2);\n        break;\n      case '-':\n        result = calculator.subtract(num1, num2);\n        break;\n      case '*':\n        result = calculator.multiply(num1, num2);\n        break;\n      case '/':\n        result = calculator.divide(num1, num2);\n        break;\n      default:\n        throw ArgumentError('Invalid operation.');\n    }\n\n    print('Result: $result');\n  } catch (e) {\n    print('Error: ${e.toString()}');\n  }\n}\n```"
  },
  {
    "task": "Design a function that tries to parse JSON data and catches parsing errors.",
    "code": "```dart\nimport 'dart:convert';\n\nvoid parseJson(String jsonString) {\n  try {\n    var jsonData = jsonDecode(jsonString);\n    print('Parsed JSON: $jsonData');\n  } catch (e) {\n    print('Error parsing JSON: $e');\n  }\n}\n\nvoid main() {\n  var validJson = '{\"name\": \"John\", \"age\": 30}';\n  var invalidJson = '{\"name\": \"John\", \"age\":}';\n\n  parseJson(validJson);\n  parseJson(invalidJson);\n}\n```"
  },
  {
    "task": "Implement a system that processes user input and handles any type conversion exceptions.",
    "code": "```dart\nimport 'dart:io';\n\nvoid main() {\n  print('Enter a number:');\n  String? userInput = stdin.readLineSync();\n\n  try {\n    if (userInput != null) {\n      int number = int.parse(userInput);\n      print('You entered the number: $number');\n    } else {\n      throw Exception('No input provided.');\n    }\n  } catch (e) {\n    print('Error: Invalid input. Please enter a valid number.');\n  }\n}\n```"
  },
  {
    "task": "Write a function that fetches data from a database and manages exceptions for missing records.",
    "code": "```dart\nclass DatabaseException implements Exception {\n  final String message;\n  DatabaseException(this.message);\n}\n\nclass Database {\n  // Simulated method to fetch data\n  String fetchData(String recordId) {\n    // Simulate missing record\n    if (recordId != 'validId') {\n      throw DatabaseException('Record not found');\n    }\n    return 'Record Data';\n  }\n}\n\nString fetchDataFromDatabase(String recordId) {\n  final database = Database();\n  try {\n    return database.fetchData(recordId);\n  } on DatabaseException catch (e) {\n    return 'Error: ${e.message}';\n  }\n}\n\nvoid main() {\n  // Example usage\n  print(fetchDataFromDatabase('invalidId')); // Outputs: Error: Record not found\n  print(fetchDataFromDatabase('validId'));   // Outputs: Record Data\n}\n```"
  },
  {
    "task": "Create a program that connects to a remote server and handles authentication failure exceptions.",
    "code": "```dart\nimport 'dart:io';\n\nclass AuthenticationException implements Exception {\n  final String message;\n  AuthenticationException(this.message);\n\n  @override\n  String toString() => 'AuthenticationException: $message';\n}\n\nFuture<void> connectToServer(String serverAddress, String username, String password) async {\n  // Simulating server connection and authentication\n  if (username != 'admin' || password != 'password123') {\n    throw AuthenticationException('Invalid username or password.');\n  }\n  print('Connected to server: $serverAddress');\n}\n\nvoid main() async {\n  final serverAddress = 'http://example.com';\n  final username = 'admin';\n  final password = 'wrongpassword';\n\n  try {\n    await connectToServer(serverAddress, username, password);\n  } on AuthenticationException catch (e) {\n    print('Authentication failed: $e');\n  } on SocketException catch (e) {\n    print('Network error: $e');\n  } catch (e) {\n    print('An unexpected error occurred: $e');\n  }\n}\n```"
  },
  {
    "task": "Develop a function to download a file from the internet and handle file not found exceptions.",
    "code": "```dart\nimport 'dart:io';\n\nFuture<void> downloadFile(String url, String savePath) async {\n  try {\n    HttpClient client = HttpClient();\n    var request = await client.getUrl(Uri.parse(url));\n    var response = await request.close();\n\n    if (response.statusCode == HttpStatus.notFound) {\n      throw Exception('File not found');\n    }\n\n    var file = File(savePath);\n    var fileSink = file.openWrite();\n\n    await response.pipe(fileSink);\n    await fileSink.close();\n  } on Exception catch (e) {\n    print('Error: $e');\n  }\n}\n```"
  },
  {
    "task": "Design a program that attempts to connect to an API and handles rate limit exceptions.",
    "code": "```dart\nimport 'dart:async';\nimport 'dart:convert';\nimport 'dart:io';\n\nFuture<void> connectToApi(String url) async {\n  try {\n    final response = await HttpClient().getUrl(Uri.parse(url)).then((req) => req.close());\n    if (response.statusCode == 200) {\n      final data = await response.transform(utf8.decoder).join();\n      print('Data received: $data');\n    } else if (response.statusCode == 429) {\n      throw RateLimitException('Rate limit exceeded');\n    } else {\n      throw HttpException('Failed to connect to API', uri: Uri.parse(url));\n    }\n  } on RateLimitException catch (e) {\n    print('Error: ${e.message}');\n  } on HttpException catch (e) {\n    print('HTTP Error: ${e.message}');\n  } on Exception catch (e) {\n    print('Unexpected error: $e');\n  }\n}\n\nclass RateLimitException implements Exception {\n  final String message;\n  RateLimitException(this.message);\n}\n\nvoid main() {\n  connectToApi('https://api.example.com/data');\n}\n```"
  },
  {
    "task": "Write a function that reads from a configuration file and manages key not found exceptions.",
    "code": "```dart\nimport 'dart:io';\n\nString readConfig(String key, String filePath) {\n  try {\n    final file = File(filePath);\n    if (!file.existsSync()) {\n      throw FileSystemException('File not found');\n    }\n    final lines = file.readAsLinesSync();\n    for (var line in lines) {\n      final parts = line.split('=');\n      if (parts.length == 2 && parts[0].trim() == key) {\n        return parts[1].trim();\n      }\n    }\n    throw Exception('Key not found');\n  } on FileSystemException catch (e) {\n    return 'Error: ${e.message}';\n  } catch (e) {\n    return 'Error: ${e.toString()}';\n  }\n}\n\nvoid main() {\n  final configValue = readConfig('someKey', 'config.txt');\n  print(configValue);\n}\n```"
  },
  {
    "task": "Create an application that processes a list of tasks and catches any task execution exceptions.",
    "code": "```dart\nvoid main() {\n  List<String> tasks = ['task1', 'task2', 'task3'];\n  \n  tasks.forEach((task) {\n    try {\n      executeTask(task);\n    } catch (e) {\n      print('Exception caught while executing $task: $e');\n    }\n  });\n}\n\nvoid executeTask(String task) {\n  if (task == 'task2') {\n    throw Exception('An error occurred executing $task');\n  } else {\n    print('$task executed successfully');\n  }\n}\n```"
  },
  {
    "task": "Implement a program that performs batch processing and handles individual item processing exceptions.",
    "code": "```dart\nvoid main() {\n  List<int> items = [1, 2, 0, 4, 5]; // Sample data with a zero to cause an exception\n  processBatch(items);\n}\n\nvoid processBatch(List<int> items) {\n  for (var item in items) {\n    try {\n      processItem(item);\n    } catch (e) {\n      print('Exception caught while processing item $item: $e');\n    }\n  }\n}\n\nvoid processItem(int item) {\n  if (item == 0) {\n    throw Exception('Cannot process item with value zero.');\n  }\n  print('Processed item: $item');\n}\n```"
  },
  {
    "task": "Develop a function that performs mathematical operations and catches arithmetic exceptions.",
    "code": "```dart\nvoid main() {\n  try {\n    double result = performOperation(10, 0, '/');\n    print('Result: $result');\n  } catch (e) {\n    print('Error: $e');\n  }\n}\n\ndouble performOperation(double a, double b, String operator) {\n  try {\n    switch (operator) {\n      case '+':\n        return a + b;\n      case '-':\n        return a - b;\n      case '*':\n        return a * b;\n      case '/':\n        if (b == 0) {\n          throw Exception('Division by zero');\n        }\n        return a / b;\n      default:\n        throw Exception('Unsupported operator');\n    }\n  } on Exception catch (e) {\n    throw e;\n  }\n}\n```"
  },
  {
    "task": "Write a program that logs error messages when exceptions occur during data processing.",
    "code": "```dart\nvoid processData(String data) {\n  try {\n    if (data.isEmpty) {\n      throw Exception('Data is empty');\n    }\n    // Simulate data processing\n    print('Processing data: $data');\n  } catch (e) {\n    logError(e);\n  }\n}\n\nvoid logError(Exception e) {\n  print('Error occurred: ${e.toString()}');\n}\n\nvoid main() {\n  List<String> dataList = ['Data1', '', 'Data2'];\n\n  for (var data in dataList) {\n    processData(data);\n  }\n}\n```"
  },
  {
    "task": "Create a script that monitors system resources and handles exceptions when limits are exceeded.",
    "code": "```dart\nimport 'dart:io';\n\nvoid main() {\n  try {\n    var cpuUsage = getCpuUsage();\n    var memoryUsage = getMemoryUsage();\n\n    if (cpuUsage > 80) {\n      throw Exception('CPU usage limit exceeded: $cpuUsage%');\n    }\n\n    if (memoryUsage > 80) {\n      throw Exception('Memory usage limit exceeded: $memoryUsage%');\n    }\n\n    print('System resources are within limits.');\n  } on Exception catch (e) {\n    print('Exception caught: $e');\n  }\n}\n\nint getCpuUsage() {\n  // Placeholder function for CPU usage retrieval\n  return 85; // Simulated percentage\n}\n\nint getMemoryUsage() {\n  // Placeholder function for Memory usage retrieval\n  return 70; // Simulated percentage\n}\n```"
  },
  {
    "task": "Design a function that validates user input and manages any format exceptions.",
    "code": "```dart\nvoid main() {\n  String userInput = '123a';\n  try {\n    int validNumber = validateAndParseInput(userInput);\n    print('Valid number: $validNumber');\n  } catch (e) {\n    print('Error: $e');\n  }\n}\n\nint validateAndParseInput(String input) {\n  try {\n    return int.parse(input);\n  } on FormatException {\n    throw Exception('Invalid format: Input is not a valid integer.');\n  }\n}\n```"
  },
  {
    "task": "Implement a service that interacts with third-party APIs and handles unexpected response exceptions.",
    "code": "```dart\nimport 'dart:convert';\nimport 'dart:io';\n\nimport 'package:http/http.dart' as http;\n\nclass ApiService {\n  final String baseUrl;\n\n  ApiService(this.baseUrl);\n\n  Future<Map<String, dynamic>> fetchData(String endpoint) async {\n    try {\n      final response = await http.get(Uri.parse('$baseUrl$endpoint'));\n\n      if (response.statusCode == 200) {\n        return jsonDecode(response.body);\n      } else {\n        throw HttpException('Unexpected status code: ${response.statusCode}');\n      }\n    } on SocketException {\n      throw Exception('No Internet connection');\n    } on HttpException catch (e) {\n      throw Exception('HttpException: ${e.message}');\n    } on FormatException {\n      throw Exception('Invalid JSON format');\n    } catch (e) {\n      throw Exception('Unexpected error: $e');\n    }\n  }\n}\n\nvoid main() async {\n  final apiService = ApiService('https://api.example.com');\n\n  try {\n    final data = await apiService.fetchData('/some-endpoint');\n    print('Data received: $data');\n  } catch (e) {\n    print('Error: $e');\n  }\n}\n```"
  },
  {
    "task": "Write a function that uploads files to a server and handles exceptions for unsupported file types.",
    "code": "```dart\nclass UnsupportedFileTypeException implements Exception {\n  final String message;\n  UnsupportedFileTypeException(this.message);\n}\n\nvoid uploadFile(String fileName) {\n  try {\n    if (!isSupportedFileType(fileName)) {\n      throw UnsupportedFileTypeException('Unsupported file type: $fileName');\n    }\n    // Simulate file upload\n    print(\"Uploading $fileName to server...\");\n    // Assume upload succeeds\n  } on UnsupportedFileTypeException catch (e) {\n    print('Error: ${e.message}');\n  } catch (e) {\n    print('An unexpected error occurred: $e');\n  }\n}\n\nbool isSupportedFileType(String fileName) {\n  final supportedExtensions = ['jpg', 'png', 'pdf'];\n  String fileExtension = fileName.split('.').last;\n  return supportedExtensions.contains(fileExtension);\n}\n\nvoid main() {\n  uploadFile('document.txt'); // Unsupported file type\n  uploadFile('image.jpg');    // Supported file type\n}\n```"
  },
  {
    "task": "Create a program that simulates network traffic and manages packet loss exceptions.",
    "code": "```dart\nimport 'dart:math';\n\nclass NetworkException implements Exception {\n  final String message;\n  NetworkException(this.message);\n}\n\nclass NetworkSimulator {\n  final Random _random = Random();\n\n  void sendPacket(String packet) {\n    if (_random.nextDouble() < 0.2) {\n      throw NetworkException('Packet loss occurred for: $packet');\n    }\n    print('Packet sent successfully: $packet');\n  }\n}\n\nvoid main() {\n  final networkSimulator = NetworkSimulator();\n  final packets = ['Packet1', 'Packet2', 'Packet3', 'Packet4', 'Packet5'];\n\n  for (var packet in packets) {\n    try {\n      networkSimulator.sendPacket(packet);\n    } on NetworkException catch (e) {\n      print(e.message);\n    }\n  }\n}\n```"
  },
  {
    "task": "Develop a function that processes XML data and catches any structural exceptions.",
    "code": "```dart\nimport 'package:xml/xml.dart';\n\nvoid processXmlData(String xmlString) {\n  try {\n    final document = XmlDocument.parse(xmlString);\n    // Process the XML data here\n    print('XML processed successfully.');\n  } on XmlParserException catch (e) {\n    print('XML parsing error: ${e.message}');\n  } catch (e) {\n    print('An unexpected error occurred: $e');\n  }\n}\n\nvoid main() {\n  const xmlData = '<note><to>Tove</to><from>Jani</from><heading>Reminder</heading><body>Don\\'t forget me this weekend!</body></note>';\n  processXmlData(xmlData);\n}\n```"
  },
  {
    "task": "Design a program that handles exceptions when accessing environment variables.",
    "code": "```dart\nimport 'dart:io';\n\nvoid main() {\n  try {\n    String? envVariable = Platform.environment['MY_ENV_VAR'];\n    if (envVariable == null) {\n      throw Exception('Environment variable not found');\n    }\n    print('Environment variable: $envVariable');\n  } catch (e) {\n    print('An error occurred: $e');\n  }\n}\n```"
  },
  {
    "task": "Write a function that calculates factorial and manages exceptions for negative input values.",
    "code": "```dart\nint factorial(int n) {\n  if (n < 0) {\n    throw ArgumentError('Negative input is not allowed.');\n  }\n  return n <= 1 ? 1 : n * factorial(n - 1);\n}\n\nvoid main() {\n  try {\n    print(factorial(5)); // Output: 120\n    print(factorial(-3)); // This will throw an exception\n  } catch (e) {\n    print('Error: ${e.toString()}');\n  }\n}\n```"
  },
  {
    "task": "Create a software tool that converts file formats and handles unsupported format exceptions.",
    "code": "```dart\nimport 'dart:io';\n\nclass UnsupportedFormatException implements Exception {\n  final String message;\n  UnsupportedFormatException(this.message);\n  @override\n  String toString() => 'UnsupportedFormatException: $message';\n}\n\nclass FileConverter {\n  final List<String> supportedFormats = ['txt', 'md'];\n\n  void convertFile(String inputFile, String outputFormat) {\n    try {\n      String inputFormat = inputFile.split('.').last;\n      if (!supportedFormats.contains(inputFormat) || \n          !supportedFormats.contains(outputFormat)) {\n        throw UnsupportedFormatException('Format not supported: $outputFormat');\n      }\n      // Conversion logic placeholder\n      print('Converting $inputFile to $outputFormat format...');\n    } on UnsupportedFormatException catch (e) {\n      print(e);\n    }\n  }\n}\n\nvoid main() {\n  FileConverter converter = FileConverter();\n  converter.convertFile('document.txt', 'md');\n  converter.convertFile('document.txt', 'pdf');\n}\n```"
  },
  {
    "task": "Implement a function that sends HTTP requests and catches exceptions for invalid response status codes.",
    "code": "```dart\nimport 'dart:convert';\nimport 'dart:io';\n\nimport 'package:http/http.dart' as http;\n\nFuture<void> sendHttpRequest(String url) async {\n  try {\n    final response = await http.get(Uri.parse(url));\n    if (response.statusCode != 200) {\n      throw HttpException('Invalid response status: ${response.statusCode}');\n    }\n    print('Response data: ${jsonDecode(response.body)}');\n  } on HttpException catch (e) {\n    print('HTTP Exception caught: $e');\n  } on SocketException {\n    print('No Internet connection.');\n  } on FormatException {\n    print('Invalid URL format.');\n  } catch (e) {\n    print('An unexpected error occurred: $e');\n  }\n}\n```"
  },
  {
    "task": "Develop a program that interacts with a message queue and handles message delivery exceptions.",
    "code": "```dart\nimport 'dart:async';\n\nclass MessageQueue {\n  final List<String> _messages = [];\n\n  void addMessage(String message) {\n    _messages.add(message);\n  }\n\n  String deliverMessage() {\n    if (_messages.isEmpty) {\n      throw Exception('No messages to deliver.');\n    }\n    return _messages.removeAt(0);\n  }\n}\n\nvoid main() {\n  final messageQueue = MessageQueue();\n\n  messageQueue.addMessage('Hello, World!');\n  messageQueue.addMessage('Dart is awesome!');\n\n  for (int i = 0; i < 3; i++) {\n    try {\n      String message = messageQueue.deliverMessage();\n      print('Delivered: $message');\n    } catch (e) {\n      print('Exception caught: $e');\n    }\n  }\n}\n```"
  },
  {
    "task": "Write a function that reads user input and catches exceptions for unexpected data types.",
    "code": "```dart\nimport 'dart:io';\n\nvoid readUserInput() {\n  print('Enter an integer:');\n  try {\n    String? input = stdin.readLineSync();\n    if (input == null) throw FormatException('No input provided');\n    int number = int.parse(input);\n    print('You entered: $number');\n  } catch (e) {\n    print('Error: ${e.toString()}');\n  }\n}\n\nvoid main() {\n  readUserInput();\n}\n```"
  },
  {
    "task": "Create a system that processes transactions and manages exceptions for insufficient funds.",
    "code": "```dart\nclass InsufficientFundsException implements Exception {\n  final String message;\n  InsufficientFundsException(this.message);\n  \n  @override\n  String toString() => 'InsufficientFundsException: $message';\n}\n\nclass Account {\n  double balance;\n\n  Account(this.balance);\n\n  void processTransaction(double amount) {\n    if (amount > balance) {\n      throw InsufficientFundsException('Transaction failed: Insufficient funds.');\n    }\n    balance -= amount;\n    print('Transaction successful: \\$${amount} debited. Remaining balance: \\$${balance}');\n  }\n}\n\nvoid main() {\n  var account = Account(100.0);\n\n  try {\n    account.processTransaction(150.0);\n  } catch (e) {\n    print(e);\n  }\n\n  try {\n    account.processTransaction(50.0);\n  } catch (e) {\n    print(e);\n  }\n}\n```"
  },
  {
    "task": "Design a function that generates random numbers and handles exceptions when the range is invalid.",
    "code": "```dart\nimport 'dart:math';\n\nvoid main() {\n  try {\n    double randomNum = generateRandomNumber(-5, 10);\n    print('Generated random number: $randomNum');\n  } catch (e) {\n    print('Error: $e');\n  }\n}\n\ndouble generateRandomNumber(int min, int max) {\n  if (min >= max) {\n    throw ArgumentError('Invalid range: min should be less than max.');\n  }\n  Random random = Random();\n  return min + random.nextDouble() * (max - min);\n}\n```"
  },
  {
    "task": "Implement a program that performs image processing and catches exceptions for unsupported file dimensions.",
    "code": "```dart\nclass UnsupportedFileDimensionsException implements Exception {\n  String errMsg() => 'Unsupported file dimensions encountered.';\n}\n\nclass ImageProcessor {\n  void processImage(int width, int height) {\n    try {\n      if (width < 0 || height < 0 || width > 10000 || height > 10000) {\n        throw UnsupportedFileDimensionsException();\n      }\n      // Assuming some image processing logic here\n      print('Processing image with dimensions: $width x $height');\n    } on UnsupportedFileDimensionsException catch (e) {\n      print(e.errMsg());\n    }\n  }\n}\n\nvoid main() {\n  ImageProcessor processor = ImageProcessor();\n  processor.processImage(1920, 1080); // Supported dimensions\n  processor.processImage(12000, 8000); // Unsupported dimensions\n}\n```"
  },
  {
    "task": "Write a function that manipulates strings and manages exceptions for invalid operations.",
    "code": "```dart\nString manipulateString(String input) {\n  try {\n    if (input.isEmpty) {\n      throw FormatException('Input string is empty');\n    }\n    // Example manipulation: reverse the string\n    return input.split('').reversed.join('');\n  } on FormatException catch (e) {\n    return 'Error: ${e.message}';\n  } catch (e) {\n    return 'An unexpected error occurred';\n  }\n}\n\nvoid main() {\n  print(manipulateString('hello')); // Output: olleh\n  print(manipulateString(''));      // Output: Error: Input string is empty\n}\n```"
  },
  {
    "task": "Create a script that automates tasks and handles exceptions for missing dependencies.",
    "code": "```dart\nimport 'dart:io';\n\nvoid main() {\n  try {\n    // Simulate checking for a dependency\n    checkDependency('dependencyName');\n    // Perform automated tasks\n    performTasks();\n  } on DependencyException catch (e) {\n    print('Error: ${e.message}');\n  }\n}\n\nvoid checkDependency(String dependency) {\n  // Simulating a missing dependency\n  bool isDependencyMissing = true;\n\n  if (isDependencyMissing) {\n    throw DependencyException('Missing dependency: $dependency');\n  }\n}\n\nvoid performTasks() {\n  print('Performing automated tasks...');\n}\n\nclass DependencyException implements Exception {\n  final String message;\n  DependencyException(this.message);\n}\n```"
  },
  {
    "task": "Develop a function that accesses nested data structures and manages key access exceptions.",
    "code": "```dart\nMap<String, dynamic> nestedData = {\n  'user': {\n    'profile': {\n      'name': 'Alice',\n      'age': 30\n    }\n  }\n};\n\nString accessNestedData(Map<String, dynamic> data, List<String> keys) {\n  try {\n    dynamic value = data;\n    for (String key in keys) {\n      if (value is Map<String, dynamic> && value.containsKey(key)) {\n        value = value[key];\n      } else {\n        throw Exception('Key not found: $key');\n      }\n    }\n    return value.toString();\n  } catch (e) {\n    return 'Error: ${e.toString()}';\n  }\n}\n\nvoid main() {\n  print(accessNestedData(nestedData, ['user', 'profile', 'name'])); // Alice\n  print(accessNestedData(nestedData, ['user', 'profile', 'height'])); // Error\n}\n```"
  },
  {
    "task": "Design a program that synchronizes data between sources and handles data mismatch exceptions.",
    "code": "```dart\nclass DataMismatchException implements Exception {\n  final String message;\n  DataMismatchException(this.message);\n\n  @override\n  String toString() => 'DataMismatchException: $message';\n}\n\nclass DataSource {\n  final Map<String, int> data;\n  DataSource(this.data);\n}\n\nclass DataSynchronizer {\n  final DataSource source1;\n  final DataSource source2;\n\n  DataSynchronizer(this.source1, this.source2);\n\n  void synchronize() {\n    try {\n      source1.data.forEach((key, value) {\n        if (source2.data.containsKey(key) && source2.data[key] != value) {\n          throw DataMismatchException(\n              'Mismatch at key: $key, source1: $value, source2: ${source2.data[key]}');\n        }\n        source2.data[key] = value;\n      });\n      print('Synchronization successful.');\n    } on DataMismatchException catch (e) {\n      print(e);\n    }\n  }\n}\n\nvoid main() {\n  final dataSource1 = DataSource({'a': 1, 'b': 2, 'c': 3});\n  final dataSource2 = DataSource({'a': 1, 'b': 3, 'd': 4});\n\n  final synchronizer = DataSynchronizer(dataSource1, dataSource2);\n  synchronizer.synchronize();\n}\n```"
  },
  {
    "task": "Write a function that interacts with hardware devices and handles connection failure exceptions.",
    "code": "```dart\nclass DeviceConnectionException implements Exception {\n  final String message;\n  DeviceConnectionException(this.message);\n}\n\nvoid connectToDevice() {\n  // Simulate a connection attempt\n  bool connectionSuccessful = false;\n\n  if (!connectionSuccessful) {\n    throw DeviceConnectionException(\"Failed to connect to the device.\");\n  }\n\n  // Code to interact with the device if connection is successful\n  print(\"Connected to the device successfully.\");\n}\n\nvoid main() {\n  try {\n    connectToDevice();\n  } on DeviceConnectionException catch (e) {\n    print(\"Error: ${e.message}\");\n  } catch (e) {\n    print(\"An unexpected error occurred: $e\");\n  }\n}\n```"
  },
  {
    "task": "Create a tool that compresses files and manages exceptions for unsupported compression formats.",
    "code": "```dart\nimport 'dart:io';\nimport 'dart:convert';\n\nclass UnsupportedFormatException implements Exception {\n  final String message;\n  UnsupportedFormatException(this.message);\n\n  @override\n  String toString() => 'UnsupportedFormatException: $message';\n}\n\nvoid compressFile(String filePath, String format) {\n  try {\n    if (format != 'zip' && format != 'gzip') {\n      throw UnsupportedFormatException('Format $format is not supported.');\n    }\n    \n    File file = File(filePath);\n    if (!file.existsSync()) {\n      throw FileSystemException('File does not exist.');\n    }\n    \n    // Placeholder for actual compression logic.\n    // e.g. compressing file content based on the format.\n    print('Compressing $filePath using $format format...');\n    \n  } on UnsupportedFormatException catch (e) {\n    print(e);\n  } on FileSystemException catch (e) {\n    print('FileSystemException: ${e.message}');\n  } catch (e) {\n    print('An unexpected error occurred: $e');\n  }\n}\n\nvoid main() {\n  compressFile('example.txt', 'zip');\n  compressFile('example.txt', 'rar'); // Unsupported format\n}\n```"
  },
  {
    "task": "Implement a function that parses command-line arguments and handles missing argument exceptions.",
    "code": "```dart\nvoid main(List<String> arguments) {\n  try {\n    if (arguments.isEmpty) {\n      throw Exception('No command-line arguments provided.');\n    }\n    parseArguments(arguments);\n  } catch (e) {\n    print('Error: ${e.toString()}');\n  }\n}\n\nvoid parseArguments(List<String> args) {\n  for (var arg in args) {\n    print('Argument: $arg');\n  }\n}\n```"
  },
  {
    "task": "Develop a program that simulates user interactions and manages timing exceptions.",
    "code": "```dart\nimport 'dart:async';\n\nclass UserInteractionSimulator {\n  Future<void> simulateInteraction() async {\n    try {\n      print(\"Starting user interaction...\");\n      await Future.delayed(Duration(seconds: 5), () {\n        throw TimeoutException(\"User interaction timed out.\");\n      });\n    } on TimeoutException catch (e) {\n      print(\"Exception caught: ${e.message}\");\n    } catch (e) {\n      print(\"An unexpected error occurred: $e\");\n    } finally {\n      print(\"User interaction simulation complete.\");\n    }\n  }\n}\n\nvoid main() {\n  UserInteractionSimulator simulator = UserInteractionSimulator();\n  simulator.simulateInteraction();\n}\n```"
  },
  {
    "task": "Write a function that encrypts data and handles exceptions for unsupported encryption algorithms.",
    "code": "```dart\nimport 'dart:convert';\nimport 'dart:typed_data';\nimport 'package:encrypt/encrypt.dart';\n\nString encryptData(String data, String algorithm) {\n  try {\n    final key = Key.fromUtf8('my32lengthsupersecretnooneknows1');\n    final iv = IV.fromLength(16);\n    Encrypter encrypter;\n\n    switch (algorithm) {\n      case 'AES':\n        encrypter = Encrypter(AES(key));\n        break;\n      case 'Fernet':\n        encrypter = Encrypter(Fernet(key));\n        break;\n      default:\n        throw UnsupportedError('Unsupported encryption algorithm: $algorithm');\n    }\n\n    final encrypted = encrypter.encrypt(data, iv: iv);\n    return encrypted.base64;\n  } on UnsupportedError catch (e) {\n    return e.message;\n  } catch (e) {\n    return 'An error occurred: ${e.toString()}';\n  }\n}\n```"
  },
  {
    "task": "Create a system that aggregates data and manages exceptions for data inconsistency.",
    "code": "```dart\nclass DataAggregator {\n  List<int> _data = [];\n\n  void addData(int value) {\n    if (value < 0) {\n      throw DataInconsistencyException('Negative values are not allowed');\n    }\n    _data.add(value);\n  }\n\n  int getTotal() {\n    return _data.reduce((a, b) => a + b);\n  }\n\n  double getAverage() {\n    if (_data.isEmpty) {\n      throw DataInconsistencyException('No data available');\n    }\n    return getTotal() / _data.length;\n  }\n}\n\nclass DataInconsistencyException implements Exception {\n  final String message;\n  DataInconsistencyException(this.message);\n\n  @override\n  String toString() {\n    return 'DataInconsistencyException: $message';\n  }\n}\n\nvoid main() {\n  var aggregator = DataAggregator();\n\n  try {\n    aggregator.addData(10);\n    aggregator.addData(20);\n    aggregator.addData(-5); // This will cause an exception\n  } on DataInconsistencyException catch (e) {\n    print(e);\n  }\n\n  try {\n    print('Total: ${aggregator.getTotal()}');\n    print('Average: ${aggregator.getAverage()}');\n  } on DataInconsistencyException catch (e) {\n    print(e);\n  }\n}\n```"
  },
  {
    "task": "Design a program that processes real-time data streams and handles connection drop exceptions.",
    "code": "```dart\nimport 'dart:async';\n\nclass DataStreamProcessor {\n  StreamController<String> _controller = StreamController<String>();\n\n  DataStreamProcessor() {\n    _controller.stream.listen(\n      (data) {\n        _processData(data);\n      },\n      onError: (error) {\n        _handleError(error);\n      },\n      cancelOnError: true,\n    );\n  }\n\n  void addData(String data) {\n    try {\n      _controller.add(data);\n    } catch (e) {\n      _handleError(e);\n    }\n  }\n\n  void _processData(String data) {\n    print(\"Processing data: $data\");\n  }\n\n  void _handleError(Object error) {\n    if (error is ConnectionDropException) {\n      print(\"Connection dropped. Attempting to reconnect...\");\n      // Implement reconnection logic here\n    } else {\n      print(\"An error occurred: $error\");\n    }\n  }\n\n  void dispose() {\n    _controller.close();\n  }\n}\n\nclass ConnectionDropException implements Exception {\n  String errMsg() => \"Connection has been dropped.\";\n}\n\nvoid main() {\n  DataStreamProcessor processor = DataStreamProcessor();\n\n  processor.addData(\"Real-time data 1\");\n  processor.addData(\"Real-time data 2\");\n\n  // Simulate a connection drop error\n  processor.addData(ConnectionDropException().errMsg());\n\n  // Dispose the processor when done\n  processor.dispose();\n}\n```"
  },
  {
    "task": "Implement a function that performs scientific calculations and manages precision exceptions.",
    "code": "```dart\nimport 'dart:math';\n\nclass PrecisionException implements Exception {\n  final String message;\n  PrecisionException(this.message);\n}\n\ndouble scientificCalculation(double value) {\n  try {\n    if (value.isNaN || value.isInfinite) {\n      throw PrecisionException('Input value is not a valid number.');\n    }\n    double result = log(value) * sqrt(value);\n    if (result.isNaN || result.isInfinite) {\n      throw PrecisionException('Result is not a valid number.');\n    }\n    return result;\n  } on PrecisionException catch (e) {\n    print('PrecisionException caught: ${e.message}');\n    return double.nan;\n  }\n}\n\nvoid main() {\n  double inputValue = 42.0;\n  double outputValue = scientificCalculation(inputValue);\n  print('The result is: $outputValue');\n}\n```"
  },
  {
    "task": "Write a script that generates reports and handles exceptions for missing data sources.",
    "code": "```dart\nimport 'dart:io';\n\nclass ReportGenerator {\n  void generateReport(String dataSource) {\n    try {\n      if (dataSource.isEmpty) {\n        throw Exception('Data source is missing.');\n      }\n      // Simulate report generation with the data source\n      print('Generating report using data source: $dataSource');\n    } catch (e) {\n      print('Error: ${e.toString()}');\n    }\n  }\n}\n\nvoid main() {\n  ReportGenerator reportGenerator = ReportGenerator();\n  \n  // Example with a valid data source\n  reportGenerator.generateReport('ValidDataSource');\n\n  // Example with a missing data source\n  reportGenerator.generateReport('');\n}\n```"
  },
  {
    "task": "Create a program that validates digital certificates and manages trust exceptions.",
    "code": "```dart\nclass Certificate {\n  final String name;\n  final bool isValid;\n\n  Certificate(this.name, this.isValid);\n}\n\nclass TrustException implements Exception {\n  final String message;\n  TrustException(this.message);\n\n  @override\n  String toString() => 'TrustException: $message';\n}\n\nclass CertificateValidator {\n  void validateCertificate(Certificate certificate) {\n    try {\n      if (!certificate.isValid) {\n        throw TrustException('Certificate ${certificate.name} is not valid.');\n      }\n      print('Certificate ${certificate.name} is valid.');\n    } on TrustException catch (e) {\n      print(e);\n    }\n  }\n}\n\nvoid main() {\n  Certificate validCert = Certificate('ValidCert', true);\n  Certificate invalidCert = Certificate('InvalidCert', false);\n\n  CertificateValidator validator = CertificateValidator();\n  validator.validateCertificate(validCert);\n  validator.validateCertificate(invalidCert);\n}\n```"
  },
  {
    "task": "Develop a function that schedules tasks and handles exceptions for scheduling conflicts.",
    "code": "```dart\nclass SchedulingConflictException implements Exception {\n  final String message;\n  SchedulingConflictException(this.message);\n  \n  @override\n  String toString() => 'SchedulingConflictException: $message';\n}\n\nclass Task {\n  final String name;\n  final DateTime start;\n  final DateTime end;\n\n  Task(this.name, this.start, this.end);\n}\n\nclass Scheduler {\n  final List<Task> _scheduledTasks = [];\n\n  void scheduleTask(Task newTask) {\n    for (var task in _scheduledTasks) {\n      if ((newTask.start.isBefore(task.end) && newTask.end.isAfter(task.start)) ||\n          (newTask.start.isAtSameMomentAs(task.start) && newTask.end.isAtSameMomentAs(task.end))) {\n        throw SchedulingConflictException('Task \"${newTask.name}\" conflicts with an existing task \"${task.name}\".');\n      }\n    }\n    _scheduledTasks.add(newTask);\n    print('Task \"${newTask.name}\" scheduled successfully.');\n  }\n}\n\nvoid main() {\n  var scheduler = Scheduler();\n\n  try {\n    scheduler.scheduleTask(Task('Task 1', DateTime(2023, 10, 1, 9), DateTime(2023, 10, 1, 11)));\n    scheduler.scheduleTask(Task('Task 2', DateTime(2023, 10, 1, 10), DateTime(2023, 10, 1, 12)));\n  } on SchedulingConflictException catch (e) {\n    print(e);\n  }\n}\n```"
  },
  {
    "task": "Design a system that manages user sessions and handles session timeout exceptions.",
    "code": "```dart\nclass SessionTimeoutException implements Exception {\n  final String message;\n  SessionTimeoutException(this.message);\n\n  @override\n  String toString() => 'SessionTimeoutException: $message';\n}\n\nclass UserSession {\n  final String userId;\n  DateTime lastActive;\n  final Duration timeoutDuration;\n\n  UserSession(this.userId, this.timeoutDuration)\n      : lastActive = DateTime.now();\n\n  void refreshSession() {\n    lastActive = DateTime.now();\n    print('Session refreshed for user: $userId');\n  }\n\n  void checkSession() {\n    final currentTime = DateTime.now();\n    if (currentTime.difference(lastActive) > timeoutDuration) {\n      throw SessionTimeoutException(\n          'Session timed out for user: $userId');\n    }\n    print('Session active for user: $userId');\n  }\n}\n\nvoid main() {\n  final userSession = UserSession('user123', Duration(seconds: 5));\n\n  try {\n    userSession.checkSession();\n    // Simulate some delay\n    Future.delayed(Duration(seconds: 6), () {\n      userSession.checkSession();\n    });\n  } on SessionTimeoutException catch (e) {\n    print(e);\n  }\n}\n```"
  },
  {
    "task": "Write a function that processes audio files and manages exceptions for unsupported audio formats.",
    "code": "```dart\nvoid processAudioFile(String filePath) {\n  try {\n    if (!filePath.endsWith('.mp3') && !filePath.endsWith('.wav')) {\n      throw UnsupportedAudioFormatException('Unsupported audio format: $filePath');\n    }\n    // Logic to process the audio file\n    print('Processing audio file: $filePath');\n  } catch (e) {\n    if (e is UnsupportedAudioFormatException) {\n      print('Error: ${e.message}');\n    } else {\n      print('An unexpected error occurred: $e');\n    }\n  }\n}\n\nclass UnsupportedAudioFormatException implements Exception {\n  final String message;\n  UnsupportedAudioFormatException(this.message);\n}\n\nvoid main() {\n  processAudioFile('song.mp3');\n  processAudioFile('track.flac');\n}\n```"
  },
  {
    "task": "Create a service that sends notifications and handles exceptions for unreachable destinations.",
    "code": "```dart\nclass NotificationService {\n  void sendNotification(String destination) {\n    try {\n      _sendToDestination(destination);\n      print('Notification sent to $destination');\n    } catch (e) {\n      print('Failed to send notification to $destination: $e');\n    }\n  }\n\n  void _sendToDestination(String destination) {\n    if (destination.isEmpty) {\n      throw Exception('Destination is unreachable');\n    }\n    // Simulate the sending process\n    if (destination == 'unreachable@example.com') {\n      throw Exception('Destination is unreachable');\n    }\n  }\n}\n\nvoid main() {\n  NotificationService service = NotificationService();\n\n  service.sendNotification('user@example.com'); // Success case\n  service.sendNotification('unreachable@example.com'); // Simulated unreachable destination\n  service.sendNotification(''); // Empty destination\n}\n```"
  },
  {
    "task": "Implement a program that performs data migration and manages data transformation exceptions.",
    "code": "```dart\nclass DataMigration {\n  void migrateData(List<String> data) {\n    for (var item in data) {\n      try {\n        String transformedData = transformData(item);\n        print('Migrated data: $transformedData');\n      } on FormatException catch (e) {\n        print('Data transformation error: ${e.message}');\n      } catch (e) {\n        print('Unexpected error: $e');\n      }\n    }\n  }\n\n  String transformData(String data) {\n    if (data.isEmpty) {\n      throw FormatException('Data cannot be empty');\n    }\n    // Simulated transformation logic\n    return data.toUpperCase();\n  }\n}\n\nvoid main() {\n  List<String> data = ['hello', '', 'world'];\n  DataMigration migration = DataMigration();\n  migration.migrateData(data);\n}\n```"
  },
  {
    "task": "Develop a function that processes video files and handles codec compatibility exceptions.",
    "code": "```dart\nclass CodecCompatibilityException implements Exception {\n  final String message;\n  CodecCompatibilityException(this.message);\n\n  @override\n  String toString() => 'CodecCompatibilityException: $message';\n}\n\nvoid processVideoFile(String videoFilePath) {\n  try {\n    // Simulate checking codec compatibility\n    bool isCodecCompatible = checkCodecCompatibility(videoFilePath);\n    if (!isCodecCompatible) {\n      throw CodecCompatibilityException('The codec is not compatible.');\n    }\n    // Simulate video processing\n    print('Processing video file: $videoFilePath');\n  } on CodecCompatibilityException catch (e) {\n    print(e);\n  } catch (e) {\n    print('An unexpected error occurred: $e');\n  }\n}\n\nbool checkCodecCompatibility(String videoFilePath) {\n  // Simulated codec compatibility check\n  // For demonstration, we randomly return false to simulate incompatibility\n  return videoFilePath.hashCode % 2 == 0;\n}\n\nvoid main() {\n  processVideoFile('sample_video.mp4');\n  processVideoFile('another_video.avi');\n}\n```"
  },
  {
    "task": "Write a function that manages memory allocation and catches out-of-memory exceptions.",
    "code": "```dart\nvoid manageMemoryAllocation() {\n  try {\n    List<int> largeList = List<int>.filled(1000000000, 0);\n    // Simulate memory allocation\n    print('Memory allocated successfully');\n  } catch (e) {\n    print('Caught an exception: $e');\n  }\n}\n\nvoid main() {\n  manageMemoryAllocation();\n}\n```"
  },
  {
    "task": "Create a program that processes financial transactions and handles currency conversion exceptions.",
    "code": "```dart\nclass CurrencyConversionException implements Exception {\n  final String message;\n  CurrencyConversionException(this.message);\n\n  @override\n  String toString() => 'CurrencyConversionException: $message';\n}\n\nclass Transaction {\n  final double amount;\n  final String currency;\n\n  Transaction(this.amount, this.currency);\n\n  double convertTo(String targetCurrency) {\n    if (targetCurrency != 'USD') {\n      throw CurrencyConversionException('Unsupported currency: $targetCurrency');\n    }\n    // Assume a fixed conversion rate for demonstration purposes\n    return amount * 1.1;\n  }\n}\n\nvoid processTransaction(Transaction transaction) {\n  try {\n    double convertedAmount = transaction.convertTo('USD');\n    print('Transaction processed: \\$${convertedAmount.toStringAsFixed(2)}');\n  } on CurrencyConversionException catch (e) {\n    print('Error processing transaction: $e');\n  }\n}\n\nvoid main() {\n  Transaction transaction1 = Transaction(100.0, 'EUR');\n  processTransaction(transaction1);\n\n  Transaction transaction2 = Transaction(150.0, 'GBP');\n  processTransaction(transaction2);\n}\n```"
  },
  {
    "task": "Design a function that interacts with cloud storage and manages access permission exceptions.",
    "code": "```dart\nimport 'dart:async';\n\nclass AccessPermissionException implements Exception {\n  final String message;\n  AccessPermissionException(this.message);\n  \n  @override\n  String toString() => 'AccessPermissionException: $message';\n}\n\nFuture<void> interactWithCloudStorage() async {\n  try {\n    await performStorageOperation();\n  } on AccessPermissionException catch (e) {\n    print('Access permission error: $e');\n  } catch (e) {\n    print('An unexpected error occurred: $e');\n  }\n}\n\nFuture<void> performStorageOperation() async {\n  // Simulate an access permission error\n  throw AccessPermissionException('You do not have permission to access this resource');\n}\n\nvoid main() {\n  interactWithCloudStorage();\n}\n```"
  },
  {
    "task": "Implement a script that automates deployment and handles exceptions for missing configuration files.",
    "code": "```dart\nimport 'dart:io';\n\nvoid main() {\n  try {\n    deploy();\n  } catch (e) {\n    print('Deployment failed: $e');\n  }\n}\n\nvoid deploy() {\n  final configFile = File('config.txt');\n  if (!configFile.existsSync()) {\n    throw Exception('Missing configuration file');\n  }\n  // Proceed with deployment using the configuration\n  print('Deployment successful');\n}\n```"
  },
  {
    "task": "Write a function that normalizes data and handles exceptions for invalid data ranges.",
    "code": "```dart\ndouble normalizeData(double value, double min, double max) {\n  try {\n    if (min >= max) {\n      throw Exception('Invalid range: min should be less than max.');\n    }\n    if (value < min || value > max) {\n      throw Exception('Value out of range.');\n    }\n    return (value - min) / (max - min);\n  } catch (e) {\n    print('Error: ${e.toString()}');\n    return double.nan;\n  }\n}\n```"
  },
  {
    "task": "Create a system that monitors application performance and handles threshold breach exceptions.",
    "code": "```dart\nclass ThresholdBreachException implements Exception {\n  final String message;\n  ThresholdBreachException(this.message);\n\n  @override\n  String toString() => \"ThresholdBreachException: $message\";\n}\n\nclass PerformanceMonitor {\n  final double threshold;\n  PerformanceMonitor(this.threshold);\n\n  void checkPerformance(double currentMetric) {\n    if (currentMetric > threshold) {\n      throw ThresholdBreachException(\n          'Performance threshold of $threshold exceeded with metric $currentMetric');\n    } else {\n      print('Performance is within acceptable limits.');\n    }\n  }\n}\n\nvoid main() {\n  final monitor = PerformanceMonitor(75.0);\n\n  try {\n    monitor.checkPerformance(80.0);\n  } on ThresholdBreachException catch (e) {\n    print(e);\n  }\n\n  try {\n    monitor.checkPerformance(70.0);\n  } on ThresholdBreachException catch (e) {\n    print(e);\n  }\n}\n```"
  },
  {
    "task": "Develop a program that processes social media data and manages API limit exceptions.",
    "code": "```dart\nimport 'dart:math';\n\nclass ApiLimitException implements Exception {\n  final String message;\n  ApiLimitException(this.message);\n\n  @override\n  String toString() => 'ApiLimitException: $message';\n}\n\nclass SocialMediaDataProcessor {\n  final int apiLimit = 100;\n  int apiCalls = 0;\n\n  void processData() {\n    try {\n      fetchData();\n    } on ApiLimitException catch (e) {\n      print(e);\n    } catch (e) {\n      print('An unexpected error occurred: $e');\n    }\n  }\n\n  void fetchData() {\n    if (apiCalls >= apiLimit) {\n      throw ApiLimitException('API limit reached. Cannot fetch more data.');\n    }\n    // Simulate data fetching and increment API call count\n    apiCalls += Random().nextInt(10) + 1;\n    print('Data fetched successfully. API calls: $apiCalls');\n  }\n}\n\nvoid main() {\n  final processor = SocialMediaDataProcessor();\n  for (int i = 0; i < 15; i++) {\n    processor.processData();\n  }\n}\n```"
  },
  {
    "task": "Design a function that integrates with payment gateways and handles payment failure exceptions.",
    "code": "```dart\nclass PaymentFailureException implements Exception {\n  final String message;\n  PaymentFailureException(this.message);\n\n  @override\n  String toString() => 'PaymentFailureException: $message';\n}\n\nclass PaymentGateway {\n  bool processPayment(double amount) {\n    // Simulate a payment failure\n    return false;\n  }\n}\n\nvoid integrateWithPaymentGateway(double amount) {\n  final paymentGateway = PaymentGateway();\n\n  try {\n    bool success = paymentGateway.processPayment(amount);\n    if (!success) {\n      throw PaymentFailureException('Payment failed for amount: \\$${amount}');\n    }\n    print('Payment processed successfully.');\n  } on PaymentFailureException catch (e) {\n    print(e);\n  }\n}\n\nvoid main() {\n  integrateWithPaymentGateway(100.0);\n}\n```"
  },
  {
    "task": "Write a function that backs up data and handles exceptions for unavailable storage media.",
    "code": "```dart\nvoid backupData() {\n  try {\n    // Simulate backing up data\n    bool success = performBackup();\n    if (!success) {\n      throw StorageUnavailableException('Storage media is unavailable.');\n    }\n    print('Backup successful');\n  } on StorageUnavailableException catch (e) {\n    print('Backup failed: ${e.message}');\n  } catch (e) {\n    print('An unexpected error occurred: $e');\n  }\n}\n\nbool performBackup() {\n  // Simulate a condition where the storage is unavailable\n  return false;\n}\n\nclass StorageUnavailableException implements Exception {\n  final String message;\n  StorageUnavailableException(this.message);\n}\n\nvoid main() {\n  backupData();\n}\n```"
  },
  {
    "task": "Create a tool that manages software updates and handles exceptions for version conflicts.",
    "code": "```dart\nclass VersionConflictException implements Exception {\n  final String message;\n  VersionConflictException(this.message);\n\n  @override\n  String toString() => 'VersionConflictException: $message';\n}\n\nclass SoftwareUpdateManager {\n  String currentVersion;\n\n  SoftwareUpdateManager(this.currentVersion);\n\n  void update(String newVersion) {\n    try {\n      if (_hasVersionConflict(newVersion)) {\n        throw VersionConflictException('Version $newVersion conflicts with the current version $currentVersion.');\n      }\n      _performUpdate(newVersion);\n    } catch (e) {\n      print(e);\n    }\n  }\n\n  bool _hasVersionConflict(String newVersion) {\n    // Dummy condition for version conflict\n    return currentVersion == newVersion;\n  }\n\n  void _performUpdate(String newVersion) {\n    // Logic to perform update\n    currentVersion = newVersion;\n    print('Updated to version $newVersion successfully.');\n  }\n}\n\nvoid main() {\n  var manager = SoftwareUpdateManager('1.0.0');\n  manager.update('1.0.0'); // This will cause a conflict\n  manager.update('1.0.1'); // This should succeed\n}\n```"
  },
  {
    "task": "Implement a program that performs sentiment analysis and manages exceptions for ambiguous texts.",
    "code": "```dart\nimport 'dart:math';\n\nString analyzeSentiment(String text) {\n  final random = Random();\n  final score = random.nextInt(3) - 1; // Randomly returns -1, 0, or 1\n  switch (score) {\n    case 1:\n      return 'Positive';\n    case 0:\n      return 'Neutral';\n    case -1:\n      return 'Negative';\n    default:\n      throw Exception('Unexpected sentiment score');\n  }\n}\n\nvoid main() {\n  List<String> texts = [\n    'I love sunny days!',\n    'I dislike rain.',\n    'It is what it is.'\n  ];\n\n  for (var text in texts) {\n    try {\n      String sentiment = analyzeSentiment(text);\n      print('Text: \"$text\" => Sentiment: $sentiment');\n    } catch (e) {\n      print('Text: \"$text\" => Error: ${e.toString()}');\n    }\n  }\n}\n```"
  },
  {
    "task": "Develop a function that manages user authentication and handles credential mismatch exceptions.",
    "code": "```dart\nclass AuthenticationException implements Exception {\n  final String message;\n  AuthenticationException(this.message);\n\n  @override\n  String toString() {\n    return \"AuthenticationException: $message\";\n  }\n}\n\nbool authenticateUser(String username, String password) {\n  const storedUsername = 'user123';\n  const storedPassword = 'pass123';\n\n  if (username == storedUsername && password == storedPassword) {\n    return true;\n  } else {\n    throw AuthenticationException('Credential mismatch');\n  }\n}\n\nvoid main() {\n  try {\n    bool isAuthenticated = authenticateUser('user123', 'wrongpass');\n    print('Authentication successful: $isAuthenticated');\n  } catch (e) {\n    print(e);\n  }\n}\n```"
  },
  {
    "task": "Write a program that processes geographic data and handles exceptions for invalid coordinates.",
    "code": "```dart\nclass InvalidCoordinateException implements Exception {\n  final String message;\n  InvalidCoordinateException(this.message);\n  \n  @override\n  String toString() => \"InvalidCoordinateException: $message\";\n}\n\nclass CoordinateProcessor {\n  void processCoordinates(double latitude, double longitude) {\n    try {\n      _validateCoordinates(latitude, longitude);\n      print(\"Processing coordinates: ($latitude, $longitude)\");\n      // Additional processing logic here\n    } catch (e) {\n      print(e);\n    }\n  }\n\n  void _validateCoordinates(double latitude, double longitude) {\n    if (latitude < -90 || latitude > 90) {\n      throw InvalidCoordinateException(\"Latitude $latitude is out of range.\");\n    }\n    if (longitude < -180 || longitude > 180) {\n      throw InvalidCoordinateException(\"Longitude $longitude is out of range.\");\n    }\n  }\n}\n\nvoid main() {\n  CoordinateProcessor processor = CoordinateProcessor();\n  processor.processCoordinates(45.0, 180.0); // Valid\n  processor.processCoordinates(-91.0, 50.0); // Invalid latitude\n  processor.processCoordinates(45.0, 181.0); // Invalid longitude\n}\n```"
  },
  {
    "task": "Create a script that manages network configurations and handles exceptions for invalid syntax.",
    "code": "```dart\nclass NetworkConfigurationException implements Exception {\n  final String message;\n  NetworkConfigurationException(this.message);\n\n  @override\n  String toString() => 'NetworkConfigurationException: $message';\n}\n\nclass NetworkConfigManager {\n  void parseConfig(String config) {\n    if (!isValidConfig(config)) {\n      throw NetworkConfigurationException('Invalid configuration syntax');\n    }\n    // Process config...\n  }\n\n  bool isValidConfig(String config) {\n    // Assume some logic to validate config syntax\n    return config.isNotEmpty; // Simplified check\n  }\n}\n\nvoid main() {\n  var configManager = NetworkConfigManager();\n  var config = ''; // Example of an invalid config\n\n  try {\n    configManager.parseConfig(config);\n    print('Configuration applied successfully.');\n  } catch (e) {\n    print(e);\n  }\n}\n```"
  },
  {
    "task": "Design a function that processes biometric data and handles exceptions for sensor errors.",
    "code": "```dart\nclass SensorError implements Exception {\n  final String message;\n  SensorError(this.message);\n}\n\nvoid processBiometricData() {\n  try {\n    // Simulate sensor data processing\n    bool sensorWorking = false; // Simulated sensor status\n    if (!sensorWorking) {\n      throw SensorError('Sensor error: Unable to read data');\n    }\n    print('Biometric data processed successfully.');\n  } on SensorError catch (e) {\n    print('Exception caught: ${e.message}');\n  } catch (e) {\n    print('An unexpected error occurred: $e');\n  }\n}\n\nvoid main() {\n  processBiometricData();\n}\n```"
  },
  {
    "task": "Implement a system that manages access control and handles exceptions for unauthorized access attempts.",
    "code": "```dart\nclass UnauthorizedAccessException implements Exception {\n  final String message;\n  UnauthorizedAccessException(this.message);\n\n  @override\n  String toString() => 'UnauthorizedAccessException: $message';\n}\n\nclass AccessControl {\n  final List<String> authorizedUsers;\n\n  AccessControl(this.authorizedUsers);\n\n  void grantAccess(String user) {\n    if (!authorizedUsers.contains(user)) {\n      throw UnauthorizedAccessException('Access denied for user: $user');\n    }\n    print('Access granted for user: $user');\n  }\n}\n\nvoid main() {\n  var accessControl = AccessControl(['admin', 'user1', 'user2']);\n\n  try {\n    accessControl.grantAccess('guest');\n  } on UnauthorizedAccessException catch (e) {\n    print(e);\n  }\n\n  try {\n    accessControl.grantAccess('admin');\n  } on UnauthorizedAccessException catch (e) {\n    print(e);\n  }\n}\n```"
  },
  {
    "task": "Write a function that performs load balancing and handles exceptions for unreachable nodes.",
    "code": "```dart\nimport 'dart:math';\n\nclass Node {\n  final String id;\n  final bool isReachable;\n\n  Node(this.id, this.isReachable);\n}\n\nvoid loadBalance(List<Node> nodes) {\n  for (var node in nodes) {\n    try {\n      if (!node.isReachable) {\n        throw Exception('Node ${node.id} is unreachable');\n      }\n      print('Balancing load on node ${node.id}');\n      // Simulate load balancing\n    } catch (e) {\n      print('Error: ${e}');\n    }\n  }\n}\n\nvoid main() {\n  var nodes = [\n    Node('Node1', true),\n    Node('Node2', false),\n    Node('Node3', true),\n  ];\n\n  loadBalance(nodes);\n}\n```"
  },
  {
    "task": "Create a program that simulates virtual environments and manages resource allocation exceptions.",
    "code": "```dart\nclass VirtualEnvironment {\n  String name;\n  int allocatedResources;\n\n  VirtualEnvironment(this.name, this.allocatedResources);\n\n  void allocateResources(int resources) {\n    if (resources < 0) {\n      throw ResourceAllocationException('Cannot allocate negative resources.');\n    }\n    allocatedResources += resources;\n  }\n\n  void deallocateResources(int resources) {\n    if (resources > allocatedResources) {\n      throw ResourceAllocationException('Cannot deallocate more resources than allocated.');\n    }\n    allocatedResources -= resources;\n  }\n}\n\nclass ResourceAllocationException implements Exception {\n  final String message;\n  ResourceAllocationException(this.message);\n\n  @override\n  String toString() {\n    return 'ResourceAllocationException: $message';\n  }\n}\n\nvoid main() {\n  var env1 = VirtualEnvironment('Env1', 100);\n\n  try {\n    env1.allocateResources(50);\n    print('Resources allocated successfully.');\n    env1.deallocateResources(200); // This will throw an exception\n  } on ResourceAllocationException catch (e) {\n    print(e);\n  }\n\n  try {\n    env1.allocateResources(-10); // This will also throw an exception\n  } on ResourceAllocationException catch (e) {\n    print(e);\n  }\n}\n```"
  },
  {
    "task": "Develop a tool that manages digital rights and handles exceptions for unauthorized content access.",
    "code": "```dart\nclass DigitalRightsManager {\n  List<String> authorizedUsers;\n  List<String> content;\n\n  DigitalRightsManager(this.authorizedUsers, this.content);\n\n  void accessContent(String user, int contentIndex) {\n    try {\n      if (!authorizedUsers.contains(user)) {\n        throw UnauthorizedAccessException('User $user is not authorized to access this content.');\n      }\n      if (contentIndex < 0 || contentIndex >= content.length) {\n        throw ContentNotFoundException('Content at index $contentIndex does not exist.');\n      }\n      print('Content accessed: ${content[contentIndex]}');\n    } on UnauthorizedAccessException catch (e) {\n      print('Exception: ${e.message}');\n    } on ContentNotFoundException catch (e) {\n      print('Exception: ${e.message}');\n    } catch (e) {\n      print('An unexpected error occurred: $e');\n    }\n  }\n}\n\nclass UnauthorizedAccessException implements Exception {\n  final String message;\n  UnauthorizedAccessException(this.message);\n}\n\nclass ContentNotFoundException implements Exception {\n  final String message;\n  ContentNotFoundException(this.message);\n}\n\nvoid main() {\n  var drm = DigitalRightsManager(['user1', 'user2'], ['Song A', 'Movie B']);\n  drm.accessContent('user1', 0); // Authorized access\n  drm.accessContent('user3', 1); // Unauthorized access\n  drm.accessContent('user1', 5); // Content not found\n}\n```"
  },
  {
    "task": "Design a function that synchronizes clocks and handles exceptions for time drift.",
    "code": "```dart\nimport 'dart:math';\n\nclass TimeSyncException implements Exception {\n  final String message;\n  TimeSyncException(this.message);\n\n  @override\n  String toString() => 'TimeSyncException: $message';\n}\n\nclass ClockSynchronizer {\n  int localTime;\n  int remoteTime;\n\n  ClockSynchronizer(this.localTime, this.remoteTime);\n\n  void synchronize() {\n    try {\n      int drift = _calculateDrift();\n      if (drift > 5) {\n        throw TimeSyncException('Time drift too large to synchronize');\n      }\n      localTime += drift;\n      print('Clocks synchronized. Local time: $localTime');\n    } on TimeSyncException catch (e) {\n      print(e);\n    }\n  }\n\n  int _calculateDrift() {\n    return remoteTime - localTime + Random().nextInt(10); // Simulating drift\n  }\n}\n\nvoid main() {\n  var synchronizer = ClockSynchronizer(100, 105);\n  synchronizer.synchronize();\n}\n```"
  },
  {
    "task": "Write a script that manages system backups and handles exceptions for insufficient backup space.",
    "code": "```dart\nimport 'dart:io';\n\nclass BackupManager {\n  void performBackup() {\n    try {\n      // Simulate checking for available space\n      bool hasEnoughSpace = checkBackupSpace();\n\n      if (!hasEnoughSpace) {\n        throw Exception('Insufficient backup space.');\n      }\n\n      // Simulate backup process\n      print('Backing up data...');\n      // Assume backup process here\n      print('Backup completed successfully.');\n      \n    } on Exception catch (e) {\n      print('Backup failed: ${e.toString()}');\n    }\n  }\n\n  bool checkBackupSpace() {\n    // Simulated space check logic\n    // Here, returning false to simulate insufficient space\n    return false;\n  }\n}\n\nvoid main() {\n  BackupManager backupManager = BackupManager();\n  backupManager.performBackup();\n}\n```"
  },
  {
    "task": "Create a program that processes natural language text and handles parsing exceptions.",
    "code": "```dart\nvoid main() {\n  String text = \"This is a sample text that will be processed.\";\n  \n  try {\n    processText(text);\n  } catch (e) {\n    print('An error occurred while processing the text: $e');\n  }\n}\n\nvoid processText(String text) {\n  if (text.isEmpty) {\n    throw FormatException('The text cannot be empty');\n  }\n\n  // Simulate parsing process\n  for (var word in text.split(' ')) {\n    if (word.contains(RegExp(r'[0-9]'))) {\n      throw FormatException('The text contains invalid characters: $word');\n    }\n  }\n\n  print('Text processed successfully: $text');\n}\n```"
  },
  {
    "task": "Implement a function that manages thread execution and handles race condition exceptions.",
    "code": "```dart\nimport 'dart:async';\n\nclass RaceConditionException implements Exception {\n  final String message;\n  RaceConditionException(this.message);\n\n  @override\n  String toString() => 'RaceConditionException: $message';\n}\n\nFuture<void> manageThreadExecution() async {\n  var lock = Completer<void>();\n\n  Future<void> thread1() async {\n    try {\n      if (!lock.isCompleted) {\n        throw RaceConditionException('Thread 1 encountered a race condition');\n      }\n      await Future.delayed(Duration(seconds: 1));\n      print('Thread 1 completed');\n    } catch (e) {\n      print(e);\n    }\n  }\n\n  Future<void> thread2() async {\n    try {\n      lock.complete();\n      await Future.delayed(Duration(seconds: 1));\n      print('Thread 2 completed');\n    } catch (e) {\n      print(e);\n    }\n  }\n\n  await Future.wait([thread1(), thread2()]);\n}\n\nvoid main() async {\n  await manageThreadExecution();\n}\n```"
  },
  {
    "task": "Develop a system that integrates with IoT devices and handles connectivity exceptions.",
    "code": "```dart\nclass IoTDevice {\n  final String id;\n\n  IoTDevice(this.id);\n\n  void connect() {\n    if (_simulateConnectivityIssue()) {\n      throw ConnectivityException('Failed to connect to device: $id');\n    }\n    print('Connected to device: $id');\n  }\n\n  bool _simulateConnectivityIssue() {\n    // Simulate a connectivity issue randomly\n    return DateTime.now().millisecondsSinceEpoch % 2 == 0;\n  }\n}\n\nclass ConnectivityException implements Exception {\n  final String message;\n  ConnectivityException(this.message);\n\n  @override\n  String toString() => 'ConnectivityException: $message';\n}\n\nvoid main() {\n  final devices = [\n    IoTDevice('Device1'),\n    IoTDevice('Device2'),\n    IoTDevice('Device3'),\n  ];\n\n  for (var device in devices) {\n    try {\n      device.connect();\n    } on ConnectivityException catch (e) {\n      print(e);\n    }\n  }\n}\n```"
  },
  {
    "task": "Write a function that manages application logging and handles exceptions for log overflow.",
    "code": "```dart\nclass LogOverflowException implements Exception {\n  final String message;\n  LogOverflowException(this.message);\n\n  @override\n  String toString() => 'LogOverflowException: $message';\n}\n\nclass Logger {\n  final List<String> _logs = [];\n  final int _maxLogs;\n\n  Logger(this._maxLogs);\n\n  void log(String message) {\n    try {\n      if (_logs.length >= _maxLogs) {\n        throw LogOverflowException('Maximum log entries reached.');\n      }\n      _logs.add(message);\n    } on LogOverflowException catch (e) {\n      print(e);\n    }\n  }\n\n  List<String> get logs => List.unmodifiable(_logs);\n}\n\nvoid main() {\n  final logger = Logger(5);\n\n  logger.log('Log entry 1');\n  logger.log('Log entry 2');\n  logger.log('Log entry 3');\n  logger.log('Log entry 4');\n  logger.log('Log entry 5');\n  logger.log('Log entry 6'); // This should trigger the overflow exception\n}\n```"
  },
  {
    "task": "Create a tool that visualizes data and handles exceptions for unsupported visualization types.",
    "code": "```dart\nimport 'dart:io';\n\nclass VisualizationException implements Exception {\n  final String message;\n  VisualizationException(this.message);\n}\n\nclass DataVisualizer {\n  void visualizeData(String type) {\n    try {\n      switch (type) {\n        case 'bar':\n          _visualizeBarChart();\n          break;\n        case 'pie':\n          _visualizePieChart();\n          break;\n        default:\n          throw VisualizationException('Unsupported visualization type: $type');\n      }\n    } on VisualizationException catch (e) {\n      print('Error: ${e.message}');\n    }\n  }\n\n  void _visualizeBarChart() {\n    print('Visualizing bar chart...');\n    // Implementation of bar chart visualization\n  }\n\n  void _visualizePieChart() {\n    print('Visualizing pie chart...');\n    // Implementation of pie chart visualization\n  }\n}\n\nvoid main() {\n  var visualizer = DataVisualizer();\n  visualizer.visualizeData('bar');  // Supported type\n  visualizer.visualizeData('line'); // Unsupported type\n}\n```"
  },
  {
    "task": "Design a program that performs genetic algorithm simulations and manages exception for invalid mutations.",
    "code": "```dart\nimport 'dart:math';\n\nclass GeneticAlgorithm {\n  final int populationSize;\n  final double mutationRate;\n\n  GeneticAlgorithm(this.populationSize, this.mutationRate);\n\n  void run() {\n    List<String> population = _initializePopulation();\n    try {\n      for (int generation = 0; generation < 100; generation++) {\n        population = _evolve(population);\n      }\n    } catch (e) {\n      print('Exception caught: $e');\n    }\n  }\n\n  List<String> _initializePopulation() {\n    List<String> population = [];\n    for (int i = 0; i < populationSize; i++) {\n      population.add(_randomChromosome());\n    }\n    return population;\n  }\n\n  String _randomChromosome() {\n    const charset = '01';\n    Random rand = Random();\n    return List.generate(10, (_) => charset[rand.nextInt(charset.length)]).join();\n  }\n\n  List<String> _evolve(List<String> population) {\n    List<String> newPopulation = [];\n    for (String individual in population) {\n      String mutated = _mutate(individual);\n      newPopulation.add(mutated);\n    }\n    return newPopulation;\n  }\n\n  String _mutate(String individual) {\n    Random rand = Random();\n    if (rand.nextDouble() < mutationRate) {\n      int mutationPoint = rand.nextInt(individual.length);\n      if (mutationPoint < 0 || mutationPoint >= individual.length) {\n        throw Exception('Invalid mutation point');\n      }\n      individual = individual.replaceRange(mutationPoint, mutationPoint + 1,\n          individual[mutationPoint] == '0' ? '1' : '0');\n    }\n    return individual;\n  }\n}\n\nvoid main() {\n  GeneticAlgorithm ga = GeneticAlgorithm(20, 0.05);\n  ga.run();\n}\n```"
  },
  {
    "task": "Implement a function that manages distributed transactions and handles consistency exceptions.",
    "code": "```dart\nclass ConsistencyException implements Exception {\n  final String message;\n  ConsistencyException(this.message);\n\n  @override\n  String toString() => 'ConsistencyException: $message';\n}\n\nvoid manageDistributedTransaction() {\n  try {\n    // Simulate transaction management\n    bool isConsistent = performTransaction();\n    if (!isConsistent) {\n      throw ConsistencyException('Transaction consistency failure.');\n    }\n    print('Transaction completed successfully.');\n  } on ConsistencyException catch (e) {\n    print(e);\n    // Handle the consistency exception\n    rollbackTransaction();\n  } catch (e) {\n    print('An unexpected error occurred: $e');\n  } finally {\n    cleanupResources();\n  }\n}\n\nbool performTransaction() {\n  // Placeholder for transaction logic\n  return false; // Simulating inconsistency\n}\n\nvoid rollbackTransaction() {\n  print('Rolling back transaction...');\n}\n\nvoid cleanupResources() {\n  print('Cleaning up resources...');\n}\n\nvoid main() {\n  manageDistributedTransaction();\n}\n```"
  },
  {
    "task": "Write a function that handles secure communications and manages encryption key exceptions.",
    "code": "```dart\nimport 'dart:math';\n\nclass EncryptionKeyException implements Exception {\n  final String message;\n  EncryptionKeyException(this.message);\n}\n\nString secureCommunication(String message, String key) {\n  if (key.isEmpty) {\n    throw EncryptionKeyException(\"Encryption key cannot be empty.\");\n  }\n\n  try {\n    return encryptMessage(message, key);\n  } on EncryptionKeyException catch (e) {\n    return \"Encryption failed: ${e.message}\";\n  }\n}\n\nString encryptMessage(String message, String key) {\n  if (key.length < 8) {\n    throw EncryptionKeyException(\"Encryption key is too short. Minimum length is 8.\");\n  }\n  // Simple encryption logic for illustration\n  return String.fromCharCodes(\n      message.runes.map((rune) => rune + key.length));\n}\n\nvoid main() {\n  try {\n    String encryptedMessage = secureCommunication(\"Hello, World!\", \"key123\");\n    print(\"Encrypted Message: $encryptedMessage\");\n  } catch (e) {\n    print(\"An error occurred: $e\");\n  }\n}\n```"
  },
  {
    "task": "Create a system that processes sensor data and handles out-of-range value exceptions.",
    "code": "```dart\nclass Sensor {\n  final double minValue;\n  final double maxValue;\n\n  Sensor(this.minValue, this.maxValue);\n\n  void processData(double value) {\n    try {\n      _validateValue(value);\n      print('Processing sensor data: $value');\n    } on OutOfRangeException catch (e) {\n      print(e.errorMessage());\n    }\n  }\n\n  void _validateValue(double value) {\n    if (value < minValue || value > maxValue) {\n      throw OutOfRangeException(value, minValue, maxValue);\n    }\n  }\n}\n\nclass OutOfRangeException implements Exception {\n  final double value;\n  final double minValue;\n  final double maxValue;\n\n  OutOfRangeException(this.value, this.minValue, this.maxValue);\n\n  String errorMessage() {\n    return 'Value $value is out of range! Must be between $minValue and $maxValue.';\n  }\n}\n\nvoid main() {\n  var sensor = Sensor(0.0, 100.0);\n  sensor.processData(50.0);  // Within range\n  sensor.processData(150.0); // Out of range\n}\n```"
  },
  {
    "task": "Develop a program that simulates weather patterns and handles model prediction exceptions.",
    "code": "```dart\nimport 'dart:math';\n\nclass WeatherPatternSimulator {\n  final Random _random = Random();\n\n  String simulateWeather() {\n    try {\n      return _predictWeather();\n    } catch (e) {\n      return 'Error in prediction: $e';\n    }\n  }\n\n  String _predictWeather() {\n    int chance = _random.nextInt(100);\n\n    if (chance < 10) {\n      throw Exception('Prediction model failed.');\n    } else if (chance < 30) {\n      return 'Sunny';\n    } else if (chance < 60) {\n      return 'Cloudy';\n    } else if (chance < 80) {\n      return 'Rainy';\n    } else {\n      return 'Stormy';\n    }\n  }\n}\n\nvoid main() {\n  var simulator = WeatherPatternSimulator();\n  for (var i = 0; i < 5; i++) {\n    print(simulator.simulateWeather());\n  }\n}\n```"
  },
  {
    "task": "Design a function that manages API versioning and handles backward compatibility exceptions.",
    "code": "```dart\nclass VersioningException implements Exception {\n  final String message;\n  VersioningException(this.message);\n\n  @override\n  String toString() {\n    return 'VersioningException: $message';\n  }\n}\n\nString manageApiVersion(String version) {\n  try {\n    switch (version) {\n      case '1.0':\n        return 'Handling API version 1.0';\n      case '2.0':\n        return 'Handling API version 2.0';\n      default:\n        throw VersioningException('Unsupported API version: $version');\n    }\n  } on VersioningException catch (e) {\n    return e.toString();\n  }\n}\n\nvoid main() {\n  print(manageApiVersion('1.0')); // Handling API version 1.0\n  print(manageApiVersion('2.0')); // Handling API version 2.0\n  print(manageApiVersion('3.0')); // VersioningException: Unsupported API version: 3.0\n}\n```"
  },
  {
    "task": "Write a tool that converts character encodings and handles unsupported encoding exceptions.",
    "code": "```dart\nimport 'dart:convert';\nimport 'dart:io';\n\nString convertEncoding(String input, Encoding fromEncoding, Encoding toEncoding) {\n  try {\n    List<int> bytes = fromEncoding.encode(input);\n    return toEncoding.decode(bytes);\n  } on UnsupportedError catch (e) {\n    throw UnsupportedEncodingException('Unsupported Encoding: ${e.message}');\n  } catch (e) {\n    throw Exception('An error occurred during encoding conversion: $e');\n  }\n}\n\nclass UnsupportedEncodingException implements Exception {\n  final String message;\n  UnsupportedEncodingException(this.message);\n\n  @override\n  String toString() => message;\n}\n\nvoid main() {\n  String input = 'Hello, World!';\n  try {\n    String output = convertEncoding(input, latin1, utf8);\n    print(output);\n  } on UnsupportedEncodingException catch (e) {\n    print('Error: $e');\n  } catch (e) {\n    print('An unexpected error occurred: $e');\n  }\n}\n```"
  },
  {
    "task": "Create a program that handles dynamic content generation and manages template parsing exceptions.",
    "code": "```dart\nvoid main() {\n  try {\n    String template = \"Hello, {{name}}!\";\n    Map<String, String> data = {'name': 'Alice'};\n\n    String result = parseTemplate(template, data);\n    print(result);\n  } catch (e) {\n    print('An error occurred: $e');\n  }\n}\n\nString parseTemplate(String template, Map<String, String> data) {\n  RegExp exp = RegExp(r'\\{\\{(\\w+)\\}\\}');\n  return template.replaceAllMapped(exp, (Match match) {\n    String key = match[1]!;\n    if (!data.containsKey(key)) {\n      throw Exception('Missing data for key: $key');\n    }\n    return data[key]!;\n  });\n}\n```"
  },
  {
    "task": "Implement a script that schedules automated tests and handles exceptions for missing test cases.",
    "code": "```dart\nimport 'dart:async';\n\nclass MissingTestCaseException implements Exception {\n  final String message;\n  MissingTestCaseException(this.message);\n\n  @override\n  String toString() => 'MissingTestCaseException: $message';\n}\n\nclass TestScheduler {\n  final List<String> testCases;\n\n  TestScheduler(this.testCases);\n\n  Future<void> runTests() async {\n    for (var testCase in testCases) {\n      try {\n        await scheduleTest(testCase);\n      } on MissingTestCaseException catch (e) {\n        print(e);\n      }\n    }\n  }\n\n  Future<void> scheduleTest(String testCase) async {\n    if (testCase.isEmpty) {\n      throw MissingTestCaseException('Test case is missing.');\n    }\n    // Simulate running the test\n    print('Running test: $testCase');\n    await Future.delayed(Duration(seconds: 1));\n  }\n}\n\nvoid main() {\n  var testCases = ['Test1', '', 'Test2', 'Test3'];\n  var testScheduler = TestScheduler(testCases);\n  testScheduler.runTests();\n}\n```"
  },
  {
    "task": "Develop a system that manages virtual machine instances and handles provisioning exceptions.",
    "code": "```dart\nclass VirtualMachine {\n  final String id;\n  bool isProvisioned;\n\n  VirtualMachine(this.id) : isProvisioned = false;\n\n  void provision() {\n    if (isProvisioned) {\n      throw ProvisioningException('VM $id is already provisioned.');\n    }\n    // Simulate provisioning logic here\n    isProvisioned = true;\n    print('VM $id provisioned successfully.');\n  }\n}\n\nclass ProvisioningException implements Exception {\n  final String message;\n  ProvisioningException(this.message);\n\n  @override\n  String toString() => 'ProvisioningException: $message';\n}\n\nclass VMManager {\n  final List<VirtualMachine> vms;\n\n  VMManager(this.vms);\n\n  void provisionVM(String id) {\n    try {\n      final vm = vms.firstWhere((vm) => vm.id == id);\n      vm.provision();\n    } on ProvisioningException catch (e) {\n      print(e);\n    } catch (e) {\n      print('An unexpected error occurred: $e');\n    }\n  }\n}\n\nvoid main() {\n  final vm1 = VirtualMachine('vm1');\n  final vm2 = VirtualMachine('vm2');\n  final manager = VMManager([vm1, vm2]);\n\n  manager.provisionVM('vm1'); // Provisioning should succeed\n  manager.provisionVM('vm1'); // This should raise a ProvisioningException\n  manager.provisionVM('vm3'); // This should raise a generic Exception\n}\n```"
  },
  {
    "task": "Write a function that processes credit scores and handles exceptions for missing credit history.",
    "code": "```dart\nvoid main() {\n  List<int?> creditScores = [750, null, 680, 720, null, 640];\n\n  for (var score in creditScores) {\n    try {\n      processCreditScore(score);\n    } catch (e) {\n      print(e);\n    }\n  }\n}\n\nvoid processCreditScore(int? score) {\n  if (score == null) {\n    throw Exception('Missing credit history');\n  }\n  print('Processing credit score: $score');\n}\n```"
  },
  {
    "task": "Create a tool that manages digital certificates and handles expiration exceptions.",
    "code": "```dart\nclass Certificate {\n  String name;\n  DateTime expirationDate;\n\n  Certificate(this.name, this.expirationDate);\n}\n\nclass CertificateExpiredException implements Exception {\n  String cause;\n  CertificateExpiredException(this.cause);\n}\n\nclass CertificateManager {\n  List<Certificate> certificates = [];\n\n  void addCertificate(Certificate certificate) {\n    certificates.add(certificate);\n  }\n\n  void checkCertificateExpiration(String certificateName) {\n    try {\n      Certificate cert = certificates.firstWhere(\n          (cert) => cert.name == certificateName,\n          orElse: () => throw CertificateExpiredException(\n              'Certificate not found: $certificateName'));\n\n      if (DateTime.now().isAfter(cert.expirationDate)) {\n        throw CertificateExpiredException(\n            'Certificate expired: $certificateName');\n      }\n      print('Certificate is valid: $certificateName');\n    } on CertificateExpiredException catch (e) {\n      print('Exception: ${e.cause}');\n    }\n  }\n}\n\nvoid main() {\n  CertificateManager manager = CertificateManager();\n  manager.addCertificate(\n      Certificate('Cert1', DateTime.now().add(Duration(days: 30))));\n  manager.addCertificate(\n      Certificate('Cert2', DateTime.now().subtract(Duration(days: 1))));\n\n  manager.checkCertificateExpiration('Cert1');\n  manager.checkCertificateExpiration('Cert2');\n  manager.checkCertificateExpiration('Cert3');\n}\n```"
  },
  {
    "task": "Design a program that processes genome sequences and handles exceptions for sequence alignment.",
    "code": "```dart\nvoid main() {\n  try {\n    String sequence1 = \"AGCTGAC\";\n    String sequence2 = \"AGCTAAC\";\n    int alignmentScore = alignSequences(sequence1, sequence2);\n    print('Alignment Score: $alignmentScore');\n  } catch (e) {\n    print('Exception caught: $e');\n  }\n}\n\nint alignSequences(String seq1, String seq2) {\n  if (seq1.isEmpty || seq2.isEmpty) {\n    throw Exception('Sequences must not be empty.');\n  }\n  if (seq1.length != seq2.length) {\n    throw Exception('Sequences must be of equal length.');\n  }\n\n  int score = 0;\n  for (int i = 0; i < seq1.length; i++) {\n    if (seq1[i] == seq2[i]) {\n      score++;\n    }\n  }\n  return score;\n}\n```"
  }
]