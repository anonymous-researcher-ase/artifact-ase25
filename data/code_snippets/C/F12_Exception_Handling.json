[
  {
    "task": "Write a function that reads a file and handles the exception if the file is not found.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid readFile(const char *filename) {\n    FILE *file = fopen(filename, \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return;\n    }\n    \n    // Assuming we just want to read and print the content\n    char ch;\n    while ((ch = fgetc(file)) != EOF) {\n        putchar(ch);\n    }\n    \n    fclose(file);\n}\n```"
  },
  {
    "task": "Create a program that divides two numbers and catches any division by zero errors.",
    "code": "```c\n#include <stdio.h>\n#include <setjmp.h>\n\njmp_buf buffer;\n\nvoid divide(int a, int b) {\n    if (b == 0) {\n        longjmp(buffer, 1);\n    }\n    printf(\"Result: %d\\n\", a / b);\n}\n\nint main() {\n    int num1, num2;\n    printf(\"Enter two numbers: \");\n    scanf(\"%d %d\", &num1, &num2);\n\n    if (setjmp(buffer) == 0) {\n        divide(num1, num2);\n    } else {\n        printf(\"Error: Division by zero!\\n\");\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Design a function to parse an integer from a string and manage invalid input exceptions.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n\nint parse_integer(const char *str) {\n    char *endptr;\n    int number;\n\n    errno = 0; // Clear errno before calling strtol\n    number = strtol(str, &endptr, 10);\n\n    // Check for various possible errors\n    if ((errno == ERANGE && (number == LONG_MAX || number == LONG_MIN))\n        || (errno != 0 && number == 0)) {\n        perror(\"strtol\");\n        return -1;\n    }\n\n    if (endptr == str) {\n        fprintf(stderr, \"No digits were found\\n\");\n        return -1;\n    }\n\n    // Successful conversion\n    return number;\n}\n\nint main() {\n    const char *test_string = \"1234\";\n    int result = parse_integer(test_string);\n    if (result != -1) {\n        printf(\"Parsed number: %d\\n\", result);\n    } else {\n        printf(\"Failed to parse number.\\n\");\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Implement an API call and catch exceptions related to network errors or timeouts.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <setjmp.h>\n#include <curl/curl.h>\n\njmp_buf env;\n\nvoid handleError(const char *error) {\n    printf(\"Error: %s\\n\", error);\n    longjmp(env, 1);\n}\n\nvoid makeAPICall(const char *url) {\n    CURL *curl;\n    CURLcode res;\n\n    curl_global_init(CURL_GLOBAL_DEFAULT);\n    curl = curl_easy_init();\n\n    if(curl) {\n        if (setjmp(env) == 0) {\n            curl_easy_setopt(curl, CURLOPT_URL, url);\n            curl_easy_setopt(curl, CURLOPT_TIMEOUT, 5L);\n\n            res = curl_easy_perform(curl);\n\n            if(res != CURLE_OK) {\n                handleError(curl_easy_strerror(res));\n            } else {\n                printf(\"API call successful.\\n\");\n            }\n        }\n        curl_easy_cleanup(curl);\n    } else {\n        handleError(\"Failed to initialize CURL\");\n    }\n\n    curl_global_cleanup();\n}\n\nint main(void) {\n    makeAPICall(\"https://api.example.com/data\");\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a program that opens a database connection and handles any connection failure exceptions.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sqlite3.h>\n\nint main() {\n    sqlite3 *db;\n    int rc;\n\n    rc = sqlite3_open(\"test.db\", &db);\n\n    if (rc) {\n        fprintf(stderr, \"Can't open database: %s\\n\", sqlite3_errmsg(db));\n        sqlite3_close(db);\n        return EXIT_FAILURE;\n    } else {\n        fprintf(stdout, \"Opened database successfully\\n\");\n    }\n\n    sqlite3_close(db);\n    return EXIT_SUCCESS;\n}\n```"
  },
  {
    "task": "Write a function that accesses an array by index and catches out-of-bounds exceptions.",
    "code": "```c\n#include <stdio.h>\n#include <setjmp.h>\n\njmp_buf env;\n\nvoid handle_exception(int exception_type) {\n    if (exception_type == 1) {\n        printf(\"Array index out of bounds exception caught.\\n\");\n    }\n}\n\nvoid access_array(int *array, int size, int index) {\n    if (setjmp(env) == 0) {\n        if (index < 0 || index >= size) {\n            longjmp(env, 1);\n        }\n        printf(\"Accessing array at index %d: %d\\n\", index, array[index]);\n    } else {\n        handle_exception(1);\n    }\n}\n\nint main() {\n    int arr[] = {10, 20, 30, 40, 50};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    \n    access_array(arr, size, 2);  // Valid index\n    access_array(arr, size, 5);  // Invalid index\n    return 0;\n}\n```"
  },
  {
    "task": "Create a function that converts a string to a date object and manages format exceptions.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\nvoid handle_date_format_exception(const char *message) {\n    fprintf(stderr, \"Date format exception: %s\\n\", message);\n    exit(EXIT_FAILURE);\n}\n\nstruct tm convert_string_to_date(const char *date_str) {\n    struct tm date;\n    memset(&date, 0, sizeof(struct tm));\n    char *result = strptime(date_str, \"%Y-%m-%d\", &date);\n    if (result == NULL) {\n        handle_date_format_exception(\"Invalid date format. Expected format: YYYY-MM-DD.\");\n    }\n    return date;\n}\n\nint main() {\n    const char *date_str = \"2023-12-31\";\n    struct tm date = convert_string_to_date(date_str);\n    printf(\"Converted date: %d-%02d-%02d\\n\", date.tm_year + 1900, date.tm_mon + 1, date.tm_mday);\n    return 0;\n}\n```"
  },
  {
    "task": "Design a program that writes data to a file and catches any file permission exceptions.",
    "code": "```c\n#include <stdio.h>\n#include <errno.h>\n#include <string.h>\n\nint main() {\n    FILE *file;\n    file = fopen(\"output.txt\", \"w\");\n\n    if (file == NULL) {\n        if (errno == EACCES) {\n            fprintf(stderr, \"File permission error: %s\\n\", strerror(errno));\n        } else {\n            fprintf(stderr, \"Error opening file: %s\\n\", strerror(errno));\n        }\n        return 1;\n    }\n\n    fprintf(file, \"Writing some data to the file.\\n\");\n    fclose(file);\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a module that retrieves data from a URL and handles malformed URL exceptions.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <curl/curl.h>\n\nvoid handleError(const char *errorMessage) {\n    fprintf(stderr, \"Error: %s\\n\", errorMessage);\n    exit(EXIT_FAILURE);\n}\n\nvoid fetchDataFromURL(const char *url) {\n    CURL *curl;\n    CURLcode res;\n\n    curl_global_init(CURL_GLOBAL_DEFAULT);\n    curl = curl_easy_init();\n\n    if (!curl) {\n        handleError(\"Failed to initialize CURL.\");\n    }\n\n    curl_easy_setopt(curl, CURLOPT_URL, url);\n    \n    res = curl_easy_perform(curl);\n\n    if (res != CURLE_OK) {\n        if (res == CURLE_URL_MALFORMAT) {\n            handleError(\"Malformed URL.\");\n        } else {\n            handleError(curl_easy_strerror(res));\n        }\n    }\n\n    curl_easy_cleanup(curl);\n    curl_global_cleanup();\n}\n\nint main() {\n    const char *url = \"http://example.com\";\n    fetchDataFromURL(url);\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function to calculate the square root of a number and catch any negative input exceptions.",
    "code": "```c\n#include <stdio.h>\n#include <math.h>\n#include <setjmp.h>\n\njmp_buf jumpBuffer;\n\ndouble calculateSquareRoot(double number) {\n    if (number < 0) {\n        longjmp(jumpBuffer, 1);\n    }\n    return sqrt(number);\n}\n\nint main() {\n    double number;\n    printf(\"Enter a number: \");\n    scanf(\"%lf\", &number);\n\n    if (setjmp(jumpBuffer) == 0) {\n        double result = calculateSquareRoot(number);\n        printf(\"Square root: %.2f\\n\", result);\n    } else {\n        printf(\"Exception: Negative input is not allowed.\\n\");\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a program that sends an email and manages exceptions for invalid email addresses.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n#include <regex.h>\n\nint isValidEmail(const char *email) {\n    regex_t regex;\n    int reti;\n    reti = regcomp(&regex, \"^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Z|a-z]{2,}$\", REG_EXTENDED);\n    if (reti) {\n        return 0;\n    }\n    reti = regexec(&regex, email, 0, NULL, 0);\n    regfree(&regex);\n    return reti == 0;\n}\n\nvoid sendEmail(const char *email) {\n    // Simulate sending an email\n    printf(\"Email sent to %s\\n\", email);\n}\n\nvoid handleException(const char *error) {\n    printf(\"Error: %s\\n\", error);\n}\n\nint main() {\n    const char *email = \"example@domain.com\"; // Replace with user input if needed\n\n    if (isValidEmail(email)) {\n        sendEmail(email);\n    } else {\n        handleException(\"Invalid email address\");\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a calculator application that handles invalid operations gracefully.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n\ndouble calculate(double a, double b, char operator) {\n    switch (operator) {\n        case '+': return a + b;\n        case '-': return a - b;\n        case '*': return a * b;\n        case '/':\n            if (b == 0) {\n                errno = EDOM; // Set errno for division by zero\n                return 0;\n            }\n            return a / b;\n        default:\n            errno = EINVAL; // Set errno for invalid operator\n            return 0;\n    }\n}\n\nint main() {\n    double num1, num2, result;\n    char operator;\n    \n    printf(\"Enter first number: \");\n    if (scanf(\"%lf\", &num1) != 1) {\n        fprintf(stderr, \"Invalid input for first number.\\n\");\n        return EXIT_FAILURE;\n    }\n    \n    printf(\"Enter an operator (+, -, *, /): \");\n    scanf(\" %c\", &operator);\n    \n    printf(\"Enter second number: \");\n    if (scanf(\"%lf\", &num2) != 1) {\n        fprintf(stderr, \"Invalid input for second number.\\n\");\n        return EXIT_FAILURE;\n    }\n    \n    result = calculate(num1, num2, operator);\n    \n    if (errno == EDOM) {\n        fprintf(stderr, \"Error: Division by zero.\\n\");\n        return EXIT_FAILURE;\n    } else if (errno == EINVAL) {\n        fprintf(stderr, \"Error: Invalid operator.\\n\");\n        return EXIT_FAILURE;\n    }\n    \n    printf(\"Result: %.2lf\\n\", result);\n    return EXIT_SUCCESS;\n}\n```"
  },
  {
    "task": "Design a function that tries to parse JSON data and catches parsing errors.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <jansson.h> // Include the Jansson library for JSON parsing\n\nvoid parse_json(const char *json_data) {\n    json_error_t error;\n    json_t *root = json_loads(json_data, 0, &error);\n\n    if (!root) {\n        fprintf(stderr, \"Error parsing JSON: %s\\n\", error.text);\n        return;\n    }\n\n    // If needed, process the JSON data here\n\n    json_decref(root);\n}\n\nint main() {\n    const char *json_data = \"{\\\"key\\\": \\\"value\\\"}\"; // Example JSON data\n    parse_json(json_data);\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a system that processes user input and handles any type conversion exceptions.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n\nint main() {\n    char input[256];\n    char *endptr;\n    long value;\n    \n    printf(\"Enter a number: \");\n    if (fgets(input, sizeof(input), stdin) != NULL) {\n        errno = 0;  // Reset errno before conversion\n        value = strtol(input, &endptr, 10);\n\n        // Check for errors: no digits were found or out of range\n        if (endptr == input || *endptr != '\\n' || errno == ERANGE) {\n            printf(\"Invalid input or out of range. Please enter a valid number.\\n\");\n        } else {\n            printf(\"You entered: %ld\\n\", value);\n        }\n    } else {\n        printf(\"Error reading input.\\n\");\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that fetches data from a database and manages exceptions for missing records.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    int id;\n    char name[50];\n} Record;\n\ntypedef struct {\n    Record *records;\n    size_t size;\n} Database;\n\nRecord fetchRecord(Database *db, int id) {\n    for (size_t i = 0; i < db->size; i++) {\n        if (db->records[i].id == id) {\n            return db->records[i];\n        }\n    }\n    fprintf(stderr, \"Error: Record with id %d not found.\\n\", id);\n    exit(EXIT_FAILURE);\n}\n\nint main() {\n    Database db;\n    Record records[] = {{1, \"Alice\"}, {2, \"Bob\"}, {3, \"Charlie\"}};\n    db.records = records;\n    db.size = 3;\n\n    Record record = fetchRecord(&db, 2);\n    printf(\"Fetched Record: %d, %s\\n\", record.id, record.name);\n\n    record = fetchRecord(&db, 5); // This will trigger an error\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a program that connects to a remote server and handles authentication failure exceptions.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define HOST \"example.com\"\n#define PORT 80\n\ntypedef enum {\n    SUCCESS,\n    AUTH_FAILURE,\n    CONNECTION_ERROR\n} ErrorType;\n\nErrorType connect_to_server(const char* host, int port) {\n    // Simulated connection logic\n    return AUTH_FAILURE; // Simulate an authentication failure\n}\n\nint main() {\n    ErrorType result = connect_to_server(HOST, PORT);\n\n    if (result == AUTH_FAILURE) {\n        fprintf(stderr, \"Authentication failed. Please check your credentials.\\n\");\n        exit(EXIT_FAILURE);\n    } else if (result == CONNECTION_ERROR) {\n        fprintf(stderr, \"Failed to connect to the server. Please try again later.\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    printf(\"Connected to the server successfully.\\n\");\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a function to download a file from the internet and handle file not found exceptions.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <curl/curl.h>\n\nvoid download_file(const char *url, const char *output_file) {\n    CURL *curl;\n    FILE *fp;\n    CURLcode res;\n\n    curl = curl_easy_init();\n    if (curl) {\n        fp = fopen(output_file, \"wb\");\n        if (!fp) {\n            fprintf(stderr, \"Error: Could not open file for writing\\n\");\n            return;\n        }\n\n        curl_easy_setopt(curl, CURLOPT_URL, url);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, fp);\n        curl_easy_setopt(curl, CURLOPT_FAILONERROR, 1L);\n\n        res = curl_easy_perform(curl);\n        if (res != CURLE_OK) {\n            fprintf(stderr, \"Error: %s\\n\", curl_easy_strerror(res));\n            if (res == CURLE_HTTP_RETURNED_ERROR) {\n                long http_code = 0;\n                curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);\n                if (http_code == 404) {\n                    fprintf(stderr, \"Error: File not found (HTTP 404)\\n\");\n                }\n            }\n        }\n\n        fclose(fp);\n        curl_easy_cleanup(curl);\n    } else {\n        fprintf(stderr, \"Error: Could not initialize CURL\\n\");\n    }\n}\n\nint main() {\n    const char *url = \"http://example.com/file.txt\";\n    const char *output_file = \"downloaded_file.txt\";\n    download_file(url, output_file);\n    return 0;\n}\n```"
  },
  {
    "task": "Design a program that attempts to connect to an API and handles rate limit exceptions.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <curl/curl.h>\n\n#define RATE_LIMIT_ERROR_CODE 429\n\nvoid connect_to_api() {\n    CURL *curl;\n    CURLcode res;\n    long response_code;\n\n    curl_global_init(CURL_GLOBAL_DEFAULT);\n    curl = curl_easy_init();\n\n    if(curl) {\n        curl_easy_setopt(curl, CURLOPT_URL, \"http://example.com/api\");\n\n        res = curl_easy_perform(curl);\n\n        if(res != CURLE_OK) {\n            fprintf(stderr, \"curl_easy_perform() failed: %s\\n\", curl_easy_strerror(res));\n        } else {\n            curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &response_code);\n            if (response_code == RATE_LIMIT_ERROR_CODE) {\n                fprintf(stderr, \"Rate limit exceeded. Please try again later.\\n\");\n            } else {\n                printf(\"Connected successfully, response code: %ld\\n\", response_code);\n            }\n        }\n        curl_easy_cleanup(curl);\n    }\n\n    curl_global_cleanup();\n}\n\nint main() {\n    connect_to_api();\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that reads from a configuration file and manages key not found exceptions.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_LINE_LENGTH 256\n\nvoid handle_error(const char *error_message) {\n    fprintf(stderr, \"Error: %s\\n\", error_message);\n    exit(EXIT_FAILURE);\n}\n\nchar *read_config(const char *filename, const char *key) {\n    FILE *file = fopen(filename, \"r\");\n    if (!file) {\n        handle_error(\"Could not open configuration file.\");\n    }\n\n    char *value = NULL;\n    char line[MAX_LINE_LENGTH];\n\n    while (fgets(line, sizeof(line), file)) {\n        char *equal_sign = strchr(line, '=');\n        if (equal_sign) {\n            *equal_sign = '\\0';\n            char *found_key = line;\n            char *found_value = equal_sign + 1;\n            if (strcmp(found_key, key) == 0) {\n                size_t len = strlen(found_value);\n                if (len > 0 && found_value[len - 1] == '\\n') {\n                    found_value[len - 1] = '\\0'; // Remove newline character\n                }\n                value = malloc(strlen(found_value) + 1);\n                if (!value) {\n                    fclose(file);\n                    handle_error(\"Memory allocation failed.\");\n                }\n                strcpy(value, found_value);\n                break;\n            }\n        }\n    }\n\n    fclose(file);\n\n    if (!value) {\n        handle_error(\"Key not found in configuration file.\");\n    }\n\n    return value;\n}\n\nint main() {\n    const char *filename = \"config.txt\";\n    const char *key = \"desired_key\";\n    char *value = read_config(filename, key);\n    printf(\"Value: %s\\n\", value);\n    free(value);\n    return 0;\n}\n```"
  },
  {
    "task": "Create an application that processes a list of tasks and catches any task execution exceptions.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <setjmp.h>\n\njmp_buf jumpBuffer;\n\nvoid processTask(int taskId) {\n    if (taskId % 2 == 0) { // Simulate an exception for even task IDs\n        printf(\"Exception: Error processing task %d\\n\", taskId);\n        longjmp(jumpBuffer, 1);\n    } else {\n        printf(\"Task %d processed successfully.\\n\", taskId);\n    }\n}\n\nint main() {\n    int taskIds[] = {1, 2, 3, 4, 5};\n    int numTasks = sizeof(taskIds) / sizeof(taskIds[0]);\n\n    for (int i = 0; i < numTasks; i++) {\n        if (setjmp(jumpBuffer) == 0) {\n            processTask(taskIds[i]);\n        } else {\n            printf(\"Handling exception for task %d\\n\", taskIds[i]);\n        }\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a program that performs batch processing and handles individual item processing exceptions.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <setjmp.h>\n\n#define NUM_ITEMS 10\n\njmp_buf buf;\n\nvoid processItem(int item) {\n    if (item % 3 == 0) {\n        // Simulate an exception for demonstration\n        printf(\"Exception occurred while processing item %d\\n\", item);\n        longjmp(buf, 1);\n    }\n    printf(\"Processed item %d successfully\\n\", item);\n}\n\nint main() {\n    int items[NUM_ITEMS];\n    for (int i = 0; i < NUM_ITEMS; i++) {\n        items[i] = i + 1;\n    }\n\n    for (int i = 0; i < NUM_ITEMS; i++) {\n        if (setjmp(buf) == 0) {\n            processItem(items[i]);\n        } else {\n            printf(\"Handling exception for item %d\\n\", items[i]);\n        }\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a function that performs mathematical operations and catches arithmetic exceptions.",
    "code": "```c\n#include <stdio.h>\n#include <setjmp.h>\n\njmp_buf buffer;\n\nvoid handle_arithmetic_exception() {\n    printf(\"Arithmetic exception caught!\\n\");\n    longjmp(buffer, 1);\n}\n\ndouble perform_operation(double a, double b, char op) {\n    double result = 0.0;\n    if (setjmp(buffer) == 0) {\n        switch (op) {\n            case '+':\n                result = a + b;\n                break;\n            case '-':\n                result = a - b;\n                break;\n            case '*':\n                result = a * b;\n                break;\n            case '/':\n                if (b == 0) {\n                    handle_arithmetic_exception();\n                } else {\n                    result = a / b;\n                }\n                break;\n            default:\n                printf(\"Unsupported operation!\\n\");\n                break;\n        }\n    }\n    return result;\n}\n\nint main() {\n    double a = 10.0;\n    double b = 0.0;\n    char op = '/';\n    \n    double result = perform_operation(a, b, op);\n    if (result != 0.0) {\n        printf(\"Result: %lf\\n\", result);\n    }\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Write a program that logs error messages when exceptions occur during data processing.",
    "code": "```c\n#include <stdio.h>\n#include <setjmp.h>\n\njmp_buf env;\n\nvoid processData(int data) {\n    if (data < 0) {\n        longjmp(env, 1); // Simulate an exception for negative data\n    }\n    printf(\"Data processed successfully: %d\\n\", data);\n}\n\nint main() {\n    int data = -5;\n\n    if (setjmp(env)) {\n        // Exception handling block\n        printf(\"Error: Negative data encountered!\\n\");\n    } else {\n        // Normal processing block\n        processData(data);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a script that monitors system resources and handles exceptions when limits are exceeded.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\n\nvoid handle_exception(int signum) {\n    if (signum == SIGUSR1) {\n        printf(\"Exception: CPU usage limit exceeded!\\n\");\n    } else if (signum == SIGUSR2) {\n        printf(\"Exception: Memory usage limit exceeded!\\n\");\n    }\n}\n\nvoid monitor_resources() {\n    int cpu_usage = 0;\n    int memory_usage = 0;\n    \n    while (1) {\n        cpu_usage = rand() % 100; // Simulate CPU usage percentage\n        memory_usage = rand() % 100; // Simulate Memory usage percentage\n        \n        if (cpu_usage > 80) {\n            raise(SIGUSR1);\n        }\n        \n        if (memory_usage > 80) {\n            raise(SIGUSR2);\n        }\n        \n        sleep(1);\n    }\n}\n\nint main() {\n    signal(SIGUSR1, handle_exception);\n    signal(SIGUSR2, handle_exception);\n    \n    monitor_resources();\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Design a function that validates user input and manages any format exceptions.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid validateInput(const char *input) {\n    char *endptr;\n    long value = strtol(input, &endptr, 10);\n\n    if (*endptr != '\\0') {\n        fprintf(stderr, \"Format exception: Input is not a valid integer\\n\");\n        return;\n    }\n\n    printf(\"Valid input: %ld\\n\", value);\n}\n\nint main() {\n    char input[100];\n\n    printf(\"Enter an integer: \");\n    if (fgets(input, sizeof(input), stdin) != NULL) {\n        validateInput(input);\n    } else {\n        fprintf(stderr, \"Error reading input\\n\");\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a service that interacts with third-party APIs and handles unexpected response exceptions.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <curl/curl.h>\n\n#define API_URL \"https://api.example.com/data\"\n\nvoid handle_exception(const char *error_message) {\n    fprintf(stderr, \"Exception occurred: %s\\n\", error_message);\n}\n\nsize_t write_callback(void *ptr, size_t size, size_t nmemb, void *stream) {\n    printf(\"%s\", (char *)ptr);\n    return size * nmemb;\n}\n\nvoid fetch_data_from_api() {\n    CURL *curl;\n    CURLcode res;\n\n    curl = curl_easy_init();\n    if (!curl) {\n        handle_exception(\"Failed to initialize CURL\");\n        return;\n    }\n\n    curl_easy_setopt(curl, CURLOPT_URL, API_URL);\n    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);\n\n    res = curl_easy_perform(curl);\n    if (res != CURLE_OK) {\n        handle_exception(curl_easy_strerror(res));\n    }\n\n    curl_easy_cleanup(curl);\n}\n\nint main() {\n    fetch_data_from_api();\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that uploads files to a server and handles exceptions for unsupported file types.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool isSupportedFileType(const char *fileName) {\n    const char *supportedExtensions[] = {\".txt\", \".jpg\", \".png\", \".pdf\"};\n    size_t numSupportedExtensions = sizeof(supportedExtensions) / sizeof(supportedExtensions[0]);\n    \n    for (size_t i = 0; i < numSupportedExtensions; i++) {\n        if (strstr(fileName, supportedExtensions[i]) != NULL) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid uploadFileToServer(const char *fileName) {\n    if (!isSupportedFileType(fileName)) {\n        fprintf(stderr, \"Exception: Unsupported file type for file '%s'\\n\", fileName);\n        return;\n    }\n\n    // Simulate file upload\n    printf(\"Uploading file '%s' to server...\\n\", fileName);\n    // Actual file upload logic would go here\n}\n\nint main() {\n    uploadFileToServer(\"document.txt\");\n    uploadFileToServer(\"image.gif\");\n    return 0;\n}\n```"
  },
  {
    "task": "Create a program that simulates network traffic and manages packet loss exceptions.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n#define PACKET_COUNT 10\n#define PACKET_LOSS_PROBABILITY 0.2\n\nvoid send_packet(int packet_id) {\n    // Simulate packet loss\n    if ((double)rand() / RAND_MAX < PACKET_LOSS_PROBABILITY) {\n        // Simulate an exception by exiting the function early\n        throw_packet_loss_exception(packet_id);\n        return;\n    }\n    printf(\"Packet %d sent successfully.\\n\", packet_id);\n}\n\nvoid throw_packet_loss_exception(int packet_id) {\n    printf(\"Exception: Packet %d lost during transmission.\\n\", packet_id);\n}\n\nint main() {\n    srand(time(NULL));\n\n    for (int i = 0; i < PACKET_COUNT; i++) {\n        send_packet(i);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a function that processes XML data and catches any structural exceptions.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <setjmp.h>\n\njmp_buf jump_buffer;\n\nvoid processXMLData(const char *xmlData) {\n    if (setjmp(jump_buffer) == 0) {\n        // Simulate XML processing\n        if (strstr(xmlData, \"<error>\") != NULL) {\n            // Simulate an error\n            longjmp(jump_buffer, 1);\n        }\n        printf(\"XML processed successfully.\\n\");\n    } else {\n        printf(\"Caught a structural exception while processing XML.\\n\");\n    }\n}\n\nint main() {\n    const char *validXML = \"<data><item>Value</item></data>\";\n    const char *invalidXML = \"<data><error>Invalid</error></data>\";\n\n    printf(\"Processing valid XML:\\n\");\n    processXMLData(validXML);\n\n    printf(\"\\nProcessing invalid XML:\\n\");\n    processXMLData(invalidXML);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Design a program that handles exceptions when accessing environment variables.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    const char *env_var = \"MY_ENV_VAR\";\n    char *value = getenv(env_var);\n\n    if (value == NULL) {\n        fprintf(stderr, \"Error: Environment variable %s not found.\\n\", env_var);\n        return EXIT_FAILURE;\n    }\n\n    printf(\"Environment variable %s has value: %s\\n\", env_var, value);\n    return EXIT_SUCCESS;\n}\n```"
  },
  {
    "task": "Write a function that calculates factorial and manages exceptions for negative input values.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint factorial(int n) {\n    if (n < 0) {\n        fprintf(stderr, \"Error: Negative input for factorial\\n\");\n        exit(EXIT_FAILURE);\n    }\n    if (n == 0 || n == 1) return 1;\n    return n * factorial(n - 1);\n}\n\nint main() {\n    int number = -5; // Example input\n    int result = factorial(number);\n    printf(\"Factorial: %d\\n\", result);\n    return 0;\n}\n```"
  },
  {
    "task": "Create a software tool that converts file formats and handles unsupported format exceptions.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef enum {\n    FORMAT_TXT,\n    FORMAT_CSV,\n    FORMAT_UNSUPPORTED\n} FileFormat;\n\nFileFormat detectFileFormat(const char *filename) {\n    const char *dot = strrchr(filename, '.');\n    if (!dot || dot == filename) return FORMAT_UNSUPPORTED;\n    if (strcmp(dot, \".txt\") == 0) return FORMAT_TXT;\n    if (strcmp(dot, \".csv\") == 0) return FORMAT_CSV;\n    return FORMAT_UNSUPPORTED;\n}\n\nvoid convertFile(const char *inputFile, const char *outputFile) {\n    FileFormat inputFormat = detectFileFormat(inputFile);\n    FileFormat outputFormat = detectFileFormat(outputFile);\n\n    if (inputFormat == FORMAT_UNSUPPORTED) {\n        fprintf(stderr, \"Unsupported input file format: %s\\n\", inputFile);\n        return;\n    }\n    if (outputFormat == FORMAT_UNSUPPORTED) {\n        fprintf(stderr, \"Unsupported output file format: %s\\n\", outputFile);\n        return;\n    }\n\n    // Simplified conversion logic\n    if (inputFormat == outputFormat) {\n        fprintf(stderr, \"Input and output formats are the same. No conversion needed.\\n\");\n        return;\n    }\n\n    printf(\"Converting %s to %s...\\n\", inputFile, outputFile);\n    // Conversion logic would go here\n    printf(\"Conversion complete.\\n\");\n}\n\nint main(int argc, char *argv[]) {\n    if (argc != 3) {\n        fprintf(stderr, \"Usage: %s <input_file> <output_file>\\n\", argv[0]);\n        return EXIT_FAILURE;\n    }\n\n    convertFile(argv[1], argv[2]);\n    return EXIT_SUCCESS;\n}\n```"
  },
  {
    "task": "Implement a function that sends HTTP requests and catches exceptions for invalid response status codes.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <curl/curl.h>\n\nvoid sendHttpRequest(const char* url) {\n    CURL *curl;\n    CURLcode res;\n\n    curl_global_init(CURL_GLOBAL_DEFAULT);\n    curl = curl_easy_init();\n    \n    if(curl) {\n        curl_easy_setopt(curl, CURLOPT_URL, url);\n\n        res = curl_easy_perform(curl);\n\n        if(res != CURLE_OK) {\n            fprintf(stderr, \"Request failed: %s\\n\", curl_easy_strerror(res));\n        } else {\n            long response_code;\n            curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &response_code);\n            if(response_code != 200) {\n                fprintf(stderr, \"Invalid response status code: %ld\\n\", response_code);\n            }\n        }\n\n        curl_easy_cleanup(curl);\n    }\n\n    curl_global_cleanup();\n}\n\nint main() {\n    sendHttpRequest(\"http://example.com\");\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a program that interacts with a message queue and handles message delivery exceptions.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/ipc.h>\n#include <sys/msg.h>\n\n#define QUEUE_KEY 1234\n#define MESSAGE_SIZE 100\n\nstruct message {\n    long msg_type;\n    char msg_text[MESSAGE_SIZE];\n};\n\nvoid receive_message(int msgid) {\n    struct message msg;\n    if (msgrcv(msgid, &msg, sizeof(msg.msg_text), 1, 0) == -1) {\n        perror(\"Error receiving message\");\n        exit(EXIT_FAILURE);\n    }\n    printf(\"Received message: %s\\n\", msg.msg_text);\n}\n\nvoid send_message(int msgid, const char *text) {\n    struct message msg;\n    msg.msg_type = 1;\n    strncpy(msg.msg_text, text, MESSAGE_SIZE - 1);\n    msg.msg_text[MESSAGE_SIZE - 1] = '\\0';\n    \n    if (msgsnd(msgid, &msg, sizeof(msg.msg_text), 0) == -1) {\n        perror(\"Error sending message\");\n        exit(EXIT_FAILURE);\n    }\n}\n\nint main() {\n    int msgid = msgget(QUEUE_KEY, 0666 | IPC_CREAT);\n    if (msgid == -1) {\n        perror(\"Error creating message queue\");\n        exit(EXIT_FAILURE);\n    }\n\n    char message_text[] = \"Hello, World!\";\n    send_message(msgid, message_text);\n\n    receive_message(msgid);\n\n    if (msgctl(msgid, IPC_RMID, NULL) == -1) {\n        perror(\"Error removing message queue\");\n        exit(EXIT_FAILURE);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that reads user input and catches exceptions for unexpected data types.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <setjmp.h>\n\njmp_buf jumpBuffer;\n\nvoid readInput() {\n    char input[100];\n    int number;\n    \n    printf(\"Enter a number: \");\n    if (fgets(input, sizeof(input), stdin)) {\n        if (setjmp(jumpBuffer) == 0) {\n            number = strtol(input, NULL, 10);\n            if (number == 0 && input[0] != '0') {\n                longjmp(jumpBuffer, 1);\n            }\n            printf(\"You entered: %d\\n\", number);\n        } else {\n            printf(\"Invalid input. Please enter a valid number.\\n\");\n        }\n    }\n}\n\nint main() {\n    readInput();\n    return 0;\n}\n```"
  },
  {
    "task": "Create a system that processes transactions and manages exceptions for insufficient funds.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    char *name;\n    double balance;\n} Account;\n\nvoid processTransaction(Account *account, double amount) {\n    if (amount > account->balance) {\n        fprintf(stderr, \"Exception: Insufficient funds for transaction of amount %.2f\\n\", amount);\n    } else {\n        account->balance -= amount;\n        printf(\"Transaction processed. New balance: %.2f\\n\", account->balance);\n    }\n}\n\nint main() {\n    Account userAccount = {\"John Doe\", 100.0};\n\n    double transactions[] = {50.0, 30.0, 40.0};\n    size_t numTransactions = sizeof(transactions) / sizeof(transactions[0]);\n\n    for (size_t i = 0; i < numTransactions; i++) {\n        processTransaction(&userAccount, transactions[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Design a function that generates random numbers and handles exceptions when the range is invalid.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\nint generateRandomNumber(int lower, int upper) {\n    if (lower > upper) {\n        fprintf(stderr, \"Invalid range: lower bound is greater than upper bound.\\n\");\n        exit(EXIT_FAILURE);\n    }\n    return (rand() % (upper - lower + 1)) + lower;\n}\n\nint main() {\n    srand(time(0));\n    int lower = 10, upper = 5;\n    int randomNumber = generateRandomNumber(lower, upper);\n    printf(\"Generated Random Number: %d\\n\", randomNumber);\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Implement a program that performs image processing and catches exceptions for unsupported file dimensions.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <setjmp.h>\n\njmp_buf jumpBuffer;\n\nvoid processImage(int width, int height) {\n    if (width <= 0 || height <= 0) {\n        printf(\"Error: Unsupported file dimensions.\\n\");\n        longjmp(jumpBuffer, 1);\n    }\n    printf(\"Processing image with dimensions: %dx%d\\n\", width, height);\n    // Image processing logic goes here\n}\n\nint main() {\n    int width, height;\n\n    // Example dimensions (these could be inputs from a file or user)\n    width = -100;\n    height = 200;\n\n    if (setjmp(jumpBuffer) == 0) {\n        processImage(width, height);\n    } else {\n        printf(\"Terminating program due to exception.\\n\");\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that manipulates strings and manages exceptions for invalid operations.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <setjmp.h>\n\njmp_buf buf;\n\nvoid handle_exception(const char *message) {\n    printf(\"Exception: %s\\n\", message);\n    longjmp(buf, 1);\n}\n\nvoid manipulate_string(const char *input) {\n    if (setjmp(buf)) {\n        // Exception handling\n        return;\n    }\n    \n    if (input == NULL) {\n        handle_exception(\"Null pointer exception\");\n    }\n    \n    size_t length = strlen(input);\n    if (length == 0) {\n        handle_exception(\"Empty string exception\");\n    }\n\n    char *reversed = (char *)malloc((length + 1) * sizeof(char));\n    if (reversed == NULL) {\n        handle_exception(\"Memory allocation failed\");\n    }\n\n    for (size_t i = 0; i < length; ++i) {\n        reversed[i] = input[length - 1 - i];\n    }\n    reversed[length] = '\\0';\n\n    printf(\"Reversed string: %s\\n\", reversed);\n    free(reversed);\n}\n\nint main() {\n    manipulate_string(\"Hello, World!\");\n    manipulate_string(\"\");\n    manipulate_string(NULL);\n    return 0;\n}\n```"
  },
  {
    "task": "Create a script that automates tasks and handles exceptions for missing dependencies.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    // Simulate a task that requires a dependency\n    int dependencyExists = 0; // Change to 1 if dependency is present\n\n    if (!dependencyExists) {\n        fprintf(stderr, \"Error: Required dependency is missing.\\n\");\n        return EXIT_FAILURE;\n    }\n\n    // Automate tasks here\n    printf(\"Automating tasks...\\n\");\n\n    return EXIT_SUCCESS;\n}\n```"
  },
  {
    "task": "Develop a function that accesses nested data structures and manages key access exceptions.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    char key[50];\n    int value;\n} NestedData;\n\ntypedef struct {\n    char key[50];\n    NestedData nested[10];\n    size_t nestedSize;\n} Data;\n\nint getNestedValue(Data *data, size_t dataSize, const char *outerKey, const char *innerKey) {\n    for (size_t i = 0; i < dataSize; i++) {\n        if (strcmp(data[i].key, outerKey) == 0) {\n            for (size_t j = 0; j < data[i].nestedSize; j++) {\n                if (strcmp(data[i].nested[j].key, innerKey) == 0) {\n                    return data[i].nested[j].value;\n                }\n            }\n            fprintf(stderr, \"Inner key '%s' not found.\\n\", innerKey);\n            exit(EXIT_FAILURE);\n        }\n    }\n    fprintf(stderr, \"Outer key '%s' not found.\\n\", outerKey);\n    exit(EXIT_FAILURE);\n}\n\nint main() {\n    Data data[] = {\n        {\"outer1\", {{\"inner1\", 10}, {\"inner2\", 20}}, 2},\n        {\"outer2\", {{\"inner3\", 30}, {\"inner4\", 40}}, 2}\n    };\n    size_t dataSize = sizeof(data) / sizeof(data[0]);\n\n    int value = getNestedValue(data, dataSize, \"outer1\", \"inner1\");\n    printf(\"Value: %d\\n\", value);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Design a program that synchronizes data between sources and handles data mismatch exceptions.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    int id;\n    char data[256];\n} DataRecord;\n\nvoid synchronizeData(DataRecord *source1, DataRecord *source2, int size) {\n    for (int i = 0; i < size; ++i) {\n        if (strcmp(source1[i].data, source2[i].data) != 0) {\n            fprintf(stderr, \"Data mismatch exception: Record ID %d does not match\\n\", source1[i].id);\n            exit(EXIT_FAILURE);\n        }\n    }\n    printf(\"Data synchronized successfully\\n\");\n}\n\nint main() {\n    DataRecord source1[] = {\n        {1, \"Data A\"},\n        {2, \"Data B\"},\n        {3, \"Data C\"}\n    };\n\n    DataRecord source2[] = {\n        {1, \"Data A\"},\n        {2, \"Data B\"},\n        {3, \"Data C\"}\n    };\n\n    int size = sizeof(source1) / sizeof(source1[0]);\n\n    synchronizeData(source1, source2, size);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that interacts with hardware devices and handles connection failure exceptions.",
    "code": "```c\n#include <stdio.h>\n#include <setjmp.h>\n\njmp_buf env;\n\nvoid connectToDevice() {\n    // Simulate a connection failure\n    int connectionSuccess = 0; // 0 indicates failure\n    if (connectionSuccess == 0) {\n        longjmp(env, 1);\n    }\n    printf(\"Connected to device successfully.\\n\");\n}\n\nvoid interactWithDevice() {\n    if (setjmp(env) != 0) {\n        printf(\"Failed to connect to the device. Handling exception.\\n\");\n        return;\n    }\n    \n    connectToDevice();\n    // Code to interact with the device would go here\n}\n\nint main() {\n    interactWithDevice();\n    return 0;\n}\n```"
  },
  {
    "task": "Create a tool that compresses files and manages exceptions for unsupported compression formats.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\nvoid compressFile(const char *filePath, const char *format) {\n    if (strcmp(format, \"zip\") != 0 && strcmp(format, \"gzip\") != 0) {\n        fprintf(stderr, \"Error: Unsupported compression format '%s'.\\n\", format);\n        return;\n    }\n\n    // Simulate compression process\n    printf(\"Compressing file '%s' using format '%s'.\\n\", filePath, format);\n    // Actual compression logic would go here\n}\n\nint main() {\n    const char *filePath = \"example.txt\";\n    const char *format = \"rar\";  // Change this to \"zip\" or \"gzip\" for supported formats\n\n    compressFile(filePath, format);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a function that parses command-line arguments and handles missing argument exceptions.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid parseArguments(int argc, char *argv[]) {\n    if (argc < 2) {\n        fprintf(stderr, \"Exception: Missing argument.\\n\");\n        exit(EXIT_FAILURE);\n    }\n    printf(\"Argument provided: %s\\n\", argv[1]);\n}\n\nint main(int argc, char *argv[]) {\n    parseArguments(argc, argv);\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a program that simulates user interactions and manages timing exceptions.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <setjmp.h>\n\njmp_buf env;\n\nvoid simulateUserInteraction() {\n    printf(\"Simulating user interaction...\\n\");\n    if (rand() % 2) {\n        printf(\"Timing exception occurred!\\n\");\n        longjmp(env, 1);\n    }\n    printf(\"User interaction successful.\\n\");\n}\n\nint main() {\n    srand(time(NULL));\n\n    if (setjmp(env) == 0) {\n        simulateUserInteraction();\n    } else {\n        printf(\"Handled timing exception. Retrying...\\n\");\n        simulateUserInteraction();\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that encrypts data and handles exceptions for unsupported encryption algorithms.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\ntypedef enum {\n    SUCCESS,\n    UNSUPPORTED_ALGORITHM,\n    GENERAL_ERROR\n} ErrorCode;\n\nErrorCode encryptData(const char *algorithm, const char *data, char **encryptedData) {\n    *encryptedData = NULL;\n\n    if (strcmp(algorithm, \"AES\") == 0) {\n        // Example encryption logic for AES\n        *encryptedData = strdup(\"encrypted_with_AES\");\n        return SUCCESS;\n    } else if (strcmp(algorithm, \"RSA\") == 0) {\n        // Example encryption logic for RSA\n        *encryptedData = strdup(\"encrypted_with_RSA\");\n        return SUCCESS;\n    } else {\n        return UNSUPPORTED_ALGORITHM;\n    }\n}\n\nint main() {\n    char *encryptedData;\n    ErrorCode result = encryptData(\"DES\", \"mydata\", &encryptedData);\n\n    if (result == SUCCESS) {\n        printf(\"Encrypted Data: %s\\n\", encryptedData);\n        free(encryptedData); // Remember to free allocated memory\n    } else if (result == UNSUPPORTED_ALGORITHM) {\n        printf(\"Error: Unsupported encryption algorithm.\\n\");\n    } else {\n        printf(\"Error: General encryption error.\\n\");\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a system that aggregates data and manages exceptions for data inconsistency.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <setjmp.h>\n\n#define MAX_DATA_SIZE 100\n#define MAX_STRING_LENGTH 50\n\ntypedef struct {\n    char name[MAX_STRING_LENGTH];\n    int value;\n} Data;\n\njmp_buf jumpBuffer;\n\nvoid handleDataInconsistency(const char *message) {\n    printf(\"Exception: %s\\n\", message);\n    longjmp(jumpBuffer, 1);\n}\n\nvoid processData(Data *data, int size) {\n    if (size <= 0 || size > MAX_DATA_SIZE) {\n        handleDataInconsistency(\"Inconsistent data size.\");\n        return;\n    }\n\n    int aggregatedValue = 0;\n    for (int i = 0; i < size; ++i) {\n        if (data[i].value < 0) {\n            handleDataInconsistency(\"Negative value encountered.\");\n            return;\n        }\n        aggregatedValue += data[i].value;\n    }\n    \n    printf(\"Aggregated Value: %d\\n\", aggregatedValue);\n}\n\nint main() {\n    Data dataset[MAX_DATA_SIZE] = {\n        {\"item1\", 10},\n        {\"item2\", 20},\n        {\"item3\", 30},\n        {\"item4\", -5}, // This will trigger an exception\n    };\n\n    if (setjmp(jumpBuffer) == 0) {\n        processData(dataset, 4);\n    } else {\n        printf(\"Data processing halted due to exception.\\n\");\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Design a program that processes real-time data streams and handles connection drop exceptions.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <errno.h>\n\nbool connect_to_data_stream() {\n    // Simulate connection attempt\n    return rand() % 2 == 0; // Random success or failure\n}\n\nvoid process_data_stream() {\n    // Simulate data processing\n    printf(\"Processing data...\\n\");\n}\n\nint main() {\n    while (true) {\n        if (!connect_to_data_stream()) {\n            fprintf(stderr, \"Connection drop exception occurred: %s\\n\", strerror(errno));\n            continue; // Retry connection\n        }\n        process_data_stream();\n        // Simulate periodic disconnection\n        if (rand() % 10 == 0) {\n            fprintf(stderr, \"Connection dropped during processing\\n\");\n            continue; // Retry connection\n        }\n    }\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a function that performs scientific calculations and manages precision exceptions.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <fenv.h>\n#include <math.h>\n\n// Function to perform scientific calculations and handle precision exceptions\ndouble performCalculation(double x) {\n    // Enable exceptions for floating-point precision errors\n    feclearexcept(FE_ALL_EXCEPT);\n    feraiseexcept(FE_INEXACT);\n\n    double result = log(x) / sqrt(x);\n\n    // Check if a precision exception occurred\n    if (fetestexcept(FE_INEXACT)) {\n        fprintf(stderr, \"Warning: Precision exception occurred during calculation.\\n\");\n        feclearexcept(FE_INEXACT);\n    }\n\n    return result;\n}\n\nint main() {\n    double x = 2.0;\n    double result = performCalculation(x);\n    printf(\"Result: %f\\n\", result);\n    return 0;\n}\n```"
  },
  {
    "task": "Write a script that generates reports and handles exceptions for missing data sources.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Custom exception type for missing data sources\ntypedef struct {\n    char message[256];\n} MissingDataSourceException;\n\n// Function to generate a report\nvoid generateReport(const char *dataSource) {\n    if (dataSource == NULL || strlen(dataSource) == 0) {\n        MissingDataSourceException e;\n        strcpy(e.message, \"Data source is missing.\");\n        throwException(&e);\n        return;\n    }\n    printf(\"Generating report using data source: %s\\n\", dataSource);\n}\n\n// Function to handle exceptions\nvoid throwException(MissingDataSourceException *e) {\n    printf(\"Exception: %s\\n\", e->message);\n}\n\nint main() {\n    const char *dataSource1 = \"data_source_1.txt\";\n    const char *dataSource2 = \"\";\n\n    // Attempt to generate reports\n    printf(\"Attempting to generate report 1...\\n\");\n    generateReport(dataSource1);\n\n    printf(\"Attempting to generate report 2...\\n\");\n    generateReport(dataSource2);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a program that validates digital certificates and manages trust exceptions.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    char *issuer;\n    char *subject;\n    char *valid_from;\n    char *valid_to;\n    int is_trusted;\n} Certificate;\n\ntypedef struct {\n    Certificate *certificates;\n    size_t count;\n} TrustStore;\n\nint validate_certificate(const Certificate *cert) {\n    if (strcmp(cert->valid_from, \"2023-01-01\") > 0 && strcmp(cert->valid_to, \"2024-01-01\") < 0) {\n        return 1; // Valid certificate\n    }\n    return 0; // Invalid certificate\n}\n\nint check_trust_exceptions(const Certificate *cert) {\n    return cert->is_trusted;\n}\n\nvoid handle_certificate(const Certificate *cert, TrustStore *trust_store) {\n    int is_valid = validate_certificate(cert);\n    int is_trusted = check_trust_exceptions(cert);\n\n    if (!is_valid || !is_trusted) {\n        fprintf(stderr, \"Certificate validation failed or untrusted issuer: %s\\n\", cert->issuer);\n        // Manage exception\n        if (!is_valid) {\n            fprintf(stderr, \"Handling validation exception...\\n\");\n        }\n        if (!is_trusted) {\n            fprintf(stderr, \"Handling trust exception...\\n\");\n        }\n    } else {\n        printf(\"Certificate is valid and trusted for issuer: %s\\n\", cert->issuer);\n    }\n}\n\nint main() {\n    Certificate cert1 = {\"Issuer A\", \"Subject A\", \"2023-01-02\", \"2023-12-31\", 1};\n    Certificate cert2 = {\"Issuer B\", \"Subject B\", \"2022-01-01\", \"2022-12-31\", 0};\n    \n    TrustStore trust_store;\n    trust_store.certificates = malloc(2 * sizeof(Certificate));\n    trust_store.certificates[0] = cert1;\n    trust_store.certificates[1] = cert2;\n    trust_store.count = 2;\n\n    for (size_t i = 0; i < trust_store.count; ++i) {\n        handle_certificate(&trust_store.certificates[i], &trust_store);\n    }\n\n    free(trust_store.certificates);\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a function that schedules tasks and handles exceptions for scheduling conflicts.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    char name[50];\n    int startTime;\n    int endTime;\n} Task;\n\ntypedef struct {\n    Task tasks[100];\n    int count;\n} Scheduler;\n\nvoid handle_exception(const char *message) {\n    printf(\"Exception: %s\\n\", message);\n    exit(EXIT_FAILURE);\n}\n\nvoid schedule_task(Scheduler *scheduler, const char *name, int startTime, int endTime) {\n    for (int i = 0; i < scheduler->count; i++) {\n        Task t = scheduler->tasks[i];\n        if ((startTime < t.endTime) && (endTime > t.startTime)) {\n            handle_exception(\"Scheduling conflict detected\");\n        }\n    }\n    strcpy(scheduler->tasks[scheduler->count].name, name);\n    scheduler->tasks[scheduler->count].startTime = startTime;\n    scheduler->tasks[scheduler->count].endTime = endTime;\n    scheduler->count++;\n}\n\nint main() {\n    Scheduler scheduler = {.count = 0};\n\n    schedule_task(&scheduler, \"Task 1\", 9, 11);\n    schedule_task(&scheduler, \"Task 2\", 11, 13);\n    schedule_task(&scheduler, \"Task 3\", 10, 12);  // This will cause a scheduling conflict\n\n    return 0;\n}\n```"
  },
  {
    "task": "Design a system that manages user sessions and handles session timeout exceptions.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <setjmp.h>\n\n#define SESSION_TIMEOUT 5 // Session timeout in seconds\n\ntypedef struct {\n    int userId;\n    time_t startTime;\n} Session;\n\njmp_buf timeoutJump;\n\nvoid handleSessionTimeout(int userId) {\n    printf(\"Session timeout for user ID %d\\n\", userId);\n    longjmp(timeoutJump, 1);\n}\n\nSession* startSession(int userId) {\n    Session* session = (Session*)malloc(sizeof(Session));\n    if (session == NULL) {\n        perror(\"Failed to allocate session\");\n        exit(EXIT_FAILURE);\n    }\n    session->userId = userId;\n    session->startTime = time(NULL);\n    return session;\n}\n\nvoid checkSession(Session* session) {\n    time_t currentTime = time(NULL);\n    if (difftime(currentTime, session->startTime) > SESSION_TIMEOUT) {\n        handleSessionTimeout(session->userId);\n    }\n}\n\nvoid endSession(Session* session) {\n    free(session);\n}\n\nint main() {\n    int userId = 1;\n    Session* session = startSession(userId);\n\n    if (setjmp(timeoutJump) == 0) {\n        while (1) {\n            checkSession(session);\n            // Simulate some work\n            sleep(1);\n            printf(\"Session active for user ID %d\\n\", session->userId);\n        }\n    } else {\n        // Handle session timeout\n        printf(\"Handling session timeout logic...\\n\");\n    }\n\n    endSession(session);\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that processes audio files and manages exceptions for unsupported audio formats.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\nvoid processAudioFile(const char *fileName) {\n    const char *supportedFormats[] = {\".mp3\", \".wav\", \".flac\"};\n    int isSupported = 0;\n    const char *extension = strrchr(fileName, '.');\n\n    if (extension != NULL) {\n        for (int i = 0; i < sizeof(supportedFormats) / sizeof(supportedFormats[0]); ++i) {\n            if (strcmp(extension, supportedFormats[i]) == 0) {\n                isSupported = 1;\n                break;\n            }\n        }\n    }\n\n    if (!isSupported) {\n        fprintf(stderr, \"Error: Unsupported audio format for file %s\\n\", fileName);\n        return;\n    }\n\n    printf(\"Processing audio file: %s\\n\", fileName);\n    // Add audio processing logic here\n}\n\nint main() {\n    processAudioFile(\"song.mp3\");\n    processAudioFile(\"voice.aac\");\n    return 0;\n}\n```"
  },
  {
    "task": "Create a service that sends notifications and handles exceptions for unreachable destinations.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Custom exception structure\ntypedef struct {\n    char message[256];\n} Exception;\n\n// Function to simulate sending a notification\nvoid sendNotification(const char *destination) {\n    // Simulating an unreachable destination\n    if (strcmp(destination, \"unreachable\") == 0) {\n        Exception e;\n        strcpy(e.message, \"Destination is unreachable.\");\n        throwException(e);\n    } else {\n        printf(\"Notification sent to %s\\n\", destination);\n    }\n}\n\n// Function to handle exceptions\nvoid handleException(Exception e) {\n    printf(\"Exception: %s\\n\", e.message);\n}\n\n// Function to throw exceptions\nvoid throwException(Exception e) {\n    handleException(e);\n    exit(EXIT_FAILURE); // Exit after handling the exception\n}\n\nint main() {\n    const char *destinations[] = {\"reachable\", \"unreachable\", \"another_destination\"};\n    size_t numDestinations = sizeof(destinations) / sizeof(destinations[0]);\n\n    for (size_t i = 0; i < numDestinations; ++i) {\n        sendNotification(destinations[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a program that performs data migration and manages data transformation exceptions.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    int id;\n    char name[50];\n    float value;\n} DataRecord;\n\nvoid transformData(DataRecord* record) {\n    if (record->value < 0) {\n        fprintf(stderr, \"Error: Negative value encountered for id %d\\n\", record->id);\n        exit(EXIT_FAILURE);\n    }\n    record->value *= 2.0;\n}\n\nint main() {\n    DataRecord sourceData[] = {\n        {1, \"Record1\", 10.5},\n        {2, \"Record2\", -5.0},\n        {3, \"Record3\", 20.0}\n    };\n    size_t dataSize = sizeof(sourceData) / sizeof(sourceData[0]);\n    DataRecord* migratedData = (DataRecord*)malloc(dataSize * sizeof(DataRecord));\n    if (migratedData == NULL) {\n        fprintf(stderr, \"Error: Memory allocation failed\\n\");\n        return EXIT_FAILURE;\n    }\n\n    for (size_t i = 0; i < dataSize; i++) {\n        migratedData[i] = sourceData[i];\n        transformData(&migratedData[i]);\n    }\n\n    for (size_t i = 0; i < dataSize; i++) {\n        printf(\"ID: %d, Name: %s, Value: %.2f\\n\", migratedData[i].id, migratedData[i].name, migratedData[i].value);\n    }\n\n    free(migratedData);\n    return EXIT_SUCCESS;\n}\n```"
  },
  {
    "task": "Develop a function that processes video files and handles codec compatibility exceptions.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Custom exception for codec compatibility\ntypedef struct CodecException {\n    const char *message;\n} CodecException;\n\n// Function to simulate video processing\nvoid processVideoFile(const char *fileName) {\n    // Simulate a codec exception\n    int codecCompatible = 0;  // 0 for incompatible, 1 for compatible\n\n    if (!codecCompatible) {\n        CodecException e;\n        e.message = \"Codec compatibility issue encountered.\";\n        throwCodecException(&e);\n        return;\n    }\n\n    printf(\"Processing video file: %s\\n\", fileName);\n}\n\n// Function to handle codec exceptions\nvoid throwCodecException(CodecException *e) {\n    fprintf(stderr, \"Error: %s\\n\", e->message);\n    // Here you can handle the exception, such as logging or retrying with a different codec\n}\n\nint main() {\n    const char *videoFile = \"sample_video.mp4\";\n\n    processVideoFile(videoFile);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that manages memory allocation and catches out-of-memory exceptions.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid* allocateMemory(size_t size) {\n    void* ptr = malloc(size);\n    if (ptr == NULL) {\n        fprintf(stderr, \"Error: Out of memory\\n\");\n        exit(EXIT_FAILURE);\n    }\n    return ptr;\n}\n\nint main() {\n    size_t size = 1024;\n    void* memory = allocateMemory(size);\n    \n    // Use the allocated memory here\n\n    free(memory);\n    return 0;\n}\n```"
  },
  {
    "task": "Create a program that processes financial transactions and handles currency conversion exceptions.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <setjmp.h>\n\njmp_buf env;\n\nvoid handleCurrencyConversionException(const char *message) {\n    printf(\"Exception: %s\\n\", message);\n    longjmp(env, 1);\n}\n\ndouble convertCurrency(double amount, const char *fromCurrency, const char *toCurrency) {\n    if (strcmp(fromCurrency, \"USD\") == 0 && strcmp(toCurrency, \"EUR\") == 0) {\n        return amount * 0.85;\n    } else if (strcmp(fromCurrency, \"EUR\") == 0 && strcmp(toCurrency, \"USD\") == 0) {\n        return amount * 1.18;\n    } else {\n        handleCurrencyConversionException(\"Unsupported currency conversion\");\n        return 0.0; // This line will not be reached due to longjmp\n    }\n}\n\nvoid processTransaction(double amount, const char *fromCurrency, const char *toCurrency) {\n    if (setjmp(env) == 0) {\n        double convertedAmount = convertCurrency(amount, fromCurrency, toCurrency);\n        printf(\"Converted amount: %.2f %s\\n\", convertedAmount, toCurrency);\n    } else {\n        printf(\"Transaction failed due to currency conversion error.\\n\");\n    }\n}\n\nint main() {\n    processTransaction(100.0, \"USD\", \"EUR\"); // Supported conversion\n    processTransaction(100.0, \"USD\", \"GBP\"); // Unsupported conversion\n    return 0;\n}\n```"
  },
  {
    "task": "Design a function that interacts with cloud storage and manages access permission exceptions.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\ntypedef enum {\n    PERMISSION_DENIED,\n    CONNECTION_ERROR,\n    SUCCESS\n} CloudError;\n\nCloudError connectToCloud(const char *permission) {\n    // Simulate permission check\n    if (strcmp(permission, \"granted\") != 0) {\n        return PERMISSION_DENIED;\n    }\n    // Simulate connection logic\n    return SUCCESS;\n}\n\nvoid handleCloudStorage(const char *permission) {\n    CloudError error = connectToCloud(permission);\n    \n    switch (error) {\n        case PERMISSION_DENIED:\n            fprintf(stderr, \"Error: Permission Denied. Unable to access cloud storage.\\n\");\n            break;\n        case CONNECTION_ERROR:\n            fprintf(stderr, \"Error: Connection Error. Please check your network.\\n\");\n            break;\n        case SUCCESS:\n            printf(\"Connected to cloud storage successfully.\\n\");\n            break;\n    }\n}\n\nint main() {\n    handleCloudStorage(\"denied\");\n    handleCloudStorage(\"granted\");\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a script that automates deployment and handles exceptions for missing configuration files.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid deploy() {\n    // Simulate deployment process\n    printf(\"Deployment process started...\\n\");\n    // Add deployment logic here\n    printf(\"Deployment process completed successfully.\\n\");\n}\n\nint main() {\n    FILE *configFile = fopen(\"config.txt\", \"r\");\n\n    if (configFile == NULL) {\n        fprintf(stderr, \"Error: Configuration file not found.\\n\");\n        return EXIT_FAILURE;\n    }\n\n    // Simulate reading configuration\n    fclose(configFile);\n    printf(\"Configuration file loaded successfully.\\n\");\n\n    try {\n        deploy();\n    } catch (...) {\n        fprintf(stderr, \"An error occurred during deployment.\\n\");\n        return EXIT_FAILURE;\n    }\n\n    return EXIT_SUCCESS;\n}\n```"
  },
  {
    "task": "Write a function that normalizes data and handles exceptions for invalid data ranges.",
    "code": "```c\n#include <stdio.h>\n#include <setjmp.h>\n\njmp_buf jumpBuffer;\n\nvoid handleException(const char* message) {\n    printf(\"Exception: %s\\n\", message);\n    longjmp(jumpBuffer, 1);\n}\n\ndouble normalizeData(double value, double min, double max) {\n    if (max <= min) {\n        handleException(\"Invalid range: max must be greater than min.\");\n    }\n    if (value < min || value > max) {\n        handleException(\"Value out of range.\");\n    }\n    return (value - min) / (max - min);\n}\n\nint main() {\n    if (setjmp(jumpBuffer) == 0) {\n        double normalizedValue = normalizeData(150.0, 100.0, 200.0);\n        printf(\"Normalized Value: %f\\n\", normalizedValue);\n    }\n    if (setjmp(jumpBuffer) == 0) {\n        double normalizedValue = normalizeData(50.0, 100.0, 200.0);\n        printf(\"Normalized Value: %f\\n\", normalizedValue);\n    }\n    return 0;\n}\n```"
  },
  {
    "task": "Create a system that monitors application performance and handles threshold breach exceptions.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <setjmp.h>\n\njmp_buf buf;\n\nvoid checkPerformance(int metric, int threshold) {\n    if (metric > threshold) {\n        longjmp(buf, 1);\n    }\n}\n\nint main() {\n    int performanceMetric = 85;\n    int threshold = 80;\n\n    if (setjmp(buf)) {\n        printf(\"Exception: Performance threshold breached!\\n\");\n        return EXIT_FAILURE;\n    }\n\n    printf(\"Monitoring application performance...\\n\");\n    checkPerformance(performanceMetric, threshold);\n    printf(\"Performance is within acceptable limits.\\n\");\n\n    return EXIT_SUCCESS;\n}\n```"
  },
  {
    "task": "Develop a program that processes social media data and manages API limit exceptions.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define API_LIMIT_EXCEEDED -1\n\n// Mock function to simulate API call\nint processSocialMediaData() {\n    // Simulating an API limit exception\n    return API_LIMIT_EXCEEDED;\n}\n\nvoid handleApiException(int errorCode) {\n    if (errorCode == API_LIMIT_EXCEEDED) {\n        fprintf(stderr, \"Error: API limit exceeded. Please try again later.\\n\");\n        exit(EXIT_FAILURE);\n    }\n}\n\nint main() {\n    int result = processSocialMediaData();\n\n    if (result == API_LIMIT_EXCEEDED) {\n        handleApiException(result);\n    }\n\n    printf(\"Social media data processed successfully.\\n\");\n    return EXIT_SUCCESS;\n}\n```"
  },
  {
    "task": "Design a function that integrates with payment gateways and handles payment failure exceptions.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n// Simulated payment gateway function\nbool processPayment(double amount) {\n    // Simulating a failure for demonstration purposes\n    return false; \n}\n\n// Custom exception handling for payment failures\nvoid handlePaymentException(const char* message) {\n    fprintf(stderr, \"Payment Exception: %s\\n\", message);\n}\n\n// Function to integrate with payment gateway\nbool integratePaymentGateway(double amount) {\n    bool success = processPayment(amount);\n    if (!success) {\n        handlePaymentException(\"Payment processing failed.\");\n        return false;\n    }\n    return true;\n}\n\nint main() {\n    double paymentAmount = 100.0;\n    if (!integratePaymentGateway(paymentAmount)) {\n        // Handle failure gracefully\n        printf(\"Failed to process payment of $%.2f\\n\", paymentAmount);\n    } else {\n        printf(\"Payment of $%.2f processed successfully.\\n\", paymentAmount);\n    }\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that backs up data and handles exceptions for unavailable storage media.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n\nvoid backupData(const char *source, const char *destination) {\n    FILE *srcFile = fopen(source, \"rb\");\n    if (srcFile == NULL) {\n        fprintf(stderr, \"Error opening source file: %s\\n\", strerror(errno));\n        return;\n    }\n\n    FILE *destFile = fopen(destination, \"wb\");\n    if (destFile == NULL) {\n        fprintf(stderr, \"Error opening destination file: %s\\n\", strerror(errno));\n        fclose(srcFile);\n        return;\n    }\n\n    char buffer[1024];\n    size_t bytesRead;\n    while ((bytesRead = fread(buffer, 1, sizeof(buffer), srcFile)) > 0) {\n        if (fwrite(buffer, 1, bytesRead, destFile) != bytesRead) {\n            fprintf(stderr, \"Error writing to destination file: %s\\n\", strerror(errno));\n            fclose(srcFile);\n            fclose(destFile);\n            return;\n        }\n    }\n\n    if (ferror(srcFile)) {\n        fprintf(stderr, \"Error reading source file: %s\\n\", strerror(errno));\n    }\n\n    fclose(srcFile);\n    fclose(destFile);\n}\n```"
  },
  {
    "task": "Create a tool that manages software updates and handles exceptions for version conflicts.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\ntypedef struct {\n    char current_version[10];\n    char new_version[10];\n} SoftwareUpdate;\n\nvoid handleVersionConflict(const char *current_version, const char *new_version) {\n    printf(\"Version conflict: Current version is %s, but new version is %s\\n\", current_version, new_version);\n    // Resolve the conflict, e.g., by prompting the user or automatically choosing a version\n    // Here, we simply print a message and exit\n    printf(\"Please resolve the version conflict.\\n\");\n    exit(EXIT_FAILURE);\n}\n\nvoid updateSoftware(SoftwareUpdate *update) {\n    if (strcmp(update->current_version, update->new_version) >= 0) {\n        handleVersionConflict(update->current_version, update->new_version);\n    } else {\n        // Proceed with the update\n        printf(\"Updating from version %s to version %s\\n\", update->current_version, update->new_version);\n        strcpy(update->current_version, update->new_version);\n        printf(\"Update successful.\\n\");\n    }\n}\n\nint main() {\n    SoftwareUpdate update;\n    strcpy(update.current_version, \"1.0.0\");\n    strcpy(update.new_version, \"1.0.1\");\n\n    updateSoftware(&update);\n\n    strcpy(update.new_version, \"0.9.9\");\n    updateSoftware(&update);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a program that performs sentiment analysis and manages exceptions for ambiguous texts.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_TEXT_LENGTH 1000\n\ntypedef enum {\n    POSITIVE,\n    NEGATIVE,\n    NEUTRAL\n} Sentiment;\n\nSentiment analyzeSentiment(const char *text) {\n    if (strstr(text, \"good\") || strstr(text, \"happy\") || strstr(text, \"excellent\")) {\n        return POSITIVE;\n    } else if (strstr(text, \"bad\") || strstr(text, \"sad\") || strstr(text, \"terrible\")) {\n        return NEGATIVE;\n    } else {\n        return NEUTRAL;\n    }\n}\n\nvoid handleException(const char *errorMessage) {\n    fprintf(stderr, \"Error: %s\\n\", errorMessage);\n}\n\nint main() {\n    char text[MAX_TEXT_LENGTH];\n\n    printf(\"Enter text for sentiment analysis: \");\n    if (fgets(text, MAX_TEXT_LENGTH, stdin) == NULL) {\n        handleException(\"Failed to read input.\");\n        return EXIT_FAILURE;\n    }\n\n    Sentiment result;\n    try {\n        result = analyzeSentiment(text);\n    } catch (...) {\n        handleException(\"An exception occurred during sentiment analysis.\");\n        return EXIT_FAILURE;\n    }\n\n    switch (result) {\n        case POSITIVE:\n            printf(\"The sentiment is positive.\\n\");\n            break;\n        case NEGATIVE:\n            printf(\"The sentiment is negative.\\n\");\n            break;\n        case NEUTRAL:\n            printf(\"The sentiment is neutral.\\n\");\n            break;\n        default:\n            handleException(\"Unknown sentiment result.\");\n            return EXIT_FAILURE;\n    }\n\n    return EXIT_SUCCESS;\n}\n```"
  },
  {
    "task": "Develop a function that manages user authentication and handles credential mismatch exceptions.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\nint authExceptionOccurred = 0;\n\nvoid handleAuthException() {\n    printf(\"Authentication failed: Credential mismatch.\\n\");\n    authExceptionOccurred = 1;\n}\n\nint authenticateUser(const char* username, const char* password) {\n    const char* correctUsername = \"admin\";\n    const char* correctPassword = \"password123\";\n\n    if (strcmp(username, correctUsername) != 0 || strcmp(password, correctPassword) != 0) {\n        handleAuthException();\n        return 0;\n    }\n    return 1;\n}\n\nint main() {\n    const char* inputUsername = \"admin\";\n    const char* inputPassword = \"wrongpassword\";\n\n    int isAuthenticated = authenticateUser(inputUsername, inputPassword);\n\n    if (isAuthenticated) {\n        printf(\"User authenticated successfully.\\n\");\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a program that processes geographic data and handles exceptions for invalid coordinates.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    double latitude;\n    double longitude;\n} Coordinate;\n\nvoid processCoordinate(Coordinate *coord) {\n    if (coord->latitude < -90.0 || coord->latitude > 90.0 || coord->longitude < -180.0 || coord->longitude > 180.0) {\n        fprintf(stderr, \"Error: Invalid coordinate values. Latitude must be between -90 and 90, and longitude between -180 and 180.\\n\");\n        exit(EXIT_FAILURE);\n    }\n    printf(\"Processing Coordinate: Latitude = %.2f, Longitude = %.2f\\n\", coord->latitude, coord->longitude);\n}\n\nint main() {\n    Coordinate coords[] = {\n        {45.0, 90.0},\n        {91.0, 180.0}, // Invalid latitude\n        {60.0, 200.0}, // Invalid longitude\n        {-45.0, -90.0}\n    };\n\n    for (int i = 0; i < sizeof(coords) / sizeof(coords[0]); i++) {\n        processCoordinate(&coords[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a script that manages network configurations and handles exceptions for invalid syntax.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <setjmp.h>\n\njmp_buf jump_buffer;\n\nvoid handle_invalid_syntax() {\n    printf(\"Error: Invalid network configuration syntax.\\n\");\n    longjmp(jump_buffer, 1);\n}\n\nvoid configure_network(const char *config) {\n    if (strcmp(config, \"valid_config\") != 0) {\n        handle_invalid_syntax();\n    }\n    printf(\"Network configured successfully with config: %s\\n\", config);\n}\n\nint main() {\n    const char *config = \"invalid_config\";\n\n    if (setjmp(jump_buffer) == 0) {\n        configure_network(config);\n    } else {\n        printf(\"Handling exception and quitting.\\n\");\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Design a function that processes biometric data and handles exceptions for sensor errors.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int sensorStatus;\n    float data;\n} BiometricData;\n\nvoid processBiometricData(BiometricData *data) {\n    if (!data) {\n        fprintf(stderr, \"Error: Null data provided.\\n\");\n        return;\n    }\n\n    if (data->sensorStatus != 0) {\n        fprintf(stderr, \"Sensor error detected: status code %d\\n\", data->sensorStatus);\n        return;\n    }\n\n    // Process the valid biometric data\n    printf(\"Processing biometric data: %.2f\\n\", data->data);\n}\n\nint main() {\n    BiometricData validData = {0, 98.6}; // Normal sensor status\n    BiometricData sensorErrorData = {1, 0}; // Simulated sensor error\n\n    processBiometricData(&validData);\n    processBiometricData(&sensorErrorData);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a system that manages access control and handles exceptions for unauthorized access attempts.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <setjmp.h>\n\n#define MAX_USERS 3\n\ntypedef struct {\n    char username[50];\n    int authorized;\n} User;\n\nUser users[MAX_USERS] = {\n    {\"admin\", 1},\n    {\"user1\", 1},\n    {\"user2\", 0}\n};\n\njmp_buf env;\n\nvoid handle_exception(const char *message) {\n    printf(\"Exception: %s\\n\", message);\n    longjmp(env, 1);\n}\n\nvoid access_control(const char *username) {\n    for (int i = 0; i < MAX_USERS; i++) {\n        if (strcmp(users[i].username, username) == 0) {\n            if (users[i].authorized) {\n                printf(\"Access granted to %s\\n\", username);\n            } else {\n                handle_exception(\"Unauthorized access attempt\");\n            }\n            return;\n        }\n    }\n    handle_exception(\"User not found\");\n}\n\nint main() {\n    if (setjmp(env) == 0) {\n        access_control(\"admin\");\n        access_control(\"user2\");\n        access_control(\"user3\");\n    } else {\n        printf(\"Handling exception, terminating program.\\n\");\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that performs load balancing and handles exceptions for unreachable nodes.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <setjmp.h>\n\n#define MAX_NODES 10\n\njmp_buf exception_env;\n\nvoid handle_exception(const char* message) {\n    printf(\"Exception: %s\\n\", message);\n    longjmp(exception_env, 1);\n}\n\nvoid check_node_reachable(int node) {\n    if (node % 2 == 0) { // Simulating some nodes as unreachable\n        handle_exception(\"Node is unreachable\");\n    }\n}\n\nvoid load_balance(int nodes[], int size) {\n    if (setjmp(exception_env) == 0) {\n        for (int i = 0; i < size; i++) {\n            check_node_reachable(nodes[i]);\n            printf(\"Node %d is reachable. Performing load balancing...\\n\", nodes[i]);\n        }\n    } else {\n        printf(\"Load balancing aborted due to an exception.\\n\");\n    }\n}\n\nint main() {\n    int nodes[MAX_NODES] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n    load_balance(nodes, MAX_NODES);\n    return 0;\n}\n```"
  },
  {
    "task": "Create a program that simulates virtual environments and manages resource allocation exceptions.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <setjmp.h>\n\njmp_buf env;\n\nvoid allocateResources(int resourceCount) {\n    if (resourceCount < 0) {\n        printf(\"Exception: Cannot allocate negative resources.\\n\");\n        longjmp(env, 1);\n    }\n    if (resourceCount > 100) {\n        printf(\"Exception: Resource allocation exceeds limit.\\n\");\n        longjmp(env, 1);\n    }\n    printf(\"Resources allocated: %d\\n\", resourceCount);\n}\n\nvoid simulateEnvironment(int resourceCount) {\n    if (setjmp(env) == 0) {\n        allocateResources(resourceCount);\n    } else {\n        printf(\"Handling resource allocation exception.\\n\");\n    }\n}\n\nint main() {\n    simulateEnvironment(50);  // Normal allocation\n    simulateEnvironment(150); // Exceeds limit\n    simulateEnvironment(-1);  // Negative resources\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a tool that manages digital rights and handles exceptions for unauthorized content access.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <setjmp.h>\n\njmp_buf env;\n\nvoid handleUnauthorizedAccess() {\n    printf(\"Exception: Unauthorized content access.\\n\");\n    longjmp(env, 1);\n}\n\nvoid accessContent(int authorized) {\n    if (!authorized) {\n        handleUnauthorizedAccess();\n    } else {\n        printf(\"Accessing content...\\n\");\n    }\n}\n\nint main() {\n    int authorized = 0; // Set to 1 for authorized access\n\n    if (setjmp(env) == 0) {\n        accessContent(authorized);\n    } else {\n        printf(\"Handling unauthorized access exception.\\n\");\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Design a function that synchronizes clocks and handles exceptions for time drift.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\ntypedef struct {\n    int hours;\n    int minutes;\n    int seconds;\n} Clock;\n\nvoid synchronizeClocks(Clock* clock1, Clock* clock2) {\n    try {\n        // Simulate time drift detection\n        if (abs(clock1->seconds - clock2->seconds) > 5) {\n            throw \"Time drift detected\";\n        }\n\n        // Synchronize clocks\n        clock2->hours = clock1->hours;\n        clock2->minutes = clock1->minutes;\n        clock2->seconds = clock1->seconds;\n\n        printf(\"Clocks synchronized successfully.\\n\");\n    }\n    catch(const char* errorMsg) {\n        printf(\"Exception: %s\\n\", errorMsg);\n        // Handle exception (e.g., log error, adjust clocks, etc.)\n    }\n}\n\nint main() {\n    Clock clock1 = {10, 15, 30};\n    Clock clock2 = {10, 15, 25};\n\n    synchronizeClocks(&clock1, &clock2);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a script that manages system backups and handles exceptions for insufficient backup space.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\n#define REQUIRED_SPACE 1000\n\nvoid performBackup() {\n    printf(\"Backup successful.\\n\");\n}\n\nint checkAvailableSpace() {\n    // Simulate checking available space, for example purposes return a fixed value\n    return 800; // In a real scenario, this would be dynamic\n}\n\nint main() {\n    try {\n        int availableSpace = checkAvailableSpace();\n        if (availableSpace < REQUIRED_SPACE) {\n            throw \"Insufficient backup space\";\n        }\n        performBackup();\n    } catch (const char *error) {\n        fprintf(stderr, \"Error: %s\\n\", error);\n    }\n    return 0;\n}\n```"
  },
  {
    "task": "Create a program that processes natural language text and handles parsing exceptions.",
    "code": "```c\n#include <stdio.h>\n#include <setjmp.h>\n#include <string.h>\n\njmp_buf jump_buffer;\n\nvoid parseText(const char *text) {\n    if (text == NULL) {\n        longjmp(jump_buffer, 1);\n    }\n    // Simulated parsing logic\n    if (strstr(text, \"error\") != NULL) {\n        longjmp(jump_buffer, 2);\n    }\n    printf(\"Text parsed successfully: %s\\n\", text);\n}\n\nint main() {\n    const char *texts[] = {\n        \"This is a valid sentence.\",\n        \"This contains an error.\",\n        NULL\n    };\n    int n = sizeof(texts) / sizeof(texts[0]);\n\n    for (int i = 0; i < n; i++) {\n        int exception = setjmp(jump_buffer);\n        if (exception == 0) {\n            parseText(texts[i]);\n        } else if (exception == 1) {\n            printf(\"Exception: NULL text encountered.\\n\");\n        } else if (exception == 2) {\n            printf(\"Exception: Parsing error detected in text.\\n\");\n        }\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a function that manages thread execution and handles race condition exceptions.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <pthread.h>\n\ntypedef struct {\n    int *shared_resource;\n    pthread_mutex_t *mutex;\n} ThreadData;\n\nvoid *thread_function(void *arg) {\n    ThreadData *data = (ThreadData *)arg;\n\n    if (pthread_mutex_lock(data->mutex) != 0) {\n        perror(\"Failed to lock mutex\");\n        pthread_exit(NULL);\n    }\n\n    // Simulate work with the shared resource\n    (*(data->shared_resource))++;\n\n    if (pthread_mutex_unlock(data->mutex) != 0) {\n        perror(\"Failed to unlock mutex\");\n        pthread_exit(NULL);\n    }\n\n    pthread_exit(NULL);\n}\n\nint main() {\n    pthread_t threads[2];\n    int shared_resource = 0;\n    pthread_mutex_t mutex;\n\n    if (pthread_mutex_init(&mutex, NULL) != 0) {\n        perror(\"Mutex initialization failed\");\n        return EXIT_FAILURE;\n    }\n\n    ThreadData data = {&shared_resource, &mutex};\n\n    for (int i = 0; i < 2; ++i) {\n        if (pthread_create(&threads[i], NULL, thread_function, &data) != 0) {\n            perror(\"Thread creation failed\");\n            return EXIT_FAILURE;\n        }\n    }\n\n    for (int i = 0; i < 2; ++i) {\n        if (pthread_join(threads[i], NULL) != 0) {\n            perror(\"Thread join failed\");\n            return EXIT_FAILURE;\n        }\n    }\n\n    printf(\"Shared resource value: %d\\n\", shared_resource);\n\n    if (pthread_mutex_destroy(&mutex) != 0) {\n        perror(\"Mutex destruction failed\");\n        return EXIT_FAILURE;\n    }\n\n    return EXIT_SUCCESS;\n}\n```"
  },
  {
    "task": "Develop a system that integrates with IoT devices and handles connectivity exceptions.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <time.h>\n\nbool connectToDevice() {\n    // Simulate a 70% chance of successful connection\n    return rand() % 10 < 7;\n}\n\nvoid handleConnectionException(const char *message) {\n    fprintf(stderr, \"Connection Error: %s\\n\", message);\n}\n\nint main() {\n    srand(time(NULL));\n\n    for (int i = 0; i < 5; i++) {\n        if (!connectToDevice()) {\n            handleConnectionException(\"Failed to connect to IoT device.\");\n            continue;\n        }\n        printf(\"Connected to IoT device successfully.\\n\");\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that manages application logging and handles exceptions for log overflow.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_LOG_SIZE 1024\n\ntypedef struct {\n    char logs[MAX_LOG_SIZE];\n    size_t log_length;\n} LogManager;\n\nvoid handle_log_overflow() {\n    fprintf(stderr, \"Log overflow error: Maximum log size exceeded.\\n\");\n    exit(EXIT_FAILURE);\n}\n\nvoid add_log(LogManager *manager, const char *new_log) {\n    size_t new_log_length = strlen(new_log);\n    if (manager->log_length + new_log_length >= MAX_LOG_SIZE) {\n        handle_log_overflow();\n    }\n    strcat(manager->logs, new_log);\n    manager->log_length += new_log_length;\n}\n\nint main() {\n    LogManager manager = { \"\", 0 };\n    \n    add_log(&manager, \"Log entry 1\\n\");\n    add_log(&manager, \"Log entry 2\\n\");\n    // Add more logs as needed\n    \n    printf(\"%s\", manager.logs);\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Create a tool that visualizes data and handles exceptions for unsupported visualization types.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\nvoid visualizeData(const char* type) {\n    if (strcmp(type, \"bar\") == 0) {\n        printf(\"Visualizing data as a bar chart...\\n\");\n        // Implement bar chart visualization logic here\n    } else if (strcmp(type, \"line\") == 0) {\n        printf(\"Visualizing data as a line chart...\\n\");\n        // Implement line chart visualization logic here\n    } else {\n        fprintf(stderr, \"Error: Unsupported visualization type '%s'\\n\", type);\n    }\n}\n\nint main() {\n    const char* visualizationType = \"pie\"; // Example type for testing\n\n    visualizeData(visualizationType);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Design a program that performs genetic algorithm simulations and manages exception for invalid mutations.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <setjmp.h>\n\n#define POPULATION_SIZE 100\n#define MUTATION_RATE 0.01\n#define CHROMOSOME_LENGTH 10\n\njmp_buf buf;\n\nvoid handle_exception(const char *message) {\n    printf(\"Exception: %s\\n\", message);\n    longjmp(buf, 1);\n}\n\nint random_gene() {\n    return rand() % 2;\n}\n\nvoid mutate(int *chromosome) {\n    for (int i = 0; i < CHROMOSOME_LENGTH; i++) {\n        if ((double)rand() / RAND_MAX < MUTATION_RATE) {\n            if (rand() % 10 == 0) { // simulate invalid mutation\n                handle_exception(\"Invalid mutation detected\");\n            }\n            chromosome[i] = random_gene();\n        }\n    }\n}\n\nvoid genetic_algorithm_simulation() {\n    int population[POPULATION_SIZE][CHROMOSOME_LENGTH];\n\n    for (int i = 0; i < POPULATION_SIZE; i++) {\n        for (int j = 0; j < CHROMOSOME_LENGTH; j++) {\n            population[i][j] = random_gene();\n        }\n    }\n\n    for (int generation = 0; generation < 100; generation++) {\n        for (int i = 0; i < POPULATION_SIZE; i++) {\n            if (setjmp(buf) == 0) {\n                mutate(population[i]);\n            } else {\n                // Handle exception: e.g., log, reset, etc.\n                // For now, just re-initialize the chromosome\n                for (int j = 0; j < CHROMOSOME_LENGTH; j++) {\n                    population[i][j] = random_gene();\n                }\n            }\n        }\n        // Continue with other genetic operations like selection, crossover, etc.\n    }\n}\n\nint main() {\n    srand(time(NULL));\n    genetic_algorithm_simulation();\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a function that manages distributed transactions and handles consistency exceptions.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef enum {\n    TRANSACTION_SUCCESS,\n    TRANSACTION_FAILURE,\n    CONSISTENCY_EXCEPTION\n} TransactionStatus;\n\nTransactionStatus performDistributedTransaction() {\n    // Simulate a transaction process\n    int randomResult = rand() % 3;\n    switch (randomResult) {\n        case 0: return TRANSACTION_SUCCESS;\n        case 1: return TRANSACTION_FAILURE;\n        case 2: return CONSISTENCY_EXCEPTION;\n    }\n    return TRANSACTION_FAILURE;\n}\n\nvoid handleTransaction() {\n    TransactionStatus status = performDistributedTransaction();\n    switch (status) {\n        case TRANSACTION_SUCCESS:\n            printf(\"Transaction completed successfully.\\n\");\n            break;\n        case TRANSACTION_FAILURE:\n            printf(\"Transaction failed. Retrying...\\n\");\n            handleTransaction(); // Retry logic\n            break;\n        case CONSISTENCY_EXCEPTION:\n            printf(\"Consistency exception encountered. Rolling back...\\n\");\n            // Rollback logic\n            break;\n    }\n}\n\nint main() {\n    srand(time(NULL));\n    handleTransaction();\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that handles secure communications and manages encryption key exceptions.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <setjmp.h>\n\njmp_buf jumpBuffer;\n\nvoid handleKeyException(const char *message) {\n    printf(\"Encryption Key Error: %s\\n\", message);\n    longjmp(jumpBuffer, 1);\n}\n\nvoid secureCommunication(const char *encryptionKey) {\n    if (strlen(encryptionKey) != 16) {\n        handleKeyException(\"Invalid key length. Key must be 16 characters.\");\n        return;\n    }\n\n    printf(\"Secure communication established using encryption key: %s\\n\", encryptionKey);\n}\n\nint main() {\n    const char *key = \"shortkey\";\n\n    if (setjmp(jumpBuffer) == 0) {\n        secureCommunication(key);\n    } else {\n        printf(\"Exception handled, continuing execution.\\n\");\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a system that processes sensor data and handles out-of-range value exceptions.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <setjmp.h>\n\n#define MIN_VALUE 0\n#define MAX_VALUE 100\n\njmp_buf exception_env;\n\nvoid process_sensor_data(int data) {\n    if (data < MIN_VALUE || data > MAX_VALUE) {\n        longjmp(exception_env, 1);\n    }\n    printf(\"Processing sensor data: %d\\n\", data);\n}\n\nint main() {\n    int sensor_data[] = {20, 150, 50, -10, 70};\n    size_t data_size = sizeof(sensor_data) / sizeof(sensor_data[0]);\n\n    if (setjmp(exception_env) == 0) {\n        for (size_t i = 0; i < data_size; i++) {\n            process_sensor_data(sensor_data[i]);\n        }\n    } else {\n        printf(\"Exception caught: Sensor data out of range\\n\");\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a program that simulates weather patterns and handles model prediction exceptions.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n#define TEMPERATURE_THRESHOLD 50\n\n// Custom exception for prediction errors\ntypedef struct {\n    const char *message;\n} PredictionException;\n\n// Function to simulate weather prediction\nint predict_weather() {\n    int temperature = rand() % 100; // Simulated temperature prediction\n    if (temperature > TEMPERATURE_THRESHOLD) {\n        PredictionException e = {\"Temperature prediction out of bounds\"};\n        throw_prediction_exception(e);\n    }\n    return temperature;\n}\n\n// Function to handle prediction exceptions\nvoid throw_prediction_exception(PredictionException e) {\n    fprintf(stderr, \"Prediction Exception: %s\\n\", e.message);\n    exit(EXIT_FAILURE);\n}\n\nint main() {\n    srand(time(NULL)); // Seed random number generator\n\n    try {\n        int predicted_temperature = predict_weather();\n        printf(\"Predicted Temperature: %d\\n\", predicted_temperature);\n    } catch (PredictionException e) {\n        fprintf(stderr, \"Caught Exception: %s\\n\", e.message);\n    }\n\n    return 0;\n}\n```\n\nNote: C does not natively support exception handling as languages like C++ or Java do. The above code uses a workaround with custom exception structures and function calls to simulate exception handling. It uses `exit(EXIT_FAILURE)` to stop execution on exceptions."
  },
  {
    "task": "Design a function that manages API versioning and handles backward compatibility exceptions.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n#include <setjmp.h>\n\njmp_buf buffer;\n\ntypedef struct {\n    int major;\n    int minor;\n} APIVersion;\n\nvoid handleCompatibilityException(const char *message) {\n    printf(\"Compatibility Exception: %s\\n\", message);\n    longjmp(buffer, 1);\n}\n\nvoid useAPIFeature(APIVersion version) {\n    if (setjmp(buffer) == 0) {\n        if (version.major < 2) {\n            handleCompatibilityException(\"API version not supported. Upgrade to version 2.0 or later.\");\n        } else {\n            printf(\"Using API version %d.%d\\n\", version.major, version.minor);\n            // Use the API feature\n        }\n    } else {\n        // Exception handling code\n        printf(\"Handling exception for version %d.%d\\n\", version.major, version.minor);\n    }\n}\n\nint main() {\n    APIVersion v1 = {1, 5};\n    APIVersion v2 = {2, 0};\n\n    useAPIFeature(v1);\n    useAPIFeature(v2);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a tool that converts character encodings and handles unsupported encoding exceptions.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <iconv.h>\n#include <string.h>\n#include <errno.h>\n\nvoid convert_encoding(const char *from_encoding, const char *to_encoding, const char *input, char *output, size_t out_size) {\n    iconv_t cd = iconv_open(to_encoding, from_encoding);\n    if (cd == (iconv_t)(-1)) {\n        if (errno == EINVAL) {\n            fprintf(stderr, \"Unsupported encoding conversion: %s to %s\\n\", from_encoding, to_encoding);\n        } else {\n            perror(\"iconv_open\");\n        }\n        exit(EXIT_FAILURE);\n    }\n\n    char *in_buf = (char *)input;\n    char *out_buf = output;\n    size_t in_bytes_left = strlen(input);\n    size_t out_bytes_left = out_size;\n\n    if (iconv(cd, &in_buf, &in_bytes_left, &out_buf, &out_bytes_left) == (size_t)(-1)) {\n        perror(\"iconv\");\n        iconv_close(cd);\n        exit(EXIT_FAILURE);\n    }\n\n    *out_buf = '\\0';  // Null-terminate the output string\n    iconv_close(cd);\n}\n\nint main() {\n    const char *input = \"Hello, World!\";\n    const char *from_encoding = \"UTF-8\";\n    const char *to_encoding = \"ISO-8859-1\";\n    char output[256];\n\n    convert_encoding(from_encoding, to_encoding, input, output, sizeof(output));\n\n    printf(\"Converted text: %s\\n\", output);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a program that handles dynamic content generation and manages template parsing exceptions.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <setjmp.h>\n\njmp_buf jump_buffer;\n\nvoid handle_template_parsing(const char *template) {\n    if (strstr(template, \"{{\") == NULL || strstr(template, \"}}\") == NULL) {\n        longjmp(jump_buffer, 1); // Simulate exception handling\n    }\n    printf(\"Template parsed successfully: %s\\n\", template);\n}\n\nint main() {\n    const char *template = \"{{name}} is {{age}} years old.\";\n    const char *invalid_template = \"name is age years old.\";\n    \n    if (setjmp(jump_buffer) == 0) {\n        handle_template_parsing(template);\n    } else {\n        printf(\"Error: Invalid template format.\\n\");\n    }\n\n    if (setjmp(jump_buffer) == 0) {\n        handle_template_parsing(invalid_template);\n    } else {\n        printf(\"Error: Invalid template format.\\n\");\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a script that schedules automated tests and handles exceptions for missing test cases.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    char *name;\n    int (*testFunction)(void);\n} TestCase;\n\nint sampleTest() {\n    // Sample test logic\n    return 1; // Return 1 for success, 0 for failure\n}\n\nint executeTestCase(TestCase *testCase) {\n    if (testCase == NULL || testCase->testFunction == NULL) {\n        fprintf(stderr, \"Error: Test case or test function is missing.\\n\");\n        return 0;\n    }\n    return testCase->testFunction();\n}\n\nint main() {\n    TestCase testCases[] = {\n        {\"Sample Test\", sampleTest},\n        {NULL, NULL} // Placeholder for additional test cases\n    };\n    \n    for (int i = 0; i < sizeof(testCases) / sizeof(TestCase); i++) {\n        if (testCases[i].name == NULL) {\n            fprintf(stderr, \"Exception: Missing test case at index %d.\\n\", i);\n            continue;\n        }\n        printf(\"Running %s...\\n\", testCases[i].name);\n        if (executeTestCase(&testCases[i])) {\n            printf(\"%s passed.\\n\", testCases[i].name);\n        } else {\n            printf(\"%s failed.\\n\", testCases[i].name);\n        }\n    }\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Develop a system that manages virtual machine instances and handles provisioning exceptions.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n\ntypedef struct {\n    int id;\n    char *name;\n    int isProvisioned;\n} VirtualMachine;\n\nVirtualMachine* provisionVM(int id, const char *name) {\n    VirtualMachine *vm = (VirtualMachine *)malloc(sizeof(VirtualMachine));\n    if (vm == NULL) {\n        perror(\"Failed to allocate memory for VM\");\n        return NULL;\n    }\n    vm->id = id;\n    vm->name = strdup(name);\n    if (vm->name == NULL) {\n        perror(\"Failed to allocate memory for VM name\");\n        free(vm);\n        return NULL;\n    }\n    vm->isProvisioned = 1; // Simulate successful provisioning\n    return vm;\n}\n\nvoid handleProvisioningError() {\n    fprintf(stderr, \"Provisioning Error: %s\\n\", strerror(errno));\n}\n\nint main() {\n    VirtualMachine *vm = provisionVM(1, \"VM-Instance-1\");\n    if (vm == NULL) {\n        handleProvisioningError();\n        return EXIT_FAILURE;\n    }\n\n    printf(\"VM ID: %d, Name: %s, Provisioned: %d\\n\", vm->id, vm->name, vm->isProvisioned);\n\n    free(vm->name);\n    free(vm);\n\n    return EXIT_SUCCESS;\n}\n```"
  },
  {
    "task": "Write a function that processes credit scores and handles exceptions for missing credit history.",
    "code": "```c\n#include <stdio.h>\n#include <setjmp.h>\n\njmp_buf env;\n\nvoid processCreditScore(int* creditScore) {\n    if (creditScore == NULL) {\n        longjmp(env, 1);\n    }\n    printf(\"Processing credit score: %d\\n\", *creditScore);\n}\n\nint main() {\n    int missingCreditHistory = setjmp(env);\n    \n    if (missingCreditHistory) {\n        printf(\"Exception: Missing credit history.\\n\");\n    } else {\n        int score = 750;\n        processCreditScore(&score);\n        processCreditScore(NULL); // This will trigger the exception\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a tool that manages digital certificates and handles expiration exceptions.",
    "code": "```c\n#include <stdio.h>\n#include <time.h>\n#include <string.h>\n\ntypedef struct {\n    char name[50];\n    time_t expiration;\n} Certificate;\n\nvoid checkCertificateExpiration(Certificate cert) {\n    time_t currentTime = time(NULL);\n    if (difftime(cert.expiration, currentTime) < 0) {\n        fprintf(stderr, \"Error: Certificate '%s' has expired.\\n\", cert.name);\n    } else {\n        printf(\"Certificate '%s' is valid.\\n\", cert.name);\n    }\n}\n\nint main() {\n    Certificate cert1;\n    strcpy(cert1.name, \"Cert1\");\n    struct tm expTime1 = {0};\n    expTime1.tm_year = 2023 - 1900; // Year 2023\n    expTime1.tm_mon = 11;           // December\n    expTime1.tm_mday = 31;          // 31st\n    cert1.expiration = mktime(&expTime1);\n\n    Certificate cert2;\n    strcpy(cert2.name, \"Cert2\");\n    struct tm expTime2 = {0};\n    expTime2.tm_year = 2022 - 1900; // Year 2022\n    expTime2.tm_mon = 0;            // January\n    expTime2.tm_mday = 1;           // 1st\n    cert2.expiration = mktime(&expTime2);\n\n    checkCertificateExpiration(cert1);\n    checkCertificateExpiration(cert2);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Design a program that processes genome sequences and handles exceptions for sequence alignment.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <setjmp.h>\n\njmp_buf env;\n\nvoid processGenomeSequence(const char *sequence) {\n    if (sequence == NULL) {\n        // Handle null sequence\n        printf(\"Error: Null sequence encountered.\\n\");\n        longjmp(env, 1);\n    }\n\n    size_t length = strlen(sequence);\n    if (length == 0) {\n        // Handle empty sequence\n        printf(\"Error: Empty sequence encountered.\\n\");\n        longjmp(env, 1);\n    }\n\n    // Example of processing: let's check for invalid characters\n    for (size_t i = 0; i < length; ++i) {\n        if (sequence[i] != 'A' && sequence[i] != 'T' && sequence[i] != 'C' && sequence[i] != 'G') {\n            printf(\"Error: Invalid character '%c' at position %zu.\\n\", sequence[i], i);\n            longjmp(env, 1);\n        }\n    }\n\n    // If everything is fine\n    printf(\"Sequence processed successfully: %s\\n\", sequence);\n}\n\nint main() {\n    char *sequences[] = {\"ATCG\", \"ATXG\", \"\", NULL, \"GGATCC\"};\n    size_t numSequences = sizeof(sequences) / sizeof(sequences[0]);\n\n    for (size_t i = 0; i < numSequences; ++i) {\n        if (setjmp(env) == 0) {\n            processGenomeSequence(sequences[i]);\n        } else {\n            printf(\"Sequence processing failed for sequence %zu.\\n\", i);\n        }\n    }\n\n    return 0;\n}\n```"
  }
]