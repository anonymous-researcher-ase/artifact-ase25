[
  {
    "task": "Create a set to store unique usernames and demonstrate adding new ones.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_USERS 100\n#define MAX_USERNAME_LEN 50\n\ntypedef struct {\n    char usernames[MAX_USERS][MAX_USERNAME_LEN];\n    int count;\n} Set;\n\nvoid initializeSet(Set *set) {\n    set->count = 0;\n}\n\nint contains(Set *set, const char *username) {\n    for (int i = 0; i < set->count; i++) {\n        if (strcmp(set->usernames[i], username) == 0) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nvoid addUsername(Set *set, const char *username) {\n    if (!contains(set, username) && set->count < MAX_USERS) {\n        strcpy(set->usernames[set->count], username);\n        set->count++;\n    }\n}\n\nint main() {\n    Set userSet;\n    initializeSet(&userSet);\n\n    addUsername(&userSet, \"user1\");\n    addUsername(&userSet, \"user2\");\n    addUsername(&userSet, \"user1\"); // Attempt to add a duplicate\n\n    for (int i = 0; i < userSet.count; i++) {\n        printf(\"%s\\n\", userSet.usernames[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that returns the union of two sets of integers.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\n// Define the set data structure\ntypedef struct {\n    int *elements;\n    int size;\n} Set;\n\n// Function to check if an element is in the set\nint isElementInSet(Set set, int element) {\n    for (int i = 0; i < set.size; i++) {\n        if (set.elements[i] == element) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\n// Function to compute the union of two sets\nSet unionOfSets(Set set1, Set set2) {\n    Set unionSet;\n    unionSet.size = set1.size + set2.size;\n    unionSet.elements = (int *)malloc(unionSet.size * sizeof(int));\n\n    int index = 0;\n    for (int i = 0; i < set1.size; i++) {\n        unionSet.elements[index++] = set1.elements[i];\n    }\n\n    for (int i = 0; i < set2.size; i++) {\n        if (!isElementInSet(set1, set2.elements[i])) {\n            unionSet.elements[index++] = set2.elements[i];\n        }\n    }\n\n    unionSet.size = index;\n    return unionSet;\n}\n\n// Function to free the memory allocated for a set\nvoid freeSet(Set set) {\n    free(set.elements);\n}\n\nint main() {\n    Set set1 = { (int[]){1, 2, 3}, 3 };\n    Set set2 = { (int[]){3, 4, 5}, 3 };\n\n    Set unionSet = unionOfSets(set1, set2);\n\n    printf(\"Union of sets: \");\n    for (int i = 0; i < unionSet.size; i++) {\n        printf(\"%d \", unionSet.elements[i]);\n    }\n    printf(\"\\n\");\n\n    freeSet(unionSet);\n    return 0;\n}\n```"
  },
  {
    "task": "Given two sets of strings, find their intersection.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n// Define a node for the linked list\ntypedef struct Node {\n    char *value;\n    struct Node *next;\n} Node;\n\n// Function to insert a node into the linked list\nNode* insert(Node *head, char *value) {\n    Node *new_node = (Node *)malloc(sizeof(Node));\n    new_node->value = strdup(value);\n    new_node->next = head;\n    return new_node;\n}\n\n// Function to check if a value exists in the linked list\nint contains(Node *head, char *value) {\n    Node *current = head;\n    while (current != NULL) {\n        if (strcmp(current->value, value) == 0) {\n            return 1;\n        }\n        current = current->next;\n    }\n    return 0;\n}\n\n// Function to find the intersection of two sets\nNode* intersection(Node *set1, Node *set2) {\n    Node *result = NULL;\n    while (set1 != NULL) {\n        if (contains(set2, set1->value)) {\n            result = insert(result, set1->value);\n        }\n        set1 = set1->next;\n    }\n    return result;\n}\n\n// Function to free the linked list\nvoid free_list(Node *head) {\n    Node *current = head;\n    while (current != NULL) {\n        Node *next = current->next;\n        free(current->value);\n        free(current);\n        current = next;\n    }\n}\n\n// Function to print the linked list\nvoid print_list(Node *head) {\n    Node *current = head;\n    while (current != NULL) {\n        printf(\"%s\\n\", current->value);\n        current = current->next;\n    }\n}\n\nint main() {\n    // Example usage\n    Node *set1 = NULL;\n    set1 = insert(set1, \"apple\");\n    set1 = insert(set1, \"banana\");\n    set1 = insert(set1, \"cherry\");\n\n    Node *set2 = NULL;\n    set2 = insert(set2, \"banana\");\n    set2 = insert(set2, \"date\");\n    set2 = insert(set2, \"apple\");\n\n    Node *result = intersection(set1, set2);\n\n    printf(\"Intersection:\\n\");\n    print_list(result);\n\n    // Free memory\n    free_list(set1);\n    free_list(set2);\n    free_list(result);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a set to track visited web pages and check if a page has been visited.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_URL_LENGTH 256\n#define INITIAL_SET_SIZE 100\n\ntypedef struct {\n    char **urls;\n    int size;\n    int count;\n} Set;\n\nSet* createSet(int size) {\n    Set *set = (Set *)malloc(sizeof(Set));\n    set->urls = (char **)malloc(sizeof(char *) * size);\n    set->size = size;\n    set->count = 0;\n    return set;\n}\n\nvoid freeSet(Set *set) {\n    for (int i = 0; i < set->count; i++) {\n        free(set->urls[i]);\n    }\n    free(set->urls);\n    free(set);\n}\n\nint contains(Set *set, const char *url) {\n    for (int i = 0; i < set->count; i++) {\n        if (strcmp(set->urls[i], url) == 0) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nvoid add(Set *set, const char *url) {\n    if (!contains(set, url)) {\n        if (set->count == set->size) {\n            set->size *= 2;\n            set->urls = (char **)realloc(set->urls, sizeof(char *) * set->size);\n        }\n        set->urls[set->count] = (char *)malloc(strlen(url) + 1);\n        strcpy(set->urls[set->count], url);\n        set->count++;\n    }\n}\n\nint main() {\n    Set *visitedPages = createSet(INITIAL_SET_SIZE);\n\n    add(visitedPages, \"http://example.com\");\n    add(visitedPages, \"http://example.org\");\n\n    if (contains(visitedPages, \"http://example.com\")) {\n        printf(\"Page 'http://example.com' has been visited.\\n\");\n    } else {\n        printf(\"Page 'http://example.com' has not been visited.\\n\");\n    }\n\n    if (contains(visitedPages, \"http://example.net\")) {\n        printf(\"Page 'http://example.net' has been visited.\\n\");\n    } else {\n        printf(\"Page 'http://example.net' has not been visited.\\n\");\n    }\n\n    freeSet(visitedPages);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a set from a list of numbers and remove duplicates.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct Node {\n    int data;\n    struct Node *next;\n} Node;\n\ntypedef struct Set {\n    Node *head;\n} Set;\n\nSet* createSet() {\n    Set* newSet = (Set*)malloc(sizeof(Set));\n    newSet->head = NULL;\n    return newSet;\n}\n\nbool isPresent(Set* set, int value) {\n    Node* current = set->head;\n    while (current != NULL) {\n        if (current->data == value) {\n            return true;\n        }\n        current = current->next;\n    }\n    return false;\n}\n\nvoid add(Set* set, int value) {\n    if (!isPresent(set, value)) {\n        Node* newNode = (Node*)malloc(sizeof(Node));\n        newNode->data = value;\n        newNode->next = set->head;\n        set->head = newNode;\n    }\n}\n\nvoid freeSet(Set* set) {\n    Node* current = set->head;\n    Node* nextNode;\n    while (current != NULL) {\n        nextNode = current->next;\n        free(current);\n        current = nextNode;\n    }\n    free(set);\n}\n\nint main() {\n    int numbers[] = {1, 2, 3, 4, 3, 2, 1, 5};\n    int size = sizeof(numbers) / sizeof(numbers[0]);\n\n    Set* uniqueSet = createSet();\n\n    for (int i = 0; i < size; i++) {\n        add(uniqueSet, numbers[i]);\n    }\n\n    Node* current = uniqueSet->head;\n    while (current != NULL) {\n        printf(\"%d \", current->data);\n        current = current->next;\n    }\n\n    freeSet(uniqueSet);\n    return 0;\n}\n```"
  },
  {
    "task": "Check if a set is a subset of another set.",
    "code": "```c\n#include <stdio.h>\n#include <stdbool.h>\n\nbool isSubset(int *setA, int sizeA, int *setB, int sizeB) {\n    for (int i = 0; i < sizeA; i++) {\n        bool found = false;\n        for (int j = 0; j < sizeB; j++) {\n            if (setA[i] == setB[j]) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    int setA[] = {1, 2, 3};\n    int setB[] = {1, 2, 3, 4, 5};\n    int sizeA = sizeof(setA) / sizeof(setA[0]);\n    int sizeB = sizeof(setB) / sizeof(setB[0]);\n\n    if (isSubset(setA, sizeA, setB, sizeB)) {\n        printf(\"Set A is a subset of Set B\\n\");\n    } else {\n        printf(\"Set A is not a subset of Set B\\n\");\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Demonstrate adding and removing elements from a set of book titles.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_BOOKS 100\n#define TITLE_LENGTH 100\n\ntypedef struct {\n    char titles[MAX_BOOKS][TITLE_LENGTH];\n    int count;\n} BookSet;\n\nvoid initializeSet(BookSet *set) {\n    set->count = 0;\n}\n\nint contains(BookSet *set, const char *title) {\n    for (int i = 0; i < set->count; i++) {\n        if (strcmp(set->titles[i], title) == 0) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nvoid addTitle(BookSet *set, const char *title) {\n    if (!contains(set, title) && set->count < MAX_BOOKS) {\n        strcpy(set->titles[set->count], title);\n        set->count++;\n    }\n}\n\nvoid removeTitle(BookSet *set, const char *title) {\n    for (int i = 0; i < set->count; i++) {\n        if (strcmp(set->titles[i], title) == 0) {\n            for (int j = i; j < set->count - 1; j++) {\n                strcpy(set->titles[j], set->titles[j + 1]);\n            }\n            set->count--;\n            break;\n        }\n    }\n}\n\nvoid printSet(BookSet *set) {\n    printf(\"Book Titles in Set:\\n\");\n    for (int i = 0; i < set->count; i++) {\n        printf(\"%s\\n\", set->titles[i]);\n    }\n}\n\nint main() {\n    BookSet myBooks;\n    initializeSet(&myBooks);\n    \n    addTitle(&myBooks, \"The Great Gatsby\");\n    addTitle(&myBooks, \"To Kill a Mockingbird\");\n    addTitle(&myBooks, \"1984\");\n    \n    printSet(&myBooks);\n    \n    removeTitle(&myBooks, \"1984\");\n    \n    printSet(&myBooks);\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Create a set and show how to clear all its elements.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct Set {\n    int *elements;\n    size_t size;\n    size_t capacity;\n} Set;\n\nSet *createSet(size_t capacity) {\n    Set *set = (Set *)malloc(sizeof(Set));\n    set->elements = (int *)malloc(capacity * sizeof(int));\n    set->size = 0;\n    set->capacity = capacity;\n    return set;\n}\n\nbool addElement(Set *set, int element) {\n    if (set->size >= set->capacity) {\n        return false;\n    }\n    for (size_t i = 0; i < set->size; i++) {\n        if (set->elements[i] == element)\n            return false;\n    }\n    set->elements[set->size++] = element;\n    return true;\n}\n\nvoid clearSet(Set *set) {\n    set->size = 0;\n}\n\nvoid freeSet(Set *set) {\n    free(set->elements);\n    free(set);\n}\n\nint main() {\n    Set *mySet = createSet(10);\n    addElement(mySet, 1);\n    addElement(mySet, 2);\n    addElement(mySet, 3);\n    \n    clearSet(mySet);\n\n    freeSet(mySet);\n    return 0;\n}\n```"
  },
  {
    "task": "Write a program to find the difference between two sets of employee IDs.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    int data;\n    struct Node* next;\n} Node;\n\ntypedef struct Set {\n    Node* head;\n} Set;\n\nSet* createSet() {\n    Set* set = (Set*) malloc(sizeof(Set));\n    set->head = NULL;\n    return set;\n}\n\nvoid add(Set* set, int data) {\n    Node* newNode = (Node*) malloc(sizeof(Node));\n    newNode->data = data;\n    newNode->next = NULL;\n    if (set->head == NULL) {\n        set->head = newNode;\n        return;\n    }\n    Node* current = set->head;\n    while (current->next != NULL) {\n        if (current->data == data) {\n            free(newNode);\n            return;\n        }\n        current = current->next;\n    }\n    if (current->data != data) {\n        current->next = newNode;\n    } else {\n        free(newNode);\n    }\n}\n\nint contains(Set* set, int data) {\n    Node* current = set->head;\n    while (current != NULL) {\n        if (current->data == data) {\n            return 1;\n        }\n        current = current->next;\n    }\n    return 0;\n}\n\nSet* difference(Set* set1, Set* set2) {\n    Set* diffSet = createSet();\n    Node* current = set1->head;\n    while (current != NULL) {\n        if (!contains(set2, current->data)) {\n            add(diffSet, current->data);\n        }\n        current = current->next;\n    }\n    return diffSet;\n}\n\nvoid printSet(Set* set) {\n    Node* current = set->head;\n    while (current != NULL) {\n        printf(\"%d \", current->data);\n        current = current->next;\n    }\n    printf(\"\\n\");\n}\n\nvoid freeSet(Set* set) {\n    Node* current = set->head;\n    Node* next;\n    while (current != NULL) {\n        next = current->next;\n        free(current);\n        current = next;\n    }\n    free(set);\n}\n\nint main() {\n    Set* set1 = createSet();\n    Set* set2 = createSet();\n\n    add(set1, 101);\n    add(set1, 102);\n    add(set1, 103);\n\n    add(set2, 102);\n    add(set2, 104);\n\n    Set* diffSet = difference(set1, set2);\n    printSet(diffSet);\n\n    freeSet(set1);\n    freeSet(set2);\n    freeSet(diffSet);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a set to store unique email addresses and check membership.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_EMAIL_LENGTH 100\n#define INITIAL_CAPACITY 10\n\ntypedef struct {\n    char **emails;\n    int size;\n    int capacity;\n} EmailSet;\n\nEmailSet* createEmailSet() {\n    EmailSet *set = malloc(sizeof(EmailSet));\n    set->emails = malloc(INITIAL_CAPACITY * sizeof(char*));\n    set->size = 0;\n    set->capacity = INITIAL_CAPACITY;\n    return set;\n}\n\nint emailExists(EmailSet *set, const char *email) {\n    for (int i = 0; i < set->size; i++) {\n        if (strcmp(set->emails[i], email) == 0) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nvoid addEmail(EmailSet *set, const char *email) {\n    if (emailExists(set, email)) {\n        return;\n    }\n    if (set->size == set->capacity) {\n        set->capacity *= 2;\n        set->emails = realloc(set->emails, set->capacity * sizeof(char*));\n    }\n    set->emails[set->size] = malloc((strlen(email) + 1) * sizeof(char));\n    strcpy(set->emails[set->size], email);\n    set->size++;\n}\n\nvoid freeEmailSet(EmailSet *set) {\n    for (int i = 0; i < set->size; i++) {\n        free(set->emails[i]);\n    }\n    free(set->emails);\n    free(set);\n}\n\nint main() {\n    EmailSet *set = createEmailSet();\n    addEmail(set, \"example1@example.com\");\n    addEmail(set, \"example2@example.com\");\n    printf(\"Email exists: %d\\n\", emailExists(set, \"example1@example.com\"));\n    printf(\"Email exists: %d\\n\", emailExists(set, \"example3@example.com\"));\n    freeEmailSet(set);\n    return 0;\n}\n```"
  },
  {
    "task": "Use a set to determine if two lists have any common elements.",
    "code": "```c\n#include <stdio.h>\n#include <stdbool.h>\n\n#define MAX 100\n\nbool hasCommonElements(int list1[], int size1, int list2[], int size2) {\n    bool set[MAX] = {false};\n\n    for (int i = 0; i < size1; i++) {\n        set[list1[i]] = true;\n    }\n\n    for (int i = 0; i < size2; i++) {\n        if (set[list2[i]]) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nint main() {\n    int list1[] = {1, 2, 3, 4, 5};\n    int list2[] = {6, 7, 3, 8, 9};\n\n    int size1 = sizeof(list1) / sizeof(list1[0]);\n    int size2 = sizeof(list2) / sizeof(list2[0]);\n\n    if (hasCommonElements(list1, size1, list2, size2)) {\n        printf(\"The lists have common elements.\\n\");\n    } else {\n        printf(\"The lists do not have common elements.\\n\");\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a set to represent a group of students and update it with new entries.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct Node {\n    char *data;\n    struct Node *next;\n} Node;\n\ntypedef struct Set {\n    Node *head;\n} Set;\n\nSet* createSet() {\n    Set *set = (Set *)malloc(sizeof(Set));\n    set->head = NULL;\n    return set;\n}\n\nint contains(Set *set, const char *element) {\n    Node *current = set->head;\n    while (current != NULL) {\n        if (strcmp(current->data, element) == 0) {\n            return 1;\n        }\n        current = current->next;\n    }\n    return 0;\n}\n\nvoid add(Set *set, const char *element) {\n    if (!contains(set, element)) {\n        Node *newNode = (Node *)malloc(sizeof(Node));\n        newNode->data = strdup(element);\n        newNode->next = set->head;\n        set->head = newNode;\n    }\n}\n\nvoid freeSet(Set *set) {\n    Node *current = set->head;\n    while (current != NULL) {\n        Node *next = current->next;\n        free(current->data);\n        free(current);\n        current = next;\n    }\n    free(set);\n}\n\nint main() {\n    Set *students = createSet();\n\n    add(students, \"Alice\");\n    add(students, \"Bob\");\n    add(students, \"Charlie\");\n    add(students, \"Alice\"); // Duplicate\n\n    // Clean up\n    freeSet(students);\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function to find symmetric difference between two sets of colors.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_COLORS 100\n#define COLOR_LENGTH 20\n\ntypedef struct {\n    char colors[MAX_COLORS][COLOR_LENGTH];\n    int size;\n} ColorSet;\n\nvoid addColor(ColorSet *set, const char *color) {\n    if (set->size < MAX_COLORS) {\n        strcpy(set->colors[set->size], color);\n        set->size++;\n    }\n}\n\nint containsColor(const ColorSet *set, const char *color) {\n    for (int i = 0; i < set->size; i++) {\n        if (strcmp(set->colors[i], color) == 0) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nColorSet symmetricDifference(const ColorSet *set1, const ColorSet *set2) {\n    ColorSet result;\n    result.size = 0;\n\n    for (int i = 0; i < set1->size; i++) {\n        if (!containsColor(set2, set1->colors[i])) {\n            addColor(&result, set1->colors[i]);\n        }\n    }\n\n    for (int i = 0; i < set2->size; i++) {\n        if (!containsColor(set1, set2->colors[i])) {\n            addColor(&result, set2->colors[i]);\n        }\n    }\n\n    return result;\n}\n\nint main() {\n    ColorSet set1 = { { \"red\", \"blue\", \"green\" }, 3 };\n    ColorSet set2 = { { \"yellow\", \"blue\", \"purple\" }, 3 };\n\n    ColorSet result = symmetricDifference(&set1, &set2);\n\n    printf(\"Symmetric Difference:\\n\");\n    for (int i = 0; i < result.size; i++) {\n        printf(\"%s\\n\", result.colors[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a set to store unique product codes and demonstrate iteration over it.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    char **items;\n    int size;\n    int capacity;\n} Set;\n\nSet *createSet(int capacity) {\n    Set *set = (Set *)malloc(sizeof(Set));\n    set->items = (char **)malloc(sizeof(char *) * capacity);\n    set->size = 0;\n    set->capacity = capacity;\n    return set;\n}\n\nint contains(Set *set, const char *item) {\n    for (int i = 0; i < set->size; i++) {\n        if (strcmp(set->items[i], item) == 0) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nvoid add(Set *set, const char *item) {\n    if (!contains(set, item)) {\n        if (set->size == set->capacity) {\n            set->capacity *= 2;\n            set->items = (char **)realloc(set->items, sizeof(char *) * set->capacity);\n        }\n        set->items[set->size] = strdup(item);\n        set->size++;\n    }\n}\n\nvoid freeSet(Set *set) {\n    for (int i = 0; i < set->size; i++) {\n        free(set->items[i]);\n    }\n    free(set->items);\n    free(set);\n}\n\nint main() {\n    Set *productCodes = createSet(5);\n\n    add(productCodes, \"A123\");\n    add(productCodes, \"B456\");\n    add(productCodes, \"C789\");\n    add(productCodes, \"A123\"); // Duplicate, won't be added\n\n    printf(\"Unique Product Codes:\\n\");\n    for (int i = 0; i < productCodes->size; i++) {\n        printf(\"%s\\n\", productCodes->items[i]);\n    }\n\n    freeSet(productCodes);\n    return 0;\n}\n```"
  },
  {
    "task": "Create a set and demonstrate the use of the `discard` method.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Set {\n    int *elements;\n    size_t size;\n    size_t capacity;\n} Set;\n\nSet* createSet(size_t capacity) {\n    Set *set = (Set *)malloc(sizeof(Set));\n    set->elements = (int *)malloc(capacity * sizeof(int));\n    set->size = 0;\n    set->capacity = capacity;\n    return set;\n}\n\nint contains(Set *set, int value) {\n    for (size_t i = 0; i < set->size; i++) {\n        if (set->elements[i] == value) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nvoid add(Set *set, int value) {\n    if (!contains(set, value) && set->size < set->capacity) {\n        set->elements[set->size++] = value;\n    }\n}\n\nvoid discard(Set *set, int value) {\n    for (size_t i = 0; i < set->size; i++) {\n        if (set->elements[i] == value) {\n            // Shift elements to the left\n            for (size_t j = i; j < set->size - 1; j++) {\n                set->elements[j] = set->elements[j + 1];\n            }\n            set->size--;\n            return;\n        }\n    }\n}\n\nvoid printSet(Set *set) {\n    printf(\"{ \");\n    for (size_t i = 0; i < set->size; i++) {\n        printf(\"%d \", set->elements[i]);\n    }\n    printf(\"}\\n\");\n}\n\nvoid freeSet(Set *set) {\n    free(set->elements);\n    free(set);\n}\n\nint main() {\n    Set *set = createSet(10);\n    \n    add(set, 1);\n    add(set, 2);\n    add(set, 3);\n    printf(\"Set after adding elements: \");\n    printSet(set);\n    \n    discard(set, 2);\n    printf(\"Set after discarding 2: \");\n    printSet(set);\n    \n    discard(set, 4);  // Attempt to discard a non-existent element\n    printf(\"Set after attempting to discard 4: \");\n    printSet(set);\n    \n    freeSet(set);\n    return 0;\n}\n```"
  },
  {
    "task": "Given a list of numbers, create a set and check if a specific number is present.",
    "code": "```c\n#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n\ntypedef struct Set {\n    int *elements;\n    size_t size;\n    size_t capacity;\n} Set;\n\nSet* createSet(size_t capacity) {\n    Set *set = (Set*)malloc(sizeof(Set));\n    set->elements = (int*)malloc(capacity * sizeof(int));\n    set->size = 0;\n    set->capacity = capacity;\n    return set;\n}\n\nvoid add(Set *set, int value) {\n    for (size_t i = 0; i < set->size; i++) {\n        if (set->elements[i] == value) {\n            return;\n        }\n    }\n    if (set->size < set->capacity) {\n        set->elements[set->size++] = value;\n    }\n}\n\nbool contains(Set *set, int value) {\n    for (size_t i = 0; i < set->size; i++) {\n        if (set->elements[i] == value) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid freeSet(Set *set) {\n    free(set->elements);\n    free(set);\n}\n\nint main() {\n    int numbers[] = {1, 2, 3, 4, 5, 6, 3, 2}; // example list of numbers\n    size_t numbersSize = sizeof(numbers) / sizeof(numbers[0]);\n    int specificNumber = 3;\n\n    Set *set = createSet(numbersSize);\n    for (size_t i = 0; i < numbersSize; i++) {\n        add(set, numbers[i]);\n    }\n\n    if (contains(set, specificNumber)) {\n        printf(\"Number %d is present in the set.\\n\", specificNumber);\n    } else {\n        printf(\"Number %d is not present in the set.\\n\", specificNumber);\n    }\n\n    freeSet(set);\n    return 0;\n}\n```"
  },
  {
    "task": "Use a set to find all unique words in a sentence.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_WORD_LENGTH 50\n#define MAX_WORDS 100\n\ntypedef struct {\n    char words[MAX_WORDS][MAX_WORD_LENGTH];\n    int size;\n} Set;\n\nint contains(Set *set, const char *word) {\n    for (int i = 0; i < set->size; ++i) {\n        if (strcmp(set->words[i], word) == 0) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nvoid add(Set *set, const char *word) {\n    if (!contains(set, word)) {\n        strcpy(set->words[set->size++], word);\n    }\n}\n\nvoid findUniqueWords(const char *sentence, Set *uniqueWords) {\n    char buffer[MAX_WORD_LENGTH];\n    int j = 0;\n    for (int i = 0; sentence[i] != '\\0'; ++i) {\n        if (sentence[i] == ' ') {\n            if (j > 0) {\n                buffer[j] = '\\0';\n                add(uniqueWords, buffer);\n                j = 0;\n            }\n        } else {\n            buffer[j++] = sentence[i];\n        }\n    }\n    if (j > 0) {\n        buffer[j] = '\\0';\n        add(uniqueWords, buffer);\n    }\n}\n\nint main() {\n    const char *sentence = \"This is a test sentence this is a test\";\n    Set uniqueWords = { .size = 0 };\n\n    findUniqueWords(sentence, &uniqueWords);\n\n    printf(\"Unique words:\\n\");\n    for (int i = 0; i < uniqueWords.size; ++i) {\n        printf(\"%s\\n\", uniqueWords.words[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a set from a sequence of characters and demonstrate set operations.",
    "code": "```c\n#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_SET_SIZE 256\n\ntypedef struct {\n    bool elements[MAX_SET_SIZE];\n} CharSet;\n\nvoid initSet(CharSet *set) {\n    for (int i = 0; i < MAX_SET_SIZE; i++) {\n        set->elements[i] = false;\n    }\n}\n\nvoid addToSet(CharSet *set, char element) {\n    set->elements[(unsigned char)element] = true;\n}\n\nbool isElementInSet(CharSet *set, char element) {\n    return set->elements[(unsigned char)element];\n}\n\nCharSet unionSets(CharSet *set1, CharSet *set2) {\n    CharSet resultSet;\n    initSet(&resultSet);\n    for (int i = 0; i < MAX_SET_SIZE; i++) {\n        resultSet.elements[i] = set1->elements[i] || set2->elements[i];\n    }\n    return resultSet;\n}\n\nCharSet intersectionSets(CharSet *set1, CharSet *set2) {\n    CharSet resultSet;\n    initSet(&resultSet);\n    for (int i = 0; i < MAX_SET_SIZE; i++) {\n        resultSet.elements[i] = set1->elements[i] && set2->elements[i];\n    }\n    return resultSet;\n}\n\nCharSet differenceSets(CharSet *set1, CharSet *set2) {\n    CharSet resultSet;\n    initSet(&resultSet);\n    for (int i = 0; i < MAX_SET_SIZE; i++) {\n        resultSet.elements[i] = set1->elements[i] && !set2->elements[i];\n    }\n    return resultSet;\n}\n\nvoid printSet(CharSet *set) {\n    printf(\"{ \");\n    for (int i = 0; i < MAX_SET_SIZE; i++) {\n        if (set->elements[i]) {\n            printf(\"%c \", (char)i);\n        }\n    }\n    printf(\"}\\n\");\n}\n\nint main() {\n    CharSet set1, set2, unionSet, intersectionSet, differenceSet;\n\n    initSet(&set1);\n    initSet(&set2);\n\n    char sequence1[] = \"abcde\";\n    char sequence2[] = \"cdefg\";\n\n    for (int i = 0; i < strlen(sequence1); i++) {\n        addToSet(&set1, sequence1[i]);\n    }\n\n    for (int i = 0; i < strlen(sequence2); i++) {\n        addToSet(&set2, sequence2[i]);\n    }\n\n    printf(\"Set 1: \");\n    printSet(&set1);\n\n    printf(\"Set 2: \");\n    printSet(&set2);\n\n    unionSet = unionSets(&set1, &set2);\n    printf(\"Union: \");\n    printSet(&unionSet);\n\n    intersectionSet = intersectionSets(&set1, &set2);\n    printf(\"Intersection: \");\n    printSet(&intersectionSet);\n\n    differenceSet = differenceSets(&set1, &set2);\n    printf(\"Difference (Set1 - Set2): \");\n    printSet(&differenceSet);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function to merge two sets and return the result.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int *elements;\n    size_t size;\n} Set;\n\nSet mergeSets(Set set1, Set set2) {\n    size_t maxSize = set1.size + set2.size;\n    int *mergedElements = (int *)malloc(maxSize * sizeof(int));\n    size_t index = 0;\n\n    for (size_t i = 0; i < set1.size; i++) {\n        mergedElements[index++] = set1.elements[i];\n    }\n\n    for (size_t i = 0; i < set2.size; i++) {\n        int found = 0;\n        for (size_t j = 0; j < set1.size; j++) {\n            if (set2.elements[i] == set1.elements[j]) {\n                found = 1;\n                break;\n            }\n        }\n        if (!found) {\n            mergedElements[index++] = set2.elements[i];\n        }\n    }\n\n    Set mergedSet;\n    mergedSet.elements = mergedElements;\n    mergedSet.size = index;\n    return mergedSet;\n}\n\nint main() {\n    Set set1 = { (int[]){1, 2, 3}, 3 };\n    Set set2 = { (int[]){3, 4, 5}, 3 };\n\n    Set resultSet = mergeSets(set1, set2);\n    \n    printf(\"Merged set: \");\n    for (size_t i = 0; i < resultSet.size; i++) {\n        printf(\"%d \", resultSet.elements[i]);\n    }\n    printf(\"\\n\");\n\n    free(resultSet.elements);\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a set to hold unique IP addresses and demonstrate basic operations.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_IP_LEN 16\n#define MAX_SET_SIZE 100\n\ntypedef struct {\n    char ip[MAX_IP_LEN];\n} IP;\n\ntypedef struct {\n    IP ip_set[MAX_SET_SIZE];\n    int size;\n} IPSet;\n\nint contains(IPSet *set, const char *ip) {\n    for (int i = 0; i < set->size; i++) {\n        if (strcmp(set->ip_set[i].ip, ip) == 0) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nvoid add_ip(IPSet *set, const char *ip) {\n    if (set->size < MAX_SET_SIZE && !contains(set, ip)) {\n        strncpy(set->ip_set[set->size].ip, ip, MAX_IP_LEN - 1);\n        set->ip_set[set->size].ip[MAX_IP_LEN - 1] = '\\0';\n        set->size++;\n    }\n}\n\nvoid remove_ip(IPSet *set, const char *ip) {\n    for (int i = 0; i < set->size; i++) {\n        if (strcmp(set->ip_set[i].ip, ip) == 0) {\n            for (int j = i; j < set->size - 1; j++) {\n                set->ip_set[j] = set->ip_set[j + 1];\n            }\n            set->size--;\n            break;\n        }\n    }\n}\n\nvoid print_set(IPSet *set) {\n    for (int i = 0; i < set->size; i++) {\n        printf(\"%s\\n\", set->ip_set[i].ip);\n    }\n}\n\nint main() {\n    IPSet my_set = {.size = 0};\n\n    add_ip(&my_set, \"192.168.1.1\");\n    add_ip(&my_set, \"10.0.0.1\");\n    add_ip(&my_set, \"192.168.1.1\"); // Duplicate, will not be added\n\n    printf(\"Set after adding IPs:\\n\");\n    print_set(&my_set);\n\n    remove_ip(&my_set, \"10.0.0.1\");\n\n    printf(\"\\nSet after removing an IP:\\n\");\n    print_set(&my_set);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a set and demonstrate how to find the size of the set.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Set {\n    int *elements;\n    int size;\n    int capacity;\n} Set;\n\nSet* createSet(int capacity) {\n    Set *set = (Set*)malloc(sizeof(Set));\n    set->elements = (int*)malloc(capacity * sizeof(int));\n    set->size = 0;\n    set->capacity = capacity;\n    return set;\n}\n\nint isElementInSet(Set *set, int element) {\n    for (int i = 0; i < set->size; i++) {\n        if (set->elements[i] == element) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nvoid addElement(Set *set, int element) {\n    if (!isElementInSet(set, element) && set->size < set->capacity) {\n        set->elements[set->size++] = element;\n    }\n}\n\nint getSetSize(Set *set) {\n    return set->size;\n}\n\nvoid freeSet(Set *set) {\n    free(set->elements);\n    free(set);\n}\n\nint main() {\n    Set *mySet = createSet(10);\n\n    addElement(mySet, 1);\n    addElement(mySet, 2);\n    addElement(mySet, 3);\n\n    printf(\"Size of the set: %d\\n\", getSetSize(mySet));\n\n    freeSet(mySet);\n    return 0;\n}\n```"
  },
  {
    "task": "Write a program to check if two sets of dates are disjoint.",
    "code": "```c\n#include <stdio.h>\n#include <stdbool.h>\n\n#define MAX_DATES 100\n\ntypedef struct {\n    int day;\n    int month;\n    int year;\n} Date;\n\nbool areDatesEqual(Date d1, Date d2) {\n    return d1.day == d2.day && d1.month == d2.month && d1.year == d2.year;\n}\n\nbool areSetsDisjoint(Date set1[], int size1, Date set2[], int size2) {\n    for (int i = 0; i < size1; i++) {\n        for (int j = 0; j < size2; j++) {\n            if (areDatesEqual(set1[i], set2[j])) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    Date set1[MAX_DATES] = {{1, 1, 2023}, {2, 2, 2023}, {3, 3, 2023}};\n    Date set2[MAX_DATES] = {{4, 4, 2023}, {5, 5, 2023}, {6, 6, 2023}};\n\n    int size1 = 3;\n    int size2 = 3;\n\n    if (areSetsDisjoint(set1, size1, set2, size2)) {\n        printf(\"The sets are disjoint.\\n\");\n    } else {\n        printf(\"The sets are not disjoint.\\n\");\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a set to manage a collection of tags and demonstrate addition and removal.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    char *tag;\n    struct Node *next;\n} Node;\n\ntypedef struct Set {\n    Node *head;\n} Set;\n\nSet* createSet() {\n    Set *set = (Set *)malloc(sizeof(Set));\n    set->head = NULL;\n    return set;\n}\n\nint contains(Set *set, const char *tag) {\n    Node *current = set->head;\n    while (current != NULL) {\n        if (strcmp(current->tag, tag) == 0) {\n            return 1;\n        }\n        current = current->next;\n    }\n    return 0;\n}\n\nvoid addTag(Set *set, const char *tag) {\n    if (!contains(set, tag)) {\n        Node *newNode = (Node *)malloc(sizeof(Node));\n        newNode->tag = strdup(tag);\n        newNode->next = set->head;\n        set->head = newNode;\n    }\n}\n\nvoid removeTag(Set *set, const char *tag) {\n    Node *current = set->head;\n    Node *previous = NULL;\n    \n    while (current != NULL) {\n        if (strcmp(current->tag, tag) == 0) {\n            if (previous == NULL) {\n                set->head = current->next;\n            } else {\n                previous->next = current->next;\n            }\n            free(current->tag);\n            free(current);\n            return;\n        }\n        previous = current;\n        current = current->next;\n    }\n}\n\nvoid printSet(Set *set) {\n    Node *current = set->head;\n    while (current != NULL) {\n        printf(\"%s \", current->tag);\n        current = current->next;\n    }\n    printf(\"\\n\");\n}\n\nvoid freeSet(Set *set) {\n    Node *current = set->head;\n    while (current != NULL) {\n        Node *next = current->next;\n        free(current->tag);\n        free(current);\n        current = next;\n    }\n    free(set);\n}\n\nint main() {\n    Set *tags = createSet();\n    \n    addTag(tags, \"C\");\n    addTag(tags, \"Python\");\n    addTag(tags, \"Java\");\n    \n    printf(\"Tags after addition: \");\n    printSet(tags);\n    \n    removeTag(tags, \"Python\");\n    \n    printf(\"Tags after removal: \");\n    printSet(tags);\n    \n    freeSet(tags);\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Implement a set to track unique inventory items in a store.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct Set {\n    char **items;\n    int size;\n    int capacity;\n} Set;\n\nSet* createSet(int capacity) {\n    Set *set = (Set *)malloc(sizeof(Set));\n    set->size = 0;\n    set->capacity = capacity;\n    set->items = (char **)malloc(sizeof(char *) * capacity);\n    return set;\n}\n\nint contains(Set *set, const char *item) {\n    for (int i = 0; i < set->size; i++) {\n        if (strcmp(set->items[i], item) == 0) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nvoid add(Set *set, const char *item) {\n    if (!contains(set, item)) {\n        if (set->size == set->capacity) {\n            set->capacity *= 2;\n            set->items = (char **)realloc(set->items, sizeof(char *) * set->capacity);\n        }\n        set->items[set->size] = strdup(item);\n        set->size++;\n    }\n}\n\nvoid freeSet(Set *set) {\n    for (int i = 0; i < set->size; i++) {\n        free(set->items[i]);\n    }\n    free(set->items);\n    free(set);\n}\n\nint main() {\n    Set *inventory = createSet(10);\n\n    add(inventory, \"apple\");\n    add(inventory, \"orange\");\n    add(inventory, \"banana\");\n    add(inventory, \"apple\"); // Duplicate, will not be added\n\n    for (int i = 0; i < inventory->size; i++) {\n        printf(\"%s\\n\", inventory->items[i]);\n    }\n\n    freeSet(inventory);\n    return 0;\n}\n```"
  },
  {
    "task": "Create a set of numbers and demonstrate conversion to a list.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MAX_SET_SIZE 100\n\ntypedef struct {\n    int elements[MAX_SET_SIZE];\n    int size;\n} Set;\n\nbool set_contains(Set *set, int value) {\n    for (int i = 0; i < set->size; i++) {\n        if (set->elements[i] == value) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid set_add(Set *set, int value) {\n    if (!set_contains(set, value)) {\n        if (set->size < MAX_SET_SIZE) {\n            set->elements[set->size++] = value;\n        }\n    }\n}\n\nint* set_to_list(Set *set) {\n    int *list = (int *)malloc(set->size * sizeof(int));\n    for (int i = 0; i < set->size; i++) {\n        list[i] = set->elements[i];\n    }\n    return list;\n}\n\nint main() {\n    Set mySet = { .size = 0 };\n\n    set_add(&mySet, 3);\n    set_add(&mySet, 5);\n    set_add(&mySet, 7);\n    set_add(&mySet, 3); // Duplicate, won't be added\n\n    int *list = set_to_list(&mySet);\n\n    printf(\"List elements: \");\n    for (int i = 0; i < mySet.size; i++) {\n        printf(\"%d \", list[i]);\n    }\n    printf(\"\\n\");\n\n    free(list);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that returns all elements present in either of two sets but not both.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int *elements;\n    int size;\n} Set;\n\nSet symmetricDifference(Set set1, Set set2) {\n    Set result;\n    result.elements = (int *)malloc((set1.size + set2.size) * sizeof(int));\n    result.size = 0;\n\n    for (int i = 0; i < set1.size; i++) {\n        int found = 0;\n        for (int j = 0; j < set2.size; j++) {\n            if (set1.elements[i] == set2.elements[j]) {\n                found = 1;\n                break;\n            }\n        }\n        if (!found) {\n            result.elements[result.size++] = set1.elements[i];\n        }\n    }\n\n    for (int i = 0; i < set2.size; i++) {\n        int found = 0;\n        for (int j = 0; j < set1.size; j++) {\n            if (set2.elements[i] == set1.elements[j]) {\n                found = 1;\n                break;\n            }\n        }\n        if (!found) {\n            result.elements[result.size++] = set2.elements[i];\n        }\n    }\n\n    return result;\n}\n\nint main() {\n    Set set1 = { (int[]){1, 2, 3, 4}, 4 };\n    Set set2 = { (int[]){3, 4, 5, 6}, 4 };\n    Set result = symmetricDifference(set1, set2);\n\n    for (int i = 0; i < result.size; i++) {\n        printf(\"%d \", result.elements[i]);\n    }\n\n    free(result.elements);\n    return 0;\n}\n```"
  },
  {
    "task": "Use a set to manage a collection of unique transaction IDs.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_TRANSACTIONS 100\n\ntypedef struct {\n    char *transaction_id;\n} Transaction;\n\ntypedef struct {\n    Transaction transactions[MAX_TRANSACTIONS];\n    int size;\n} TransactionSet;\n\nvoid initTransactionSet(TransactionSet *set) {\n    set->size = 0;\n}\n\nint contains(TransactionSet *set, const char *transaction_id) {\n    for (int i = 0; i < set->size; i++) {\n        if (strcmp(set->transactions[i].transaction_id, transaction_id) == 0) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nint addTransaction(TransactionSet *set, const char *transaction_id) {\n    if (set->size >= MAX_TRANSACTIONS || contains(set, transaction_id)) {\n        return 0;\n    }\n    set->transactions[set->size].transaction_id = strdup(transaction_id);\n    set->size++;\n    return 1;\n}\n\nvoid freeTransactionSet(TransactionSet *set) {\n    for (int i = 0; i < set->size; i++) {\n        free(set->transactions[i].transaction_id);\n    }\n}\n\nint main() {\n    TransactionSet set;\n    initTransactionSet(&set);\n\n    addTransaction(&set, \"TX123\");\n    addTransaction(&set, \"TX456\");\n    addTransaction(&set, \"TX123\");  // Duplicate, won't be added\n\n    freeTransactionSet(&set);\n    return 0;\n}\n```"
  },
  {
    "task": "Create a set of integers and demonstrate the `pop` operation.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\n// Define a structure for set elements\ntypedef struct SetElement {\n    int value;\n    struct SetElement* next;\n} SetElement;\n\n// Define a structure for the set itself\ntypedef struct Set {\n    SetElement* head;\n} Set;\n\n// Function to create a new set\nSet* createSet() {\n    Set* newSet = (Set*)malloc(sizeof(Set));\n    newSet->head = NULL;\n    return newSet;\n}\n\n// Function to add an element to the set\nvoid add(Set* set, int value) {\n    SetElement* newElement = (SetElement*)malloc(sizeof(SetElement));\n    newElement->value = value;\n    newElement->next = set->head;\n    set->head = newElement;\n}\n\n// Function to pop an element from the set\nint pop(Set* set) {\n    if (set->head == NULL) {\n        printf(\"Set is empty\\n\");\n        return -1; // Or any other error indicator\n    }\n    SetElement* elementToPop = set->head;\n    int value = elementToPop->value;\n    set->head = set->head->next;\n    free(elementToPop);\n    return value;\n}\n\n// Function to free the entire set\nvoid freeSet(Set* set) {\n    SetElement* current = set->head;\n    while (current != NULL) {\n        SetElement* toFree = current;\n        current = current->next;\n        free(toFree);\n    }\n    free(set);\n}\n\nint main() {\n    Set* mySet = createSet();\n    \n    // Add some integers to the set\n    add(mySet, 10);\n    add(mySet, 20);\n    add(mySet, 30);\n\n    // Demonstrate the pop operation\n    int poppedValue = pop(mySet);\n    printf(\"Popped value: %d\\n\", poppedValue);\n\n    // Clean up\n    freeSet(mySet);\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Write a program to find the maximum element in a set of floating-point numbers.",
    "code": "```c\n#include <stdio.h>\n#include <float.h>\n\nint main() {\n    float numbers[] = {3.2, 5.1, 9.7, 4.4, 2.8};\n    int size = sizeof(numbers) / sizeof(numbers[0]);\n    float max = -FLT_MAX;\n    \n    for (int i = 0; i < size; i++) {\n        if (numbers[i] > max) {\n            max = numbers[i];\n        }\n    }\n\n    printf(\"The maximum element is: %.2f\\n\", max);\n    return 0;\n}\n```"
  },
  {
    "task": "Create a set and demonstrate the use of the `update` method with another set.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int *items;\n    int size;\n    int capacity;\n} Set;\n\nvoid initSet(Set *set) {\n    set->size = 0;\n    set->capacity = 10;\n    set->items = (int *)malloc(set->capacity * sizeof(int));\n}\n\nvoid freeSet(Set *set) {\n    free(set->items);\n    set->size = 0;\n    set->capacity = 0;\n}\n\nint contains(Set *set, int value) {\n    for (int i = 0; i < set->size; i++) {\n        if (set->items[i] == value) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nvoid add(Set *set, int value) {\n    if (!contains(set, value)) {\n        if (set->size >= set->capacity) {\n            set->capacity *= 2;\n            set->items = (int *)realloc(set->items, set->capacity * sizeof(int));\n        }\n        set->items[set->size++] = value;\n    }\n}\n\nvoid update(Set *set1, Set *set2) {\n    for (int i = 0; i < set2->size; i++) {\n        add(set1, set2->items[i]);\n    }\n}\n\nvoid printSet(Set *set) {\n    printf(\"{\");\n    for (int i = 0; i < set->size; i++) {\n        printf(\"%d\", set->items[i]);\n        if (i < set->size - 1) {\n            printf(\", \");\n        }\n    }\n    printf(\"}\\n\");\n}\n\nint main() {\n    Set set1, set2;\n    initSet(&set1);\n    initSet(&set2);\n\n    add(&set1, 1);\n    add(&set1, 2);\n    add(&set1, 3);\n\n    add(&set2, 3);\n    add(&set2, 4);\n    add(&set2, 5);\n\n    printf(\"Set 1 before update: \");\n    printSet(&set1);\n\n    printf(\"Set 2: \");\n    printSet(&set2);\n\n    update(&set1, &set2);\n\n    printf(\"Set 1 after update: \");\n    printSet(&set1);\n\n    freeSet(&set1);\n    freeSet(&set2);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a set to keep track of unique file extensions in a directory.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <dirent.h>\n\ntypedef struct Node {\n    char *extension;\n    struct Node *next;\n} Node;\n\ntypedef struct Set {\n    Node *head;\n} Set;\n\nSet* createSet() {\n    Set *set = (Set*)malloc(sizeof(Set));\n    set->head = NULL;\n    return set;\n}\n\nint contains(Set *set, const char *extension) {\n    Node *current = set->head;\n    while (current != NULL) {\n        if (strcmp(current->extension, extension) == 0) {\n            return 1;\n        }\n        current = current->next;\n    }\n    return 0;\n}\n\nvoid add(Set *set, const char *extension) {\n    if (!contains(set, extension)) {\n        Node *node = (Node*)malloc(sizeof(Node));\n        node->extension = strdup(extension);\n        node->next = set->head;\n        set->head = node;\n    }\n}\n\nvoid freeSet(Set *set) {\n    Node *current = set->head;\n    while (current != NULL) {\n        Node *next = current->next;\n        free(current->extension);\n        free(current);\n        current = next;\n    }\n    free(set);\n}\n\nvoid collectExtensions(const char *directoryPath, Set *set) {\n    struct dirent *entry;\n    DIR *dp = opendir(directoryPath);\n\n    if (dp == NULL) {\n        perror(\"opendir\");\n        return;\n    }\n\n    while ((entry = readdir(dp))) {\n        char *extension = strrchr(entry->d_name, '.');\n        if (extension && extension != entry->d_name) {\n            add(set, extension + 1);\n        }\n    }\n\n    closedir(dp);\n}\n\nvoid printSet(Set *set) {\n    Node *current = set->head;\n    while (current != NULL) {\n        printf(\"%s\\n\", current->extension);\n        current = current->next;\n    }\n}\n\nint main() {\n    const char *directoryPath = \".\"; // Change this to the target directory path\n    Set *set = createSet();\n\n    collectExtensions(directoryPath, set);\n    printSet(set);\n\n    freeSet(set);\n    return 0;\n}\n```"
  },
  {
    "task": "Create a set of strings and demonstrate how to iterate over it in reverse order.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct Node {\n    char *data;\n    struct Node *next;\n} Node;\n\ntypedef struct Set {\n    Node *head;\n} Set;\n\nvoid insert(Set *set, const char *str) {\n    Node *node = (Node *)malloc(sizeof(Node));\n    node->data = strdup(str);\n    node->next = set->head;\n    set->head = node;\n}\n\nvoid iterate_reverse(const Set *set) {\n    Node *current = set->head;\n    Node *prev = NULL, *next = NULL;\n\n    while (current != NULL) {\n        next = current->next;\n        current->next = prev;\n        prev = current;\n        current = next;\n    }\n\n    current = prev;\n    while (current != NULL) {\n        printf(\"%s\\n\", current->data);\n        current = current->next;\n    }\n}\n\nvoid free_set(Set *set) {\n    Node *current = set->head;\n    while (current != NULL) {\n        Node *next = current->next;\n        free(current->data);\n        free(current);\n        current = next;\n    }\n}\n\nint main() {\n    Set set = {NULL};\n\n    insert(&set, \"apple\");\n    insert(&set, \"banana\");\n    insert(&set, \"cherry\");\n\n    iterate_reverse(&set);\n    free_set(&set);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function to check if a set is empty.",
    "code": "```c\n#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int *data;\n    size_t size;\n} Set;\n\nbool isSetEmpty(Set *set) {\n    return set->size == 0;\n}\n\nint main() {\n    Set set;\n    set.data = NULL;\n    set.size = 0;\n\n    if (isSetEmpty(&set)) {\n        printf(\"The set is empty.\\n\");\n    } else {\n        printf(\"The set is not empty.\\n\");\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Use a set to filter out duplicate entries from a list of participants.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct Node {\n    char *value;\n    struct Node *next;\n} Node;\n\ntypedef struct Set {\n    Node **buckets;\n    size_t size;\n} Set;\n\nunsigned int hash(const char *str, size_t size) {\n    unsigned int hash = 0;\n    while (*str) {\n        hash = (hash << 5) + *str++;\n    }\n    return hash % size;\n}\n\nSet *create_set(size_t size) {\n    Set *set = malloc(sizeof(Set));\n    set->buckets = calloc(size, sizeof(Node *));\n    set->size = size;\n    return set;\n}\n\nint set_insert(Set *set, const char *value) {\n    unsigned int index = hash(value, set->size);\n    Node *node = set->buckets[index];\n    while (node) {\n        if (strcmp(node->value, value) == 0) {\n            return 0; // Already exists\n        }\n        node = node->next;\n    }\n    Node *new_node = malloc(sizeof(Node));\n    new_node->value = strdup(value);\n    new_node->next = set->buckets[index];\n    set->buckets[index] = new_node;\n    return 1;\n}\n\nvoid free_set(Set *set) {\n    for (size_t i = 0; i < set->size; ++i) {\n        Node *node = set->buckets[i];\n        while (node) {\n            Node *temp = node;\n            node = node->next;\n            free(temp->value);\n            free(temp);\n        }\n    }\n    free(set->buckets);\n    free(set);\n}\n\nint main() {\n    char *participants[] = {\"Alice\", \"Bob\", \"Alice\", \"Charlie\", \"Bob\", \"David\"};\n    size_t num_participants = sizeof(participants) / sizeof(participants[0]);\n    \n    Set *set = create_set(10);\n\n    printf(\"Unique participants:\\n\");\n    for (size_t i = 0; i < num_participants; ++i) {\n        if (set_insert(set, participants[i])) {\n            printf(\"%s\\n\", participants[i]);\n        }\n    }\n\n    free_set(set);\n    return 0;\n}\n```"
  },
  {
    "task": "Create a set of tuples and demonstrate basic set operations.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct {\n    int x;\n    int y;\n} Tuple;\n\ntypedef struct Node {\n    Tuple data;\n    struct Node* next;\n} Node;\n\ntypedef struct {\n    Node* head;\n} Set;\n\nSet* createSet() {\n    Set* set = (Set*)malloc(sizeof(Set));\n    set->head = NULL;\n    return set;\n}\n\nbool contains(Set* set, Tuple tuple) {\n    Node* current = set->head;\n    while (current != NULL) {\n        if (current->data.x == tuple.x && current->data.y == tuple.y) {\n            return true;\n        }\n        current = current->next;\n    }\n    return false;\n}\n\nvoid add(Set* set, Tuple tuple) {\n    if (!contains(set, tuple)) {\n        Node* newNode = (Node*)malloc(sizeof(Node));\n        newNode->data = tuple;\n        newNode->next = set->head;\n        set->head = newNode;\n    }\n}\n\nvoid removeTuple(Set* set, Tuple tuple) {\n    Node* current = set->head;\n    Node* prev = NULL;\n    while (current != NULL) {\n        if (current->data.x == tuple.x && current->data.y == tuple.y) {\n            if (prev == NULL) {\n                set->head = current->next;\n            } else {\n                prev->next = current->next;\n            }\n            free(current);\n            return;\n        }\n        prev = current;\n        current = current->next;\n    }\n}\n\nvoid printSet(Set* set) {\n    Node* current = set->head;\n    while (current != NULL) {\n        printf(\"(%d, %d) \", current->data.x, current->data.y);\n        current = current->next;\n    }\n    printf(\"\\n\");\n}\n\nvoid freeSet(Set* set) {\n    Node* current = set->head;\n    while (current != NULL) {\n        Node* temp = current;\n        current = current->next;\n        free(temp);\n    }\n    free(set);\n}\n\nint main() {\n    Set* mySet = createSet();\n    \n    Tuple t1 = {1, 2};\n    Tuple t2 = {3, 4};\n    Tuple t3 = {5, 6};\n\n    add(mySet, t1);\n    add(mySet, t2);\n    add(mySet, t3);\n    add(mySet, t1); // Duplicate, should not be added\n\n    printf(\"Set after adding tuples:\\n\");\n    printSet(mySet);\n\n    removeTuple(mySet, t2);\n    printf(\"Set after removing (3, 4):\\n\");\n    printSet(mySet);\n\n    freeSet(mySet);\n    return 0;\n}\n```"
  },
  {
    "task": "Write a program to find the common elements between two sets of country names.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_COUNTRIES 100\n#define MAX_NAME_LENGTH 50\n\ntypedef struct {\n    char name[MAX_NAME_LENGTH];\n} Country;\n\ntypedef struct {\n    Country countries[MAX_COUNTRIES];\n    int size;\n} CountrySet;\n\nvoid addCountry(CountrySet *set, const char *name) {\n    if (set->size < MAX_COUNTRIES) {\n        strcpy(set->countries[set->size].name, name);\n        set->size++;\n    }\n}\n\nint containsCountry(const CountrySet *set, const char *name) {\n    for (int i = 0; i < set->size; i++) {\n        if (strcmp(set->countries[i].name, name) == 0) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nCountrySet findCommonElements(const CountrySet *set1, const CountrySet *set2) {\n    CountrySet common;\n    common.size = 0;\n    for (int i = 0; i < set1->size; i++) {\n        if (containsCountry(set2, set1->countries[i].name)) {\n            addCountry(&common, set1->countries[i].name);\n        }\n    }\n    return common;\n}\n\nvoid printCountrySet(const CountrySet *set) {\n    for (int i = 0; i < set->size; i++) {\n        printf(\"%s\\n\", set->countries[i].name);\n    }\n}\n\nint main() {\n    CountrySet set1, set2, common;\n    set1.size = 0;\n    set2.size = 0;\n\n    addCountry(&set1, \"USA\");\n    addCountry(&set1, \"Canada\");\n    addCountry(&set1, \"Mexico\");\n\n    addCountry(&set2, \"France\");\n    addCountry(&set2, \"Canada\");\n    addCountry(&set2, \"Brazil\");\n\n    common = findCommonElements(&set1, &set2);\n\n    printf(\"Common elements:\\n\");\n    printCountrySet(&common);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a set of characters and demonstrate the use of the `issubset` method.",
    "code": "```c\n#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool isSubset(char *set1, char *set2) {\n    int count[256] = {0};\n    for (int i = 0; set2[i] != '\\0'; i++) {\n        count[(unsigned char)set2[i]]++;\n    }\n    for (int i = 0; set1[i] != '\\0'; i++) {\n        if (count[(unsigned char)set1[i]] == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    char setA[] = \"abc\";\n    char setB[] = \"abcdef\";\n\n    if (isSubset(setA, setB)) {\n        printf(\"setA is a subset of setB\\n\");\n    } else {\n        printf(\"setA is not a subset of setB\\n\");\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a set to manage a collection of unique hashtags from social media posts.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_HASHTAGS 100\n#define MAX_LENGTH 100\n\ntypedef struct {\n    char hashtags[MAX_HASHTAGS][MAX_LENGTH];\n    int size;\n} Set;\n\n// Initialize the set\nvoid initSet(Set *set) {\n    set->size = 0;\n}\n\n// Check if the hashtag is in the set\nint contains(Set *set, const char *hashtag) {\n    for (int i = 0; i < set->size; i++) {\n        if (strcmp(set->hashtags[i], hashtag) == 0) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\n// Add a hashtag to the set\nvoid add(Set *set, const char *hashtag) {\n    if (!contains(set, hashtag) && set->size < MAX_HASHTAGS) {\n        strcpy(set->hashtags[set->size], hashtag);\n        set->size++;\n    }\n}\n\n// Display all hashtags in the set\nvoid display(Set *set) {\n    for (int i = 0; i < set->size; i++) {\n        printf(\"%s\\n\", set->hashtags[i]);\n    }\n}\n\nint main() {\n    Set hashtagSet;\n    initSet(&hashtagSet);\n    \n    add(&hashtagSet, \"#coding\");\n    add(&hashtagSet, \"#programming\");\n    add(&hashtagSet, \"#coding\"); // Duplicate, will not be added\n    add(&hashtagSet, \"#C_language\");\n    \n    display(&hashtagSet);\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Create a set and demonstrate how to copy it to another set.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Set {\n    int *elements;\n    int size;\n    int capacity;\n} Set;\n\nSet *createSet(int capacity) {\n    Set *set = (Set *)malloc(sizeof(Set));\n    set->elements = (int *)malloc(sizeof(int) * capacity);\n    set->size = 0;\n    set->capacity = capacity;\n    return set;\n}\n\nvoid addElement(Set *set, int element) {\n    for (int i = 0; i < set->size; i++) {\n        if (set->elements[i] == element) {\n            return;\n        }\n    }\n    if (set->size < set->capacity) {\n        set->elements[set->size++] = element;\n    }\n}\n\nSet *copySet(Set *original) {\n    Set *copy = createSet(original->capacity);\n    for (int i = 0; i < original->size; i++) {\n        copy->elements[i] = original->elements[i];\n    }\n    copy->size = original->size;\n    return copy;\n}\n\nvoid printSet(Set *set) {\n    printf(\"{ \");\n    for (int i = 0; i < set->size; i++) {\n        printf(\"%d \", set->elements[i]);\n    }\n    printf(\"}\\n\");\n}\n\nint main() {\n    Set *set1 = createSet(10);\n    addElement(set1, 1);\n    addElement(set1, 2);\n    addElement(set1, 3);\n\n    Set *set2 = copySet(set1);\n\n    printf(\"Original set: \");\n    printSet(set1);\n\n    printf(\"Copied set: \");\n    printSet(set2);\n\n    free(set1->elements);\n    free(set1);\n    free(set2->elements);\n    free(set2);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that accepts two sets and returns a new set with elements found in both.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int *elements;\n    size_t size;\n} Set;\n\nSet createSet(size_t size) {\n    Set set;\n    set.elements = (int *)malloc(size * sizeof(int));\n    set.size = 0;\n    return set;\n}\n\nvoid addElement(Set *set, int element) {\n    set->elements[set->size] = element;\n    set->size++;\n}\n\nSet intersection(Set set1, Set set2) {\n    Set result = createSet(set1.size < set2.size ? set1.size : set2.size);\n    for (size_t i = 0; i < set1.size; i++) {\n        for (size_t j = 0; j < set2.size; j++) {\n            if (set1.elements[i] == set2.elements[j]) {\n                addElement(&result, set1.elements[i]);\n                break;\n            }\n        }\n    }\n    return result;\n}\n\nint main() {\n    Set set1 = createSet(3);\n    addElement(&set1, 1);\n    addElement(&set1, 2);\n    addElement(&set1, 3);\n\n    Set set2 = createSet(3);\n    addElement(&set2, 2);\n    addElement(&set2, 3);\n    addElement(&set2, 4);\n\n    Set result = intersection(set1, set2);\n\n    for (size_t i = 0; i < result.size; i++) {\n        printf(\"%d \", result.elements[i]);\n    }\n\n    free(set1.elements);\n    free(set2.elements);\n    free(result.elements);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Use a set to determine the unique items purchased in a day.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_ITEMS 100\n\ntypedef struct {\n    char itemName[50];\n} Item;\n\nint isUnique(Item items[], int size, char *newItem) {\n    for (int i = 0; i < size; i++) {\n        if (strcmp(items[i].itemName, newItem) == 0) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    char *purchases[] = {\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"grape\"};\n    int purchaseCount = sizeof(purchases) / sizeof(purchases[0]);\n\n    Item uniqueItems[MAX_ITEMS];\n    int uniqueCount = 0;\n\n    for (int i = 0; i < purchaseCount; i++) {\n        if (isUnique(uniqueItems, uniqueCount, purchases[i])) {\n            strcpy(uniqueItems[uniqueCount].itemName, purchases[i]);\n            uniqueCount++;\n        }\n    }\n\n    printf(\"Unique items purchased in a day:\\n\");\n    for (int i = 0; i < uniqueCount; i++) {\n        printf(\"%s\\n\", uniqueItems[i].itemName);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a set of student IDs and demonstrate set comprehension to filter IDs.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int *elements;\n    int size;\n    int capacity;\n} Set;\n\nvoid initSet(Set *set, int capacity) {\n    set->elements = (int *)malloc(capacity * sizeof(int));\n    set->size = 0;\n    set->capacity = capacity;\n}\n\nvoid addElement(Set *set, int element) {\n    for (int i = 0; i < set->size; i++) {\n        if (set->elements[i] == element) {\n            return;\n        }\n    }\n    if (set->size < set->capacity) {\n        set->elements[set->size++] = element;\n    }\n}\n\nSet filterSet(Set *set, int (*predicate)(int)) {\n    Set result;\n    initSet(&result, set->capacity);\n    for (int i = 0; i < set->size; i++) {\n        if (predicate(set->elements[i])) {\n            addElement(&result, set->elements[i]);\n        }\n    }\n    return result;\n}\n\nint isEven(int number) {\n    return number % 2 == 0;\n}\n\nvoid freeSet(Set *set) {\n    free(set->elements);\n}\n\nint main() {\n    Set studentIDs;\n    initSet(&studentIDs, 10);\n\n    addElement(&studentIDs, 101);\n    addElement(&studentIDs, 102);\n    addElement(&studentIDs, 103);\n    addElement(&studentIDs, 104);\n    addElement(&studentIDs, 105);\n\n    Set filteredIDs = filterSet(&studentIDs, isEven);\n\n    printf(\"Filtered IDs: \");\n    for (int i = 0; i < filteredIDs.size; i++) {\n        printf(\"%d \", filteredIDs.elements[i]);\n    }\n    printf(\"\\n\");\n\n    freeSet(&studentIDs);\n    freeSet(&filteredIDs);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a program to check if a set of strings is a superset of another set.",
    "code": "```c\n#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_STRINGS 100\n#define MAX_LENGTH 100\n\nbool isSuperset(char set1[][MAX_LENGTH], int size1, char set2[][MAX_LENGTH], int size2) {\n    for (int i = 0; i < size2; i++) {\n        bool found = false;\n        for (int j = 0; j < size1; j++) {\n            if (strcmp(set2[i], set1[j]) == 0) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) return false;\n    }\n    return true;\n}\n\nint main() {\n    char set1[MAX_STRINGS][MAX_LENGTH] = {\"apple\", \"banana\", \"cherry\"};\n    char set2[MAX_STRINGS][MAX_LENGTH] = {\"banana\", \"apple\"};\n    \n    int size1 = 3;\n    int size2 = 2;\n    \n    if (isSuperset(set1, size1, set2, size2)) {\n        printf(\"Set 1 is a superset of Set 2.\\n\");\n    } else {\n        printf(\"Set 1 is not a superset of Set 2.\\n\");\n    }\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Create a set of unique words from a text file.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_WORD_LENGTH 100\n\ntypedef struct Node {\n    char word[MAX_WORD_LENGTH];\n    struct Node* next;\n} Node;\n\ntypedef struct Set {\n    Node* head;\n} Set;\n\nSet* createSet() {\n    Set* set = (Set*)malloc(sizeof(Set));\n    set->head = NULL;\n    return set;\n}\n\nint contains(Set* set, const char* word) {\n    Node* current = set->head;\n    while (current != NULL) {\n        if (strcmp(current->word, word) == 0) {\n            return 1;\n        }\n        current = current->next;\n    }\n    return 0;\n}\n\nvoid addWord(Set* set, const char* word) {\n    if (!contains(set, word)) {\n        Node* newNode = (Node*)malloc(sizeof(Node));\n        strcpy(newNode->word, word);\n        newNode->next = set->head;\n        set->head = newNode;\n    }\n}\n\nvoid freeSet(Set* set) {\n    Node* current = set->head;\n    while (current != NULL) {\n        Node* temp = current;\n        current = current->next;\n        free(temp);\n    }\n    free(set);\n}\n\nint main() {\n    FILE* file = fopen(\"text.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Unable to open file\");\n        return 1;\n    }\n\n    Set* set = createSet();\n    char word[MAX_WORD_LENGTH];\n\n    while (fscanf(file, \"%99s\", word) != EOF) {\n        addWord(set, word);\n    }\n\n    // Example of iterating over the set and printing the words\n    Node* current = set->head;\n    while (current != NULL) {\n        printf(\"%s\\n\", current->word);\n        current = current->next;\n    }\n\n    fclose(file);\n    freeSet(set);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a set to store unique project identifiers and demonstrate membership testing.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_PROJECTS 100\n\ntypedef struct {\n    char *identifiers[MAX_PROJECTS];\n    int count;\n} Set;\n\nvoid initializeSet(Set *set) {\n    set->count = 0;\n}\n\nint isMember(Set *set, const char *identifier) {\n    for (int i = 0; i < set->count; i++) {\n        if (strcmp(set->identifiers[i], identifier) == 0) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nvoid addIdentifier(Set *set, const char *identifier) {\n    if (!isMember(set, identifier) && set->count < MAX_PROJECTS) {\n        set->identifiers[set->count] = strdup(identifier);\n        set->count++;\n    }\n}\n\nint main() {\n    Set projectSet;\n    initializeSet(&projectSet);\n\n    addIdentifier(&projectSet, \"ProjectA\");\n    addIdentifier(&projectSet, \"ProjectB\");\n    addIdentifier(&projectSet, \"ProjectA\"); // Duplicate, should not be added\n\n    printf(\"Is 'ProjectA' in the set? %s\\n\", isMember(&projectSet, \"ProjectA\") ? \"Yes\" : \"No\");\n    printf(\"Is 'ProjectC' in the set? %s\\n\", isMember(&projectSet, \"ProjectC\") ? \"Yes\" : \"No\");\n\n    for (int i = 0; i < projectSet.count; i++) {\n        free(projectSet.identifiers[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a set and demonstrate the `symmetric_difference_update` method.",
    "code": "```c\n#include <stdio.h>\n\n// Function to find symmetric difference of two sets\nvoid symmetric_difference_update(int set1[], int *size1, int set2[], int size2) {\n    int result[100];\n    int k = 0;\n    \n    for (int i = 0; i < *size1; i++) {\n        int found = 0;\n        for (int j = 0; j < size2; j++) {\n            if (set1[i] == set2[j]) {\n                found = 1;\n                break;\n            }\n        }\n        if (!found) {\n            result[k++] = set1[i];\n        }\n    }\n    \n    for (int j = 0; j < size2; j++) {\n        int found = 0;\n        for (int i = 0; i < *size1; i++) {\n            if (set2[j] == set1[i]) {\n                found = 1;\n                break;\n            }\n        }\n        if (!found) {\n            result[k++] = set2[j];\n        }\n    }\n    \n    for (int i = 0; i < k; i++) {\n        set1[i] = result[i];\n    }\n    *size1 = k;\n}\n\nint main() {\n    int set1[] = {1, 2, 3, 4, 5};\n    int set2[] = {4, 5, 6, 7, 8};\n    \n    int size1 = sizeof(set1) / sizeof(set1[0]);\n    int size2 = sizeof(set2) / sizeof(set2[0]);\n    \n    symmetric_difference_update(set1, &size1, set2, size2);\n    \n    printf(\"Symmetric difference update result: \");\n    for (int i = 0; i < size1; i++) {\n        printf(\"%d \", set1[i]);\n    }\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Write a function to remove all elements from a set that are also in another set.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int *elements;\n    size_t size;\n    size_t capacity;\n} Set;\n\nSet create_set(size_t capacity) {\n    Set set;\n    set.elements = (int *)malloc(capacity * sizeof(int));\n    set.size = 0;\n    set.capacity = capacity;\n    return set;\n}\n\nvoid free_set(Set *set) {\n    free(set->elements);\n    set->elements = NULL;\n    set->size = 0;\n    set->capacity = 0;\n}\n\nint contains(Set *set, int value) {\n    for (size_t i = 0; i < set->size; i++) {\n        if (set->elements[i] == value) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nvoid add(Set *set, int value) {\n    if (!contains(set, value) && set->size < set->capacity) {\n        set->elements[set->size++] = value;\n    }\n}\n\nvoid remove_elements(Set *set1, Set *set2) {\n    size_t i = 0;\n    while (i < set1->size) {\n        if (contains(set2, set1->elements[i])) {\n            set1->elements[i] = set1->elements[--set1->size];\n        } else {\n            i++;\n        }\n    }\n}\n\nint main() {\n    Set set1 = create_set(10);\n    Set set2 = create_set(10);\n\n    add(&set1, 1);\n    add(&set1, 2);\n    add(&set1, 3);\n    add(&set2, 2);\n    add(&set2, 4);\n\n    remove_elements(&set1, &set2);\n\n    for (size_t i = 0; i < set1.size; i++) {\n        printf(\"%d \", set1.elements[i]);\n    }\n    printf(\"\\n\");\n\n    free_set(&set1);\n    free_set(&set2);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Use a set to keep track of unique error codes from server logs.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    int data;\n    struct Node* next;\n} Node;\n\ntypedef struct Set {\n    Node* head;\n} Set;\n\nSet* createSet() {\n    Set* set = (Set*)malloc(sizeof(Set));\n    set->head = NULL;\n    return set;\n}\n\nint contains(Set* set, int value) {\n    Node* current = set->head;\n    while (current != NULL) {\n        if (current->data == value) {\n            return 1;\n        }\n        current = current->next;\n    }\n    return 0;\n}\n\nvoid add(Set* set, int value) {\n    if (!contains(set, value)) {\n        Node* node = (Node*)malloc(sizeof(Node));\n        node->data = value;\n        node->next = set->head;\n        set->head = node;\n    }\n}\n\nvoid freeSet(Set* set) {\n    Node* current = set->head;\n    while (current != NULL) {\n        Node* next = current->next;\n        free(current);\n        current = next;\n    }\n    free(set);\n}\n\nint main() {\n    Set* errorCodes = createSet();\n    \n    // Example usage: adding error codes from server logs\n    add(errorCodes, 404);\n    add(errorCodes, 500);\n    add(errorCodes, 404); // Duplicate, will not be added\n\n    // Clean up\n    freeSet(errorCodes);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a set and demonstrate how to find all unique pairs of elements.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int *elements;\n    int size;\n    int capacity;\n} Set;\n\nvoid initSet(Set *set, int capacity) {\n    set->elements = (int *)malloc(capacity * sizeof(int));\n    set->size = 0;\n    set->capacity = capacity;\n}\n\nint contains(Set *set, int element) {\n    for (int i = 0; i < set->size; i++) {\n        if (set->elements[i] == element) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nvoid add(Set *set, int element) {\n    if (!contains(set, element)) {\n        if (set->size == set->capacity) {\n            set->capacity *= 2;\n            set->elements = (int *)realloc(set->elements, set->capacity * sizeof(int));\n        }\n        set->elements[set->size++] = element;\n    }\n}\n\nvoid freeSet(Set *set) {\n    free(set->elements);\n}\n\nint main() {\n    Set set;\n    initSet(&set, 10);\n\n    add(&set, 1);\n    add(&set, 2);\n    add(&set, 3);\n    add(&set, 4);\n    \n    printf(\"Unique pairs:\\n\");\n    for (int i = 0; i < set.size; i++) {\n        for (int j = i + 1; j < set.size; j++) {\n            printf(\"(%d, %d)\\n\", set.elements[i], set.elements[j]);\n        }\n    }\n\n    freeSet(&set);\n    return 0;\n}\n```"
  },
  {
    "task": "Write a program to find the smallest element in a set of integers.",
    "code": "```c\n#include <stdio.h>\n#include <limits.h>\n\nint main() {\n    int n, num, min = INT_MAX;\n    printf(\"Enter the number of elements in the set: \");\n    scanf(\"%d\", &n);\n\n    printf(\"Enter the elements of the set:\\n\");\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &num);\n        if (num < min) {\n            min = num;\n        }\n    }\n\n    printf(\"The smallest element in the set is: %d\\n\", min);\n    return 0;\n}\n```"
  },
  {
    "task": "Create a set and demonstrate the `add` method with multiple elements.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\n// Define a node for the linked list\ntypedef struct Node {\n    int data;\n    struct Node* next;\n} Node;\n\n// Define a set using a linked list\ntypedef struct Set {\n    Node* head;\n} Set;\n\n// Function to initialize a new set\nSet* createSet() {\n    Set* set = (Set*)malloc(sizeof(Set));\n    set->head = NULL;\n    return set;\n}\n\n// Function to check if an element exists in the set\nint contains(Set* set, int value) {\n    Node* current = set->head;\n    while (current != NULL) {\n        if (current->data == value) {\n            return 1;\n        }\n        current = current->next;\n    }\n    return 0;\n}\n\n// Function to add an element to the set\nvoid add(Set* set, int value) {\n    if (!contains(set, value)) {\n        Node* newNode = (Node*)malloc(sizeof(Node));\n        newNode->data = value;\n        newNode->next = set->head;\n        set->head = newNode;\n    }\n}\n\n// Function to print the set\nvoid printSet(Set* set) {\n    Node* current = set->head;\n    printf(\"{ \");\n    while (current != NULL) {\n        printf(\"%d \", current->data);\n        current = current->next;\n    }\n    printf(\"}\\n\");\n}\n\nint main() {\n    Set* mySet = createSet();\n    add(mySet, 1);\n    add(mySet, 2);\n    add(mySet, 3);\n    add(mySet, 2); // Attempt to add a duplicate\n    printSet(mySet);\n\n    // Clean up dynamically allocated memory\n    Node* current = mySet->head;\n    while (current != NULL) {\n        Node* next = current->next;\n        free(current);\n        current = next;\n    }\n    free(mySet);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a set to manage a collection of unique author names.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct Node {\n    char *author;\n    struct Node *next;\n} Node;\n\ntypedef struct {\n    Node *head;\n} Set;\n\nSet* createSet() {\n    Set *set = (Set *)malloc(sizeof(Set));\n    set->head = NULL;\n    return set;\n}\n\nint contains(Set *set, const char *author) {\n    Node *current = set->head;\n    while (current != NULL) {\n        if (strcmp(current->author, author) == 0) {\n            return 1;\n        }\n        current = current->next;\n    }\n    return 0;\n}\n\nvoid add(Set *set, const char *author) {\n    if (!contains(set, author)) {\n        Node *newNode = (Node *)malloc(sizeof(Node));\n        newNode->author = strdup(author);\n        newNode->next = set->head;\n        set->head = newNode;\n    }\n}\n\nvoid deleteSet(Set *set) {\n    Node *current = set->head;\n    while (current != NULL) {\n        Node *next = current->next;\n        free(current->author);\n        free(current);\n        current = next;\n    }\n    free(set);\n}\n\nvoid printSet(Set *set) {\n    Node *current = set->head;\n    while (current != NULL) {\n        printf(\"%s\\n\", current->author);\n        current = current->next;\n    }\n}\n\nint main() {\n    Set *set = createSet();\n    add(set, \"Author A\");\n    add(set, \"Author B\");\n    add(set, \"Author A\");\n    printSet(set);\n    deleteSet(set);\n    return 0;\n}\n```"
  },
  {
    "task": "Create a set of integers and demonstrate converting it to a sorted list.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_SET_SIZE 100\n\ntypedef struct {\n    int data[MAX_SET_SIZE];\n    int size;\n} IntSet;\n\nvoid add_to_set(IntSet *set, int value) {\n    for (int i = 0; i < set->size; ++i) {\n        if (set->data[i] == value) {\n            return;\n        }\n    }\n    if (set->size < MAX_SET_SIZE) {\n        set->data[set->size++] = value;\n    }\n}\n\nint compare(const void *a, const void *b) {\n    return (*(int *)a - *(int *)b);\n}\n\nint main() {\n    IntSet set = { .size = 0 };\n    add_to_set(&set, 3);\n    add_to_set(&set, 1);\n    add_to_set(&set, 4);\n    add_to_set(&set, 2);\n\n    int sorted_list[MAX_SET_SIZE];\n    for (int i = 0; i < set.size; ++i) {\n        sorted_list[i] = set.data[i];\n    }\n\n    qsort(sorted_list, set.size, sizeof(int), compare);\n\n    for (int i = 0; i < set.size; ++i) {\n        printf(\"%d \", sorted_list[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that returns the union of multiple sets.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Set {\n    int *elements;\n    int size;\n} Set;\n\nSet unionSets(Set *sets, int numberOfSets) {\n    Set result;\n    result.elements = (int *)malloc(sizeof(int) * 100); // Assuming a max size\n    result.size = 0;\n\n    for (int i = 0; i < numberOfSets; i++) {\n        for (int j = 0; j < sets[i].size; j++) {\n            int element = sets[i].elements[j];\n            int found = 0;\n\n            for (int k = 0; k < result.size; k++) {\n                if (result.elements[k] == element) {\n                    found = 1;\n                    break;\n                }\n            }\n            \n            if (!found) {\n                result.elements[result.size++] = element;\n            }\n        }\n    }\n\n    return result;\n}\n\nint main() {\n    Set sets[2];\n\n    int elements1[] = {1, 2, 3};\n    sets[0].elements = elements1;\n    sets[0].size = 3;\n\n    int elements2[] = {3, 4, 5};\n    sets[1].elements = elements2;\n    sets[1].size = 3;\n\n    Set result = unionSets(sets, 2);\n\n    for (int i = 0; i < result.size; i++) {\n        printf(\"%d \", result.elements[i]);\n    }\n    printf(\"\\n\");\n\n    free(result.elements);\n    return 0;\n}\n```"
  },
  {
    "task": "Use a set to identify unique characters in a string.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define ASCII_SIZE 256\n\nint main() {\n    char str[] = \"example string\";\n    bool charSet[ASCII_SIZE] = { false };\n    int length = strlen(str);\n    \n    for (int i = 0; i < length; i++) {\n        charSet[(int)str[i]] = true;\n    }\n    \n    printf(\"Unique characters: \");\n    for (int i = 0; i < ASCII_SIZE; i++) {\n        if (charSet[i]) {\n            printf(\"%c \", (char)i);\n        }\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Create a set of prime numbers and demonstrate basic set operations.",
    "code": "```c\n#include <stdio.h>\n#include <stdbool.h>\n\n#define MAX_SIZE 100\n\ntypedef struct {\n    int elements[MAX_SIZE];\n    int size;\n} Set;\n\nvoid initializeSet(Set *s) {\n    s->size = 0;\n}\n\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nvoid addElement(Set *s, int element) {\n    for (int i = 0; i < s->size; i++) {\n        if (s->elements[i] == element) return;\n    }\n    if (s->size < MAX_SIZE) {\n        s->elements[s->size++] = element;\n    }\n}\n\nbool containsElement(Set *s, int element) {\n    for (int i = 0; i < s->size; i++) {\n        if (s->elements[i] == element) return true;\n    }\n    return false;\n}\n\nvoid printSet(Set *s) {\n    printf(\"{ \");\n    for (int i = 0; i < s->size; i++) {\n        printf(\"%d \", s->elements[i]);\n    }\n    printf(\"}\\n\");\n}\n\nvoid unionSets(Set *result, Set *s1, Set *s2) {\n    initializeSet(result);\n    for (int i = 0; i < s1->size; i++) {\n        addElement(result, s1->elements[i]);\n    }\n    for (int i = 0; i < s2->size; i++) {\n        addElement(result, s2->elements[i]);\n    }\n}\n\nvoid intersectionSets(Set *result, Set *s1, Set *s2) {\n    initializeSet(result);\n    for (int i = 0; i < s1->size; i++) {\n        if (containsElement(s2, s1->elements[i])) {\n            addElement(result, s1->elements[i]);\n        }\n    }\n}\n\nvoid differenceSets(Set *result, Set *s1, Set *s2) {\n    initializeSet(result);\n    for (int i = 0; i < s1->size; i++) {\n        if (!containsElement(s2, s1->elements[i])) {\n            addElement(result, s1->elements[i]);\n        }\n    }\n}\n\nint main() {\n    Set primes;\n    initializeSet(&primes);\n\n    for (int i = 2; i <= 50; i++) {\n        if (isPrime(i)) {\n            addElement(&primes, i);\n        }\n    }\n    \n    printf(\"Set of prime numbers up to 50: \");\n    printSet(&primes);\n\n    Set otherPrimes;\n    initializeSet(&otherPrimes);\n    addElement(&otherPrimes, 2);\n    addElement(&otherPrimes, 3);\n    addElement(&otherPrimes, 5);\n    addElement(&otherPrimes, 7);\n\n    Set result;\n    \n    unionSets(&result, &primes, &otherPrimes);\n    printf(\"Union of sets: \");\n    printSet(&result);\n\n    intersectionSets(&result, &primes, &otherPrimes);\n    printf(\"Intersection of sets: \");\n    printSet(&result);\n\n    differenceSets(&result, &primes, &otherPrimes);\n    printf(\"Difference of sets (primes - otherPrimes): \");\n    printSet(&result);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a set and demonstrate how to check for non-membership.",
    "code": "```c\n#include <stdio.h>\n#include <stdbool.h>\n\n#define MAX_ELEMENTS 100\n\ntypedef struct {\n    int elements[MAX_ELEMENTS];\n    int size;\n} Set;\n\nvoid initSet(Set *s) {\n    s->size = 0;\n}\n\nbool isMember(Set *s, int element) {\n    for (int i = 0; i < s->size; i++) {\n        if (s->elements[i] == element) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid addElement(Set *s, int element) {\n    if (!isMember(s, element)) {\n        if (s->size < MAX_ELEMENTS) {\n            s->elements[s->size++] = element;\n        }\n    }\n}\n\nbool isNotMember(Set *s, int element) {\n    return !isMember(s, element);\n}\n\nint main() {\n    Set mySet;\n    initSet(&mySet);\n\n    addElement(&mySet, 1);\n    addElement(&mySet, 2);\n    addElement(&mySet, 3);\n\n    int testElement = 4;\n    if (isNotMember(&mySet, testElement)) {\n        printf(\"%d is not a member of the set.\\n\", testElement);\n    } else {\n        printf(\"%d is a member of the set.\\n\", testElement);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a program to find the largest element in a set of numbers.",
    "code": "```c\n#include <stdio.h>\n\nint main() {\n    int numbers[] = {10, 25, 3, 42, 17};\n    int size = sizeof(numbers) / sizeof(numbers[0]);\n\n    int largest = numbers[0];\n    for (int i = 1; i < size; i++) {\n        if (numbers[i] > largest) {\n            largest = numbers[i];\n        }\n    }\n\n    printf(\"The largest number is: %d\\n\", largest);\n    return 0;\n}\n```"
  },
  {
    "task": "Create a set of unique movie titles and demonstrate membership testing.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_MOVIES 10\n#define TITLE_LENGTH 100\n\ntypedef struct {\n    char titles[MAX_MOVIES][TITLE_LENGTH];\n    int size;\n} MovieSet;\n\nvoid initializeSet(MovieSet *set) {\n    set->size = 0;\n}\n\nint isMember(MovieSet *set, const char *title) {\n    for (int i = 0; i < set->size; i++) {\n        if (strcmp(set->titles[i], title) == 0) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nvoid addMovie(MovieSet *set, const char *title) {\n    if (!isMember(set, title) && set->size < MAX_MOVIES) {\n        strcpy(set->titles[set->size++], title);\n    }\n}\n\nint main() {\n    MovieSet set;\n    initializeSet(&set);\n\n    addMovie(&set, \"Inception\");\n    addMovie(&set, \"The Matrix\");\n    addMovie(&set, \"Interstellar\");\n\n    const char *testTitle = \"Inception\";\n\n    if (isMember(&set, testTitle)) {\n        printf(\"\\\"%s\\\" is in the set.\\n\", testTitle);\n    } else {\n        printf(\"\\\"%s\\\" is not in the set.\\n\", testTitle);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a set to store unique keys from a dictionary.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_KEYS 100\n#define MAX_KEY_LENGTH 100\n\ntypedef struct {\n    char keys[MAX_KEYS][MAX_KEY_LENGTH];\n    int size;\n} Set;\n\nvoid initSet(Set *set) {\n    set->size = 0;\n}\n\nint contains(Set *set, const char *key) {\n    for (int i = 0; i < set->size; i++) {\n        if (strcmp(set->keys[i], key) == 0) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nvoid addKey(Set *set, const char *key) {\n    if (!contains(set, key)) {\n        strcpy(set->keys[set->size], key);\n        set->size++;\n    }\n}\n\nint main() {\n    Set uniqueKeys;\n    initSet(&uniqueKeys);\n\n    char *dictionaryKeys[] = {\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"pear\"};\n    int numKeys = sizeof(dictionaryKeys) / sizeof(dictionaryKeys[0]);\n\n    for (int i = 0; i < numKeys; i++) {\n        addKey(&uniqueKeys, dictionaryKeys[i]);\n    }\n\n    printf(\"Unique keys:\\n\");\n    for (int i = 0; i < uniqueKeys.size; i++) {\n        printf(\"%s\\n\", uniqueKeys.keys[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a set and demonstrate the `difference_update` method.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int *elements;\n    size_t size;\n    size_t capacity;\n} Set;\n\nvoid initSet(Set *set) {\n    set->size = 0;\n    set->capacity = 10;\n    set->elements = (int *)malloc(set->capacity * sizeof(int));\n}\n\nvoid freeSet(Set *set) {\n    free(set->elements);\n}\n\nint contains(Set *set, int element) {\n    for (size_t i = 0; i < set->size; i++) {\n        if (set->elements[i] == element) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nvoid addElement(Set *set, int element) {\n    if (!contains(set, element)) {\n        if (set->size == set->capacity) {\n            set->capacity *= 2;\n            set->elements = (int *)realloc(set->elements, set->capacity * sizeof(int));\n        }\n        set->elements[set->size++] = element;\n    }\n}\n\nvoid differenceUpdate(Set *set1, Set *set2) {\n    size_t newSize = 0;\n    for (size_t i = 0; i < set1->size; i++) {\n        if (!contains(set2, set1->elements[i])) {\n            set1->elements[newSize++] = set1->elements[i];\n        }\n    }\n    set1->size = newSize;\n}\n\nvoid printSet(Set *set) {\n    printf(\"{ \");\n    for (size_t i = 0; i < set->size; i++) {\n        printf(\"%d \", set->elements[i]);\n    }\n    printf(\"}\\n\");\n}\n\nint main() {\n    Set set1, set2;\n    initSet(&set1);\n    initSet(&set2);\n\n    addElement(&set1, 1);\n    addElement(&set1, 2);\n    addElement(&set1, 3);\n    addElement(&set2, 2);\n    addElement(&set2, 4);\n\n    printf(\"Set 1 before difference update: \");\n    printSet(&set1);\n\n    differenceUpdate(&set1, &set2);\n\n    printf(\"Set 1 after difference update: \");\n    printSet(&set1);\n\n    freeSet(&set1);\n    freeSet(&set2);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function to merge multiple sets into a single set.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Set {\n    int *elements;\n    int size;\n    int capacity;\n} Set;\n\nSet* createSet(int capacity) {\n    Set *set = (Set*) malloc(sizeof(Set));\n    set->elements = (int*) malloc(capacity * sizeof(int));\n    set->size = 0;\n    set->capacity = capacity;\n    return set;\n}\n\nint contains(Set *set, int element) {\n    for (int i = 0; i < set->size; i++) {\n        if (set->elements[i] == element) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nvoid addElement(Set *set, int element) {\n    if (!contains(set, element)) {\n        if (set->size >= set->capacity) {\n            set->capacity *= 2;\n            set->elements = (int*) realloc(set->elements, set->capacity * sizeof(int));\n        }\n        set->elements[set->size++] = element;\n    }\n}\n\nSet* mergeSets(Set **sets, int numberOfSets) {\n    Set *mergedSet = createSet(10);\n    for (int i = 0; i < numberOfSets; i++) {\n        for (int j = 0; j < sets[i]->size; j++) {\n            addElement(mergedSet, sets[i]->elements[j]);\n        }\n    }\n    return mergedSet;\n}\n\nvoid freeSet(Set *set) {\n    free(set->elements);\n    free(set);\n}\n\nint main() {\n    Set *set1 = createSet(5);\n    Set *set2 = createSet(5);\n    \n    addElement(set1, 1);\n    addElement(set1, 2);\n    addElement(set2, 2);\n    addElement(set2, 3);\n    \n    Set *sets[] = {set1, set2};\n    Set *mergedSet = mergeSets(sets, 2);\n    \n    for (int i = 0; i < mergedSet->size; i++) {\n        printf(\"%d \", mergedSet->elements[i]);\n    }\n    \n    freeSet(set1);\n    freeSet(set2);\n    freeSet(mergedSet);\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Use a set to filter out duplicate letters from a word.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define ALPHABET_SIZE 26\n\nvoid filter_duplicates(const char *word, char *filtered_word) {\n    bool set[ALPHABET_SIZE] = {false};\n    int index = 0;\n    for (int i = 0; word[i] != '\\0'; i++) {\n        char c = word[i];\n        if (c >= 'a' && c <= 'z') {\n            if (!set[c - 'a']) {\n                set[c - 'a'] = true;\n                filtered_word[index++] = c;\n            }\n        } else if (c >= 'A' && c <= 'Z') {\n            if (!set[c - 'A']) {\n                set[c - 'A'] = true;\n                filtered_word[index++] = c;\n            }\n        }\n    }\n    filtered_word[index] = '\\0';\n}\n\nint main() {\n    const char *word = \"programming\";\n    char filtered_word[256];\n    filter_duplicates(word, filtered_word);\n    printf(\"Filtered word: %s\\n\", filtered_word);\n    return 0;\n}\n```"
  },
  {
    "task": "Create a set and demonstrate the use of the `isdisjoint` method.",
    "code": "```c\n#include <stdio.h>\n#include <stdbool.h>\n\n#define MAX 100\n\ntypedef struct {\n    int data[MAX];\n    int size;\n} Set;\n\nvoid initSet(Set* s) {\n    s->size = 0;\n}\n\nbool isMember(const Set* s, int value) {\n    for (int i = 0; i < s->size; i++) {\n        if (s->data[i] == value) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid add(Set* s, int value) {\n    if (!isMember(s, value) && s->size < MAX) {\n        s->data[s->size++] = value;\n    }\n}\n\nbool isDisjoint(const Set* s1, const Set* s2) {\n    for (int i = 0; i < s1->size; i++) {\n        if (isMember(s2, s1->data[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    Set set1, set2;\n    \n    initSet(&set1);\n    initSet(&set2);\n\n    add(&set1, 1);\n    add(&set1, 2);\n    add(&set1, 3);\n\n    add(&set2, 4);\n    add(&set2, 5);\n    add(&set2, 6);\n\n    if (isDisjoint(&set1, &set2)) {\n        printf(\"The sets are disjoint.\\n\");\n    } else {\n        printf(\"The sets are not disjoint.\\n\");\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a program to find all elements that are only in one of two sets.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int *data;\n    int size;\n    int capacity;\n} Set;\n\n// Initialize the set\nSet createSet() {\n    Set set;\n    set.size = 0;\n    set.capacity = 10;\n    set.data = (int *)malloc(set.capacity * sizeof(int));\n    return set;\n}\n\n// Add an element to the set\nvoid add(Set *set, int value) {\n    for (int i = 0; i < set->size; i++) {\n        if (set->data[i] == value) {\n            return; // Element already in the set\n        }\n    }\n    if (set->size >= set->capacity) {\n        set->capacity *= 2;\n        set->data = (int *)realloc(set->data, set->capacity * sizeof(int));\n    }\n    set->data[set->size++] = value;\n}\n\n// Check if an element is in the set\nint contains(Set *set, int value) {\n    for (int i = 0; i < set->size; i++) {\n        if (set->data[i] == value) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\n// Free the set's memory\nvoid freeSet(Set *set) {\n    free(set->data);\n}\n\n// Find the symmetric difference of two sets\nSet symmetricDifference(Set *set1, Set *set2) {\n    Set result = createSet();\n    for (int i = 0; i < set1->size; i++) {\n        if (!contains(set2, set1->data[i])) {\n            add(&result, set1->data[i]);\n        }\n    }\n    for (int i = 0; i < set2->size; i++) {\n        if (!contains(set1, set2->data[i])) {\n            add(&result, set2->data[i]);\n        }\n    }\n    return result;\n}\n\nint main() {\n    Set set1 = createSet();\n    Set set2 = createSet();\n\n    // Example elements for set1 and set2\n    add(&set1, 1);\n    add(&set1, 2);\n    add(&set1, 3);\n    add(&set2, 3);\n    add(&set2, 4);\n    add(&set2, 5);\n\n    Set result = symmetricDifference(&set1, &set2);\n\n    printf(\"Elements only in one of the sets:\\n\");\n    for (int i = 0; i < result.size; i++) {\n        printf(\"%d \", result.data[i]);\n    }\n    printf(\"\\n\");\n\n    freeSet(&set1);\n    freeSet(&set2);\n    freeSet(&result);\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Create a set of unique book authors and demonstrate basic set operations.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\ntypedef struct {\n    char **authors;\n    size_t size;\n    size_t capacity;\n} AuthorSet;\n\nvoid initSet(AuthorSet *set) {\n    set->size = 0;\n    set->capacity = 5;\n    set->authors = malloc(set->capacity * sizeof(char *));\n}\n\nvoid freeSet(AuthorSet *set) {\n    for (size_t i = 0; i < set->size; i++) {\n        free(set->authors[i]);\n    }\n    free(set->authors);\n}\n\nint contains(AuthorSet *set, const char *author) {\n    for (size_t i = 0; i < set->size; i++) {\n        if (strcmp(set->authors[i], author) == 0) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nvoid addAuthor(AuthorSet *set, const char *author) {\n    if (!contains(set, author)) {\n        if (set->size == set->capacity) {\n            set->capacity *= 2;\n            set->authors = realloc(set->authors, set->capacity * sizeof(char *));\n        }\n        set->authors[set->size] = malloc(strlen(author) + 1);\n        strcpy(set->authors[set->size], author);\n        set->size++;\n    }\n}\n\nvoid removeAuthor(AuthorSet *set, const char *author) {\n    for (size_t i = 0; i < set->size; i++) {\n        if (strcmp(set->authors[i], author) == 0) {\n            free(set->authors[i]);\n            set->authors[i] = set->authors[set->size - 1];\n            set->size--;\n            return;\n        }\n    }\n}\n\nvoid printAuthors(AuthorSet *set) {\n    printf(\"Authors in the set:\\n\");\n    for (size_t i = 0; i < set->size; i++) {\n        printf(\"%s\\n\", set->authors[i]);\n    }\n}\n\nint main() {\n    AuthorSet set;\n    initSet(&set);\n\n    addAuthor(&set, \"J.K. Rowling\");\n    addAuthor(&set, \"George R.R. Martin\");\n    addAuthor(&set, \"J.R.R. Tolkien\");\n    addAuthor(&set, \"J.K. Rowling\"); // Duplicate, won't be added\n\n    printAuthors(&set);\n\n    removeAuthor(&set, \"J.R.R. Tolkien\");\n    printAuthors(&set);\n\n    freeSet(&set);\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a set to store unique phone numbers and check for duplicates.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_PHONE_NUMBERS 100\n\ntypedef struct {\n    char *phone_numbers[MAX_PHONE_NUMBERS];\n    int count;\n} PhoneNumberSet;\n\nint contains(PhoneNumberSet *set, const char *phone_number) {\n    for (int i = 0; i < set->count; i++) {\n        if (strcmp(set->phone_numbers[i], phone_number) == 0) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nvoid add_phone_number(PhoneNumberSet *set, const char *phone_number) {\n    if (!contains(set, phone_number) && set->count < MAX_PHONE_NUMBERS) {\n        set->phone_numbers[set->count] = strdup(phone_number);\n        set->count++;\n    }\n}\n\nvoid free_phone_number_set(PhoneNumberSet *set) {\n    for (int i = 0; i < set->count; i++) {\n        free(set->phone_numbers[i]);\n    }\n}\n\nint main() {\n    PhoneNumberSet set = { .count = 0 };\n\n    add_phone_number(&set, \"123-456-7890\");\n    add_phone_number(&set, \"098-765-4321\");\n    add_phone_number(&set, \"123-456-7890\"); // Duplicate\n\n    printf(\"Phone numbers in set:\\n\");\n    for (int i = 0; i < set.count; i++) {\n        printf(\"%s\\n\", set.phone_numbers[i]);\n    }\n\n    free_phone_number_set(&set);\n    return 0;\n}\n```"
  },
  {
    "task": "Create a set of floating-point numbers and demonstrate rounding each element.",
    "code": "```c\n#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    float value;\n    struct Node* next;\n} Node;\n\ntypedef struct Set {\n    Node* head;\n} Set;\n\nSet* createSet() {\n    Set* set = (Set*)malloc(sizeof(Set));\n    set->head = NULL;\n    return set;\n}\n\nint contains(Set* set, float value) {\n    Node* current = set->head;\n    while (current != NULL) {\n        if (current->value == value) {\n            return 1;\n        }\n        current = current->next;\n    }\n    return 0;\n}\n\nvoid add(Set* set, float value) {\n    if (!contains(set, value)) {\n        Node* newNode = (Node*)malloc(sizeof(Node));\n        newNode->value = value;\n        newNode->next = set->head;\n        set->head = newNode;\n    }\n}\n\nvoid roundAndPrintSet(Set* set) {\n    Node* current = set->head;\n    while (current != NULL) {\n        printf(\"%.0f\\n\", round(current->value));\n        current = current->next;\n    }\n}\n\nvoid freeSet(Set* set) {\n    Node* current = set->head;\n    Node* next;\n    while (current != NULL) {\n        next = current->next;\n        free(current);\n        current = next;\n    }\n    free(set);\n}\n\nint main() {\n    Set* set = createSet();\n    add(set, 1.1f);\n    add(set, 2.5f);\n    add(set, 3.7f);\n    add(set, 4.9f);\n    roundAndPrintSet(set);\n    freeSet(set);\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that returns a set of all vowels present in a given sentence.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\ntypedef struct {\n    char *elements;\n    size_t size;\n} Set;\n\nSet createSet() {\n    Set s;\n    s.elements = (char *)malloc(5 * sizeof(char));\n    s.size = 0;\n    return s;\n}\n\nint contains(Set *s, char c) {\n    for (size_t i = 0; i < s->size; ++i) {\n        if (s->elements[i] == c) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nvoid add(Set *s, char c) {\n    if (!contains(s, c)) {\n        s->elements[s->size++] = c;\n    }\n}\n\nSet vowelsInSentence(const char *sentence) {\n    Set vowels = createSet();\n    const char *vowelChars = \"aeiouAEIOU\";\n    for (size_t i = 0; sentence[i] != '\\0'; ++i) {\n        if (strchr(vowelChars, sentence[i])) {\n            add(&vowels, tolower(sentence[i]));\n        }\n    }\n    return vowels;\n}\n\nvoid printSet(Set *s) {\n    printf(\"{ \");\n    for (size_t i = 0; i < s->size; ++i) {\n        printf(\"'%c' \", s->elements[i]);\n    }\n    printf(\"}\\n\");\n}\n\nint main() {\n    const char *sentence = \"Example sentence with vowels.\";\n    Set vowels = vowelsInSentence(sentence);\n    printSet(&vowels);\n    free(vowels.elements);\n    return 0;\n}\n```"
  },
  {
    "task": "Use a set to track unique session IDs for a web application.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    int sessionID;\n    struct Node* next;\n} Node;\n\ntypedef struct Set {\n    Node* head;\n} Set;\n\nSet* createSet() {\n    Set* set = (Set*)malloc(sizeof(Set));\n    set->head = NULL;\n    return set;\n}\n\nint contains(Set* set, int sessionID) {\n    Node* current = set->head;\n    while (current != NULL) {\n        if (current->sessionID == sessionID) {\n            return 1;\n        }\n        current = current->next;\n    }\n    return 0;\n}\n\nvoid add(Set* set, int sessionID) {\n    if (contains(set, sessionID)) {\n        return;\n    }\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->sessionID = sessionID;\n    newNode->next = set->head;\n    set->head = newNode;\n}\n\nvoid freeSet(Set* set) {\n    Node* current = set->head;\n    while (current != NULL) {\n        Node* next = current->next;\n        free(current);\n        current = next;\n    }\n    free(set);\n}\n\nint main() {\n    Set* sessionSet = createSet();\n\n    add(sessionSet, 101);\n    add(sessionSet, 102);\n    add(sessionSet, 101); // Duplicate, will not be added\n\n    printf(\"Session 101 exists: %d\\n\", contains(sessionSet, 101));\n    printf(\"Session 103 exists: %d\\n\", contains(sessionSet, 103));\n\n    freeSet(sessionSet);\n    return 0;\n}\n```"
  },
  {
    "task": "Create a set of unique city names and demonstrate set operations with it.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_CITIES 100\n#define MAX_NAME_LENGTH 50\n\ntypedef struct {\n    char name[MAX_NAME_LENGTH];\n} City;\n\ntypedef struct {\n    City cities[MAX_CITIES];\n    int size;\n} CitySet;\n\nvoid addCity(CitySet *set, const char *name) {\n    for (int i = 0; i < set->size; i++) {\n        if (strcmp(set->cities[i].name, name) == 0) {\n            return;\n        }\n    }\n    if (set->size < MAX_CITIES) {\n        strncpy(set->cities[set->size].name, name, MAX_NAME_LENGTH - 1);\n        set->cities[set->size].name[MAX_NAME_LENGTH - 1] = '\\0';\n        set->size++;\n    }\n}\n\nint containsCity(const CitySet *set, const char *name) {\n    for (int i = 0; i < set->size; i++) {\n        if (strcmp(set->cities[i].name, name) == 0) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nvoid printCities(const CitySet *set) {\n    printf(\"City Set: \");\n    for (int i = 0; i < set->size; i++) {\n        printf(\"%s \", set->cities[i].name);\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    CitySet citySet = {.size = 0};\n\n    addCity(&citySet, \"New York\");\n    addCity(&citySet, \"Los Angeles\");\n    addCity(&citySet, \"Chicago\");\n    addCity(&citySet, \"New York\"); // Duplicate, will not be added\n    addCity(&citySet, \"Houston\");\n\n    printCities(&citySet);\n\n    printf(\"Contains 'Chicago'? %s\\n\", containsCity(&citySet, \"Chicago\") ? \"Yes\" : \"No\");\n    printf(\"Contains 'Miami'? %s\\n\", containsCity(&citySet, \"Miami\") ? \"Yes\" : \"No\");\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a program to find the common elements in three sets.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int *elements;\n    int size;\n} Set;\n\nvoid findCommonElements(Set set1, Set set2, Set set3) {\n    for(int i = 0; i < set1.size; i++) {\n        int elem = set1.elements[i];\n        int foundInSet2 = 0;\n        int foundInSet3 = 0;\n\n        for(int j = 0; j < set2.size; j++) {\n            if(set2.elements[j] == elem) {\n                foundInSet2 = 1;\n                break;\n            }\n        }\n        \n        for(int k = 0; k < set3.size; k++) {\n            if(set3.elements[k] == elem) {\n                foundInSet3 = 1;\n                break;\n            }\n        }\n\n        if(foundInSet2 && foundInSet3) {\n            printf(\"%d \", elem);\n        }\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    Set set1 = { (int[]){1, 2, 3, 4, 5}, 5 };\n    Set set2 = { (int[]){3, 4, 5, 6, 7}, 5 };\n    Set set3 = { (int[]){5, 6, 7, 8, 9}, 5 };\n\n    printf(\"Common elements: \");\n    findCommonElements(set1, set2, set3);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a set and demonstrate how to remove an element by its value.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct Node {\n    int data;\n    struct Node* next;\n} Node;\n\ntypedef struct Set {\n    Node* head;\n} Set;\n\nSet* createSet() {\n    Set* set = (Set*)malloc(sizeof(Set));\n    set->head = NULL;\n    return set;\n}\n\nvoid addElement(Set* set, int value) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->data = value;\n    newNode->next = set->head;\n    set->head = newNode;\n}\n\nvoid removeElement(Set* set, int value) {\n    Node* current = set->head;\n    Node* previous = NULL;\n    while (current != NULL) {\n        if (current->data == value) {\n            if (previous == NULL) {\n                set->head = current->next;\n            } else {\n                previous->next = current->next;\n            }\n            free(current);\n            return;\n        }\n        previous = current;\n        current = current->next;\n    }\n}\n\nvoid printSet(Set* set) {\n    Node* current = set->head;\n    while (current != NULL) {\n        printf(\"%d \", current->data);\n        current = current->next;\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    Set* set = createSet();\n    addElement(set, 1);\n    addElement(set, 2);\n    addElement(set, 3);\n    printf(\"Set before removing element: \");\n    printSet(set);\n    removeElement(set, 2);\n    printf(\"Set after removing element: \");\n    printSet(set);\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a set to store a collection of unique ISBN numbers.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define ISBN_LENGTH 14  // including the null terminator\n\ntypedef struct Node {\n    char isbn[ISBN_LENGTH];\n    struct Node* next;\n} Node;\n\ntypedef struct Set {\n    Node* head;\n} Set;\n\nSet* createSet() {\n    Set* set = (Set*)malloc(sizeof(Set));\n    set->head = NULL;\n    return set;\n}\n\nint contains(Set* set, const char* isbn) {\n    Node* current = set->head;\n    while (current != NULL) {\n        if (strcmp(current->isbn, isbn) == 0) {\n            return 1;\n        }\n        current = current->next;\n    }\n    return 0;\n}\n\nvoid add(Set* set, const char* isbn) {\n    if (!contains(set, isbn)) {\n        Node* newNode = (Node*)malloc(sizeof(Node));\n        strncpy(newNode->isbn, isbn, ISBN_LENGTH - 1);\n        newNode->isbn[ISBN_LENGTH - 1] = '\\0';  // Ensure null termination\n        newNode->next = set->head;\n        set->head = newNode;\n    }\n}\n\nvoid freeSet(Set* set) {\n    Node* current = set->head;\n    while (current != NULL) {\n        Node* next = current->next;\n        free(current);\n        current = next;\n    }\n    free(set);\n}\n\nint main() {\n    Set* isbnSet = createSet();\n\n    add(isbnSet, \"978-3-16-148410-0\");\n    add(isbnSet, \"978-0-306-40615-7\");\n    add(isbnSet, \"978-3-16-148410-0\"); // This won't be added as it's a duplicate\n\n    printf(\"Contains 978-3-16-148410-0: %d\\n\", contains(isbnSet, \"978-3-16-148410-0\"));\n    printf(\"Contains 978-0-306-40615-7: %d\\n\", contains(isbnSet, \"978-0-306-40615-7\"));\n    printf(\"Contains 978-1-4028-9462-6: %d\\n\", contains(isbnSet, \"978-1-4028-9462-6\"));\n\n    freeSet(isbnSet);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a set and demonstrate the `intersection_update` method.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int *elements;\n    size_t size;\n    size_t capacity;\n} Set;\n\nSet *create_set(size_t initial_capacity) {\n    Set *set = (Set *)malloc(sizeof(Set));\n    set->elements = (int *)malloc(sizeof(int) * initial_capacity);\n    set->size = 0;\n    set->capacity = initial_capacity;\n    return set;\n}\n\nvoid add(Set *set, int value) {\n    for (size_t i = 0; i < set->size; ++i) {\n        if (set->elements[i] == value) {\n            return;\n        }\n    }\n    if (set->size == set->capacity) {\n        set->capacity *= 2;\n        set->elements = (int *)realloc(set->elements, sizeof(int) * set->capacity);\n    }\n    set->elements[set->size++] = value;\n}\n\nvoid intersection_update(Set *set1, Set *set2) {\n    size_t new_size = 0;\n    for (size_t i = 0; i < set1->size; ++i) {\n        for (size_t j = 0; j < set2->size; ++j) {\n            if (set1->elements[i] == set2->elements[j]) {\n                set1->elements[new_size++] = set1->elements[i];\n                break;\n            }\n        }\n    }\n    set1->size = new_size;\n}\n\nvoid print_set(Set *set) {\n    printf(\"{ \");\n    for (size_t i = 0; i < set->size; ++i) {\n        printf(\"%d \", set->elements[i]);\n    }\n    printf(\"}\\n\");\n}\n\nvoid free_set(Set *set) {\n    free(set->elements);\n    free(set);\n}\n\nint main() {\n    Set *set1 = create_set(5);\n    Set *set2 = create_set(5);\n\n    add(set1, 1);\n    add(set1, 2);\n    add(set1, 3);\n\n    add(set2, 2);\n    add(set2, 3);\n    add(set2, 4);\n\n    printf(\"Set 1 before intersection_update: \");\n    print_set(set1);\n\n    printf(\"Set 2: \");\n    print_set(set2);\n\n    intersection_update(set1, set2);\n\n    printf(\"Set 1 after intersection_update: \");\n    print_set(set1);\n\n    free_set(set1);\n    free_set(set2);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function to generate a set of all unique elements in a list.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    int data;\n    struct Node* next;\n} Node;\n\ntypedef struct Set {\n    Node* head;\n} Set;\n\nSet* createSet() {\n    Set* newSet = (Set*)malloc(sizeof(Set));\n    newSet->head = NULL;\n    return newSet;\n}\n\nint isElementInSet(Set* set, int element) {\n    Node* current = set->head;\n    while (current != NULL) {\n        if (current->data == element) {\n            return 1;\n        }\n        current = current->next;\n    }\n    return 0;\n}\n\nvoid addElementToSet(Set* set, int element) {\n    if (!isElementInSet(set, element)) {\n        Node* newNode = (Node*)malloc(sizeof(Node));\n        newNode->data = element;\n        newNode->next = set->head;\n        set->head = newNode;\n    }\n}\n\nSet* generateUniqueSet(int* list, int size) {\n    Set* uniqueSet = createSet();\n    for (int i = 0; i < size; i++) {\n        addElementToSet(uniqueSet, list[i]);\n    }\n    return uniqueSet;\n}\n\nvoid printSet(Set* set) {\n    Node* current = set->head;\n    while (current != NULL) {\n        printf(\"%d \", current->data);\n        current = current->next;\n    }\n    printf(\"\\n\");\n}\n\nvoid freeSet(Set* set) {\n    Node* current = set->head;\n    while (current != NULL) {\n        Node* temp = current;\n        current = current->next;\n        free(temp);\n    }\n    free(set);\n}\n\nint main() {\n    int list[] = {4, 6, 2, 8, 6, 1, 4, 8};\n    int size = sizeof(list) / sizeof(list[0]);\n\n    Set* uniqueSet = generateUniqueSet(list, size);\n    printSet(uniqueSet);\n    freeSet(uniqueSet);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Use a set to determine the unique characters in two strings.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct Node {\n    char data;\n    struct Node *next;\n} Node;\n\ntypedef struct Set {\n    Node *head;\n} Set;\n\nSet *createSet() {\n    Set *set = (Set *)malloc(sizeof(Set));\n    set->head = NULL;\n    return set;\n}\n\nint contains(Set *set, char c) {\n    Node *current = set->head;\n    while (current != NULL) {\n        if (current->data == c) {\n            return 1;\n        }\n        current = current->next;\n    }\n    return 0;\n}\n\nvoid add(Set *set, char c) {\n    if (!contains(set, c)) {\n        Node *newNode = (Node *)malloc(sizeof(Node));\n        newNode->data = c;\n        newNode->next = set->head;\n        set->head = newNode;\n    }\n}\n\nvoid freeSet(Set *set) {\n    Node *current = set->head;\n    while (current != NULL) {\n        Node *next = current->next;\n        free(current);\n        current = next;\n    }\n    free(set);\n}\n\nvoid uniqueCharacters(const char *str1, const char *str2) {\n    Set *set = createSet();\n    for (int i = 0; i < strlen(str1); i++) {\n        add(set, str1[i]);\n    }\n    for (int i = 0; i < strlen(str2); i++) {\n        add(set, str2[i]);\n    }\n    \n    Node *current = set->head;\n    while (current != NULL) {\n        printf(\"%c \", current->data);\n        current = current->next;\n    }\n    printf(\"\\n\");\n    \n    freeSet(set);\n}\n\nint main() {\n    const char *str1 = \"hello\";\n    const char *str2 = \"world\";\n    uniqueCharacters(str1, str2);\n    return 0;\n}\n```"
  },
  {
    "task": "Create a set of unique animal names and demonstrate the `discard` method.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_ANIMALS 100\n#define MAX_NAME_LENGTH 50\n\ntypedef struct {\n    char names[MAX_ANIMALS][MAX_NAME_LENGTH];\n    int size;\n} AnimalSet;\n\nvoid addAnimal(AnimalSet *set, const char *name) {\n    for (int i = 0; i < set->size; ++i) {\n        if (strcmp(set->names[i], name) == 0) {\n            return;\n        }\n    }\n    if (set->size < MAX_ANIMALS) {\n        strcpy(set->names[set->size], name);\n        set->size++;\n    }\n}\n\nvoid discardAnimal(AnimalSet *set, const char *name) {\n    for (int i = 0; i < set->size; ++i) {\n        if (strcmp(set->names[i], name) == 0) {\n            for (int j = i; j < set->size - 1; ++j) {\n                strcpy(set->names[j], set->names[j + 1]);\n            }\n            set->size--;\n            return;\n        }\n    }\n}\n\nvoid printAnimals(const AnimalSet *set) {\n    for (int i = 0; i < set->size; ++i) {\n        printf(\"%s\\n\", set->names[i]);\n    }\n}\n\nint main() {\n    AnimalSet set = { .size = 0 };\n    \n    addAnimal(&set, \"Dog\");\n    addAnimal(&set, \"Cat\");\n    addAnimal(&set, \"Bird\");\n    addAnimal(&set, \"Fish\");\n    \n    printf(\"Animals before discard:\\n\");\n    printAnimals(&set);\n    \n    discardAnimal(&set, \"Cat\");\n    \n    printf(\"\\nAnimals after discard:\\n\");\n    printAnimals(&set);\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Write a program to find all elements present in the first set but not in the second.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    int data;\n    struct Node* next;\n} Node;\n\ntypedef struct Set {\n    Node* head;\n} Set;\n\nvoid add(Set* set, int data) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->data = data;\n    newNode->next = set->head;\n    set->head = newNode;\n}\n\nint contains(Set* set, int data) {\n    Node* current = set->head;\n    while (current != NULL) {\n        if (current->data == data) {\n            return 1;\n        }\n        current = current->next;\n    }\n    return 0;\n}\n\nSet* difference(Set* set1, Set* set2) {\n    Set* diffSet = (Set*)malloc(sizeof(Set));\n    diffSet->head = NULL;\n    Node* current = set1->head;\n    while (current != NULL) {\n        if (!contains(set2, current->data)) {\n            add(diffSet, current->data);\n        }\n        current = current->next;\n    }\n    return diffSet;\n}\n\nvoid printSet(Set* set) {\n    Node* current = set->head;\n    printf(\"{ \");\n    while (current != NULL) {\n        printf(\"%d \", current->data);\n        current = current->next;\n    }\n    printf(\"}\\n\");\n}\n\nvoid freeSet(Set* set) {\n    Node* current = set->head;\n    while (current != NULL) {\n        Node* temp = current;\n        current = current->next;\n        free(temp);\n    }\n    free(set);\n}\n\nint main() {\n    Set* set1 = (Set*)malloc(sizeof(Set));\n    set1->head = NULL;\n    Set* set2 = (Set*)malloc(sizeof(Set));\n    set2->head = NULL;\n\n    // Example elements for set1 and set2\n    add(set1, 1);\n    add(set1, 2);\n    add(set1, 3);\n    add(set2, 2);\n    add(set2, 4);\n\n    printf(\"Set 1: \");\n    printSet(set1);\n    printf(\"Set 2: \");\n    printSet(set2);\n\n    Set* diffSet = difference(set1, set2);\n    printf(\"Difference (Set 1 - Set 2): \");\n    printSet(diffSet);\n\n    // Free allocated memory\n    freeSet(set1);\n    freeSet(set2);\n    freeSet(diffSet);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a set of integers and demonstrate using it to eliminate duplicates from a list.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Set {\n    int *elements;\n    size_t size;\n    size_t capacity;\n} Set;\n\nvoid initSet(Set *set) {\n    set->size = 0;\n    set->capacity = 10;\n    set->elements = (int *)malloc(set->capacity * sizeof(int));\n}\n\nvoid addToSet(Set *set, int value) {\n    for (size_t i = 0; i < set->size; i++) {\n        if (set->elements[i] == value) {\n            return;\n        }\n    }\n    if (set->size >= set->capacity) {\n        set->capacity *= 2;\n        set->elements = (int *)realloc(set->elements, set->capacity * sizeof(int));\n    }\n    set->elements[set->size++] = value;\n}\n\nvoid freeSet(Set *set) {\n    free(set->elements);\n    set->elements = NULL;\n    set->size = 0;\n    set->capacity = 0;\n}\n\nvoid printSet(Set *set) {\n    for (size_t i = 0; i < set->size; i++) {\n        printf(\"%d \", set->elements[i]);\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    int list[] = {1, 2, 2, 3, 4, 4, 5, 6, 6, 7};\n    size_t listSize = sizeof(list) / sizeof(list[0]);\n\n    Set set;\n    initSet(&set);\n\n    for (size_t i = 0; i < listSize; i++) {\n        addToSet(&set, list[i]);\n    }\n\n    printSet(&set);\n\n    freeSet(&set);\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a set to manage a collection of unique car models.",
    "code": "```c\n#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_MODELS 100\n#define MODEL_NAME_LEN 50\n\ntypedef struct {\n    char models[MAX_MODELS][MODEL_NAME_LEN];\n    int count;\n} CarModelSet;\n\nvoid initSet(CarModelSet *set) {\n    set->count = 0;\n}\n\nbool addModel(CarModelSet *set, const char *model) {\n    for (int i = 0; i < set->count; i++) {\n        if (strcmp(set->models[i], model) == 0) {\n            return false; // Model already exists\n        }\n    }\n    if (set->count < MAX_MODELS) {\n        strcpy(set->models[set->count++], model);\n        return true;\n    }\n    return false; // Set is full\n}\n\nbool removeModel(CarModelSet *set, const char *model) {\n    for (int i = 0; i < set->count; i++) {\n        if (strcmp(set->models[i], model) == 0) {\n            for (int j = i; j < set->count - 1; j++) {\n                strcpy(set->models[j], set->models[j + 1]);\n            }\n            set->count--;\n            return true;\n        }\n    }\n    return false; // Model not found\n}\n\nbool containsModel(const CarModelSet *set, const char *model) {\n    for (int i = 0; i < set->count; i++) {\n        if (strcmp(set->models[i], model) == 0) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid printSet(const CarModelSet *set) {\n    printf(\"Car Models:\\n\");\n    for (int i = 0; i < set->count; i++) {\n        printf(\"%s\\n\", set->models[i]);\n    }\n}\n\nint main() {\n    CarModelSet carSet;\n    initSet(&carSet);\n\n    addModel(&carSet, \"Toyota\");\n    addModel(&carSet, \"Honda\");\n    addModel(&carSet, \"Ford\");\n\n    printSet(&carSet);\n\n    removeModel(&carSet, \"Honda\");\n\n    printSet(&carSet);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a set and demonstrate the use of the `clear` method.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Set {\n    int *elements;\n    size_t size;\n} Set;\n\nSet createSet() {\n    Set set;\n    set.elements = NULL;\n    set.size = 0;\n    return set;\n}\n\nvoid addElement(Set *set, int element) {\n    set->elements = realloc(set->elements, (set->size + 1) * sizeof(int));\n    set->elements[set->size] = element;\n    set->size++;\n}\n\nvoid clearSet(Set *set) {\n    free(set->elements);\n    set->elements = NULL;\n    set->size = 0;\n}\n\nvoid printSet(const Set *set) {\n    printf(\"{ \");\n    for (size_t i = 0; i < set->size; ++i) {\n        printf(\"%d \", set->elements[i]);\n    }\n    printf(\"}\\n\");\n}\n\nint main() {\n    Set mySet = createSet();\n\n    addElement(&mySet, 1);\n    addElement(&mySet, 2);\n    addElement(&mySet, 3);\n\n    printf(\"Set before clear: \");\n    printSet(&mySet);\n\n    clearSet(&mySet);\n\n    printf(\"Set after clear: \");\n    printSet(&mySet);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that finds the intersection of multiple sets.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Set {\n    int *elements;\n    int size;\n} Set;\n\nSet intersection(Set *sets, int numSets) {\n    if (numSets == 0) {\n        Set emptySet = {NULL, 0};\n        return emptySet;\n    }\n\n    int *result = (int *)malloc(sets[0].size * sizeof(int));\n    int resultSize = 0;\n\n    for (int i = 0; i < sets[0].size; i++) {\n        int elem = sets[0].elements[i];\n        int foundInAll = 1;\n        for (int j = 1; j < numSets; j++) {\n            int foundInCurrent = 0;\n            for (int k = 0; k < sets[j].size; k++) {\n                if (sets[j].elements[k] == elem) {\n                    foundInCurrent = 1;\n                    break;\n                }\n            }\n            if (!foundInCurrent) {\n                foundInAll = 0;\n                break;\n            }\n        }\n        if (foundInAll) {\n            result[resultSize++] = elem;\n        }\n    }\n\n    Set resultSet = {result, resultSize};\n    return resultSet;\n}\n\nvoid freeSet(Set *set) {\n    free(set->elements);\n    set->elements = NULL;\n    set->size = 0;\n}\n\nint main() {\n    Set sets[3];\n    int elements1[] = {1, 2, 3, 4};\n    int elements2[] = {3, 4, 5, 6};\n    int elements3[] = {0, 4, 3, 7};\n    \n    sets[0].elements = elements1;\n    sets[0].size = 4;\n    sets[1].elements = elements2;\n    sets[1].size = 4;\n    sets[2].elements = elements3;\n    sets[2].size = 4;\n\n    Set resultSet = intersection(sets, 3);\n    \n    printf(\"Intersection: \");\n    for (int i = 0; i < resultSet.size; i++) {\n        printf(\"%d \", resultSet.elements[i]);\n    }\n    printf(\"\\n\");\n\n    freeSet(&resultSet);\n    return 0;\n}\n```"
  },
  {
    "task": "Use a set to identify unique words in a paragraph.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_WORD_LENGTH 100\n#define MAX_PARAGRAPH_LENGTH 1000\n\ntypedef struct Node {\n    char word[MAX_WORD_LENGTH];\n    struct Node *next;\n} Node;\n\ntypedef struct {\n    Node *head;\n} Set;\n\nSet* createSet() {\n    Set *set = (Set *)malloc(sizeof(Set));\n    set->head = NULL;\n    return set;\n}\n\nint contains(Set *set, const char *word) {\n    Node *current = set->head;\n    while (current != NULL) {\n        if (strcmp(current->word, word) == 0) {\n            return 1;\n        }\n        current = current->next;\n    }\n    return 0;\n}\n\nvoid add(Set *set, const char *word) {\n    if (!contains(set, word)) {\n        Node *newNode = (Node *)malloc(sizeof(Node));\n        strcpy(newNode->word, word);\n        newNode->next = set->head;\n        set->head = newNode;\n    }\n}\n\nvoid freeSet(Set *set) {\n    Node *current = set->head;\n    while (current != NULL) {\n        Node *next = current->next;\n        free(current);\n        current = next;\n    }\n    free(set);\n}\n\nvoid printSet(Set *set) {\n    Node *current = set->head;\n    while (current != NULL) {\n        printf(\"%s\\n\", current->word);\n        current = current->next;\n    }\n}\n\nint main() {\n    char paragraph[MAX_PARAGRAPH_LENGTH] = \"This is a sample paragraph with some words. Some words are repeated, and some are unique.\";\n    char delimiters[] = \" ,.!?\\n\";\n    char *token;\n\n    Set *uniqueWords = createSet();\n\n    token = strtok(paragraph, delimiters);\n    while (token != NULL) {\n        add(uniqueWords, token);\n        token = strtok(NULL, delimiters);\n    }\n\n    printSet(uniqueWords);\n\n    freeSet(uniqueWords);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a set of unique country codes and demonstrate membership testing.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_COUNTRY_CODES 10\n#define MAX_CODE_LENGTH 4\n\ntypedef struct {\n    char codes[MAX_COUNTRY_CODES][MAX_CODE_LENGTH];\n    int size;\n} Set;\n\nvoid initSet(Set* set) {\n    set->size = 0;\n}\n\nint isMember(Set* set, const char* code) {\n    for (int i = 0; i < set->size; ++i) {\n        if (strcmp(set->codes[i], code) == 0) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nvoid addToSet(Set* set, const char* code) {\n    if (!isMember(set, code) && set->size < MAX_COUNTRY_CODES) {\n        strcpy(set->codes[set->size], code);\n        set->size++;\n    }\n}\n\nint main() {\n    Set countryCodes;\n    initSet(&countryCodes);\n\n    addToSet(&countryCodes, \"USA\");\n    addToSet(&countryCodes, \"CAN\");\n    addToSet(&countryCodes, \"MEX\");\n\n    printf(\"Is USA in set? %s\\n\", isMember(&countryCodes, \"USA\") ? \"Yes\" : \"No\");\n    printf(\"Is BRA in set? %s\\n\", isMember(&countryCodes, \"BRA\") ? \"Yes\" : \"No\");\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a program to find the union of two sets and return it as a list.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    int data;\n    struct Node *next;\n} Node;\n\ntypedef struct Set {\n    Node *head;\n} Set;\n\nSet* createSet() {\n    Set *set = (Set*)malloc(sizeof(Set));\n    set->head = NULL;\n    return set;\n}\n\nvoid add(Set *set, int value) {\n    Node *current = set->head;\n    while (current != NULL) {\n        if (current->data == value) {\n            return;\n        }\n        current = current->next;\n    }\n    Node *newNode = (Node*)malloc(sizeof(Node));\n    newNode->data = value;\n    newNode->next = set->head;\n    set->head = newNode;\n}\n\nSet* unionSets(Set *set1, Set *set2) {\n    Set *result = createSet();\n    Node *current = set1->head;\n    while (current != NULL) {\n        add(result, current->data);\n        current = current->next;\n    }\n    current = set2->head;\n    while (current != NULL) {\n        add(result, current->data);\n        current = current->next;\n    }\n    return result;\n}\n\nvoid printSet(Set *set) {\n    Node *current = set->head;\n    while (current != NULL) {\n        printf(\"%d \", current->data);\n        current = current->next;\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    Set *set1 = createSet();\n    Set *set2 = createSet();\n    \n    add(set1, 1);\n    add(set1, 2);\n    add(set1, 3);\n    \n    add(set2, 3);\n    add(set2, 4);\n    add(set2, 5);\n    \n    Set *result = unionSets(set1, set2);\n    printSet(result);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a set and demonstrate using it to check if all elements of another set are present.",
    "code": "```c\n#include <stdio.h>\n#include <stdbool.h>\n\n#define MAX_SIZE 100\n\ntypedef struct {\n    int elements[MAX_SIZE];\n    int size;\n} Set;\n\n// Function to initialize a set\nvoid initSet(Set *s) {\n    s->size = 0;\n}\n\n// Function to add an element to the set\nvoid addElement(Set *s, int element) {\n    for (int i = 0; i < s->size; i++) {\n        if (s->elements[i] == element) {\n            return;\n        }\n    }\n    s->elements[s->size++] = element;\n}\n\n// Function to check if an element is in the set\nbool contains(Set *s, int element) {\n    for (int i = 0; i < s->size; i++) {\n        if (s->elements[i] == element) {\n            return true;\n        }\n    }\n    return false;\n}\n\n// Function to check if all elements of set b are in set a\nbool checkSubset(Set *a, Set *b) {\n    for (int i = 0; i < b->size; i++) {\n        if (!contains(a, b->elements[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    Set setA, setB;\n    initSet(&setA);\n    initSet(&setB);\n\n    addElement(&setA, 1);\n    addElement(&setA, 2);\n    addElement(&setA, 3);\n\n    addElement(&setB, 2);\n    addElement(&setB, 3);\n\n    if (checkSubset(&setA, &setB)) {\n        printf(\"All elements of setB are present in setA.\\n\");\n    } else {\n        printf(\"Not all elements of setB are present in setA.\\n\");\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a set to store unique coupon codes and demonstrate adding new codes.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_CODES 100\n#define CODE_LENGTH 20\n\ntypedef struct {\n    char codes[MAX_CODES][CODE_LENGTH];\n    int size;\n} CouponSet;\n\nvoid initSet(CouponSet *set) {\n    set->size = 0;\n}\n\nint contains(CouponSet *set, const char *code) {\n    for (int i = 0; i < set->size; i++) {\n        if (strcmp(set->codes[i], code) == 0) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nvoid addCode(CouponSet *set, const char *code) {\n    if (!contains(set, code) && set->size < MAX_CODES) {\n        strncpy(set->codes[set->size], code, CODE_LENGTH - 1);\n        set->codes[set->size][CODE_LENGTH - 1] = '\\0'; // Ensure null-termination\n        set->size++;\n    }\n}\n\nint main() {\n    CouponSet set;\n    initSet(&set);\n    \n    addCode(&set, \"COUPON123\");\n    addCode(&set, \"DISCOUNT50\");\n    addCode(&set, \"SAVE10\");\n    addCode(&set, \"COUPON123\"); // Duplicate, should not be added\n\n    for (int i = 0; i < set.size; i++) {\n        printf(\"Coupon Code: %s\\n\", set.codes[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a set and demonstrate the `copy` method.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct Set {\n    int *elements;\n    size_t size;\n    size_t capacity;\n} Set;\n\nSet *create_set(size_t capacity) {\n    Set *set = (Set *)malloc(sizeof(Set));\n    set->elements = (int *)malloc(capacity * sizeof(int));\n    set->size = 0;\n    set->capacity = capacity;\n    return set;\n}\n\nvoid add_element(Set *set, int element) {\n    for (size_t i = 0; i < set->size; i++) {\n        if (set->elements[i] == element) {\n            return; // element already in set\n        }\n    }\n    if (set->size < set->capacity) {\n        set->elements[set->size] = element;\n        set->size++;\n    } else {\n        // Handle capacity overflow\n        set->capacity *= 2;\n        set->elements = (int *)realloc(set->elements, set->capacity * sizeof(int));\n        set->elements[set->size] = element;\n        set->size++;\n    }\n}\n\nSet *copy_set(const Set *original) {\n    Set *copy = create_set(original->capacity);\n    copy->size = original->size;\n    memcpy(copy->elements, original->elements, original->size * sizeof(int));\n    return copy;\n}\n\nvoid print_set(const Set *set) {\n    printf(\"{ \");\n    for (size_t i = 0; i < set->size; i++) {\n        printf(\"%d \", set->elements[i]);\n    }\n    printf(\"}\\n\");\n}\n\nvoid free_set(Set *set) {\n    free(set->elements);\n    free(set);\n}\n\nint main() {\n    Set *original_set = create_set(5);\n    add_element(original_set, 1);\n    add_element(original_set, 2);\n    add_element(original_set, 3);\n\n    printf(\"Original set: \");\n    print_set(original_set);\n\n    Set *copied_set = copy_set(original_set);\n    printf(\"Copied set: \");\n    print_set(copied_set);\n\n    free_set(original_set);\n    free_set(copied_set);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function to remove duplicates from a list using a set.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    int value;\n    struct Node* next;\n} Node;\n\ntypedef struct Set {\n    int* data;\n    int size;\n    int capacity;\n} Set;\n\nSet* createSet(int capacity) {\n    Set* set = (Set*)malloc(sizeof(Set));\n    set->data = (int*)malloc(capacity * sizeof(int));\n    set->size = 0;\n    set->capacity = capacity;\n    return set;\n}\n\nint contains(Set* set, int value) {\n    for (int i = 0; i < set->size; i++) {\n        if (set->data[i] == value) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nvoid add(Set* set, int value) {\n    if (!contains(set, value)) {\n        if (set->size == set->capacity) {\n            set->capacity *= 2;\n            set->data = (int*)realloc(set->data, set->capacity * sizeof(int));\n        }\n        set->data[set->size++] = value;\n    }\n}\n\nvoid freeSet(Set* set) {\n    free(set->data);\n    free(set);\n}\n\nNode* removeDuplicates(Node* head) {\n    Set* seen = createSet(10);\n    Node* current = head;\n    Node* prev = NULL;\n    \n    while (current != NULL) {\n        if (contains(seen, current->value)) {\n            prev->next = current->next;\n            free(current);\n            current = prev->next;\n        } else {\n            add(seen, current->value);\n            prev = current;\n            current = current->next;\n        }\n    }\n    \n    freeSet(seen);\n    return head;\n}\n```"
  },
  {
    "task": "Use a set to identify unique numbers in a sequence.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    int data;\n    struct Node* next;\n} Node;\n\ntypedef struct Set {\n    Node* head;\n} Set;\n\nSet* createSet() {\n    Set* set = (Set*)malloc(sizeof(Set));\n    set->head = NULL;\n    return set;\n}\n\nint contains(Set* set, int value) {\n    Node* current = set->head;\n    while (current != NULL) {\n        if (current->data == value) {\n            return 1;\n        }\n        current = current->next;\n    }\n    return 0;\n}\n\nvoid add(Set* set, int value) {\n    if (!contains(set, value)) {\n        Node* newNode = (Node*)malloc(sizeof(Node));\n        newNode->data = value;\n        newNode->next = set->head;\n        set->head = newNode;\n    }\n}\n\nvoid freeSet(Set* set) {\n    Node* current = set->head;\n    while (current != NULL) {\n        Node* next = current->next;\n        free(current);\n        current = next;\n    }\n    free(set);\n}\n\nvoid printSet(Set* set) {\n    Node* current = set->head;\n    while (current != NULL) {\n        printf(\"%d \", current->data);\n        current = current->next;\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    int sequence[] = {1, 2, 2, 3, 4, 4, 5};\n    int n = sizeof(sequence) / sizeof(sequence[0]);\n\n    Set* set = createSet();\n\n    for (int i = 0; i < n; i++) {\n        add(set, sequence[i]);\n    }\n\n    printSet(set);\n\n    freeSet(set);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a set of unique fruit names and demonstrate set operations with it.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct Node {\n    char *fruit;\n    struct Node *next;\n} Node;\n\ntypedef struct Set {\n    Node *head;\n} Set;\n\nSet* create_set() {\n    Set *set = (Set*)malloc(sizeof(Set));\n    set->head = NULL;\n    return set;\n}\n\nint contains(Set *set, const char *fruit) {\n    Node *current = set->head;\n    while (current != NULL) {\n        if (strcmp(current->fruit, fruit) == 0) {\n            return 1;\n        }\n        current = current->next;\n    }\n    return 0;\n}\n\nvoid add(Set *set, const char *fruit) {\n    if (!contains(set, fruit)) {\n        Node *newNode = (Node*)malloc(sizeof(Node));\n        newNode->fruit = strdup(fruit);\n        newNode->next = set->head;\n        set->head = newNode;\n    }\n}\n\nvoid display(Set *set) {\n    Node *current = set->head;\n    printf(\"{ \");\n    while (current != NULL) {\n        printf(\"%s \", current->fruit);\n        current = current->next;\n    }\n    printf(\"}\\n\");\n}\n\nvoid free_set(Set *set) {\n    Node *current = set->head;\n    while (current != NULL) {\n        Node *next = current->next;\n        free(current->fruit);\n        free(current);\n        current = next;\n    }\n    free(set);\n}\n\nint main() {\n    Set *fruitSet = create_set();\n\n    add(fruitSet, \"apple\");\n    add(fruitSet, \"banana\");\n    add(fruitSet, \"orange\");\n    add(fruitSet, \"apple\"); // Duplicate, should not be added\n\n    display(fruitSet);\n    \n    free_set(fruitSet);\n    return 0;\n}\n```"
  }
]