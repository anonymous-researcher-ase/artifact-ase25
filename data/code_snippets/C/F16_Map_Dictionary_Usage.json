[
  {
    "task": "Create a map to store student names as keys and their grades as values, then calculate the average grade.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_STUDENTS 100\n\ntypedef struct {\n    char name[50];\n    int grade;\n} Student;\n\nint main() {\n    Student students[MAX_STUDENTS];\n    int num_students = 0;\n    char input[50];\n    int total_grades = 0;\n\n    // Example data\n    strcpy(students[num_students].name, \"Alice\");\n    students[num_students++].grade = 85;\n    strcpy(students[num_students].name, \"Bob\");\n    students[num_students++].grade = 90;\n    strcpy(students[num_students].name, \"Charlie\");\n    students[num_students++].grade = 78;\n\n    // Calculate the average grade\n    for (int i = 0; i < num_students; i++) {\n        total_grades += students[i].grade;\n    }\n\n    double average_grade = (double)total_grades / num_students;\n    printf(\"Average grade: %.2f\\n\", average_grade);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a function that takes a dictionary of product names and prices, and returns the total cost of all products.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    char *productName;\n    double price;\n} Product;\n\ntypedef struct {\n    Product *products;\n    size_t size;\n} ProductMap;\n\ndouble calculateTotalCost(ProductMap productMap) {\n    double totalCost = 0.0;\n    for (size_t i = 0; i < productMap.size; ++i) {\n        totalCost += productMap.products[i].price;\n    }\n    return totalCost;\n}\n\nint main() {\n    Product products[] = {\n        {\"Product1\", 10.5},\n        {\"Product2\", 20.0},\n        {\"Product3\", 30.25}\n    };\n    ProductMap productMap = {products, 3};\n    \n    double totalCost = calculateTotalCost(productMap);\n    printf(\"Total Cost: %.2f\\n\", totalCost);\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a program that counts the frequency of each word in a given text using a dictionary.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#define MAX_WORD_LENGTH 100\n\ntypedef struct WordFreq {\n    char word[MAX_WORD_LENGTH];\n    int count;\n    struct WordFreq *next;\n} WordFreq;\n\nWordFreq *addWord(WordFreq *head, const char *word) {\n    WordFreq *current = head;\n    while (current != NULL) {\n        if (strcmp(current->word, word) == 0) {\n            current->count++;\n            return head;\n        }\n        current = current->next;\n    }\n\n    WordFreq *newNode = (WordFreq *)malloc(sizeof(WordFreq));\n    strcpy(newNode->word, word);\n    newNode->count = 1;\n    newNode->next = head;\n    return newNode;\n}\n\nvoid printWordFrequencies(WordFreq *head) {\n    WordFreq *current = head;\n    while (current != NULL) {\n        printf(\"%s: %d\\n\", current->word, current->count);\n        current = current->next;\n    }\n}\n\nvoid freeWordFrequencies(WordFreq *head) {\n    WordFreq *current = head;\n    while (current != NULL) {\n        WordFreq *next = current->next;\n        free(current);\n        current = next;\n    }\n}\n\nint main() {\n    WordFreq *wordFreqs = NULL;\n    char text[] = \"this is a test. This test is only a test.\";\n    char *word;\n    char delimiters[] = \" .,!?\";\n\n    word = strtok(text, delimiters);\n    while (word != NULL) {\n        for (int i = 0; word[i]; i++) {\n            word[i] = tolower(word[i]);\n        }\n        wordFreqs = addWord(wordFreqs, word);\n        word = strtok(NULL, delimiters);\n    }\n\n    printWordFrequencies(wordFreqs);\n    freeWordFrequencies(wordFreqs);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that takes a dictionary of employee IDs and their work hours, and returns the ID of the employee with the most hours.",
    "code": "```c\n#include <stdio.h>\n\ntypedef struct {\n    int id;\n    int hours;\n} Employee;\n\nint findMaxHoursEmployee(Employee employees[], int size) {\n    if (size == 0) return -1;\n    int maxId = employees[0].id;\n    int maxHours = employees[0].hours;\n    for (int i = 1; i < size; i++) {\n        if (employees[i].hours > maxHours) {\n            maxHours = employees[i].hours;\n            maxId = employees[i].id;\n        }\n    }\n    return maxId;\n}\n\nint main() {\n    Employee employees[] = {{101, 40}, {102, 50}, {103, 45}};\n    int size = sizeof(employees) / sizeof(employees[0]);\n    int maxId = findMaxHoursEmployee(employees, size);\n    printf(\"Employee with the most hours: %d\\n\", maxId);\n    return 0;\n}\n```"
  },
  {
    "task": "Design a system that uses a map to store users' login attempts and timestamps, then locks the account after three failed attempts.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n#include <time.h>\n\n#define MAX_ATTEMPTS 3\n\ntypedef struct {\n    int attempt_count;\n    time_t last_attempt;\n} UserStatus;\n\ntypedef struct {\n    char username[50];\n    UserStatus status;\n} UserRecord;\n\nUserRecord user_records[100];\nint user_count = 0;\n\nint find_user_index(const char* username) {\n    for (int i = 0; i < user_count; i++) {\n        if (strcmp(user_records[i].username, username) == 0) {\n            return i;\n        }\n    }\n    return -1;\n}\n\nvoid register_failed_attempt(const char* username) {\n    int index = find_user_index(username);\n    if (index == -1) {\n        strcpy(user_records[user_count].username, username);\n        user_records[user_count].status.attempt_count = 1;\n        user_records[user_count].status.last_attempt = time(NULL);\n        user_count++;\n    } else {\n        user_records[index].status.attempt_count++;\n        user_records[index].status.last_attempt = time(NULL);\n    }\n}\n\nint is_account_locked(const char* username) {\n    int index = find_user_index(username);\n    if (index != -1) {\n        return user_records[index].status.attempt_count >= MAX_ATTEMPTS;\n    }\n    return 0;\n}\n\nvoid reset_attempts(const char* username) {\n    int index = find_user_index(username);\n    if (index != -1) {\n        user_records[index].status.attempt_count = 0;\n    }\n}\n\nint main() {\n    const char* user1 = \"user1\";\n    register_failed_attempt(user1);\n    register_failed_attempt(user1);\n    printf(\"User1 locked: %d\\n\", is_account_locked(user1));\n    register_failed_attempt(user1);\n    printf(\"User1 locked: %d\\n\", is_account_locked(user1));\n    reset_attempts(user1);\n    printf(\"User1 locked after reset: %d\\n\", is_account_locked(user1));\n    return 0;\n}\n```"
  },
  {
    "task": "Create a dictionary to represent a phonebook, allowing users to add, remove, and look up contacts by name.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_NAME_LENGTH 100\n#define MAX_PHONE_LENGTH 15\n#define INITIAL_CAPACITY 10\n\ntypedef struct {\n    char name[MAX_NAME_LENGTH];\n    char phone[MAX_PHONE_LENGTH];\n} Contact;\n\ntypedef struct {\n    Contact *contacts;\n    int size;\n    int capacity;\n} PhoneBook;\n\nPhoneBook* createPhoneBook() {\n    PhoneBook *phoneBook = (PhoneBook *)malloc(sizeof(PhoneBook));\n    phoneBook->contacts = (Contact *)malloc(INITIAL_CAPACITY * sizeof(Contact));\n    phoneBook->size = 0;\n    phoneBook->capacity = INITIAL_CAPACITY;\n    return phoneBook;\n}\n\nvoid addContact(PhoneBook *phoneBook, const char *name, const char *phone) {\n    if (phoneBook->size >= phoneBook->capacity) {\n        phoneBook->capacity *= 2;\n        phoneBook->contacts = (Contact *)realloc(phoneBook->contacts, phoneBook->capacity * sizeof(Contact));\n    }\n    strncpy(phoneBook->contacts[phoneBook->size].name, name, MAX_NAME_LENGTH);\n    strncpy(phoneBook->contacts[phoneBook->size].phone, phone, MAX_PHONE_LENGTH);\n    phoneBook->size++;\n}\n\nvoid removeContact(PhoneBook *phoneBook, const char *name) {\n    for (int i = 0; i < phoneBook->size; i++) {\n        if (strcmp(phoneBook->contacts[i].name, name) == 0) {\n            for (int j = i; j < phoneBook->size - 1; j++) {\n                phoneBook->contacts[j] = phoneBook->contacts[j + 1];\n            }\n            phoneBook->size--;\n            break;\n        }\n    }\n}\n\nchar* lookupContact(PhoneBook *phoneBook, const char *name) {\n    for (int i = 0; i < phoneBook->size; i++) {\n        if (strcmp(phoneBook->contacts[i].name, name) == 0) {\n            return phoneBook->contacts[i].phone;\n        }\n    }\n    return NULL;\n}\n\nvoid freePhoneBook(PhoneBook *phoneBook) {\n    free(phoneBook->contacts);\n    free(phoneBook);\n}\n\nint main() {\n    PhoneBook *phoneBook = createPhoneBook();\n    addContact(phoneBook, \"Alice\", \"123-456-7890\");\n    addContact(phoneBook, \"Bob\", \"098-765-4321\");\n    \n    char *phone = lookupContact(phoneBook, \"Alice\");\n    if (phone != NULL) {\n        printf(\"Alice's phone: %s\\n\", phone);\n    } else {\n        printf(\"Contact not found.\\n\");\n    }\n    \n    removeContact(phoneBook, \"Alice\");\n    \n    phone = lookupContact(phoneBook, \"Alice\");\n    if (phone != NULL) {\n        printf(\"Alice's phone: %s\\n\", phone);\n    } else {\n        printf(\"Contact not found.\\n\");\n    }\n    \n    freePhoneBook(phoneBook);\n    return 0;\n}\n```"
  },
  {
    "task": "Build a map that associates city names with their population, then find the city with the highest population.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_CITIES 100\n\ntypedef struct {\n    char cityName[50];\n    int population;\n} City;\n\nint main() {\n    City cityMap[MAX_CITIES];\n    int cityCount = 0;\n\n    // Example data\n    strcpy(cityMap[cityCount].cityName, \"New York\");\n    cityMap[cityCount++].population = 8419000;\n    strcpy(cityMap[cityCount].cityName, \"Los Angeles\");\n    cityMap[cityCount++].population = 3980400;\n    strcpy(cityMap[cityCount].cityName, \"Chicago\");\n    cityMap[cityCount++].population = 2716000;\n\n    City maxCity;\n    maxCity.population = 0;\n\n    for (int i = 0; i < cityCount; i++) {\n        if (cityMap[i].population > maxCity.population) {\n            maxCity = cityMap[i];\n        }\n    }\n\n    printf(\"City with the highest population: %s (%d)\\n\", maxCity.cityName, maxCity.population);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a program that translates English words to another language using a provided dictionary, and translates a given sentence.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_WORD_LENGTH 50\n#define MAX_TRANSLATION_LENGTH 50\n#define MAX_DICTIONARY_SIZE 100\n#define MAX_SENTENCE_LENGTH 500\n\ntypedef struct {\n    char english[MAX_WORD_LENGTH];\n    char foreign[MAX_TRANSLATION_LENGTH];\n} DictionaryEntry;\n\nint main() {\n    DictionaryEntry dictionary[MAX_DICTIONARY_SIZE] = {\n        {\"hello\", \"hola\"},\n        {\"world\", \"mundo\"},\n        {\"how\", \"c\u00f3mo\"},\n        {\"are\", \"est\u00e1s\"},\n        {\"you\", \"t\u00fa\"}\n    };\n    int dictionarySize = 5;\n\n    char sentence[MAX_SENTENCE_LENGTH] = \"hello world how are you\";\n    char translatedSentence[MAX_SENTENCE_LENGTH] = \"\";\n\n    char *word = strtok(sentence, \" \");\n    while (word != NULL) {\n        int found = 0;\n        for (int i = 0; i < dictionarySize; i++) {\n            if (strcmp(word, dictionary[i].english) == 0) {\n                strcat(translatedSentence, dictionary[i].foreign);\n                found = 1;\n                break;\n            }\n        }\n        if (!found) {\n            strcat(translatedSentence, word);\n        }\n        strcat(translatedSentence, \" \");\n        word = strtok(NULL, \" \");\n    }\n\n    printf(\"Translated Sentence: %s\\n\", translatedSentence);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Construct a dictionary to map book titles to their authors, and implement a search function to find all books by a given author.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    char *title;\n    char *author;\n} Book;\n\ntypedef struct {\n    Book *books;\n    size_t size;\n} Dictionary;\n\nvoid initDictionary(Dictionary *dict) {\n    dict->books = NULL;\n    dict->size = 0;\n}\n\nvoid addBook(Dictionary *dict, const char *title, const char *author) {\n    dict->books = realloc(dict->books, (dict->size + 1) * sizeof(Book));\n    dict->books[dict->size].title = strdup(title);\n    dict->books[dict->size].author = strdup(author);\n    dict->size++;\n}\n\nvoid findBooksByAuthor(Dictionary *dict, const char *author) {\n    for (size_t i = 0; i < dict->size; i++) {\n        if (strcmp(dict->books[i].author, author) == 0) {\n            printf(\"Book: %s\\n\", dict->books[i].title);\n        }\n    }\n}\n\nvoid freeDictionary(Dictionary *dict) {\n    for (size_t i = 0; i < dict->size; i++) {\n        free(dict->books[i].title);\n        free(dict->books[i].author);\n    }\n    free(dict->books);\n}\n\nint main() {\n    Dictionary dict;\n    initDictionary(&dict);\n\n    addBook(&dict, \"1984\", \"George Orwell\");\n    addBook(&dict, \"Animal Farm\", \"George Orwell\");\n    addBook(&dict, \"Brave New World\", \"Aldous Huxley\");\n\n    printf(\"Books by George Orwell:\\n\");\n    findBooksByAuthor(&dict, \"George Orwell\");\n\n    freeDictionary(&dict);\n    return 0;\n}\n```"
  },
  {
    "task": "Create a map to store product IDs and their stock levels, then implement a function to update stock levels after a sale.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    int productId;\n    int stockLevel;\n} Product;\n\ntypedef struct {\n    Product *products;\n    size_t size;\n    size_t capacity;\n} ProductMap;\n\nvoid initializeMap(ProductMap *map, size_t capacity) {\n    map->products = (Product *)malloc(capacity * sizeof(Product));\n    map->size = 0;\n    map->capacity = capacity;\n}\n\nvoid addProduct(ProductMap *map, int productId, int stockLevel) {\n    if (map->size >= map->capacity) {\n        map->capacity *= 2;\n        map->products = (Product *)realloc(map->products, map->capacity * sizeof(Product));\n    }\n    map->products[map->size].productId = productId;\n    map->products[map->size].stockLevel = stockLevel;\n    map->size++;\n}\n\nint findProductIndex(ProductMap *map, int productId) {\n    for (size_t i = 0; i < map->size; i++) {\n        if (map->products[i].productId == productId) {\n            return i;\n        }\n    }\n    return -1;\n}\n\nvoid updateStock(ProductMap *map, int productId, int quantitySold) {\n    int index = findProductIndex(map, productId);\n    if (index != -1) {\n        map->products[index].stockLevel -= quantitySold;\n    }\n}\n\nvoid freeMap(ProductMap *map) {\n    free(map->products);\n}\n\nint main() {\n    ProductMap map;\n    initializeMap(&map, 5);\n\n    addProduct(&map, 101, 50);\n    addProduct(&map, 102, 30);\n    addProduct(&map, 103, 20);\n\n    updateStock(&map, 101, 5);\n\n    for (size_t i = 0; i < map.size; i++) {\n        printf(\"Product ID: %d, Stock Level: %d\\n\", map.products[i].productId, map.products[i].stockLevel);\n    }\n\n    freeMap(&map);\n    return 0;\n}\n```"
  },
  {
    "task": "Write a script that uses a dictionary to convert country codes to country names and prints the full name for a given code.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    char code[3];\n    char name[50];\n} Country;\n\nCountry dictionary[] = {\n    {\"US\", \"United States\"},\n    {\"CA\", \"Canada\"},\n    {\"MX\", \"Mexico\"},\n    {\"FR\", \"France\"},\n    {\"DE\", \"Germany\"},\n    {\"JP\", \"Japan\"}\n};\n\nconst char* getCountryName(const char* code) {\n    int size = sizeof(dictionary) / sizeof(dictionary[0]);\n    for (int i = 0; i < size; i++) {\n        if (strcmp(dictionary[i].code, code) == 0) {\n            return dictionary[i].name;\n        }\n    }\n    return \"Unknown\";\n}\n\nint main() {\n    const char* code = \"JP\";\n    printf(\"The country name for code %s is %s.\\n\", code, getCountryName(code));\n    return 0;\n}\n```"
  },
  {
    "task": "Design a program that stores student IDs and names in a dictionary, and allows retrieval of names by ID.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    int id;\n    char name[50];\n} Student;\n\ntypedef struct {\n    Student *students;\n    size_t size;\n    size_t capacity;\n} Dictionary;\n\nvoid initDictionary(Dictionary *dict, size_t capacity) {\n    dict->students = malloc(capacity * sizeof(Student));\n    dict->size = 0;\n    dict->capacity = capacity;\n}\n\nvoid addStudent(Dictionary *dict, int id, const char *name) {\n    if (dict->size == dict->capacity) {\n        dict->capacity *= 2;\n        dict->students = realloc(dict->students, dict->capacity * sizeof(Student));\n    }\n    dict->students[dict->size].id = id;\n    strcpy(dict->students[dict->size].name, name);\n    dict->size++;\n}\n\nchar* getStudentName(Dictionary *dict, int id) {\n    for (size_t i = 0; i < dict->size; i++) {\n        if (dict->students[i].id == id) {\n            return dict->students[i].name;\n        }\n    }\n    return NULL;\n}\n\nvoid freeDictionary(Dictionary *dict) {\n    free(dict->students);\n}\n\nint main() {\n    Dictionary studentDict;\n    initDictionary(&studentDict, 2);\n\n    addStudent(&studentDict, 101, \"Alice\");\n    addStudent(&studentDict, 102, \"Bob\");\n\n    int searchId = 101;\n    char *name = getStudentName(&studentDict, searchId);\n    if (name) {\n        printf(\"Student ID %d: %s\\n\", searchId, name);\n    } else {\n        printf(\"Student ID %d not found.\\n\", searchId);\n    }\n\n    freeDictionary(&studentDict);\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a dictionary to store configuration settings for a software application, allowing updates and retrieval of settings.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_CONFIGS 100\n#define MAX_KEY_LENGTH 50\n#define MAX_VALUE_LENGTH 100\n\ntypedef struct {\n    char key[MAX_KEY_LENGTH];\n    char value[MAX_VALUE_LENGTH];\n} Config;\n\ntypedef struct {\n    Config configs[MAX_CONFIGS];\n    int size;\n} ConfigDictionary;\n\nvoid initDictionary(ConfigDictionary *dict) {\n    dict->size = 0;\n}\n\nvoid updateConfig(ConfigDictionary *dict, const char *key, const char *value) {\n    for (int i = 0; i < dict->size; i++) {\n        if (strcmp(dict->configs[i].key, key) == 0) {\n            strncpy(dict->configs[i].value, value, MAX_VALUE_LENGTH);\n            return;\n        }\n    }\n    if (dict->size < MAX_CONFIGS) {\n        strncpy(dict->configs[dict->size].key, key, MAX_KEY_LENGTH);\n        strncpy(dict->configs[dict->size].value, value, MAX_VALUE_LENGTH);\n        dict->size++;\n    }\n}\n\nconst char *getConfig(ConfigDictionary *dict, const char *key) {\n    for (int i = 0; i < dict->size; i++) {\n        if (strcmp(dict->configs[i].key, key) == 0) {\n            return dict->configs[i].value;\n        }\n    }\n    return NULL;\n}\n\nint main() {\n    ConfigDictionary dict;\n    initDictionary(&dict);\n\n    updateConfig(&dict, \"setting1\", \"value1\");\n    updateConfig(&dict, \"setting2\", \"value2\");\n\n    printf(\"setting1: %s\\n\", getConfig(&dict, \"setting1\"));\n    printf(\"setting2: %s\\n\", getConfig(&dict, \"setting2\"));\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a map that stores words as keys and their definitions as values, and write a function to display all words starting with a given letter.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct Node {\n    char *key;\n    char *value;\n    struct Node *next;\n} Node;\n\ntypedef struct {\n    Node **buckets;\n    size_t size;\n} HashMap;\n\nunsigned int hash(const char *str, size_t size) {\n    unsigned int hash = 0;\n    while (*str) {\n        hash = (hash << 5) + *str++;\n    }\n    return hash % size;\n}\n\nHashMap* create_map(size_t size) {\n    HashMap *map = (HashMap *)malloc(sizeof(HashMap));\n    map->buckets = (Node **)calloc(size, sizeof(Node *));\n    map->size = size;\n    return map;\n}\n\nvoid insert(HashMap *map, const char *key, const char *value) {\n    unsigned int index = hash(key, map->size);\n    Node *newNode = (Node *)malloc(sizeof(Node));\n    newNode->key = strdup(key);\n    newNode->value = strdup(value);\n    newNode->next = map->buckets[index];\n    map->buckets[index] = newNode;\n}\n\nvoid display_words_starting_with(HashMap *map, char letter) {\n    for (size_t i = 0; i < map->size; i++) {\n        Node *current = map->buckets[i];\n        while (current) {\n            if (current->key[0] == letter) {\n                printf(\"Word: %s, Definition: %s\\n\", current->key, current->value);\n            }\n            current = current->next;\n        }\n    }\n}\n\nvoid free_map(HashMap *map) {\n    for (size_t i = 0; i < map->size; i++) {\n        Node *current = map->buckets[i];\n        while (current) {\n            Node *temp = current;\n            current = current->next;\n            free(temp->key);\n            free(temp->value);\n            free(temp);\n        }\n    }\n    free(map->buckets);\n    free(map);\n}\n\nint main() {\n    HashMap *map = create_map(100);\n    insert(map, \"apple\", \"a fruit\");\n    insert(map, \"banana\", \"another fruit\");\n    insert(map, \"apricot\", \"a type of fruit\");\n    insert(map, \"carrot\", \"a vegetable\");\n\n    printf(\"Words starting with 'a':\\n\");\n    display_words_starting_with(map, 'a');\n\n    free_map(map);\n    return 0;\n}\n```"
  },
  {
    "task": "Write a program that uses a dictionary to store usernames and passwords, and verifies login attempts.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_USERS 100\n#define USERNAME_LENGTH 50\n#define PASSWORD_LENGTH 50\n\ntypedef struct {\n    char username[USERNAME_LENGTH];\n    char password[PASSWORD_LENGTH];\n} User;\n\ntypedef struct {\n    User users[MAX_USERS];\n    int size;\n} UserMap;\n\nvoid initUserMap(UserMap* map) {\n    map->size = 0;\n}\n\nint addUser(UserMap* map, const char* username, const char* password) {\n    if (map->size >= MAX_USERS) {\n        return -1; // Map is full\n    }\n    strcpy(map->users[map->size].username, username);\n    strcpy(map->users[map->size].password, password);\n    map->size++;\n    return 0;\n}\n\nint verifyLogin(UserMap* map, const char* username, const char* password) {\n    for (int i = 0; i < map->size; i++) {\n        if (strcmp(map->users[i].username, username) == 0 &&\n            strcmp(map->users[i].password, password) == 0) {\n            return 1; // Login successful\n        }\n    }\n    return 0; // Login failed\n}\n\nint main() {\n    UserMap userMap;\n    initUserMap(&userMap);\n\n    addUser(&userMap, \"user1\", \"password1\");\n    addUser(&userMap, \"user2\", \"password2\");\n\n    if (verifyLogin(&userMap, \"user1\", \"password1\")) {\n        printf(\"Login successful!\\n\");\n    } else {\n        printf(\"Login failed!\\n\");\n    }\n\n    if (verifyLogin(&userMap, \"user2\", \"wrongpassword\")) {\n        printf(\"Login successful!\\n\");\n    } else {\n        printf(\"Login failed!\\n\");\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Design a map to track the number of times each item is purchased in a store, then find the most popular item.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_ITEMS 100\n#define MAX_NAME_LENGTH 50\n\ntypedef struct {\n    char name[MAX_NAME_LENGTH];\n    int count;\n} Item;\n\nint main() {\n    Item items[MAX_ITEMS];\n    int itemCount = 0;\n    \n    // Sample input data (items purchased)\n    const char *purchases[] = {\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"apple\"};\n    int purchaseCount = sizeof(purchases) / sizeof(purchases[0]);\n\n    // Track the number of times each item is purchased\n    for (int i = 0; i < purchaseCount; i++) {\n        int found = 0;\n        for (int j = 0; j < itemCount; j++) {\n            if (strcmp(items[j].name, purchases[i]) == 0) {\n                items[j].count++;\n                found = 1;\n                break;\n            }\n        }\n        if (!found && itemCount < MAX_ITEMS) {\n            strcpy(items[itemCount].name, purchases[i]);\n            items[itemCount].count = 1;\n            itemCount++;\n        }\n    }\n\n    // Find the most popular item\n    int maxCount = 0;\n    char mostPopular[MAX_NAME_LENGTH];\n    for (int i = 0; i < itemCount; i++) {\n        if (items[i].count > maxCount) {\n            maxCount = items[i].count;\n            strcpy(mostPopular, items[i].name);\n        }\n    }\n\n    printf(\"Most popular item: %s\\n\", mostPopular);\n    return 0;\n}\n```"
  },
  {
    "task": "Build a dictionary that associates file extensions with their corresponding application types and uses it to determine how to open a given file.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    char extension[10];\n    char application[50];\n} FileAssociation;\n\n#define DICTIONARY_SIZE 3\n\nint main() {\n    FileAssociation dictionary[DICTIONARY_SIZE] = {\n        {\".txt\", \"Text Editor\"},\n        {\".jpg\", \"Image Viewer\"},\n        {\".mp4\", \"Video Player\"}\n    };\n\n    char filename[100];\n    printf(\"Enter the filename: \");\n    scanf(\"%s\", filename);\n\n    char *ext = strrchr(filename, '.');\n    if (ext) {\n        int i;\n        for (i = 0; i < DICTIONARY_SIZE; i++) {\n            if (strcmp(ext, dictionary[i].extension) == 0) {\n                printf(\"Open with: %s\\n\", dictionary[i].application);\n                break;\n            }\n        }\n        if (i == DICTIONARY_SIZE) {\n            printf(\"No application found for this file type.\\n\");\n        }\n    } else {\n        printf(\"No file extension found.\\n\");\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a program that uses a map to store menu items and their prices, and allows customers to calculate their total bill.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_ITEMS 10\n\ntypedef struct {\n    char name[50];\n    double price;\n} MenuItem;\n\nint main() {\n    MenuItem menu[MAX_ITEMS] = {\n        {\"Burger\", 5.99},\n        {\"Fries\", 2.99},\n        {\"Soda\", 1.50},\n        {\"Salad\", 4.50},\n        {\"Pizza\", 8.99}\n    };\n    int menuSize = 5;\n\n    char order[50];\n    double totalBill = 0.0;\n\n    printf(\"Enter your order items (type 'done' to finish):\\n\");\n    while (1) {\n        scanf(\"%49s\", order);\n        if (strcmp(order, \"done\") == 0) {\n            break;\n        }\n\n        int found = 0;\n        for (int i = 0; i < menuSize; i++) {\n            if (strcmp(order, menu[i].name) == 0) {\n                totalBill += menu[i].price;\n                found = 1;\n                break;\n            }\n        }\n\n        if (!found) {\n            printf(\"Item not found on menu. Please try again.\\n\");\n        }\n    }\n\n    printf(\"Total Bill: $%.2f\\n\", totalBill);\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a dictionary to track the inventory of a warehouse, allowing additions, removals, and inventory checks.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_ITEMS 100\n#define NAME_LENGTH 50\n\ntypedef struct {\n    char name[NAME_LENGTH];\n    int quantity;\n} Item;\n\ntypedef struct {\n    Item items[MAX_ITEMS];\n    int count;\n} Inventory;\n\nvoid init_inventory(Inventory *inventory) {\n    inventory->count = 0;\n}\n\nint find_item_index(Inventory *inventory, const char *name) {\n    for (int i = 0; i < inventory->count; ++i) {\n        if (strcmp(inventory->items[i].name, name) == 0) {\n            return i;\n        }\n    }\n    return -1;\n}\n\nvoid add_item(Inventory *inventory, const char *name, int quantity) {\n    int index = find_item_index(inventory, name);\n    if (index == -1) {\n        if (inventory->count < MAX_ITEMS) {\n            strcpy(inventory->items[inventory->count].name, name);\n            inventory->items[inventory->count].quantity = quantity;\n            inventory->count++;\n        } else {\n            printf(\"Inventory is full.\\n\");\n        }\n    } else {\n        inventory->items[index].quantity += quantity;\n    }\n}\n\nvoid remove_item(Inventory *inventory, const char *name, int quantity) {\n    int index = find_item_index(inventory, name);\n    if (index != -1) {\n        if (inventory->items[index].quantity >= quantity) {\n            inventory->items[index].quantity -= quantity;\n            if (inventory->items[index].quantity == 0) {\n                for (int i = index; i < inventory->count - 1; ++i) {\n                    inventory->items[i] = inventory->items[i + 1];\n                }\n                inventory->count--;\n            }\n        } else {\n            printf(\"Not enough quantity to remove.\\n\");\n        }\n    } else {\n        printf(\"Item not found.\\n\");\n    }\n}\n\nvoid check_inventory(Inventory *inventory) {\n    for (int i = 0; i < inventory->count; ++i) {\n        printf(\"Item: %s, Quantity: %d\\n\", inventory->items[i].name, inventory->items[i].quantity);\n    }\n}\n\nint main() {\n    Inventory inventory;\n    init_inventory(&inventory);\n\n    add_item(&inventory, \"Apples\", 50);\n    add_item(&inventory, \"Bananas\", 30);\n    check_inventory(&inventory);\n\n    remove_item(&inventory, \"Apples\", 10);\n    check_inventory(&inventory);\n\n    remove_item(&inventory, \"Bananas\", 40);\n    check_inventory(&inventory);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that uses a map to convert Roman numerals to integers.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\nint romanToInt(char *s) {\n    int map[26] = {0};\n    map['I' - 'A'] = 1;\n    map['V' - 'A'] = 5;\n    map['X' - 'A'] = 10;\n    map['L' - 'A'] = 50;\n    map['C' - 'A'] = 100;\n    map['D' - 'A'] = 500;\n    map['M' - 'A'] = 1000;\n\n    int total = 0;\n    int len = strlen(s);\n    for (int i = 0; i < len; i++) {\n        int value = map[s[i] - 'A'];\n        if (i < len - 1 && value < map[s[i + 1] - 'A']) {\n            total -= value;\n        } else {\n            total += value;\n        }\n    }\n    return total;\n}\n\nint main() {\n    printf(\"%d\\n\", romanToInt(\"III\"));   // Output: 3\n    printf(\"%d\\n\", romanToInt(\"IV\"));    // Output: 4\n    printf(\"%d\\n\", romanToInt(\"IX\"));    // Output: 9\n    printf(\"%d\\n\", romanToInt(\"LVIII\")); // Output: 58\n    printf(\"%d\\n\", romanToInt(\"MCMXCIV\")); // Output: 1994\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a program that uses a dictionary to track the number of occurrences of each letter in a string.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    char *str = \"example string\";\n    int counts[256] = {0};\n\n    for (int i = 0; str[i] != '\\0'; i++) {\n        counts[(unsigned char)str[i]]++;\n    }\n\n    for (int i = 0; i < 256; i++) {\n        if (counts[i] > 0 && ((i >= 'a' && i <= 'z') || (i >= 'A' && i <= 'Z'))) {\n            printf(\"'%c' : %d\\n\", i, counts[i]);\n        }\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a map to store team names and their scores, then determine the team with the highest score.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_TEAMS 100\n#define NAME_LENGTH 50\n\ntypedef struct {\n    char name[NAME_LENGTH];\n    int score;\n} Team;\n\nint main() {\n    Team teams[MAX_TEAMS];\n    int n, i, maxIndex = 0;\n    \n    printf(\"Enter the number of teams: \");\n    scanf(\"%d\", &n);\n    \n    for (i = 0; i < n; i++) {\n        printf(\"Enter team name: \");\n        scanf(\"%s\", teams[i].name);\n        printf(\"Enter team score: \");\n        scanf(\"%d\", &teams[i].score);\n    }\n    \n    for (i = 1; i < n; i++) {\n        if (teams[i].score > teams[maxIndex].score) {\n            maxIndex = i;\n        }\n    }\n    \n    printf(\"Team with the highest score: %s with %d points\\n\", teams[maxIndex].name, teams[maxIndex].score);\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that takes a dictionary of item weights and calculates the total weight of all items.",
    "code": "```c\n#include <stdio.h>\n\ntypedef struct {\n    char *key;\n    double value;\n} Item;\n\ndouble calculateTotalWeight(Item *items, int size) {\n    double totalWeight = 0.0;\n    for (int i = 0; i < size; i++) {\n        totalWeight += items[i].value;\n    }\n    return totalWeight;\n}\n\nint main() {\n    Item items[] = {\n        {\"item1\", 2.5},\n        {\"item2\", 3.0},\n        {\"item3\", 4.5}\n    };\n    int size = sizeof(items) / sizeof(items[0]);\n    double totalWeight = calculateTotalWeight(items, size);\n    printf(\"Total weight: %.2f\\n\", totalWeight);\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a map to store website URLs and their respective visit counts, then find the most visited website.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_WEBSITES 100\n\ntypedef struct {\n    char url[256];\n    int count;\n} Website;\n\nint main() {\n    Website websites[MAX_WEBSITES];\n    int num_websites = 0;\n\n    // Example data\n    const char *urls[] = {\n        \"https://example.com\",\n        \"https://example.com\",\n        \"https://example2.com\",\n        \"https://example.com\",\n        \"https://example2.com\",\n        \"https://example3.com\"\n    };\n    int num_urls = sizeof(urls) / sizeof(urls[0]);\n\n    // Count the visits\n    for (int i = 0; i < num_urls; i++) {\n        int found = 0;\n        for (int j = 0; j < num_websites; j++) {\n            if (strcmp(websites[j].url, urls[i]) == 0) {\n                websites[j].count++;\n                found = 1;\n                break;\n            }\n        }\n        if (!found) {\n            strcpy(websites[num_websites].url, urls[i]);\n            websites[num_websites].count = 1;\n            num_websites++;\n        }\n    }\n\n    // Find the most visited website\n    int max_index = 0;\n    for (int i = 1; i < num_websites; i++) {\n        if (websites[i].count > websites[max_index].count) {\n            max_index = i;\n        }\n    }\n\n    printf(\"Most visited website: %s with %d visits\\n\", websites[max_index].url, websites[max_index].count);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a script that uses a dictionary to map error codes to error messages, and prints the message for a given code.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_ERROR_CODE 5\n\ntypedef struct {\n    int code;\n    const char *message;\n} ErrorMap;\n\nconst ErrorMap error_map[MAX_ERROR_CODE] = {\n    {404, \"Not Found\"},\n    {500, \"Internal Server Error\"},\n    {403, \"Forbidden\"},\n    {400, \"Bad Request\"},\n    {401, \"Unauthorized\"}\n};\n\nconst char* get_error_message(int code) {\n    for (int i = 0; i < MAX_ERROR_CODE; i++) {\n        if (error_map[i].code == code) {\n            return error_map[i].message;\n        }\n    }\n    return \"Unknown Error\";\n}\n\nint main() {\n    int code;\n    printf(\"Enter error code: \");\n    scanf(\"%d\", &code);\n\n    const char *message = get_error_message(code);\n    printf(\"Error message: %s\\n\", message);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Design a dictionary to store contact information with names as keys and phone numbers as values, allowing updates and lookups.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_CONTACTS 100\n#define NAME_LENGTH 50\n#define PHONE_LENGTH 15\n\ntypedef struct {\n    char name[NAME_LENGTH];\n    char phone[PHONE_LENGTH];\n} Contact;\n\ntypedef struct {\n    Contact contacts[MAX_CONTACTS];\n    int size;\n} Dictionary;\n\nvoid initDictionary(Dictionary *dict) {\n    dict->size = 0;\n}\n\nint findContact(Dictionary *dict, const char *name) {\n    for (int i = 0; i < dict->size; i++) {\n        if (strcmp(dict->contacts[i].name, name) == 0) {\n            return i;\n        }\n    }\n    return -1;\n}\n\nvoid addOrUpdateContact(Dictionary *dict, const char *name, const char *phone) {\n    int index = findContact(dict, name);\n    if (index != -1) {\n        strncpy(dict->contacts[index].phone, phone, PHONE_LENGTH);\n    } else if (dict->size < MAX_CONTACTS) {\n        strncpy(dict->contacts[dict->size].name, name, NAME_LENGTH);\n        strncpy(dict->contacts[dict->size].phone, phone, PHONE_LENGTH);\n        dict->size++;\n    }\n}\n\nconst char* lookupContact(Dictionary *dict, const char *name) {\n    int index = findContact(dict, name);\n    if (index != -1) {\n        return dict->contacts[index].phone;\n    }\n    return NULL;\n}\n\nint main() {\n    Dictionary dict;\n    initDictionary(&dict);\n\n    addOrUpdateContact(&dict, \"Alice\", \"123-456-7890\");\n    addOrUpdateContact(&dict, \"Bob\", \"987-654-3210\");\n    \n    const char *phone = lookupContact(&dict, \"Alice\");\n    if (phone) {\n        printf(\"Alice's phone number is %s\\n\", phone);\n    } else {\n        printf(\"Alice's phone number not found.\\n\");\n    }\n\n    addOrUpdateContact(&dict, \"Alice\", \"111-222-3333\");\n    phone = lookupContact(&dict, \"Alice\");\n    if (phone) {\n        printf(\"Alice's updated phone number is %s\\n\", phone);\n    }\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Write a program that uses a map to assign tasks to employees based on their skill levels.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_EMPLOYEES 100\n#define MAX_TASKS 10\n\ntypedef struct {\n    char name[50];\n    char skill[50];\n} Employee;\n\ntypedef struct {\n    char task[50];\n    char requiredSkill[50];\n} Task;\n\ntypedef struct {\n    Employee employee;\n    Task task;\n} Assignment;\n\nint main() {\n    Employee employees[MAX_EMPLOYEES] = {\n        {\"Alice\", \"Intermediate\"},\n        {\"Bob\", \"Beginner\"},\n        {\"Charlie\", \"Advanced\"}\n    };\n\n    Task tasks[MAX_TASKS] = {\n        {\"Data Entry\", \"Beginner\"},\n        {\"Software Development\", \"Intermediate\"},\n        {\"System Design\", \"Advanced\"}\n    };\n\n    Assignment assignments[MAX_EMPLOYEES];\n\n    int numEmployees = 3;\n    int numTasks = 3;\n    int assignmentCount = 0;\n\n    for (int i = 0; i < numEmployees; ++i) {\n        for (int j = 0; j < numTasks; ++j) {\n            if (strcmp(employees[i].skill, tasks[j].requiredSkill) == 0) {\n                assignments[assignmentCount].employee = employees[i];\n                assignments[assignmentCount].task = tasks[j];\n                assignmentCount++;\n            }\n        }\n    }\n\n    printf(\"Task Assignments:\\n\");\n    for (int i = 0; i < assignmentCount; ++i) {\n        printf(\"Employee: %s, Task: %s\\n\", assignments[i].employee.name, assignments[i].task.task);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a dictionary that maps airport codes to their respective city names, and allows retrieval of city names by code.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n// Define a structure for dictionary items\ntypedef struct {\n    char code[4];\n    char city[50];\n} Airport;\n\n// Function to find a city by airport code\nconst char* getCityByCode(Airport *dictionary, int size, const char *code) {\n    for (int i = 0; i < size; i++) {\n        if (strcmp(dictionary[i].code, code) == 0) {\n            return dictionary[i].city;\n        }\n    }\n    return NULL;\n}\n\nint main() {\n    // Initialize the dictionary\n    Airport dictionary[] = {\n        {\"LAX\", \"Los Angeles\"},\n        {\"JFK\", \"New York\"},\n        {\"ORD\", \"Chicago\"},\n        {\"ATL\", \"Atlanta\"},\n        {\"DFW\", \"Dallas/Fort Worth\"}\n    };\n    int size = sizeof(dictionary) / sizeof(dictionary[0]);\n\n    // Retrieve city name by code\n    const char *code = \"JFK\";\n    const char *city = getCityByCode(dictionary, size, code);\n\n    if (city) {\n        printf(\"The city for airport code %s is %s.\\n\", code, city);\n    } else {\n        printf(\"Airport code %s not found.\\n\", code);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Build a map to store movie titles and their release years, then find all movies released in a given decade.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    char title[100];\n    int year;\n} Movie;\n\ntypedef struct {\n    Movie *movies;\n    size_t size;\n    size_t capacity;\n} MovieMap;\n\nvoid initMovieMap(MovieMap *map, size_t capacity) {\n    map->movies = (Movie *)malloc(capacity * sizeof(Movie));\n    map->size = 0;\n    map->capacity = capacity;\n}\n\nvoid addMovie(MovieMap *map, const char *title, int year) {\n    if (map->size == map->capacity) {\n        map->capacity *= 2;\n        map->movies = (Movie *)realloc(map->movies, map->capacity * sizeof(Movie));\n    }\n    strcpy(map->movies[map->size].title, title);\n    map->movies[map->size].year = year;\n    map->size++;\n}\n\nvoid findMoviesByDecade(MovieMap *map, int decade) {\n    printf(\"Movies released in the %d0s:\\n\", decade);\n    for (size_t i = 0; i < map->size; i++) {\n        if (map->movies[i].year / 10 == decade) {\n            printf(\"%s (%d)\\n\", map->movies[i].title, map->movies[i].year);\n        }\n    }\n}\n\nvoid freeMovieMap(MovieMap *map) {\n    free(map->movies);\n}\n\nint main() {\n    MovieMap map;\n    initMovieMap(&map, 5);\n    \n    addMovie(&map, \"The Godfather\", 1972);\n    addMovie(&map, \"Star Wars\", 1977);\n    addMovie(&map, \"Back to the Future\", 1985);\n    addMovie(&map, \"Pulp Fiction\", 1994);\n    addMovie(&map, \"The Dark Knight\", 2008);\n    \n    findMoviesByDecade(&map, 197);\n    findMoviesByDecade(&map, 198);\n    \n    freeMovieMap(&map);\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that uses a dictionary to group students by their grades.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_NAME_LENGTH 50\n#define MAX_STUDENTS 100\n#define MAX_GRADES 10\n\ntypedef struct {\n    char name[MAX_NAME_LENGTH];\n    char grade;\n} Student;\n\ntypedef struct {\n    char grade;\n    Student students[MAX_STUDENTS];\n    int count;\n} GradeGroup;\n\ntypedef struct {\n    GradeGroup groups[MAX_GRADES];\n    int count;\n} GradeDictionary;\n\nvoid addStudent(GradeDictionary *dict, Student student) {\n    for (int i = 0; i < dict->count; i++) {\n        if (dict->groups[i].grade == student.grade) {\n            dict->groups[i].students[dict->groups[i].count++] = student;\n            return;\n        }\n    }\n    dict->groups[dict->count].grade = student.grade;\n    dict->groups[dict->count].students[0] = student;\n    dict->groups[dict->count++].count = 1;\n}\n\nvoid printGradeDictionary(GradeDictionary *dict) {\n    for (int i = 0; i < dict->count; i++) {\n        printf(\"Grade %c:\\n\", dict->groups[i].grade);\n        for (int j = 0; j < dict->groups[i].count; j++) {\n            printf(\"  %s\\n\", dict->groups[i].students[j].name);\n        }\n    }\n}\n\nint main() {\n    GradeDictionary dict = {.count = 0};\n\n    Student students[] = {\n        {\"Alice\", 'A'},\n        {\"Bob\", 'B'},\n        {\"Charlie\", 'A'},\n        {\"David\", 'C'},\n        {\"Eve\", 'B'}\n    };\n    int studentCount = sizeof(students) / sizeof(students[0]);\n\n    for (int i = 0; i < studentCount; i++) {\n        addStudent(&dict, students[i]);\n    }\n\n    printGradeDictionary(&dict);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a dictionary to store the number of visitors to different sections of a website, and determine the most visited section.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_SECTIONS 100\n\ntypedef struct {\n    char section[50];\n    int visitors;\n} SectionData;\n\nint main() {\n    SectionData sections[MAX_SECTIONS];\n    int sectionCount = 0;\n    \n    // Example data\n    strcpy(sections[sectionCount].section, \"Home\");\n    sections[sectionCount++].visitors = 150;\n    \n    strcpy(sections[sectionCount].section, \"About\");\n    sections[sectionCount++].visitors = 75;\n    \n    strcpy(sections[sectionCount].section, \"Contact\");\n    sections[sectionCount++].visitors = 200;\n    \n    strcpy(sections[sectionCount].section, \"Blog\");\n    sections[sectionCount++].visitors = 125;\n    \n    // Determine the most visited section\n    int maxVisitors = 0;\n    char mostVisited[50];\n    for (int i = 0; i < sectionCount; i++) {\n        if (sections[i].visitors > maxVisitors) {\n            maxVisitors = sections[i].visitors;\n            strcpy(mostVisited, sections[i].section);\n        }\n    }\n    \n    printf(\"Most visited section: %s with %d visitors\\n\", mostVisited, maxVisitors);\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Design a program that uses a map to assign project deadlines to team members, allowing for deadline extensions.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_NAME_LENGTH 50\n#define MAX_DATE_LENGTH 12\n\ntypedef struct {\n    char memberName[MAX_NAME_LENGTH];\n    char deadline[MAX_DATE_LENGTH];\n} Project;\n\ntypedef struct {\n    Project *projects;\n    size_t size;\n    size_t capacity;\n} ProjectMap;\n\nvoid initProjectMap(ProjectMap *map) {\n    map->size = 0;\n    map->capacity = 10;\n    map->projects = malloc(map->capacity * sizeof(Project));\n}\n\nvoid addOrUpdateProject(ProjectMap *map, const char *memberName, const char *deadline) {\n    for (size_t i = 0; i < map->size; ++i) {\n        if (strcmp(map->projects[i].memberName, memberName) == 0) {\n            strncpy(map->projects[i].deadline, deadline, MAX_DATE_LENGTH);\n            return;\n        }\n    }\n    if (map->size >= map->capacity) {\n        map->capacity *= 2;\n        map->projects = realloc(map->projects, map->capacity * sizeof(Project));\n    }\n    strncpy(map->projects[map->size].memberName, memberName, MAX_NAME_LENGTH);\n    strncpy(map->projects[map->size].deadline, deadline, MAX_DATE_LENGTH);\n    map->size++;\n}\n\nvoid printProjectMap(const ProjectMap *map) {\n    for (size_t i = 0; i < map->size; ++i) {\n        printf(\"Member: %s, Deadline: %s\\n\", map->projects[i].memberName, map->projects[i].deadline);\n    }\n}\n\nvoid freeProjectMap(ProjectMap *map) {\n    free(map->projects);\n    map->projects = NULL;\n    map->size = 0;\n    map->capacity = 0;\n}\n\nint main() {\n    ProjectMap projectMap;\n    initProjectMap(&projectMap);\n\n    addOrUpdateProject(&projectMap, \"Alice\", \"2023-12-01\");\n    addOrUpdateProject(&projectMap, \"Bob\", \"2023-11-15\");\n    addOrUpdateProject(&projectMap, \"Alice\", \"2023-12-15\"); // Extend Alice's deadline\n\n    printProjectMap(&projectMap);\n\n    freeProjectMap(&projectMap);\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a dictionary that keeps track of borrowed books in a library, allowing users to check available books.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct Book {\n    char title[100];\n    int isBorrowed;\n} Book;\n\ntypedef struct Dictionary {\n    Book *books;\n    int size;\n} Dictionary;\n\nDictionary *createDictionary(int size) {\n    Dictionary *dict = (Dictionary *)malloc(sizeof(Dictionary));\n    dict->books = (Book *)malloc(size * sizeof(Book));\n    dict->size = size;\n    for (int i = 0; i < size; i++) {\n        dict->books[i].isBorrowed = 0;\n    }\n    return dict;\n}\n\nvoid addBook(Dictionary *dict, int index, char *title) {\n    if (index >= 0 && index < dict->size) {\n        strcpy(dict->books[index].title, title);\n    }\n}\n\nvoid borrowBook(Dictionary *dict, char *title) {\n    for (int i = 0; i < dict->size; i++) {\n        if (strcmp(dict->books[i].title, title) == 0) {\n            if (!dict->books[i].isBorrowed) {\n                dict->books[i].isBorrowed = 1;\n                printf(\"Book '%s' borrowed successfully.\\n\", title);\n            } else {\n                printf(\"Book '%s' is already borrowed.\\n\", title);\n            }\n            return;\n        }\n    }\n    printf(\"Book '%s' not found in library.\\n\", title);\n}\n\nvoid checkAvailableBooks(Dictionary *dict) {\n    printf(\"Available books:\\n\");\n    for (int i = 0; i < dict->size; i++) {\n        if (!dict->books[i].isBorrowed) {\n            printf(\"- %s\\n\", dict->books[i].title);\n        }\n    }\n}\n\nvoid freeDictionary(Dictionary *dict) {\n    free(dict->books);\n    free(dict);\n}\n\nint main() {\n    Dictionary *library = createDictionary(3);\n    addBook(library, 0, \"The Great Gatsby\");\n    addBook(library, 1, \"1984\");\n    addBook(library, 2, \"To Kill a Mockingbird\");\n\n    borrowBook(library, \"1984\");\n    borrowBook(library, \"1984\");\n\n    checkAvailableBooks(library);\n\n    freeDictionary(library);\n    return 0;\n}\n```"
  },
  {
    "task": "Create a map to store the names of planets and their distances from the sun, then find the closest planet to Earth.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n#define NUM_PLANETS 5\n\ntypedef struct {\n    char name[20];\n    double distanceFromSun; // in million kilometers\n} Planet;\n\nint main() {\n    Planet planets[NUM_PLANETS] = {\n        {\"Mercury\", 57.9},\n        {\"Venus\", 108.2},\n        {\"Earth\", 149.6},\n        {\"Mars\", 227.9},\n        {\"Jupiter\", 778.3}\n    };\n\n    double earthDistance = 149.6;\n    double minDifference = 1e9;\n    int closestPlanetIndex = -1;\n\n    for (int i = 0; i < NUM_PLANETS; i++) {\n        if (strcmp(planets[i].name, \"Earth\") != 0) {\n            double difference = planets[i].distanceFromSun - earthDistance;\n            if (difference < 0) difference = -difference;\n            if (difference < minDifference) {\n                minDifference = difference;\n                closestPlanetIndex = i;\n            }\n        }\n    }\n\n    if (closestPlanetIndex != -1) {\n        printf(\"The closest planet to Earth is %s.\\n\", planets[closestPlanetIndex].name);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a script that uses a dictionary to translate Morse code into plain text.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    const char *morse;\n    char letter;\n} MorseCode;\n\nMorseCode morseDictionary[] = {\n    {\".-\", 'A'},   {\"-...\", 'B'}, {\"-.-.\", 'C'}, {\"-..\", 'D'}, {\".\", 'E'},\n    {\"..-.\", 'F'}, {\"--.\", 'G'},  {\"....\", 'H'}, {\"..\", 'I'},  {\".---\", 'J'},\n    {\"-.-\", 'K'},  {\".-..\", 'L'}, {\"--\", 'M'},   {\"-.\", 'N'},  {\"---\", 'O'},\n    {\".--.\", 'P'}, {\"--.-\", 'Q'}, {\".-.\", 'R'},  {\"...\", 'S'}, {\"-\", 'T'},\n    {\"..-\", 'U'},  {\"...-\", 'V'}, {\".--\", 'W'},  {\"-..-\", 'X'}, {\"-.--\", 'Y'},\n    {\"--..\", 'Z'}, {\"/\", ' '},    {NULL, 0}\n};\n\nchar translateMorseToText(const char *morse) {\n    for (int i = 0; morseDictionary[i].morse != NULL; i++) {\n        if (strcmp(morseDictionary[i].morse, morse) == 0) {\n            return morseDictionary[i].letter;\n        }\n    }\n    return '?';\n}\n\nvoid translateMorseString(const char *morseCode) {\n    char buffer[10];\n    int bufferIndex = 0;\n    for (int i = 0; morseCode[i] != '\\0'; i++) {\n        if (morseCode[i] != ' ') {\n            buffer[bufferIndex++] = morseCode[i];\n        } else {\n            buffer[bufferIndex] = '\\0';\n            printf(\"%c\", translateMorseToText(buffer));\n            bufferIndex = 0;\n        }\n    }\n    if (bufferIndex > 0) {\n        buffer[bufferIndex] = '\\0';\n        printf(\"%c\", translateMorseToText(buffer));\n    }\n}\n\nint main() {\n    const char *morseCode = \"... --- ... / .... . .-.. .-.. ---\";\n    translateMorseString(morseCode);\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a program that uses a map to store vehicle registration numbers and their corresponding owner's name.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_VEHICLES 100\n\ntypedef struct {\n    char registrationNumber[15];\n    char ownerName[50];\n} Vehicle;\n\ntypedef struct {\n    Vehicle vehicles[MAX_VEHICLES];\n    int size;\n} VehicleMap;\n\nvoid addVehicle(VehicleMap *map, const char *registrationNumber, const char *ownerName) {\n    if (map->size < MAX_VEHICLES) {\n        strcpy(map->vehicles[map->size].registrationNumber, registrationNumber);\n        strcpy(map->vehicles[map->size].ownerName, ownerName);\n        map->size++;\n    }\n}\n\nconst char* getOwnerName(VehicleMap *map, const char *registrationNumber) {\n    for (int i = 0; i < map->size; i++) {\n        if (strcmp(map->vehicles[i].registrationNumber, registrationNumber) == 0) {\n            return map->vehicles[i].ownerName;\n        }\n    }\n    return NULL;\n}\n\nint main() {\n    VehicleMap map;\n    map.size = 0;\n\n    addVehicle(&map, \"ABC123\", \"John Doe\");\n    addVehicle(&map, \"XYZ456\", \"Jane Smith\");\n\n    const char *owner = getOwnerName(&map, \"ABC123\");\n    if (owner) {\n        printf(\"Owner of ABC123: %s\\n\", owner);\n    } else {\n        printf(\"Vehicle not found.\\n\");\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a dictionary that maps sports teams to their win-loss records, and find the team with the best record.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    char name[50];\n    int wins;\n    int losses;\n} TeamRecord;\n\nint main() {\n    TeamRecord records[] = {\n        {\"Team A\", 10, 2},\n        {\"Team B\", 8, 4},\n        {\"Team C\", 12, 1},\n        {\"Team D\", 6, 6}\n    };\n\n    int numTeams = sizeof(records) / sizeof(records[0]);\n    TeamRecord *bestTeam = &records[0];\n    float bestWinLossRatio = (float)records[0].wins / (records[0].wins + records[0].losses);\n\n    for (int i = 1; i < numTeams; ++i) {\n        float currentWinLossRatio = (float)records[i].wins / (records[i].wins + records[i].losses);\n        if (currentWinLossRatio > bestWinLossRatio) {\n            bestWinLossRatio = currentWinLossRatio;\n            bestTeam = &records[i];\n        }\n    }\n\n    printf(\"Team with the best record: %s (Wins: %d, Losses: %d)\\n\", bestTeam->name, bestTeam->wins, bestTeam->losses);\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that uses a map to convert currency codes to full currency names.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_CURRENCIES 5\n\ntypedef struct {\n    char code[4];\n    char name[50];\n} Currency;\n\nchar* getCurrencyName(const char* code) {\n    static Currency currencyMap[MAX_CURRENCIES] = {\n        {\"USD\", \"United States Dollar\"},\n        {\"EUR\", \"Euro\"},\n        {\"JPY\", \"Japanese Yen\"},\n        {\"GBP\", \"British Pound\"},\n        {\"AUD\", \"Australian Dollar\"}\n    };\n    \n    for (int i = 0; i < MAX_CURRENCIES; i++) {\n        if (strcmp(currencyMap[i].code, code) == 0) {\n            return currencyMap[i].name;\n        }\n    }\n    return \"Unknown Currency\";\n}\n\nint main() {\n    printf(\"USD: %s\\n\", getCurrencyName(\"USD\"));\n    printf(\"EUR: %s\\n\", getCurrencyName(\"EUR\"));\n    printf(\"INR: %s\\n\", getCurrencyName(\"INR\"));\n    return 0;\n}\n```"
  },
  {
    "task": "Build a dictionary to store student names and their attendance counts, and determine the student with the highest attendance.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_STUDENTS 100\n\ntypedef struct {\n    char name[50];\n    int attendance;\n} Student;\n\nint main() {\n    Student students[MAX_STUDENTS];\n    int n, maxIndex = 0;\n\n    printf(\"Enter the number of students: \");\n    scanf(\"%d\", &n);\n\n    for (int i = 0; i < n; i++) {\n        printf(\"Enter name and attendance count for student %d: \", i + 1);\n        scanf(\"%s %d\", students[i].name, &students[i].attendance);\n    }\n\n    for (int i = 1; i < n; i++) {\n        if (students[i].attendance > students[maxIndex].attendance) {\n            maxIndex = i;\n        }\n    }\n\n    printf(\"Student with highest attendance: %s with %d attendances\\n\", students[maxIndex].name, students[maxIndex].attendance);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a map to store the names of countries and their capitals, allowing lookups by country name.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_COUNTRIES 100\n#define MAX_NAME_LENGTH 50\n\ntypedef struct {\n    char country[MAX_NAME_LENGTH];\n    char capital[MAX_NAME_LENGTH];\n} CountryCapital;\n\ntypedef struct {\n    CountryCapital entries[MAX_COUNTRIES];\n    int size;\n} CountryCapitalMap;\n\nvoid initMap(CountryCapitalMap *map) {\n    map->size = 0;\n}\n\nvoid addEntry(CountryCapitalMap *map, const char *country, const char *capital) {\n    if (map->size < MAX_COUNTRIES) {\n        strncpy(map->entries[map->size].country, country, MAX_NAME_LENGTH);\n        strncpy(map->entries[map->size].capital, capital, MAX_NAME_LENGTH);\n        map->size++;\n    }\n}\n\nconst char* getCapital(CountryCapitalMap *map, const char *country) {\n    for (int i = 0; i < map->size; i++) {\n        if (strcmp(map->entries[i].country, country) == 0) {\n            return map->entries[i].capital;\n        }\n    }\n    return NULL;\n}\n\nint main() {\n    CountryCapitalMap map;\n    initMap(&map);\n\n    addEntry(&map, \"France\", \"Paris\");\n    addEntry(&map, \"Germany\", \"Berlin\");\n    addEntry(&map, \"Italy\", \"Rome\");\n\n    const char *capital = getCapital(&map, \"Germany\");\n    if (capital != NULL) {\n        printf(\"The capital of Germany is %s.\\n\", capital);\n    } else {\n        printf(\"Country not found.\\n\");\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a program that uses a dictionary to keep track of recipe ingredients and their quantities.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_INGREDIENTS 100\n#define MAX_NAME_LENGTH 50\n\ntypedef struct {\n    char name[MAX_NAME_LENGTH];\n    int quantity;\n} Ingredient;\n\ntypedef struct {\n    Ingredient ingredients[MAX_INGREDIENTS];\n    int count;\n} Dictionary;\n\nvoid addIngredient(Dictionary *dict, const char *name, int quantity) {\n    for (int i = 0; i < dict->count; i++) {\n        if (strcmp(dict->ingredients[i].name, name) == 0) {\n            dict->ingredients[i].quantity += quantity;\n            return;\n        }\n    }\n    if (dict->count < MAX_INGREDIENTS) {\n        strcpy(dict->ingredients[dict->count].name, name);\n        dict->ingredients[dict->count].quantity = quantity;\n        dict->count++;\n    }\n}\n\nvoid printIngredients(const Dictionary *dict) {\n    for (int i = 0; i < dict->count; i++) {\n        printf(\"%s: %d\\n\", dict->ingredients[i].name, dict->ingredients[i].quantity);\n    }\n}\n\nint main() {\n    Dictionary recipe = { .count = 0 };\n\n    addIngredient(&recipe, \"Flour\", 500);\n    addIngredient(&recipe, \"Sugar\", 200);\n    addIngredient(&recipe, \"Eggs\", 3);\n    addIngredient(&recipe, \"Milk\", 250);\n    addIngredient(&recipe, \"Flour\", 300);\n\n    printIngredients(&recipe);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Design a system that uses a map to associate social media usernames with user profiles.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_USERS 100\n#define USERNAME_LENGTH 30\n#define PROFILE_INFO_LENGTH 100\n\ntypedef struct {\n    char username[USERNAME_LENGTH];\n    char profileInfo[PROFILE_INFO_LENGTH];\n} UserProfile;\n\ntypedef struct {\n    UserProfile users[MAX_USERS];\n    int count;\n} UserMap;\n\nvoid addUser(UserMap* map, const char* username, const char* profileInfo) {\n    if (map->count < MAX_USERS) {\n        strcpy(map->users[map->count].username, username);\n        strcpy(map->users[map->count].profileInfo, profileInfo);\n        map->count++;\n    } else {\n        printf(\"User map is full.\\n\");\n    }\n}\n\nconst char* getProfile(UserMap* map, const char* username) {\n    for (int i = 0; i < map->count; i++) {\n        if (strcmp(map->users[i].username, username) == 0) {\n            return map->users[i].profileInfo;\n        }\n    }\n    return NULL;\n}\n\nint main() {\n    UserMap userMap;\n    userMap.count = 0;\n\n    addUser(&userMap, \"john_doe\", \"John Doe's profile description.\");\n    addUser(&userMap, \"jane_smith\", \"Jane Smith's profile info.\");\n\n    const char* profile = getProfile(&userMap, \"john_doe\");\n    if (profile) {\n        printf(\"Profile of john_doe: %s\\n\", profile);\n    } else {\n        printf(\"User not found.\\n\");\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that takes a dictionary of product categories and lists all products in a given category.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_PRODUCTS 100\n#define MAX_CATEGORY_NAME 50\n#define MAX_PRODUCT_NAME 50\n\ntypedef struct {\n    char category[MAX_CATEGORY_NAME];\n    char products[MAX_PRODUCTS][MAX_PRODUCT_NAME];\n    int product_count;\n} ProductCategory;\n\ntypedef struct {\n    ProductCategory categories[MAX_PRODUCTS];\n    int category_count;\n} ProductDictionary;\n\nvoid listProductsInCategory(ProductDictionary *dict, const char *category) {\n    for (int i = 0; i < dict->category_count; i++) {\n        if (strcmp(dict->categories[i].category, category) == 0) {\n            printf(\"Products in category '%s':\\n\", category);\n            for (int j = 0; j < dict->categories[i].product_count; j++) {\n                printf(\"%s\\n\", dict->categories[i].products[j]);\n            }\n            return;\n        }\n    }\n    printf(\"Category '%s' not found.\\n\", category);\n}\n\nint main() {\n    ProductDictionary dict;\n    dict.category_count = 2;\n    \n    strcpy(dict.categories[0].category, \"Electronics\");\n    dict.categories[0].product_count = 2;\n    strcpy(dict.categories[0].products[0], \"Smartphone\");\n    strcpy(dict.categories[0].products[1], \"Laptop\");\n    \n    strcpy(dict.categories[1].category, \"Books\");\n    dict.categories[1].product_count = 2;\n    strcpy(dict.categories[1].products[0], \"Fiction\");\n    strcpy(dict.categories[1].products[1], \"Non-Fiction\");\n    \n    listProductsInCategory(&dict, \"Electronics\");\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a dictionary to store shopping list items and their quantities, and implement a function to update quantities.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Define a structure for dictionary entries\ntypedef struct {\n    char item[50];\n    int quantity;\n} Entry;\n\n// Define a structure for the dictionary\ntypedef struct {\n    Entry *entries;\n    size_t size;\n    size_t capacity;\n} Dictionary;\n\n// Function to initialize the dictionary\nvoid initDictionary(Dictionary *dict, size_t capacity) {\n    dict->entries = (Entry *)malloc(sizeof(Entry) * capacity);\n    dict->size = 0;\n    dict->capacity = capacity;\n}\n\n// Function to free the dictionary\nvoid freeDictionary(Dictionary *dict) {\n    free(dict->entries);\n}\n\n// Function to find an entry in the dictionary\nint findEntry(Dictionary *dict, const char *item) {\n    for (size_t i = 0; i < dict->size; i++) {\n        if (strcmp(dict->entries[i].item, item) == 0) {\n            return i;\n        }\n    }\n    return -1;\n}\n\n// Function to update the quantity of an item\nvoid updateQuantity(Dictionary *dict, const char *item, int quantity) {\n    int index = findEntry(dict, item);\n    if (index != -1) {\n        dict->entries[index].quantity = quantity;\n    } else {\n        if (dict->size == dict->capacity) {\n            dict->capacity *= 2;\n            dict->entries = (Entry *)realloc(dict->entries, sizeof(Entry) * dict->capacity);\n        }\n        strcpy(dict->entries[dict->size].item, item);\n        dict->entries[dict->size].quantity = quantity;\n        dict->size++;\n    }\n}\n\n// Function to print the dictionary\nvoid printDictionary(Dictionary *dict) {\n    for (size_t i = 0; i < dict->size; i++) {\n        printf(\"%s: %d\\n\", dict->entries[i].item, dict->entries[i].quantity);\n    }\n}\n\nint main() {\n    Dictionary shoppingList;\n    initDictionary(&shoppingList, 2);\n\n    updateQuantity(&shoppingList, \"Apples\", 5);\n    updateQuantity(&shoppingList, \"Bananas\", 3);\n    updateQuantity(&shoppingList, \"Oranges\", 10);\n    updateQuantity(&shoppingList, \"Apples\", 10);\n\n    printDictionary(&shoppingList);\n\n    freeDictionary(&shoppingList);\n    return 0;\n}\n```"
  },
  {
    "task": "Build a program that uses a map to store historical events and their dates, and finds events that occurred in a given year.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\ntypedef struct {\n    char event[100];\n    char date[10];\n} HistoricalEvent;\n\ntypedef struct Node {\n    HistoricalEvent event;\n    struct Node* next;\n} Node;\n\ntypedef struct {\n    Node* head;\n} Map;\n\nvoid initMap(Map* map) {\n    map->head = NULL;\n}\n\nvoid addEvent(Map* map, const char* event, const char* date) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    strcpy(newNode->event.event, event);\n    strcpy(newNode->event.date, date);\n    newNode->next = map->head;\n    map->head = newNode;\n}\n\nvoid findEventsByYear(Map* map, const char* year) {\n    Node* current = map->head;\n    while (current != NULL) {\n        if (strstr(current->event.date, year) != NULL) {\n            printf(\"Event: %s, Date: %s\\n\", current->event.event, current->event.date);\n        }\n        current = current->next;\n    }\n}\n\nvoid freeMap(Map* map) {\n    Node* current = map->head;\n    Node* next;\n    while (current != NULL) {\n        next = current->next;\n        free(current);\n        current = next;\n    }\n    map->head = NULL;\n}\n\nint main() {\n    Map historicalEvents;\n    initMap(&historicalEvents);\n\n    addEvent(&historicalEvents, \"Moon Landing\", \"1969-07-20\");\n    addEvent(&historicalEvents, \"Fall of the Berlin Wall\", \"1989-11-09\");\n    addEvent(&historicalEvents, \"Y2K\", \"2000-01-01\");\n\n    printf(\"Events in 1989:\\n\");\n    findEventsByYear(&historicalEvents, \"1989\");\n\n    freeMap(&historicalEvents);\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a dictionary to manage user roles and permissions within an application.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_USERS 100\n#define MAX_ROLE_LENGTH 50\n#define MAX_PERMISSION_LENGTH 50\n\ntypedef struct {\n    char role[MAX_ROLE_LENGTH];\n    char permissions[MAX_USERS][MAX_PERMISSION_LENGTH];\n    int permission_count;\n} Role;\n\ntypedef struct {\n    char username[MAX_USERS];\n    char role[MAX_ROLE_LENGTH];\n} User;\n\nRole roles[MAX_USERS];\nUser users[MAX_USERS];\n\nint role_count = 0;\nint user_count = 0;\n\nvoid add_role(const char *role_name) {\n    strcpy(roles[role_count].role, role_name);\n    roles[role_count].permission_count = 0;\n    role_count++;\n}\n\nvoid add_permission_to_role(const char *role_name, const char *permission) {\n    for (int i = 0; i < role_count; i++) {\n        if (strcmp(roles[i].role, role_name) == 0) {\n            strcpy(roles[i].permissions[roles[i].permission_count], permission);\n            roles[i].permission_count++;\n            break;\n        }\n    }\n}\n\nvoid add_user(const char *username, const char *role_name) {\n    strcpy(users[user_count].username, username);\n    strcpy(users[user_count].role, role_name);\n    user_count++;\n}\n\nvoid print_user_permissions(const char *username) {\n    for (int i = 0; i < user_count; i++) {\n        if (strcmp(users[i].username, username) == 0) {\n            for (int j = 0; j < role_count; j++) {\n                if (strcmp(users[i].role, roles[j].role) == 0) {\n                    printf(\"Permissions for user %s: \", username);\n                    for (int k = 0; k < roles[j].permission_count; k++) {\n                        printf(\"%s \", roles[j].permissions[k]);\n                    }\n                    printf(\"\\n\");\n                    return;\n                }\n            }\n        }\n    }\n    printf(\"User %s not found.\\n\", username);\n}\n\nint main() {\n    add_role(\"admin\");\n    add_role(\"editor\");\n    add_permission_to_role(\"admin\", \"read\");\n    add_permission_to_role(\"admin\", \"write\");\n    add_permission_to_role(\"editor\", \"read\");\n    \n    add_user(\"alice\", \"admin\");\n    add_user(\"bob\", \"editor\");\n    \n    print_user_permissions(\"alice\");\n    print_user_permissions(\"bob\");\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Write a script that uses a map to convert numeric grades to letter grades.",
    "code": "```c\n#include <stdio.h>\n\nchar getLetterGrade(int grade) {\n    // Map numeric grades to letter grades\n    if (grade >= 90) return 'A';\n    else if (grade >= 80) return 'B';\n    else if (grade >= 70) return 'C';\n    else if (grade >= 60) return 'D';\n    else return 'F';\n}\n\nint main() {\n    int numericGrades[] = {95, 82, 67, 54, 79};\n    int size = sizeof(numericGrades) / sizeof(numericGrades[0]);\n    char letterGrades[size];\n\n    for (int i = 0; i < size; i++) {\n        letterGrades[i] = getLetterGrade(numericGrades[i]);\n    }\n\n    for (int i = 0; i < size; i++) {\n        printf(\"Numeric Grade: %d, Letter Grade: %c\\n\", numericGrades[i], letterGrades[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a dictionary that maps holiday names to their corresponding dates, and allows lookup by holiday name.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_HOLIDAYS 10\n#define NAME_LENGTH 50\n#define DATE_LENGTH 20\n\ntypedef struct {\n    char name[NAME_LENGTH];\n    char date[DATE_LENGTH];\n} Holiday;\n\ntypedef struct {\n    Holiday holidays[MAX_HOLIDAYS];\n    int count;\n} HolidayMap;\n\nvoid addHoliday(HolidayMap *map, const char *name, const char *date) {\n    if (map->count < MAX_HOLIDAYS) {\n        strncpy(map->holidays[map->count].name, name, NAME_LENGTH);\n        strncpy(map->holidays[map->count].date, date, DATE_LENGTH);\n        map->count++;\n    }\n}\n\nconst char* lookupHoliday(const HolidayMap *map, const char *name) {\n    for (int i = 0; i < map->count; i++) {\n        if (strcmp(map->holidays[i].name, name) == 0) {\n            return map->holidays[i].date;\n        }\n    }\n    return NULL;\n}\n\nint main() {\n    HolidayMap holidayMap = { .count = 0 };\n    addHoliday(&holidayMap, \"New Year\", \"2024-01-01\");\n    addHoliday(&holidayMap, \"Christmas\", \"2023-12-25\");\n    \n    const char *date = lookupHoliday(&holidayMap, \"Christmas\");\n    if (date) {\n        printf(\"Christmas is on %s\\n\", date);\n    } else {\n        printf(\"Holiday not found.\\n\");\n    }\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Design a system that uses a map to track the status of online orders, allowing updates to order status.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct Order {\n    char orderID[50];\n    char status[50];\n    struct Order* next;\n} Order;\n\ntypedef struct {\n    Order* head;\n} OrderMap;\n\nOrderMap* createOrderMap() {\n    OrderMap* map = (OrderMap*)malloc(sizeof(OrderMap));\n    map->head = NULL;\n    return map;\n}\n\nvoid updateOrderStatus(OrderMap* map, const char* orderID, const char* status) {\n    Order* current = map->head;\n    while (current != NULL) {\n        if (strcmp(current->orderID, orderID) == 0) {\n            strcpy(current->status, status);\n            return;\n        }\n        current = current->next;\n    }\n\n    Order* newOrder = (Order*)malloc(sizeof(Order));\n    strcpy(newOrder->orderID, orderID);\n    strcpy(newOrder->status, status);\n    newOrder->next = map->head;\n    map->head = newOrder;\n}\n\nconst char* getOrderStatus(OrderMap* map, const char* orderID) {\n    Order* current = map->head;\n    while (current != NULL) {\n        if (strcmp(current->orderID, orderID) == 0) {\n            return current->status;\n        }\n        current = current->next;\n    }\n    return \"Order not found\";\n}\n\nvoid freeOrderMap(OrderMap* map) {\n    Order* current = map->head;\n    while (current != NULL) {\n        Order* toFree = current;\n        current = current->next;\n        free(toFree);\n    }\n    free(map);\n}\n\nint main() {\n    OrderMap* orderMap = createOrderMap();\n\n    updateOrderStatus(orderMap, \"123\", \"Pending\");\n    updateOrderStatus(orderMap, \"456\", \"Shipped\");\n\n    printf(\"Order 123 status: %s\\n\", getOrderStatus(orderMap, \"123\"));\n    printf(\"Order 456 status: %s\\n\", getOrderStatus(orderMap, \"456\"));\n\n    updateOrderStatus(orderMap, \"123\", \"Delivered\");\n\n    printf(\"Order 123 status: %s\\n\", getOrderStatus(orderMap, \"123\"));\n\n    freeOrderMap(orderMap);\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a program that uses a dictionary to associate food items with their nutritional information.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_ITEMS 10\n#define MAX_NAME_LENGTH 50\n\ntypedef struct {\n    char name[MAX_NAME_LENGTH];\n    int calories;\n    float protein;\n    float fat;\n    float carbohydrates;\n} NutritionalInfo;\n\ntypedef struct {\n    char key[MAX_NAME_LENGTH];\n    NutritionalInfo value;\n} DictionaryEntry;\n\ntypedef struct {\n    DictionaryEntry entries[MAX_ITEMS];\n    int size;\n} Dictionary;\n\nvoid addEntry(Dictionary *dict, const char *key, NutritionalInfo value) {\n    if (dict->size < MAX_ITEMS) {\n        strncpy(dict->entries[dict->size].key, key, MAX_NAME_LENGTH);\n        dict->entries[dict->size].value = value;\n        dict->size++;\n    }\n}\n\nNutritionalInfo *getEntry(Dictionary *dict, const char *key) {\n    for (int i = 0; i < dict->size; i++) {\n        if (strcmp(dict->entries[i].key, key) == 0) {\n            return &dict->entries[i].value;\n        }\n    }\n    return NULL;\n}\n\nint main() {\n    Dictionary foodDictionary = {0};\n\n    NutritionalInfo apple = {\"Apple\", 95, 0.5, 0.3, 25.0};\n    NutritionalInfo banana = {\"Banana\", 105, 1.3, 0.4, 27.0};\n\n    addEntry(&foodDictionary, \"Apple\", apple);\n    addEntry(&foodDictionary, \"Banana\", banana);\n\n    NutritionalInfo *info = getEntry(&foodDictionary, \"Apple\");\n    if (info != NULL) {\n        printf(\"Apple: %d calories, %.1f g protein, %.1f g fat, %.1f g carbohydrates\\n\",\n               info->calories, info->protein, info->fat, info->carbohydrates);\n    }\n\n    info = getEntry(&foodDictionary, \"Banana\");\n    if (info != NULL) {\n        printf(\"Banana: %d calories, %.1f g protein, %.1f g fat, %.1f g carbohydrates\\n\",\n               info->calories, info->protein, info->fat, info->carbohydrates);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a map to store book genres and lists of book titles, allowing retrieval of all books in a given genre.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct Node {\n    char *title;\n    struct Node *next;\n} Node;\n\ntypedef struct {\n    char *genre;\n    Node *books;\n} Genre;\n\ntypedef struct {\n    Genre *genres;\n    int size;\n} Map;\n\nNode* createNode(char *title) {\n    Node *newNode = (Node *)malloc(sizeof(Node));\n    newNode->title = strdup(title);\n    newNode->next = NULL;\n    return newNode;\n}\n\nvoid addBookToGenre(Genre *genre, char *title) {\n    Node *newBook = createNode(title);\n    newBook->next = genre->books;\n    genre->books = newBook;\n}\n\nMap* createMap() {\n    Map *map = (Map *)malloc(sizeof(Map));\n    map->genres = NULL;\n    map->size = 0;\n    return map;\n}\n\nvoid addGenre(Map *map, char *genre) {\n    map->genres = (Genre *)realloc(map->genres, (map->size + 1) * sizeof(Genre));\n    map->genres[map->size].genre = strdup(genre);\n    map->genres[map->size].books = NULL;\n    map->size++;\n}\n\nGenre* findGenre(Map *map, char *genre) {\n    for (int i = 0; i < map->size; i++) {\n        if (strcmp(map->genres[i].genre, genre) == 0) {\n            return &map->genres[i];\n        }\n    }\n    return NULL;\n}\n\nvoid addBook(Map *map, char *genre, char *title) {\n    Genre *g = findGenre(map, genre);\n    if (g == NULL) {\n        addGenre(map, genre);\n        g = &map->genres[map->size - 1];\n    }\n    addBookToGenre(g, title);\n}\n\nvoid printBooksInGenre(Map *map, char *genre) {\n    Genre *g = findGenre(map, genre);\n    if (g != NULL) {\n        Node *current = g->books;\n        while (current != NULL) {\n            printf(\"%s\\n\", current->title);\n            current = current->next;\n        }\n    } else {\n        printf(\"Genre not found.\\n\");\n    }\n}\n\nvoid freeMap(Map *map) {\n    for (int i = 0; i < map->size; i++) {\n        free(map->genres[i].genre);\n        Node *current = map->genres[i].books;\n        while (current != NULL) {\n            Node *next = current->next;\n            free(current->title);\n            free(current);\n            current = next;\n        }\n    }\n    free(map->genres);\n    free(map);\n}\n\nint main() {\n    Map *bookMap = createMap();\n    addBook(bookMap, \"Science Fiction\", \"Dune\");\n    addBook(bookMap, \"Science Fiction\", \"Neuromancer\");\n    addBook(bookMap, \"Fantasy\", \"The Hobbit\");\n    addBook(bookMap, \"Fantasy\", \"Harry Potter\");\n    \n    printf(\"Books in Science Fiction:\\n\");\n    printBooksInGenre(bookMap, \"Science Fiction\");\n    \n    printf(\"\\nBooks in Fantasy:\\n\");\n    printBooksInGenre(bookMap, \"Fantasy\");\n    \n    freeMap(bookMap);\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that uses a dictionary to convert state abbreviations to full state names.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    char abbreviation[3];\n    char name[50];\n} State;\n\nconst State states[] = {\n    {\"AL\", \"Alabama\"},\n    {\"AK\", \"Alaska\"},\n    {\"AZ\", \"Arizona\"},\n    {\"AR\", \"Arkansas\"},\n    {\"CA\", \"California\"},\n    {\"CO\", \"Colorado\"},\n    {\"CT\", \"Connecticut\"},\n    {\"DE\", \"Delaware\"},\n    {\"FL\", \"Florida\"},\n    {\"GA\", \"Georgia\"},\n    {\"HI\", \"Hawaii\"},\n    {\"ID\", \"Idaho\"},\n    {\"IL\", \"Illinois\"},\n    {\"IN\", \"Indiana\"},\n    {\"IA\", \"Iowa\"},\n    {\"KS\", \"Kansas\"},\n    {\"KY\", \"Kentucky\"},\n    {\"LA\", \"Louisiana\"},\n    {\"ME\", \"Maine\"},\n    {\"MD\", \"Maryland\"},\n    {\"MA\", \"Massachusetts\"},\n    {\"MI\", \"Michigan\"},\n    {\"MN\", \"Minnesota\"},\n    {\"MS\", \"Mississippi\"},\n    {\"MO\", \"Missouri\"},\n    {\"MT\", \"Montana\"},\n    {\"NE\", \"Nebraska\"},\n    {\"NV\", \"Nevada\"},\n    {\"NH\", \"New Hampshire\"},\n    {\"NJ\", \"New Jersey\"},\n    {\"NM\", \"New Mexico\"},\n    {\"NY\", \"New York\"},\n    {\"NC\", \"North Carolina\"},\n    {\"ND\", \"North Dakota\"},\n    {\"OH\", \"Ohio\"},\n    {\"OK\", \"Oklahoma\"},\n    {\"OR\", \"Oregon\"},\n    {\"PA\", \"Pennsylvania\"},\n    {\"RI\", \"Rhode Island\"},\n    {\"SC\", \"South Carolina\"},\n    {\"SD\", \"South Dakota\"},\n    {\"TN\", \"Tennessee\"},\n    {\"TX\", \"Texas\"},\n    {\"UT\", \"Utah\"},\n    {\"VT\", \"Vermont\"},\n    {\"VA\", \"Virginia\"},\n    {\"WA\", \"Washington\"},\n    {\"WV\", \"West Virginia\"},\n    {\"WI\", \"Wisconsin\"},\n    {\"WY\", \"Wyoming\"}\n};\n\nconst char* getStateName(const char* abbreviation) {\n    int numStates = sizeof(states) / sizeof(states[0]);\n    for (int i = 0; i < numStates; i++) {\n        if (strcmp(states[i].abbreviation, abbreviation) == 0) {\n            return states[i].name;\n        }\n    }\n    return \"Unknown\";\n}\n\nint main() {\n    const char* abbreviation = \"CA\";\n    printf(\"The full name of the state with abbreviation %s is %s.\\n\", abbreviation, getStateName(abbreviation));\n    return 0;\n}\n```"
  },
  {
    "task": "Build a dictionary to store customer names and their order histories.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_CUSTOMERS 100\n#define MAX_ORDERS 10\n#define NAME_LENGTH 50\n#define ORDER_LENGTH 100\n\ntypedef struct {\n    char orders[MAX_ORDERS][ORDER_LENGTH];\n    int order_count;\n} OrderHistory;\n\ntypedef struct {\n    char name[NAME_LENGTH];\n    OrderHistory order_history;\n} Customer;\n\ntypedef struct {\n    Customer customers[MAX_CUSTOMERS];\n    int customer_count;\n} CustomerDictionary;\n\nvoid add_customer(CustomerDictionary *dict, const char *name) {\n    if (dict->customer_count < MAX_CUSTOMERS) {\n        strcpy(dict->customers[dict->customer_count].name, name);\n        dict->customers[dict->customer_count].order_history.order_count = 0;\n        dict->customer_count++;\n    }\n}\n\nvoid add_order(CustomerDictionary *dict, const char *name, const char *order) {\n    for (int i = 0; i < dict->customer_count; i++) {\n        if (strcmp(dict->customers[i].name, name) == 0) {\n            OrderHistory *history = &dict->customers[i].order_history;\n            if (history->order_count < MAX_ORDERS) {\n                strcpy(history->orders[history->order_count], order);\n                history->order_count++;\n            }\n            return;\n        }\n    }\n}\n\nvoid print_customer_orders(const CustomerDictionary *dict, const char *name) {\n    for (int i = 0; i < dict->customer_count; i++) {\n        if (strcmp(dict->customers[i].name, name) == 0) {\n            printf(\"Order history for %s:\\n\", name);\n            for (int j = 0; j < dict->customers[i].order_history.order_count; j++) {\n                printf(\"- %s\\n\", dict->customers[i].order_history.orders[j]);\n            }\n            return;\n        }\n    }\n    printf(\"Customer %s not found.\\n\", name);\n}\n\nint main() {\n    CustomerDictionary dict = { .customer_count = 0 };\n\n    add_customer(&dict, \"Alice\");\n    add_order(&dict, \"Alice\", \"Order 1: Widget\");\n    add_order(&dict, \"Alice\", \"Order 2: Gadget\");\n\n    add_customer(&dict, \"Bob\");\n    add_order(&dict, \"Bob\", \"Order 1: Thingamajig\");\n\n    print_customer_orders(&dict, \"Alice\");\n    print_customer_orders(&dict, \"Bob\");\n\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a map to manage parking lot spaces, tracking which spaces are occupied.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_SPACES 100\n\ntypedef struct {\n    char license_plate[8];\n    int occupied;\n} ParkingSpace;\n\ntypedef struct {\n    ParkingSpace spaces[MAX_SPACES];\n    int count;\n} ParkingLot;\n\nvoid initialize_parking_lot(ParkingLot *lot) {\n    lot->count = 0;\n    for (int i = 0; i < MAX_SPACES; i++) {\n        lot->spaces[i].occupied = 0;\n    }\n}\n\nint park_car(ParkingLot *lot, const char *license_plate) {\n    if (lot->count >= MAX_SPACES) {\n        return -1;\n    }\n    for (int i = 0; i < MAX_SPACES; i++) {\n        if (!lot->spaces[i].occupied) {\n            strcpy(lot->spaces[i].license_plate, license_plate);\n            lot->spaces[i].occupied = 1;\n            lot->count++;\n            return i;\n        }\n    }\n    return -1;\n}\n\nint leave_space(ParkingLot *lot, int space_number) {\n    if (space_number < 0 || space_number >= MAX_SPACES || !lot->spaces[space_number].occupied) {\n        return 0;\n    }\n    lot->spaces[space_number].occupied = 0;\n    lot->count--;\n    return 1;\n}\n\nvoid print_parking_lot(ParkingLot *lot) {\n    printf(\"Parking Lot Status:\\n\");\n    for (int i = 0; i < MAX_SPACES; i++) {\n        if (lot->spaces[i].occupied) {\n            printf(\"Space %d: Occupied by %s\\n\", i, lot->spaces[i].license_plate);\n        } else {\n            printf(\"Space %d: Empty\\n\", i);\n        }\n    }\n}\n\nint main() {\n    ParkingLot lot;\n    initialize_parking_lot(&lot);\n    park_car(&lot, \"ABC123\");\n    park_car(&lot, \"XYZ789\");\n    print_parking_lot(&lot);\n    leave_space(&lot, 0);\n    print_parking_lot(&lot);\n    return 0;\n}\n```"
  },
  {
    "task": "Create a program that uses a dictionary to track the scores of players in a game.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_PLAYERS 100\n#define MAX_NAME_LENGTH 50\n\ntypedef struct {\n    char name[MAX_NAME_LENGTH];\n    int score;\n} Player;\n\ntypedef struct {\n    Player players[MAX_PLAYERS];\n    int size;\n} Dictionary;\n\nvoid initDictionary(Dictionary* dict) {\n    dict->size = 0;\n}\n\nint findPlayerIndex(Dictionary* dict, const char* name) {\n    for (int i = 0; i < dict->size; ++i) {\n        if (strcmp(dict->players[i].name, name) == 0) {\n            return i;\n        }\n    }\n    return -1;\n}\n\nvoid addOrUpdatePlayer(Dictionary* dict, const char* name, int score) {\n    int index = findPlayerIndex(dict, name);\n    if (index != -1) {\n        dict->players[index].score = score;\n    } else {\n        if (dict->size < MAX_PLAYERS) {\n            strcpy(dict->players[dict->size].name, name);\n            dict->players[dict->size].score = score;\n            dict->size++;\n        } else {\n            printf(\"Dictionary is full, cannot add more players.\\n\");\n        }\n    }\n}\n\nint getPlayerScore(Dictionary* dict, const char* name) {\n    int index = findPlayerIndex(dict, name);\n    if (index != -1) {\n        return dict->players[index].score;\n    }\n    printf(\"Player not found.\\n\");\n    return -1;\n}\n\nvoid printScores(Dictionary* dict) {\n    for (int i = 0; i < dict->size; ++i) {\n        printf(\"Player: %s, Score: %d\\n\", dict->players[i].name, dict->players[i].score);\n    }\n}\n\nint main() {\n    Dictionary dict;\n    initDictionary(&dict);\n\n    addOrUpdatePlayer(&dict, \"Alice\", 10);\n    addOrUpdatePlayer(&dict, \"Bob\", 20);\n    addOrUpdatePlayer(&dict, \"Charlie\", 30);\n\n    printf(\"Score of Alice: %d\\n\", getPlayerScore(&dict, \"Alice\"));\n\n    printScores(&dict);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Design a dictionary to store scientific terms and their definitions, allowing users to look up definitions.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    char *term;\n    char *definition;\n} DictionaryEntry;\n\ntypedef struct {\n    DictionaryEntry *entries;\n    size_t size;\n    size_t capacity;\n} Dictionary;\n\nvoid initDictionary(Dictionary *dict, size_t capacity) {\n    dict->entries = malloc(capacity * sizeof(DictionaryEntry));\n    dict->size = 0;\n    dict->capacity = capacity;\n}\n\nvoid addTerm(Dictionary *dict, const char *term, const char *definition) {\n    if (dict->size == dict->capacity) {\n        dict->capacity *= 2;\n        dict->entries = realloc(dict->entries, dict->capacity * sizeof(DictionaryEntry));\n    }\n    dict->entries[dict->size].term = strdup(term);\n    dict->entries[dict->size].definition = strdup(definition);\n    dict->size++;\n}\n\nconst char* lookupDefinition(Dictionary *dict, const char *term) {\n    for (size_t i = 0; i < dict->size; i++) {\n        if (strcmp(dict->entries[i].term, term) == 0) {\n            return dict->entries[i].definition;\n        }\n    }\n    return NULL;\n}\n\nvoid freeDictionary(Dictionary *dict) {\n    for (size_t i = 0; i < dict->size; i++) {\n        free(dict->entries[i].term);\n        free(dict->entries[i].definition);\n    }\n    free(dict->entries);\n}\n\nint main() {\n    Dictionary dict;\n    initDictionary(&dict, 2);\n\n    addTerm(&dict, \"Photosynthesis\", \"Process used by plants to convert light energy into chemical energy.\");\n    addTerm(&dict, \"Evolution\", \"Change in the heritable traits of biological populations over successive generations.\");\n\n    const char *definition = lookupDefinition(&dict, \"Photosynthesis\");\n    if (definition) {\n        printf(\"Definition of Photosynthesis: %s\\n\", definition);\n    } else {\n        printf(\"Term not found.\\n\");\n    }\n\n    freeDictionary(&dict);\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that uses a map to convert temperature scales (e.g., Celsius to Fahrenheit).",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    char scale[20];\n    double (*convert)(double);\n} TemperatureMap;\n\ndouble celsiusToFahrenheit(double celsius) {\n    return celsius * 9.0 / 5.0 + 32;\n}\n\ndouble fahrenheitToCelsius(double fahrenheit) {\n    return (fahrenheit - 32) * 5.0 / 9.0;\n}\n\ndouble convertTemperature(const char *fromScale, const char *toScale, double value) {\n    TemperatureMap map[] = {\n        {\"CelsiusToFahrenheit\", celsiusToFahrenheit},\n        {\"FahrenheitToCelsius\", fahrenheitToCelsius}\n    };\n    \n    char key[40];\n    snprintf(key, sizeof(key), \"%sTo%s\", fromScale, toScale);\n\n    for (int i = 0; i < sizeof(map) / sizeof(TemperatureMap); i++) {\n        if (strcmp(map[i].scale, key) == 0) {\n            return map[i].convert(value);\n        }\n    }\n    \n    return value; // return the original value if conversion is not found\n}\n\nint main() {\n    double celsius = 30.0;\n    double fahrenheit = convertTemperature(\"Celsius\", \"Fahrenheit\", celsius);\n    printf(\"%.2f Celsius is %.2f Fahrenheit\\n\", celsius, fahrenheit);\n\n    fahrenheit = 86.0;\n    celsius = convertTemperature(\"Fahrenheit\", \"Celsius\", fahrenheit);\n    printf(\"%.2f Fahrenheit is %.2f Celsius\\n\", fahrenheit, celsius);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a dictionary to store employee names and their respective departments.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_EMPLOYEES 100\n#define NAME_LENGTH 50\n#define DEPT_LENGTH 50\n\ntypedef struct {\n    char name[NAME_LENGTH];\n    char department[DEPT_LENGTH];\n} Employee;\n\ntypedef struct {\n    Employee employees[MAX_EMPLOYEES];\n    int size;\n} EmployeeMap;\n\nvoid addEmployee(EmployeeMap *map, const char *name, const char *department) {\n    if (map->size < MAX_EMPLOYEES) {\n        strcpy(map->employees[map->size].name, name);\n        strcpy(map->employees[map->size].department, department);\n        map->size++;\n    }\n}\n\nconst char* getDepartment(EmployeeMap *map, const char *name) {\n    for (int i = 0; i < map->size; i++) {\n        if (strcmp(map->employees[i].name, name) == 0) {\n            return map->employees[i].department;\n        }\n    }\n    return NULL;\n}\n\nint main() {\n    EmployeeMap map;\n    map.size = 0;\n\n    addEmployee(&map, \"Alice\", \"HR\");\n    addEmployee(&map, \"Bob\", \"Engineering\");\n\n    printf(\"Alice works in %s department.\\n\", getDepartment(&map, \"Alice\"));\n    printf(\"Bob works in %s department.\\n\", getDepartment(&map, \"Bob\"));\n\n    return 0;\n}\n```"
  },
  {
    "task": "Build a program that uses a map to store tourist attractions and their locations.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_ATTRACTIONS 10\n#define MAX_NAME_LENGTH 50\n\ntypedef struct {\n    char name[MAX_NAME_LENGTH];\n    char location[MAX_NAME_LENGTH];\n} Attraction;\n\ntypedef struct {\n    Attraction attractions[MAX_ATTRACTIONS];\n    int size;\n} AttractionMap;\n\nvoid addAttraction(AttractionMap *map, const char *name, const char *location) {\n    if (map->size < MAX_ATTRACTIONS) {\n        strncpy(map->attractions[map->size].name, name, MAX_NAME_LENGTH - 1);\n        strncpy(map->attractions[map->size].location, location, MAX_NAME_LENGTH - 1);\n        map->size++;\n    } else {\n        printf(\"Max attractions reached.\\n\");\n    }\n}\n\nvoid printAttractions(const AttractionMap *map) {\n    for (int i = 0; i < map->size; i++) {\n        printf(\"Attraction: %s, Location: %s\\n\", map->attractions[i].name, map->attractions[i].location);\n    }\n}\n\nint main() {\n    AttractionMap attractionMap = { .size = 0 };\n\n    addAttraction(&attractionMap, \"Eiffel Tower\", \"Paris\");\n    addAttraction(&attractionMap, \"Statue of Liberty\", \"New York\");\n    addAttraction(&attractionMap, \"Colosseum\", \"Rome\");\n\n    printAttractions(&attractionMap);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a dictionary to manage a collection of music albums, allowing additions and removals.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct Album {\n    char title[50];\n    char artist[50];\n    int year;\n} Album;\n\ntypedef struct Node {\n    Album album;\n    struct Node* next;\n} Node;\n\ntypedef struct Dictionary {\n    Node* head;\n} Dictionary;\n\nDictionary* createDictionary() {\n    Dictionary* dict = (Dictionary*)malloc(sizeof(Dictionary));\n    dict->head = NULL;\n    return dict;\n}\n\nvoid addAlbum(Dictionary* dict, char* title, char* artist, int year) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    strcpy(newNode->album.title, title);\n    strcpy(newNode->album.artist, artist);\n    newNode->album.year = year;\n    newNode->next = dict->head;\n    dict->head = newNode;\n}\n\nvoid removeAlbum(Dictionary* dict, char* title) {\n    Node* temp = dict->head;\n    Node* prev = NULL;\n\n    while (temp != NULL && strcmp(temp->album.title, title) != 0) {\n        prev = temp;\n        temp = temp->next;\n    }\n\n    if (temp == NULL) return;\n\n    if (prev == NULL) {\n        dict->head = temp->next;\n    } else {\n        prev->next = temp->next;\n    }\n\n    free(temp);\n}\n\nvoid printAlbums(Dictionary* dict) {\n    Node* current = dict->head;\n    while (current != NULL) {\n        printf(\"Title: %s, Artist: %s, Year: %d\\n\", current->album.title, current->album.artist, current->album.year);\n        current = current->next;\n    }\n}\n\nvoid freeDictionary(Dictionary* dict) {\n    Node* current = dict->head;\n    while (current != NULL) {\n        Node* next = current->next;\n        free(current);\n        current = next;\n    }\n    free(dict);\n}\n\nint main() {\n    Dictionary* myAlbums = createDictionary();\n    addAlbum(myAlbums, \"Album1\", \"Artist1\", 1999);\n    addAlbum(myAlbums, \"Album2\", \"Artist2\", 2005);\n\n    printf(\"Albums in collection:\\n\");\n    printAlbums(myAlbums);\n\n    removeAlbum(myAlbums, \"Album1\");\n    printf(\"\\nAfter removal:\\n\");\n    printAlbums(myAlbums);\n\n    freeDictionary(myAlbums);\n    return 0;\n}\n```"
  },
  {
    "task": "Write a script that uses a map to track the inventory of a small retail store.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_ITEMS 100\n#define MAX_NAME_LENGTH 50\n\ntypedef struct {\n    char name[MAX_NAME_LENGTH];\n    int quantity;\n} InventoryItem;\n\ntypedef struct {\n    InventoryItem items[MAX_ITEMS];\n    int count;\n} Inventory;\n\nvoid initializeInventory(Inventory* inventory) {\n    inventory->count = 0;\n}\n\nvoid addItem(Inventory* inventory, const char* name, int quantity) {\n    for (int i = 0; i < inventory->count; i++) {\n        if (strcmp(inventory->items[i].name, name) == 0) {\n            inventory->items[i].quantity += quantity;\n            return;\n        }\n    }\n    if (inventory->count < MAX_ITEMS) {\n        strncpy(inventory->items[inventory->count].name, name, MAX_NAME_LENGTH);\n        inventory->items[inventory->count].quantity = quantity;\n        inventory->count++;\n    }\n}\n\nvoid removeItem(Inventory* inventory, const char* name, int quantity) {\n    for (int i = 0; i < inventory->count; i++) {\n        if (strcmp(inventory->items[i].name, name) == 0) {\n            if (inventory->items[i].quantity >= quantity) {\n                inventory->items[i].quantity -= quantity;\n                if (inventory->items[i].quantity == 0) {\n                    for (int j = i; j < inventory->count - 1; j++) {\n                        inventory->items[j] = inventory->items[j + 1];\n                    }\n                    inventory->count--;\n                }\n            }\n            return;\n        }\n    }\n}\n\nvoid displayInventory(const Inventory* inventory) {\n    for (int i = 0; i < inventory->count; i++) {\n        printf(\"Item: %s, Quantity: %d\\n\", inventory->items[i].name, inventory->items[i].quantity);\n    }\n}\n\nint main() {\n    Inventory storeInventory;\n    initializeInventory(&storeInventory);\n\n    addItem(&storeInventory, \"Apples\", 50);\n    addItem(&storeInventory, \"Bananas\", 30);\n    addItem(&storeInventory, \"Oranges\", 20);\n    \n    printf(\"Current Inventory:\\n\");\n    displayInventory(&storeInventory);\n\n    removeItem(&storeInventory, \"Bananas\", 10);\n    \n    printf(\"\\nInventory after removing 10 Bananas:\\n\");\n    displayInventory(&storeInventory);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a dictionary to store the names of rivers and their lengths, allowing length lookups by river name.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_RIVERS 100\n#define NAME_LENGTH 50\n\ntypedef struct {\n    char name[NAME_LENGTH];\n    int length;\n} River;\n\ntypedef struct {\n    River rivers[MAX_RIVERS];\n    int count;\n} RiverDictionary;\n\nvoid initializeDictionary(RiverDictionary *dict) {\n    dict->count = 0;\n}\n\nvoid addRiver(RiverDictionary *dict, const char *name, int length) {\n    if (dict->count < MAX_RIVERS) {\n        strcpy(dict->rivers[dict->count].name, name);\n        dict->rivers[dict->count].length = length;\n        dict->count++;\n    }\n}\n\nint getRiverLength(RiverDictionary *dict, const char *name) {\n    for (int i = 0; i < dict->count; i++) {\n        if (strcmp(dict->rivers[i].name, name) == 0) {\n            return dict->rivers[i].length;\n        }\n    }\n    return -1; // Indicates river not found\n}\n\nint main() {\n    RiverDictionary dict;\n    initializeDictionary(&dict);\n\n    addRiver(&dict, \"Amazon\", 6400);\n    addRiver(&dict, \"Nile\", 6650);\n    addRiver(&dict, \"Yangtze\", 6300);\n\n    printf(\"Length of Nile: %d km\\n\", getRiverLength(&dict, \"Nile\"));\n    printf(\"Length of Amazon: %d km\\n\", getRiverLength(&dict, \"Amazon\"));\n    printf(\"Length of Mississippi: %d km\\n\", getRiverLength(&dict, \"Mississippi\"));\n\n    return 0;\n}\n```"
  },
  {
    "task": "Design a system that uses a map to track the availability of conference rooms in an office building.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    char name[50];\n    int isAvailable;\n} ConferenceRoom;\n\ntypedef struct {\n    ConferenceRoom *rooms;\n    size_t size;\n} ConferenceRoomMap;\n\nConferenceRoomMap *createMap(size_t size) {\n    ConferenceRoomMap *map = malloc(sizeof(ConferenceRoomMap));\n    map->rooms = malloc(size * sizeof(ConferenceRoom));\n    map->size = size;\n    return map;\n}\n\nvoid setRoom(ConferenceRoomMap *map, const char *name, int isAvailable) {\n    for (size_t i = 0; i < map->size; i++) {\n        if (strcmp(map->rooms[i].name, name) == 0) {\n            map->rooms[i].isAvailable = isAvailable;\n            return;\n        }\n        if (map->rooms[i].name[0] == '\\0') {\n            strcpy(map->rooms[i].name, name);\n            map->rooms[i].isAvailable = isAvailable;\n            return;\n        }\n    }\n}\n\nint getRoomAvailability(ConferenceRoomMap *map, const char *name) {\n    for (size_t i = 0; i < map->size; i++) {\n        if (strcmp(map->rooms[i].name, name) == 0) {\n            return map->rooms[i].isAvailable;\n        }\n    }\n    return -1; // Room not found\n}\n\nvoid freeMap(ConferenceRoomMap *map) {\n    free(map->rooms);\n    free(map);\n}\n\nint main() {\n    ConferenceRoomMap *map = createMap(10);\n\n    setRoom(map, \"Room A\", 1);\n    setRoom(map, \"Room B\", 0);\n    setRoom(map, \"Room C\", 1);\n\n    printf(\"Room A availability: %d\\n\", getRoomAvailability(map, \"Room A\"));\n    printf(\"Room B availability: %d\\n\", getRoomAvailability(map, \"Room B\"));\n    printf(\"Room C availability: %d\\n\", getRoomAvailability(map, \"Room C\"));\n\n    freeMap(map);\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a program that uses a dictionary to associate animal species with their habitats.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_SPECIES 10\n#define MAX_NAME_LENGTH 50\n\ntypedef struct {\n    char species[MAX_NAME_LENGTH];\n    char habitat[MAX_NAME_LENGTH];\n} Animal;\n\ntypedef struct {\n    Animal animals[MAX_SPECIES];\n    int count;\n} AnimalDictionary;\n\nvoid addAnimal(AnimalDictionary *dict, const char *species, const char *habitat) {\n    if (dict->count < MAX_SPECIES) {\n        strcpy(dict->animals[dict->count].species, species);\n        strcpy(dict->animals[dict->count].habitat, habitat);\n        dict->count++;\n    }\n}\n\nconst char *getHabitat(const AnimalDictionary *dict, const char *species) {\n    for (int i = 0; i < dict->count; i++) {\n        if (strcmp(dict->animals[i].species, species) == 0) {\n            return dict->animals[i].habitat;\n        }\n    }\n    return \"Unknown\";\n}\n\nint main() {\n    AnimalDictionary dict = {.count = 0};\n\n    addAnimal(&dict, \"Lion\", \"Savannah\");\n    addAnimal(&dict, \"Polar Bear\", \"Arctic\");\n    addAnimal(&dict, \"Penguin\", \"Antarctica\");\n\n    printf(\"The habitat of the Lion is: %s\\n\", getHabitat(&dict, \"Lion\"));\n    printf(\"The habitat of the Polar Bear is: %s\\n\", getHabitat(&dict, \"Polar Bear\"));\n    printf(\"The habitat of the Penguin is: %s\\n\", getHabitat(&dict, \"Penguin\"));\n    printf(\"The habitat of the Tiger is: %s\\n\", getHabitat(&dict, \"Tiger\"));\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a map to store the names of mountains and their elevations, then find the tallest mountain.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_MOUNTAINS 100\n\ntypedef struct {\n    char name[50];\n    int elevation;\n} Mountain;\n\nint main() {\n    Mountain mountains[MAX_MOUNTAINS];\n    int mountainCount = 0;\n\n    // Example mountains\n    strcpy(mountains[mountainCount].name, \"Everest\");\n    mountains[mountainCount++].elevation = 8848;\n\n    strcpy(mountains[mountainCount].name, \"K2\");\n    mountains[mountainCount++].elevation = 8611;\n\n    strcpy(mountains[mountainCount].name, \"Kangchenjunga\");\n    mountains[mountainCount++].elevation = 8586;\n\n    int tallestIndex = 0;\n    for (int i = 1; i < mountainCount; i++) {\n        if (mountains[i].elevation > mountains[tallestIndex].elevation) {\n            tallestIndex = i;\n        }\n    }\n\n    printf(\"The tallest mountain is %s with an elevation of %d meters.\\n\", mountains[tallestIndex].name, mountains[tallestIndex].elevation);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that uses a dictionary to convert time zones to their respective UTC offsets.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_TIMEZONE_LENGTH 32\n\ntypedef struct {\n    char timezone[MAX_TIMEZONE_LENGTH];\n    int utcOffset;\n} TimeZoneMap;\n\nint getUTCOffset(const char *timezone) {\n    TimeZoneMap timeZones[] = {\n        {\"PST\", -8},\n        {\"MST\", -7},\n        {\"CST\", -6},\n        {\"EST\", -5},\n        {\"UTC\", 0},\n        {\"GMT\", 0},\n        {\"CET\", 1},\n        {\"EET\", 2},\n        {\"IST\", 5},\n        {\"CST\", 8}, // China Standard Time\n        {\"JST\", 9},\n        {\"AEST\", 10}\n    };\n    \n    int numTimeZones = sizeof(timeZones) / sizeof(TimeZoneMap);\n\n    for (int i = 0; i < numTimeZones; i++) {\n        if (strcmp(timeZones[i].timezone, timezone) == 0) {\n            return timeZones[i].utcOffset;\n        }\n    }\n\n    // Return some default or error value if timezone not found\n    return -99; // For example, -99 indicates not found\n}\n\nint main() {\n    printf(\"UTC Offset for PST: %d\\n\", getUTCOffset(\"PST\"));\n    printf(\"UTC Offset for IST: %d\\n\", getUTCOffset(\"IST\"));\n    printf(\"UTC Offset for CET: %d\\n\", getUTCOffset(\"CET\"));\n    printf(\"UTC Offset for Unknown: %d\\n\", getUTCOffset(\"Unknown\"));\n    return 0;\n}\n```"
  },
  {
    "task": "Build a dictionary to store the names of programming languages and their creators.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_LANGUAGES 10\n#define MAX_NAME_LENGTH 50\n\ntypedef struct {\n    char language[MAX_NAME_LENGTH];\n    char creator[MAX_NAME_LENGTH];\n} LanguageCreatorPair;\n\nint main() {\n    LanguageCreatorPair dictionary[MAX_LANGUAGES];\n\n    strcpy(dictionary[0].language, \"Python\");\n    strcpy(dictionary[0].creator, \"Guido van Rossum\");\n\n    strcpy(dictionary[1].language, \"Java\");\n    strcpy(dictionary[1].creator, \"James Gosling\");\n\n    strcpy(dictionary[2].language, \"C\");\n    strcpy(dictionary[2].creator, \"Dennis Ritchie\");\n\n    strcpy(dictionary[3].language, \"C++\");\n    strcpy(dictionary[3].creator, \"Bjarne Stroustrup\");\n\n    strcpy(dictionary[4].language, \"JavaScript\");\n    strcpy(dictionary[4].creator, \"Brendan Eich\");\n\n    strcpy(dictionary[5].language, \"Ruby\");\n    strcpy(dictionary[5].creator, \"Yukihiro Matsumoto\");\n\n    strcpy(dictionary[6].language, \"PHP\");\n    strcpy(dictionary[6].creator, \"Rasmus Lerdorf\");\n\n    strcpy(dictionary[7].language, \"Swift\");\n    strcpy(dictionary[7].creator, \"Chris Lattner\");\n\n    strcpy(dictionary[8].language, \"Go\");\n    strcpy(dictionary[8].creator, \"Robert Griesemer, Rob Pike, Ken Thompson\");\n\n    strcpy(dictionary[9].language, \"Kotlin\");\n    strcpy(dictionary[9].creator, \"JetBrains\");\n\n    for (int i = 0; i < MAX_LANGUAGES; i++) {\n        printf(\"Language: %s, Creator: %s\\n\", dictionary[i].language, dictionary[i].creator);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a map to manage a list of subscribers to a newsletter, allowing subscriptions and cancellations.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_NAME_LENGTH 100\n#define MAX_SUBSCRIBERS 100\n\ntypedef struct {\n    char name[MAX_NAME_LENGTH];\n} Subscriber;\n\ntypedef struct {\n    Subscriber subscribers[MAX_SUBSCRIBERS];\n    int count;\n} SubscriberMap;\n\nvoid initMap(SubscriberMap *map) {\n    map->count = 0;\n}\n\nint findSubscriber(SubscriberMap *map, const char* name) {\n    for (int i = 0; i < map->count; i++) {\n        if (strcmp(map->subscribers[i].name, name) == 0) {\n            return i;\n        }\n    }\n    return -1;\n}\n\nvoid subscribe(SubscriberMap *map, const char* name) {\n    if (map->count >= MAX_SUBSCRIBERS) {\n        printf(\"Subscriber list is full.\\n\");\n        return;\n    }\n    if (findSubscriber(map, name) != -1) {\n        printf(\"%s is already subscribed.\\n\", name);\n        return;\n    }\n    strncpy(map->subscribers[map->count].name, name, MAX_NAME_LENGTH);\n    map->count++;\n    printf(\"%s has been subscribed.\\n\", name);\n}\n\nvoid cancelSubscription(SubscriberMap *map, const char* name) {\n    int index = findSubscriber(map, name);\n    if (index == -1) {\n        printf(\"%s is not subscribed.\\n\", name);\n        return;\n    }\n    map->subscribers[index] = map->subscribers[map->count - 1];\n    map->count--;\n    printf(\"%s has been unsubscribed.\\n\", name);\n}\n\nvoid listSubscribers(SubscriberMap *map) {\n    printf(\"Subscribers:\\n\");\n    for (int i = 0; i < map->count; i++) {\n        printf(\"- %s\\n\", map->subscribers[i].name);\n    }\n}\n\nint main() {\n    SubscriberMap map;\n    initMap(&map);\n\n    subscribe(&map, \"Alice\");\n    subscribe(&map, \"Bob\");\n    listSubscribers(&map);\n\n    cancelSubscription(&map, \"Alice\");\n    listSubscribers(&map);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a program that uses a dictionary to track the number of likes for social media posts.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_POSTS 100\n#define MAX_TITLE_LENGTH 50\n\ntypedef struct {\n    char title[MAX_TITLE_LENGTH];\n    int likes;\n} Post;\n\ntypedef struct {\n    Post posts[MAX_POSTS];\n    int count;\n} PostDictionary;\n\nvoid initializeDictionary(PostDictionary *dict) {\n    dict->count = 0;\n}\n\nint findPostIndex(PostDictionary *dict, const char *title) {\n    for (int i = 0; i < dict->count; i++) {\n        if (strcmp(dict->posts[i].title, title) == 0) {\n            return i;\n        }\n    }\n    return -1;\n}\n\nvoid addOrIncrementLike(PostDictionary *dict, const char *title) {\n    int index = findPostIndex(dict, title);\n    if (index != -1) {\n        dict->posts[index].likes++;\n    } else if (dict->count < MAX_POSTS) {\n        strncpy(dict->posts[dict->count].title, title, MAX_TITLE_LENGTH);\n        dict->posts[dict->count].title[MAX_TITLE_LENGTH - 1] = '\\0';\n        dict->posts[dict->count].likes = 1;\n        dict->count++;\n    }\n}\n\nvoid printLikes(PostDictionary *dict) {\n    for (int i = 0; i < dict->count; i++) {\n        printf(\"Post: %s, Likes: %d\\n\", dict->posts[i].title, dict->posts[i].likes);\n    }\n}\n\nint main() {\n    PostDictionary postDict;\n    initializeDictionary(&postDict);\n\n    addOrIncrementLike(&postDict, \"Post1\");\n    addOrIncrementLike(&postDict, \"Post2\");\n    addOrIncrementLike(&postDict, \"Post1\");\n\n    printLikes(&postDict);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Design a dictionary to store the names of elements and their atomic numbers, allowing lookups by element name.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_ELEMENTS 10\n\ntypedef struct {\n    char name[20];\n    int atomic_number;\n} Element;\n\nElement elements[MAX_ELEMENTS] = {\n    {\"Hydrogen\", 1},\n    {\"Helium\", 2},\n    {\"Lithium\", 3},\n    {\"Beryllium\", 4},\n    {\"Boron\", 5},\n    {\"Carbon\", 6},\n    {\"Nitrogen\", 7},\n    {\"Oxygen\", 8},\n    {\"Fluorine\", 9},\n    {\"Neon\", 10}\n};\n\nint get_atomic_number(const char *element_name) {\n    for (int i = 0; i < MAX_ELEMENTS; i++) {\n        if (strcmp(elements[i].name, element_name) == 0) {\n            return elements[i].atomic_number;\n        }\n    }\n    return -1; // Not found\n}\n\nint main() {\n    char element_to_lookup[20];\n    printf(\"Enter element name: \");\n    scanf(\"%s\", element_to_lookup);\n\n    int atomic_number = get_atomic_number(element_to_lookup);\n    if (atomic_number != -1) {\n        printf(\"The atomic number of %s is %d.\\n\", element_to_lookup, atomic_number);\n    } else {\n        printf(\"Element not found.\\n\");\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that uses a map to group movies by their directors.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_MOVIES 100\n#define MAX_NAME_LENGTH 100\n\ntypedef struct Movie {\n    char title[MAX_NAME_LENGTH];\n    char director[MAX_NAME_LENGTH];\n} Movie;\n\ntypedef struct MovieNode {\n    char title[MAX_NAME_LENGTH];\n    struct MovieNode* next;\n} MovieNode;\n\ntypedef struct DirectorNode {\n    char director[MAX_NAME_LENGTH];\n    MovieNode* movies;\n    struct DirectorNode* next;\n} DirectorNode;\n\nDirectorNode* add_movie_to_director(DirectorNode* head, char* director, char* title) {\n    DirectorNode* current = head;\n    while (current != NULL && strcmp(current->director, director) != 0) {\n        current = current->next;\n    }\n    if (current == NULL) {\n        DirectorNode* new_director = malloc(sizeof(DirectorNode));\n        strcpy(new_director->director, director);\n        new_director->movies = NULL;\n        new_director->next = head;\n        head = new_director;\n        current = new_director;\n    }\n    MovieNode* new_movie = malloc(sizeof(MovieNode));\n    strcpy(new_movie->title, title);\n    new_movie->next = current->movies;\n    current->movies = new_movie;\n    return head;\n}\n\nvoid group_movies_by_director(Movie movies[], int n) {\n    DirectorNode* directors = NULL;\n    for (int i = 0; i < n; i++) {\n        directors = add_movie_to_director(directors, movies[i].director, movies[i].title);\n    }\n\n    DirectorNode* current_director = directors;\n    while (current_director != NULL) {\n        printf(\"Director: %s\\n\", current_director->director);\n        MovieNode* current_movie = current_director->movies;\n        while (current_movie != NULL) {\n            printf(\"  Movie: %s\\n\", current_movie->title);\n            current_movie = current_movie->next;\n        }\n        current_director = current_director->next;\n    }\n}\n\nint main() {\n    Movie movies[MAX_MOVIES] = {\n        {\"Inception\", \"Christopher Nolan\"},\n        {\"The Dark Knight\", \"Christopher Nolan\"},\n        {\"Pulp Fiction\", \"Quentin Tarantino\"},\n        {\"Kill Bill\", \"Quentin Tarantino\"}\n    };\n\n    int n = 4;\n    group_movies_by_director(movies, n);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a dictionary to store the names of historical figures and their birth years.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_ENTRIES 100\n\ntypedef struct {\n    char name[50];\n    int birthYear;\n} HistoricalFigure;\n\ntypedef struct {\n    HistoricalFigure entries[MAX_ENTRIES];\n    int size;\n} Dictionary;\n\nvoid addEntry(Dictionary *dict, const char *name, int birthYear) {\n    if (dict->size < MAX_ENTRIES) {\n        strcpy(dict->entries[dict->size].name, name);\n        dict->entries[dict->size].birthYear = birthYear;\n        dict->size++;\n    }\n}\n\nint main() {\n    Dictionary historicalFigures;\n    historicalFigures.size = 0;\n\n    addEntry(&historicalFigures, \"Albert Einstein\", 1879);\n    addEntry(&historicalFigures, \"Isaac Newton\", 1643);\n    addEntry(&historicalFigures, \"Marie Curie\", 1867);\n\n    for (int i = 0; i < historicalFigures.size; i++) {\n        printf(\"%s: %d\\n\", historicalFigures.entries[i].name, historicalFigures.entries[i].birthYear);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Build a program that uses a map to store the names of planets and their diameters.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n#define NUM_PLANETS 8\n\ntypedef struct {\n    char name[20];\n    double diameter;\n} Planet;\n\nint main() {\n    Planet planets[NUM_PLANETS] = {\n        {\"Mercury\", 4879.0},\n        {\"Venus\", 12104.0},\n        {\"Earth\", 12742.0},\n        {\"Mars\", 6779.0},\n        {\"Jupiter\", 139820.0},\n        {\"Saturn\", 116460.0},\n        {\"Uranus\", 50724.0},\n        {\"Neptune\", 49244.0}\n    };\n    \n    printf(\"Planets and their diameters:\\n\");\n    for (int i = 0; i < NUM_PLANETS; i++) {\n        printf(\"%s: %.2f km\\n\", planets[i].name, planets[i].diameter);\n    }\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Implement a dictionary to track the ratings of restaurants, allowing updates to ratings.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_RESTAURANTS 100\n#define NAME_LENGTH 50\n\ntypedef struct {\n    char name[NAME_LENGTH];\n    int rating;\n} Restaurant;\n\ntypedef struct {\n    Restaurant restaurants[MAX_RESTAURANTS];\n    int count;\n} RestaurantDictionary;\n\nvoid initDictionary(RestaurantDictionary* dict) {\n    dict->count = 0;\n}\n\nint findRestaurant(RestaurantDictionary* dict, const char* name) {\n    for (int i = 0; i < dict->count; i++) {\n        if (strcmp(dict->restaurants[i].name, name) == 0) {\n            return i;\n        }\n    }\n    return -1;\n}\n\nvoid updateRating(RestaurantDictionary* dict, const char* name, int rating) {\n    int index = findRestaurant(dict, name);\n    if (index != -1) {\n        dict->restaurants[index].rating = rating;\n    } else if (dict->count < MAX_RESTAURANTS) {\n        strcpy(dict->restaurants[dict->count].name, name);\n        dict->restaurants[dict->count].rating = rating;\n        dict->count++;\n    }\n}\n\nvoid printRatings(const RestaurantDictionary* dict) {\n    for (int i = 0; i < dict->count; i++) {\n        printf(\"Restaurant: %s, Rating: %d\\n\", dict->restaurants[i].name, dict->restaurants[i].rating);\n    }\n}\n\nint main() {\n    RestaurantDictionary dict;\n    initDictionary(&dict);\n    \n    updateRating(&dict, \"Pizza Place\", 5);\n    updateRating(&dict, \"Burger Joint\", 4);\n    updateRating(&dict, \"Pizza Place\", 3);\n    \n    printRatings(&dict);\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Write a script that uses a map to translate binary numbers to decimal.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\nint binaryToDecimal(const char *binary) {\n    int decimal = 0;\n    int length = strlen(binary);\n    for (int i = 0; i < length; i++) {\n        if (binary[length - i - 1] == '1') {\n            decimal += pow(2, i);\n        }\n    }\n    return decimal;\n}\n\nint main() {\n    const char *binaryNumbers[] = {\"1010\", \"1111\", \"1001\"};\n    int decimalValues[3];\n    \n    for (int i = 0; i < 3; i++) {\n        decimalValues[i] = binaryToDecimal(binaryNumbers[i]);\n    }\n    \n    for (int i = 0; i < 3; i++) {\n        printf(\"Binary: %s -> Decimal: %d\\n\", binaryNumbers[i], decimalValues[i]);\n    }\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Create a dictionary to store the names of artists and their famous works.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    char *artist;\n    char *work;\n} ArtistWork;\n\nint main() {\n    ArtistWork dictionary[3];\n\n    dictionary[0].artist = \"Leonardo da Vinci\";\n    dictionary[0].work = \"Mona Lisa\";\n\n    dictionary[1].artist = \"Vincent van Gogh\";\n    dictionary[1].work = \"Starry Night\";\n\n    dictionary[2].artist = \"Pablo Picasso\";\n    dictionary[2].work = \"Guernica\";\n\n    for (int i = 0; i < 3; i++) {\n        printf(\"Artist: %s, Famous Work: %s\\n\", dictionary[i].artist, dictionary[i].work);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Design a system that uses a map to track the maintenance schedules of vehicles.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    char vehicleID[20];\n    char maintenanceDate[11];\n} VehicleMaintenance;\n\ntypedef struct MapNode {\n    char key[20];\n    VehicleMaintenance value;\n    struct MapNode* next;\n} MapNode;\n\ntypedef struct {\n    MapNode** table;\n    size_t size;\n} Map;\n\nMap* createMap(size_t size);\nvoid freeMap(Map* map);\nunsigned int hashFunction(const char* key, size_t size);\nvoid insert(Map* map, const char* key, VehicleMaintenance value);\nVehicleMaintenance* get(Map* map, const char* key);\n\nint main() {\n    Map* maintenanceMap = createMap(100);\n\n    VehicleMaintenance vm1 = {\"ABC123\", \"2024-05-01\"};\n    insert(maintenanceMap, vm1.vehicleID, vm1);\n\n    VehicleMaintenance vm2 = {\"XYZ789\", \"2024-06-15\"};\n    insert(maintenanceMap, vm2.vehicleID, vm2);\n\n    VehicleMaintenance* result = get(maintenanceMap, \"ABC123\");\n    if (result) {\n        printf(\"Vehicle ID: %s, Maintenance Date: %s\\n\", result->vehicleID, result->maintenanceDate);\n    }\n\n    freeMap(maintenanceMap);\n    return 0;\n}\n\nMap* createMap(size_t size) {\n    Map* map = (Map*)malloc(sizeof(Map));\n    map->size = size;\n    map->table = (MapNode**)malloc(size * sizeof(MapNode*));\n    for (size_t i = 0; i < size; ++i) {\n        map->table[i] = NULL;\n    }\n    return map;\n}\n\nvoid freeMap(Map* map) {\n    for (size_t i = 0; i < map->size; ++i) {\n        MapNode* node = map->table[i];\n        while (node) {\n            MapNode* temp = node;\n            node = node->next;\n            free(temp);\n        }\n    }\n    free(map->table);\n    free(map);\n}\n\nunsigned int hashFunction(const char* key, size_t size) {\n    unsigned int hash = 0;\n    while (*key) {\n        hash = (hash * 31) + *key++;\n    }\n    return hash % size;\n}\n\nvoid insert(Map* map, const char* key, VehicleMaintenance value) {\n    unsigned int hashIndex = hashFunction(key, map->size);\n    MapNode* newNode = (MapNode*)malloc(sizeof(MapNode));\n    strcpy(newNode->key, key);\n    newNode->value = value;\n    newNode->next = map->table[hashIndex];\n    map->table[hashIndex] = newNode;\n}\n\nVehicleMaintenance* get(Map* map, const char* key) {\n    unsigned int hashIndex = hashFunction(key, map->size);\n    MapNode* node = map->table[hashIndex];\n    while (node) {\n        if (strcmp(node->key, key) == 0) {\n            return &node->value;\n        }\n        node = node->next;\n    }\n    return NULL;\n}\n```"
  },
  {
    "task": "Develop a program that uses a dictionary to associate languages with their number of speakers worldwide.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    char language[50];\n    long speakers;\n} LanguageEntry;\n\ntypedef struct {\n    LanguageEntry *entries;\n    size_t size;\n} Dictionary;\n\nvoid initializeDictionary(Dictionary *dict, size_t size) {\n    dict->entries = (LanguageEntry *)malloc(size * sizeof(LanguageEntry));\n    dict->size = size;\n}\n\nvoid setEntry(Dictionary *dict, size_t index, const char *language, long speakers) {\n    if (index < dict->size) {\n        strncpy(dict->entries[index].language, language, sizeof(dict->entries[index].language) - 1);\n        dict->entries[index].language[sizeof(dict->entries[index].language) - 1] = '\\0';\n        dict->entries[index].speakers = speakers;\n    }\n}\n\nvoid printDictionary(Dictionary *dict) {\n    for (size_t i = 0; i < dict->size; ++i) {\n        printf(\"Language: %s, Speakers: %ld\\n\", dict->entries[i].language, dict->entries[i].speakers);\n    }\n}\n\nvoid freeDictionary(Dictionary *dict) {\n    free(dict->entries);\n}\n\nint main() {\n    Dictionary dict;\n    initializeDictionary(&dict, 3);\n\n    setEntry(&dict, 0, \"English\", 1500000000);\n    setEntry(&dict, 1, \"Mandarin\", 1100000000);\n    setEntry(&dict, 2, \"Spanish\", 460000000);\n\n    printDictionary(&dict);\n    freeDictionary(&dict);\n    return 0;\n}\n```"
  },
  {
    "task": "Create a map to store the names of cities and their average annual temperatures.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Define the structure for a map entry\ntypedef struct {\n    char city[50];\n    float temperature;\n} CityTemperature;\n\n// Function to add a city and its temperature to the map\nvoid addCityTemperature(CityTemperature map[], int *size, const char *city, float temperature) {\n    strcpy(map[*size].city, city);\n    map[*size].temperature = temperature;\n    (*size)++;\n}\n\n// Function to print all city temperatures from the map\nvoid printCityTemperatures(CityTemperature map[], int size) {\n    for (int i = 0; i < size; i++) {\n        printf(\"City: %s, Temperature: %.2f\\n\", map[i].city, map[i].temperature);\n    }\n}\n\nint main() {\n    CityTemperature cityMap[100];\n    int size = 0;\n\n    addCityTemperature(cityMap, &size, \"New York\", 12.3);\n    addCityTemperature(cityMap, &size, \"Los Angeles\", 17.5);\n    addCityTemperature(cityMap, &size, \"Chicago\", 10.0);\n    addCityTemperature(cityMap, &size, \"Houston\", 20.0);\n    addCityTemperature(cityMap, &size, \"Phoenix\", 23.0);\n\n    printCityTemperatures(cityMap, size);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that uses a dictionary to convert metric units to imperial units.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\ndouble convertMetricToImperial(const char *unit, double value) {\n    struct UnitConversion {\n        const char *metric;\n        const char *imperial;\n        double conversionFactor;\n    };\n\n    struct UnitConversion conversions[] = {\n        {\"meter\", \"yard\", 1.09361},\n        {\"kilogram\", \"pound\", 2.20462},\n        {\"liter\", \"gallon\", 0.264172}\n    };\n\n    int n = sizeof(conversions) / sizeof(conversions[0]);\n    for (int i = 0; i < n; i++) {\n        if (strcmp(conversions[i].metric, unit) == 0) {\n            return value * conversions[i].conversionFactor;\n        }\n    }\n    return -1; // Return -1 if unit not found\n}\n\nint main() {\n    printf(\"10 meters is %.2f yards\\n\", convertMetricToImperial(\"meter\", 10));\n    printf(\"5 kilograms is %.2f pounds\\n\", convertMetricToImperial(\"kilogram\", 5));\n    printf(\"3 liters is %.2f gallons\\n\", convertMetricToImperial(\"liter\", 3));\n    return 0;\n}\n```"
  },
  {
    "task": "Build a dictionary to store the names of sports and their respective world records.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_SPORTS 100\n#define MAX_NAME_LENGTH 50\n\ntypedef struct {\n    char sport[MAX_NAME_LENGTH];\n    char worldRecord[MAX_NAME_LENGTH];\n} SportRecord;\n\nvoid addRecord(SportRecord records[], int *count, const char *sport, const char *record) {\n    if (*count < MAX_SPORTS) {\n        strcpy(records[*count].sport, sport);\n        strcpy(records[*count].worldRecord, record);\n        (*count)++;\n    }\n}\n\nvoid printRecords(SportRecord records[], int count) {\n    for (int i = 0; i < count; i++) {\n        printf(\"Sport: %s, World Record: %s\\n\", records[i].sport, records[i].worldRecord);\n    }\n}\n\nint main() {\n    SportRecord records[MAX_SPORTS];\n    int count = 0;\n\n    addRecord(records, &count, \"100m Sprint\", \"9.58 seconds\");\n    addRecord(records, &count, \"Marathon\", \"2:01:09 hours\");\n    addRecord(records, &count, \"Long Jump\", \"8.95 meters\");\n\n    printRecords(records, count);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a map to manage a list of favorite movies, allowing additions and deletions.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_MOVIES 100\n#define MAX_TITLE_LENGTH 100\n\ntypedef struct {\n    char title[MAX_TITLE_LENGTH];\n    int is_favorite;\n} Movie;\n\ntypedef struct {\n    Movie movies[MAX_MOVIES];\n    int count;\n} MovieMap;\n\nvoid initialize_map(MovieMap *map) {\n    map->count = 0;\n}\n\nvoid add_movie(MovieMap *map, const char *title) {\n    if (map->count < MAX_MOVIES) {\n        strcpy(map->movies[map->count].title, title);\n        map->movies[map->count].is_favorite = 1;\n        map->count++;\n    } else {\n        printf(\"Movie map is full.\\n\");\n    }\n}\n\nvoid delete_movie(MovieMap *map, const char *title) {\n    for (int i = 0; i < map->count; i++) {\n        if (strcmp(map->movies[i].title, title) == 0) {\n            for (int j = i; j < map->count - 1; j++) {\n                map->movies[j] = map->movies[j + 1];\n            }\n            map->count--;\n            return;\n        }\n    }\n    printf(\"Movie not found.\\n\");\n}\n\nvoid print_movies(const MovieMap *map) {\n    printf(\"Favorite Movies:\\n\");\n    for (int i = 0; i < map->count; i++) {\n        printf(\"%s\\n\", map->movies[i].title);\n    }\n}\n\nint main() {\n    MovieMap my_movies;\n    initialize_map(&my_movies);\n\n    add_movie(&my_movies, \"The Shawshank Redemption\");\n    add_movie(&my_movies, \"The Godfather\");\n    add_movie(&my_movies, \"The Dark Knight\");\n\n    print_movies(&my_movies);\n\n    delete_movie(&my_movies, \"The Godfather\");\n    print_movies(&my_movies);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a program that uses a dictionary to track the distances between pairs of cities.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_CITIES 100\n#define MAX_LENGTH 50\n\ntypedef struct {\n    char city1[MAX_LENGTH];\n    char city2[MAX_LENGTH];\n    int distance;\n} CityDistance;\n\ntypedef struct {\n    CityDistance distances[MAX_CITIES];\n    int size;\n} CityMap;\n\nvoid add_distance(CityMap *map, const char *city1, const char *city2, int distance) {\n    if (map->size < MAX_CITIES) {\n        strncpy(map->distances[map->size].city1, city1, MAX_LENGTH);\n        strncpy(map->distances[map->size].city2, city2, MAX_LENGTH);\n        map->distances[map->size].distance = distance;\n        map->size++;\n    }\n}\n\nint get_distance(CityMap *map, const char *city1, const char *city2) {\n    for (int i = 0; i < map->size; i++) {\n        if ((strcmp(map->distances[i].city1, city1) == 0 && strcmp(map->distances[i].city2, city2) == 0) ||\n            (strcmp(map->distances[i].city1, city2) == 0 && strcmp(map->distances[i].city2, city1) == 0)) {\n            return map->distances[i].distance;\n        }\n    }\n    return -1; // Distance not found\n}\n\nint main() {\n    CityMap city_map;\n    city_map.size = 0;\n\n    add_distance(&city_map, \"New York\", \"Los Angeles\", 2451);\n    add_distance(&city_map, \"Chicago\", \"Houston\", 1090);\n    add_distance(&city_map, \"San Francisco\", \"Seattle\", 807);\n\n    printf(\"Distance between New York and Los Angeles: %d miles\\n\", get_distance(&city_map, \"New York\", \"Los Angeles\"));\n    printf(\"Distance between Chicago and Houston: %d miles\\n\", get_distance(&city_map, \"Chicago\", \"Houston\"));\n    printf(\"Distance between San Francisco and Seattle: %d miles\\n\", get_distance(&city_map, \"San Francisco\", \"Seattle\"));\n\n    return 0;\n}\n```"
  },
  {
    "task": "Design a dictionary to store the names of planets and their orbital periods.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_PLANETS 8\n#define NAME_LENGTH 20\n\ntypedef struct {\n    char name[NAME_LENGTH];\n    double orbitalPeriod;\n} Planet;\n\nint main() {\n    Planet planets[MAX_PLANETS] = {\n        {\"Mercury\", 88.0},\n        {\"Venus\", 224.7},\n        {\"Earth\", 365.2},\n        {\"Mars\", 687.0},\n        {\"Jupiter\", 4331.0},\n        {\"Saturn\", 10747.0},\n        {\"Uranus\", 30589.0},\n        {\"Neptune\", 59800.0}\n    };\n\n    for (int i = 0; i < MAX_PLANETS; i++) {\n        printf(\"Planet: %s, Orbital Period: %.1f days\\n\", planets[i].name, planets[i].orbitalPeriod);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that uses a map to convert HTML color codes to their respective color names.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n// Define a structure for map\ntypedef struct {\n    const char *code;\n    const char *name;\n} ColorMap;\n\n// Function to get color name from code\nconst char* getColorName(const char *colorCode) {\n    // Define the map of color codes and their respective names\n    ColorMap colorMap[] = {\n        {\"#FF5733\", \"Red\"},\n        {\"#33FF57\", \"Green\"},\n        {\"#3357FF\", \"Blue\"},\n        {\"#FFFFFF\", \"White\"},\n        {\"#000000\", \"Black\"}\n    };\n\n    int mapSize = sizeof(colorMap) / sizeof(ColorMap);\n    for (int i = 0; i < mapSize; i++) {\n        if (strcmp(colorMap[i].code, colorCode) == 0) {\n            return colorMap[i].name;\n        }\n    }\n    return \"Unknown\";\n}\n\nint main() {\n    const char *colorCode = \"#FF5733\";\n    const char *colorName = getColorName(colorCode);\n    printf(\"The color name for code %s is %s.\\n\", colorCode, colorName);\n    return 0;\n}\n```"
  },
  {
    "task": "Create a dictionary to store the names of composers and their famous compositions.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_COMPOSERS 5\n#define MAX_NAME_LENGTH 50\n#define MAX_COMPOSITION_LENGTH 100\n\ntypedef struct {\n    char composer[MAX_NAME_LENGTH];\n    char composition[MAX_COMPOSITION_LENGTH];\n} ComposerEntry;\n\nint main() {\n    ComposerEntry composers[MAX_COMPOSERS] = {\n        {\"Ludwig van Beethoven\", \"Symphony No. 9\"},\n        {\"Johann Sebastian Bach\", \"Brandenburg Concertos\"},\n        {\"Wolfgang Amadeus Mozart\", \"The Magic Flute\"},\n        {\"Pyotr Ilyich Tchaikovsky\", \"Swan Lake\"},\n        {\"Fr\u00e9d\u00e9ric Chopin\", \"Nocturnes\"}\n    };\n\n    for(int i = 0; i < MAX_COMPOSERS; i++) {\n        printf(\"Composer: %s, Famous Composition: %s\\n\", composers[i].composer, composers[i].composition);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Build a program that uses a map to store the names of bridges and their lengths.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_BRIDGES 100\n#define MAX_NAME_LEN 100\n\ntypedef struct {\n    char name[MAX_NAME_LEN];\n    double length;\n} Bridge;\n\ntypedef struct {\n    Bridge bridges[MAX_BRIDGES];\n    int count;\n} BridgeMap;\n\nvoid addBridge(BridgeMap *map, const char *name, double length) {\n    if (map->count < MAX_BRIDGES) {\n        strncpy(map->bridges[map->count].name, name, MAX_NAME_LEN);\n        map->bridges[map->count].name[MAX_NAME_LEN - 1] = '\\0'; // Ensure null-termination\n        map->bridges[map->count].length = length;\n        map->count++;\n    } else {\n        printf(\"Bridge map is full.\\n\");\n    }\n}\n\nint main() {\n    BridgeMap map = {.count = 0};\n\n    addBridge(&map, \"Golden Gate\", 2737.4);\n    addBridge(&map, \"Brooklyn Bridge\", 1825.0);\n\n    for (int i = 0; i < map.count; i++) {\n        printf(\"Bridge: %s, Length: %.1f meters\\n\", map.bridges[i].name, map.bridges[i].length);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a dictionary to manage a list of personal goals, allowing updates to goals.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_GOALS 100\n#define MAX_LENGTH 100\n\ntypedef struct {\n    char goal[MAX_LENGTH];\n    char description[MAX_LENGTH];\n} Goal;\n\ntypedef struct {\n    Goal goals[MAX_GOALS];\n    int count;\n} GoalList;\n\nvoid addOrUpdateGoal(GoalList* list, const char* goal, const char* description) {\n    for (int i = 0; i < list->count; i++) {\n        if (strcmp(list->goals[i].goal, goal) == 0) {\n            strcpy(list->goals[i].description, description);\n            return;\n        }\n    }\n    if (list->count < MAX_GOALS) {\n        strcpy(list->goals[list->count].goal, goal);\n        strcpy(list->goals[list->count].description, description);\n        list->count++;\n    } else {\n        printf(\"Goal list is full.\\n\");\n    }\n}\n\nvoid printGoals(GoalList* list) {\n    for (int i = 0; i < list->count; i++) {\n        printf(\"Goal: %s, Description: %s\\n\", list->goals[i].goal, list->goals[i].description);\n    }\n}\n\nint main() {\n    GoalList goalList = {.count = 0};\n\n    addOrUpdateGoal(&goalList, \"Exercise\", \"Go to the gym daily.\");\n    addOrUpdateGoal(&goalList, \"Read\", \"Read a new book every month.\");\n    addOrUpdateGoal(&goalList, \"Exercise\", \"Go to the gym three times a week.\");\n\n    printGoals(&goalList);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a script that uses a map to convert hexadecimal numbers to binary.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    // Define map for hexadecimal to binary conversion\n    const char *hexToBinMap[16] = {\n        \"0000\", \"0001\", \"0010\", \"0011\",\n        \"0100\", \"0101\", \"0110\", \"0111\",\n        \"1000\", \"1001\", \"1010\", \"1011\",\n        \"1100\", \"1101\", \"1110\", \"1111\"\n    };\n\n    char hexNumber[] = \"1A3F\";\n    char binaryResult[65] = \"\"; // Enough to hold binary representation\n\n    for (int i = 0; i < strlen(hexNumber); i++) {\n        char hexDigit = hexNumber[i];\n        int index;\n\n        if (hexDigit >= '0' && hexDigit <= '9') {\n            index = hexDigit - '0';\n        } else if (hexDigit >= 'A' && hexDigit <= 'F') {\n            index = hexDigit - 'A' + 10;\n        } else if (hexDigit >= 'a' && hexDigit <= 'f') {\n            index = hexDigit - 'a' + 10;\n        } else {\n            continue; // Invalid character, skip\n        }\n\n        strcat(binaryResult, hexToBinMap[index]);\n    }\n\n    printf(\"Binary representation: %s\\n\", binaryResult);\n    return 0;\n}\n```"
  },
  {
    "task": "Create a dictionary to store the names of trees and their average heights.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    char name[50];\n    float averageHeight;\n} Tree;\n\ntypedef struct {\n    Tree *trees;\n    size_t size;\n    size_t capacity;\n} TreeDictionary;\n\nvoid initDictionary(TreeDictionary *dict, size_t capacity) {\n    dict->trees = (Tree *)malloc(capacity * sizeof(Tree));\n    dict->size = 0;\n    dict->capacity = capacity;\n}\n\nvoid addTree(TreeDictionary *dict, const char *name, float height) {\n    if (dict->size >= dict->capacity) {\n        dict->capacity *= 2;\n        dict->trees = (Tree *)realloc(dict->trees, dict->capacity * sizeof(Tree));\n    }\n    strcpy(dict->trees[dict->size].name, name);\n    dict->trees[dict->size].averageHeight = height;\n    dict->size++;\n}\n\nvoid freeDictionary(TreeDictionary *dict) {\n    free(dict->trees);\n}\n\nint main() {\n    TreeDictionary treeDict;\n    initDictionary(&treeDict, 2);\n\n    addTree(&treeDict, \"Oak\", 70.0);\n    addTree(&treeDict, \"Pine\", 60.0);\n    addTree(&treeDict, \"Maple\", 50.0);\n\n    for (size_t i = 0; i < treeDict.size; i++) {\n        printf(\"Tree: %s, Average Height: %.2f\\n\", treeDict.trees[i].name, treeDict.trees[i].averageHeight);\n    }\n\n    freeDictionary(&treeDict);\n\n    return 0;\n}\n```"
  }
]