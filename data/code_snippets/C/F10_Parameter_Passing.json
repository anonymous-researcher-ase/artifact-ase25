[
  {
    "task": "Create a function that modifies the first element of an array passed to it. Explain how the changes are reflected in the original array.",
    "code": "```c\n#include <stdio.h>\n\nvoid modifyFirstElement(int *arr) {\n    arr[0] = 100; // Modify the first element\n}\n\nint main() {\n    int numbers[] = {1, 2, 3, 4, 5};\n    \n    printf(\"Before modification: %d\\n\", numbers[0]);\n    modifyFirstElement(numbers);\n    printf(\"After modification: %d\\n\", numbers[0]);\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Design a function that swaps the values of two variables using pass-by-reference. Demonstrate how the swap affects the original variables.",
    "code": "```c\n#include <stdio.h>\n\nvoid swap(int *a, int *b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint main() {\n    int x = 5, y = 10;\n    printf(\"Before swap: x = %d, y = %d\\n\", x, y);\n    swap(&x, &y);\n    printf(\"After swap: x = %d, y = %d\\n\", x, y);\n    return 0;\n}\n```"
  },
  {
    "task": "Write a program that passes a large data structure to a function by value and by reference. Compare the performance and memory usage for both approaches.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n#define SIZE 1000000\n\ntypedef struct {\n    int data[SIZE];\n} LargeStruct;\n\nvoid processByValue(LargeStruct ls) {\n    for (int i = 0; i < SIZE; i++) {\n        ls.data[i]++;\n    }\n}\n\nvoid processByReference(LargeStruct *ls) {\n    for (int i = 0; i < SIZE; i++) {\n        ls->data[i]++;\n    }\n}\n\nint main() {\n    LargeStruct ls;\n    for (int i = 0; i < SIZE; i++) {\n        ls.data[i] = i;\n    }\n\n    clock_t start, end;\n    double cpu_time_used;\n\n    start = clock();\n    processByValue(ls);\n    end = clock();\n    cpu_time_used = ((double)(end - start)) / CLOCKS_PER_SEC;\n    printf(\"Time taken by value: %f seconds\\n\", cpu_time_used);\n\n    start = clock();\n    processByReference(&ls);\n    end = clock();\n    cpu_time_used = ((double)(end - start)) / CLOCKS_PER_SEC;\n    printf(\"Time taken by reference: %f seconds\\n\", cpu_time_used);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a function that accepts an integer and doubles its value. Show the difference in the original variable when using pass-by-value versus pass-by-reference.",
    "code": "```c\n#include <stdio.h>\n\nvoid doubleValueByValue(int n) {\n    n = n * 2;\n}\n\nvoid doubleValueByReference(int *n) {\n    *n = *n * 2;\n}\n\nint main() {\n    int originalValue = 5;\n    int valueByValue = originalValue;\n    int valueByReference = originalValue;\n    \n    doubleValueByValue(valueByValue);\n    doubleValueByReference(&valueByReference);\n    \n    printf(\"Original Value: %d\\n\", originalValue);\n    printf(\"After pass-by-value: %d\\n\", valueByValue);\n    printf(\"After pass-by-reference: %d\\n\", valueByReference);\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Create a function that takes a list and returns a new list with elements doubled. Ensure the original list remains unchanged.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint* doubleElements(const int* list, int size) {\n    int* doubledList = (int*)malloc(size * sizeof(int));\n    for (int i = 0; i < size; i++) {\n        doubledList[i] = 2 * list[i];\n    }\n    return doubledList;\n}\n\nint main() {\n    int originalList[] = {1, 2, 3, 4, 5};\n    int size = sizeof(originalList) / sizeof(originalList[0]);\n\n    int* newList = doubleElements(originalList, size);\n\n    for (int i = 0; i < size; i++) {\n        printf(\"%d \", newList[i]);\n    }\n    printf(\"\\n\");\n\n    free(newList);\n    return 0;\n}\n```"
  },
  {
    "task": "Design a function that takes a string argument and appends a character to it. Illustrate the result when the string is passed by value.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\nvoid appendCharacter(char str[], char c) {\n    size_t len = strlen(str);\n    str[len] = c;\n    str[len + 1] = '\\0';\n}\n\nint main() {\n    char str[] = \"Hello\";\n    char strCopy[100];\n    strcpy(strCopy, str);\n    \n    appendCharacter(strCopy, '!');\n    \n    printf(\"Original string: %s\\n\", str);\n    printf(\"Modified string: %s\\n\", strCopy);\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that increments a counter variable. Pass the variable by reference to see changes in the original variable.",
    "code": "```c\n#include <stdio.h>\n\nvoid incrementCounter(int *counter) {\n    (*counter)++;\n}\n\nint main() {\n    int counter = 0;\n    printf(\"Counter before increment: %d\\n\", counter);\n    incrementCounter(&counter);\n    printf(\"Counter after increment: %d\\n\", counter);\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a function that removes an item from a dictionary passed to it. Demonstrate how pass-by-reference affects the original dictionary.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    char key[50];\n    char value[50];\n} KeyValuePair;\n\ntypedef struct {\n    KeyValuePair items[100];\n    int size;\n} Dictionary;\n\nvoid removeItem(Dictionary *dict, const char *key) {\n    int found = 0;\n    for (int i = 0; i < dict->size; i++) {\n        if (!found && strcmp(dict->items[i].key, key) == 0) {\n            found = 1;\n        }\n        if (found && i < dict->size - 1) {\n            dict->items[i] = dict->items[i + 1];\n        }\n    }\n    if (found) {\n        dict->size--;\n    }\n}\n\nvoid printDictionary(const Dictionary *dict) {\n    for (int i = 0; i < dict->size; i++) {\n        printf(\"%s: %s\\n\", dict->items[i].key, dict->items[i].value);\n    }\n}\n\nint main() {\n    Dictionary dict = {\n        {\n            {\"key1\", \"value1\"},\n            {\"key2\", \"value2\"},\n            {\"key3\", \"value3\"}\n        },\n        3\n    };\n\n    printf(\"Original Dictionary:\\n\");\n    printDictionary(&dict);\n\n    removeItem(&dict, \"key2\");\n\n    printf(\"\\nDictionary after removal:\\n\");\n    printDictionary(&dict);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a program that passes a matrix to a function, which transposes it. Explain how the transposition affects the original matrix with pass-by-reference.",
    "code": "```c\n#include <stdio.h>\n\n#define ROWS 3\n#define COLS 3\n\nvoid transposeMatrix(int matrix[ROWS][COLS], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = i + 1; j < cols; j++) {\n            int temp = matrix[i][j];\n            matrix[i][j] = matrix[j][i];\n            matrix[j][i] = temp;\n        }\n    }\n}\n\nvoid printMatrix(int matrix[ROWS][COLS], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            printf(\"%d \", matrix[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n\nint main() {\n    int matrix[ROWS][COLS] = {\n        {1, 2, 3},\n        {4, 5, 6},\n        {7, 8, 9}\n    };\n\n    printf(\"Original Matrix:\\n\");\n    printMatrix(matrix, ROWS, COLS);\n\n    transposeMatrix(matrix, ROWS, COLS);\n\n    printf(\"Transposed Matrix:\\n\");\n    printMatrix(matrix, ROWS, COLS);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a function that takes a float number and rounds it. Discuss the implications of passing the number by value.",
    "code": "```c\n#include <stdio.h>\n#include <math.h>\n\nfloat roundFloat(float number) {\n    return roundf(number);\n}\n\nint main() {\n    float number = 3.7f;\n    float rounded = roundFloat(number);\n    printf(\"Original: %f, Rounded: %f\\n\", number, rounded);\n    return 0;\n}\n```"
  },
  {
    "task": "Design a function that accepts a dictionary and adds a key-value pair to it. Show the changes when the dictionary is passed by reference.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    char key[50];\n    char value[50];\n} KeyValuePair;\n\ntypedef struct {\n    KeyValuePair pairs[100];\n    int size;\n} Dictionary;\n\nvoid addKeyValuePair(Dictionary *dict, const char *key, const char *value) {\n    strcpy(dict->pairs[dict->size].key, key);\n    strcpy(dict->pairs[dict->size].value, value);\n    dict->size++;\n}\n\nvoid printDictionary(const Dictionary *dict) {\n    for (int i = 0; i < dict->size; i++) {\n        printf(\"%s: %s\\n\", dict->pairs[i].key, dict->pairs[i].value);\n    }\n}\n\nint main() {\n    Dictionary dict = {.size = 0};\n\n    addKeyValuePair(&dict, \"language\", \"C\");\n    addKeyValuePair(&dict, \"feature\", \"Parameter Passing\");\n\n    printDictionary(&dict);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a program that passes a string to a function that converts it to uppercase. Explain how this affects the original string with pass-by-value.",
    "code": "```c\n#include <stdio.h>\n#include <ctype.h>\n\nvoid toUpperCase(char *str) {\n    while (*str) {\n        *str = toupper(*str);\n        str++;\n    }\n}\n\nint main() {\n    char originalString[] = \"hello world\";\n    printf(\"Original String: %s\\n\", originalString);\n    toUpperCase(originalString);\n    printf(\"Modified String: %s\\n\", originalString);\n    return 0;\n}\n```"
  },
  {
    "task": "Create a function that receives a tuple and attempts to modify one of its elements. Discuss the outcome of using pass-by-value.",
    "code": "```c\n#include <stdio.h>\n\ntypedef struct {\n    int a;\n    int b;\n} Tuple;\n\nvoid modifyTuple(Tuple t) {\n    t.a = 99; // Attempt to modify the first element of the tuple\n}\n\nint main() {\n    Tuple t = {1, 2};\n    printf(\"Before modification: a = %d, b = %d\\n\", t.a, t.b);\n    modifyTuple(t);\n    printf(\"After modification: a = %d, b = %d\\n\", t.a, t.b);\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a function that accepts an object and modifies one of its attributes. Illustrate how pass-by-reference alters the original object.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    char name[50];\n    int age;\n} Person;\n\nvoid modifyPerson(Person *p) {\n    p->age += 1; // Modify the age attribute\n}\n\nint main() {\n    Person person;\n    strcpy(person.name, \"Alice\");\n    person.age = 30;\n\n    printf(\"Before modification: %s is %d years old.\\n\", person.name, person.age);\n    \n    modifyPerson(&person); // Pass-by-reference\n    \n    printf(\"After modification: %s is %d years old.\\n\", person.name, person.age);\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Design a function that outputs the sum of all elements in an array passed by value. Confirm the original array remains unchanged.",
    "code": "```c\n#include <stdio.h>\n\nint sumArray(int arr[], int size) {\n    int sum = 0;\n    for (int i = 0; i < size; i++) {\n        sum += arr[i];\n    }\n    return sum;\n}\n\nint main() {\n    int originalArray[] = {1, 2, 3, 4, 5};\n    int size = sizeof(originalArray) / sizeof(originalArray[0]);\n    int sum = sumArray(originalArray, size);\n\n    printf(\"Sum of array elements: %d\\n\", sum);\n\n    printf(\"Original array: \");\n    for (int i = 0; i < size; i++) {\n        printf(\"%d \", originalArray[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that takes a boolean flag and toggles its value. Demonstrate the effect of pass-by-reference on the original flag.",
    "code": "```c\n#include <stdio.h>\n\nvoid toggleFlag(int *flag) {\n    *flag = !(*flag);\n}\n\nint main() {\n    int flag = 1; // true\n    printf(\"Original flag: %d\\n\", flag);\n    toggleFlag(&flag);\n    printf(\"Toggled flag: %d\\n\", flag);\n    return 0;\n}\n```"
  },
  {
    "task": "Create a function that takes an object and clones it. Modify the clone and show that the original object remains unaffected.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    int id;\n    char name[50];\n} Object;\n\nvoid cloneAndModify(Object original, Object *clone) {\n    // Clone the object\n    clone->id = original.id;\n    strcpy(clone->name, original.name);\n\n    // Modify the clone\n    clone->id += 1;\n    strcat(clone->name, \" (modified)\");\n}\n\nint main() {\n    Object original = {1, \"Original Object\"};\n    Object clone;\n\n    cloneAndModify(original, &clone);\n\n    printf(\"Original Object: id=%d, name=%s\\n\", original.id, original.name);\n    printf(\"Cloned and Modified Object: id=%d, name=%s\\n\", clone.id, clone.name);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a function that accepts a list of integers and removes all even numbers. Describe the difference in behavior when using pass-by-value and pass-by-reference.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid removeEvens(int** arr, int* size) {\n    int* newArr = (int*)malloc((*size) * sizeof(int));\n    int newIdx = 0;\n\n    for (int i = 0; i < *size; ++i) {\n        if ((*arr)[i] % 2 != 0) {\n            newArr[newIdx++] = (*arr)[i];\n        }\n    }\n\n    free(*arr);\n    *arr = newArr;\n    *size = newIdx;\n}\n\nint main() {\n    int arr[] = {1, 2, 3, 4, 5, 6};\n    int size = sizeof(arr) / sizeof(arr[0]);\n\n    int* arrPtr = arr;\n    removeEvens(&arrPtr, &size);\n\n    for (int i = 0; i < size; ++i) {\n        printf(\"%d \", arrPtr[i]);\n    }\n    printf(\"\\n\");\n\n    free(arrPtr);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a function that takes a complex number and returns its conjugate. Explain how pass-by-value affects the original complex number.",
    "code": "```c\n#include <stdio.h>\n\ntypedef struct {\n    double real;\n    double imag;\n} Complex;\n\nComplex conjugate(Complex c) {\n    Complex result;\n    result.real = c.real;\n    result.imag = -c.imag;\n    return result;\n}\n\nint main() {\n    Complex c1 = {3.0, 4.0};\n    Complex c1_conjugate = conjugate(c1);\n\n    printf(\"Original: %.2f + %.2fi\\n\", c1.real, c1.imag);\n    printf(\"Conjugate: %.2f + %.2fi\\n\", c1_conjugate.real, c1_conjugate.imag);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Design a program where a function receives a binary tree and inverts it. Discuss how pass-by-reference impacts the original tree structure.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\n// Define the structure for a tree node\ntypedef struct TreeNode {\n    int value;\n    struct TreeNode *left;\n    struct TreeNode *right;\n} TreeNode;\n\n// Function to invert a binary tree\nvoid invertTree(TreeNode **root) {\n    if (root == NULL || *root == NULL) {\n        return;\n    }\n    \n    // Swap the left and right children of the current node\n    TreeNode *temp = (*root)->left;\n    (*root)->left = (*root)->right;\n    (*root)->right = temp;\n    \n    // Recursively invert the left and right subtrees\n    invertTree(&(*root)->left);\n    invertTree(&(*root)->right);\n}\n\n// Helper function to create a new tree node\nTreeNode* createNode(int value) {\n    TreeNode *newNode = (TreeNode*)malloc(sizeof(TreeNode));\n    newNode->value = value;\n    newNode->left = NULL;\n    newNode->right = NULL;\n    return newNode;\n}\n\n// Helper function to print the tree in-order for verification\nvoid printTree(TreeNode *root) {\n    if (root == NULL) {\n        return;\n    }\n    printTree(root->left);\n    printf(\"%d \", root->value);\n    printTree(root->right);\n}\n\nint main() {\n    // Create a sample tree: 4, 2, 7, 1, 3, 6, 9\n    TreeNode *root = createNode(4);\n    root->left = createNode(2);\n    root->right = createNode(7);\n    root->left->left = createNode(1);\n    root->left->right = createNode(3);\n    root->right->left = createNode(6);\n    root->right->right = createNode(9);\n\n    printf(\"Original Tree: \");\n    printTree(root);\n    printf(\"\\n\");\n\n    // Invert the binary tree\n    invertTree(&root);\n\n    printf(\"Inverted Tree: \");\n    printTree(root);\n    printf(\"\\n\");\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that adds an element to a set passed to it. Show how pass-by-reference affects the original set.",
    "code": "```c\n#include <stdio.h>\n#include <stdbool.h>\n\n#define MAX_SET_SIZE 100\n\ntypedef struct {\n    int elements[MAX_SET_SIZE];\n    int size;\n} Set;\n\nbool isInSet(Set *s, int element) {\n    for (int i = 0; i < s->size; i++) {\n        if (s->elements[i] == element) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid addElement(Set *s, int element) {\n    if (s->size < MAX_SET_SIZE && !isInSet(s, element)) {\n        s->elements[s->size] = element;\n        s->size++;\n    }\n}\n\nvoid printSet(Set *s) {\n    printf(\"{ \");\n    for (int i = 0; i < s->size; i++) {\n        printf(\"%d \", s->elements[i]);\n    }\n    printf(\"}\\n\");\n}\n\nint main() {\n    Set mySet = {{1, 2, 3}, 3};\n    printf(\"Original set: \");\n    printSet(&mySet);\n\n    addElement(&mySet, 4);\n\n    printf(\"Modified set: \");\n    printSet(&mySet);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a function that accepts an integer array and sorts it. Demonstrate the difference when the array is passed by value.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\nvoid sortArray(int arr[], int size) {\n    for (int i = 0; i < size - 1; i++) {\n        for (int j = 0; j < size - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n}\n\nvoid passByValueSort(int arr[], int size) {\n    int copy[size];\n    memcpy(copy, arr, size * sizeof(int));\n    sortArray(copy, size);\n    printf(\"Sorted copy of array (pass by value): \");\n    for (int i = 0; i < size; i++) {\n        printf(\"%d \", copy[i]);\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    int arr[] = {5, 3, 8, 1, 2};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    \n    printf(\"Original array: \");\n    for (int i = 0; i < size; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    printf(\"\\n\");\n\n    passByValueSort(arr, size);\n\n    printf(\"Original array after attempt to sort by value: \");\n    for (int i = 0; i < size; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a function that takes a configuration object and toggles a setting. Illustrate the changes with pass-by-reference.",
    "code": "```c\n#include <stdio.h>\n\ntypedef struct {\n    int setting;\n} Config;\n\nvoid toggleSetting(Config *config) {\n    config->setting = !config->setting;\n}\n\nint main() {\n    Config config = {0}; // Initially setting is 0 (false)\n    \n    printf(\"Initial setting: %d\\n\", config.setting);\n    toggleSetting(&config);\n    printf(\"Toggled setting: %d\\n\", config.setting);\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Design a function that receives a file path and reads its content. Explain how passing the path by value affects the outcome.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid readFileByPath(char filePath[]) {\n    FILE *file = fopen(filePath, \"r\");\n    if (file == NULL) {\n        printf(\"Failed to open the file.\\n\");\n        return;\n    }\n\n    char ch;\n    while ((ch = fgetc(file)) != EOF) {\n        putchar(ch);\n    }\n\n    fclose(file);\n}\n\nint main() {\n    char path[] = \"example.txt\";\n    readFileByPath(path);\n    return 0;\n}\n```"
  },
  {
    "task": "Write a program in which a function takes a stack and reverses its elements. Discuss the impact of pass-by-reference on the stack.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    int data;\n    struct Node* next;\n} Node;\n\ntypedef struct Stack {\n    Node* top;\n} Stack;\n\nvoid push(Stack* stack, int data) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    if (!newNode) {\n        printf(\"Memory allocation failed\\n\");\n        exit(1);\n    }\n    newNode->data = data;\n    newNode->next = stack->top;\n    stack->top = newNode;\n}\n\nint pop(Stack* stack) {\n    if (stack->top == NULL) {\n        printf(\"Stack underflow\\n\");\n        exit(1);\n    }\n    Node* temp = stack->top;\n    int popped = temp->data;\n    stack->top = temp->next;\n    free(temp);\n    return popped;\n}\n\nvoid reverseStack(Stack* stack) {\n    Stack tempStack = {NULL};\n    while (stack->top != NULL) {\n        push(&tempStack, pop(stack));\n    }\n    *stack = tempStack;\n}\n\nvoid printStack(Stack* stack) {\n    Node* current = stack->top;\n    while (current != NULL) {\n        printf(\"%d \", current->data);\n        current = current->next;\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    Stack stack = {NULL};\n\n    push(&stack, 1);\n    push(&stack, 2);\n    push(&stack, 3);\n    push(&stack, 4);\n\n    printf(\"Original Stack: \");\n    printStack(&stack);\n\n    reverseStack(&stack);\n\n    printf(\"Reversed Stack: \");\n    printStack(&stack);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a function that takes a queue and dequeues an element. Show the result when the queue is passed by reference.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    int data;\n    struct Node* next;\n} Node;\n\ntypedef struct Queue {\n    Node* front;\n    Node* rear;\n} Queue;\n\nvoid enqueue(Queue* q, int value) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->data = value;\n    newNode->next = NULL;\n    if (q->rear == NULL) {\n        q->front = q->rear = newNode;\n        return;\n    }\n    q->rear->next = newNode;\n    q->rear = newNode;\n}\n\nint dequeue(Queue* q) {\n    if (q->front == NULL) {\n        return -1; // Queue is empty\n    }\n    Node* temp = q->front;\n    int value = temp->data;\n    q->front = q->front->next;\n    if (q->front == NULL) {\n        q->rear = NULL;\n    }\n    free(temp);\n    return value;\n}\n\nint main() {\n    Queue q = {NULL, NULL};\n    enqueue(&q, 10);\n    enqueue(&q, 20);\n    enqueue(&q, 30);\n\n    printf(\"Dequeued: %d\\n\", dequeue(&q));\n    printf(\"Dequeued: %d\\n\", dequeue(&q));\n\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a function that accepts a hashmap and updates a value for a specific key. Illustrate the effects of pass-by-reference.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\ntypedef struct {\n    char key[50];\n    char value[50];\n} HashMapItem;\n\ntypedef struct {\n    HashMapItem *items;\n    int size;\n} HashMap;\n\nvoid updateValue(HashMap *map, const char *key, const char *newValue) {\n    for (int i = 0; i < map->size; i++) {\n        if (strcmp(map->items[i].key, key) == 0) {\n            strcpy(map->items[i].value, newValue);\n            return;\n        }\n    }\n    printf(\"Key not found.\\n\");\n}\n\nint main() {\n    HashMap map;\n    map.size = 2;\n    map.items = (HashMapItem *)malloc(map.size * sizeof(HashMapItem));\n\n    strcpy(map.items[0].key, \"key1\");\n    strcpy(map.items[0].value, \"value1\");\n    strcpy(map.items[1].key, \"key2\");\n    strcpy(map.items[1].value, \"value2\");\n\n    printf(\"Before update: %s\\n\", map.items[0].value);\n    updateValue(&map, \"key1\", \"newValue1\");\n    printf(\"After update: %s\\n\", map.items[0].value);\n\n    free(map.items);\n    return 0;\n}\n```"
  },
  {
    "task": "Design a function that receives a JSON object and adds a new property. Discuss the implications of modifying the object by reference.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <json-c/json.h>\n\nvoid add_property(json_object *jobj, const char *key, const char *value) {\n    json_object *new_value = json_object_new_string(value);\n    json_object_object_add(jobj, key, new_value);\n}\n\nint main() {\n    json_object *jobj = json_object_new_object();\n    json_object_object_add(jobj, \"existing_key\", json_object_new_string(\"existing_value\"));\n    \n    printf(\"Before: %s\\n\", json_object_to_json_string(jobj));\n\n    add_property(jobj, \"new_key\", \"new_value\");\n\n    printf(\"After: %s\\n\", json_object_to_json_string(jobj));\n\n    json_object_put(jobj);\n    return 0;\n}\n```"
  },
  {
    "task": "Write a program where a function accepts a graph and adds a node. Explain how pass-by-reference affects the original graph structure.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    int value;\n    struct Node* next;\n} Node;\n\ntypedef struct Graph {\n    Node** adjLists;\n    int numVertices;\n} Graph;\n\nNode* createNode(int value) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->value = value;\n    newNode->next = NULL;\n    return newNode;\n}\n\nvoid addNode(Graph* graph) {\n    graph->adjLists = (Node**)realloc(graph->adjLists, (graph->numVertices + 1) * sizeof(Node*));\n    graph->adjLists[graph->numVertices] = NULL;\n    graph->numVertices++;\n}\n\nvoid printGraph(Graph* graph) {\n    for (int i = 0; i < graph->numVertices; i++) {\n        Node* temp = graph->adjLists[i];\n        printf(\"\\n Vertex %d\\n: \", i);\n        while (temp) {\n            printf(\"%d -> \", temp->value);\n            temp = temp->next;\n        }\n        printf(\"NULL\\n\");\n    }\n}\n\nint main() {\n    Graph graph;\n    graph.numVertices = 0;\n    graph.adjLists = NULL;\n\n    addNode(&graph);\n    printGraph(&graph);\n\n    addNode(&graph);\n    printGraph(&graph);\n\n    free(graph.adjLists);\n    return 0;\n}\n```"
  },
  {
    "task": "Create a function that accepts a set of coordinates and shifts them. Demonstrate how pass-by-value ensures the original set is unchanged.",
    "code": "```c\n#include <stdio.h>\n\ntypedef struct {\n    int x;\n    int y;\n} Coordinates;\n\nvoid shiftCoordinates(Coordinates coords, int shiftX, int shiftY) {\n    coords.x += shiftX;\n    coords.y += shiftY;\n    printf(\"Shifted Coordinates: (%d, %d)\\n\", coords.x, coords.y);\n}\n\nint main() {\n    Coordinates original = {10, 20};\n    printf(\"Original Coordinates: (%d, %d)\\n\", original.x, original.y);\n    \n    shiftCoordinates(original, 5, -3);\n    \n    printf(\"After function call, Original Coordinates: (%d, %d)\\n\", original.x, original.y);\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Implement a function that takes a date object and sets it to the next day. Discuss the effects of pass-by-reference on the date object.",
    "code": "```c\n#include <stdio.h>\n\ntypedef struct {\n    int day;\n    int month;\n    int year;\n} Date;\n\nint isLeapYear(int year) {\n    if (year % 4 == 0) {\n        if (year % 100 == 0) {\n            if (year % 400 == 0)\n                return 1;\n            else\n                return 0;\n        } else\n            return 1;\n    } else\n        return 0;\n}\n\nint daysInMonth(int month, int year) {\n    switch (month) {\n        case 1: case 3: case 5: case 7: case 8: case 10: case 12:\n            return 31;\n        case 4: case 6: case 9: case 11:\n            return 30;\n        case 2:\n            return isLeapYear(year) ? 29 : 28;\n        default:\n            return 0;\n    }\n}\n\nvoid setNextDay(Date *date) {\n    if (date == NULL) return;\n    \n    date->day++;\n    if (date->day > daysInMonth(date->month, date->year)) {\n        date->day = 1;\n        date->month++;\n        if (date->month > 12) {\n            date->month = 1;\n            date->year++;\n        }\n    }\n}\n\nint main() {\n    Date today = {31, 12, 2023};\n    setNextDay(&today);\n    printf(\"Next day is: %02d-%02d-%d\\n\", today.day, today.month, today.year);\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a function that receives a polynomial represented as a list of coefficients and differentiates it. Show how the original list remains unchanged with pass-by-value.",
    "code": "```c\n#include <stdio.h>\n\nvoid differentiate(const int *coeffs, int *diff_coeffs, int size) {\n    for (int i = 1; i < size; i++) {\n        diff_coeffs[i - 1] = coeffs[i] * i;\n    }\n}\n\nint main() {\n    int coef[] = {3, 2, 5, 0}; // Represents 3 + 2x + 5x^2\n    int size = sizeof(coef) / sizeof(coef[0]);\n    int diff_coef[size - 1];\n\n    differentiate(coef, diff_coef, size);\n\n    printf(\"Original coefficients: \");\n    for (int i = 0; i < size; i++) {\n        printf(\"%d \", coef[i]);\n    }\n    printf(\"\\n\");\n\n    printf(\"Differentiated coefficients: \");\n    for (int i = 0; i < size - 1; i++) {\n        printf(\"%d \", diff_coef[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n```"
  },
  {
    "task": "Design a function that accepts a stack and clears it. Explain how pass-by-reference affects the original stack.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\n// Define a simple stack structure\ntypedef struct Stack {\n    int *data;\n    int top;\n    int capacity;\n} Stack;\n\n// Function to create a stack\nStack createStack(int capacity) {\n    Stack stack;\n    stack.capacity = capacity;\n    stack.top = -1;\n    stack.data = (int *)malloc(capacity * sizeof(int));\n    return stack;\n}\n\n// Function to clear the stack\nvoid clearStack(Stack *stack) {\n    stack->top = -1;\n}\n\n// Function to push an element onto the stack\nvoid push(Stack *stack, int value) {\n    if (stack->top < stack->capacity - 1) {\n        stack->data[++stack->top] = value;\n    }\n}\n\n// Function to check if the stack is empty\nint isStackEmpty(Stack *stack) {\n    return stack->top == -1;\n}\n\nint main() {\n    // Create a stack\n    Stack stack = createStack(10);\n\n    // Push some elements onto the stack\n    push(&stack, 1);\n    push(&stack, 2);\n    push(&stack, 3);\n\n    // Clear the stack\n    clearStack(&stack);\n\n    // Check if the stack is empty\n    if (isStackEmpty(&stack)) {\n        printf(\"Stack is empty.\\n\");\n    } else {\n        printf(\"Stack is not empty.\\n\");\n    }\n\n    // Free the allocated memory\n    free(stack.data);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that takes a linked list and appends a new node. Demonstrate the impact of pass-by-reference on the list.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    int data;\n    struct Node* next;\n} Node;\n\nvoid appendNode(Node** head_ref, int new_data) {\n    Node* new_node = (Node*)malloc(sizeof(Node));\n    Node* last = *head_ref;\n    new_node->data = new_data;\n    new_node->next = NULL;\n\n    if (*head_ref == NULL) {\n        *head_ref = new_node;\n        return;\n    }\n\n    while (last->next != NULL)\n        last = last->next;\n\n    last->next = new_node;\n}\n\nvoid printList(Node* node) {\n    while (node != NULL) {\n        printf(\"%d -> \", node->data);\n        node = node->next;\n    }\n    printf(\"NULL\\n\");\n}\n\nint main() {\n    Node* head = NULL;\n\n    appendNode(&head, 10);\n    appendNode(&head, 20);\n    appendNode(&head, 30);\n\n    printList(head);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a function that receives a URL and extracts the domain name. Discuss the effects of pass-by-value on the URL string.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\nvoid extractDomain(const char url[], char domain[], size_t domainSize) {\n    const char *start = strstr(url, \"://\");\n    if (start) {\n        start += 3; // Move past '://'\n    } else {\n        start = url; // No scheme found, start from the beginning\n    }\n    \n    const char *end = strchr(start, '/');\n    if (!end) {\n        end = start + strlen(start); // No path found, end at the end of the string\n    }\n    \n    size_t length = end - start;\n    if (length >= domainSize) {\n        length = domainSize - 1; // Ensure null-termination\n    }\n    \n    strncpy(domain, start, length);\n    domain[length] = '\\0';\n}\n\nint main() {\n    char url[] = \"https://www.example.com/some/path\";\n    char domain[256];\n    \n    extractDomain(url, domain, sizeof(domain));\n    printf(\"URL: %s\\n\", url);\n    printf(\"Domain: %s\\n\", domain);\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Implement a function that takes a priority queue and changes the priority of an element. Illustrate the effects using pass-by-reference.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int data;\n    int priority;\n} Element;\n\ntypedef struct {\n    Element *elements;\n    int size;\n    int capacity;\n} PriorityQueue;\n\nPriorityQueue* createQueue(int capacity) {\n    PriorityQueue *queue = (PriorityQueue*)malloc(sizeof(PriorityQueue));\n    queue->elements = (Element*)malloc(capacity * sizeof(Element));\n    queue->size = 0;\n    queue->capacity = capacity;\n    return queue;\n}\n\nvoid changePriority(PriorityQueue *queue, int index, int newPriority) {\n    if (index < 0 || index >= queue->size) {\n        printf(\"Index out of bounds.\\n\");\n        return;\n    }\n    queue->elements[index].priority = newPriority;\n}\n\nvoid insertElement(PriorityQueue *queue, int data, int priority) {\n    if (queue->size == queue->capacity) {\n        printf(\"Queue is full.\\n\");\n        return;\n    }\n    queue->elements[queue->size].data = data;\n    queue->elements[queue->size].priority = priority;\n    queue->size++;\n}\n\nvoid printQueue(PriorityQueue *queue) {\n    for (int i = 0; i < queue->size; i++) {\n        printf(\"Element: %d, Priority: %d\\n\", queue->elements[i].data, queue->elements[i].priority);\n    }\n}\n\nint main() {\n    PriorityQueue *queue = createQueue(5);\n    insertElement(queue, 10, 1);\n    insertElement(queue, 20, 2);\n    insertElement(queue, 30, 3);\n    \n    printf(\"Queue before priority change:\\n\");\n    printQueue(queue);\n    \n    changePriority(queue, 1, 5);\n    \n    printf(\"\\nQueue after priority change:\\n\");\n    printQueue(queue);\n    \n    free(queue->elements);\n    free(queue);\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a function that accepts a circular buffer and reads an element. Explain how pass-by-reference influences the buffer.",
    "code": "```c\n#include <stdio.h>\n#include <stdbool.h>\n\n#define BUFFER_SIZE 5\n\ntypedef struct {\n    int data[BUFFER_SIZE];\n    int head;\n    int tail;\n    bool full;\n} CircularBuffer;\n\nbool readElement(CircularBuffer *buffer, int *element) {\n    if (buffer->head == buffer->tail && !buffer->full) {\n        return false; // Buffer is empty\n    }\n    \n    *element = buffer->data[buffer->tail];\n    buffer->tail = (buffer->tail + 1) % BUFFER_SIZE;\n    buffer->full = false;\n    \n    return true;\n}\n\nint main() {\n    CircularBuffer buffer = {{1, 2, 3, 4, 5}, 0, 0, true};\n    int element;\n    \n    if (readElement(&buffer, &element)) {\n        printf(\"Read element: %d\\n\", element);\n    } else {\n        printf(\"Buffer is empty.\\n\");\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Design a program where a function receives a record and updates a field. Show how pass-by-reference affects the original record.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    char name[50];\n    int age;\n} Person;\n\n// Function to update the age of a person\nvoid updateAge(Person *p, int newAge) {\n    p->age = newAge;\n}\n\nint main() {\n    Person person;\n    strcpy(person.name, \"Alice\");\n    person.age = 30;\n\n    printf(\"Before update: %s is %d years old.\\n\", person.name, person.age);\n\n    // Update the age using pass-by-reference\n    updateAge(&person, 35);\n\n    printf(\"After update: %s is now %d years old.\\n\", person.name, person.age);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that takes a frequency list and normalizes it. Describe how pass-by-value ensures the original list remains unchanged.",
    "code": "```c\n#include <stdio.h>\n\nvoid normalizeFrequencies(const double freqList[], double normalizedList[], int size) {\n    double sum = 0.0;\n    for (int i = 0; i < size; i++) {\n        sum += freqList[i];\n    }\n    for (int i = 0; i < size; i++) {\n        normalizedList[i] = freqList[i] / sum;\n    }\n}\n\nint main() {\n    double freqList[] = {10.0, 20.0, 30.0, 40.0};\n    int size = sizeof(freqList) / sizeof(freqList[0]);\n    double normalizedList[size];\n\n    normalizeFrequencies(freqList, normalizedList, size);\n\n    printf(\"Normalized Frequencies:\\n\");\n    for (int i = 0; i < size; i++) {\n        printf(\"%f \", normalizedList[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a function that accepts a chessboard and makes a move. Discuss how pass-by-reference alters the original board setup.",
    "code": "```c\n#include <stdio.h>\n\n#define SIZE 8\n\nvoid makeMove(char board[SIZE][SIZE], int fromRow, int fromCol, int toRow, int toCol) {\n    // Simple move logic: move piece from (fromRow, fromCol) to (toRow, toCol)\n    board[toRow][toCol] = board[fromRow][fromCol];\n    board[fromRow][fromCol] = ' ';\n}\n\nvoid printBoard(char board[SIZE][SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        for (int j = 0; j < SIZE; j++) {\n            printf(\"%c \", board[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n\nint main() {\n    char chessboard[SIZE][SIZE] = {\n        {'R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R'},\n        {'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'},\n        {' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},\n        {' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},\n        {' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},\n        {' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},\n        {'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'},\n        {'r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'}\n    };\n\n    printf(\"Original board:\\n\");\n    printBoard(chessboard);\n\n    makeMove(chessboard, 1, 0, 3, 0); // Move pawn from (1,0) to (3,0)\n\n    printf(\"\\nBoard after move:\\n\");\n    printBoard(chessboard);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a function that takes a decimal number and converts it to binary. Explain the effects of pass-by-value on the original number.",
    "code": "```c\n#include <stdio.h>\n\nvoid decimalToBinary(int num) {\n    int binary[32];\n    int index = 0;\n    \n    while (num > 0) {\n        binary[index++] = num % 2;\n        num = num / 2;\n    }\n\n    for (int i = index - 1; i >= 0; i--) {\n        printf(\"%d\", binary[i]);\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    int decimalNumber = 10;\n    printf(\"Decimal Number: %d\\n\", decimalNumber);\n    printf(\"Binary Equivalent: \");\n    decimalToBinary(decimalNumber);\n    printf(\"Original Decimal Number after function call: %d\\n\", decimalNumber);\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a function that receives a DNA sequence and counts nucleotides. Illustrate how pass-by-value ensures the original sequence remains intact.",
    "code": "```c\n#include <stdio.h>\n\nvoid countNucleotides(char sequence[], int *aCount, int *cCount, int *gCount, int *tCount) {\n    *aCount = *cCount = *gCount = *tCount = 0;\n    \n    for (int i = 0; sequence[i] != '\\0'; i++) {\n        switch (sequence[i]) {\n            case 'A': (*aCount)++; break;\n            case 'C': (*cCount)++; break;\n            case 'G': (*gCount)++; break;\n            case 'T': (*tCount)++; break;\n        }\n    }\n}\n\nint main() {\n    char dnaSequence[] = \"AGCTTAGCTA\";\n    int aCount, cCount, gCount, tCount;\n    \n    countNucleotides(dnaSequence, &aCount, &cCount, &gCount, &tCount);\n    \n    printf(\"A: %d\\nC: %d\\nG: %d\\nT: %d\\n\", aCount, cCount, gCount, tCount);\n    printf(\"Original sequence: %s\\n\", dnaSequence);\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Design a function that accepts a shopping cart object and applies a discount. Show the changes with pass-by-reference.",
    "code": "```c\n#include <stdio.h>\n\ntypedef struct {\n    double total_price;\n} ShoppingCart;\n\nvoid applyDiscount(ShoppingCart *cart, double discount) {\n    cart->total_price -= cart->total_price * discount;\n}\n\nint main() {\n    ShoppingCart cart = {100.0};\n    printf(\"Original total price: %.2f\\n\", cart.total_price);\n    applyDiscount(&cart, 0.1); // Applying a 10% discount\n    printf(\"Total price after discount: %.2f\\n\", cart.total_price);\n    return 0;\n}\n```"
  },
  {
    "task": "Write a program where a function receives a playlist and adds a song. Discuss how pass-by-reference affects the original playlist.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_SONGS 100\n#define SONG_NAME_LENGTH 100\n\ntypedef struct {\n    char songs[MAX_SONGS][SONG_NAME_LENGTH];\n    int count;\n} Playlist;\n\nvoid addSong(Playlist *playlist, const char *song) {\n    if (playlist->count < MAX_SONGS) {\n        strncpy(playlist->songs[playlist->count], song, SONG_NAME_LENGTH - 1);\n        playlist->songs[playlist->count][SONG_NAME_LENGTH - 1] = '\\0';\n        playlist->count++;\n    } else {\n        printf(\"Playlist is full!\\n\");\n    }\n}\n\nint main() {\n    Playlist myPlaylist = { .count = 0 };\n    \n    addSong(&myPlaylist, \"Song 1\");\n    addSong(&myPlaylist, \"Song 2\");\n    \n    printf(\"Playlist contains %d songs:\\n\", myPlaylist.count);\n    for (int i = 0; i < myPlaylist.count; i++) {\n        printf(\"%d: %s\\n\", i + 1, myPlaylist.songs[i]);\n    }\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Create a function that takes a sprite in a game and moves it. Demonstrate the result when the sprite is passed by reference.",
    "code": "```c\n#include <stdio.h>\n\ntypedef struct {\n    int x;\n    int y;\n} Sprite;\n\nvoid moveSprite(Sprite *s, int dx, int dy) {\n    s->x += dx;\n    s->y += dy;\n}\n\nint main() {\n    Sprite mySprite = { 0, 0 };\n    printf(\"Before move: (%d, %d)\\n\", mySprite.x, mySprite.y);\n    moveSprite(&mySprite, 5, 7);\n    printf(\"After move: (%d, %d)\\n\", mySprite.x, mySprite.y);\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a function that accepts a book object and updates the title. Illustrate the impact of pass-by-reference on the original object.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    char title[100];\n    char author[100];\n} Book;\n\nvoid updateTitle(Book *b, const char *newTitle) {\n    strcpy(b->title, newTitle);\n}\n\nint main() {\n    Book myBook;\n    strcpy(myBook.title, \"Original Title\");\n    strcpy(myBook.author, \"Author Name\");\n\n    printf(\"Before update: %s\\n\", myBook.title);\n\n    updateTitle(&myBook, \"Updated Title\");\n\n    printf(\"After update: %s\\n\", myBook.title);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a function that receives a sound wave and normalizes it. Explain how pass-by-value affects the original sound wave.",
    "code": "```c\n#include <stdio.h>\n\n#define SIZE 10\n\nvoid normalizeSoundWave(float wave[], int size) {\n    float maxAmplitude = 0.0;\n    for (int i = 0; i < size; i++) {\n        if (wave[i] > maxAmplitude) {\n            maxAmplitude = wave[i];\n        }\n    }\n    if (maxAmplitude == 0.0) return;\n    for (int i = 0; i < size; i++) {\n        wave[i] /= maxAmplitude;\n    }\n}\n\nint main() {\n    float soundWave[SIZE] = {0.3, 0.5, 0.9, 0.4, 0.7, 0.6, 0.8, 0.2, 0.1, 0.5};\n    \n    printf(\"Original Sound Wave:\\n\");\n    for (int i = 0; i < SIZE; i++) {\n        printf(\"%.2f \", soundWave[i]);\n    }\n    printf(\"\\n\");\n    \n    normalizeSoundWave(soundWave, SIZE);\n    \n    printf(\"Normalized Sound Wave:\\n\");\n    for (int i = 0; i < SIZE; i++) {\n        printf(\"%.2f \", soundWave[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n```"
  },
  {
    "task": "Design a program where a function receives a bank account object and credits an amount. Discuss the effects of pass-by-reference.",
    "code": "```c\n#include <stdio.h>\n\ntypedef struct {\n    char accountHolder[50];\n    double balance;\n} BankAccount;\n\nvoid creditAmount(BankAccount *account, double amount) {\n    account->balance += amount;\n}\n\nint main() {\n    BankAccount account = {\"John Doe\", 1000.0};\n    printf(\"Initial Balance: %.2f\\n\", account.balance);\n\n    creditAmount(&account, 500.0);\n    printf(\"Balance after credit: %.2f\\n\", account.balance);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that takes an email list and filters out invalid addresses. Show the difference in the list when using pass-by-value.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\n#define MAX_EMAILS 100\n#define MAX_EMAIL_LENGTH 256\n\nint isValidEmail(const char* email) {\n    const char* at = strchr(email, '@');\n    if (at == NULL || at == email || at - email > MAX_EMAIL_LENGTH) {\n        return 0;\n    }\n    const char* dot = strchr(at, '.');\n    return dot != NULL && dot > at && dot - email <= MAX_EMAIL_LENGTH;\n}\n\nvoid filterEmailsByValue(char emails[MAX_EMAILS][MAX_EMAIL_LENGTH], int count) {\n    char filteredEmails[MAX_EMAILS][MAX_EMAIL_LENGTH];\n    int filteredCount = 0;\n\n    for (int i = 0; i < count; i++) {\n        if (isValidEmail(emails[i])) {\n            strcpy(filteredEmails[filteredCount++], emails[i]);\n        }\n    }\n\n    printf(\"Filtered emails (pass-by-value):\\n\");\n    for (int i = 0; i < filteredCount; i++) {\n        printf(\"%s\\n\", filteredEmails[i]);\n    }\n}\n\nint main() {\n    char emailList[MAX_EMAILS][MAX_EMAIL_LENGTH] = {\n        \"valid.email@example.com\",\n        \"invalid-email.com\",\n        \"another.valid@example.co\",\n        \"@missingusername.com\"\n    };\n    int emailCount = 4;\n\n    printf(\"Original emails:\\n\");\n    for (int i = 0; i < emailCount; i++) {\n        printf(\"%s\\n\", emailList[i]);\n    }\n\n    filterEmailsByValue(emailList, emailCount);\n\n    printf(\"Original emails after function call:\\n\");\n    for (int i = 0; i < emailCount; i++) {\n        printf(\"%s\\n\", emailList[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a function that accepts a 3D model and scales it. Demonstrate how pass-by-reference affects the original model.",
    "code": "```c\n#include <stdio.h>\n\ntypedef struct {\n    float x, y, z;\n} Vertex;\n\ntypedef struct {\n    Vertex vertices[100];\n    int vertexCount;\n} Model;\n\nvoid scaleModel(Model *model, float scaleFactor) {\n    for (int i = 0; i < model->vertexCount; i++) {\n        model->vertices[i].x *= scaleFactor;\n        model->vertices[i].y *= scaleFactor;\n        model->vertices[i].z *= scaleFactor;\n    }\n}\n\nvoid printModel(const Model *model) {\n    for (int i = 0; i < model->vertexCount; i++) {\n        printf(\"Vertex %d: (%.2f, %.2f, %.2f)\\n\", i, \n               model->vertices[i].x, \n               model->vertices[i].y, \n               model->vertices[i].z);\n    }\n}\n\nint main() {\n    Model myModel = {\n        .vertices = {{0, 0, 0}, {1, 1, 1}, {2, 2, 2}},\n        .vertexCount = 3\n    };\n\n    printf(\"Original Model:\\n\");\n    printModel(&myModel);\n\n    scaleModel(&myModel, 2.0);\n\n    printf(\"\\nScaled Model:\\n\");\n    printModel(&myModel);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a function that receives a text document and redacts sensitive information. Explain the impact of pass-by-reference.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\nvoid redactSensitiveInfo(char *document) {\n    char *sensitiveWord = \"secret\";\n    char *replacement = \"REDACTED\";\n    char *pos;\n\n    while ((pos = strstr(document, sensitiveWord)) != NULL) {\n        memset(pos, '*', strlen(sensitiveWord));\n    }\n}\n\nint main() {\n    char document[256] = \"This is a secret document containing secret information.\";\n\n    printf(\"Original Document: %s\\n\", document);\n\n    redactSensitiveInfo(document);\n\n    printf(\"Redacted Document: %s\\n\", document);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a function that takes a temperature reading and adjusts for calibration. Discuss how pass-by-value ensures the original reading is unchanged.",
    "code": "```c\n#include <stdio.h>\n\nfloat adjustTemperature(float temperatureReading) {\n    float calibrationOffset = 2.5; // Example calibration offset\n    return temperatureReading + calibrationOffset;\n}\n\nint main() {\n    float originalReading = 25.0;\n    float adjustedReading = adjustTemperature(originalReading);\n\n    printf(\"Original Reading: %.2f\\n\", originalReading);\n    printf(\"Adjusted Reading: %.2f\\n\", adjustedReading);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Design a function that accepts a bug report and updates its status. Show the changes with pass-by-reference.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    int id;\n    char description[256];\n    char status[50];\n} BugReport;\n\nvoid updateBugStatus(BugReport *bugReport, const char *newStatus) {\n    strcpy(bugReport->status, newStatus);\n}\n\nint main() {\n    BugReport bug = {1, \"Sample bug description\", \"Open\"};\n    printf(\"Before update: ID: %d, Description: %s, Status: %s\\n\",\n           bug.id, bug.description, bug.status);\n\n    updateBugStatus(&bug, \"Closed\");\n\n    printf(\"After update: ID: %d, Description: %s, Status: %s\\n\",\n           bug.id, bug.description, bug.status);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a program where a function receives a sensor array and calibrates it. Demonstrate the effect of pass-by-reference on the array.",
    "code": "```c\n#include <stdio.h>\n\n#define SIZE 5\n\nvoid calibrateSensorArray(int *sensorArray, int size) {\n    for (int i = 0; i < size; i++) {\n        sensorArray[i] += 10;  // Example calibration adjustment\n    }\n}\n\nint main() {\n    int sensors[SIZE] = {5, 10, 15, 20, 25};\n    printf(\"Original sensor values:\\n\");\n    for (int i = 0; i < SIZE; i++) {\n        printf(\"%d \", sensors[i]);\n    }\n    printf(\"\\n\");\n\n    calibrateSensorArray(sensors, SIZE);\n\n    printf(\"Calibrated sensor values:\\n\");\n    for (int i = 0; i < SIZE; i++) {\n        printf(\"%d \", sensors[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a function that takes a vector and rotates it. Explain how pass-by-value ensures the original vector remains unchanged.",
    "code": "```c\n#include <stdio.h>\n\nvoid rotateVector(int vector[], int size) {\n    int temp = vector[0];\n    for (int i = 0; i < size - 1; i++) {\n        vector[i] = vector[i + 1];\n    }\n    vector[size - 1] = temp;\n}\n\nvoid printVector(const int vector[], int size) {\n    for (int i = 0; i < size; i++) {\n        printf(\"%d \", vector[i]);\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    int originalVector[] = {1, 2, 3, 4, 5};\n    int size = sizeof(originalVector) / sizeof(originalVector[0]);\n    \n    int vectorCopy[size];\n    for (int i = 0; i < size; i++) {\n        vectorCopy[i] = originalVector[i];\n    }\n    \n    rotateVector(vectorCopy, size);\n    \n    printf(\"Original vector: \");\n    printVector(originalVector, size);\n    \n    printf(\"Rotated vector: \");\n    printVector(vectorCopy, size);\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Implement a function that accepts an operation log and compresses it. Discuss the impact of pass-by-reference on the log.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\nvoid compressLog(char *log) {\n    int writeIndex = 0;\n    int readIndex = 0;\n    int length = strlen(log);\n\n    while (readIndex < length) {\n        char currentChar = log[readIndex];\n        int count = 1;\n\n        while (readIndex + 1 < length && log[readIndex] == log[readIndex + 1]) {\n            count++;\n            readIndex++;\n        }\n\n        log[writeIndex++] = currentChar;\n        if (count > 1) {\n            int numChars = sprintf(&log[writeIndex], \"%d\", count);\n            writeIndex += numChars;\n        }\n        readIndex++;\n    }\n    log[writeIndex] = '\\0';\n}\n\nint main() {\n    char log[] = \"aaabbccccdde\";\n    printf(\"Original log: %s\\n\", log);\n    compressLog(log);\n    printf(\"Compressed log: %s\\n\", log);\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a function that receives a neural network model and updates its weights. Illustrate the effects of pass-by-reference.",
    "code": "```c\n#include <stdio.h>\n\n#define NUM_WEIGHTS 5\n\ntypedef struct {\n    double weights[NUM_WEIGHTS];\n} NeuralNetwork;\n\nvoid updateWeights(NeuralNetwork *model, double increment) {\n    for (int i = 0; i < NUM_WEIGHTS; ++i) {\n        model->weights[i] += increment;\n    }\n}\n\nvoid printWeights(const NeuralNetwork *model) {\n    printf(\"Weights: \");\n    for (int i = 0; i < NUM_WEIGHTS; ++i) {\n        printf(\"%.2f \", model->weights[i]);\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    NeuralNetwork model = {{0.1, 0.2, 0.3, 0.4, 0.5}};\n    \n    printf(\"Before update:\\n\");\n    printWeights(&model);\n\n    updateWeights(&model, 0.05);\n\n    printf(\"After update:\\n\");\n    printWeights(&model);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Design a function that accepts a command history and reverts the last command. Show the changes with pass-by-reference.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_HISTORY 100\n#define MAX_COMMAND_LENGTH 100\n\nvoid revert_last_command(char history[][MAX_COMMAND_LENGTH], int *command_count) {\n    if (*command_count > 0) {\n        (*command_count)--;\n        printf(\"Reverted command: %s\\n\", history[*command_count]);\n    } else {\n        printf(\"No commands to revert.\\n\");\n    }\n}\n\nint main() {\n    char command_history[MAX_HISTORY][MAX_COMMAND_LENGTH];\n    int command_count = 0;\n\n    // Sample commands for demonstration\n    strcpy(command_history[command_count++], \"Command1\");\n    strcpy(command_history[command_count++], \"Command2\");\n    strcpy(command_history[command_count++], \"Command3\");\n\n    printf(\"Command count before revert: %d\\n\", command_count);\n    revert_last_command(command_history, &command_count);\n    printf(\"Command count after revert: %d\\n\", command_count);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that takes a user profile and anonymizes it. Discuss how pass-by-reference affects the original profile.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    char name[50];\n    char email[50];\n} UserProfile;\n\nvoid anonymizeProfile(UserProfile *profile) {\n    strcpy(profile->name, \"Anonymous\");\n    strcpy(profile->email, \"anonymous@example.com\");\n}\n\nint main() {\n    UserProfile user = {\"John Doe\", \"john.doe@example.com\"};\n    \n    printf(\"Before anonymization:\\n\");\n    printf(\"Name: %s\\n\", user.name);\n    printf(\"Email: %s\\n\", user.email);\n    \n    anonymizeProfile(&user);\n    \n    printf(\"\\nAfter anonymization:\\n\");\n    printf(\"Name: %s\\n\", user.name);\n    printf(\"Email: %s\\n\", user.email);\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Create a function that accepts a polynomial and evaluates it at a given point. Explain how pass-by-value ensures the polynomial remains unchanged.",
    "code": "```c\n#include <stdio.h>\n#include <math.h>\n\ndouble evaluatePolynomial(double coefficients[], int degree, double x) {\n    double result = 0.0;\n    for (int i = 0; i <= degree; ++i) {\n        result += coefficients[i] * pow(x, i);\n    }\n    return result;\n}\n\nint main() {\n    double coefficients[] = {1.0, -3.0, 2.0}; // Example: x^2 - 3x + 2\n    int degree = 2;\n    double x = 2.0;\n    \n    double result = evaluatePolynomial(coefficients, degree, x);\n    printf(\"The polynomial evaluates to: %f\\n\", result);\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Implement a function that receives a video stream and applies a filter. Demonstrate the effects of pass-by-reference on the stream.",
    "code": "```c\n#include <stdio.h>\n\ntypedef struct {\n    int width;\n    int height;\n    int frameCount;\n    unsigned char *frames;\n} VideoStream;\n\nvoid applyFilter(VideoStream *stream) {\n    for (int i = 0; i < stream->width * stream->height * stream->frameCount; i++) {\n        stream->frames[i] = 255 - stream->frames[i]; // Invert colors as a sample filter\n    }\n}\n\nvoid printFirstFrame(VideoStream *stream) {\n    printf(\"First frame pixels: \");\n    for (int i = 0; i < stream->width * stream->height; i++) {\n        printf(\"%d \", stream->frames[i]);\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    int width = 2;\n    int height = 2;\n    int frameCount = 1;\n    unsigned char frames[] = {10, 20, 30, 40};\n\n    VideoStream stream = {width, height, frameCount, frames};\n\n    printf(\"Before applying filter:\\n\");\n    printFirstFrame(&stream);\n\n    applyFilter(&stream);\n\n    printf(\"After applying filter:\\n\");\n    printFirstFrame(&stream);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a function that takes a task queue and reorders tasks based on priority. Illustrate the impact of pass-by-reference.",
    "code": "```c\n#include <stdio.h>\n\ntypedef struct {\n    int task_id;\n    int priority;\n} Task;\n\nvoid reorderTasks(Task *tasks, int numTasks) {\n    for (int i = 0; i < numTasks - 1; i++) {\n        for (int j = i + 1; j < numTasks; j++) {\n            if (tasks[i].priority < tasks[j].priority) {\n                Task temp = tasks[i];\n                tasks[i] = tasks[j];\n                tasks[j] = temp;\n            }\n        }\n    }\n}\n\nvoid printTasks(Task *tasks, int numTasks) {\n    for (int i = 0; i < numTasks; i++) {\n        printf(\"Task ID: %d, Priority: %d\\n\", tasks[i].task_id, tasks[i].priority);\n    }\n}\n\nint main() {\n    Task taskQueue[] = {{1, 3}, {2, 5}, {3, 1}, {4, 4}};\n    int numTasks = sizeof(taskQueue) / sizeof(taskQueue[0]);\n\n    printf(\"Before reordering:\\n\");\n    printTasks(taskQueue, numTasks);\n\n    reorderTasks(taskQueue, numTasks);\n\n    printf(\"\\nAfter reordering:\\n\");\n    printTasks(taskQueue, numTasks);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Design a program where a function receives a blockchain and verifies a transaction. Discuss how pass-by-reference affects the blockchain.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    char sender[50];\n    char receiver[50];\n    double amount;\n} Transaction;\n\ntypedef struct {\n    Transaction transactions[100];\n    int transactionCount;\n} Blockchain;\n\nint verifyTransaction(Blockchain *blockchain, Transaction *transaction) {\n    for (int i = 0; i < blockchain->transactionCount; i++) {\n        if (strcmp(blockchain->transactions[i].sender, transaction->sender) == 0 &&\n            strcmp(blockchain->transactions[i].receiver, transaction->receiver) == 0 &&\n            blockchain->transactions[i].amount == transaction->amount) {\n            return 1; // Transaction verified\n        }\n    }\n    return 0; // Transaction not found\n}\n\nint main() {\n    Blockchain blockchain;\n    blockchain.transactionCount = 2;\n    strcpy(blockchain.transactions[0].sender, \"Alice\");\n    strcpy(blockchain.transactions[0].receiver, \"Bob\");\n    blockchain.transactions[0].amount = 25.0;\n\n    strcpy(blockchain.transactions[1].sender, \"Charlie\");\n    strcpy(blockchain.transactions[1].receiver, \"Dave\");\n    blockchain.transactions[1].amount = 50.0;\n\n    Transaction tx;\n    strcpy(tx.sender, \"Alice\");\n    strcpy(tx.receiver, \"Bob\");\n    tx.amount = 25.0;\n\n    if (verifyTransaction(&blockchain, &tx)) {\n        printf(\"Transaction verified.\\n\");\n    } else {\n        printf(\"Transaction not found.\\n\");\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that takes a game leaderboard and updates scores. Show the changes with pass-by-reference.",
    "code": "```c\n#include <stdio.h>\n\n#define NUM_PLAYERS 5\n\ntypedef struct {\n    char name[50];\n    int score;\n} Player;\n\nvoid updateScores(Player *leaderboard, int *scoreUpdates, int size) {\n    for (int i = 0; i < size; i++) {\n        leaderboard[i].score += scoreUpdates[i];\n    }\n}\n\nvoid printLeaderboard(Player *leaderboard, int size) {\n    for (int i = 0; i < size; i++) {\n        printf(\"Player: %s, Score: %d\\n\", leaderboard[i].name, leaderboard[i].score);\n    }\n}\n\nint main() {\n    Player leaderboard[NUM_PLAYERS] = {\n        {\"Alice\", 100},\n        {\"Bob\", 150},\n        {\"Charlie\", 200},\n        {\"Diana\", 250},\n        {\"Eve\", 300}\n    };\n\n    int scoreUpdates[NUM_PLAYERS] = {10, -20, 30, 40, -50};\n\n    printf(\"Leaderboard before update:\\n\");\n    printLeaderboard(leaderboard, NUM_PLAYERS);\n\n    updateScores(leaderboard, scoreUpdates, NUM_PLAYERS);\n\n    printf(\"\\nLeaderboard after update:\\n\");\n    printLeaderboard(leaderboard, NUM_PLAYERS);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a function that accepts a project timeline and adjusts for delays. Explain how pass-by-reference influences the timeline.",
    "code": "```c\n#include <stdio.h>\n\nvoid adjustForDelays(int *timeline, int delay) {\n    *timeline += delay;\n}\n\nint main() {\n    int projectTimeline = 30; // initial timeline in days\n    int delay = 5; // delay in days\n\n    printf(\"Original Timeline: %d days\\n\", projectTimeline);\n    adjustForDelays(&projectTimeline, delay);\n    printf(\"Adjusted Timeline: %d days\\n\", projectTimeline);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a function that receives a to-do list and completes a task. Demonstrate the effect of pass-by-reference on the list.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_TASKS 10\n#define TASK_LENGTH 50\n\nvoid completeTask(char toDoList[MAX_TASKS][TASK_LENGTH], int taskIndex) {\n    if (taskIndex < 0 || taskIndex >= MAX_TASKS || strlen(toDoList[taskIndex]) == 0) {\n        printf(\"Invalid task index.\\n\");\n        return;\n    }\n    printf(\"Completing task: %s\\n\", toDoList[taskIndex]);\n    toDoList[taskIndex][0] = '\\0'; // Mark the task as completed by emptying the string\n}\n\nvoid printToDoList(char toDoList[MAX_TASKS][TASK_LENGTH]) {\n    for (int i = 0; i < MAX_TASKS; i++) {\n        if (strlen(toDoList[i]) > 0)\n            printf(\"%d: %s\\n\", i, toDoList[i]);\n    }\n}\n\nint main() {\n    char toDoList[MAX_TASKS][TASK_LENGTH] = {\n        \"Buy groceries\",\n        \"Call mom\",\n        \"Finish project\",\n        \"Read book\"\n    };\n\n    printf(\"To-Do List before completing task:\\n\");\n    printToDoList(toDoList);\n\n    completeTask(toDoList, 1);\n\n    printf(\"\\nTo-Do List after completing task:\\n\");\n    printToDoList(toDoList);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a function that takes a paint canvas and adds a layer. Discuss the impact of pass-by-reference on the canvas.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_LAYERS 10\n\ntypedef struct {\n    char layers[MAX_LAYERS][50];\n    int layer_count;\n} Canvas;\n\nvoid addLayer(Canvas *canvas, const char *layer) {\n    if (canvas->layer_count < MAX_LAYERS) {\n        strcpy(canvas->layers[canvas->layer_count], layer);\n        canvas->layer_count++;\n    }\n}\n\nvoid printCanvas(const Canvas *canvas) {\n    printf(\"Canvas Layers:\\n\");\n    for (int i = 0; i < canvas->layer_count; i++) {\n        printf(\"%s\\n\", canvas->layers[i]);\n    }\n}\n\nint main() {\n    Canvas myCanvas = { .layer_count = 0 };\n\n    addLayer(&myCanvas, \"Base Layer\");\n    addLayer(&myCanvas, \"First Layer\");\n    addLayer(&myCanvas, \"Second Layer\");\n\n    printCanvas(&myCanvas);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Design a function that accepts a URL list and fetches content. Show the difference in the list when using pass-by-value.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n// Function that attempts to modify the URLs passed by value\nvoid fetchContent(char urls[][100], int size) {\n    for(int i = 0; i < size; i++) {\n        // Attempt to modify the URL\n        strcat(urls[i], \"/fetched\");\n    }\n}\n\nint main() {\n    char urlList[3][100] = {\n        \"http://example.com\",\n        \"http://openai.com\",\n        \"http://github.com\"\n    };\n\n    int size = 3;\n    printf(\"URLs before fetchContent:\\n\");\n    for(int i = 0; i < size; i++) {\n        printf(\"%s\\n\", urlList[i]);\n    }\n\n    fetchContent(urlList, size);\n\n    printf(\"\\nURLs after fetchContent:\\n\");\n    for(int i = 0; i < size; i++) {\n        printf(\"%s\\n\", urlList[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a program where a function receives a game board and resets it. Illustrate the effects of pass-by-reference.",
    "code": "```c\n#include <stdio.h>\n\n#define SIZE 3\n\nvoid resetBoard(char board[SIZE][SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        for (int j = 0; j < SIZE; j++) {\n            board[i][j] = '-';\n        }\n    }\n}\n\nvoid printBoard(char board[SIZE][SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        for (int j = 0; j < SIZE; j++) {\n            printf(\"%c \", board[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n\nint main() {\n    char gameBoard[SIZE][SIZE] = {\n        {'X', 'O', 'X'},\n        {'O', 'X', 'O'},\n        {'X', 'O', 'X'}\n    };\n\n    printf(\"Original Board:\\n\");\n    printBoard(gameBoard);\n\n    resetBoard(gameBoard);\n\n    printf(\"\\nReset Board:\\n\");\n    printBoard(gameBoard);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a function that takes a sound effect and increases its volume. Explain how pass-by-reference affects the original sound.",
    "code": "```c\n#include <stdio.h>\n\nvoid increaseVolume(float *soundEffect, float increaseFactor) {\n    *soundEffect *= increaseFactor;\n}\n\nint main() {\n    float sound = 0.5; // Example sound effect volume\n    float factor = 1.5; // Increase factor\n\n    printf(\"Original Volume: %.2f\\n\", sound);\n    increaseVolume(&sound, factor);\n    printf(\"Increased Volume: %.2f\\n\", sound);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a function that accepts a weather forecast and updates temperature predictions. Discuss the impact of pass-by-reference.",
    "code": "```c\n#include <stdio.h>\n\ntypedef struct {\n    float temperature;\n    float humidity;\n} WeatherForecast;\n\nvoid updateTemperature(WeatherForecast *forecast, float newTemperature) {\n    forecast->temperature = newTemperature;\n}\n\nint main() {\n    WeatherForecast forecast = {25.0, 60.0};\n    printf(\"Original Temperature: %.2f\\n\", forecast.temperature);\n    updateTemperature(&forecast, 30.0);\n    printf(\"Updated Temperature: %.2f\\n\", forecast.temperature);\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a function that receives a system log and extracts error messages. Show how pass-by-value ensures the original log remains unchanged.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_LOG_SIZE 1024\n#define MAX_ERROR_MSGS 100\n\nvoid extractErrors(const char *log, char errorMessages[][MAX_LOG_SIZE], int *errorCount) {\n    const char *errorKeyword = \"ERROR\";\n    char *pos;\n    *errorCount = 0;\n    \n    char logCopy[MAX_LOG_SIZE];\n    strncpy(logCopy, log, MAX_LOG_SIZE);\n    \n    pos = strstr(logCopy, errorKeyword);\n    while (pos != NULL && *errorCount < MAX_ERROR_MSGS) {\n        int msgLength = 0;\n        while (pos[msgLength] != '\\n' && pos[msgLength] != '\\0') {\n            msgLength++;\n        }\n        strncpy(errorMessages[*errorCount], pos, msgLength);\n        errorMessages[*errorCount][msgLength] = '\\0';\n        (*errorCount)++;\n        pos = strstr(pos + msgLength, errorKeyword);\n    }\n}\n\nint main() {\n    const char systemLog[MAX_LOG_SIZE] = \n        \"INFO: System started\\n\"\n        \"ERROR: Failed to load configuration\\n\"\n        \"INFO: Configuration loaded\\n\"\n        \"ERROR: Disk not found\\n\";\n\n    char errorMessages[MAX_ERROR_MSGS][MAX_LOG_SIZE];\n    int errorCount;\n\n    extractErrors(systemLog, errorMessages, &errorCount);\n\n    printf(\"Extracted Error Messages:\\n\");\n    for (int i = 0; i < errorCount; i++) {\n        printf(\"%s\\n\", errorMessages[i]);\n    }\n\n    printf(\"\\nOriginal System Log:\\n%s\", systemLog);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Design a function that accepts a data packet and encrypts it. Demonstrate the effect of pass-by-value on the packet.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\nvoid encryptPacket(char packet[], char encryptedPacket[], int key) {\n    int i;\n    for (i = 0; packet[i] != '\\0'; i++) {\n        encryptedPacket[i] = packet[i] + key;\n    }\n    encryptedPacket[i] = '\\0';\n}\n\nvoid demonstratePassByValue(char packet[], int key) {\n    char encryptedPacket[100];\n    encryptPacket(packet, encryptedPacket, key);\n    printf(\"Original Packet: %s\\n\", packet);\n    printf(\"Encrypted Packet: %s\\n\", encryptedPacket);\n}\n\nint main() {\n    char dataPacket[] = \"SensitiveData\";\n    int encryptionKey = 3;\n    demonstratePassByValue(dataPacket, encryptionKey);\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that takes a website theme and applies a color change. Explain how pass-by-reference affects the original theme.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    char color[20];\n} Theme;\n\nvoid applyColorChange(Theme *theme, const char *newColor) {\n    strcpy(theme->color, newColor);\n}\n\nint main() {\n    Theme websiteTheme;\n    strcpy(websiteTheme.color, \"blue\");\n\n    printf(\"Original color: %s\\n\", websiteTheme.color);\n\n    applyColorChange(&websiteTheme, \"green\");\n\n    printf(\"Updated color: %s\\n\", websiteTheme.color);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a function that accepts a digital signature and verifies it. Discuss the implications of pass-by-value on the signature.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\nint verifySignature(char signature[]) {\n    // Simulated verification process\n    // Normally, you would have complex logic here\n    if (strcmp(signature, \"VALID_SIGNATURE\") == 0) {\n        return 1; // Signature is valid\n    }\n    return 0; // Signature is invalid\n}\n\nint main() {\n    char signature[] = \"VALID_SIGNATURE\";\n    int isValid = verifySignature(signature);\n    \n    if (isValid) {\n        printf(\"Signature is valid.\\n\");\n    } else {\n        printf(\"Signature is invalid.\\n\");\n    }\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Implement a function that receives a robot's path and optimizes it. Illustrate the effects of pass-by-reference on the path.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n// Function to optimize the robot's path\nvoid optimizePath(char *path) {\n    int i, j;\n    int length = strlen(path);\n    \n    // Remove consecutive 'N' and 'S' or 'E' and 'W'\n    for (i = 0, j = 0; i < length; i++) {\n        if (i < length - 1 && \n            ((path[i] == 'N' && path[i + 1] == 'S') || \n             (path[i] == 'S' && path[i + 1] == 'N') ||\n             (path[i] == 'E' && path[i + 1] == 'W') || \n             (path[i] == 'W' && path[i + 1] == 'E'))) {\n            i++; // Skip the next character\n        } else {\n            path[j++] = path[i];\n        }\n    }\n    path[j] = '\\0'; // Null-terminate the optimized path\n}\n\nint main() {\n    char path[] = \"NSEWNEESSWW\";\n    \n    printf(\"Original Path: %s\\n\", path);\n    optimizePath(path);\n    printf(\"Optimized Path: %s\\n\", path);\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Develop a function that takes a music playlist and shuffles it. Demonstrate the impact of pass-by-reference on the playlist.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\nvoid shufflePlaylist(int *playlist, int size) {\n    srand(time(NULL));\n    for (int i = size - 1; i > 0; i--) {\n        int j = rand() % (i + 1);\n        int temp = playlist[i];\n        playlist[i] = playlist[j];\n        playlist[j] = temp;\n    }\n}\n\nvoid printPlaylist(int *playlist, int size) {\n    for (int i = 0; i < size; i++) {\n        printf(\"%d \", playlist[i]);\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    int playlist[] = {1, 2, 3, 4, 5};\n    int size = sizeof(playlist) / sizeof(playlist[0]);\n\n    printf(\"Original playlist:\\n\");\n    printPlaylist(playlist, size);\n\n    shufflePlaylist(playlist, size);\n\n    printf(\"Shuffled playlist:\\n\");\n    printPlaylist(playlist, size);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Design a program where a function receives a social media feed and removes duplicates. Show the changes with pass-by-reference.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_FEED_SIZE 100\n#define MAX_POST_LENGTH 256\n\nvoid removeDuplicates(char feed[][MAX_POST_LENGTH], int *size) {\n    int i, j, k;\n    for (i = 0; i < *size; i++) {\n        for (j = i + 1; j < *size; ) {\n            if (strcmp(feed[i], feed[j]) == 0) {\n                for (k = j; k < *size - 1; k++) {\n                    strcpy(feed[k], feed[k + 1]);\n                }\n                (*size)--;\n            } else {\n                j++;\n            }\n        }\n    }\n}\n\nint main() {\n    char feed[MAX_FEED_SIZE][MAX_POST_LENGTH] = {\n        \"Post about cats\",\n        \"Post about dogs\",\n        \"Post about cats\", // duplicate\n        \"Post about programming\",\n        \"Post about dogs\"  // duplicate\n    };\n    int feedSize = 5;\n\n    printf(\"Original Feed:\\n\");\n    for (int i = 0; i < feedSize; i++) {\n        printf(\"%s\\n\", feed[i]);\n    }\n\n    removeDuplicates(feed, &feedSize);\n\n    printf(\"\\nFeed after removing duplicates:\\n\");\n    for (int i = 0; i < feedSize; i++) {\n        printf(\"%s\\n\", feed[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that takes a coding challenge and adds test cases. Discuss the effects of pass-by-reference on the challenge.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    char description[256];\n    char testCases[5][256];\n    int numTestCases;\n} CodingChallenge;\n\nvoid addTestCases(CodingChallenge *challenge) {\n    strcpy(challenge->testCases[0], \"Test case 1: Input 1, Expected output: X\");\n    strcpy(challenge->testCases[1], \"Test case 2: Input 2, Expected output: Y\");\n    challenge->numTestCases = 2;\n}\n\nvoid printChallenge(const CodingChallenge *challenge) {\n    printf(\"Challenge: %s\\n\", challenge->description);\n    printf(\"Number of test cases: %d\\n\", challenge->numTestCases);\n    for (int i = 0; i < challenge->numTestCases; i++) {\n        printf(\"  %s\\n\", challenge->testCases[i]);\n    }\n}\n\nint main() {\n    CodingChallenge challenge;\n    strcpy(challenge.description, \"Example Coding Challenge\");\n    challenge.numTestCases = 0;\n\n    printf(\"Before adding test cases:\\n\");\n    printChallenge(&challenge);\n\n    addTestCases(&challenge);\n\n    printf(\"\\nAfter adding test cases:\\n\");\n    printChallenge(&challenge);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a function that accepts an animation sequence and reverses it. Explain how pass-by-value ensures the sequence remains unchanged.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\nvoid reverseSequence(const char sequence[], char reversed[], int length) {\n    for (int i = 0; i < length; i++) {\n        reversed[i] = sequence[length - i - 1];\n    }\n    reversed[length] = '\\0';\n}\n\nint main() {\n    const char animationSequence[] = \"ABCDE\";\n    int length = strlen(animationSequence);\n    char reversedSequence[length + 1];\n\n    reverseSequence(animationSequence, reversedSequence, length);\n\n    printf(\"Original Sequence: %s\\n\", animationSequence);\n    printf(\"Reversed Sequence: %s\\n\", reversedSequence);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a function that receives a GPS route and recalculates it. Illustrate the impact of pass-by-reference on the route.",
    "code": "```c\n#include <stdio.h>\n\ntypedef struct {\n    double latitude;\n    double longitude;\n} GPSPoint;\n\ntypedef struct {\n    GPSPoint points[100];\n    int point_count;\n} GPSRoute;\n\n// Function to recalculate route, modifying the original route\nvoid recalculateRoute(GPSRoute *route) {\n    for (int i = 0; i < route->point_count; i++) {\n        route->points[i].latitude += 0.001;\n        route->points[i].longitude += 0.001;\n    }\n}\n\nvoid printRoute(const GPSRoute *route) {\n    for (int i = 0; i < route->point_count; i++) {\n        printf(\"Point %d: Latitude = %f, Longitude = %f\\n\",\n               i + 1, route->points[i].latitude, route->points[i].longitude);\n    }\n}\n\nint main() {\n    GPSRoute route = {\n        .points = {\n            {45.0, -122.0},\n            {45.1, -122.1},\n            {45.2, -122.2},\n        },\n        .point_count = 3\n    };\n\n    printf(\"Original Route:\\n\");\n    printRoute(&route);\n\n    recalculateRoute(&route);\n\n    printf(\"\\nRecalculated Route:\\n\");\n    printRoute(&route);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a function that takes a chat history and censors inappropriate language. Show the effect of pass-by-reference on the history.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_HISTORY 1000\n#define BAD_WORD \"badword\"\n#define CENSOR \"***\"\n\n// Function to censor inappropriate language in chat history\nvoid censorChatHistory(char *history) {\n    char *ptr = strstr(history, BAD_WORD);\n    while (ptr != NULL) {\n        strncpy(ptr, CENSOR, strlen(CENSOR));\n        ptr = strstr(ptr + strlen(CENSOR), BAD_WORD);\n    }\n}\n\nint main() {\n    char chatHistory[MAX_HISTORY] = \"Hello, this is a chat with a badword. Another badword here.\";\n\n    printf(\"Before Censoring:\\n%s\\n\", chatHistory);\n\n    censorChatHistory(chatHistory);\n\n    printf(\"After Censoring:\\n%s\\n\", chatHistory);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Design a function that accepts a lighting setup and adjusts brightness. Discuss the changes when the setup is passed by reference.",
    "code": "```c\n#include <stdio.h>\n\n// Define a structure for the lighting setup\ntypedef struct {\n    int brightness;\n    int colorTemperature;\n} LightingSetup;\n\n// Function to adjust brightness, passing the setup by reference\nvoid adjustBrightness(LightingSetup *setup, int newBrightness) {\n    setup->brightness = newBrightness;\n}\n\nint main() {\n    LightingSetup myLighting = {75, 6500};\n    \n    printf(\"Original brightness: %d\\n\", myLighting.brightness);\n    \n    // Adjust brightness by passing the setup by reference\n    adjustBrightness(&myLighting, 90);\n    \n    printf(\"Adjusted brightness: %d\\n\", myLighting.brightness);\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Write a program where a function receives a VR environment and changes the scenery. Demonstrate the effects of pass-by-reference.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    char scenery[50];\n} VREnvironment;\n\nvoid changeScenery(VREnvironment *env) {\n    strcpy(env->scenery, \"Ocean View\");\n}\n\nint main() {\n    VREnvironment vrEnv;\n    strcpy(vrEnv.scenery, \"Mountain View\");\n\n    printf(\"Before change: %s\\n\", vrEnv.scenery);\n    changeScenery(&vrEnv);\n    printf(\"After change: %s\\n\", vrEnv.scenery);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a function that takes a blockchain ledger and adds a block. Explain how pass-by-reference affects the ledger.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct Block {\n    int data;\n    struct Block* next;\n} Block;\n\ntypedef struct Blockchain {\n    Block* head;\n} Blockchain;\n\n// Function to add a block to the blockchain ledger\nvoid addBlock(Blockchain* ledger, int data) {\n    Block* newBlock = (Block*)malloc(sizeof(Block));\n    if (newBlock == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        return;\n    }\n    newBlock->data = data;\n    newBlock->next = ledger->head;\n    ledger->head = newBlock;\n}\n\n// Function to print the blockchain\nvoid printBlockchain(const Blockchain* ledger) {\n    Block* current = ledger->head;\n    while (current != NULL) {\n        printf(\"Block data: %d\\n\", current->data);\n        current = current->next;\n    }\n}\n\nint main() {\n    Blockchain ledger = { NULL };\n\n    addBlock(&ledger, 1);\n    addBlock(&ledger, 2);\n    addBlock(&ledger, 3);\n\n    printBlockchain(&ledger);\n\n    // Free the allocated memory\n    Block* current = ledger.head;\n    while (current != NULL) {\n        Block* temp = current;\n        current = current->next;\n        free(temp);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a function that accepts a network packet and alters its headers. Discuss the implications of pass-by-value on the packet.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_HEADER_SIZE 100\n\ntypedef struct {\n    char headers[MAX_HEADER_SIZE];\n    char data[256];\n} NetworkPacket;\n\nvoid alterHeaders(NetworkPacket packet) {\n    // Attempt to alter headers\n    strcpy(packet.headers, \"New Header Content\");\n    printf(\"Inside function: Headers = %s\\n\", packet.headers);\n}\n\nint main() {\n    NetworkPacket packet;\n\n    // Original header content\n    strcpy(packet.headers, \"Original Header\");\n    strcpy(packet.data, \"Some packet data\");\n\n    printf(\"Before function call: Headers = %s\\n\", packet.headers);\n\n    // Pass packet by value\n    alterHeaders(packet);\n\n    printf(\"After function call: Headers = %s\\n\", packet.headers);\n\n    return 0;\n}\n```"
  }
]