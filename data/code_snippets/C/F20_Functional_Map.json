[
  {
    "task": "Convert a list of temperatures from Celsius to Fahrenheit using a map function.",
    "code": "```c\n#include <stdio.h>\n\n#define SIZE 5\n\nvoid map(double (*func)(double), double *input, double *output, int size) {\n    for (int i = 0; i < size; i++) {\n        output[i] = func(input[i]);\n    }\n}\n\ndouble celsiusToFahrenheit(double celsius) {\n    return (celsius * 9.0 / 5.0) + 32.0;\n}\n\nint main() {\n    double celsiusTemperatures[SIZE] = {0.0, 20.0, 37.0, 100.0, -40.0};\n    double fahrenheitTemperatures[SIZE];\n\n    map(celsiusToFahrenheit, celsiusTemperatures, fahrenheitTemperatures, SIZE);\n\n    for (int i = 0; i < SIZE; i++) {\n        printf(\"%.2f C = %.2f F\\n\", celsiusTemperatures[i], fahrenheitTemperatures[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Use map to convert a list of lowercase words to uppercase.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nvoid to_uppercase(char *str) {\n    for (int i = 0; str[i]; i++) {\n        str[i] = toupper(str[i]);\n    }\n}\n\nvoid map(char **array, size_t length, void (*func)(char *)) {\n    for (size_t i = 0; i < length; i++) {\n        func(array[i]);\n    }\n}\n\nint main() {\n    char *words[] = {\"hello\", \"world\", \"map\", \"function\"};\n    size_t length = sizeof(words) / sizeof(words[0]);\n\n    map(words, length, to_uppercase);\n\n    for (size_t i = 0; i < length; i++) {\n        printf(\"%s\\n\", words[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Apply map to add a prefix to each string in a list of filenames.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Function to add a prefix to a filename\nchar *add_prefix(const char *prefix, const char *filename) {\n    size_t prefix_len = strlen(prefix);\n    size_t filename_len = strlen(filename);\n    char *result = malloc(prefix_len + filename_len + 1); // +1 for the null terminator\n    if (result == NULL) {\n        perror(\"malloc\");\n        exit(EXIT_FAILURE);\n    }\n    strcpy(result, prefix);\n    strcat(result, filename);\n    return result;\n}\n\n// Function to map over an array of filenames\nvoid map_filenames(char **filenames, size_t count, const char *prefix, char **output) {\n    for (size_t i = 0; i < count; ++i) {\n        output[i] = add_prefix(prefix, filenames[i]);\n    }\n}\n\nint main() {\n    const char *prefix = \"prefix_\";\n    char *filenames[] = {\"file1.txt\", \"file2.txt\", \"file3.txt\"};\n    size_t count = sizeof(filenames) / sizeof(filenames[0]);\n    char **prefixed_filenames = malloc(count * sizeof(char *));\n    if (prefixed_filenames == NULL) {\n        perror(\"malloc\");\n        return EXIT_FAILURE;\n    }\n\n    map_filenames(filenames, count, prefix, prefixed_filenames);\n\n    for (size_t i = 0; i < count; ++i) {\n        printf(\"%s\\n\", prefixed_filenames[i]);\n        free(prefixed_filenames[i]);\n    }\n    free(prefixed_filenames);\n\n    return EXIT_SUCCESS;\n}\n```"
  },
  {
    "task": "Transform a list of numbers by squaring each element with a map function.",
    "code": "```c\n#include <stdio.h>\n\n#define SIZE 5\n\nvoid square(int *num) {\n    *num = (*num) * (*num);\n}\n\nvoid map(int *arr, int size, void (*func)(int *)) {\n    for (int i = 0; i < size; i++) {\n        func(&arr[i]);\n    }\n}\n\nint main() {\n    int numbers[SIZE] = {1, 2, 3, 4, 5};\n\n    map(numbers, SIZE, square);\n\n    for (int i = 0; i < SIZE; i++) {\n        printf(\"%d \", numbers[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Convert a list of integers to their string representations using map.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\nchar** mapIntToString(int* array, size_t size) {\n    char** result = (char**)malloc(size * sizeof(char*));\n    for (size_t i = 0; i < size; i++) {\n        result[i] = (char*)malloc(12 * sizeof(char)); // Enough to hold any int\n        sprintf(result[i], \"%d\", array[i]);\n    }\n    return result;\n}\n\nint main() {\n    int numbers[] = {1, 2, 3, 4, 5};\n    size_t size = sizeof(numbers) / sizeof(numbers[0]);\n    char** strings = mapIntToString(numbers, size);\n\n    for (size_t i = 0; i < size; i++) {\n        printf(\"%s\\n\", strings[i]);\n        free(strings[i]);\n    }\n    free(strings);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Use map to compute the length of each string in a list of sentences.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid map(int (*func)(const char *), const char **array, int *results, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        results[i] = func(array[i]);\n    }\n}\n\nint string_length(const char *str) {\n    return strlen(str);\n}\n\nint main() {\n    const char *sentences[] = {\n        \"Hello, World!\",\n        \"Functional programming in C\",\n        \"Using map to compute lengths\",\n        \"This is a test sentence\"\n    };\n    size_t size = sizeof(sentences) / sizeof(sentences[0]);\n    int *lengths = malloc(size * sizeof(int));\n\n    map(string_length, sentences, lengths, size);\n\n    for (size_t i = 0; i < size; ++i) {\n        printf(\"Length of sentence %zu: %d\\n\", i + 1, lengths[i]);\n    }\n\n    free(lengths);\n    return 0;\n}\n```"
  },
  {
    "task": "Apply a discount to a list of prices using a map function.",
    "code": "```c\n#include <stdio.h>\n\n#define SIZE 5\n\ndouble applyDiscount(double price) {\n    return price * 0.9; // Applying a 10% discount\n}\n\nvoid map(double (*func)(double), double *prices, double *discountedPrices, int size) {\n    for (int i = 0; i < size; ++i) {\n        discountedPrices[i] = func(prices[i]);\n    }\n}\n\nint main() {\n    double prices[SIZE] = {100.0, 200.0, 300.0, 400.0, 500.0};\n    double discountedPrices[SIZE];\n\n    map(applyDiscount, prices, discountedPrices, SIZE);\n\n    for (int i = 0; i < SIZE; ++i) {\n        printf(\"Original Price: %.2f, Discounted Price: %.2f\\n\", prices[i], discountedPrices[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Extract the first element from each tuple in a list of tuples with map.",
    "code": "```c\n#include <stdio.h>\n\n#define NUM_TUPLES 3\n\ntypedef struct {\n    int first;\n    int second;\n} Tuple;\n\nint extractFirst(Tuple tuple) {\n    return tuple.first;\n}\n\nvoid map(int (*func)(Tuple), Tuple *input, int *output, int size) {\n    for (int i = 0; i < size; i++) {\n        output[i] = func(input[i]);\n    }\n}\n\nint main() {\n    Tuple tuples[NUM_TUPLES] = {{1, 2}, {3, 4}, {5, 6}};\n    int firstElements[NUM_TUPLES];\n\n    map(extractFirst, tuples, firstElements, NUM_TUPLES);\n\n    for (int i = 0; i < NUM_TUPLES; i++) {\n        printf(\"%d\\n\", firstElements[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Use map to round a list of floating-point numbers to two decimal places.",
    "code": "```c\n#include <stdio.h>\n#include <math.h>\n\n#define SIZE 5\n\nvoid map(double (*func)(double), double *arr, double *result, int size) {\n    for (int i = 0; i < size; i++) {\n        result[i] = func(arr[i]);\n    }\n}\n\ndouble roundToTwoDecimals(double num) {\n    return round(num * 100) / 100;\n}\n\nint main() {\n    double numbers[SIZE] = {3.14159, 2.71828, 1.41421, 1.73205, 0.57721};\n    double roundedNumbers[SIZE];\n\n    map(roundToTwoDecimals, numbers, roundedNumbers, SIZE);\n\n    for (int i = 0; i < SIZE; i++) {\n        printf(\"%.2f\\n\", roundedNumbers[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Capitalize the first letter of each word in a list of names using map.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\n#define MAX_NAMES 100\n#define MAX_LENGTH 100\n\nvoid capitalizeFirstLetter(char *name) {\n    if (name[0] != '\\0') {\n        name[0] = toupper(name[0]);\n    }\n}\n\nvoid map(char names[][MAX_LENGTH], int size, void (*func)(char *)) {\n    for (int i = 0; i < size; i++) {\n        func(names[i]);\n    }\n}\n\nint main() {\n    char names[MAX_NAMES][MAX_LENGTH] = {\n        \"alice\", \"bob\", \"charlie\", \"dave\"\n    };\n    int size = 4;\n\n    map(names, size, capitalizeFirstLetter);\n\n    for (int i = 0; i < size; i++) {\n        printf(\"%s\\n\", names[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Convert a list of JSON strings to corresponding dictionary objects with map.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <jansson.h>\n\n#define NUM_JSON_STRINGS 3\n\n// A function to parse JSON string to a JSON object\njson_t *parse_json(const char *json_str) {\n    json_error_t error;\n    json_t *json_obj = json_loads(json_str, 0, &error);\n    if (!json_obj) {\n        fprintf(stderr, \"error: on line %d: %s\\n\", error.line, error.text);\n        return NULL;\n    }\n    return json_obj;\n}\n\n// A function to map a parsing function to each JSON string\nvoid map_json_parse(const char **json_strings, json_t **json_objects, size_t num_strings) {\n    for (size_t i = 0; i < num_strings; i++) {\n        json_objects[i] = parse_json(json_strings[i]);\n    }\n}\n\nint main() {\n    const char *json_strings[NUM_JSON_STRINGS] = {\n        \"{\\\"name\\\": \\\"John\\\", \\\"age\\\": 30}\",\n        \"{\\\"name\\\": \\\"Jane\\\", \\\"age\\\": 25}\",\n        \"{\\\"name\\\": \\\"Doe\\\", \\\"age\\\": 22}\"\n    };\n\n    json_t *json_objects[NUM_JSON_STRINGS];\n\n    // Map the parse_json function to each JSON string\n    map_json_parse(json_strings, json_objects, NUM_JSON_STRINGS);\n\n    // Example usage: print the name from each JSON object\n    for (size_t i = 0; i < NUM_JSON_STRINGS; i++) {\n        if (json_objects[i]) {\n            json_t *name = json_object_get(json_objects[i], \"name\");\n            if (json_is_string(name)) {\n                printf(\"Name: %s\\n\", json_string_value(name));\n            }\n            json_decref(json_objects[i]);\n        }\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Use map to double the value of each number in a list.",
    "code": "```c\n#include <stdio.h>\n\n#define ARRAY_SIZE 5\n\nvoid map(int *array, int size, int (*func)(int)) {\n    for (int i = 0; i < size; i++) {\n        array[i] = func(array[i]);\n    }\n}\n\nint doubleValue(int x) {\n    return x * 2;\n}\n\nint main() {\n    int numbers[ARRAY_SIZE] = {1, 2, 3, 4, 5};\n\n    map(numbers, ARRAY_SIZE, doubleValue);\n\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        printf(\"%d \", numbers[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Transform a list of RGB tuples to hexadecimal color codes using map.",
    "code": "```c\n#include <stdio.h>\n\ntypedef struct {\n    int r, g, b;\n} RGB;\n\nchar* rgb_to_hex(RGB rgb) {\n    static char hex[8];\n    snprintf(hex, sizeof(hex), \"#%02X%02X%02X\", rgb.r, rgb.g, rgb.b);\n    return hex;\n}\n\nvoid map_rgb_to_hex(RGB* rgb_array, char** hex_array, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        hex_array[i] = rgb_to_hex(rgb_array[i]);\n    }\n}\n\nint main() {\n    RGB rgb_list[] = { {255, 0, 0}, {0, 255, 0}, {0, 0, 255} };\n    size_t size = sizeof(rgb_list) / sizeof(rgb_list[0]);\n    char* hex_list[size];\n\n    map_rgb_to_hex(rgb_list, hex_list, size);\n\n    for (size_t i = 0; i < size; i++) {\n        printf(\"%s\\n\", hex_list[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Use map to compute the factorial of each number in a list.",
    "code": "```c\n#include <stdio.h>\n\nint factorial(int n) {\n    if (n == 0) return 1;\n    int result = 1;\n    for (int i = 1; i <= n; i++) {\n        result *= i;\n    }\n    return result;\n}\n\nvoid map(int (*func)(int), int *input, int *output, int length) {\n    for (int i = 0; i < length; i++) {\n        output[i] = func(input[i]);\n    }\n}\n\nint main() {\n    int numbers[] = {1, 2, 3, 4, 5};\n    int length = sizeof(numbers) / sizeof(numbers[0]);\n    int factorials[length];\n\n    map(factorial, numbers, factorials, length);\n\n    for (int i = 0; i < length; i++) {\n        printf(\"%d \", factorials[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Translate a list of English words to Spanish using a map function.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n#define SIZE 5\n\nconst char* translateWord(const char* word) {\n    if (strcmp(word, \"hello\") == 0) return \"hola\";\n    if (strcmp(word, \"world\") == 0) return \"mundo\";\n    if (strcmp(word, \"friend\") == 0) return \"amigo\";\n    if (strcmp(word, \"computer\") == 0) return \"computadora\";\n    if (strcmp(word, \"code\") == 0) return \"c\u00f3digo\";\n    return word;\n}\n\nvoid map(const char* input[], const char* output[], int size, const char* (*func)(const char*)) {\n    for (int i = 0; i < size; ++i) {\n        output[i] = func(input[i]);\n    }\n}\n\nint main() {\n    const char* englishWords[SIZE] = {\"hello\", \"world\", \"friend\", \"computer\", \"code\"};\n    const char* spanishWords[SIZE];\n\n    map(englishWords, spanishWords, SIZE, translateWord);\n\n    for (int i = 0; i < SIZE; ++i) {\n        printf(\"%s -> %s\\n\", englishWords[i], spanishWords[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Apply a map function to format a list of dates from one format to another.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n#include <time.h>\n\n#define NUM_DATES 3\n#define INPUT_FORMAT \"%d-%m-%Y\"\n#define OUTPUT_FORMAT \"%Y/%m/%d\"\n\nvoid format_date(const char *input_date, char *output_date) {\n    struct tm tm;\n    strptime(input_date, INPUT_FORMAT, &tm);\n    strftime(output_date, 11, OUTPUT_FORMAT, &tm);\n}\n\nvoid map_dates(const char input_dates[][11], char output_dates[][11], int num_dates) {\n    for (int i = 0; i < num_dates; ++i) {\n        format_date(input_dates[i], output_dates[i]);\n    }\n}\n\nint main() {\n    const char input_dates[NUM_DATES][11] = {\n        \"01-12-2023\",\n        \"15-01-2024\",\n        \"03-03-2025\"\n    };\n    char output_dates[NUM_DATES][11];\n    \n    map_dates(input_dates, output_dates, NUM_DATES);\n    \n    for (int i = 0; i < NUM_DATES; ++i) {\n        printf(\"%s -> %s\\n\", input_dates[i], output_dates[i]);\n    }\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Use map to check if each number in a list is even, returning a list of booleans.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint is_even(int n) {\n    return n % 2 == 0;\n}\n\nint* map(int (*func)(int), int* arr, int size) {\n    int* result = (int*)malloc(size * sizeof(int));\n    for (int i = 0; i < size; i++) {\n        result[i] = func(arr[i]);\n    }\n    return result;\n}\n\nint main() {\n    int numbers[] = {1, 2, 3, 4, 5, 6};\n    int size = sizeof(numbers) / sizeof(numbers[0]);\n    int* is_even_list = map(is_even, numbers, size);\n\n    for (int i = 0; i < size; i++) {\n        printf(\"%s \", is_even_list[i] ? \"true\" : \"false\");\n    }\n\n    free(is_even_list);\n    return 0;\n}\n```"
  },
  {
    "task": "Convert a list of binary strings to decimal numbers using map.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint binary_to_decimal(const char *binary_str) {\n    return (int)strtol(binary_str, NULL, 2);\n}\n\nvoid map(const char *binary_strs[], int *decimals, size_t len) {\n    for (size_t i = 0; i < len; ++i) {\n        decimals[i] = binary_to_decimal(binary_strs[i]);\n    }\n}\n\nint main() {\n    const char *binary_strs[] = {\"101\", \"110\", \"111\"};\n    size_t len = sizeof(binary_strs) / sizeof(binary_strs[0]);\n    int decimals[len];\n\n    map(binary_strs, decimals, len);\n\n    for (size_t i = 0; i < len; ++i) {\n        printf(\"%d\\n\", decimals[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Use map to append a domain name to a list of user names to create email addresses.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* appendDomain(const char *username, const char *domain) {\n    size_t len = strlen(username) + strlen(domain) + 1;\n    char *email = (char *)malloc(len * sizeof(char));\n    if (email != NULL) {\n        strcpy(email, username);\n        strcat(email, domain);\n    }\n    return email;\n}\n\nchar** map(char **usernames, size_t count, const char *domain) {\n    char **emails = (char **)malloc(count * sizeof(char *));\n    if (emails != NULL) {\n        for (size_t i = 0; i < count; ++i) {\n            emails[i] = appendDomain(usernames[i], domain);\n        }\n    }\n    return emails;\n}\n\nint main() {\n    char *usernames[] = {\"alice\", \"bob\", \"charlie\"};\n    size_t count = sizeof(usernames) / sizeof(usernames[0]);\n    const char *domain = \"@example.com\";\n    \n    char **emails = map(usernames, count, domain);\n    for (size_t i = 0; i < count; ++i) {\n        printf(\"%s\\n\", emails[i]);\n        free(emails[i]);\n    }\n    free(emails);\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Calculate the area of each circle in a list of radii using a map function.",
    "code": "```c\n#include <stdio.h>\n#define PI 3.14159265358979323846\n\nvoid map(double radii[], double areas[], int size, double (*func)(double)) {\n    for (int i = 0; i < size; i++) {\n        areas[i] = func(radii[i]);\n    }\n}\n\ndouble calculate_area(double radius) {\n    return PI * radius * radius;\n}\n\nint main() {\n    double radii[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    int size = sizeof(radii) / sizeof(radii[0]);\n    double areas[size];\n\n    map(radii, areas, size, calculate_area);\n\n    for (int i = 0; i < size; i++) {\n        printf(\"Circle with radius %.2f has area %.2f\\n\", radii[i], areas[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Use map to strip whitespace from the start and end of each string in a list.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar *trim_whitespace(char *str) {\n    char *end;\n\n    // Trim leading space\n    while (isspace((unsigned char)*str)) str++;\n\n    if (*str == 0)  // All spaces?\n        return str;\n\n    // Trim trailing space\n    end = str + strlen(str) - 1;\n    while (end > str && isspace((unsigned char)*end)) end--;\n\n    // Null terminate after last non-space character\n    *(end + 1) = '\\0';\n\n    return str;\n}\n\nvoid map(char **array, size_t size, char *(*func)(char *)) {\n    for (size_t i = 0; i < size; ++i) {\n        array[i] = func(array[i]);\n    }\n}\n\nint main() {\n    char *str_list[] = {\"  hello  \", \"  world \", \" test \"};\n    size_t list_size = sizeof(str_list) / sizeof(str_list[0]);\n\n    map(str_list, list_size, trim_whitespace);\n\n    for (size_t i = 0; i < list_size; ++i) {\n        printf(\"'%s'\\n\", str_list[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Apply map to replace spaces with underscores in a list of file paths.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\nvoid replace_space_with_underscore(char *path) {\n    for (int i = 0; path[i] != '\\0'; i++) {\n        if (path[i] == ' ') {\n            path[i] = '_';\n        }\n    }\n}\n\nint main() {\n    char *file_paths[] = {\n        \"file one.txt\",\n        \"another file.doc\",\n        \"some directory/file name.pdf\",\n    };\n    int num_paths = sizeof(file_paths) / sizeof(file_paths[0]);\n\n    for (int i = 0; i < num_paths; i++) {\n        replace_space_with_underscore(file_paths[i]);\n        printf(\"%s\\n\", file_paths[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Convert a list of mixed-case strings to title case using map.",
    "code": "```c\n#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\n#define NUM_STRINGS 3\n#define MAX_STRING_LENGTH 100\n\nvoid toTitleCase(char *str) {\n    int i;\n    int new_word = 1;\n    for (i = 0; str[i] != '\\0'; i++) {\n        if (isspace(str[i])) {\n            new_word = 1;\n        } else if (new_word) {\n            str[i] = toupper(str[i]);\n            new_word = 0;\n        } else {\n            str[i] = tolower(str[i]);\n        }\n    }\n}\n\nvoid map(char *strings[], int size, void (*func)(char *)) {\n    for (int i = 0; i < size; i++) {\n        func(strings[i]);\n    }\n}\n\nint main() {\n    char *strings[NUM_STRINGS] = {\"hello world\", \"cOde in c\", \"Functional MAP\"};\n    map(strings, NUM_STRINGS, toTitleCase);\n    \n    for (int i = 0; i < NUM_STRINGS; i++) {\n        printf(\"%s\\n\", strings[i]);\n    }\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Use map to filter out only the digits from a list of mixed alphanumeric strings.",
    "code": "```c\n#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\n#define MAX_STR_LEN 100\n\nvoid filter_digits(char *input, char *output) {\n    while (*input) {\n        if (isdigit(*input)) {\n            *output++ = *input;\n        }\n        input++;\n    }\n    *output = '\\0';\n}\n\nint main() {\n    char *inputs[] = {\"abc123\", \"4d5e6f\", \"789xyz\", \"no_digits\"};\n    char output[MAX_STR_LEN];\n    size_t n = sizeof(inputs) / sizeof(inputs[0]);\n    \n    for (size_t i = 0; i < n; i++) {\n        filter_digits(inputs[i], output);\n        printf(\"Digits from '%s': %s\\n\", inputs[i], output);\n    }\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Apply map to convert a list of Unix timestamps to readable date strings.",
    "code": "```c\n#include <stdio.h>\n#include <time.h>\n\n#define SIZE 5\n\nvoid map_unix_to_date(time_t *timestamps, char date_strings[SIZE][20], int size) {\n    for (int i = 0; i < size; i++) {\n        struct tm *tm_info = localtime(&timestamps[i]);\n        strftime(date_strings[i], 20, \"%Y-%m-%d %H:%M:%S\", tm_info);\n    }\n}\n\nint main() {\n    time_t timestamps[SIZE] = {1609459200, 1612137600, 1614556800, 1617235200, 1619827200};\n    char date_strings[SIZE][20];\n\n    map_unix_to_date(timestamps, date_strings, SIZE);\n\n    for (int i = 0; i < SIZE; i++) {\n        printf(\"%s\\n\", date_strings[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Transform a list of dictionary objects by extracting a specific key's value using map.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    char *key;\n    char *value;\n} Dictionary;\n\nchar *extract_key_value(Dictionary *dict, const char *key) {\n    if (strcmp(dict->key, key) == 0) {\n        return dict->value;\n    }\n    return NULL;\n}\n\nvoid map(Dictionary *dictArray, char **resultArray, int size, const char *key) {\n    for (int i = 0; i < size; ++i) {\n        resultArray[i] = extract_key_value(&dictArray[i], key);\n    }\n}\n\nint main() {\n    Dictionary dictArray[] = {\n        {\"name\", \"Alice\"},\n        {\"age\", \"30\"},\n        {\"name\", \"Bob\"},\n        {\"age\", \"25\"}\n    };\n\n    int dictSize = sizeof(dictArray) / sizeof(Dictionary);\n    char *resultArray[dictSize];\n\n    map(dictArray, resultArray, dictSize, \"name\");\n\n    for (int i = 0; i < dictSize; ++i) {\n        if (resultArray[i] != NULL) {\n            printf(\"%s\\n\", resultArray[i]);\n        }\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Use map to compute the cube of each number in a list.",
    "code": "```c\n#include <stdio.h>\n\nvoid map(int *arr, int size, int (*func)(int)) {\n    for (int i = 0; i < size; i++) {\n        arr[i] = func(arr[i]);\n    }\n}\n\nint cube(int x) {\n    return x * x * x;\n}\n\nint main() {\n    int numbers[] = {1, 2, 3, 4, 5};\n    int size = sizeof(numbers) / sizeof(numbers[0]);\n\n    map(numbers, size, cube);\n\n    for (int i = 0; i < size; i++) {\n        printf(\"%d \", numbers[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Translate a list of URLs to their respective domain names using a map function.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Function to extract domain name from URL\nchar* get_domain(const char* url) {\n    char* domain_start = strstr(url, \"://\");\n    if (!domain_start) {\n        domain_start = (char*)url;\n    } else {\n        domain_start += 3;\n    }\n    char* domain_end = strchr(domain_start, '/');\n    size_t length = domain_end ? (size_t)(domain_end - domain_start) : strlen(domain_start);\n    char* domain = (char*)malloc(length + 1);\n    strncpy(domain, domain_start, length);\n    domain[length] = '\\0';\n    return domain;\n}\n\n// Function to apply map operation\nchar** map_urls_to_domains(char* urls[], size_t size) {\n    char** domains = (char**)malloc(size * sizeof(char*));\n    for (size_t i = 0; i < size; i++) {\n        domains[i] = get_domain(urls[i]);\n    }\n    return domains;\n}\n\n// Main function to demonstrate the feature\nint main() {\n    char* urls[] = {\n        \"http://example.com/path\",\n        \"https://www.google.com/search\",\n        \"ftp://ftp.example.org/resource\",\n        \"https://openai.com\"\n    };\n    size_t size = sizeof(urls) / sizeof(urls[0]);\n\n    char** domains = map_urls_to_domains(urls, size);\n\n    for (size_t i = 0; i < size; i++) {\n        printf(\"Domain: %s\\n\", domains[i]);\n        free(domains[i]);\n    }\n    free(domains);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Use map to generate HTML list items from a list of text strings.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar *map(const char *str) {\n    char *result = (char *)malloc(strlen(str) + 11);\n    sprintf(result, \"<li>%s</li>\", str);\n    return result;\n}\n\nint main() {\n    const char *texts[] = {\"Item 1\", \"Item 2\", \"Item 3\"};\n    size_t size = sizeof(texts) / sizeof(texts[0]);\n    char **htmlItems = (char **)malloc(size * sizeof(char *));\n    \n    for (size_t i = 0; i < size; i++) {\n        htmlItems[i] = map(texts[i]);\n    }\n    \n    for (size_t i = 0; i < size; i++) {\n        printf(\"%s\\n\", htmlItems[i]);\n        free(htmlItems[i]);\n    }\n    \n    free(htmlItems);\n    return 0;\n}\n```"
  },
  {
    "task": "Convert a list of polar coordinates to Cartesian coordinates using map.",
    "code": "```c\n#include <stdio.h>\n#include <math.h>\n\ntypedef struct {\n    double r;\n    double theta;\n} Polar;\n\ntypedef struct {\n    double x;\n    double y;\n} Cartesian;\n\nCartesian polarToCartesian(Polar p) {\n    Cartesian c;\n    c.x = p.r * cos(p.theta);\n    c.y = p.r * sin(p.theta);\n    return c;\n}\n\nvoid map(Polar polars[], Cartesian cartesians[], int size, Cartesian (*func)(Polar)) {\n    for (int i = 0; i < size; i++) {\n        cartesians[i] = func(polars[i]);\n    }\n}\n\nint main() {\n    Polar polars[] = {{1.0, 0.0}, {2.0, M_PI / 4}, {3.0, M_PI / 2}};\n    int size = sizeof(polars) / sizeof(polars[0]);\n    Cartesian cartesians[size];\n\n    map(polars, cartesians, size, polarToCartesian);\n\n    for (int i = 0; i < size; i++) {\n        printf(\"Polar (r=%f, theta=%f) -> Cartesian (x=%f, y=%f)\\n\",\n               polars[i].r, polars[i].theta, cartesians[i].x, cartesians[i].y);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Use map to decode a list of Base64 encoded strings.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <openssl/evp.h>\n\nchar *decode_base64(const char *input) {\n    BIO *b64, *bmem;\n    size_t len = strlen(input);\n    char *buffer = (char *)malloc(len);\n    if (buffer == NULL) {\n        return NULL;\n    }\n\n    b64 = BIO_new(BIO_f_base64());\n    bmem = BIO_new_mem_buf(input, len);\n    bmem = BIO_push(b64, bmem);\n    BIO_set_flags(bmem, BIO_FLAGS_BASE64_NO_NL);\n\n    int decoded_length = BIO_read(bmem, buffer, len);\n    buffer[decoded_length] = '\\0';\n\n    BIO_free_all(bmem);\n\n    return buffer;\n}\n\nvoid map_base64_decoder(char *encoded_strings[], char *decoded_strings[], size_t count) {\n    for (size_t i = 0; i < count; i++) {\n        decoded_strings[i] = decode_base64(encoded_strings[i]);\n    }\n}\n\nint main() {\n    char *encoded_strings[] = {\n        \"SGVsbG8gd29ybGQ=\",\n        \"Q29kZSBnZW5lcmF0aW9u\",\n        \"VHJhbnNsYXRpb24gdGFzaw==\"\n    };\n    size_t count = sizeof(encoded_strings) / sizeof(encoded_strings[0]);\n    char *decoded_strings[count];\n\n    map_base64_decoder(encoded_strings, decoded_strings, count);\n\n    for (size_t i = 0; i < count; i++) {\n        printf(\"Decoded string: %s\\n\", decoded_strings[i]);\n        free(decoded_strings[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Convert a list of English sentences to Pig Latin using a map function.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n// Function to convert a single word to Pig Latin\nchar* convertToPigLatin(const char* word) {\n    size_t len = strlen(word);\n    char* pigLatinWord = (char*)malloc((len + 3) * sizeof(char)); // \"ay\" + '\\0' = 3 extra chars\n    if (len > 0) {\n        if (strchr(\"aeiouAEIOU\", word[0])) {\n            snprintf(pigLatinWord, len + 3, \"%sway\", word);\n        } else {\n            snprintf(pigLatinWord, len + 3, \"%s%cay\", word + 1, tolower(word[0]));\n        }\n    }\n    return pigLatinWord;\n}\n\n// Function to tokenize a sentence and convert each word to Pig Latin\nchar* processSentence(const char* sentence) {\n    char* result = (char*)malloc(1024 * sizeof(char)); // Arbitrary large size for demonstration\n    char* sentenceCopy = strdup(sentence);\n    char* token = strtok(sentenceCopy, \" \");\n    result[0] = '\\0';\n\n    while (token != NULL) {\n        char* pigLatinWord = convertToPigLatin(token);\n        strcat(result, pigLatinWord);\n        strcat(result, \" \");\n        free(pigLatinWord);\n        token = strtok(NULL, \" \");\n    }\n    free(sentenceCopy);\n    return result;\n}\n\n// Function to map over a list of sentences\nvoid mapSentencesToPigLatin(char** sentences, int count) {\n    for (int i = 0; i < count; ++i) {\n        char* pigLatinSentence = processSentence(sentences[i]);\n        printf(\"Pig Latin: %s\\n\", pigLatinSentence);\n        free(pigLatinSentence);\n    }\n}\n\nint main() {\n    char* sentences[] = {\n        \"Hello world\",\n        \"This is a test\",\n        \"Pig Latin is fun\"\n    };\n    int count = sizeof(sentences) / sizeof(sentences[0]);\n    mapSentencesToPigLatin(sentences, count);\n    return 0;\n}\n```"
  },
  {
    "task": "Use map to anonymize a list of email addresses by masking them.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_EMAILS 10\n#define MAX_EMAIL_LENGTH 100\n\nvoid maskEmail(char* email) {\n    char* atSign = strchr(email, '@');\n    if (atSign != NULL) {\n        for (char* p = email + 1; p < atSign - 1; ++p) {\n            *p = '*';\n        }\n    }\n}\n\nvoid map(char emails[][MAX_EMAIL_LENGTH], int size, void (*func)(char*)) {\n    for (int i = 0; i < size; ++i) {\n        func(emails[i]);\n    }\n}\n\nint main() {\n    char emails[MAX_EMAILS][MAX_EMAIL_LENGTH] = {\n        \"example1@gmail.com\",\n        \"example2@yahoo.com\",\n        \"example3@outlook.com\",\n        \"example4@domain.com\"\n    };\n    int emailCount = 4;\n\n    map(emails, emailCount, maskEmail);\n\n    for (int i = 0; i < emailCount; ++i) {\n        printf(\"%s\\n\", emails[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Apply map to reverse each string in a list of words.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n#define NUM_WORDS 3\n#define MAX_WORD_LENGTH 100\n\nvoid reverseString(char* str) {\n    int n = strlen(str);\n    for (int i = 0; i < n / 2; i++) {\n        char temp = str[i];\n        str[i] = str[n - i - 1];\n        str[n - i - 1] = temp;\n    }\n}\n\nvoid mapReverse(char words[][MAX_WORD_LENGTH], int num_words) {\n    for (int i = 0; i < num_words; i++) {\n        reverseString(words[i]);\n    }\n}\n\nint main() {\n    char words[NUM_WORDS][MAX_WORD_LENGTH] = {\"hello\", \"world\", \"example\"};\n    \n    mapReverse(words, NUM_WORDS);\n    \n    for (int i = 0; i < NUM_WORDS; i++) {\n        printf(\"%s\\n\", words[i]);\n    }\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Convert a list of hexadecimal color codes to RGB tuples using map.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int r;\n    int g;\n    int b;\n} RGB;\n\nRGB hex_to_rgb(const char *hex) {\n    RGB color;\n    sscanf(hex, \"#%02x%02x%02x\", &color.r, &color.g, &color.b);\n    return color;\n}\n\nvoid map_hex_to_rgb(const char **hex_colors, RGB *rgb_colors, size_t count) {\n    for (size_t i = 0; i < count; ++i) {\n        rgb_colors[i] = hex_to_rgb(hex_colors[i]);\n    }\n}\n\nint main() {\n    const char *hex_colors[] = {\"#FF5733\", \"#33FF57\", \"#3357FF\"};\n    size_t count = sizeof(hex_colors) / sizeof(hex_colors[0]);\n    RGB rgb_colors[count];\n\n    map_hex_to_rgb(hex_colors, rgb_colors, count);\n\n    for (size_t i = 0; i < count; ++i) {\n        printf(\"RGB(%d, %d, %d)\\n\", rgb_colors[i].r, rgb_colors[i].g, rgb_colors[i].b);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Use map to increment each integer in a list by a constant value.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid map(int* array, size_t length, int (*func)(int)) {\n    for (size_t i = 0; i < length; i++) {\n        array[i] = func(array[i]);\n    }\n}\n\nint incrementBy(int x) {\n    return x + 1; // Change this constant to increment by a different value\n}\n\nint main() {\n    int list[] = {1, 2, 3, 4, 5};\n    size_t length = sizeof(list) / sizeof(list[0]);\n\n    map(list, length, incrementBy);\n\n    for (size_t i = 0; i < length; i++) {\n        printf(\"%d \", list[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Calculate the square root of each number in a list using a map function.",
    "code": "```c\n#include <stdio.h>\n#include <math.h>\n\n#define SIZE 5\n\nvoid map(double (*func)(double), double *input, double *output, int size) {\n    for (int i = 0; i < size; i++) {\n        output[i] = func(input[i]);\n    }\n}\n\ndouble squareRoot(double num) {\n    return sqrt(num);\n}\n\nint main() {\n    double numbers[SIZE] = {1.0, 4.0, 9.0, 16.0, 25.0};\n    double results[SIZE];\n\n    map(squareRoot, numbers, results, SIZE);\n\n    for (int i = 0; i < SIZE; i++) {\n        printf(\"%.2f \", results[i]);\n    }\n    return 0;\n}\n```"
  },
  {
    "task": "Use map to convert a list of currency amounts from dollars to euros.",
    "code": "```c\n#include <stdio.h>\n\n#define SIZE 5\n\ndouble convertToEuros(double dollars) {\n    const double exchangeRate = 0.85; // Example exchange rate\n    return dollars * exchangeRate;\n}\n\nvoid map(double (*func)(double), double *arr, double *result, int size) {\n    for (int i = 0; i < size; i++) {\n        result[i] = func(arr[i]);\n    }\n}\n\nint main() {\n    double dollars[SIZE] = {100.0, 250.0, 50.0, 400.0, 320.0};\n    double euros[SIZE];\n\n    map(convertToEuros, dollars, euros, SIZE);\n\n    for (int i = 0; i < SIZE; i++) {\n        printf(\"Dollars: %.2f, Euros: %.2f\\n\", dollars[i], euros[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Extract the domain from each email address in a list using map.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_EMAILS 100\n#define MAX_LENGTH 256\n\nchar* extract_domain(const char* email) {\n    const char* at_sign = strchr(email, '@');\n    if (at_sign != NULL) {\n        return strdup(at_sign + 1);\n    }\n    return NULL;\n}\n\nvoid map(char* emails[], char* results[], int size, char* (*func)(const char*)) {\n    for (int i = 0; i < size; i++) {\n        results[i] = func(emails[i]);\n    }\n}\n\nint main() {\n    char* emails[MAX_EMAILS] = {\n        \"user1@example.com\",\n        \"user2@test.org\",\n        \"user3@sample.net\"\n    };\n    int size = 3; // Number of emails\n    char* domains[MAX_EMAILS] = { NULL };\n\n    map(emails, domains, size, extract_domain);\n\n    for (int i = 0; i < size; i++) {\n        if (domains[i] != NULL) {\n            printf(\"%s\\n\", domains[i]);\n            free(domains[i]);\n        }\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Use map to serialize a list of objects into JSON strings.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <json-c/json.h>\n\ntypedef struct {\n    char *name;\n    int age;\n} Person;\n\nchar* person_to_json(Person *p) {\n    struct json_object *jobj = json_object_new_object();\n    json_object_object_add(jobj, \"name\", json_object_new_string(p->name));\n    json_object_object_add(jobj, \"age\", json_object_new_int(p->age));\n    const char *json_str = json_object_to_json_string(jobj);\n    char *result = strdup(json_str);\n    json_object_put(jobj);\n    return result;\n}\n\nchar** map_to_json(Person *people, int count) {\n    char **json_strings = malloc(sizeof(char*) * count);\n    for (int i = 0; i < count; i++) {\n        json_strings[i] = person_to_json(&people[i]);\n    }\n    return json_strings;\n}\n\nint main() {\n    Person people[] = {{\"Alice\", 30}, {\"Bob\", 25}, {\"Charlie\", 35}};\n    int count = sizeof(people) / sizeof(people[0]);\n\n    char **json_strings = map_to_json(people, count);\n\n    for (int i = 0; i < count; i++) {\n        printf(\"%s\\n\", json_strings[i]);\n        free(json_strings[i]);\n    }\n    free(json_strings);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Transform a list of file sizes from bytes to kilobytes using map.",
    "code": "```c\n#include <stdio.h>\n\n#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))\n\nvoid transformToKilobytes(int *sizesInBytes, double *sizesInKilobytes, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        sizesInKilobytes[i] = sizesInBytes[i] / 1024.0;\n    }\n}\n\nint main() {\n    int fileSizesInBytes[] = {1024, 2048, 5120, 10240, 15360};\n    size_t length = ARRAY_SIZE(fileSizesInBytes);\n    double fileSizesInKilobytes[length];\n\n    transformToKilobytes(fileSizesInBytes, fileSizesInKilobytes, length);\n\n    for (size_t i = 0; i < length; ++i) {\n        printf(\"%.2f KB\\n\", fileSizesInKilobytes[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Use map to append a suffix to each string in a list of identifiers.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n#define NUM_IDENTIFIERS 5\n#define SUFFIX \"_suffix\"\n\nvoid append_suffix(char *identifier) {\n    strcat(identifier, SUFFIX);\n}\n\nint main() {\n    char identifiers[NUM_IDENTIFIERS][50] = {\"id1\", \"id2\", \"id3\", \"id4\", \"id5\"};\n    \n    for (int i = 0; i < NUM_IDENTIFIERS; i++) {\n        append_suffix(identifiers[i]);\n    }\n\n    for (int i = 0; i < NUM_IDENTIFIERS; i++) {\n        printf(\"%s\\n\", identifiers[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Apply map to convert measurements from inches to centimeters in a list.",
    "code": "```c\n#include <stdio.h>\n\n#define INCH_TO_CM 2.54\n\nvoid map(double (*func)(double), double *array, int size, double *result) {\n    for (int i = 0; i < size; i++) {\n        result[i] = func(array[i]);\n    }\n}\n\ndouble inchesToCm(double inches) {\n    return inches * INCH_TO_CM;\n}\n\nint main() {\n    double inches[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    int size = sizeof(inches) / sizeof(inches[0]);\n    double centimeters[size];\n\n    map(inchesToCm, inches, size, centimeters);\n\n    for (int i = 0; i < size; i++) {\n        printf(\"%.2f inches = %.2f cm\\n\", inches[i], centimeters[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Use map to encrypt a list of plaintext messages using a simple cipher.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n#define SHIFT 3 // Simple cipher shift value\n\n// Function to encrypt a single character\nchar encrypt_char(char c) {\n    if (c >= 'a' && c <= 'z') {\n        return (c - 'a' + SHIFT) % 26 + 'a';\n    } else if (c >= 'A' && c <= 'Z') {\n        return (c - 'A' + SHIFT) % 26 + 'A';\n    } else {\n        return c;\n    }\n}\n\n// Function to encrypt a message\nvoid encrypt_message(char *message) {\n    for (int i = 0; message[i] != '\\0'; i++) {\n        message[i] = encrypt_char(message[i]);\n    }\n}\n\n// Function to map encryption over a list of messages\nvoid map_encrypt(char messages[][100], int num_messages) {\n    for (int i = 0; i < num_messages; i++) {\n        encrypt_message(messages[i]);\n    }\n}\n\nint main() {\n    char messages[][100] = {\n        \"Hello, World!\",\n        \"Functional Map in C\",\n        \"Encrypt this message\"\n    };\n    int num_messages = sizeof(messages) / sizeof(messages[0]);\n\n    map_encrypt(messages, num_messages);\n\n    for (int i = 0; i < num_messages; i++) {\n        printf(\"Encrypted Message %d: %s\\n\", i + 1, messages[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Transform a list of date strings to day of the week names using a map function.",
    "code": "```c\n#include <stdio.h>\n#include <time.h>\n#include <string.h>\n\n#define NUM_DATES 3\n\nvoid map_dates_to_days(const char *dates[], char *days[]) {\n    struct tm tm;\n    char day_buffer[10];\n    for (int i = 0; i < NUM_DATES; i++) {\n        memset(&tm, 0, sizeof(struct tm));\n        strptime(dates[i], \"%Y-%m-%d\", &tm);\n        strftime(day_buffer, sizeof(day_buffer), \"%A\", &tm);\n        days[i] = strdup(day_buffer);\n    }\n}\n\nint main() {\n    const char *dates[NUM_DATES] = {\"2023-10-20\", \"2023-10-21\", \"2023-10-22\"};\n    char *days[NUM_DATES];\n\n    map_dates_to_days(dates, days);\n\n    for (int i = 0; i < NUM_DATES; i++) {\n        printf(\"%s -> %s\\n\", dates[i], days[i]);\n        free(days[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Use map to derive the absolute value of each number in a list.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid map(int *array, size_t length, int (*func)(int)) {\n    for (size_t i = 0; i < length; i++) {\n        array[i] = func(array[i]);\n    }\n}\n\nint absolute(int n) {\n    return abs(n);\n}\n\nint main() {\n    int numbers[] = {-10, 20, -30, 40, -50};\n    size_t length = sizeof(numbers) / sizeof(numbers[0]);\n\n    map(numbers, length, absolute);\n\n    for (size_t i = 0; i < length; i++) {\n        printf(\"%d \", numbers[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Convert a list of lowercase hexadecimal strings to uppercase using map.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n\n#define NUM_STRINGS 5\n\nvoid to_uppercase(char* s) {\n    while (*s) {\n        *s = toupper(*s);\n        s++;\n    }\n}\n\nint main() {\n    char* hex_strings[] = {\n        \"1a3b\",\n        \"4c5d\",\n        \"6e7f\",\n        \"8a9b\",\n        \"bcd1\"\n    };\n\n    for (int i = 0; i < NUM_STRINGS; i++) {\n        to_uppercase(hex_strings[i]);\n        printf(\"%s\\n\", hex_strings[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Use map to find the maximum value in a list of lists of numbers.",
    "code": "```c\n#include <stdio.h>\n\n#define ROWS 3\n#define COLS 4\n\nint max_in_array(int arr[], int size) {\n    int max_val = arr[0];\n    for (int i = 1; i < size; i++) {\n        if (arr[i] > max_val) {\n            max_val = arr[i];\n        }\n    }\n    return max_val;\n}\n\nint map_max(int lists[][COLS], int num_lists) {\n    int max_val = max_in_array(lists[0], COLS);\n    for (int i = 1; i < num_lists; i++) {\n        int current_max = max_in_array(lists[i], COLS);\n        if (current_max > max_val) {\n            max_val = current_max;\n        }\n    }\n    return max_val;\n}\n\nint main() {\n    int list_of_lists[ROWS][COLS] = {\n        {1, 2, 3, 4},\n        {5, 6, 7, 8},\n        {9, 10, 11, 12}\n    };\n\n    int max_value = map_max(list_of_lists, ROWS);\n    printf(\"Maximum value: %d\\n\", max_value);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Apply map to extract the year from each date in a list of date objects.",
    "code": "```c\n#include <stdio.h>\n\ntypedef struct {\n    int year;\n    int month;\n    int day;\n} Date;\n\nint getYear(Date date) {\n    return date.year;\n}\n\nvoid map(int (*func)(Date), Date dates[], int years[], int size) {\n    for (int i = 0; i < size; i++) {\n        years[i] = func(dates[i]);\n    }\n}\n\nint main() {\n    Date dates[] = {\n        {2023, 10, 1},\n        {2022, 5, 15},\n        {2021, 8, 30}\n    };\n\n    int size = sizeof(dates) / sizeof(dates[0]);\n    int years[size];\n\n    map(getYear, dates, years, size);\n\n    for (int i = 0; i < size; i++) {\n        printf(\"%d\\n\", years[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Use map to prepend a country code to each phone number in a list.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define COUNTRY_CODE \"+1\"\n#define PHONE_NUMBER_COUNT 3\n\nchar* prependCountryCode(const char* phoneNumber) {\n    char* fullNumber = malloc(strlen(COUNTRY_CODE) + strlen(phoneNumber) + 1);\n    strcpy(fullNumber, COUNTRY_CODE);\n    strcat(fullNumber, phoneNumber);\n    return fullNumber;\n}\n\nvoid map(char* phoneNumbers[], char* (*func)(const char*), char* results[], int count) {\n    for (int i = 0; i < count; i++) {\n        results[i] = func(phoneNumbers[i]);\n    }\n}\n\nint main() {\n    char* phoneNumbers[PHONE_NUMBER_COUNT] = { \"1234567890\", \"0987654321\", \"5555555555\" };\n    char* results[PHONE_NUMBER_COUNT];\n\n    map(phoneNumbers, prependCountryCode, results, PHONE_NUMBER_COUNT);\n\n    for (int i = 0; i < PHONE_NUMBER_COUNT; i++) {\n        printf(\"%s\\n\", results[i]);\n        free(results[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Capitalize the last letter of each word in a list using a map function.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nvoid capitalize_last(char *word) {\n    size_t len = strlen(word);\n    if (len > 0) {\n        word[len - 1] = toupper(word[len - 1]);\n    }\n}\n\nvoid map(char **words, size_t count, void (*func)(char *)) {\n    for (size_t i = 0; i < count; i++) {\n        func(words[i]);\n    }\n}\n\nint main() {\n    char *words[] = {\"hello\", \"world\", \"this\", \"is\", \"c\"};\n    size_t count = sizeof(words) / sizeof(words[0]);\n\n    map(words, count, capitalize_last);\n\n    for (size_t i = 0; i < count; i++) {\n        printf(\"%s\\n\", words[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Use map to transform a list of strings by removing all vowels.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nint is_vowel(char c) {\n    char vowels[] = \"aeiouAEIOU\";\n    return strchr(vowels, c) != NULL;\n}\n\nchar* remove_vowels(const char* str) {\n    size_t len = strlen(str);\n    char* result = (char*)malloc(len + 1);\n    if (!result) return NULL;\n    size_t j = 0;\n    for (size_t i = 0; i < len; ++i) {\n        if (!is_vowel(str[i])) {\n            result[j++] = str[i];\n        }\n    }\n    result[j] = '\\0';\n    return result;\n}\n\nvoid map(char** strings, size_t count, char** output, char* (*func)(const char*)) {\n    for (size_t i = 0; i < count; ++i) {\n        output[i] = func(strings[i]);\n    }\n}\n\nint main() {\n    char* strings[] = {\"hello\", \"world\", \"example\"};\n    size_t count = sizeof(strings) / sizeof(strings[0]);\n    char* transformed[count];\n\n    map(strings, count, transformed, remove_vowels);\n\n    for (size_t i = 0; i < count; ++i) {\n        printf(\"%s\\n\", transformed[i]);\n        free(transformed[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Convert a list of music notes to their corresponding frequencies using map.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\n#define NUM_NOTES 7\n\ntypedef struct {\n    char *note;\n    double frequency;\n} NoteFrequency;\n\ndouble getFrequency(char *note, NoteFrequency *noteFrequencies, int numNotes) {\n    for (int i = 0; i < numNotes; i++) {\n        if (strcmp(note, noteFrequencies[i].note) == 0) {\n            return noteFrequencies[i].frequency;\n        }\n    }\n    return -1.0;  // Return -1.0 if note is not found\n}\n\nvoid mapFrequencies(char *notes[], double frequencies[], int size, NoteFrequency *noteFrequencies, int numNotes) {\n    for (int i = 0; i < size; i++) {\n        frequencies[i] = getFrequency(notes[i], noteFrequencies, numNotes);\n    }\n}\n\nint main() {\n    NoteFrequency noteFrequencies[NUM_NOTES] = {\n        {\"C\", 261.63},\n        {\"D\", 293.66},\n        {\"E\", 329.63},\n        {\"F\", 349.23},\n        {\"G\", 392.00},\n        {\"A\", 440.00},\n        {\"B\", 493.88}\n    };\n    \n    char *notes[] = {\"C\", \"E\", \"G\", \"A\", \"B\"};\n    int size = sizeof(notes) / sizeof(notes[0]);\n    double frequencies[size];\n\n    mapFrequencies(notes, frequencies, size, noteFrequencies, NUM_NOTES);\n\n    for (int i = 0; i < size; i++) {\n        printf(\"Note: %s, Frequency: %.2f Hz\\n\", notes[i], frequencies[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Use map to find the reciprocal of each number in a list.",
    "code": "```c\n#include <stdio.h>\n\n#define SIZE 5\n\ndouble reciprocal(double num) {\n    return 1.0 / num;\n}\n\nvoid map(double (*func)(double), double input[], double output[], int size) {\n    for (int i = 0; i < size; i++) {\n        output[i] = func(input[i]);\n    }\n}\n\nint main() {\n    double numbers[SIZE] = {1.0, 2.0, 4.0, 0.5, 5.0};\n    double results[SIZE];\n\n    map(reciprocal, numbers, results, SIZE);\n\n    for (int i = 0; i < SIZE; i++) {\n        printf(\"%f\\n\", results[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Transform a list of URLs to their shortened versions using a map function.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_URLS 100\n#define MAX_URL_LENGTH 256\n#define SHORT_URL_PREFIX \"short.ly/\"\n#define SHORT_URL_LENGTH 15\n\nvoid map_urls(char urls[][MAX_URL_LENGTH], char short_urls[][MAX_URL_LENGTH], int count, char* (*map_func)(const char*)) {\n    for (int i = 0; i < count; i++) {\n        strcpy(short_urls[i], map_func(urls[i]));\n    }\n}\n\nchar* shorten_url(const char* url) {\n    static char short_url[MAX_URL_LENGTH];\n    snprintf(short_url, MAX_URL_LENGTH, \"%s%ld\", SHORT_URL_PREFIX, strlen(url));\n    return short_url;\n}\n\nint main() {\n    char urls[MAX_URLS][MAX_URL_LENGTH] = {\n        \"http://example.com\",\n        \"http://anotherexample.com/path\",\n        \"https://yetanotherexample.com\"\n    };\n    char short_urls[MAX_URLS][MAX_URL_LENGTH];\n    int url_count = 3;\n\n    map_urls(urls, short_urls, url_count, shorten_url);\n\n    for (int i = 0; i < url_count; i++) {\n        printf(\"Original URL: %s\\n\", urls[i]);\n        printf(\"Shortened URL: %s\\n\", short_urls[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Use map to generate a list of initials from a list of full names.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_NAMES 100\n#define MAX_NAME_LENGTH 100\n#define INITIAL_LENGTH 3\n\nvoid extractInitials(char initials[], const char fullName[]) {\n    int j = 0;\n    initials[j++] = fullName[0]; // First initial\n    for (int i = 1; fullName[i] != '\\0'; i++) {\n        if (fullName[i] == ' ') {\n            initials[j++] = fullName[i + 1]; // Next initial after space\n        }\n    }\n    initials[j] = '\\0';\n}\n\nvoid mapInitials(char initialsList[][INITIAL_LENGTH], char fullNames[][MAX_NAME_LENGTH], int count) {\n    for (int i = 0; i < count; i++) {\n        extractInitials(initialsList[i], fullNames[i]);\n    }\n}\n\nint main() {\n    char fullNames[MAX_NAMES][MAX_NAME_LENGTH] = {\n        \"John Doe\",\n        \"Jane Smith\",\n        \"Emily Johnson\"\n    };\n    int count = 3;\n    char initialsList[MAX_NAMES][INITIAL_LENGTH];\n\n    mapInitials(initialsList, fullNames, count);\n\n    for (int i = 0; i < count; i++) {\n        printf(\"%s -> %s\\n\", fullNames[i], initialsList[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Convert a list of decimal numbers to their binary string representations using map.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\nchar* decimalToBinaryString(int num) {\n    char* binaryString = (char*)malloc(33);\n    for (int i = 31; i >= 0; --i) {\n        binaryString[31-i] = (num & (1 << i)) ? '1' : '0';\n    }\n    binaryString[32] = '\\0';\n    return binaryString;\n}\n\nvoid map(int* numbers, char** binaryStrings, int size, char* (*func)(int)) {\n    for (int i = 0; i < size; ++i) {\n        binaryStrings[i] = func(numbers[i]);\n    }\n}\n\nint main() {\n    int numbers[] = {5, 10, 15};\n    int size = sizeof(numbers) / sizeof(numbers[0]);\n    char* binaryStrings[size];\n\n    map(numbers, binaryStrings, size, decimalToBinaryString);\n\n    for (int i = 0; i < size; ++i) {\n        printf(\"%d in binary is %s\\n\", numbers[i], binaryStrings[i]);\n        free(binaryStrings[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Use map to adjust the brightness of each color in a list of RGB tuples.",
    "code": "```c\n#include <stdio.h>\n\ntypedef struct {\n    int r, g, b;\n} RGB;\n\nRGB adjustBrightness(RGB color, float factor) {\n    RGB newColor;\n    newColor.r = (int)(color.r * factor);\n    newColor.g = (int)(color.g * factor);\n    newColor.b = (int)(color.b * factor);\n    return newColor;\n}\n\nvoid map(RGB (*func)(RGB, float), RGB* colors, RGB* result, int size, float factor) {\n    for (int i = 0; i < size; i++) {\n        result[i] = func(colors[i], factor);\n    }\n}\n\nint main() {\n    RGB colors[] = {{100, 150, 200}, {50, 75, 100}, {200, 100, 50}};\n    int size = sizeof(colors) / sizeof(colors[0]);\n    RGB result[size];\n    float brightnessFactor = 1.2; // Example brightness adjustment factor\n\n    map(adjustBrightness, colors, result, size, brightnessFactor);\n\n    for (int i = 0; i < size; i++) {\n        printf(\"RGB(%d, %d, %d)\\n\", result[i].r, result[i].g, result[i].b);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Apply map to filter out only alphabetic characters from a list of strings.",
    "code": "```c\n#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\n#define MAX_STRINGS 100\n#define MAX_LENGTH 100\n\nvoid filterAlphabetic(const char *input, char *output) {\n    int j = 0;\n    for (int i = 0; input[i] != '\\0'; i++) {\n        if (isalpha((unsigned char)input[i])) {\n            output[j++] = input[i];\n        }\n    }\n    output[j] = '\\0';\n}\n\nvoid mapFilterAlphabetic(char inputList[MAX_STRINGS][MAX_LENGTH], char outputList[MAX_STRINGS][MAX_LENGTH], int count) {\n    for (int i = 0; i < count; i++) {\n        filterAlphabetic(inputList[i], outputList[i]);\n    }\n}\n\nint main() {\n    char inputList[MAX_STRINGS][MAX_LENGTH] = {\n        \"Hello123\", \n        \"World!@#\", \n        \"Test123ABC\"\n    };\n    char outputList[MAX_STRINGS][MAX_LENGTH];\n    int count = 3;\n    \n    mapFilterAlphabetic(inputList, outputList, count);\n\n    for (int i = 0; i < count; i++) {\n        printf(\"%s\\n\", outputList[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Use map to compute the prime factorization of each number in a list.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int *factors;\n    int count;\n} Factorization;\n\nint is_prime(int n) {\n    if (n <= 1) return 0;\n    if (n <= 3) return 1;\n    if (n % 2 == 0 || n % 3 == 0) return 0;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return 0;\n    }\n    return 1;\n}\n\nFactorization prime_factors(int n) {\n    Factorization result;\n    result.factors = (int *)malloc(sizeof(int) * 32);\n    result.count = 0;\n    for (int i = 2; i <= n / 2; ++i) {\n        while (is_prime(i) && n % i == 0) {\n            result.factors[result.count++] = i;\n            n /= i;\n        }\n    }\n    if (n > 1) {\n        result.factors[result.count++] = n;\n    }\n    return result;\n}\n\nvoid map(int *array, int size, Factorization (*func)(int)) {\n    for (int i = 0; i < size; i++) {\n        Factorization result = func(array[i]);\n        printf(\"%d: \", array[i]);\n        for (int j = 0; j < result.count; j++) {\n            printf(\"%d\", result.factors[j]);\n            if (j < result.count - 1) printf(\" x \");\n        }\n        printf(\"\\n\");\n        free(result.factors);\n    }\n}\n\nint main() {\n    int numbers[] = {60, 13, 45, 100};\n    int size = sizeof(numbers) / sizeof(numbers[0]);\n    map(numbers, size, prime_factors);\n    return 0;\n}\n```"
  },
  {
    "task": "Calculate the exponential of each number in a list using a map function.",
    "code": "```c\n#include <stdio.h>\n#include <math.h>\n\n#define SIZE 5\n\nvoid map(double (*func)(double), double *arr, double *result, int size) {\n    for (int i = 0; i < size; i++) {\n        result[i] = func(arr[i]);\n    }\n}\n\ndouble exponential(double x) {\n    return exp(x);\n}\n\nint main() {\n    double numbers[SIZE] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    double results[SIZE];\n\n    map(exponential, numbers, results, SIZE);\n\n    for (int i = 0; i < SIZE; i++) {\n        printf(\"%f\\n\", results[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Use map to convert a list of text messages to morse code.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\nconst char *morse_code(char c) {\n    switch (toupper(c)) {\n        case 'A': return \".-\";\n        case 'B': return \"-...\";\n        case 'C': return \"-.-.\";\n        case 'D': return \"-..\";\n        case 'E': return \".\";\n        case 'F': return \"..-.\";\n        case 'G': return \"--.\";\n        case 'H': return \"....\";\n        case 'I': return \"..\";\n        case 'J': return \".---\";\n        case 'K': return \"-.-\";\n        case 'L': return \".-..\";\n        case 'M': return \"--\";\n        case 'N': return \"-.\";\n        case 'O': return \"---\";\n        case 'P': return \".--.\";\n        case 'Q': return \"--.-\";\n        case 'R': return \".-.\";\n        case 'S': return \"...\";\n        case 'T': return \"-\";\n        case 'U': return \"..-\";\n        case 'V': return \"...-\";\n        case 'W': return \".--\";\n        case 'X': return \"-..-\";\n        case 'Y': return \"-.--\";\n        case 'Z': return \"--..\";\n        case '1': return \".----\";\n        case '2': return \"..---\";\n        case '3': return \"...--\";\n        case '4': return \"....-\";\n        case '5': return \".....\";\n        case '6': return \"-....\";\n        case '7': return \"--...\";\n        case '8': return \"---..\";\n        case '9': return \"----.\";\n        case '0': return \"-----\";\n        case ' ': return \" \";\n        default: return \"\";\n    }\n}\n\nvoid map_to_morse(const char *message, char *output) {\n    size_t len = strlen(message);\n    for (size_t i = 0; i < len; i++) {\n        strcat(output, morse_code(message[i]));\n        if (i < len - 1) {\n            strcat(output, \" \");\n        }\n    }\n}\n\nint main() {\n    const char *messages[] = {\n        \"HELLO WORLD\",\n        \"SOS\",\n        \"C PROGRAMMING\"\n    };\n    size_t num_messages = sizeof(messages) / sizeof(messages[0]);\n\n    for (size_t i = 0; i < num_messages; i++) {\n        char morse[1024] = \"\";\n        map_to_morse(messages[i], morse);\n        printf(\"Original: %s\\nMorse: %s\\n\", messages[i], morse);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Transform a list of JSON objects to XML strings using a map function.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <json-c/json.h>\n\n// Function to convert JSON object to XML string\nchar* json_to_xml(struct json_object *jobj) {\n    const char *json_str = json_object_to_json_string(jobj);\n    // Simplistic conversion, replace this with proper XML conversion logic\n    size_t len = strlen(json_str);\n    char *xml_str = (char *)malloc((len + 15) * sizeof(char));\n    sprintf(xml_str, \"<xml>%s</xml>\", json_str);\n    return xml_str;\n}\n\n// Function to map JSON array to XML strings\nchar** map_json_to_xml(struct json_object *jarray, size_t *out_size) {\n    if (!json_object_is_type(jarray, json_type_array)) {\n        *out_size = 0;\n        return NULL;\n    }\n    size_t array_len = json_object_array_length(jarray);\n    char **xml_strings = (char **)malloc(array_len * sizeof(char *));\n    for (size_t i = 0; i < array_len; i++) {\n        struct json_object *jobj = json_object_array_get_idx(jarray, i);\n        xml_strings[i] = json_to_xml(jobj);\n    }\n    *out_size = array_len;\n    return xml_strings;\n}\n\nint main() {\n    const char *json_data = \"[{\\\"name\\\": \\\"Alice\\\", \\\"age\\\": 30}, {\\\"name\\\": \\\"Bob\\\", \\\"age\\\": 25}]\";\n    struct json_object *jarray = json_tokener_parse(json_data);\n\n    size_t xml_size;\n    char **xml_strings = map_json_to_xml(jarray, &xml_size);\n\n    for (size_t i = 0; i < xml_size; i++) {\n        printf(\"%s\\n\", xml_strings[i]);\n        free(xml_strings[i]); // Free each XML string\n    }\n    free(xml_strings); // Free the XML strings array\n    json_object_put(jarray); // Free the JSON object\n\n    return 0;\n}\n```"
  },
  {
    "task": "Use map to extract the extension from each filename in a list.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar *get_extension(const char *filename) {\n    const char *dot = strrchr(filename, '.');\n    if (!dot || dot == filename) return \"\";\n    return strdup(dot + 1);\n}\n\nvoid map(char **filenames, char **extensions, size_t size, char *(*func)(const char *)) {\n    for (size_t i = 0; i < size; ++i) {\n        extensions[i] = func(filenames[i]);\n    }\n}\n\nint main() {\n    char *filenames[] = {\"file1.txt\", \"image.jpeg\", \"script.js\", \"archive.tar.gz\"};\n    size_t size = sizeof(filenames) / sizeof(filenames[0]);\n    char **extensions = malloc(size * sizeof(char *));\n    \n    map(filenames, extensions, size, get_extension);\n\n    for (size_t i = 0; i < size; ++i) {\n        printf(\"%s\\n\", extensions[i]);\n        free(extensions[i]);\n    }\n    free(extensions);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Convert a list of temperatures from Fahrenheit to Kelvin using map.",
    "code": "```c\n#include <stdio.h>\n\n#define FAHRENHEIT_TO_KELVIN(f) ((f - 32) * 5.0 / 9.0 + 273.15)\n\nvoid map(double (*func)(double), double *src, double *dest, int size) {\n    for (int i = 0; i < size; i++) {\n        dest[i] = func(src[i]);\n    }\n}\n\ndouble fahrenheitToKelvin(double fahrenheit) {\n    return FAHRENHEIT_TO_KELVIN(fahrenheit);\n}\n\nint main() {\n    double fahrenheitTemps[] = {32.0, 212.0, 98.6};\n    int size = sizeof(fahrenheitTemps) / sizeof(fahrenheitTemps[0]);\n    double kelvinTemps[size];\n\n    map(fahrenheitToKelvin, fahrenheitTemps, kelvinTemps, size);\n\n    for (int i = 0; i < size; i++) {\n        printf(\"%.2f F = %.2f K\\n\", fahrenheitTemps[i], kelvinTemps[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Use map to calculate the perimeter of each rectangle in a list of dimensions.",
    "code": "```c\n#include <stdio.h>\n\ntypedef struct {\n    int length;\n    int width;\n} Rectangle;\n\nint calculatePerimeter(Rectangle rect) {\n    return 2 * (rect.length + rect.width);\n}\n\nvoid map(Rectangle* rectangles, int* perimeters, int size, int (*func)(Rectangle)) {\n    for (int i = 0; i < size; ++i) {\n        perimeters[i] = func(rectangles[i]);\n    }\n}\n\nint main() {\n    Rectangle rectangles[] = { {5, 10}, {8, 12}, {15, 20} };\n    int size = sizeof(rectangles) / sizeof(rectangles[0]);\n    int perimeters[size];\n\n    map(rectangles, perimeters, size, calculatePerimeter);\n\n    for (int i = 0; i < size; ++i) {\n        printf(\"Perimeter of rectangle %d: %d\\n\", i, perimeters[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Apply map to format a list of phone numbers into a standard format.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n#define NUM_PHONE_NUMBERS 5\n#define PHONE_NUMBER_LENGTH 11\n#define FORMATTED_LENGTH 15\n\n// Function to format a single phone number\nvoid formatPhoneNumber(const char *input, char *output) {\n    snprintf(output, FORMATTED_LENGTH, \"(%c%c%c) %c%c%c-%c%c%c%c\",\n             input[0], input[1], input[2], input[3], input[4], input[5],\n             input[6], input[7], input[8], input[9]);\n}\n\n// Function to map the formatting function across an array of phone numbers\nvoid mapFormatPhoneNumbers(char phoneNumbers[][PHONE_NUMBER_LENGTH], char formattedNumbers[][FORMATTED_LENGTH], int length) {\n    for (int i = 0; i < length; i++) {\n        formatPhoneNumber(phoneNumbers[i], formattedNumbers[i]);\n    }\n}\n\nint main() {\n    char phoneNumbers[NUM_PHONE_NUMBERS][PHONE_NUMBER_LENGTH] = {\n        \"1234567890\",\n        \"2345678901\",\n        \"3456789012\",\n        \"4567890123\",\n        \"5678901234\"\n    };\n    char formattedNumbers[NUM_PHONE_NUMBERS][FORMATTED_LENGTH];\n\n    mapFormatPhoneNumbers(phoneNumbers, formattedNumbers, NUM_PHONE_NUMBERS);\n\n    for (int i = 0; i < NUM_PHONE_NUMBERS; i++) {\n        printf(\"%s\\n\", formattedNumbers[i]);\n    }\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Use map to generate a hashed version of passwords from a list.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define HASH_CONST 5381\n\nunsigned long hash_function(const char *str) {\n    unsigned long hash = HASH_CONST;\n    int c;\n    while ((c = *str++))\n        hash = ((hash << 5) + hash) + c; \n    return hash;\n}\n\nvoid map(char **passwords, unsigned long *hashed, size_t size, unsigned long (*func)(const char *)) {\n    for (size_t i = 0; i < size; i++) {\n        hashed[i] = func(passwords[i]);\n    }\n}\n\nint main() {\n    char *passwords[] = {\"password1\", \"123456\", \"qwerty\", \"letmein\"};\n    size_t size = sizeof(passwords) / sizeof(passwords[0]);\n    unsigned long hashed[size];\n\n    map(passwords, hashed, size, hash_function);\n\n    for (size_t i = 0; i < size; i++) {\n        printf(\"Original: %s, Hashed: %lu\\n\", passwords[i], hashed[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Convert a list of text paragraphs to a word count using map.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint countWords(const char *paragraph) {\n    int count = 0;\n    int inWord = 0;\n    while (*paragraph) {\n        if (*paragraph == ' ' || *paragraph == '\\n' || *paragraph == '\\t') {\n            inWord = 0;\n        } else if (inWord == 0) {\n            inWord = 1;\n            count++;\n        }\n        paragraph++;\n    }\n    return count;\n}\n\nvoid mapWordCount(char **paragraphs, int *wordCounts, int size) {\n    for (int i = 0; i < size; i++) {\n        wordCounts[i] = countWords(paragraphs[i]);\n    }\n}\n\nint main() {\n    char *paragraphs[] = {\n        \"This is the first paragraph.\",\n        \"This is the second paragraph, which is a bit longer.\",\n        \"Short one.\"\n    };\n    int size = sizeof(paragraphs) / sizeof(paragraphs[0]);\n    int *wordCounts = malloc(size * sizeof(int));\n    \n    mapWordCount(paragraphs, wordCounts, size);\n\n    for (int i = 0; i < size; i++) {\n        printf(\"Paragraph %d has %d words.\\n\", i+1, wordCounts[i]);\n    }\n\n    free(wordCounts);\n    return 0;\n}\n```"
  },
  {
    "task": "Use map to remove punctuation from each string in a list of sentences.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#define SENTENCE_COUNT 3\n#define MAX_SENTENCE_LENGTH 256\n\nchar* remove_punctuation(char* sentence) {\n    char* result = malloc(strlen(sentence) + 1);\n    char* ptr = result;\n    while (*sentence != '\\0') {\n        if (!ispunct(*sentence)) {\n            *ptr++ = *sentence;\n        }\n        sentence++;\n    }\n    *ptr = '\\0';\n    return result;\n}\n\nint main() {\n    char* sentences[SENTENCE_COUNT] = {\n        \"Hello, world!\",\n        \"This is a test sentence.\",\n        \"C programming: fun & challenging!\"\n    };\n\n    for (int i = 0; i < SENTENCE_COUNT; i++) {\n        char* cleaned_sentence = remove_punctuation(sentences[i]);\n        printf(\"%s\\n\", cleaned_sentence);\n        free(cleaned_sentence);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Transform a list of URLs to their base domain using a map function.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_URLS 100\n#define MAX_URL_LENGTH 256\n\nvoid getBaseDomain(const char* url, char* baseDomain) {\n    const char* start = strstr(url, \"://\");\n    if (start) {\n        start += 3; // Skip \"://\"\n    } else {\n        start = url;\n    }\n\n    const char* end = strchr(start, '/');\n    if (end) {\n        strncpy(baseDomain, start, end - start);\n        baseDomain[end - start] = '\\0';\n    } else {\n        strcpy(baseDomain, start);\n    }\n}\n\nvoid mapUrlsToBaseDomains(char urls[][MAX_URL_LENGTH], char baseDomains[][MAX_URL_LENGTH], int urlCount) {\n    for (int i = 0; i < urlCount; i++) {\n        getBaseDomain(urls[i], baseDomains[i]);\n    }\n}\n\nint main() {\n    char urls[MAX_URLS][MAX_URL_LENGTH] = {\n        \"http://example.com/path\",\n        \"https://www.example.org\",\n        \"ftp://ftp.example.net/resource\"\n    };\n    int urlCount = 3;\n    char baseDomains[MAX_URLS][MAX_URL_LENGTH];\n\n    mapUrlsToBaseDomains(urls, baseDomains, urlCount);\n\n    for (int i = 0; i < urlCount; i++) {\n        printf(\"Base domain: %s\\n\", baseDomains[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Use map to translate a list of expressions to their symbolic algebraic forms.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    char* expression;\n    char* algebraic_form;\n} ExpressionMap;\n\nchar* toAlgebraicForm(const char* expression) {\n    // This function is a placeholder for the transformation logic\n    // For demonstration, we'll just return the same expression\n    return strdup(expression);\n}\n\nExpressionMap* mapExpressions(const char** expressions, size_t size) {\n    ExpressionMap* result = malloc(size * sizeof(ExpressionMap));\n    for (size_t i = 0; i < size; ++i) {\n        result[i].expression = strdup(expressions[i]);\n        result[i].algebraic_form = toAlgebraicForm(expressions[i]);\n    }\n    return result;\n}\n\nvoid freeExpressionMap(ExpressionMap* map, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        free(map[i].expression);\n        free(map[i].algebraic_form);\n    }\n    free(map);\n}\n\nint main() {\n    const char* expressions[] = {\n        \"x + y\",\n        \"a * b\",\n        \"cos(theta)\"\n    };\n    size_t size = sizeof(expressions) / sizeof(expressions[0]);\n\n    ExpressionMap* algebraicForms = mapExpressions(expressions, size);\n\n    for (size_t i = 0; i < size; ++i) {\n        printf(\"Expression: %s, Algebraic Form: %s\\n\", \n               algebraicForms[i].expression, algebraicForms[i].algebraic_form);\n    }\n\n    freeExpressionMap(algebraicForms, size);\n    return 0;\n}\n```"
  },
  {
    "task": "Apply map to convert a list of ASCII codes to corresponding characters.",
    "code": "```c\n#include <stdio.h>\n\nchar to_char(int ascii) {\n    return (char)ascii;\n}\n\nvoid map(int *ascii_list, char *char_list, int size) {\n    for (int i = 0; i < size; i++) {\n        char_list[i] = to_char(ascii_list[i]);\n    }\n}\n\nint main() {\n    int ascii_list[] = {65, 66, 67, 68, 69}; // Example ASCII codes\n    int size = sizeof(ascii_list) / sizeof(ascii_list[0]);\n    char char_list[size];\n\n    map(ascii_list, char_list, size);\n\n    for (int i = 0; i < size; i++) {\n        printf(\"%c \", char_list[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Use map to transform a list of text strings to their lemmatized forms.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n// Dummy lemmatizer function\nchar* lemmatize(const char* word) {\n    // In a real scenario, this function would use a lemmatization library\n    // For demonstration, we'll just return the word itself\n    char* lemmatized = (char*)malloc(strlen(word) + 1);\n    strcpy(lemmatized, word);\n    return lemmatized;\n}\n\n// Map function\nvoid map(char* (*func)(const char*), char** list, char** result, int size) {\n    for (int i = 0; i < size; i++) {\n        result[i] = func(list[i]);\n    }\n}\n\nint main() {\n    char* words[] = {\"running\", \"jumps\", \"easily\"};\n    int size = sizeof(words) / sizeof(words[0]);\n    char* lemmatizedWords[size];\n\n    map(lemmatize, words, lemmatizedWords, size);\n\n    for (int i = 0; i < size; i++) {\n        printf(\"%s -> %s\\n\", words[i], lemmatizedWords[i]);\n        free(lemmatizedWords[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Convert a list of HTML strings to plain text using map.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n// Function to remove HTML tags from a string\nchar* strip_html_tags(const char* html) {\n    size_t len = strlen(html);\n    char* plain = (char*)malloc(len + 1);\n    int j = 0;\n    int in_tag = 0;\n    for (int i = 0; i < len; i++) {\n        if (html[i] == '<') {\n            in_tag = 1;\n        } else if (html[i] == '>') {\n            in_tag = 0;\n        } else if (!in_tag) {\n            plain[j++] = html[i];\n        }\n    }\n    plain[j] = '\\0';\n    return plain;\n}\n\n// Functional map implementation\nvoid map(char* (*func)(const char*), char** list, char** result, int size) {\n    for (int i = 0; i < size; i++) {\n        result[i] = func(list[i]);\n    }\n}\n\nint main() {\n    char* html_list[] = {\n        \"<p>Hello, <b>World</b>!</p>\",\n        \"<div>Sample <span>text</span> here.</div>\",\n        \"<h1>Title</h1><p>Paragraph</p>\"\n    };\n    int list_size = sizeof(html_list) / sizeof(html_list[0]);\n    char* plain_text_list[list_size];\n\n    // Use map to convert each HTML string to plain text\n    map(strip_html_tags, html_list, plain_text_list, list_size);\n\n    // Print the converted plain text strings\n    for (int i = 0; i < list_size; i++) {\n        printf(\"%s\\n\", plain_text_list[i]);\n        free(plain_text_list[i]);  // Free the allocated memory\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Use map to create a summary of each article in a list of texts.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_ARTICLES 100\n#define MAX_LENGTH 1000\n\n// Function to create a summary of an article\nvoid summarize_article(const char *article, char *summary) {\n    // Simple summary: copy the first 100 characters or less\n    strncpy(summary, article, 100);\n    summary[100] = '\\0'; // Ensure null termination\n}\n\n// Function to apply map-like functionality to articles\nvoid map_summarize(char articles[][MAX_LENGTH], char summaries[][101], int count) {\n    for (int i = 0; i < count; i++) {\n        summarize_article(articles[i], summaries[i]);\n    }\n}\n\nint main() {\n    // Example articles\n    char articles[MAX_ARTICLES][MAX_LENGTH] = {\n        \"This is the first article. It contains some interesting content.\",\n        \"Here is the second article. It is also filled with insightful information.\",\n        \"The third article offers a lot of value to the reader.\"\n    };\n\n    int article_count = 3;\n    char summaries[MAX_ARTICLES][101];\n\n    // Create summaries of each article\n    map_summarize(articles, summaries, article_count);\n\n    // Print summaries\n    for (int i = 0; i < article_count; i++) {\n        printf(\"Summary %d: %s\\n\", i + 1, summaries[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Transform a list of paths to their absolute paths using a map function.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\nchar* get_absolute_path(const char* path) {\n    char* absolute_path = realpath(path, NULL);\n    return absolute_path;\n}\n\nvoid map(char** list, char** result, size_t size, char* (*func)(const char*)) {\n    for (size_t i = 0; i < size; ++i) {\n        result[i] = func(list[i]);\n    }\n}\n\nint main() {\n    char* paths[] = { \"./path1\", \"../path2\", \"/absolute/path3\" };\n    size_t size = sizeof(paths) / sizeof(paths[0]);\n    char* absolute_paths[size];\n\n    map(paths, absolute_paths, size, get_absolute_path);\n\n    for (size_t i = 0; i < size; ++i) {\n        printf(\"%s\\n\", absolute_paths[i]);\n        free(absolute_paths[i]); // Free memory allocated by realpath\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Use map to generate QR codes from a list of URLs.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <qrencode.h>\n\nvoid generate_qr(const char *url) {\n    QRcode *qrcode = QRcode_encodeString(url, 0, QR_ECLEVEL_L, QR_MODE_8, 1);\n    if (qrcode) {\n        for (int y = 0; y < qrcode->width; y++) {\n            for (int x = 0; x < qrcode->width; x++) {\n                putchar(qrcode->data[y * qrcode->width + x] & 1 ? '#' : ' ');\n            }\n            putchar('\\n');\n        }\n        QRcode_free(qrcode);\n    }\n    printf(\"\\n\");\n}\n\nvoid map(void (*func)(const char *), const char **list, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        func(list[i]);\n    }\n}\n\nint main() {\n    const char *urls[] = {\n        \"https://example.com\",\n        \"https://openai.com\",\n        \"https://github.com\"\n    };\n    size_t url_count = sizeof(urls) / sizeof(urls[0]);\n    map(generate_qr, urls, url_count);\n    return 0;\n}\n```"
  },
  {
    "task": "Convert a list of angles from degrees to radians using map.",
    "code": "```c\n#include <stdio.h>\n#include <math.h>\n\n#define SIZE 5\n\nvoid map(double *array, int size, double (*func)(double)) {\n    for (int i = 0; i < size; i++) {\n        array[i] = func(array[i]);\n    }\n}\n\ndouble degreesToRadians(double degrees) {\n    return degrees * (M_PI / 180.0);\n}\n\nint main() {\n    double degrees[SIZE] = {0.0, 30.0, 45.0, 90.0, 180.0};\n    \n    map(degrees, SIZE, degreesToRadians);\n    \n    for (int i = 0; i < SIZE; i++) {\n        printf(\"%f\\n\", degrees[i]);\n    }\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Use map to anonymize a list of IP addresses by masking parts of them.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_IPS 10\n#define IP_LENGTH 16\n\nvoid mask_ip(char *ip) {\n    int i, dots = 0;\n    for (i = 0; ip[i] != '\\0'; ++i) {\n        if (ip[i] == '.') {\n            dots++;\n        }\n        if (dots >= 2) {\n            ip[i] = 'x';\n        }\n    }\n}\n\nvoid map_ips(char ips[][IP_LENGTH], int count, void (*func)(char *)) {\n    for (int i = 0; i < count; ++i) {\n        func(ips[i]);\n    }\n}\n\nint main() {\n    char ip_addresses[MAX_IPS][IP_LENGTH] = {\n        \"192.168.0.1\",\n        \"10.0.0.1\",\n        \"172.16.0.1\",\n        \"192.168.1.1\",\n        \"10.1.1.1\"\n    };\n\n    int ip_count = 5;\n    map_ips(ip_addresses, ip_count, mask_ip);\n\n    for (int i = 0; i < ip_count; ++i) {\n        printf(\"%s\\n\", ip_addresses[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Transform a list of tuples by swapping their elements using a map function.",
    "code": "```c\n#include <stdio.h>\n\ntypedef struct {\n    int first;\n    int second;\n} Tuple;\n\nvoid swap(Tuple* t) {\n    int temp = t->first;\n    t->first = t->second;\n    t->second = temp;\n}\n\nvoid map(Tuple arr[], int len, void (*func)(Tuple*)) {\n    for (int i = 0; i < len; i++) {\n        func(&arr[i]);\n    }\n}\n\nint main() {\n    Tuple tuples[] = { {1, 2}, {3, 4}, {5, 6} };\n    int len = sizeof(tuples) / sizeof(tuples[0]);\n\n    map(tuples, len, swap);\n\n    for (int i = 0; i < len; i++) {\n        printf(\"(%d, %d)\\n\", tuples[i].first, tuples[i].second);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Use map to compute the greatest common divisor of pairs in a list of number pairs.",
    "code": "```c\n#include <stdio.h>\n\nint gcd(int a, int b) {\n    while (b != 0) {\n        int t = b;\n        b = a % b;\n        a = t;\n    }\n    return a;\n}\n\nvoid map(int (*func)(int, int), int pairs[][2], int results[], int size) {\n    for (int i = 0; i < size; i++) {\n        results[i] = func(pairs[i][0], pairs[i][1]);\n    }\n}\n\nint main() {\n    int pairs[][2] = {{48, 18}, {56, 98}, {99, 78}};\n    int size = sizeof(pairs) / sizeof(pairs[0]);\n    int results[size];\n\n    map(gcd, pairs, results, size);\n\n    for (int i = 0; i < size; i++) {\n        printf(\"GCD of pair (%d, %d) is %d\\n\", pairs[i][0], pairs[i][1], results[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Convert a list of file paths to their directory names using map.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Function to extract directory name from a file path\nchar* get_directory_name(const char* path) {\n    char* dir_name = strdup(path);\n    char* last_slash = strrchr(dir_name, '/');\n    if (last_slash != NULL) {\n        *last_slash = '\\0';\n    }\n    return dir_name;\n}\n\n// Function to map a list of file paths to their directory names\nvoid map_file_paths_to_directories(char* file_paths[], char* dir_names[], int count) {\n    for (int i = 0; i < count; i++) {\n        dir_names[i] = get_directory_name(file_paths[i]);\n    }\n}\n\nint main() {\n    char* file_paths[] = {\n        \"/home/user/docs/report.txt\",\n        \"/var/log/system.log\",\n        \"/usr/local/bin/script.sh\"\n    };\n    int count = sizeof(file_paths) / sizeof(file_paths[0]);\n\n    // Allocate memory for directory names\n    char** dir_names = malloc(count * sizeof(char*));\n    \n    // Map file paths to directory names\n    map_file_paths_to_directories(file_paths, dir_names, count);\n\n    // Print out the directory names\n    for (int i = 0; i < count; i++) {\n        printf(\"Directory: %s\\n\", dir_names[i]);\n        free(dir_names[i]); // Free the duplicated string\n    }\n\n    free(dir_names); // Free the array of directory names\n    return 0;\n}\n```"
  },
  {
    "task": "Use map to replace each vowel in a list of strings with a specific character.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n#define TARGET_CHAR '*'\n\nvoid replaceVowels(char *str) {\n    for (int i = 0; str[i]; i++) {\n        if (strchr(\"AEIOUaeiou\", str[i])) {\n            str[i] = TARGET_CHAR;\n        }\n    }\n}\n\nvoid map(char **strings, int size) {\n    for (int i = 0; i < size; i++) {\n        replaceVowels(strings[i]);\n    }\n}\n\nint main() {\n    char *strings[] = {\"apple\", \"banana\", \"orange\", \"grape\"};\n    int size = sizeof(strings) / sizeof(strings[0]);\n    \n    map(strings, size);\n\n    for (int i = 0; i < size; i++) {\n        printf(\"%s\\n\", strings[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Transform a list of integers to their hexadecimal representations using map.",
    "code": "```c\n#include <stdio.h>\n\nvoid toHex(int n, char *buffer) {\n    sprintf(buffer, \"%x\", n);\n}\n\nvoid mapToHex(int *arr, char hexArr[][9], int size) {\n    for (int i = 0; i < size; i++) {\n        toHex(arr[i], hexArr[i]);\n    }\n}\n\nint main() {\n    int numbers[] = {10, 255, 4096, 12345};\n    int size = sizeof(numbers) / sizeof(numbers[0]);\n    char hexNumbers[size][9]; // Buffer for hex strings\n\n    mapToHex(numbers, hexNumbers, size);\n\n    for (int i = 0; i < size; i++) {\n        printf(\"%s\\n\", hexNumbers[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Use map to apply a transformation matrix to a list of 2D vectors.",
    "code": "```c\n#include <stdio.h>\n\ntypedef struct {\n    double x, y;\n} Vector2D;\n\nVector2D applyTransformation(const Vector2D *vector, const double matrix[2][2]) {\n    Vector2D result;\n    result.x = matrix[0][0] * vector->x + matrix[0][1] * vector->y;\n    result.y = matrix[1][0] * vector->x + matrix[1][1] * vector->y;\n    return result;\n}\n\nvoid map(Vector2D *vectors, int size, const double matrix[2][2]) {\n    for (int i = 0; i < size; i++) {\n        vectors[i] = applyTransformation(&vectors[i], matrix);\n    }\n}\n\nint main() {\n    Vector2D vectors[] = {{1.0, 2.0}, {3.0, 4.0}, {5.0, 6.0}};\n    int size = sizeof(vectors) / sizeof(vectors[0]);\n    double matrix[2][2] = {{1.0, 0.0}, {0.0, 1.0}};\n\n    map(vectors, size, matrix);\n\n    for (int i = 0; i < size; i++) {\n        printf(\"Vector %d: (%.2f, %.2f)\\n\", i, vectors[i].x, vectors[i].y);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Convert a list of text strings to their phonetic alphabet equivalents using map.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_STR_LEN 100\n\nconst char* phonetic_alphabet[] = {\n    \"Alfa\", \"Bravo\", \"Charlie\", \"Delta\", \"Echo\", \"Foxtrot\", \"Golf\", \"Hotel\", \"India\", \"Juliett\",\n    \"Kilo\", \"Lima\", \"Mike\", \"November\", \"Oscar\", \"Papa\", \"Quebec\", \"Romeo\", \"Sierra\", \"Tango\",\n    \"Uniform\", \"Victor\", \"Whiskey\", \"X-ray\", \"Yankee\", \"Zulu\"\n};\n\nchar* to_phonetic(const char* text) {\n    char* result = malloc(strlen(text) * 10); // Max phonetic size estimation\n    result[0] = '\\0';\n    for (int i = 0; text[i] != '\\0'; i++) {\n        char c = text[i];\n        if (c >= 'a' && c <= 'z') {\n            strcat(result, phonetic_alphabet[c - 'a']);\n        } else if (c >= 'A' && c <= 'Z') {\n            strcat(result, phonetic_alphabet[c - 'A']);\n        }\n        if (text[i + 1] != '\\0') {\n            strcat(result, \" \");\n        }\n    }\n    return result;\n}\n\nvoid map_phonetic(char* result[], char* strings[], int len) {\n    for (int i = 0; i < len; i++) {\n        result[i] = to_phonetic(strings[i]);\n    }\n}\n\nint main() {\n    char* strings[] = {\"Hello\", \"World\"};\n    int len = sizeof(strings) / sizeof(strings[0]);\n    char* result[len];\n\n    map_phonetic(result, strings, len);\n\n    for (int i = 0; i < len; i++) {\n        printf(\"%s -> %s\\n\", strings[i], result[i]);\n        free(result[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Use map to determine if each word in a list is a palindrome, returning booleans.",
    "code": "```c\n#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool is_palindrome(const char* word) {\n    int len = strlen(word);\n    for (int i = 0; i < len / 2; i++) {\n        if (word[i] != word[len - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid map_palindrome(const char* words[], bool results[], int size) {\n    for (int i = 0; i < size; i++) {\n        results[i] = is_palindrome(words[i]);\n    }\n}\n\nint main() {\n    const char* words[] = {\"radar\", \"hello\", \"level\", \"world\", \"civic\"};\n    int size = sizeof(words) / sizeof(words[0]);\n    bool results[size];\n\n    map_palindrome(words, results, size);\n\n    for (int i = 0; i < size; i++) {\n        printf(\"%s: %s\\n\", words[i], results[i] ? \"true\" : \"false\");\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Transform a list of dictionaries by renaming a specified key using a map function.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_DICT_SIZE 100\n#define MAX_KEY_LEN 50\n#define MAX_VALUE_LEN 50\n\ntypedef struct {\n    char key[MAX_KEY_LEN];\n    char value[MAX_VALUE_LEN];\n} DictItem;\n\ntypedef struct {\n    DictItem items[MAX_DICT_SIZE];\n    int size;\n} Dictionary;\n\nvoid renameKey(DictItem *item, const char *oldKey, const char *newKey) {\n    if (strcmp(item->key, oldKey) == 0) {\n        strcpy(item->key, newKey);\n    }\n}\n\nvoid map(Dictionary *dicts, int dictCount, const char *oldKey, const char *newKey) {\n    for (int i = 0; i < dictCount; ++i) {\n        for (int j = 0; j < dicts[i].size; ++j) {\n            renameKey(&(dicts[i].items[j]), oldKey, newKey);\n        }\n    }\n}\n\nint main() {\n    Dictionary dicts[2] = {\n        {{{\"oldKey\", \"value1\"}, {\"anotherKey\", \"value2\"}}, 2},\n        {{{\"oldKey\", \"value3\"}, {\"anotherKey2\", \"value4\"}}, 2}\n    };\n\n    map(dicts, 2, \"oldKey\", \"newKey\");\n\n    for (int i = 0; i < 2; ++i) {\n        for (int j = 0; j < dicts[i].size; ++j) {\n            printf(\"%s: %s\\n\", dicts[i].items[j].key, dicts[i].items[j].value);\n        }\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Use map to compute the logarithm of each number in a list.",
    "code": "```c\n#include <stdio.h>\n#include <math.h>\n\nvoid map_logarithm(double *arr, double *result, int size) {\n    for (int i = 0; i < size; i++) {\n        result[i] = log(arr[i]);\n    }\n}\n\nint main() {\n    double numbers[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    int size = sizeof(numbers) / sizeof(numbers[0]);\n    double results[size];\n\n    map_logarithm(numbers, results, size);\n\n    for (int i = 0; i < size; i++) {\n        printf(\"%f\\n\", results[i]);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Convert a list of image file paths to grayscale versions using map.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <dirent.h>\n#include <jpeglib.h>\n\nvoid convert_to_grayscale(const char *input_path, const char *output_path) {\n    struct jpeg_decompress_struct cinfo;\n    struct jpeg_error_mgr jerr;\n    FILE *input_file = fopen(input_path, \"rb\");\n    if (!input_file) return;\n    \n    cinfo.err = jpeg_std_error(&jerr);\n    jpeg_create_decompress(&cinfo);\n    jpeg_stdio_src(&cinfo, input_file);\n    jpeg_read_header(&cinfo, TRUE);\n    jpeg_start_decompress(&cinfo);\n\n    int width = cinfo.output_width;\n    int height = cinfo.output_height;\n    int channels = cinfo.output_components;\n    unsigned char *buffer = (unsigned char *)malloc(width * channels);\n\n    FILE *output_file = fopen(output_path, \"wb\");\n    if (!output_file) {\n        fclose(input_file);\n        return;\n    }\n    struct jpeg_compress_struct cinfo_out;\n    struct jpeg_error_mgr jerr_out;\n    cinfo_out.err = jpeg_std_error(&jerr_out);\n    jpeg_create_compress(&cinfo_out);\n    jpeg_stdio_dest(&cinfo_out, output_file);\n    \n    cinfo_out.image_width = width;\n    cinfo_out.image_height = height;\n    cinfo_out.input_components = 1;\n    cinfo_out.in_color_space = JCS_GRAYSCALE;\n    jpeg_set_defaults(&cinfo_out);\n    jpeg_start_compress(&cinfo_out, TRUE);\n\n    while (cinfo.output_scanline < cinfo.output_height) {\n        jpeg_read_scanlines(&cinfo, &buffer, 1);\n        unsigned char *gray_buffer = (unsigned char *)malloc(width);\n        for (int i = 0; i < width; i++) {\n            int gray_value = 0;\n            for (int j = 0; j < channels; j++) {\n                gray_value += buffer[i * channels + j];\n            }\n            gray_buffer[i] = gray_value / channels;\n        }\n        jpeg_write_scanlines(&cinfo_out, &gray_buffer, 1);\n        free(gray_buffer);\n    }\n\n    jpeg_finish_decompress(&cinfo);\n    jpeg_destroy_decompress(&cinfo);\n    fclose(input_file);\n\n    jpeg_finish_compress(&cinfo_out);\n    jpeg_destroy_compress(&cinfo_out);\n    fclose(output_file);\n    free(buffer);\n}\n\nint main(int argc, char **argv) {\n    if (argc < 2) {\n        fprintf(stderr, \"Usage: %s <image1> <image2> ...\\n\", argv[0]);\n        return EXIT_FAILURE;\n    }\n\n    for (int i = 1; i < argc; i++) {\n        char output_path[256];\n        snprintf(output_path, sizeof(output_path), \"gray_%s\", argv[i]);\n        convert_to_grayscale(argv[i], output_path);\n    }\n\n    return EXIT_SUCCESS;\n}\n```"
  },
  {
    "task": "Use map to flatten a list of lists of strings into a single list of strings.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_STR_LEN 100\n\nchar** flatten(char*** list_of_lists, int outer_size, int* inner_sizes, int* result_size) {\n    // Calculate total size for the flattened list\n    int total_size = 0;\n    for (int i = 0; i < outer_size; ++i) {\n        total_size += inner_sizes[i];\n    }\n\n    // Allocate memory for the flattened list\n    char** result = (char**)malloc(total_size * sizeof(char*));\n    int index = 0;\n\n    // Flatten the list of lists\n    for (int i = 0; i < outer_size; ++i) {\n        for (int j = 0; j < inner_sizes[i]; ++j) {\n            result[index] = (char*)malloc((strlen(list_of_lists[i][j]) + 1) * sizeof(char));\n            strcpy(result[index], list_of_lists[i][j]);\n            ++index;\n        }\n    }\n\n    *result_size = total_size;\n    return result;\n}\n\nint main() {\n    // Example list of lists\n    char* list1[] = {\"hello\", \"world\"};\n    char* list2[] = {\"foo\", \"bar\", \"baz\"};\n    char** list_of_lists[] = {list1, list2};\n    int inner_sizes[] = {2, 3};\n    int outer_size = 2;\n\n    int result_size;\n    char** result = flatten(list_of_lists, outer_size, inner_sizes, &result_size);\n\n    // Print the flattened list\n    for (int i = 0; i < result_size; ++i) {\n        printf(\"%s\\n\", result[i]);\n        free(result[i]);  // Free each string\n    }\n    free(result);  // Free the list\n\n    return 0;\n}\n```"
  },
  {
    "task": "Transform a list of temperature readings to temperature anomalies using a map function.",
    "code": "```c\n#include <stdio.h>\n\n#define SIZE 5\n\nvoid map(double *readings, double *anomalies, int size, double (*func)(double)) {\n    for (int i = 0; i < size; i++) {\n        anomalies[i] = func(readings[i]);\n    }\n}\n\ndouble calculate_anomaly(double reading) {\n    double average = 15.0; // Example average temperature\n    return reading - average;\n}\n\nint main() {\n    double readings[SIZE] = {17.2, 14.5, 16.0, 13.8, 15.5};\n    double anomalies[SIZE];\n\n    map(readings, anomalies, SIZE, calculate_anomaly);\n\n    for (int i = 0; i < SIZE; i++) {\n        printf(\"Anomaly %d: %.2f\\n\", i, anomalies[i]);\n    }\n\n    return 0;\n}\n```"
  }
]