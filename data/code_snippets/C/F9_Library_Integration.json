[
  {
    "task": "Create a program that reads a CSV file using a library designed for parsing CSV data.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"csv.h\" // Assuming a CSV library is available with this header\n\nvoid field_cb(void *s, size_t len, void *data) {\n    char *field = (char *)malloc(len + 1);\n    memcpy(field, s, len);\n    field[len] = '\\0';\n    printf(\"Field: %s\\n\", field);\n    free(field);\n}\n\nvoid row_cb(int c, void *data) {\n    printf(\"End of row\\n\");\n}\n\nint main() {\n    struct csv_parser p;\n    FILE *fp;\n    char buf[1024];\n    size_t bytes_read;\n    \n    csv_init(&p, 0);\n    \n    fp = fopen(\"data.csv\", \"rb\");\n    if (!fp) {\n        perror(\"Failed to open file\");\n        return EXIT_FAILURE;\n    }\n    \n    while ((bytes_read = fread(buf, 1, 1024, fp)) > 0) {\n        if (csv_parse(&p, buf, bytes_read, field_cb, row_cb, NULL) != bytes_read) {\n            fprintf(stderr, \"Error while parsing file: %s\\n\", csv_strerror(csv_error(&p)));\n            fclose(fp);\n            csv_free(&p);\n            return EXIT_FAILURE;\n        }\n    }\n    \n    csv_fini(&p, field_cb, row_cb, NULL);\n    fclose(fp);\n    csv_free(&p);\n    \n    return EXIT_SUCCESS;\n}\n```"
  },
  {
    "task": "Implement a function that generates a random number using a standard library for random number generation.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\nint generate_random_number() {\n    srand(time(0));\n    return rand();\n}\n\nint main() {\n    int random_number = generate_random_number();\n    printf(\"Random Number: %d\\n\", random_number);\n    return 0;\n}\n```"
  },
  {
    "task": "Use a third-party library to send an HTTP GET request to a public API and print the response.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <curl/curl.h>\n\nsize_t write_callback(void *ptr, size_t size, size_t nmemb, void *stream) {\n    fwrite(ptr, size, nmemb, (FILE *)stream);\n    return size * nmemb;\n}\n\nint main(void) {\n    CURL *curl;\n    CURLcode res;\n\n    curl_global_init(CURL_GLOBAL_DEFAULT);\n    curl = curl_easy_init();\n    if(curl) {\n        FILE *response_file = tmpfile();\n        curl_easy_setopt(curl, CURLOPT_URL, \"https://api.example.com/data\");\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, response_file);\n\n        res = curl_easy_perform(curl);\n        if(res != CURLE_OK) {\n            fprintf(stderr, \"curl_easy_perform() failed: %s\\n\", curl_easy_strerror(res));\n        } else {\n            fseek(response_file, 0, SEEK_SET);\n            char buffer[1024];\n            while (fgets(buffer, sizeof(buffer), response_file) != NULL) {\n                printf(\"%s\", buffer);\n            }\n        }\n        fclose(response_file);\n        curl_easy_cleanup(curl);\n    }\n    curl_global_cleanup();\n    return 0;\n}\n```"
  },
  {
    "task": "Write a script that extracts the text from a PDF file using a library for PDF manipulation.",
    "code": "```c\n#include <stdio.h>\n#include <poppler/cpp/poppler-document.h>\n#include <poppler/cpp/poppler-page.h>\n\nint main(int argc, char **argv) {\n    if (argc != 2) {\n        fprintf(stderr, \"Usage: %s <pdf-file>\\n\", argv[0]);\n        return 1;\n    }\n\n    const char *pdf_file = argv[1];\n    poppler::document *doc = poppler::document::load_from_file(pdf_file);\n    if (!doc) {\n        fprintf(stderr, \"Failed to open PDF file: %s\\n\", pdf_file);\n        return 1;\n    }\n\n    int num_pages = doc->pages();\n    for (int i = 0; i < num_pages; ++i) {\n        poppler::page *p = doc->create_page(i);\n        if (p) {\n            std::string text = p->text().to_utf8();\n            printf(\"Page %d:\\n%s\\n\", i + 1, text.c_str());\n            delete p;\n        }\n    }\n\n    delete doc;\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a tool that resizes images by integrating an image processing library.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <wand/MagickWand.h>\n\nvoid ResizeImage(const char *inputImagePath, const char *outputImagePath, const size_t width, const size_t height) {\n    MagickWand *magick_wand;\n    MagickBooleanType status;\n\n    MagickWandGenesis();\n    magick_wand = NewMagickWand();\n\n    status = MagickReadImage(magick_wand, inputImagePath);\n    if (status == MagickFalse) {\n        fprintf(stderr, \"Failed to read the image.\\n\");\n        magick_wand = DestroyMagickWand(magick_wand);\n        MagickWandTerminus();\n        return;\n    }\n\n    status = MagickResizeImage(magick_wand, width, height, LanczosFilter, 1.0);\n    if (status == MagickFalse) {\n        fprintf(stderr, \"Failed to resize the image.\\n\");\n        magick_wand = DestroyMagickWand(magick_wand);\n        MagickWandTerminus();\n        return;\n    }\n\n    status = MagickWriteImage(magick_wand, outputImagePath);\n    if (status == MagickFalse) {\n        fprintf(stderr, \"Failed to write the image.\\n\");\n    }\n\n    magick_wand = DestroyMagickWand(magick_wand);\n    MagickWandTerminus();\n}\n\nint main(int argc, char *argv[]) {\n    if (argc != 5) {\n        fprintf(stderr, \"Usage: %s <input image> <output image> <width> <height>\\n\", argv[0]);\n        return 1;\n    }\n\n    const char *inputImagePath = argv[1];\n    const char *outputImagePath = argv[2];\n    size_t width = atoi(argv[3]);\n    size_t height = atoi(argv[4]);\n\n    ResizeImage(inputImagePath, outputImagePath, width, height);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a program that connects to a database using a library for database interaction.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <libpq-fe.h>\n\nint main() {\n    PGconn *conn = PQconnectdb(\"user=yourusername dbname=yourdbname\");\n\n    if (PQstatus(conn) != CONNECTION_OK) {\n        fprintf(stderr, \"Connection to database failed: %s\", PQerrorMessage(conn));\n        PQfinish(conn);\n        exit(1);\n    }\n\n    printf(\"Connected to database successfully.\\n\");\n\n    PQfinish(conn);\n    return 0;\n}\n```"
  },
  {
    "task": "Build an application that converts Markdown text to HTML using a Markdown parsing library.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <markdown.h>\n\nint main() {\n    const char *markdownText = \"# Hello World\\nThis is a *markdown* text.\";\n    char *htmlOutput;\n    struct buf *ib, *ob;\n    \n    ib = bufnew(strlen(markdownText));\n    ob = bufnew(64);\n    \n    bufputs(ib, markdownText);\n\n    sd_markdown *markdown = sd_markdown_new(MKDEXT_NO_INTRA_EMPHASIS, 16, NULL, NULL);\n    sd_markdown_render(ob, ib->data, ib->size, markdown);\n    sd_markdown_free(markdown);\n    \n    htmlOutput = (char *)malloc(ob->size + 1);\n    memcpy(htmlOutput, ob->data, ob->size);\n    htmlOutput[ob->size] = '\\0';\n\n    printf(\"HTML Output:\\n%s\\n\", htmlOutput);\n\n    free(htmlOutput);\n    bufrelease(ib);\n    bufrelease(ob);\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Use a library to transform XML data into JSON format for easier manipulation.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <libxml/parser.h>\n#include <libxml/tree.h>\n#include <json-c/json.h>\n\nvoid xmlNodeToJson(xmlNode *node, struct json_object *jsonObj) {\n    for (xmlNode *current = node; current; current = current->next) {\n        if (current->type == XML_ELEMENT_NODE) {\n            struct json_object *childObj = json_object_new_object();\n            if (current->children) {\n                xmlNodeToJson(current->children, childObj);\n            }\n            json_object_object_add(jsonObj, (const char *)current->name, childObj);\n        } else if (current->type == XML_TEXT_NODE) {\n            if (current->content && strlen((const char *)current->content) > 0) {\n                json_object_object_add(jsonObj, \"text\", json_object_new_string((const char *)current->content));\n            }\n        }\n    }\n}\n\nint main() {\n    const char *xmlData = \"<root><item>Value</item></root>\";\n    xmlDocPtr doc = xmlReadMemory(xmlData, strlen(xmlData), \"noname.xml\", NULL, 0);\n    if (doc == NULL) {\n        fprintf(stderr, \"Failed to parse XML\\n\");\n        return 1;\n    }\n\n    xmlNode *rootElement = xmlDocGetRootElement(doc);\n    struct json_object *jsonObj = json_object_new_object();\n    xmlNodeToJson(rootElement, jsonObj);\n\n    printf(\"JSON Output:\\n%s\\n\", json_object_to_json_string(jsonObj));\n\n    json_object_put(jsonObj);\n    xmlFreeDoc(doc);\n    xmlCleanupParser();\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a feature that schedules tasks at regular intervals using a scheduler library.",
    "code": "```c\n#include <stdio.h>\n#include <unistd.h>\n#include <signal.h>\n#include <time.h>\n\nvoid task_to_schedule() {\n    printf(\"Task executed\\n\");\n}\n\nvoid timer_handler(int signum) {\n    task_to_schedule();\n}\n\nint main() {\n    struct sigaction sa;\n    struct itimerval timer;\n\n    sa.sa_handler = &timer_handler;\n    sigaction(SIGALRM, &sa, NULL);\n\n    timer.it_value.tv_sec = 1;\n    timer.it_value.tv_usec = 0;\n    timer.it_interval.tv_sec = 1;\n    timer.it_interval.tv_usec = 0;\n\n    setitimer(ITIMER_REAL, &timer, NULL);\n\n    while (1) {\n        pause();\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a chat application that utilizes a library for WebSocket communication.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <libwebsockets.h>\n\nstatic int callback_chat(struct lws *wsi, enum lws_callback_reasons reason, void *user, void *in, size_t len) {\n    switch (reason) {\n        case LWS_CALLBACK_RECEIVE:\n            printf(\"Received: %s\\n\", (char *)in);\n            break;\n        case LWS_CALLBACK_ESTABLISHED:\n            printf(\"Connection established\\n\");\n            break;\n        case LWS_CALLBACK_CLOSED:\n            printf(\"Connection closed\\n\");\n            break;\n        default:\n            break;\n    }\n    return 0;\n}\n\nint main() {\n    struct lws_context_creation_info info;\n    struct lws_context *context;\n    struct lws_protocols protocols[] = {\n        { \"chat-protocol\", callback_chat, 0, 4096 },\n        { NULL, NULL, 0, 0 }\n    };\n    \n    memset(&info, 0, sizeof(info));\n    info.port = 8080;\n    info.protocols = protocols;\n\n    context = lws_create_context(&info);\n    if (!context) {\n        fprintf(stderr, \"lws init failed\\n\");\n        return -1;\n    }\n    \n    printf(\"Starting chat server...\\n\");\n    while (1) {\n        lws_service(context, 1000);\n    }\n\n    lws_context_destroy(context);\n    return 0;\n}\n```"
  },
  {
    "task": "Create a game that uses a library to handle physics simulations for realistic movements.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include \"some_physics_library.h\"\n\ntypedef struct {\n    float x, y;\n    float velocityX, velocityY;\n} GameObject;\n\nvoid initGameObject(GameObject* obj, float x, float y) {\n    obj->x = x;\n    obj->y = y;\n    obj->velocityX = 0.0f;\n    obj->velocityY = 0.0f;\n}\n\nvoid updatePhysics(GameObject* obj, float deltaTime) {\n    PhysicsBody body;\n    body.position.x = obj->x;\n    body.position.y = obj->y;\n    body.velocity.x = obj->velocityX;\n    body.velocity.y = obj->velocityY;\n\n    simulatePhysics(&body, deltaTime);\n\n    obj->x = body.position.x;\n    obj->y = body.position.y;\n    obj->velocityX = body.velocity.x;\n    obj->velocityY = body.velocity.y;\n}\n\nint main() {\n    GameObject player;\n    initGameObject(&player, 0.0f, 0.0f);\n    \n    float deltaTime = 0.016f; // Assuming 60 FPS\n    while (1) {\n        updatePhysics(&player, deltaTime);\n        \n        printf(\"Player Position: (%f, %f)\\n\", player.x, player.y);\n        \n        // Game loop delay (for demonstration purposes, not accurate timing)\n        usleep(16000);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a function that hashes a string using a cryptographic hashing library.",
    "code": "```c\n#include <stdio.h>\n#include <openssl/evp.h>\n#include <string.h>\n\nvoid hash_string(const char *input, unsigned char *output, unsigned int *output_len) {\n    EVP_MD_CTX *mdctx;\n    const EVP_MD *md;\n    \n    md = EVP_sha256();\n    mdctx = EVP_MD_CTX_new();\n    EVP_DigestInit_ex(mdctx, md, NULL);\n    EVP_DigestUpdate(mdctx, input, strlen(input));\n    EVP_DigestFinal_ex(mdctx, output, output_len);\n    EVP_MD_CTX_free(mdctx);\n}\n\nint main() {\n    const char *input_string = \"Hello, World!\";\n    unsigned char hash_output[EVP_MAX_MD_SIZE];\n    unsigned int hash_output_len;\n\n    hash_string(input_string, hash_output, &hash_output_len);\n\n    for (unsigned int i = 0; i < hash_output_len; ++i) {\n        printf(\"%02x\", hash_output[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n```"
  },
  {
    "task": "Build a program that validates email addresses using a library for regular expression matching.",
    "code": "```c\n#include <stdio.h>\n#include <regex.h>\n\nint validate_email(const char *email) {\n    regex_t regex;\n    int result;\n    const char *pattern = \"^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}$\";\n\n    result = regcomp(&regex, pattern, REG_EXTENDED);\n    if (result) {\n        return 0;\n    }\n\n    result = regexec(&regex, email, 0, NULL, 0);\n    regfree(&regex);\n\n    return result == 0;\n}\n\nint main() {\n    const char *email = \"example@example.com\";\n    if (validate_email(email)) {\n        printf(\"Valid email address.\\n\");\n    } else {\n        printf(\"Invalid email address.\\n\");\n    }\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a feature that reads and writes Excel files using a library tailored for Excel file manipulation.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <libxls/xls.h>\n#include <xlsxwriter.h>\n\nvoid read_excel(const char *filename) {\n    xlsWorkBook* workbook = xls_open(filename, \"UTF-8\");\n    if (workbook != NULL) {\n        xlsWorkSheet* worksheet = xls_getWorkSheet(workbook, 0);\n        xls_parseWorkSheet(worksheet);\n        for (uint16_t row = 0; row <= worksheet->rows.lastrow; ++row) {\n            for (uint16_t col = 0; col <= worksheet->rows.lastcol; ++col) {\n                xlsCell* cell = xls_cell(worksheet, row, col);\n                if (cell != NULL) {\n                    printf(\"Cell[%d,%d]: %s\\n\", row, col, cell->str);\n                }\n            }\n        }\n        xls_close_WS(worksheet);\n        xls_close_WB(workbook);\n    } else {\n        fprintf(stderr, \"Failed to open Excel file.\\n\");\n    }\n}\n\nvoid write_excel(const char *filename) {\n    lxw_workbook  *workbook  = workbook_new(filename);\n    lxw_worksheet *worksheet = workbook_add_worksheet(workbook, NULL);\n    worksheet_write_string(worksheet, 0, 0, \"Hello\", NULL);\n    worksheet_write_string(worksheet, 1, 1, \"Excel\", NULL);\n    workbook_close(workbook);\n}\n\nint main() {\n    const char *read_filename = \"input.xls\";\n    const char *write_filename = \"output.xlsx\";\n\n    printf(\"Reading Excel file...\\n\");\n    read_excel(read_filename);\n\n    printf(\"Writing Excel file...\\n\");\n    write_excel(write_filename);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Use a library to translate text from one language to another in your application.",
    "code": "```c\n#include <stdio.h>\n#include <libtranslate.h> // Hypothetical library for translation\n\nint main() {\n    // Initialize the translation engine\n    translate_engine_t *engine = translate_engine_new();\n\n    // Set the source and target languages\n    translate_engine_set_languages(engine, \"en\", \"es\"); // English to Spanish\n\n    // Text to be translated\n    const char *input_text = \"Hello, world!\";\n    char *translated_text;\n\n    // Translate the text\n    translated_text = translate_engine_translate(engine, input_text);\n\n    // Output the translated text\n    printf(\"Translated Text: %s\\n\", translated_text);\n\n    // Clean up\n    translate_engine_free(engine);\n    free(translated_text);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a script that generates QR codes using a library for QR code creation.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <qrencode.h>\n\nint main() {\n    const char *text = \"https://example.com\";\n    QRcode *qrcode = QRcode_encodeString(text, 0, QR_ECLEVEL_L, QR_MODE_8, 1);\n\n    if (qrcode != NULL) {\n        FILE *fp = fopen(\"qrcode.pbm\", \"wb\");\n        if (fp != NULL) {\n            fprintf(fp, \"P4\\n%d %d\\n\", qrcode->width, qrcode->width);\n            for (int y = 0; y < qrcode->width; y++) {\n                for (int x = 0; x < qrcode->width; x++) {\n                    fputc(qrcode->data[y * qrcode->width + x] & 1 ? 0 : 1, fp);\n                }\n            }\n            fclose(fp);\n        }\n        QRcode_free(qrcode);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Build an app that plays audio files using a library for audio processing.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <ao/ao.h>\n#include <mpg123.h>\n\n#define BITS 8\n\nint main(int argc, char *argv[]) {\n    if (argc < 2) {\n        fprintf(stderr, \"Usage: %s <audiofile>\\n\", argv[0]);\n        return 1;\n    }\n\n    ao_initialize();\n    int driver = ao_default_driver_id();\n\n    mpg123_init();\n    mpg123_handle *mh = mpg123_new(NULL, NULL);\n    unsigned char *buffer;\n    size_t buffer_size;\n    size_t done;\n    int err;\n\n    long rate;\n    int channels, encoding;\n\n    mpg123_open(mh, argv[1]);\n    mpg123_getformat(mh, &rate, &channels, &encoding);\n\n    ao_sample_format format;\n    format.bits = mpg123_encsize(encoding) * BITS;\n    format.channels = channels;\n    format.rate = rate;\n    format.byte_format = AO_FMT_NATIVE;\n    format.matrix = 0;\n\n    ao_device *device = ao_open_live(driver, &format, NULL);\n\n    buffer_size = mpg123_outblock(mh);\n    buffer = (unsigned char*) malloc(buffer_size * sizeof(unsigned char));\n\n    while (mpg123_read(mh, buffer, buffer_size, &done) == MPG123_OK) {\n        ao_play(device, (char*)buffer, done);\n    }\n\n    free(buffer);\n    ao_close(device);\n    mpg123_close(mh);\n    mpg123_delete(mh);\n    mpg123_exit();\n    ao_shutdown();\n\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a tool that scrapes web pages for specific data using a web scraping library.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <libxml/HTMLparser.h>\n#include <libxml/xpath.h>\n#include <curl/curl.h>\n\nstruct MemoryStruct {\n    char *memory;\n    size_t size;\n};\n\nstatic size_t WriteMemoryCallback(void *contents, size_t size, size_t nmemb, void *userp) {\n    size_t realsize = size * nmemb;\n    struct MemoryStruct *mem = (struct MemoryStruct *)userp;\n\n    char *ptr = realloc(mem->memory, mem->size + realsize + 1);\n    if (ptr == NULL) {\n        printf(\"Not enough memory (realloc returned NULL)\\n\");\n        return 0;\n    }\n\n    mem->memory = ptr;\n    memcpy(&(mem->memory[mem->size]), contents, realsize);\n    mem->size += realsize;\n    mem->memory[mem->size] = 0;\n\n    return realsize;\n}\n\nvoid scrapeWebPage(const char *url, const char *xpathExpr) {\n    CURL *curl_handle;\n    CURLcode res;\n    struct MemoryStruct chunk;\n\n    chunk.memory = malloc(1);\n    chunk.size = 0;\n\n    curl_global_init(CURL_GLOBAL_ALL);\n    curl_handle = curl_easy_init();\n    curl_easy_setopt(curl_handle, CURLOPT_URL, url);\n    curl_easy_setopt(curl_handle, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);\n    curl_easy_setopt(curl_handle, CURLOPT_WRITEDATA, (void *)&chunk);\n    curl_easy_setopt(curl_handle, CURLOPT_FOLLOWLOCATION, 1L);\n\n    res = curl_easy_perform(curl_handle);\n    if (res != CURLE_OK) {\n        fprintf(stderr, \"curl_easy_perform() failed: %s\\n\", curl_easy_strerror(res));\n    } else {\n        htmlDocPtr doc = htmlReadMemory(chunk.memory, chunk.size, url, NULL, HTML_PARSE_NOERROR | HTML_PARSE_NOWARNING);\n        if (doc != NULL) {\n            xmlXPathContextPtr xpathCtx = xmlXPathNewContext(doc);\n            xmlXPathObjectPtr xpathObj = xmlXPathEvalExpression((const xmlChar *)xpathExpr, xpathCtx);\n\n            if (xpathObj && !xmlXPathNodeSetIsEmpty(xpathObj->nodesetval)) {\n                for (int i = 0; i < xpathObj->nodesetval->nodeNr; i++) {\n                    xmlNodePtr node = xpathObj->nodesetval->nodeTab[i];\n                    if (node->type == XML_ELEMENT_NODE) {\n                        xmlChar *content = xmlNodeGetContent(node);\n                        printf(\"Found: %s\\n\", content);\n                        xmlFree(content);\n                    }\n                }\n            }\n\n            xmlXPathFreeObject(xpathObj);\n            xmlXPathFreeContext(xpathCtx);\n            xmlFreeDoc(doc);\n        }\n    }\n\n    curl_easy_cleanup(curl_handle);\n    free(chunk.memory);\n    curl_global_cleanup();\n}\n\nint main() {\n    const char *url = \"http://example.com\";\n    const char *xpath = \"//h1\";\n    scrapeWebPage(url, xpath);\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a service that sends emails using a library that facilitates SMTP communication.",
    "code": "```c\n#include <stdio.h>\n#include <libesmtp.h>\n\nvoid send_email(const char *to, const char *from, const char *subject, const char *body) {\n    smtp_session_t session;\n    smtp_message_t message;\n    smtp_recipient_t recipient;\n    const smtp_status_t *status;\n\n    smtp_startup(NULL, NULL);\n\n    session = smtp_create_session();\n    smtp_set_server(session, \"smtp.example.com\");\n\n    message = smtp_add_message(session);\n    smtp_set_reverse_path(message, from);\n    smtp_set_header(message, \"From\", from, NULL);\n    smtp_set_header(message, \"To\", to, NULL);\n    smtp_set_header(message, \"Subject\", subject);\n\n    smtp_add_recipient(message, to);\n    \n    smtp_set_message_str(message, body);\n\n    if (smtp_start_session(session)) {\n        status = smtp_message_transfer_status(message);\n        printf(\"Email sent: %d %s\\n\", status->code, status->text);\n    } else {\n        fprintf(stderr, \"Failed to send email\\n\");\n    }\n\n    smtp_destroy_session(session);\n    smtp_cleanup();\n}\n\nint main() {\n    send_email(\"recipient@example.com\", \"sender@example.com\", \"Test Email\", \"This is a test email.\");\n    return 0;\n}\n```"
  },
  {
    "task": "Create a program that visualizes data in charts using a charting library.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <cairo.h>\n#include <cairo-pdf.h>\n\nvoid draw_chart(cairo_t *cr) {\n    cairo_set_source_rgb(cr, 0, 0, 0);\n    cairo_set_line_width(cr, 2);\n\n    // Draw X and Y axis\n    cairo_move_to(cr, 50, 50);\n    cairo_line_to(cr, 50, 400);\n    cairo_line_to(cr, 450, 400);\n    cairo_stroke(cr);\n\n    // Sample data\n    double data[] = {50, 100, 150, 200, 250};\n    int data_length = sizeof(data) / sizeof(data[0]);\n\n    // Plot the data\n    for (int i = 0; i < data_length; i++) {\n        cairo_arc(cr, 50 + i * 80, 400 - data[i], 5, 0, 2 * 3.14);\n        cairo_fill(cr);\n    }\n}\n\nint main() {\n    cairo_surface_t *surface;\n    cairo_t *cr;\n\n    surface = cairo_pdf_surface_create(\"chart.pdf\", 500, 500);\n    cr = cairo_create(surface);\n\n    draw_chart(cr);\n\n    cairo_destroy(cr);\n    cairo_surface_destroy(surface);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a script that compresses files into a zip archive using a standard library.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <zip.h>\n\nint main(int argc, char *argv[]) {\n    if (argc < 3) {\n        fprintf(stderr, \"Usage: %s <output.zip> <file1> <file2> ... <fileN>\\n\", argv[0]);\n        return 1;\n    }\n\n    int error = 0;\n    zip_t *archive = zip_open(argv[1], ZIP_CREATE | ZIP_TRUNCATE, &error);\n    if (!archive) {\n        fprintf(stderr, \"Could not create archive: %s\\n\", zip_strerror(archive));\n        return 1;\n    }\n\n    for (int i = 2; i < argc; i++) {\n        zip_source_t *source = zip_source_file(archive, argv[i], 0, 0);\n        if (source == NULL) {\n            fprintf(stderr, \"Could not add file %s: %s\\n\", argv[i], zip_strerror(archive));\n            zip_close(archive);\n            return 1;\n        }\n\n        if (zip_file_add(archive, argv[i], source, ZIP_FL_OVERWRITE) < 0) {\n            fprintf(stderr, \"Could not add file %s: %s\\n\", argv[i], zip_strerror(archive));\n            zip_source_free(source);\n            zip_close(archive);\n            return 1;\n        }\n    }\n\n    if (zip_close(archive) < 0) {\n        fprintf(stderr, \"Could not close archive: %s\\n\", zip_strerror(archive));\n        return 1;\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Use a library to parse command-line arguments in your application.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <getopt.h>\n\nint main(int argc, char *argv[]) {\n    int opt;\n    const char *short_opts = \"a:b:c:\";\n    const struct option long_opts[] = {\n        {\"alpha\", required_argument, NULL, 'a'},\n        {\"beta\", required_argument, NULL, 'b'},\n        {\"charlie\", required_argument, NULL, 'c'},\n        {NULL, no_argument, NULL, 0}\n    };\n\n    while ((opt = getopt_long(argc, argv, short_opts, long_opts, NULL)) != -1) {\n        switch (opt) {\n            case 'a':\n                printf(\"Option alpha with value '%s'\\n\", optarg);\n                break;\n            case 'b':\n                printf(\"Option beta with value '%s'\\n\", optarg);\n                break;\n            case 'c':\n                printf(\"Option charlie with value '%s'\\n\", optarg);\n                break;\n            default:\n                fprintf(stderr, \"Usage: %s [-a alpha] [-b beta] [-c charlie]\\n\", argv[0]);\n                return EXIT_FAILURE;\n        }\n    }\n    return EXIT_SUCCESS;\n}\n```"
  },
  {
    "task": "Build a weather application that displays data from a weather API using a library for JSON parsing.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <curl/curl.h>\n#include <jansson.h>\n\nstruct MemoryStruct {\n    char *memory;\n    size_t size;\n};\n\nstatic size_t WriteMemoryCallback(void *contents, size_t size, size_t nmemb, void *userp) {\n    size_t realsize = size * nmemb;\n    struct MemoryStruct *mem = (struct MemoryStruct *)userp;\n\n    char *ptr = realloc(mem->memory, mem->size + realsize + 1);\n    if(ptr == NULL) {\n        printf(\"Not enough memory (realloc returned NULL)\\n\");\n        return 0;\n    }\n\n    mem->memory = ptr;\n    memcpy(&(mem->memory[mem->size]), contents, realsize);\n    mem->size += realsize;\n    mem->memory[mem->size] = 0;\n\n    return realsize;\n}\n\nint main(void) {\n    CURL *curl_handle;\n    CURLcode res;\n    struct MemoryStruct chunk;\n    const char *api_url = \"http://api.weatherapi.com/v1/current.json?key=YOUR_API_KEY&q=London\";\n\n    chunk.memory = malloc(1);\n    chunk.size = 0;\n\n    curl_global_init(CURL_GLOBAL_ALL);\n    curl_handle = curl_easy_init();\n    curl_easy_setopt(curl_handle, CURLOPT_URL, api_url);\n    curl_easy_setopt(curl_handle, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);\n    curl_easy_setopt(curl_handle, CURLOPT_WRITEDATA, (void *)&chunk);\n\n    res = curl_easy_perform(curl_handle);\n\n    if(res != CURLE_OK) {\n        fprintf(stderr, \"curl_easy_perform() failed: %s\\n\", curl_easy_strerror(res));\n    } else {\n        json_error_t error;\n        json_t *root = json_loads(chunk.memory, 0, &error);\n        if(root) {\n            json_t *location = json_object_get(root, \"location\");\n            json_t *current = json_object_get(root, \"current\");\n            if(json_is_object(location) && json_is_object(current)) {\n                const char *name = json_string_value(json_object_get(location, \"name\"));\n                double temp_c = json_number_value(json_object_get(current, \"temp_c\"));\n                printf(\"Location: %s\\n\", name);\n                printf(\"Temperature (C): %.2f\\n\", temp_c);\n            }\n            json_decref(root);\n        } else {\n            fprintf(stderr, \"JSON error: %s\\n\", error.text);\n        }\n    }\n\n    curl_easy_cleanup(curl_handle);\n    free(chunk.memory);\n    curl_global_cleanup();\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a video player application using a library that handles video playback.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <vlc/vlc.h>\n\nint main() {\n    libvlc_instance_t *inst;\n    libvlc_media_player_t *mp;\n    libvlc_media_t *m;\n\n    // Initialize libVLC\n    inst = libvlc_new(0, NULL);\n    if (inst == NULL) {\n        fprintf(stderr, \"Failed to initialize libVLC\\n\");\n        return EXIT_FAILURE;\n    }\n\n    // Create a new media\n    m = libvlc_media_new_path(inst, \"example_video.mp4\");\n    if (m == NULL) {\n        fprintf(stderr, \"Failed to create media\\n\");\n        libvlc_release(inst);\n        return EXIT_FAILURE;\n    }\n\n    // Create a media player\n    mp = libvlc_media_player_new_from_media(m);\n    libvlc_media_release(m);\n    if (mp == NULL) {\n        fprintf(stderr, \"Failed to create media player\\n\");\n        libvlc_release(inst);\n        return EXIT_FAILURE;\n    }\n\n    // Play the media\n    libvlc_media_player_play(mp);\n\n    // Wait for the video to finish\n    printf(\"Press Enter to exit...\\n\");\n    getchar();\n\n    // Stop and release the media player\n    libvlc_media_player_stop(mp);\n    libvlc_media_player_release(mp);\n\n    // Release libVLC instance\n    libvlc_release(inst);\n\n    return EXIT_SUCCESS;\n}\n```"
  },
  {
    "task": "Develop a system that logs application events using a logging library for better traceability.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <log4c.h>\n\n#define LOG_CATEGORY \"myapp.category\"\n\nvoid initialize_logging() {\n    if (log4c_init()) {\n        fprintf(stderr, \"Failed to initialize log4c\\n\");\n        exit(EXIT_FAILURE);\n    }\n}\n\nvoid finalize_logging() {\n    if (log4c_fini()) {\n        fprintf(stderr, \"Failed to finalize log4c\\n\");\n    }\n}\n\nvoid log_event(const char* event) {\n    log4c_category_t* category = log4c_category_get(LOG_CATEGORY);\n    log4c_category_log(category, LOG4C_PRIORITY_INFO, \"%s\", event);\n}\n\nint main() {\n    initialize_logging();\n\n    log_event(\"Application started\");\n    // Application code here\n    log_event(\"Application running\");\n\n    finalize_logging();\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a feature that encrypts and decrypts data using a library for encryption.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n#include <openssl/evp.h>\n\nvoid handleErrors(void) {\n    ERR_print_errors_fp(stderr);\n    abort();\n}\n\nint encrypt(unsigned char *plaintext, int plaintext_len, unsigned char *key,\n            unsigned char *iv, unsigned char *ciphertext) {\n    EVP_CIPHER_CTX *ctx;\n    int len;\n    int ciphertext_len;\n\n    if (!(ctx = EVP_CIPHER_CTX_new())) handleErrors();\n\n    if (1 != EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, key, iv))\n        handleErrors();\n\n    if (1 != EVP_EncryptUpdate(ctx, ciphertext, &len, plaintext, plaintext_len))\n        handleErrors();\n    ciphertext_len = len;\n\n    if (1 != EVP_EncryptFinal_ex(ctx, ciphertext + len, &len)) handleErrors();\n    ciphertext_len += len;\n\n    EVP_CIPHER_CTX_free(ctx);\n\n    return ciphertext_len;\n}\n\nint decrypt(unsigned char *ciphertext, int ciphertext_len, unsigned char *key,\n            unsigned char *iv, unsigned char *plaintext) {\n    EVP_CIPHER_CTX *ctx;\n    int len;\n    int plaintext_len;\n\n    if (!(ctx = EVP_CIPHER_CTX_new())) handleErrors();\n\n    if (1 != EVP_DecryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, key, iv))\n        handleErrors();\n\n    if (1 != EVP_DecryptUpdate(ctx, plaintext, &len, ciphertext, ciphertext_len))\n        handleErrors();\n    plaintext_len = len;\n\n    if (1 != EVP_DecryptFinal_ex(ctx, plaintext + len, &len)) handleErrors();\n    plaintext_len += len;\n\n    EVP_CIPHER_CTX_free(ctx);\n\n    return plaintext_len;\n}\n\nint main(void) {\n    unsigned char *key = (unsigned char *)\"01234567890123456789012345678901\";\n    unsigned char *iv = (unsigned char *)\"0123456789012345\";\n    unsigned char *plaintext = (unsigned char *)\"The quick brown fox jumps over the lazy dog\";\n\n    unsigned char ciphertext[128];\n    unsigned char decryptedtext[128];\n\n    int decryptedtext_len, ciphertext_len;\n\n    ciphertext_len = encrypt(plaintext, strlen((char *)plaintext), key, iv, ciphertext);\n\n    decryptedtext_len = decrypt(ciphertext, ciphertext_len, key, iv, decryptedtext);\n\n    decryptedtext[decryptedtext_len] = '\\0';\n\n    printf(\"Decrypted text is:\\n\");\n    printf(\"%s\\n\", decryptedtext);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a program that fetches and displays cryptocurrency prices using a third-party library for API interaction.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <curl/curl.h>\n\nstruct MemoryStruct {\n    char *memory;\n    size_t size;\n};\n\nstatic size_t WriteMemoryCallback(void *contents, size_t size, size_t nmemb, void *userp) {\n    size_t realsize = size * nmemb;\n    struct MemoryStruct *mem = (struct MemoryStruct *)userp;\n\n    char *ptr = realloc(mem->memory, mem->size + realsize + 1);\n    if(ptr == NULL) {\n        printf(\"Not enough memory (realloc returned NULL)\\n\");\n        return 0;\n    }\n\n    mem->memory = ptr;\n    memcpy(&(mem->memory[mem->size]), contents, realsize);\n    mem->size += realsize;\n    mem->memory[mem->size] = 0;\n\n    return realsize;\n}\n\nint main(void) {\n    CURL *curl_handle;\n    CURLcode res;\n\n    struct MemoryStruct chunk;\n    chunk.memory = malloc(1);\n    chunk.size = 0;\n\n    curl_global_init(CURL_GLOBAL_ALL);\n    curl_handle = curl_easy_init();\n\n    curl_easy_setopt(curl_handle, CURLOPT_URL, \"https://api.coingecko.com/api/v3/simple/price?ids=bitcoin,ethereum&vs_currencies=usd\");\n    curl_easy_setopt(curl_handle, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);\n    curl_easy_setopt(curl_handle, CURLOPT_WRITEDATA, (void *)&chunk);\n\n    res = curl_easy_perform(curl_handle);\n\n    if(res != CURLE_OK) {\n        fprintf(stderr, \"curl_easy_perform() failed: %s\\n\", curl_easy_strerror(res));\n    } else {\n        printf(\"%s\\n\", chunk.memory);\n    }\n\n    curl_easy_cleanup(curl_handle);\n    free(chunk.memory);\n    curl_global_cleanup();\n\n    return 0;\n}\n```"
  },
  {
    "task": "Use a library to implement OAuth authentication for secure user login in your application.",
    "code": "```c\n#include <oauth.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    const char *consumer_key = \"your_consumer_key\";\n    const char *consumer_secret = \"your_consumer_secret\";\n    const char *request_token_url = \"https://provider.com/oauth/request_token\";\n    const char *access_token_url = \"https://provider.com/oauth/access_token\";\n    const char *authorize_url = \"https://provider.com/oauth/authorize\";\n    \n    char *request_token = NULL;\n    char *request_token_secret = NULL;\n    char *access_token = NULL;\n    char *access_token_secret = NULL;\n    char *url = NULL;\n\n    // Request a request token\n    url = oauth_sign_url2(request_token_url, &request_token, OA_HMAC, consumer_key, consumer_secret, NULL, NULL);\n    printf(\"Request Token URL: %s\\n\", url);\n\n    // Normally, you'd open this URL in a browser to authorize the application\n    printf(\"Please visit this URL to authorize: %s\\n\", oauth_sign_url2(authorize_url, NULL, OA_HMAC, consumer_key, consumer_secret, request_token, request_token_secret));\n\n    // Simulate user authorization and exchange request token for access token\n    // This requires user interaction in a real scenario\n    url = oauth_sign_url2(access_token_url, &access_token, OA_HMAC, consumer_key, consumer_secret, request_token, request_token_secret);\n    printf(\"Access Token URL: %s\\n\", url);\n\n    // Use the access token obtained\n    printf(\"Access Token: %s\\n\", access_token);\n\n    // Clean up\n    free(request_token);\n    free(request_token_secret);\n    free(access_token);\n    free(access_token_secret);\n    free(url);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Build a calculator that evaluates mathematical expressions using a math parsing library.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <muParser.h>\n\ndouble evaluateExpression(const char *expression) {\n    muParserHandle_t parser = mupCreate();\n    mupSetExpr(parser, expression);\n\n    double result = 0;\n    mupEval(parser, &result);\n\n    mupRelease(parser);\n    return result;\n}\n\nint main() {\n    char expression[256];\n    printf(\"Enter a mathematical expression: \");\n    fgets(expression, sizeof(expression), stdin);\n\n    double result = evaluateExpression(expression);\n    printf(\"Result: %lf\\n\", result);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a chatbot that integrates a natural language processing library for understanding user input.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <nlp.h> // Hypothetical NLP library\n\n#define MAX_INPUT_SIZE 1024\n\nvoid process_input(const char* user_input) {\n    NLPResult* result = nlp_process(user_input);\n    if (result->understood) {\n        printf(\"Bot: %s\\n\", result->response);\n    } else {\n        printf(\"Bot: I'm sorry, I didn't understand that.\\n\");\n    }\n    nlp_free_result(result);\n}\n\nint main() {\n    char user_input[MAX_INPUT_SIZE];\n\n    printf(\"Chatbot: Hello! How can I help you today?\\n\");\n\n    while (1) {\n        printf(\"You: \");\n        if (fgets(user_input, MAX_INPUT_SIZE, stdin) == NULL) {\n            printf(\"Error reading input.\\n\");\n            continue;\n        }\n\n        // Remove newline character from input\n        user_input[strcspn(user_input, \"\\n\")] = 0;\n\n        // Process user input\n        process_input(user_input);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a tool that detects faces in images using a computer vision library.",
    "code": "```c\n#include <opencv2/opencv.hpp>\n\nint main(int argc, char** argv) {\n    if (argc != 2) {\n        printf(\"Usage: %s <image_path>\\n\", argv[0]);\n        return -1;\n    }\n\n    cv::Mat image = cv::imread(argv[1], cv::IMREAD_COLOR);\n    if (image.empty()) {\n        printf(\"Could not open or find the image\\n\");\n        return -1;\n    }\n\n    cv::CascadeClassifier face_cascade;\n    if (!face_cascade.load(cv::samples::findFile(\"haarcascade_frontalface_default.xml\"))) {\n        printf(\"Error loading face cascade\\n\");\n        return -1;\n    }\n\n    std::vector<cv::Rect> faces;\n    cv::Mat gray;\n    cv::cvtColor(image, gray, cv::COLOR_BGR2GRAY);\n    cv::equalizeHist(gray, gray);\n\n    face_cascade.detectMultiScale(gray, faces);\n\n    for (size_t i = 0; i < faces.size(); i++) {\n        cv::rectangle(image, faces[i], cv::Scalar(255, 0, 0), 2);\n    }\n\n    cv::imshow(\"Detected Faces\", image);\n    cv::waitKey(0);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a program that converts date and time across different time zones using a library for date manipulation.",
    "code": "```c\n#include <stdio.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Function to convert time between time zones\nvoid convert_timezone(const char *time_str, const char *from_tz, const char *to_tz) {\n    struct tm tm;\n    time_t t;\n    char buf[256];\n\n    // Set the environment variable for the from_tz\n    setenv(\"TZ\", from_tz, 1);\n    tzset();\n\n    // Parse the input time string\n    strptime(time_str, \"%Y-%m-%d %H:%M:%S\", &tm);\n    t = mktime(&tm);\n\n    // Set the environment variable for the to_tz\n    setenv(\"TZ\", to_tz, 1);\n    tzset();\n\n    // Convert time to the target time zone\n    struct tm *converted_tm = localtime(&t);\n    strftime(buf, sizeof(buf), \"%Y-%m-%d %H:%M:%S\", converted_tm);\n\n    printf(\"Converted time: %s\\n\", buf);\n}\n\nint main() {\n    const char *time_str = \"2023-10-10 15:00:00\";\n    const char *from_tz = \"UTC\";\n    const char *to_tz = \"America/New_York\";\n\n    convert_timezone(time_str, from_tz, to_tz);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a utility that uploads files to a cloud storage service using a library that interfaces with the service's API.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"cloud_storage_api.h\" // hypothetical library for cloud storage\n\nvoid upload_file_to_cloud(const char *file_path, const char *cloud_path) {\n    FILE *file = fopen(file_path, \"rb\");\n    if (file == NULL) {\n        fprintf(stderr, \"Error: Could not open file %s\\n\", file_path);\n        return;\n    }\n\n    fseek(file, 0, SEEK_END);\n    long file_size = ftell(file);\n    fseek(file, 0, SEEK_SET);\n\n    char *buffer = (char *)malloc(file_size);\n    if (buffer == NULL) {\n        fprintf(stderr, \"Error: Could not allocate memory\\n\");\n        fclose(file);\n        return;\n    }\n\n    fread(buffer, 1, file_size, file);\n    fclose(file);\n\n    // Hypothetical function call to upload file using cloud storage API\n    int result = cloud_storage_upload(cloud_path, buffer, file_size);\n    if (result != 0) {\n        fprintf(stderr, \"Error: Failed to upload file to %s\\n\", cloud_path);\n    } else {\n        printf(\"File %s uploaded successfully to %s\\n\", file_path, cloud_path);\n    }\n\n    free(buffer);\n}\n\nint main(int argc, char *argv[]) {\n    if (argc != 3) {\n        fprintf(stderr, \"Usage: %s <local_file_path> <cloud_file_path>\\n\", argv[0]);\n        return EXIT_FAILURE;\n    }\n\n    const char *local_file_path = argv[1];\n    const char *cloud_file_path = argv[2];\n\n    upload_file_to_cloud(local_file_path, cloud_file_path);\n\n    return EXIT_SUCCESS;\n}\n```"
  },
  {
    "task": "Create a real-time chat system using a library that supports asynchronous communication.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <uv.h>\n\n#define MAX_MESSAGE_LENGTH 1024\n\nuv_loop_t *loop;\nuv_tcp_t server;\nuv_tcp_t *clients[10];\nint client_count = 0;\n\nvoid alloc_buffer(uv_handle_t *handle, size_t suggested_size, uv_buf_t *buf) {\n    buf->base = (char*) malloc(suggested_size);\n    buf->len = suggested_size;\n}\n\nvoid on_write_end(uv_write_t *req, int status) {\n    if (status) {\n        fprintf(stderr, \"Write error %s\\n\", uv_strerror(status));\n    }\n    free(req);\n}\n\nvoid broadcast_message(const char *message, size_t length) {\n    for (int i = 0; i < client_count; i++) {\n        uv_buf_t buf = uv_buf_init((char*)message, length);\n        uv_write_t *req = (uv_write_t*) malloc(sizeof(uv_write_t));\n        uv_write(req, (uv_stream_t*) clients[i], &buf, 1, on_write_end);\n    }\n}\n\nvoid on_read(uv_stream_t *client, ssize_t nread, const uv_buf_t *buf) {\n    if (nread > 0) {\n        broadcast_message(buf->base, nread);\n    } else if (nread < 0) {\n        if (nread != UV_EOF)\n            fprintf(stderr, \"Read error %s\\n\", uv_err_name(nread));\n        uv_close((uv_handle_t*) client, NULL);\n    }\n\n    if (buf->base)\n        free(buf->base);\n}\n\nvoid on_new_connection(uv_stream_t *server, int status) {\n    if (status < 0) {\n        fprintf(stderr, \"New connection error %s\\n\", uv_strerror(status));\n        return;\n    }\n\n    uv_tcp_t *client = (uv_tcp_t*) malloc(sizeof(uv_tcp_t));\n    uv_tcp_init(loop, client);\n    if (uv_accept(server, (uv_stream_t*) client) == 0) {\n        clients[client_count++] = client;\n        uv_read_start((uv_stream_t*) client, alloc_buffer, on_read);\n    } else {\n        uv_close((uv_handle_t*) client, NULL);\n    }\n}\n\nint main() {\n    loop = uv_default_loop();\n\n    uv_tcp_init(loop, &server);\n    struct sockaddr_in addr;\n    uv_ip4_addr(\"0.0.0.0\", 7000, &addr);\n\n    uv_tcp_bind(&server, (const struct sockaddr*)&addr, 0);\n    int r = uv_listen((uv_stream_t*) &server, 10, on_new_connection);\n    if (r) {\n        fprintf(stderr, \"Listen error %s\\n\", uv_strerror(r));\n        return 1;\n    }\n    return uv_run(loop, UV_RUN_DEFAULT);\n}\n```"
  },
  {
    "task": "Use a library to generate and manipulate UUIDs for unique identification in your application.",
    "code": "```c\n#include <stdio.h>\n#include <uuid/uuid.h>\n\nint main() {\n    uuid_t uuid;\n    char uuid_str[37]; // UUIDs are 36 characters plus null terminator\n\n    // Generate a UUID\n    uuid_generate(uuid);\n\n    // Convert UUID to string\n    uuid_unparse(uuid, uuid_str);\n\n    // Print the UUID\n    printf(\"Generated UUID: %s\\n\", uuid_str);\n\n    // Example of parsing a UUID from a string\n    uuid_t parsed_uuid;\n    if (uuid_parse(uuid_str, parsed_uuid) == 0) {\n        printf(\"Successfully parsed UUID: %s\\n\", uuid_str);\n    } else {\n        printf(\"Failed to parse UUID\\n\");\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Build a desktop application that uses a library for creating graphical user interfaces.",
    "code": "```c\n#include <gtk/gtk.h>\n\nstatic void on_app_activate(GtkApplication *app, gpointer user_data) {\n    GtkWidget *window = gtk_application_window_new(app);\n    gtk_window_set_title(GTK_WINDOW(window), \"Library Integration Example\");\n    gtk_window_set_default_size(GTK_WINDOW(window), 400, 300);\n    gtk_widget_show_all(window);\n}\n\nint main(int argc, char **argv) {\n    GtkApplication *app;\n    int status;\n\n    app = gtk_application_new(\"com.example.GtkApp\", G_APPLICATION_FLAGS_NONE);\n    g_signal_connect(app, \"activate\", G_CALLBACK(on_app_activate), NULL);\n    status = g_application_run(G_APPLICATION(app), argc, argv);\n    g_object_unref(app);\n\n    return status;\n}\n```"
  },
  {
    "task": "Develop an algorithm that finds the shortest path in a graph using a library that provides graph algorithms.",
    "code": "```c\n#include <stdio.h>\n#include <graph.h>  // Assuming a graph library named graph.h\n\nint main() {\n    Graph *g = graph_create();\n    \n    // Add nodes and edges to the graph\n    // graph_add_node(g, ...);\n    // graph_add_edge(g, ..., ...);\n\n    int source = 0;  // Example source node index\n    int destination = 5;  // Example destination node index\n    \n    // Find the shortest path using the library's function\n    Path *shortest_path = graph_find_shortest_path(g, source, destination);\n\n    // Assuming a function to print the path\n    graph_print_path(shortest_path);\n\n    // Clean up resources\n    graph_destroy(g);\n    path_destroy(shortest_path);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a digital clock application that uses a library for handling time events.",
    "code": "```c\n#include <stdio.h>\n#include <time.h>\n#include <unistd.h>\n\nvoid displayTime(struct tm *t) {\n    printf(\"\\r%02d:%02d:%02d\", t->tm_hour, t->tm_min, t->tm_sec);\n    fflush(stdout);\n}\n\nint main() {\n    time_t rawtime;\n    struct tm *timeinfo;\n\n    while (1) {\n        time(&rawtime);\n        timeinfo = localtime(&rawtime);\n        displayTime(timeinfo);\n        sleep(1);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a program that uses a library to convert between different units of measurement.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n// A simple library for unit conversion\ndouble convert_units(double value, const char *from_unit, const char *to_unit) {\n    if (strcmp(from_unit, \"meters\") == 0 && strcmp(to_unit, \"feet\") == 0) {\n        return value * 3.28084;\n    } else if (strcmp(from_unit, \"feet\") == 0 && strcmp(to_unit, \"meters\") == 0) {\n        return value / 3.28084;\n    } else if (strcmp(from_unit, \"kilograms\") == 0 && strcmp(to_unit, \"pounds\") == 0) {\n        return value * 2.20462;\n    } else if (strcmp(from_unit, \"pounds\") == 0 && strcmp(to_unit, \"kilograms\") == 0) {\n        return value / 2.20462;\n    } else {\n        fprintf(stderr, \"Unsupported conversion from %s to %s.\\n\", from_unit, to_unit);\n        exit(EXIT_FAILURE);\n    }\n}\n\nint main() {\n    double value = 10.0;\n\n    double converted_value = convert_units(value, \"meters\", \"feet\");\n    printf(\"%.2f meters is %.2f feet.\\n\", value, converted_value);\n\n    converted_value = convert_units(value, \"kilograms\", \"pounds\");\n    printf(\"%.2f kilograms is %.2f pounds.\\n\", value, converted_value);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Use a library to implement a caching mechanism for improving application performance.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <uthash.h>\n\n// Define a cache entry structure\ntypedef struct CacheEntry {\n    char *key;               // key for accessing cache\n    char *value;             // cached data\n    UT_hash_handle hh;       // makes this structure hashable\n} CacheEntry;\n\nCacheEntry *cache = NULL; // Initialize the hash table\n\n// Function to add an item to the cache\nvoid cache_set(const char *key, const char *value) {\n    CacheEntry *entry = NULL;\n    HASH_FIND_STR(cache, key, entry);\n    if (entry == NULL) {\n        entry = (CacheEntry *)malloc(sizeof(CacheEntry));\n        entry->key = strdup(key);\n        HASH_ADD_STR(cache, key, entry);\n    }\n    free(entry->value);\n    entry->value = strdup(value);\n}\n\n// Function to retrieve an item from the cache\nchar *cache_get(const char *key) {\n    CacheEntry *entry = NULL;\n    HASH_FIND_STR(cache, key, entry);\n    if (entry != NULL) {\n        return entry->value;\n    }\n    return NULL;\n}\n\n// Function to clear the cache\nvoid cache_clear() {\n    CacheEntry *entry, *tmp;\n    HASH_ITER(hh, cache, entry, tmp) {\n        HASH_DEL(cache, entry);\n        free(entry->key);\n        free(entry->value);\n        free(entry);\n    }\n}\n\nint main() {\n    // Example usage\n    cache_set(\"key1\", \"value1\");\n    printf(\"Cache key1: %s\\n\", cache_get(\"key1\"));\n    cache_set(\"key2\", \"value2\");\n    printf(\"Cache key2: %s\\n\", cache_get(\"key2\"));\n    cache_clear();\n    return 0;\n}\n```"
  },
  {
    "task": "Build an e-commerce platform that integrates a payment processing library for handling transactions.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Mock payment processing library\ntypedef struct {\n    char card_number[16];\n    char expiry_date[5];\n    char cvv[3];\n    double amount;\n} PaymentDetails;\n\nint processPayment(PaymentDetails *details) {\n    printf(\"Processing payment of $%.2f\\n\", details->amount);\n    printf(\"Using card: %s\\n\", details->card_number);\n    // Here you would have actual logic to process the payment\n    // For example, calling an API of a third-party payment processor\n    return 1; // Return 1 for success\n}\n\n// E-commerce platform\ntypedef struct {\n    char item_id[20];\n    double price;\n} Item;\n\ntypedef struct {\n    Item *items;\n    int item_count;\n    double total_amount;\n} ShoppingCart;\n\nvoid addItemToCart(ShoppingCart *cart, Item item) {\n    cart->items[cart->item_count++] = item;\n    cart->total_amount += item.price;\n}\n\nvoid checkout(ShoppingCart *cart, PaymentDetails *payment) {\n    payment->amount = cart->total_amount;\n    if (processPayment(payment)) {\n        printf(\"Payment successful. Thank you for your purchase!\\n\");\n    } else {\n        printf(\"Payment failed. Please try again.\\n\");\n    }\n}\n\nint main() {\n    ShoppingCart cart;\n    cart.items = malloc(10 * sizeof(Item));\n    cart.item_count = 0;\n    cart.total_amount = 0.0;\n\n    Item item1 = {\"item123\", 29.99};\n    addItemToCart(&cart, item1);\n\n    Item item2 = {\"item456\", 49.99};\n    addItemToCart(&cart, item2);\n\n    PaymentDetails payment = {\n        .card_number = \"1234567890123456\",\n        .expiry_date = \"12/23\",\n        .cvv = \"123\",\n        .amount = 0.0\n    };\n\n    checkout(&cart, &payment);\n\n    free(cart.items);\n    return 0;\n}\n```"
  },
  {
    "task": "Create a to-do list application that stores data locally using a library for file management.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define FILENAME \"todo.txt\"\n#define MAX_TODO_LENGTH 256\n\nvoid add_todo_item(const char *item) {\n    FILE *file = fopen(FILENAME, \"a\");\n    if (file != NULL) {\n        fprintf(file, \"%s\\n\", item);\n        fclose(file);\n    } else {\n        printf(\"Error: Could not open file for appending.\\n\");\n    }\n}\n\nvoid list_todo_items() {\n    FILE *file = fopen(FILENAME, \"r\");\n    char buffer[MAX_TODO_LENGTH];\n    \n    if (file != NULL) {\n        printf(\"To-Do List:\\n\");\n        while (fgets(buffer, MAX_TODO_LENGTH, file) != NULL) {\n            printf(\"- %s\", buffer);\n        }\n        fclose(file);\n    } else {\n        printf(\"Error: Could not open file for reading.\\n\");\n    }\n}\n\nint main() {\n    int choice;\n    char todo_item[MAX_TODO_LENGTH];\n    \n    while (1) {\n        printf(\"To-Do List Application\\n\");\n        printf(\"1. Add To-Do Item\\n\");\n        printf(\"2. List To-Do Items\\n\");\n        printf(\"3. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n        getchar();  // Consume newline character\n        \n        switch (choice) {\n            case 1:\n                printf(\"Enter a new to-do item: \");\n                fgets(todo_item, MAX_TODO_LENGTH, stdin);\n                todo_item[strcspn(todo_item, \"\\n\")] = '\\0';  // Remove newline\n                add_todo_item(todo_item);\n                break;\n            case 2:\n                list_todo_items();\n                break;\n            case 3:\n                exit(0);\n            default:\n                printf(\"Invalid choice. Please try again.\\n\");\n        }\n    }\n    \n    return 0;\n}\n```"
  },
  {
    "task": "Develop a system that monitors server health using a library that provides network utilities.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unistd.h>\n#include <string.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n\n// Example library integration (libcurl)\n#include <curl/curl.h>\n\n#define SERVER_URL \"http://example.com/health\"\n#define CHECK_INTERVAL 5\n\nvoid check_server_health() {\n    CURL *curl;\n    CURLcode res;\n    long response_code;\n\n    curl = curl_easy_init();\n    if(curl) {\n        curl_easy_setopt(curl, CURLOPT_URL, SERVER_URL);\n        curl_easy_setopt(curl, CURLOPT_NOBODY, 1L);\n        \n        res = curl_easy_perform(curl);\n        \n        if(res != CURLE_OK) {\n            fprintf(stderr, \"curl_easy_perform() failed: %s\\n\", curl_easy_strerror(res));\n        } else {\n            curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &response_code);\n            printf(\"Server response code: %ld\\n\", response_code);\n        }\n        \n        curl_easy_cleanup(curl);\n    }\n}\n\nint main() {\n    while(1) {\n        check_server_health();\n        sleep(CHECK_INTERVAL);\n    }\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a program that detects language from a given text using a language detection library.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <cld2/public/compact_lang_det.h>\n\nint main() {\n    const char* text = \"This is a test sentence to detect language.\";\n    bool is_reliable;\n    int num_bytes;\n    CLD2::Language lang = CLD2::DetectLanguage(text, strlen(text), true, &is_reliable, &num_bytes);\n\n    if (is_reliable) {\n        printf(\"Detected language: %s\\n\", CLD2::LanguageName(lang));\n    } else {\n        printf(\"Language detection not reliable.\\n\");\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a script that sends notifications to a mobile device using a push notification library.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"push_notification_library.h\"\n\nint main() {\n    push_notification_t notification;\n    notification_init(&notification);\n\n    notification.title = \"Hello!\";\n    notification.message = \"You have a new message.\";\n    notification.device_token = \"device_token_here\";\n    \n    if (send_push_notification(&notification) == 0) {\n        printf(\"Notification sent successfully.\\n\");\n    } else {\n        printf(\"Failed to send notification.\\n\");\n    }\n\n    notification_cleanup(&notification);\n    return 0;\n}\n```"
  },
  {
    "task": "Use a library to generate reports in PDF format from application data.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <hpdf.h>\n\nvoid error_handler(HPDF_STATUS error_no, HPDF_STATUS detail_no, void *user_data) {\n    printf(\"ERROR: error_no=%04X, detail_no=%u\\n\", (unsigned int)error_no, (unsigned int)detail_no);\n    exit(1);\n}\n\nint main() {\n    HPDF_Doc pdf;\n    HPDF_Page page;\n    const char *page_title = \"Report\";\n    \n    pdf = HPDF_New(error_handler, NULL);\n    if (!pdf) {\n        printf(\"ERROR: Cannot create pdf object.\\n\");\n        return 1;\n    }\n\n    page = HPDF_AddPage(pdf);\n    HPDF_Page_SetSize(page, HPDF_PAGE_SIZE_A4, HPDF_PAGE_PORTRAIT);\n    \n    HPDF_Page_BeginText(page);\n    HPDF_Page_SetFontAndSize(page, HPDF_GetFont(pdf, \"Helvetica\", NULL), 24);\n    HPDF_Page_TextOut(page, 50, 750, page_title);\n    HPDF_Page_EndText(page);\n\n    HPDF_SaveToFile(pdf, \"report.pdf\");\n    HPDF_Free(pdf);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Build a program that performs statistical analysis on datasets using a statistical computing library.",
    "code": "```c\n#include <stdio.h>\n#include <gsl/gsl_statistics.h>\n\nint main() {\n    double data[] = {17.1, 18.2, 19.3, 20.4, 21.5};\n    size_t size = sizeof(data) / sizeof(data[0]);\n\n    double mean = gsl_stats_mean(data, 1, size);\n    double variance = gsl_stats_variance(data, 1, size);\n    double stddev = gsl_stats_sd(data, 1, size);\n    double min = gsl_stats_min(data, 1, size);\n    double max = gsl_stats_max(data, 1, size);\n\n    printf(\"Mean: %f\\n\", mean);\n    printf(\"Variance: %f\\n\", variance);\n    printf(\"Standard Deviation: %f\\n\", stddev);\n    printf(\"Min: %f\\n\", min);\n    printf(\"Max: %f\\n\", max);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create an image gallery application that uses a library for image caching and lazy loading.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <dirent.h>\n#include <SDL2/SDL.h>\n#include <SDL2/SDL_image.h>\n#include \"stb_image.h\"\n\n#define WINDOW_WIDTH 800\n#define WINDOW_HEIGHT 600\n\ntypedef struct ImageCache {\n    char *fileName;\n    SDL_Texture *texture;\n    struct ImageCache *next;\n} ImageCache;\n\nImageCache *cacheHead = NULL;\n\nSDL_Texture* loadImage(SDL_Renderer *renderer, const char *filePath) {\n    ImageCache *current = cacheHead;\n    while (current) {\n        if (strcmp(current->fileName, filePath) == 0) {\n            return current->texture;\n        }\n        current = current->next;\n    }\n\n    SDL_Surface *loadedSurface = IMG_Load(filePath);\n    if (!loadedSurface) {\n        fprintf(stderr, \"Unable to load image %s! SDL_image Error: %s\\n\", filePath, IMG_GetError());\n        return NULL;\n    }\n\n    SDL_Texture *newTexture = SDL_CreateTextureFromSurface(renderer, loadedSurface);\n    SDL_FreeSurface(loadedSurface);\n\n    if (!newTexture) {\n        fprintf(stderr, \"Unable to create texture from %s! SDL Error: %s\\n\", filePath, SDL_GetError());\n        return NULL;\n    }\n\n    ImageCache *newCache = (ImageCache *)malloc(sizeof(ImageCache));\n    newCache->fileName = strdup(filePath);\n    newCache->texture = newTexture;\n    newCache->next = cacheHead;\n    cacheHead = newCache;\n\n    return newTexture;\n}\n\nvoid freeCache() {\n    ImageCache *current = cacheHead;\n    while (current) {\n        ImageCache *next = current->next;\n        SDL_DestroyTexture(current->texture);\n        free(current->fileName);\n        free(current);\n        current = next;\n    }\n    cacheHead = NULL;\n}\n\nint main(int argc, char *argv[]) {\n    if (argc < 2) {\n        printf(\"Usage: %s <image_directory>\\n\", argv[0]);\n        return 1;\n    }\n\n    if (SDL_Init(SDL_INIT_VIDEO) < 0) {\n        fprintf(stderr, \"SDL could not initialize! SDL Error: %s\\n\", SDL_GetError());\n        return 1;\n    }\n\n    SDL_Window *window = SDL_CreateWindow(\"Image Gallery\", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, WINDOW_WIDTH, WINDOW_HEIGHT, SDL_WINDOW_SHOWN);\n    if (!window) {\n        fprintf(stderr, \"Window could not be created! SDL Error: %s\\n\", SDL_GetError());\n        SDL_Quit();\n        return 1;\n    }\n\n    SDL_Renderer *renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);\n    if (!renderer) {\n        fprintf(stderr, \"Renderer could not be created! SDL Error: %s\\n\", SDL_GetError());\n        SDL_DestroyWindow(window);\n        SDL_Quit();\n        return 1;\n    }\n\n    DIR *dir;\n    struct dirent *ent;\n    if ((dir = opendir(argv[1])) != NULL) {\n        while ((ent = readdir(dir)) != NULL) {\n            if (strstr(ent->d_name, \".png\") || strstr(ent->d_name, \".jpg\")) {\n                char filePath[1024];\n                snprintf(filePath, sizeof(filePath), \"%s/%s\", argv[1], ent->d_name);\n                SDL_Texture *texture = loadImage(renderer, filePath);\n\n                if (texture) {\n                    SDL_RenderClear(renderer);\n                    SDL_RenderCopy(renderer, texture, NULL, NULL);\n                    SDL_RenderPresent(renderer);\n                    SDL_Delay(2000);\n                }\n            }\n        }\n        closedir(dir);\n    } else {\n        perror(\"\");\n        return EXIT_FAILURE;\n    }\n\n    freeCache();\n    SDL_DestroyRenderer(renderer);\n    SDL_DestroyWindow(window);\n    SDL_Quit();\n\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a machine learning model that predicts outcomes using a machine learning library.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <cblas.h>  // Example for BLAS library\n\n// Example function to demonstrate library integration\n// This is a placeholder for actual ML library functions\ndouble predict_outcome(double *features, int size) {\n    // Dummy weights for demonstration\n    double weights[] = {1.5, -2.0, 3.0};\n    double outcome = 0.0;\n\n    // Using BLAS library function to compute dot product\n    outcome = cblas_ddot(size, features, 1, weights, 1);\n\n    return outcome;\n}\n\nint main() {\n    double features[] = {2.0, 3.0, 5.0};\n    int size = sizeof(features) / sizeof(features[0]);\n\n    double predicted_outcome = predict_outcome(features, size);\n    printf(\"Predicted Outcome: %f\\n\", predicted_outcome);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a feature that automatically formats code according to style guidelines using a code formatter library.",
    "code": "```c\n#include <stdio.h>\n#include <clang-c/Index.h>\n\nvoid formatCode(const char *sourceFile, const char *formattedFile) {\n    CXIndex index = clang_createIndex(0, 0);\n    const char *args[] = {\"-style=LLVM\"}; // Example style\n    CXTranslationUnit tu = clang_parseTranslationUnit(index, sourceFile, args, 1, NULL, 0, CXTranslationUnit_None);\n\n    if (tu != NULL) {\n        clang_reparseTranslationUnit(tu, 0, NULL, CXTranslationUnit_None);\n        CXFile file = clang_getFile(tu, sourceFile);\n        CXSourceRange range = clang_getRange(clang_getLocationForOffset(tu, file, 0), clang_getLocationForOffset(tu, file, INT_MAX));\n        CXRewriter rewriter = clang_createRewriter(tu);\n\n        clang_RewriteSourceRange(rewriter, range);\n        clang_saveTranslationUnit(tu, formattedFile, CXSaveTranslationUnit_None);\n\n        clang_disposeRewriter(rewriter);\n        clang_disposeTranslationUnit(tu);\n    }\n    clang_disposeIndex(index);\n}\n\nint main() {\n    const char *sourceFile = \"source.c\";\n    const char *formattedFile = \"formatted.c\";\n    formatCode(sourceFile, formattedFile);\n    printf(\"Code formatting complete. Output saved to %s\\n\", formattedFile);\n    return 0;\n}\n```"
  },
  {
    "task": "Write a program that generates barcodes using a library for barcode generation.",
    "code": "```c\n#include <barcode.h>  // Assume a barcode generation library is available\n\nint main() {\n    BarcodeGenerator *generator = barcode_generator_create();\n\n    Barcode *barcode = barcode_create(generator, \"123456789012\");\n    \n    barcode_save(barcode, \"barcode.png\");\n\n    barcode_destroy(barcode);\n    barcode_generator_destroy(generator);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Use a library to create interactive maps for displaying geographical data in your application.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <libpq-fe.h>\n\n// Assuming the use of a library like libpq for database connection\n// and a hypothetical mapping library for map rendering\n\nvoid createInteractiveMap() {\n    // Initialize the map\n    Map *map = map_initialize();\n\n    // Add geographical data to the map\n    add_geographic_data(map, \"path/to/geodata/file\");\n\n    // Display the map\n    map_display(map);\n\n    // Clean up\n    map_cleanup(map);\n}\n\nint main() {\n    // Initialize the library\n    if (!map_library_initialize()) {\n        fprintf(stderr, \"Failed to initialize map library\\n\");\n        return EXIT_FAILURE;\n    }\n\n    // Create and display the interactive map\n    createInteractiveMap();\n\n    // Finalize the library\n    map_library_finalize();\n\n    return EXIT_SUCCESS;\n}\n```"
  },
  {
    "task": "Build a simulation that models fluid dynamics using a library for physics simulations.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <ode/ode.h>\n\n#define NUM_PARTICLES 100\n\ntypedef struct {\n    dBodyID body;\n    dGeomID geom;\n} Particle;\n\nParticle particles[NUM_PARTICLES];\ndWorldID world;\ndSpaceID space;\ndJointGroupID contactgroup;\n\nvoid nearCallback(void *data, dGeomID o1, dGeomID o2) {\n    const int MAX_CONTACTS = 10;\n    dContact contact[MAX_CONTACTS];\n    \n    int numc = dCollide(o1, o2, MAX_CONTACTS, &contact[0].geom, sizeof(dContact));\n    \n    for (int i = 0; i < numc; i++) {\n        contact[i].surface.mode = dContactBounce;\n        contact[i].surface.mu = dInfinity;\n        contact[i].surface.bounce = 0.1;\n        contact[i].surface.bounce_vel = 0.1;\n        \n        dJointID c = dJointCreateContact(world, contactgroup, &contact[i]);\n        dJointAttach(c, dGeomGetBody(contact[i].geom.g1), dGeomGetBody(contact[i].geom.g2));\n    }\n}\n\nvoid initSimulation() {\n    dInitODE();\n    world = dWorldCreate();\n    space = dSimpleSpaceCreate(0);\n    contactgroup = dJointGroupCreate(0);\n    \n    dWorldSetGravity(world, 0, 0, -9.81);\n\n    for (int i = 0; i < NUM_PARTICLES; i++) {\n        particles[i].body = dBodyCreate(world);\n        dBodySetPosition(particles[i].body, rand() % 10, rand() % 10, rand() % 10);\n        \n        particles[i].geom = dCreateSphere(space, 0.1);\n        dGeomSetBody(particles[i].geom, particles[i].body);\n    }\n}\n\nvoid stepSimulation() {\n    dSpaceCollide(space, 0, &nearCallback);\n    dWorldStep(world, 0.01);\n    dJointGroupEmpty(contactgroup);\n}\n\nvoid cleanUp() {\n    for (int i = 0; i < NUM_PARTICLES; i++) {\n        dBodyDestroy(particles[i].body);\n        dGeomDestroy(particles[i].geom);\n    }\n\n    dJointGroupDestroy(contactgroup);\n    dSpaceDestroy(space);\n    dWorldDestroy(world);\n    dCloseODE();\n}\n\nint main() {\n    srand(time(0));\n    initSimulation();\n    \n    for (int i = 0; i < 100; i++) {\n        stepSimulation();\n        printf(\"Simulation step %d\\n\", i);\n    }\n    \n    cleanUp();\n    return 0;\n}\n```"
  },
  {
    "task": "Create a program that reads barcodes from images using a library for barcode scanning.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include \"zbar.h\"\n\nint main(int argc, char **argv) {\n    if (argc < 2) {\n        fprintf(stderr, \"Usage: %s <image-file>\\n\", argv[0]);\n        return 1;\n    }\n\n    // Create a zbar image scanner\n    zbar_image_scanner_t *scanner = zbar_image_scanner_create();\n\n    // Configure the scanner\n    zbar_image_scanner_set_config(scanner, 0, ZBAR_CFG_ENABLE, 1);\n\n    // Open the image file\n    FILE *file = fopen(argv[1], \"rb\");\n    if (!file) {\n        fprintf(stderr, \"Unable to open image file: %s\\n\", argv[1]);\n        return 1;\n    }\n\n    // Read the image dimensions and data\n    int width, height;\n    fseek(file, 18, SEEK_SET);\n    fread(&width, sizeof(int), 1, file);\n    fread(&height, sizeof(int), 1, file);\n    fseek(file, 54, SEEK_SET);\n\n    unsigned char *raw = malloc(width * height);\n    fread(raw, width * height, 1, file);\n    fclose(file);\n\n    // Wrap image data in a zbar image\n    zbar_image_t *image = zbar_image_create();\n    zbar_image_set_format(image, *(int*)\"Y800\");\n    zbar_image_set_size(image, width, height);\n    zbar_image_set_data(image, raw, width * height, zbar_image_free_data);\n\n    // Scan the image for barcodes\n    int n = zbar_scan_image(scanner, image);\n\n    // Extract results\n    const zbar_symbol_t *symbol = zbar_image_first_symbol(image);\n    for (; symbol; symbol = zbar_symbol_next(symbol)) {\n        zbar_symbol_type_t type = zbar_symbol_get_type(symbol);\n        const char *data = zbar_symbol_get_data(symbol);\n        printf(\"Decoded %s symbol: \\\"%s\\\"\\n\", zbar_get_symbol_name(type), data);\n    }\n\n    // Clean up\n    zbar_image_destroy(image);\n    zbar_image_scanner_destroy(scanner);\n    free(raw);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a feature that performs spell checking using a library for text processing.",
    "code": "```c\n#include <stdio.h>\n#include <hunspell/hunspell.h>\n\nint main() {\n    // Initialize Hunspell\n    Hunhandle *hunspell = Hunspell_create(\"/path/to/en_US.aff\", \"/path/to/en_US.dic\");\n\n    // Sample text\n    const char *word = \"exampel\";\n\n    // Check spelling\n    if (Hunspell_spell(hunspell, word) == 0) {\n        printf(\"The word '%s' is misspelled.\\n\", word);\n    } else {\n        printf(\"The word '%s' is correct.\\n\", word);\n    }\n\n    // Clean up\n    Hunspell_destroy(hunspell);\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a service that aggregates news articles from various sources using a library for web content aggregation.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <libxml/parser.h>\n#include <curl/curl.h>\n\ntypedef struct {\n    char *memory;\n    size_t size;\n} MemoryStruct;\n\nstatic size_t WriteMemoryCallback(void *contents, size_t size, size_t nmemb, void *userp) {\n    size_t realSize = size * nmemb;\n    MemoryStruct *mem = (MemoryStruct *)userp;\n\n    char *ptr = realloc(mem->memory, mem->size + realSize + 1);\n    if(ptr == NULL) {\n        printf(\"Not enough memory (realloc returned NULL)\\n\");\n        return 0;\n    }\n\n    mem->memory = ptr;\n    memcpy(&(mem->memory[mem->size]), contents, realSize);\n    mem->size += realSize;\n    mem->memory[mem->size] = 0;\n\n    return realSize;\n}\n\nvoid fetchContent(const char *url, MemoryStruct *chunk) {\n    CURL *curl_handle;\n    CURLcode res;\n\n    curl_global_init(CURL_GLOBAL_ALL);\n    curl_handle = curl_easy_init();\n\n    curl_easy_setopt(curl_handle, CURLOPT_URL, url);\n    curl_easy_setopt(curl_handle, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);\n    curl_easy_setopt(curl_handle, CURLOPT_WRITEDATA, (void *)chunk);\n\n    res = curl_easy_perform(curl_handle);\n\n    if(res != CURLE_OK) {\n        fprintf(stderr, \"curl_easy_perform() failed: %s\\n\", curl_easy_strerror(res));\n    }\n\n    curl_easy_cleanup(curl_handle);\n    curl_global_cleanup();\n}\n\nvoid parseXML(char *content) {\n    xmlDoc *document = xmlReadMemory(content, strlen(content), \"noname.xml\", NULL, 0);\n    xmlNode *root_element = NULL;\n\n    if (document == NULL) {\n        printf(\"Failed to parse document\\n\");\n        return;\n    }\n\n    root_element = xmlDocGetRootElement(document);\n\n    // Processing the XML content should be done here.\n\n    xmlFreeDoc(document);\n}\n\nint main() {\n    const char *urls[] = {\n        \"http://example.com/news1.xml\",\n        \"http://example.com/news2.xml\"\n    };\n    int numUrls = sizeof(urls) / sizeof(urls[0]);\n\n    for (int i = 0; i < numUrls; i++) {\n        MemoryStruct chunk;\n        chunk.memory = malloc(1);\n        chunk.size = 0;\n\n        fetchContent(urls[i], &chunk);\n        parseXML(chunk.memory);\n\n        free(chunk.memory);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Write a script that converts spoken language to text using a speech recognition library.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n#include <pocketsphinx.h>\n\nint main() {\n    const char *hyp;\n    int rv;\n    ps_decoder_t *ps;\n    cmd_ln_t *config;\n\n    config = cmd_ln_init(NULL, ps_args(), TRUE,\n                         \"-hmm\", \"/usr/local/share/pocketsphinx/model/en-us/en-us\",\n                         \"-lm\", \"/usr/local/share/pocketsphinx/model/en-us/en-us.lm.bin\",\n                         \"-dict\", \"/usr/local/share/pocketsphinx/model/en-us/cmudict-en-us.dict\",\n                         NULL);\n    if (config == NULL) {\n        fprintf(stderr, \"Failed to create config object\\n\");\n        return 1;\n    }\n\n    ps = ps_init(config);\n    if (ps == NULL) {\n        fprintf(stderr, \"Failed to create recognizer\\n\");\n        return 1;\n    }\n\n    FILE *fh;\n    fh = fopen(\"audio.wav\", \"rb\");\n    if (fh == NULL) {\n        fprintf(stderr, \"Unable to open audio file\\n\");\n        return 1;\n    }\n\n    rv = ps_decode_raw(ps, fh, NULL, -1);\n    if (rv < 0) {\n        fprintf(stderr, \"Failed to decode audio\\n\");\n        return 1;\n    }\n\n    hyp = ps_get_hyp(ps, NULL);\n    if (hyp != NULL) {\n        printf(\"Recognized: %s\\n\", hyp);\n    } else {\n        printf(\"No speech recognized.\\n\");\n    }\n\n    fclose(fh);\n    ps_free(ps);\n    cmd_ln_free_r(config);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Use a library to implement a feature that tracks user behavior in a web application.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\n// Assume this is a mock library for tracking user behavior\ntypedef struct {\n    char userId[50];\n    char action[256];\n    time_t timestamp;\n} UserBehavior;\n\nvoid logUserBehavior(const char *userId, const char *action) {\n    UserBehavior behavior;\n    strcpy(behavior.userId, userId);\n    strcpy(behavior.action, action);\n    behavior.timestamp = time(NULL);\n\n    // Here you would send this data to the library's tracking system\n    printf(\"User ID: %s\\n\", behavior.userId);\n    printf(\"Action: %s\\n\", behavior.action);\n    printf(\"Timestamp: %ld\\n\", behavior.timestamp);\n}\n\nint main() {\n    // Initialize the tracking library (mock)\n    printf(\"Initializing user behavior tracking...\\n\");\n    \n    // Example usage\n    logUserBehavior(\"user123\", \"Clicked Login Button\");\n    logUserBehavior(\"user123\", \"Visited Home Page\");\n\n    return 0;\n}\n```"
  },
  {
    "task": "Build a program that analyzes sentiment in social media posts using a sentiment analysis library.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n#include <sentiment.h>  // Assuming a sentiment analysis library exists\n\nint main() {\n    const char *post = \"I love programming with C!\";\n    SentimentResult result;\n\n    // Initialize sentiment analysis library\n    if (sentiment_init() != 0) {\n        fprintf(stderr, \"Failed to initialize sentiment analysis library.\\n\");\n        return 1;\n    }\n\n    // Analyze sentiment of the post\n    result = sentiment_analyze(post);\n\n    // Output the sentiment result\n    printf(\"Sentiment Score: %.2f\\n\", result.score);\n    printf(\"Sentiment: %s\\n\", result.sentiment > 0 ? \"Positive\" : (result.sentiment < 0 ? \"Negative\" : \"Neutral\"));\n\n    // Clean up resources\n    sentiment_cleanup();\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a utility that detects plagiarism in text using a library for text comparison.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <simhash.h> // Assuming a hypothetical simhash library\n\n#define BUFFER_SIZE 1024\n\n// Function to read text from a file\nchar* read_file(const char* filename) {\n    FILE *file = fopen(filename, \"r\");\n    if (!file) return NULL;\n    fseek(file, 0, SEEK_END);\n    long length = ftell(file);\n    fseek(file, 0, SEEK_SET);\n    char *buffer = malloc(length + 1);\n    if (buffer) {\n        fread(buffer, 1, length, file);\n    }\n    buffer[length] = '\\0';\n    fclose(file);\n    return buffer;\n}\n\n// Function to detect plagiarism using a library\nint detect_plagiarism(const char* text1, const char* text2) {\n    simhash_t hash1 = simhash(text1, strlen(text1));\n    simhash_t hash2 = simhash(text2, strlen(text2));\n    int distance = simhash_compare(hash1, hash2);\n    return distance < 3; // Example threshold for similarity\n}\n\nint main(int argc, char *argv[]) {\n    if (argc != 3) {\n        fprintf(stderr, \"Usage: %s <file1> <file2>\\n\", argv[0]);\n        return EXIT_FAILURE;\n    }\n\n    char *text1 = read_file(argv[1]);\n    char *text2 = read_file(argv[2]);\n\n    if (!text1 || !text2) {\n        fprintf(stderr, \"Error reading files\\n\");\n        return EXIT_FAILURE;\n    }\n\n    if (detect_plagiarism(text1, text2)) {\n        printf(\"Plagiarism detected.\\n\");\n    } else {\n        printf(\"No plagiarism detected.\\n\");\n    }\n\n    free(text1);\n    free(text2);\n    return EXIT_SUCCESS;\n}\n```"
  },
  {
    "task": "Develop a program that predicts weather trends using a library for time series forecasting.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include \"forecasting_library.h\" // Assuming a hypothetical forecasting library\n\n#define DATA_POINTS 100\n\nint main() {\n    double weather_data[DATA_POINTS];\n    double predicted_trend[DATA_POINTS];\n    \n    // Generate some random weather data for demonstration\n    srand(time(NULL));\n    for (int i = 0; i < DATA_POINTS; ++i) {\n        weather_data[i] = (rand() % 300) / 10.0;\n    }\n\n    // Initialize forecasting model\n    ForecastModel *model = forecasting_model_create();\n    forecasting_model_train(model, weather_data, DATA_POINTS);\n\n    // Predict future trends\n    forecasting_model_predict(model, predicted_trend, DATA_POINTS);\n\n    // Output the predicted trends\n    printf(\"Predicted Weather Trends:\\n\");\n    for (int i = 0; i < DATA_POINTS; ++i) {\n        printf(\"Day %d: %.2f\\n\", i + 1, predicted_trend[i]);\n    }\n\n    // Clean up\n    forecasting_model_destroy(model);\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a feature that performs facial recognition using a library specialized for biometric analysis.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <biometric_library.h> // Hypothetical library for biometric analysis\n\nint main() {\n    // Initialize the biometric library\n    if (biometric_init() != BIOMETRIC_SUCCESS) {\n        fprintf(stderr, \"Failed to initialize biometric library\\n\");\n        return EXIT_FAILURE;\n    }\n\n    // Load an image for facial recognition\n    biometric_image_t *image = biometric_load_image(\"face_image.jpg\");\n    if (image == NULL) {\n        fprintf(stderr, \"Failed to load image\\n\");\n        biometric_cleanup();\n        return EXIT_FAILURE;\n    }\n\n    // Perform facial recognition\n    biometric_result_t result;\n    if (biometric_recognize_face(image, &result) != BIOMETRIC_SUCCESS) {\n        fprintf(stderr, \"Facial recognition failed\\n\");\n        biometric_free_image(image);\n        biometric_cleanup();\n        return EXIT_FAILURE;\n    }\n\n    // Output recognition results\n    printf(\"Face recognized: %s\\n\", result.matched ? \"Yes\" : \"No\");\n\n    // Clean up resources\n    biometric_free_image(image);\n    biometric_cleanup();\n\n    return EXIT_SUCCESS;\n}\n```"
  },
  {
    "task": "Write a program that interacts with blockchain networks using a library for blockchain communication.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <curl/curl.h>\n#include <json-c/json.h>\n\n// Function to perform a POST request using libcurl\nvoid post_request(const char *url, const char *data) {\n    CURL *curl;\n    CURLcode res;\n    \n    curl_global_init(CURL_GLOBAL_DEFAULT);\n    curl = curl_easy_init();\n\n    if(curl) {\n        struct curl_slist *headers = NULL;\n        headers = curl_slist_append(headers, \"Content-Type: application/json\");\n\n        curl_easy_setopt(curl, CURLOPT_URL, url);\n        curl_easy_setopt(curl, CURLOPT_POSTFIELDS, data);\n        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);\n\n        res = curl_easy_perform(curl);\n        \n        if(res != CURLE_OK) {\n            fprintf(stderr, \"curl_easy_perform() failed: %s\\n\", curl_easy_strerror(res));\n        }\n\n        curl_slist_free_all(headers);\n        curl_easy_cleanup(curl);\n    }\n    curl_global_cleanup();\n}\n\nint main() {\n    // JSON-RPC example for interacting with a blockchain\n    const char *url = \"http://localhost:8545\";\n    struct json_object *json_data = json_object_new_object();\n\n    json_object_object_add(json_data, \"jsonrpc\", json_object_new_string(\"2.0\"));\n    json_object_object_add(json_data, \"method\", json_object_new_string(\"eth_blockNumber\"));\n    json_object_object_add(json_data, \"params\", json_object_new_array());\n    json_object_object_add(json_data, \"id\", json_object_new_int(1));\n\n    const char *post_data = json_object_to_json_string(json_data);\n    \n    post_request(url, post_data);\n\n    json_object_put(json_data); // Free JSON object\n\n    return 0;\n}\n```"
  },
  {
    "task": "Use a library to perform image recognition tasks in your application.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <image_recognition_library.h> // Hypothetical library\n\nint main() {\n    // Initialize the image recognition system\n    ImageRecognitionSystem *system = init_image_recognition_system();\n    if (system == NULL) {\n        fprintf(stderr, \"Failed to initialize the image recognition system.\\n\");\n        return EXIT_FAILURE;\n    }\n\n    // Load an image\n    Image *image = load_image(\"example.jpg\");\n    if (image == NULL) {\n        fprintf(stderr, \"Failed to load image.\\n\");\n        free_image_recognition_system(system);\n        return EXIT_FAILURE;\n    }\n\n    // Perform image recognition\n    RecognitionResult *result = recognize_image(system, image);\n    if (result == NULL) {\n        fprintf(stderr, \"Image recognition failed.\\n\");\n        free_image(image);\n        free_image_recognition_system(system);\n        return EXIT_FAILURE;\n    }\n\n    // Display recognition result\n    printf(\"Recognition result: %s\\n\", get_recognition_result_text(result));\n\n    // Clean up\n    free_recognition_result(result);\n    free_image(image);\n    free_image_recognition_system(system);\n\n    return EXIT_SUCCESS;\n}\n```"
  },
  {
    "task": "Build a program that converts audio files from one format to another using an audio conversion library.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <libavformat/avformat.h>\n#include <libavcodec/avcodec.h>\n#include <libavutil/avutil.h>\n#include <libavutil/opt.h>\n#include <libavutil/samplefmt.h>\n#include <libswresample/swresample.h>\n\nint main(int argc, char *argv[]) {\n    if (argc < 4) {\n        fprintf(stderr, \"Usage: %s <input_file> <output_file> <output_format>\\n\", argv[0]);\n        return 1;\n    }\n\n    const char *input_filename = argv[1];\n    const char *output_filename = argv[2];\n    const char *output_format_name = argv[3];\n\n    av_register_all();\n\n    AVFormatContext *input_format_context = NULL;\n    if (avformat_open_input(&input_format_context, input_filename, NULL, NULL) < 0) {\n        fprintf(stderr, \"Could not open input file.\\n\");\n        return 1;\n    }\n\n    if (avformat_find_stream_info(input_format_context, NULL) < 0) {\n        fprintf(stderr, \"Could not find stream information.\\n\");\n        return 1;\n    }\n\n    AVStream *input_audio_stream = NULL;\n    for (unsigned int i = 0; i < input_format_context->nb_streams; i++) {\n        if (input_format_context->streams[i]->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {\n            input_audio_stream = input_format_context->streams[i];\n            break;\n        }\n    }\n\n    if (!input_audio_stream) {\n        fprintf(stderr, \"Could not find audio stream in input file.\\n\");\n        return 1;\n    }\n\n    AVCodec *input_codec = avcodec_find_decoder(input_audio_stream->codecpar->codec_id);\n    if (!input_codec) {\n        fprintf(stderr, \"Unsupported codec.\\n\");\n        return 1;\n    }\n\n    AVCodecContext *input_codec_context = avcodec_alloc_context3(input_codec);\n    if (!input_codec_context) {\n        fprintf(stderr, \"Could not allocate input codec context.\\n\");\n        return 1;\n    }\n\n    if (avcodec_parameters_to_context(input_codec_context, input_audio_stream->codecpar) < 0) {\n        fprintf(stderr, \"Could not fill input codec context.\\n\");\n        return 1;\n    }\n\n    if (avcodec_open2(input_codec_context, input_codec, NULL) < 0) {\n        fprintf(stderr, \"Could not open codec.\\n\");\n        return 1;\n    }\n\n    AVFormatContext *output_format_context = NULL;\n    avformat_alloc_output_context2(&output_format_context, NULL, output_format_name, output_filename);\n    if (!output_format_context) {\n        fprintf(stderr, \"Could not create output context.\\n\");\n        return 1;\n    }\n\n    AVStream *output_audio_stream = avformat_new_stream(output_format_context, NULL);\n    if (!output_audio_stream) {\n        fprintf(stderr, \"Could not create output stream.\\n\");\n        return 1;\n    }\n\n    AVCodec *output_codec = avcodec_find_encoder(output_format_context->oformat->audio_codec);\n    if (!output_codec) {\n        fprintf(stderr, \"Necessary encoder not found.\\n\");\n        return 1;\n    }\n\n    AVCodecContext *output_codec_context = avcodec_alloc_context3(output_codec);\n    if (!output_codec_context) {\n        fprintf(stderr, \"Could not allocate output codec context.\\n\");\n        return 1;\n    }\n\n    output_codec_context->sample_rate = input_codec_context->sample_rate;\n    output_codec_context->channel_layout = input_codec_context->channel_layout;\n    output_codec_context->channels = av_get_channel_layout_nb_channels(output_codec_context->channel_layout);\n    output_codec_context->sample_fmt = output_codec->sample_fmts[0];\n    output_codec_context->bit_rate = 64000;\n\n    if (avcodec_open2(output_codec_context, output_codec, NULL) < 0) {\n        fprintf(stderr, \"Could not open output codec.\\n\");\n        return 1;\n    }\n\n    if (avcodec_parameters_from_context(output_audio_stream->codecpar, output_codec_context) < 0) {\n        fprintf(stderr, \"Could not copy output codec parameters.\\n\");\n        return 1;\n    }\n\n    if (!(output_format_context->oformat->flags & AVFMT_NOFILE)) {\n        if (avio_open(&output_format_context->pb, output_filename, AVIO_FLAG_WRITE) < 0) {\n            fprintf(stderr, \"Could not open output file.\\n\");\n            return 1;\n        }\n    }\n\n    if (avformat_write_header(output_format_context, NULL) < 0) {\n        fprintf(stderr, \"Error occurred when opening output file.\\n\");\n        return 1;\n    }\n\n    AVPacket *packet = av_packet_alloc();\n    if (!packet) {\n        fprintf(stderr, \"Could not allocate packet.\\n\");\n        return 1;\n    }\n\n    AVFrame *frame = av_frame_alloc();\n    if (!frame) {\n        fprintf(stderr, \"Could not allocate audio frame.\\n\");\n        return 1;\n    }\n\n    int response;\n    struct SwrContext *swr_ctx = swr_alloc();\n    swr_alloc_set_opts(swr_ctx, \n                       output_codec_context->channel_layout, \n                       output_codec_context->sample_fmt, \n                       output_codec_context->sample_rate, \n                       input_codec_context->channel_layout, \n                       input_codec_context->sample_fmt, \n                       input_codec_context->sample_rate, \n                       0, NULL);\n    swr_init(swr_ctx);\n\n    while (av_read_frame(input_format_context, packet) >= 0) {\n        if (packet->stream_index == input_audio_stream->index) {\n            response = avcodec_send_packet(input_codec_context, packet);\n            if (response < 0) {\n                fprintf(stderr, \"Failed to send packet to decoder.\\n\");\n                return 1;\n            }\n\n            while (response >= 0) {\n                response = avcodec_receive_frame(input_codec_context, frame);\n                if (response == AVERROR(EAGAIN) || response == AVERROR_EOF) {\n                    break;\n                } else if (response < 0) {\n                    fprintf(stderr, \"Error during decoding.\\n\");\n                    return 1;\n                }\n\n                AVFrame *resampled_frame = av_frame_alloc();\n                resampled_frame->channel_layout = output_codec_context->channel_layout;\n                resampled_frame->sample_rate = output_codec_context->sample_rate;\n                resampled_frame->format = output_codec_context->sample_fmt;\n                resampled_frame->nb_samples = frame->nb_samples;\n\n                av_frame_get_buffer(resampled_frame, 0);\n\n                swr_convert(swr_ctx, \n                            resampled_frame->data, \n                            resampled_frame->nb_samples, \n                            (const uint8_t **)frame->data, \n                            frame->nb_samples);\n\n                response = avcodec_send_frame(output_codec_context, resampled_frame);\n                if (response < 0) {\n                    fprintf(stderr, \"Failed to send frame to encoder.\\n\");\n                    return 1;\n                }\n\n                while (response >= 0) {\n                    response = avcodec_receive_packet(output_codec_context, packet);\n                    if (response == AVERROR(EAGAIN) || response == AVERROR_EOF) {\n                        break;\n                    } else if (response < 0) {\n                        fprintf(stderr, \"Error during encoding.\\n\");\n                        return 1;\n                    }\n\n                    packet->stream_index = output_audio_stream->index;\n                    av_interleaved_write_frame(output_format_context, packet);\n                    av_packet_unref(packet);\n                }\n\n                av_frame_unref(resampled_frame);\n            }\n        }\n        av_packet_unref(packet);\n    }\n\n    av_write_trailer(output_format_context);\n\n    av_packet_free(&packet);\n    av_frame_free(&frame);\n    swr_free(&swr_ctx);\n    avcodec_free_context(&input_codec_context);\n    avcodec_free_context(&output_codec_context);\n    avformat_close_input(&input_format_context);\n    if (!(output_format_context->oformat->flags & AVFMT_NOFILE)) {\n        avio_closep(&output_format_context->pb);\n    }\n    avformat_free_context(output_format_context);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a web application that uses a library for rendering 3D graphics.",
    "code": "```c\n#include <GL/glut.h>\n\nvoid display() {\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n    glBegin(GL_TRIANGLES);\n    glVertex3f(-0.5, -0.5, 0.0);\n    glVertex3f(0.5, -0.5, 0.0);\n    glVertex3f(0.0, 0.5, 0.0);\n    glEnd();\n    glutSwapBuffers();\n}\n\nint main(int argc, char** argv) {\n    glutInit(&argc, argv);\n    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);\n    glutInitWindowSize(800, 600);\n    glutCreateWindow(\"3D Graphics with OpenGL\");\n    glEnable(GL_DEPTH_TEST);\n    glutDisplayFunc(display);\n    glutMainLoop();\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a feature that performs currency conversion using a library for financial calculations.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <libintl.h>  // Hypothetical library for financial calculations\n\ndouble convert_currency(double amount, const char* from_currency, const char* to_currency);\n\nint main() {\n    double amount = 100.0;\n    const char* from_currency = \"USD\";\n    const char* to_currency = \"EUR\";\n\n    double converted_amount = convert_currency(amount, from_currency, to_currency);\n    printf(\"Converted amount: %.2f %s\\n\", converted_amount, to_currency);\n\n    return 0;\n}\n\ndouble convert_currency(double amount, const char* from_currency, const char* to_currency) {\n    double rate = get_exchange_rate(from_currency, to_currency); // Hypothetical function from the library\n    return amount * rate;\n}\n```"
  },
  {
    "task": "Implement a program that manages user sessions using a library for session handling.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"sessionlib.h\" // Hypothetical library for session handling\n\nint main() {\n    // Initialize session library\n    if (!session_init()) {\n        fprintf(stderr, \"Failed to initialize session library\\n\");\n        return EXIT_FAILURE;\n    }\n\n    // Create a new session for a user\n    Session *session = session_create(\"user123\");\n    if (!session) {\n        fprintf(stderr, \"Failed to create session\\n\");\n        session_cleanup();\n        return EXIT_FAILURE;\n    }\n\n    // Perform operations with the session\n    printf(\"Session created for user: %s\\n\", session_get_user(session));\n\n    // Destroy the session\n    if (!session_destroy(session)) {\n        fprintf(stderr, \"Failed to destroy session\\n\");\n        session_cleanup();\n        return EXIT_FAILURE;\n    }\n\n    // Clean up session library\n    session_cleanup();\n    \n    return EXIT_SUCCESS;\n}\n```"
  },
  {
    "task": "Write a script that automates browser actions using a browser automation library.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <webkit2/webkit2.h>\n#include <glib.h>\n\nstatic gboolean on_web_view_load_changed(WebKitWebView *web_view, WebKitLoadEvent load_event, gpointer user_data) {\n    if (load_event == WEBKIT_LOAD_FINISHED) {\n        printf(\"Page load finished.\\n\");\n        gtk_main_quit(); // Exit the main loop when done\n    }\n    return FALSE;\n}\n\nint main(int argc, char **argv) {\n    if (argc != 2) {\n        fprintf(stderr, \"Usage: %s <URL>\\n\", argv[0]);\n        return 1;\n    }\n\n    gtk_init(&argc, &argv);\n\n    WebKitWebView *web_view = WEBKIT_WEB_VIEW(webkit_web_view_new());\n    g_signal_connect(web_view, \"load-changed\", G_CALLBACK(on_web_view_load_changed), NULL);\n\n    GtkWidget *window = gtk_window_new(GTK_WINDOW_TOPLEVEL);\n    gtk_container_add(GTK_CONTAINER(window), GTK_WIDGET(web_view));\n    gtk_widget_show_all(window);\n\n    webkit_web_view_load_uri(web_view, argv[1]);\n\n    gtk_main(); // Start the main loop\n\n    g_object_unref(web_view);\n    return 0;\n}\n```"
  },
  {
    "task": "Use a library to implement data serialization and deserialization in your application.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <jansson.h>\n\ntypedef struct {\n    int id;\n    char name[50];\n    double balance;\n} Account;\n\nchar* serialize_account(const Account *account) {\n    json_t *json_obj = json_object();\n    json_object_set_new(json_obj, \"id\", json_integer(account->id));\n    json_object_set_new(json_obj, \"name\", json_string(account->name));\n    json_object_set_new(json_obj, \"balance\", json_real(account->balance));\n    \n    char *serialized_data = json_dumps(json_obj, JSON_ENCODE_ANY);\n    json_decref(json_obj);\n    return serialized_data;\n}\n\nAccount deserialize_account(const char *data) {\n    Account account;\n    json_error_t error;\n    json_t *json_obj = json_loads(data, 0, &error);\n    \n    if (json_obj) {\n        json_t *id = json_object_get(json_obj, \"id\");\n        json_t *name = json_object_get(json_obj, \"name\");\n        json_t *balance = json_object_get(json_obj, \"balance\");\n\n        account.id = json_integer_value(id);\n        strncpy(account.name, json_string_value(name), sizeof(account.name) - 1);\n        account.name[sizeof(account.name) - 1] = '\\0';\n        account.balance = json_real_value(balance);\n\n        json_decref(json_obj);\n    } else {\n        fprintf(stderr, \"Error parsing JSON: %s\\n\", error.text);\n    }\n\n    return account;\n}\n\nint main() {\n    Account account = {1, \"John Doe\", 1000.50};\n    char *serialized = serialize_account(&account);\n    printf(\"Serialized: %s\\n\", serialized);\n\n    Account deserialized_account = deserialize_account(serialized);\n    printf(\"Deserialized: ID=%d, Name=%s, Balance=%.2f\\n\", \n           deserialized_account.id, deserialized_account.name, deserialized_account.balance);\n\n    free(serialized);\n    return 0;\n}\n```"
  },
  {
    "task": "Build an application that generates interactive reports using a library for data visualization.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <cairo/cairo.h>\n#include <cairo/cairo-pdf.h>\n\nvoid create_report(const char *filename) {\n    cairo_surface_t *surface;\n    cairo_t *cr;\n\n    // Create a PDF surface and context\n    surface = cairo_pdf_surface_create(filename, 595, 842); // A4 size\n    cr = cairo_create(surface);\n\n    // Set font and draw some text\n    cairo_select_font_face(cr, \"Sans\", CAIRO_FONT_SLANT_NORMAL, CAIRO_FONT_WEIGHT_BOLD);\n    cairo_set_font_size(cr, 40);\n    cairo_move_to(cr, 100, 100);\n    cairo_show_text(cr, \"Interactive Report\");\n\n    cairo_set_font_size(cr, 20);\n    cairo_move_to(cr, 100, 150);\n    cairo_show_text(cr, \"This report is generated using Cairo for visualization.\");\n\n    // Draw a rectangle\n    cairo_rectangle(cr, 100, 200, 400, 50);\n    cairo_set_source_rgb(cr, 0.5, 0.5, 1);\n    cairo_fill(cr);\n\n    // Draw a line\n    cairo_set_source_rgb(cr, 0, 0, 0);\n    cairo_set_line_width(cr, 2);\n    cairo_move_to(cr, 100, 300);\n    cairo_line_to(cr, 500, 300);\n    cairo_stroke(cr);\n\n    // Clean up\n    cairo_destroy(cr);\n    cairo_surface_destroy(surface);\n}\n\nint main() {\n    create_report(\"report.pdf\");\n    printf(\"Report generated: report.pdf\\n\");\n    return 0;\n}\n```"
  },
  {
    "task": "Create a system that backs up and restores data using a library for file system operations.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <libgen.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\n#define BUFFER_SIZE 1024\n\nvoid backupData(const char *source, const char *destination) {\n    int src_fd, dest_fd;\n    char buffer[BUFFER_SIZE];\n    ssize_t bytesRead, bytesWritten;\n\n    src_fd = open(source, O_RDONLY);\n    if (src_fd < 0) {\n        perror(\"Error opening source file\");\n        exit(EXIT_FAILURE);\n    }\n\n    dest_fd = open(destination, O_WRONLY | O_CREAT | O_TRUNC, 0644);\n    if (dest_fd < 0) {\n        perror(\"Error opening destination file\");\n        close(src_fd);\n        exit(EXIT_FAILURE);\n    }\n\n    while ((bytesRead = read(src_fd, buffer, BUFFER_SIZE)) > 0) {\n        bytesWritten = write(dest_fd, buffer, bytesRead);\n        if (bytesWritten != bytesRead) {\n            perror(\"Error writing to destination file\");\n            close(src_fd);\n            close(dest_fd);\n            exit(EXIT_FAILURE);\n        }\n    }\n\n    close(src_fd);\n    close(dest_fd);\n}\n\nvoid restoreData(const char *backup, const char *original) {\n    backupData(backup, original);\n}\n\nint main(int argc, char *argv[]) {\n    if (argc != 4) {\n        fprintf(stderr, \"Usage: %s <backup|restore> <source> <destination>\\n\", argv[0]);\n        exit(EXIT_FAILURE);\n    }\n\n    if (strcmp(argv[1], \"backup\") == 0) {\n        backupData(argv[2], argv[3]);\n    } else if (strcmp(argv[1], \"restore\") == 0) {\n        restoreData(argv[2], argv[3]);\n    } else {\n        fprintf(stderr, \"Invalid operation: %s\\n\", argv[1]);\n        exit(EXIT_FAILURE);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a feature that performs real-time language translation using a translation library.",
    "code": "```c\n#include <stdio.h>\n#include <string.h>\n#include <libtranslate.h> // Hypothetical translation library\n\nvoid translate_text(const char *source_text, const char *source_lang, const char *target_lang) {\n    translate_t *translator = translate_new();\n    if (translator == NULL) {\n        fprintf(stderr, \"Failed to initialize translator\\n\");\n        return;\n    }\n\n    char translated_text[1024];\n    if (translate(translator, source_text, source_lang, target_lang, translated_text, sizeof(translated_text)) != 0) {\n        fprintf(stderr, \"Translation failed\\n\");\n    } else {\n        printf(\"Translated text: %s\\n\", translated_text);\n    }\n\n    translate_free(translator);\n}\n\nint main() {\n    const char *text = \"Hello, world!\";\n    const char *source_language = \"en\";\n    const char *target_language = \"es\";\n\n    translate_text(text, source_language, target_language);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a program that tracks stock market prices using a library for financial data retrieval.",
    "code": "```c\n#include <stdio.h>\n#include <yahoofinanceapi.h>  // Hypothetical library for financial data retrieval\n\nint main() {\n    YahooFinanceAPI api;  // Assuming the library provides a struct or object for interaction\n    init_yahoo_finance_api(&api);  // Hypothetical function to initialize the API\n\n    const char* stockSymbol = \"AAPL\";\n    double stockPrice = 0.0;\n\n    if (get_stock_price(&api, stockSymbol, &stockPrice) == 0) {  // Function to retrieve stock price\n        printf(\"The current stock price of %s is $%.2f\\n\", stockSymbol, stockPrice);\n    } else {\n        printf(\"Failed to retrieve stock price for %s\\n\", stockSymbol);\n    }\n\n    cleanup_yahoo_finance_api(&api);  // Hypothetical function to clean up resources\n    return 0;\n}\n```"
  },
  {
    "task": "Write a script that generates and validates JSON Web Tokens using a library for JWT handling.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <jansson.h>\n#include <jwt.h>\n\n#define SECRET_KEY \"your-256-bit-secret\"\n\nint main() {\n    jwt_t *jwt = NULL;\n    char *token = NULL;\n    jwt_alg_t alg = JWT_ALG_HS256;\n\n    // Generate a JWT\n    if (jwt_new(&jwt) != 0) {\n        fprintf(stderr, \"Failed to create JWT object\\n\");\n        return EXIT_FAILURE;\n    }\n    \n    if (jwt_add_grant(jwt, \"iss\", \"issuer\") != 0 ||\n        jwt_add_grant(jwt, \"sub\", \"subject\") != 0 ||\n        jwt_add_grant_int(jwt, \"exp\", time(NULL) + 3600) != 0) {\n        fprintf(stderr, \"Failed to add claims to JWT\\n\");\n        jwt_free(jwt);\n        return EXIT_FAILURE;\n    }\n\n    if (jwt_set_alg(jwt, alg, (unsigned char *)SECRET_KEY, strlen(SECRET_KEY)) != 0) {\n        fprintf(stderr, \"Failed to set algorithm and key\\n\");\n        jwt_free(jwt);\n        return EXIT_FAILURE;\n    }\n\n    token = jwt_encode_str(jwt);\n    if (!token) {\n        fprintf(stderr, \"Failed to encode JWT\\n\");\n        jwt_free(jwt);\n        return EXIT_FAILURE;\n    }\n\n    printf(\"Generated JWT: %s\\n\", token);\n\n    // Validate the JWT\n    jwt_t *decoded_jwt = NULL;\n    if (jwt_decode(&decoded_jwt, token, (unsigned char *)SECRET_KEY, strlen(SECRET_KEY)) != 0) {\n        fprintf(stderr, \"Failed to decode JWT\\n\");\n        free(token);\n        jwt_free(jwt);\n        return EXIT_FAILURE;\n    }\n\n    const char *iss = jwt_get_grant(decoded_jwt, \"iss\");\n    if (iss) {\n        printf(\"Decoded JWT issuer: %s\\n\", iss);\n    } else {\n        fprintf(stderr, \"Failed to retrieve 'iss' from decoded JWT\\n\");\n    }\n\n    free(token);\n    jwt_free(jwt);\n    jwt_free(decoded_jwt);\n\n    return EXIT_SUCCESS;\n}\n```"
  },
  {
    "task": "Use a library to build a feature that synchronizes data across multiple devices.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <libsync.h> // Hypothetical library for data synchronization\n\nint main() {\n    SyncHandle *sync_handle;\n    int init_result, sync_result;\n\n    // Initialize synchronization library\n    init_result = sync_init();\n    if (init_result != SYNC_SUCCESS) {\n        fprintf(stderr, \"Failed to initialize sync library\\n\");\n        return EXIT_FAILURE;\n    }\n\n    // Create a sync handle for a specific data set\n    sync_handle = sync_create_handle(\"dataset_id\");\n    if (!sync_handle) {\n        fprintf(stderr, \"Failed to create sync handle\\n\");\n        sync_cleanup();\n        return EXIT_FAILURE;\n    }\n\n    // Perform data synchronization across devices\n    sync_result = sync_data(sync_handle);\n    if (sync_result != SYNC_SUCCESS) {\n        fprintf(stderr, \"Data synchronization failed\\n\");\n        sync_destroy_handle(sync_handle);\n        sync_cleanup();\n        return EXIT_FAILURE;\n    }\n\n    printf(\"Data synchronized successfully!\\n\");\n\n    // Clean up resources\n    sync_destroy_handle(sync_handle);\n    sync_cleanup();\n\n    return EXIT_SUCCESS;\n}\n```"
  },
  {
    "task": "Build a program that implements pattern recognition using a library for machine learning.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <cblas.h> // Example for using BLAS library for matrix operations\n#include <fann.h>  // Fast Artificial Neural Network Library for machine learning\n\nint main() {\n    // Create a simple neural network\n    const unsigned int num_input = 2;\n    const unsigned int num_output = 1;\n    const unsigned int num_layers = 3;\n    const unsigned int num_neurons_hidden = 3;\n    struct fann *ann = fann_create_standard(num_layers, num_input, num_neurons_hidden, num_output);\n\n    // Set activation functions\n    fann_set_activation_function_hidden(ann, FANN_SIGMOID_SYMMETRIC);\n    fann_set_activation_function_output(ann, FANN_SIGMOID_SYMMETRIC);\n\n    // Training data\n    fann_type train_input[2] = { -1, 1 };\n    fann_type *calc_out;\n\n    // Train the network with predefined data\n    fann_train_on_file(ann, \"training_data.data\", 5000, 100, 0.001);\n\n    // Run the network on the input data\n    calc_out = fann_run(ann, train_input);\n\n    // Output the result\n    printf(\"Result: %f\\n\", calc_out[0]);\n\n    // Clean up\n    fann_destroy(ann);\n    return 0;\n}\n```"
  },
  {
    "task": "Create an email client that uses a library for IMAP and POP3 communication.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <libetpan/libetpan.h>\n\nvoid check_imap_mailbox(const char *server, const char *username, const char *password) {\n    mailsession *session = NULL;\n    mailimap *imap = NULL;\n    int r;\n    \n    session = mailsession_new(SESSION_IMAP);\n    if (session == NULL) {\n        fprintf(stderr, \"Unable to create session\\n\");\n        return;\n    }\n    \n    r = mailsession_connect(session, server, 0, 0);\n    if (r != MAIL_NO_ERROR) {\n        fprintf(stderr, \"Connection error: %s\\n\", mail_strerror(r));\n        return;\n    }\n    \n    imap = (mailimap *)session_get_data(session);\n    r = mailimap_login(imap, username, password);\n    if (r != MAILIMAP_NO_ERROR) {\n        fprintf(stderr, \"Login error: %s\\n\", mailimap_strerror(r));\n        return;\n    }\n    \n    printf(\"IMAP connection successful\\n\");\n    mailimap_logout(imap);\n    mailsession_free(session);\n}\n\nvoid check_pop3_mailbox(const char *server, const char *username, const char *password) {\n    mailsession *session = NULL;\n    int r;\n    \n    session = mailsession_new(SESSION_POP3);\n    if (session == NULL) {\n        fprintf(stderr, \"Unable to create session\\n\");\n        return;\n    }\n    \n    r = mailsession_connect(session, server, 0, 0);\n    if (r != MAIL_NO_ERROR) {\n        fprintf(stderr, \"Connection error: %s\\n\", mail_strerror(r));\n        return;\n    }\n    \n    r = mailpop3_authenticate((mailpop3 *)session_get_data(session), username, password);\n    if (r != MAILPOP3_NO_ERROR) {\n        fprintf(stderr, \"Authentication error: %s\\n\", mailpop3_strerror(r));\n        return;\n    }\n    \n    printf(\"POP3 connection successful\\n\");\n    mailsession_free(session);\n}\n\nint main() {\n    const char *imap_server = \"imap.example.com\";\n    const char *pop3_server = \"pop3.example.com\";\n    const char *username = \"user@example.com\";\n    const char *password = \"password\";\n\n    check_imap_mailbox(imap_server, username, password);\n    check_pop3_mailbox(pop3_server, username, password);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a feature that analyzes network traffic using a library for network monitoring.",
    "code": "```c\n#include <stdio.h>\n#include <pcap.h>\n\nvoid analyze_network_traffic(const u_char *packet, struct pcap_pkthdr packet_header) {\n    printf(\"Packet size: %d bytes\\n\", packet_header.len);\n    // Additional analysis would go here\n}\n\nint main() {\n    char *dev, errbuf[PCAP_ERRBUF_SIZE];\n    pcap_t *handle;\n\n    dev = pcap_lookupdev(errbuf);\n    if (dev == NULL) {\n        fprintf(stderr, \"Couldn't find default device: %s\\n\", errbuf);\n        return 1;\n    }\n\n    handle = pcap_open_live(dev, BUFSIZ, 1, 1000, errbuf);\n    if (handle == NULL) {\n        fprintf(stderr, \"Couldn't open device %s: %s\\n\", dev, errbuf);\n        return 2;\n    }\n\n    pcap_loop(handle, 10, analyze_network_traffic, NULL);\n\n    pcap_close(handle);\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a program that manages user authentication and authorization using a security library.",
    "code": "```c\n#include <security/pam_appl.h>\n#include <security/pam_misc.h>\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    pam_handle_t *pamh = NULL;\n    struct pam_conv pamc = { misc_conv, NULL };\n    int retval;\n    const char *user = \"testuser\";\n\n    retval = pam_start(\"check_user\", user, &pamc, &pamh);\n    if (retval == PAM_SUCCESS) {\n        retval = pam_authenticate(pamh, 0);\n        if (retval == PAM_SUCCESS) {\n            retval = pam_acct_mgmt(pamh, 0);\n            if (retval == PAM_SUCCESS) {\n                printf(\"User authenticated and authorized successfully.\\n\");\n            } else {\n                printf(\"User authorization failed.\\n\");\n            }\n        } else {\n            printf(\"User authentication failed.\\n\");\n        }\n        pam_end(pamh, retval);\n    } else {\n        printf(\"PAM start failed.\\n\");\n    }\n\n    return retval == PAM_SUCCESS ? 0 : 1;\n}\n```"
  },
  {
    "task": "Write a script that generates word clouds from text data using a library for text visualization.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <wordcloud_c/wordcloud.h>\n\nint main() {\n    const char *text = \"Sample text data for generating a word cloud. \"\n                       \"This is a simple example of word cloud generation using a library.\";\n    const char *output_image = \"wordcloud.png\";\n\n    // Create a word cloud object\n    WordCloud *wc = wc_new();\n    if (!wc) {\n        fprintf(stderr, \"Failed to create word cloud object\\n\");\n        return EXIT_FAILURE;\n    }\n\n    // Configure word cloud\n    wc_set_width(wc, 800);\n    wc_set_height(wc, 600);\n    wc_set_background_color(wc, 255, 255, 255, 255);  // White background\n    wc_set_font_path(wc, \"/path/to/font.ttf\");        // Set the path to a valid TTF font file\n\n    // Generate the word cloud from text\n    if (wc_generate_from_text(wc, text) != 0) {\n        fprintf(stderr, \"Failed to generate word cloud\\n\");\n        wc_free(wc);\n        return EXIT_FAILURE;\n    }\n\n    // Save the word cloud to an image file\n    if (wc_save_to_file(wc, output_image) != 0) {\n        fprintf(stderr, \"Failed to save word cloud to file\\n\");\n        wc_free(wc);\n        return EXIT_FAILURE;\n    }\n\n    // Clean up\n    wc_free(wc);\n    printf(\"Word cloud saved to %s\\n\", output_image);\n    return EXIT_SUCCESS;\n}\n```"
  },
  {
    "task": "Use a library to create a feature that schedules and sends automated emails.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <libical/ical.h>\n#include <curl/curl.h>\n\n#define SMTP_SERVER \"smtp://smtp.example.com:587\"\n#define SMTP_USERNAME \"your_email@example.com\"\n#define SMTP_PASSWORD \"your_password\"\n\nvoid send_email(const char *to, const char *subject, const char *body) {\n    CURL *curl;\n    CURLcode res = CURLE_OK;\n    struct curl_slist *recipients = NULL;\n\n    curl = curl_easy_init();\n    if(curl) {\n        curl_easy_setopt(curl, CURLOPT_USERNAME, SMTP_USERNAME);\n        curl_easy_setopt(curl, CURLOPT_PASSWORD, SMTP_PASSWORD);\n        curl_easy_setopt(curl, CURLOPT_URL, SMTP_SERVER);\n        curl_easy_setopt(curl, CURLOPT_MAIL_FROM, SMTP_USERNAME);\n\n        recipients = curl_slist_append(recipients, to);\n        curl_easy_setopt(curl, CURLOPT_MAIL_RCPT, recipients);\n\n        curl_easy_setopt(curl, CURLOPT_READFUNCTION, fread);\n        curl_easy_setopt(curl, CURLOPT_READDATA, body);\n        curl_easy_setopt(curl, CURLOPT_UPLOAD, 1L);\n\n        res = curl_easy_perform(curl);\n\n        if(res != CURLE_OK)\n            fprintf(stderr, \"curl_easy_perform() failed: %s\\n\", curl_easy_strerror(res));\n\n        curl_slist_free_all(recipients);\n        curl_easy_cleanup(curl);\n    }\n}\n\nint main() {\n    icaltimetype start = icaltime_from_string(\"20231010T090000Z\");\n    icaltimetype end = icaltime_from_string(\"20231010T093000Z\");\n    icalcomponent *event = icalcomponent_new_vevent();\n    icalcomponent_set_dtstart(event, start);\n    icalcomponent_set_dtend(event, end);\n    icalcomponent_set_summary(event, \"Scheduled Email\");\n\n    // Simulate scheduling logic here\n    // For simplicity, immediately send email\n    send_email(\"recipient@example.com\", \"Automated Email\", \"This is an automated email sent using libical and libcurl.\");\n\n    icalcomponent_free(event);\n    return 0;\n}\n```"
  },
  {
    "task": "Build a mobile application that accesses device sensors using a library for hardware interaction.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include \"sensor_library.h\" // Hypothetical library for sensor interaction\n\nint main() {\n    if (initialize_sensors() != 0) {\n        fprintf(stderr, \"Failed to initialize sensors\\n\");\n        return EXIT_FAILURE;\n    }\n\n    float temperature = 0.0f;\n    if (get_temperature_sensor_data(&temperature) != 0) {\n        fprintf(stderr, \"Failed to read temperature data\\n\");\n        return EXIT_FAILURE;\n    }\n\n    printf(\"Current Temperature: %.2f\u00b0C\\n\", temperature);\n\n    if (shutdown_sensors() != 0) {\n        fprintf(stderr, \"Failed to shut down sensors\\n\");\n        return EXIT_FAILURE;\n    }\n\n    return EXIT_SUCCESS;\n}\n```"
  },
  {
    "task": "Create a system that audits and logs file system changes using a library for filesystem monitoring.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/inotify.h>\n#include <unistd.h>\n\n#define EVENT_SIZE (sizeof(struct inotify_event))\n#define EVENT_BUF_LEN (1024 * (EVENT_SIZE + 16))\n\nint main() {\n    int length, i = 0;\n    int fd;\n    int wd;\n    char buffer[EVENT_BUF_LEN];\n\n    // Initialize inotify\n    fd = inotify_init();\n    if (fd < 0) {\n        perror(\"inotify_init\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Add watch on a directory or file\n    wd = inotify_add_watch(fd, \"/path/to/monitor\", IN_MODIFY | IN_CREATE | IN_DELETE);\n    if (wd == -1) {\n        perror(\"inotify_add_watch\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Read events\n    while ((length = read(fd, buffer, EVENT_BUF_LEN)) > 0) {\n        i = 0;\n        while (i < length) {\n            struct inotify_event *event = (struct inotify_event *)&buffer[i];\n            if (event->len) {\n                if (event->mask & IN_CREATE) {\n                    printf(\"New file %s created.\\n\", event->name);\n                } else if (event->mask & IN_DELETE) {\n                    printf(\"File %s deleted.\\n\", event->name);\n                } else if (event->mask & IN_MODIFY) {\n                    printf(\"File %s modified.\\n\", event->name);\n                }\n            }\n            i += EVENT_SIZE + event->len;\n        }\n    }\n\n    // Clean up\n    inotify_rm_watch(fd, wd);\n    close(fd);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a feature that visualizes geospatial data using a library for geographic information systems.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ogr_api.h>\n#include <ogr_srs_api.h>\n#include <ogr_geometry.h>\n\nvoid visualizeGeospatialData(const char *filename) {\n    OGRRegisterAll();\n    OGRDataSourceH hDS = OGROpen(filename, FALSE, NULL);\n    if (hDS == NULL) {\n        fprintf(stderr, \"Failed to open dataset: %s\\n\", filename);\n        exit(1);\n    }\n\n    OGRLayerH hLayer = OGR_DS_GetLayer(hDS, 0);\n    if (hLayer == NULL) {\n        fprintf(stderr, \"Failed to get layer\\n\");\n        OGR_DS_Destroy(hDS);\n        exit(1);\n    }\n\n    OGRFeatureH hFeature;\n    OGR_L_ResetReading(hLayer);\n    while ((hFeature = OGR_L_GetNextFeature(hLayer)) != NULL) {\n        OGRGeometryH hGeometry = OGR_F_GetGeometryRef(hFeature);\n        if (hGeometry != NULL) {\n            char *wkt;\n            OGR_G_ExportToWkt(hGeometry, &wkt);\n            printf(\"Feature WKT: %s\\n\", wkt);\n            CPLFree(wkt);\n        }\n        OGR_F_Destroy(hFeature);\n    }\n\n    OGR_DS_Destroy(hDS);\n}\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        fprintf(stderr, \"Usage: %s <shapefile>\\n\", argv[0]);\n        return 1;\n    }\n    visualizeGeospatialData(argv[1]);\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a program that performs clustering analysis using a library for statistical computing.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <gsl/gsl_vector.h>\n#include <gsl/gsl_matrix.h>\n#include <gsl/gsl_statistics.h>\n#include <gsl/gsl_rng.h>\n#include <gsl/gsl_blas.h>\n#include <gsl/gsl_linalg.h>\n\n#define NUM_POINTS 100\n#define DIMENSIONS 2\n#define NUM_CLUSTERS 3\n\nvoid perform_clustering(gsl_matrix *data, gsl_matrix *centroids, size_t num_points, size_t dimensions, size_t num_clusters) {\n    // Simple K-Means clustering\n    size_t i, j, k;\n    gsl_rng *rng = gsl_rng_alloc(gsl_rng_default);\n    gsl_rng_set(rng, time(NULL));\n\n    // Initialize centroids to random points from the dataset\n    for (i = 0; i < num_clusters; i++) {\n        size_t random_index = gsl_rng_uniform_int(rng, num_points);\n        gsl_vector_view data_point = gsl_matrix_row(data, random_index);\n        gsl_vector_view centroid = gsl_matrix_row(centroids, i);\n        gsl_vector_memcpy(&centroid.vector, &data_point.vector);\n    }\n\n    int changed;\n    gsl_vector *distances = gsl_vector_alloc(num_clusters);\n    size_t *assignments = malloc(num_points * sizeof(size_t));\n\n    do {\n        changed = 0;\n\n        // Assignment step\n        for (i = 0; i < num_points; i++) {\n            gsl_vector_view data_point = gsl_matrix_row(data, i);\n            for (j = 0; j < num_clusters; j++) {\n                gsl_vector_view centroid = gsl_matrix_row(centroids, j);\n                gsl_vector_memcpy(distances, &data_point.vector);\n                gsl_vector_sub(distances, &centroid.vector);\n                double distance = gsl_blas_dnrm2(distances);\n                gsl_vector_set(distances, j, distance);\n            }\n\n            size_t new_assignment = gsl_vector_min_index(distances);\n            if (assignments[i] != new_assignment) {\n                assignments[i] = new_assignment;\n                changed = 1;\n            }\n        }\n\n        // Update step\n        gsl_matrix_set_zero(centroids);\n        size_t *cluster_sizes = calloc(num_clusters, sizeof(size_t));\n\n        for (i = 0; i < num_points; i++) {\n            gsl_vector_view data_point = gsl_matrix_row(data, i);\n            gsl_vector_view centroid = gsl_matrix_row(centroids, assignments[i]);\n            gsl_vector_add(&centroid.vector, &data_point.vector);\n            cluster_sizes[assignments[i]]++;\n        }\n\n        for (j = 0; j < num_clusters; j++) {\n            if (cluster_sizes[j] != 0) {\n                gsl_vector_view centroid = gsl_matrix_row(centroids, j);\n                gsl_vector_scale(&centroid.vector, 1.0 / cluster_sizes[j]);\n            }\n        }\n\n        free(cluster_sizes);\n\n    } while (changed);\n\n    gsl_vector_free(distances);\n    gsl_rng_free(rng);\n    free(assignments);\n}\n\nint main() {\n    gsl_matrix *data = gsl_matrix_alloc(NUM_POINTS, DIMENSIONS);\n    gsl_matrix *centroids = gsl_matrix_alloc(NUM_CLUSTERS, DIMENSIONS);\n\n    // Fill data matrix with random values or real data\n    // For example:\n    // gsl_matrix_set(data, i, j, value);\n\n    perform_clustering(data, centroids, NUM_POINTS, DIMENSIONS, NUM_CLUSTERS);\n\n    gsl_matrix_free(data);\n    gsl_matrix_free(centroids);\n    return 0;\n}\n```"
  },
  {
    "task": "Write a script that monitors and analyzes CPU and memory usage using a library for system diagnostics.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/sysinfo.h>\n\nvoid monitor_system_usage() {\n    struct sysinfo sys_info;\n    \n    if (sysinfo(&sys_info) != 0) {\n        perror(\"sysinfo\");\n        return;\n    }\n\n    long totalram = sys_info.totalram / 1024 / 1024;\n    long freeram = sys_info.freeram / 1024 / 1024;\n    long usedram = totalram - freeram;\n\n    printf(\"CPU Load: %.2f%%\\n\", (sys_info.loads[0] / (float)(1 << SI_LOAD_SHIFT)) * 100);\n    printf(\"Total RAM: %ld MB\\n\", totalram);\n    printf(\"Used RAM: %ld MB\\n\", usedram);\n    printf(\"Free RAM: %ld MB\\n\", freeram);\n}\n\nint main() {\n    while (1) {\n        monitor_system_usage();\n        sleep(5); // Monitor every 5 seconds\n    }\n    return 0;\n}\n```"
  },
  {
    "task": "Use a library to implement a feature that provides voice commands in your application.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <pocketsphinx.h>\n\nvoid execute_voice_command(const char *command) {\n    if (strcmp(command, \"start\") == 0) {\n        printf(\"Starting the application...\\n\");\n    } else if (strcmp(command, \"stop\") == 0) {\n        printf(\"Stopping the application...\\n\");\n    } else {\n        printf(\"Unknown command: %s\\n\", command);\n    }\n}\n\nint main() {\n    ps_decoder_t *ps;\n    cmd_ln_t *config;\n    int rv;\n    const char *hyp;\n\n    config = cmd_ln_init(NULL, ps_args(), TRUE,\n                         \"-hmm\", MODELDIR \"/en-us/en-us\",\n                         \"-lm\", MODELDIR \"/en-us/en-us.lm.bin\",\n                         \"-dict\", MODELDIR \"/cmudict-en-us.dict\",\n                         NULL);\n\n    ps = ps_init(config);\n\n    FILE *fh;\n    fh = fopen(\"voice.raw\", \"rb\");\n    if (fh == NULL) {\n        fprintf(stderr, \"Failed to open file\\n\");\n        return -1;\n    }\n\n    rv = ps_decode_raw(ps, fh, -1);\n    if (rv < 0) {\n        fprintf(stderr, \"Failed to decode\\n\");\n        return -1;\n    }\n\n    hyp = ps_get_hyp(ps, NULL);\n    if (hyp != NULL) {\n        printf(\"Recognized: %s\\n\", hyp);\n        execute_voice_command(hyp);\n    }\n\n    fclose(fh);\n    ps_free(ps);\n    cmd_ln_free_r(config);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Build a tool that converts video files to different resolutions using a video processing library.",
    "code": "```c\n#include <libavformat/avformat.h>\n#include <libavcodec/avcodec.h>\n#include <libswscale/swscale.h>\n\nvoid convert_video_resolution(const char *input_file, const char *output_file, int target_width, int target_height) {\n    AVFormatContext *input_format_context = NULL;\n    AVFormatContext *output_format_context = NULL;\n    AVCodecContext *input_codec_context = NULL;\n    AVCodecContext *output_codec_context = NULL;\n    AVStream *input_stream = NULL;\n    AVStream *output_stream = NULL;\n    AVPacket packet;\n    struct SwsContext *sws_ctx = NULL;\n\n    av_register_all();\n\n    avformat_open_input(&input_format_context, input_file, NULL, NULL);\n    avformat_find_stream_info(input_format_context, NULL);\n\n    avformat_alloc_output_context2(&output_format_context, NULL, NULL, output_file);\n    input_stream = input_format_context->streams[0];\n    AVCodec *decoder = avcodec_find_decoder(input_stream->codecpar->codec_id);\n    input_codec_context = avcodec_alloc_context3(decoder);\n    avcodec_parameters_to_context(input_codec_context, input_stream->codecpar);\n    avcodec_open2(input_codec_context, decoder, NULL);\n\n    output_stream = avformat_new_stream(output_format_context, NULL);\n    AVCodec *encoder = avcodec_find_encoder(AV_CODEC_ID_H264);\n    output_codec_context = avcodec_alloc_context3(encoder);\n    output_codec_context->height = target_height;\n    output_codec_context->width = target_width;\n    output_codec_context->sample_aspect_ratio = input_codec_context->sample_aspect_ratio;\n    output_codec_context->pix_fmt = AV_PIX_FMT_YUV420P;\n    output_codec_context->time_base = input_stream->time_base;\n    avcodec_open2(output_codec_context, encoder, NULL);\n    avcodec_parameters_from_context(output_stream->codecpar, output_codec_context);\n\n    avio_open(&output_format_context->pb, output_file, AVIO_FLAG_WRITE);\n    avformat_write_header(output_format_context, NULL);\n\n    sws_ctx = sws_getContext(input_codec_context->width, input_codec_context->height, input_codec_context->pix_fmt,\n                             target_width, target_height, output_codec_context->pix_fmt, SWS_BICUBIC, NULL, NULL, NULL);\n\n    av_init_packet(&packet);\n    while (av_read_frame(input_format_context, &packet) >= 0) {\n        if (packet.stream_index == input_stream->index) {\n            avcodec_send_packet(input_codec_context, &packet);\n            AVFrame *frame = av_frame_alloc();\n            if (avcodec_receive_frame(input_codec_context, frame) >= 0) {\n                AVFrame *scaled_frame = av_frame_alloc();\n                scaled_frame->format = output_codec_context->pix_fmt;\n                scaled_frame->width = target_width;\n                scaled_frame->height = target_height;\n                av_frame_get_buffer(scaled_frame, 32);\n                sws_scale(sws_ctx, (const uint8_t *const *)frame->data, frame->linesize, 0,\n                          input_codec_context->height, scaled_frame->data, scaled_frame->linesize);\n                avcodec_send_frame(output_codec_context, scaled_frame);\n                AVPacket out_packet;\n                av_init_packet(&out_packet);\n                if (avcodec_receive_packet(output_codec_context, &out_packet) >= 0) {\n                    av_write_frame(output_format_context, &out_packet);\n                    av_packet_unref(&out_packet);\n                }\n                av_frame_free(&scaled_frame);\n            }\n            av_frame_free(&frame);\n        }\n        av_packet_unref(&packet);\n    }\n\n    av_write_trailer(output_format_context);\n\n    avcodec_free_context(&input_codec_context);\n    avcodec_free_context(&output_codec_context);\n    avformat_close_input(&input_format_context);\n    avio_closep(&output_format_context->pb);\n    avformat_free_context(output_format_context);\n    sws_freeContext(sws_ctx);\n}\n\nint main(int argc, char *argv[]) {\n    if (argc < 5) {\n        fprintf(stderr, \"Usage: %s <input file> <output file> <target width> <target height>\\n\", argv[0]);\n        return 1;\n    }\n\n    const char *input_file = argv[1];\n    const char *output_file = argv[2];\n    int target_width = atoi(argv[3]);\n    int target_height = atoi(argv[4]);\n\n    convert_video_resolution(input_file, output_file, target_width, target_height);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Create a program that detects and classifies objects in images using a library for image recognition.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <opencv2/opencv.hpp>\n#include <opencv2/dnn.hpp>\n\nint main(int argc, char** argv) {\n    if (argc != 3) {\n        printf(\"Usage: %s <image_path> <model_path>\\n\", argv[0]);\n        return -1;\n    }\n\n    const char* image_path = argv[1];\n    const char* model_path = argv[2];\n    \n    cv::Mat image = cv::imread(image_path);\n    if (image.empty()) {\n        printf(\"Could not read the image: %s\\n\", image_path);\n        return -1;\n    }\n\n    cv::dnn::Net net = cv::dnn::readNet(model_path);\n    if (net.empty()) {\n        printf(\"Could not load the model: %s\\n\", model_path);\n        return -1;\n    }\n\n    cv::Mat inputBlob = cv::dnn::blobFromImage(image, 1.0, cv::Size(224, 224), cv::Scalar(104, 117, 123));\n    net.setInput(inputBlob);\n    cv::Mat result = net.forward();\n\n    double minVal, maxVal;\n    cv::Point minLoc, maxLoc;\n    cv::minMaxLoc(result, &minVal, &maxVal, &minLoc, &maxLoc);\n    printf(\"Detected object class ID: %d with confidence: %f\\n\", maxLoc.x, maxVal);\n\n    return 0;\n}\n```"
  },
  {
    "task": "Develop a feature that generates synthetic test data using a data generation library.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n// Function to generate a random integer\nint generate_random_int(int min, int max) {\n    return min + rand() % (max - min + 1);\n}\n\n// Function to generate a random floating-point number\ndouble generate_random_double(double min, double max) {\n    return min + (double)rand() / RAND_MAX * (max - min);\n}\n\n// Function to generate synthetic test data\nvoid generate_synthetic_data(int num_samples) {\n    for (int i = 0; i < num_samples; i++) {\n        int random_int = generate_random_int(1, 100);\n        double random_double = generate_random_double(1.0, 100.0);\n        printf(\"Sample %d: int = %d, double = %.2f\\n\", i + 1, random_int, random_double);\n    }\n}\n\nint main() {\n    srand(time(NULL));  // Seed the random number generator\n    int num_samples = 10;  // Number of synthetic samples to generate\n    generate_synthetic_data(num_samples);\n    return 0;\n}\n```"
  },
  {
    "task": "Implement a script that interacts with IoT devices using a library for IoT communication.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include \"iot_library.h\" // Replace with actual IoT library header\n\nvoid connect_to_device(const char *device_id) {\n    IoTDevice *device = iot_connect(device_id);\n    if (device == NULL) {\n        fprintf(stderr, \"Error connecting to device: %s\\n\", device_id);\n        return;\n    }\n    printf(\"Connected to device: %s\\n\", device_id);\n\n    // Example interaction\n    int status = iot_send_command(device, \"GET_STATUS\");\n    if (status != 0) {\n        fprintf(stderr, \"Failed to send command to device: %s\\n\", device_id);\n    } else {\n        printf(\"Command sent successfully to device: %s\\n\", device_id);\n    }\n\n    iot_disconnect(device);\n    printf(\"Disconnected from device: %s\\n\", device_id);\n}\n\nint main() {\n    const char *device_id = \"device_1234\"; // Replace with actual device ID\n    connect_to_device(device_id);\n    return 0;\n}\n```"
  },
  {
    "task": "Write a program that compresses and decompresses data using a data compression library.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <zlib.h>\n\n#define CHUNK 16384\n\nvoid compressData(FILE *source, FILE *dest) {\n    int ret, flush;\n    unsigned have;\n    z_stream strm;\n    unsigned char in[CHUNK];\n    unsigned char out[CHUNK];\n\n    strm.zalloc = Z_NULL;\n    strm.zfree = Z_NULL;\n    strm.opaque = Z_NULL;\n    ret = deflateInit(&strm, Z_DEFAULT_COMPRESSION);\n    if (ret != Z_OK) {\n        return;\n    }\n\n    do {\n        strm.avail_in = fread(in, 1, CHUNK, source);\n        if (ferror(source)) {\n            (void)deflateEnd(&strm);\n            return;\n        }\n        flush = feof(source) ? Z_FINISH : Z_NO_FLUSH;\n        strm.next_in = in;\n\n        do {\n            strm.avail_out = CHUNK;\n            strm.next_out = out;\n            ret = deflate(&strm, flush);\n            have = CHUNK - strm.avail_out;\n            if (fwrite(out, 1, have, dest) != have || ferror(dest)) {\n                (void)deflateEnd(&strm);\n                return;\n            }\n        } while (strm.avail_out == 0);\n\n    } while (flush != Z_FINISH);\n    (void)deflateEnd(&strm);\n}\n\nvoid decompressData(FILE *source, FILE *dest) {\n    int ret;\n    unsigned have;\n    z_stream strm;\n    unsigned char in[CHUNK];\n    unsigned char out[CHUNK];\n\n    strm.zalloc = Z_NULL;\n    strm.zfree = Z_NULL;\n    strm.opaque = Z_NULL;\n    strm.avail_in = 0;\n    strm.next_in = Z_NULL;\n    ret = inflateInit(&strm);\n    if (ret != Z_OK) {\n        return;\n    }\n\n    do {\n        strm.avail_in = fread(in, 1, CHUNK, source);\n        if (ferror(source)) {\n            (void)inflateEnd(&strm);\n            return;\n        }\n        if (strm.avail_in == 0) break;\n        strm.next_in = in;\n\n        do {\n            strm.avail_out = CHUNK;\n            strm.next_out = out;\n            ret = inflate(&strm, Z_NO_FLUSH);\n            switch (ret) {\n            case Z_NEED_DICT:\n            case Z_DATA_ERROR:\n            case Z_MEM_ERROR:\n                (void)inflateEnd(&strm);\n                return;\n            }\n            have = CHUNK - strm.avail_out;\n            if (fwrite(out, 1, have, dest) != have || ferror(dest)) {\n                (void)inflateEnd(&strm);\n                return;\n            }\n        } while (strm.avail_out == 0);\n\n    } while (ret != Z_STREAM_END);\n    (void)inflateEnd(&strm);\n}\n\nint main() {\n    FILE *source = fopen(\"input.txt\", \"rb\");\n    FILE *compressed = fopen(\"compressed.bin\", \"wb\");\n    FILE *decompressed = fopen(\"decompressed.txt\", \"wb\");\n\n    if (source && compressed && decompressed) {\n        compressData(source, compressed);\n        fclose(source);\n        fclose(compressed);\n\n        compressed = fopen(\"compressed.bin\", \"rb\");\n        if (compressed) {\n            decompressData(compressed, decompressed);\n            fclose(compressed);\n        }\n        fclose(decompressed);\n    }\n\n    return 0;\n}\n```"
  },
  {
    "task": "Use a library to implement a feature that generates dynamic web content from templates.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctemplate/template.h>\n\nint main() {\n    // Initialize the template system\n    ctemplate_initialize();\n\n    // Create a new template dictionary\n    TemplateDictionary *dict = ctemplate_create_dictionary(\"example\");\n\n    // Set values in the dictionary\n    ctemplate_set_value(dict, \"TITLE\", \"Dynamic Web Page\");\n    ctemplate_set_value(dict, \"BODY\", \"This content is generated from a template.\");\n\n    // Load and expand the template\n    const char *template_path = \"template.tpl\";\n    char *output;\n    size_t output_size;\n    ctemplate_expand_template(template_path, dict, &output, &output_size);\n\n    // Output the result\n    printf(\"%s\\n\", output);\n\n    // Clean up\n    ctemplate_free_dictionary(dict);\n    free(output);\n    ctemplate_terminate();\n\n    return 0;\n}\n```"
  },
  {
    "task": "Build an application that integrates with social media platforms using a library for API communication.",
    "code": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <curl/curl.h>\n\n#define API_URL \"https://api.socialmedia.com/v1/endpoint\"\n#define ACCESS_TOKEN \"your_access_token_here\"\n\nstatic size_t WriteCallback(void *contents, size_t size, size_t nmemb, void *userp) {\n    ((char *)userp)[strlen(userp) + size * nmemb] = 0;\n    strncat(userp, contents, size * nmemb);\n    return size * nmemb;\n}\n\nvoid api_request() {\n    CURL *curl;\n    CURLcode res;\n    char url[256];\n    char response[1024] = {0};\n\n    snprintf(url, sizeof(url), \"%s?access_token=%s\", API_URL, ACCESS_TOKEN);\n\n    curl_global_init(CURL_GLOBAL_DEFAULT);\n    curl = curl_easy_init();\n    if(curl) {\n        curl_easy_setopt(curl, CURLOPT_URL, url);\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, response);\n\n        res = curl_easy_perform(curl);\n\n        if(res != CURLE_OK) {\n            fprintf(stderr, \"curl_easy_perform() failed: %s\\n\", curl_easy_strerror(res));\n        } else {\n            printf(\"Response:\\n%s\\n\", response);\n        }\n\n        curl_easy_cleanup(curl);\n    }\n\n    curl_global_cleanup();\n}\n\nint main(void) {\n    api_request();\n    return 0;\n}\n```"
  }
]