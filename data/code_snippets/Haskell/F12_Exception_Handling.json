[
  {
    "task": "Write a function that reads a file and handles the exception if the file is not found.",
    "code": "```haskell\nimport System.IO\nimport Control.Exception\n\nreadFileWithExceptionHandling :: FilePath -> IO ()\nreadFileWithExceptionHandling path = do\n    result <- try (readFile path) :: IO (Either IOError String)\n    case result of\n        Left ex  -> putStrLn $ \"An error occurred: \" ++ show ex\n        Right content -> putStrLn content\n```"
  },
  {
    "task": "Create a program that divides two numbers and catches any division by zero errors.",
    "code": "```haskell\nimport Control.Exception\n\nsafeDivide :: Double -> Double -> IO Double\nsafeDivide _ 0 = throwIO (ArithmeticException \"Division by zero\")\nsafeDivide x y = return (x / y)\n\nmain :: IO ()\nmain = do\n    putStrLn \"Enter the numerator:\"\n    numInput <- getLine\n    putStrLn \"Enter the denominator:\"\n    denomInput <- getLine\n    let num = read numInput :: Double\n    let denom = read denomInput :: Double\n    result <- try (safeDivide num denom) :: IO (Either SomeException Double)\n    case result of\n        Left ex   -> putStrLn $ \"Caught exception: \" ++ show ex\n        Right val -> putStrLn $ \"Result: \" ++ show val\n```"
  },
  {
    "task": "Design a function to parse an integer from a string and manage invalid input exceptions.",
    "code": "```haskell\nimport Text.Read (readMaybe)\nimport Control.Exception\n\ndata ParseException = InvalidInputException String\n  deriving Show\n\ninstance Exception ParseException\n\nparseInteger :: String -> IO (Either ParseException Int)\nparseInteger input =\n  case readMaybe input of\n    Just n  -> return (Right n)\n    Nothing -> return (Left (InvalidInputException \"Invalid input: not a valid integer\"))\n```"
  },
  {
    "task": "Implement an API call and catch exceptions related to network errors or timeouts.",
    "code": "```haskell\n{-# LANGUAGE OverloadedStrings #-}\n\nimport Network.HTTP.Client\nimport Network.HTTP.Client.TLS (tlsManagerSettings)\nimport Control.Exception (SomeException, catch)\nimport Data.ByteString.Lazy.Char8 as L8\n\nmakeApiCall :: IO ()\nmakeApiCall = do\n    manager <- newManager tlsManagerSettings\n    request <- parseRequest \"https://api.example.com/data\"\n    \n    response <- (httpLbs request manager) `catch` handleHttpException\n    L8.putStrLn $ responseBody response\n\nhandleHttpException :: SomeException -> IO (Response L8.ByteString)\nhandleHttpException e = do\n    putStrLn $ \"Caught exception: \" ++ show e\n    return $ responseLBS status500 [] \"Request failed due to exception.\"\n```"
  },
  {
    "task": "Develop a program that opens a database connection and handles any connection failure exceptions.",
    "code": "```haskell\nimport Database.HDBC\nimport Database.HDBC.Sqlite3\nimport Control.Exception\n\nmain :: IO ()\nmain = handleSqlError $ do\n    conn <- connectSqlite3 \"example.db\"\n    putStrLn \"Database connection successful.\"\n    disconnect conn\n\nhandleSqlError :: IO () -> IO ()\nhandleSqlError action = catchSql action handler\n  where\n    handler :: SqlError -> IO ()\n    handler e = putStrLn $ \"Failed to connect to database: \" ++ show e\n```"
  },
  {
    "task": "Write a function that accesses an array by index and catches out-of-bounds exceptions.",
    "code": "```haskell\nimport Control.Exception\nimport Data.Array\n\naccessArray :: Array Int a -> Int -> IO (Either String a)\naccessArray arr index = try (evaluate (arr ! index)) >>= handleResult\n\nhandleResult :: Either SomeException a -> IO (Either String a)\nhandleResult (Left _)  = return $ Left \"Index out of bounds\"\nhandleResult (Right v) = return $ Right v\n```"
  },
  {
    "task": "Create a function that converts a string to a date object and manages format exceptions.",
    "code": "```haskell\nimport Data.Time (parseTimeM, defaultTimeLocale, Day)\nimport Control.Exception (try, SomeException)\n\nconvertStringToDate :: String -> IO (Either SomeException Day)\nconvertStringToDate dateString = try $ parseTimeM True defaultTimeLocale \"%Y-%m-%d\" dateString\n```"
  },
  {
    "task": "Design a program that writes data to a file and catches any file permission exceptions.",
    "code": "```haskell\nimport System.IO\nimport Control.Exception\n\nwriteToFile :: FilePath -> String -> IO ()\nwriteToFile path content = do\n    result <- try (writeFile path content) :: IO (Either IOError ())\n    case result of\n        Left ex  -> putStrLn $ \"Caught exception: \" ++ show ex\n        Right _  -> putStrLn \"Data written successfully.\"\n\nmain :: IO ()\nmain = do\n    let filePath = \"output.txt\"\n    let dataToWrite = \"Hello, Haskell!\"\n    writeToFile filePath dataToWrite\n```"
  },
  {
    "task": "Implement a module that retrieves data from a URL and handles malformed URL exceptions.",
    "code": "```haskell\nmodule URLRetriever (retrieveData) where\n\nimport Network.HTTP.Simple\nimport Control.Exception\nimport Network.HTTP.Client\nimport Network.URI\n\nretrieveData :: String -> IO (Either String String)\nretrieveData url = do\n    case parseURI url of\n        Nothing -> return $ Left \"Malformed URL\"\n        Just _  -> handle handler $ do\n            response <- httpLBS (parseRequest_ url)\n            return $ Right (show response)\n  where\n    handler :: HttpException -> IO (Either String String)\n    handler _ = return $ Left \"Failed to retrieve data\"\n```"
  },
  {
    "task": "Write a function to calculate the square root of a number and catch any negative input exceptions.",
    "code": "```haskell\nimport Control.Exception\n\ndata SqrtException = NegativeInputException deriving Show\n\ninstance Exception SqrtException\n\nsafeSqrt :: Double -> IO Double\nsafeSqrt x\n  | x < 0     = throwIO NegativeInputException\n  | otherwise = return (sqrt x)\n\nmain :: IO ()\nmain = do\n  putStrLn \"Enter a number to compute its square root:\"\n  input <- getLine\n  let number = read input :: Double\n  result <- try (safeSqrt number) :: IO (Either SqrtException Double)\n  case result of\n    Left ex  -> putStrLn $ \"Error: \" ++ show ex\n    Right val -> putStrLn $ \"The square root is: \" ++ show val\n```"
  },
  {
    "task": "Develop a program that sends an email and manages exceptions for invalid email addresses.",
    "code": "```haskell\nimport Network.Mail.SMTP\nimport Text.Email.Validate (isValid)\nimport Control.Exception\n\nsendEmail :: String -> IO ()\nsendEmail email = do\n    let from = Address Nothing \"sender@example.com\"\n    let to = [Address Nothing email]\n    let subject = \"Test Email\"\n    let body = plainTextPart \"This is a test email.\"\n    let mail = simpleMail from to [] [] subject [body]\n\n    if isValid (pack email)\n    then catch (sendMailWithLogin' \"smtp.example.com\" 587 \"username\" \"password\" mail) handleException\n    else putStrLn \"Invalid email address.\"\n\nhandleException :: SomeException -> IO ()\nhandleException ex = putStrLn $ \"An error occurred: \" ++ show ex\n\nmain :: IO ()\nmain = do\n    putStrLn \"Enter the recipient's email address:\"\n    email <- getLine\n    sendEmail email\n```"
  },
  {
    "task": "Create a calculator application that handles invalid operations gracefully.",
    "code": "```haskell\nimport Text.Read (readMaybe)\n\nmain :: IO ()\nmain = do\n    putStrLn \"Simple Calculator\"\n    putStrLn \"Enter first number:\"\n    input1 <- getLine\n    putStrLn \"Enter second number:\"\n    input2 <- getLine\n    putStrLn \"Enter operation (+, -, *, /):\"\n    operation <- getLine\n    let maybeResult = do\n            num1 <- readMaybe input1 :: Maybe Double\n            num2 <- readMaybe input2 :: Maybe Double\n            case operation of\n                \"+\" -> Just (num1 + num2)\n                \"-\" -> Just (num1 - num2)\n                \"*\" -> Just (num1 * num2)\n                \"/\" -> if num2 /= 0 then Just (num1 / num2) else Nothing\n                _   -> Nothing\n    case maybeResult of\n        Just result -> putStrLn (\"The result is: \" ++ show result)\n        Nothing -> putStrLn \"Invalid input or operation. Please try again.\"\n```"
  },
  {
    "task": "Design a function that tries to parse JSON data and catches parsing errors.",
    "code": "```haskell\n{-# LANGUAGE OverloadedStrings #-}\n\nimport Data.Aeson (decode, eitherDecode, Value)\nimport Data.ByteString.Lazy (ByteString)\nimport Control.Exception (catch, SomeException)\n\nparseJson :: ByteString -> IO (Either String Value)\nparseJson jsonData = catch tryParse handleError\n  where\n    tryParse = return $ eitherDecode jsonData\n    handleError :: SomeException -> IO (Either String Value)\n    handleError _ = return $ Left \"Parsing error occurred\"\n```"
  },
  {
    "task": "Implement a system that processes user input and handles any type conversion exceptions.",
    "code": "```haskell\nimport Control.Exception (catch, SomeException)\n\nmain :: IO ()\nmain = do\n    putStrLn \"Enter a number:\"\n    input <- getLine\n    handleConversion input\n\nhandleConversion :: String -> IO ()\nhandleConversion input = do\n    let result = (readMaybe input :: Maybe Int)\n    case result of\n        Just n  -> putStrLn $ \"You entered the number: \" ++ show n\n        Nothing -> putStrLn \"Error: Invalid number format\"\n    `catch` handler\n\nhandler :: SomeException -> IO ()\nhandler _ = putStrLn \"An unexpected error occurred\"\n\nreadMaybe :: Read a => String -> Maybe a\nreadMaybe s = case reads s of\n    [(val, \"\")] -> Just val\n    _           -> Nothing\n```"
  },
  {
    "task": "Write a function that fetches data from a database and manages exceptions for missing records.",
    "code": "```haskell\nimport Control.Exception\nimport Data.Maybe\n\ndata DatabaseError = RecordNotFound deriving (Show)\n\ninstance Exception DatabaseError\n\nfetchData :: Int -> IO (Maybe String)\nfetchData recordId = do\n    -- Simulate database fetch\n    if recordId == 1\n        then return (Just \"Record data\")\n        else return Nothing\n\nfetchDataWithExceptionHandling :: Int -> IO String\nfetchDataWithExceptionHandling recordId = do\n    result <- fetchData recordId\n    case result of\n        Just dataStr -> return dataStr\n        Nothing -> throwIO RecordNotFound\n\nmain :: IO ()\nmain = do\n    result <- try (fetchDataWithExceptionHandling 2) :: IO (Either DatabaseError String)\n    case result of\n        Left ex -> putStrLn $ \"Error: \" ++ show ex\n        Right dataStr -> putStrLn $ \"Fetched data: \" ++ dataStr\n```"
  },
  {
    "task": "Create a program that connects to a remote server and handles authentication failure exceptions.",
    "code": "```haskell\nimport Network.HTTP.Client\nimport Network.HTTP.Client.TLS\nimport Control.Exception\n\ndata AuthException = AuthFailed deriving (Show)\n\ninstance Exception AuthException\n\nconnectToServer :: IO ()\nconnectToServer = do\n    manager <- newManager tlsManagerSettings\n    request <- parseRequest \"https://example.com/login\"\n    let requestWithAuth = applyBasicAuth \"username\" \"wrong-password\" request\n    response <- httpLbs requestWithAuth manager\n    if responseStatus response == status401\n       then throwIO AuthFailed\n       else putStrLn \"Connected successfully\"\n\nmain :: IO ()\nmain = do\n    result <- try connectToServer\n    case result of\n        Left AuthFailed -> putStrLn \"Authentication failed.\"\n        Right _         -> return ()\n```"
  },
  {
    "task": "Develop a function to download a file from the internet and handle file not found exceptions.",
    "code": "```haskell\nimport Network.HTTP.Conduit (simpleHttp)\nimport Control.Exception (try, SomeException)\n\ndownloadFile :: String -> IO (Either String String)\ndownloadFile url = do\n    result <- try (simpleHttp url) :: IO (Either SomeException String)\n    case result of\n        Left _ -> return $ Left \"File not found or other error occurred.\"\n        Right content -> return $ Right content\n\nmain :: IO ()\nmain = do\n    let url = \"http://example.com/file.txt\"\n    result <- downloadFile url\n    case result of\n        Left errMsg -> putStrLn errMsg\n        Right content -> putStrLn \"File downloaded successfully.\"\n```"
  },
  {
    "task": "Design a program that attempts to connect to an API and handles rate limit exceptions.",
    "code": "```haskell\nimport Control.Exception\nimport Network.HTTP.Client\nimport Network.HTTP.Types.Status (statusCode)\n\ndata RateLimitException = RateLimitException deriving (Show)\n\ninstance Exception RateLimitException\n\nconnectToAPI :: IO ()\nconnectToAPI = do\n    manager <- newManager defaultManagerSettings\n    request <- parseRequest \"http://example.com/api\"\n    response <- httpLbs request manager\n    let code = statusCode (responseStatus response)\n    if code == 429\n        then throwIO RateLimitException\n        else putStrLn \"Connected successfully!\"\n\nmain :: IO ()\nmain = catch connectToAPI handler\n  where\n    handler :: RateLimitException -> IO ()\n    handler _ = putStrLn \"Rate limit exceeded, try again later.\"\n```"
  },
  {
    "task": "Write a function that reads from a configuration file and manages key not found exceptions.",
    "code": "```haskell\nimport System.IO (readFile)\nimport Control.Exception (catch, IOException)\n\nreadConfigFile :: FilePath -> IO ()\nreadConfigFile path = do\n    content <- catch (readFile path) handleReadError\n    putStrLn \"Enter a key to search in configuration:\"\n    key <- getLine\n    let keyValue = lookupKey key (lines content)\n    case keyValue of\n        Just value -> putStrLn $ \"Value: \" ++ value\n        Nothing -> putStrLn $ \"Key \" ++ key ++ \" not found.\"\n\nhandleReadError :: IOException -> IO String\nhandleReadError _ = return \"Error reading configuration file.\"\n\nlookupKey :: String -> [String] -> Maybe String\nlookupKey key = foldr (\\line acc -> if key `elem` words line then Just (unwords . tail $ words line) else acc) Nothing\n```"
  },
  {
    "task": "Create an application that processes a list of tasks and catches any task execution exceptions.",
    "code": "```haskell\nimport Control.Exception (SomeException, catch)\nimport Control.Monad (forM_)\n\n-- Type alias for a task\ntype Task = IO ()\n\n-- Example tasks\ntask1 :: Task\ntask1 = putStrLn \"Task 1 completed successfully.\"\n\ntask2 :: Task\ntask2 = error \"Task 2 failed.\"\n\ntask3 :: Task\ntask3 = putStrLn \"Task 3 completed successfully.\"\n\n-- Function to process tasks with exception handling\nprocessTasks :: [Task] -> IO ()\nprocessTasks tasks = forM_ tasks $ \\task -> \n    catch task handler\n  where\n    handler :: SomeException -> IO ()\n    handler e = putStrLn $ \"Caught exception: \" ++ show e\n\n-- Main function to execute tasks\nmain :: IO ()\nmain = processTasks [task1, task2, task3]\n```"
  },
  {
    "task": "Implement a program that performs batch processing and handles individual item processing exceptions.",
    "code": "```haskell\nimport Control.Exception\n\n-- Define a custom exception type\ndata ProcessingException = ProcessingException String deriving (Show)\n\ninstance Exception ProcessingException\n\n-- Function to process individual items\nprocessItem :: Int -> IO ()\nprocessItem item\n  | item < 0   = throwIO (ProcessingException $ \"Negative item: \" ++ show item)\n  | otherwise  = putStrLn $ \"Processed item: \" ++ show item\n\n-- Function to process a batch of items\nprocessBatch :: [Int] -> IO ()\nprocessBatch items = mapM_ handleItem items\n  where\n    handleItem item = catch (processItem item) handler\n    handler :: ProcessingException -> IO ()\n    handler (ProcessingException msg) = putStrLn $ \"Error: \" ++ msg\n\n-- Main function\nmain :: IO ()\nmain = do\n  let batch = [1, 2, -1, 3, -2, 4]\n  processBatch batch\n```"
  },
  {
    "task": "Develop a function that performs mathematical operations and catches arithmetic exceptions.",
    "code": "```haskell\nimport Control.Exception\n\n-- Define a function to safely perform division\nsafeDivide :: Double -> Double -> IO (Either SomeException Double)\nsafeDivide x y = try (evaluate (x / y))\n\n-- Perform a mathematical operation and handle exceptions\nperformOperation :: Double -> Double -> IO ()\nperformOperation x y = do\n    result <- safeDivide x y\n    case result of\n        Left ex  -> putStrLn $ \"Caught exception: \" ++ show ex\n        Right val -> putStrLn $ \"Result is: \" ++ show val\n\nmain :: IO ()\nmain = do\n    performOperation 10 2\n    performOperation 10 0\n```"
  },
  {
    "task": "Write a program that logs error messages when exceptions occur during data processing.",
    "code": "```haskell\nimport Control.Exception\nimport System.IO\n\nmain :: IO ()\nmain = do\n    result <- try processData :: IO (Either SomeException ())\n    case result of\n        Left ex  -> logError (show ex)\n        Right () -> putStrLn \"Data processed successfully\"\n\nprocessData :: IO ()\nprocessData = do\n    -- Simulate data processing\n    putStrLn \"Processing data...\"\n    -- Simulate an exception\n    throwIO (userError \"An error occurred during data processing\")\n\nlogError :: String -> IO ()\nlogError errorMsg = do\n    withFile \"error.log\" AppendMode $ \\h -> do\n        hPutStrLn h errorMsg\n```"
  },
  {
    "task": "Create a script that monitors system resources and handles exceptions when limits are exceeded.",
    "code": "```haskell\nimport Control.Exception (SomeException, handle)\nimport System.Process (readProcess)\nimport Text.Read (readMaybe)\n\nmain :: IO ()\nmain = handle resourceExceptionHandler $ do\n    cpuUsage <- getCPUUsage\n    ramUsage <- getRAMUsage\n    if cpuUsage > 80\n        then error \"CPU usage limit exceeded\"\n        else putStrLn $ \"CPU Usage: \" ++ show cpuUsage ++ \"%\"\n    if ramUsage > 80\n        then error \"RAM usage limit exceeded\"\n        else putStrLn $ \"RAM Usage: \" ++ show ramUsage ++ \"%\"\n\ngetCPUUsage :: IO Int\ngetCPUUsage = do\n    output <- readProcess \"sh\" [\"-c\", \"top -bn1 | grep 'Cpu(s)' | sed 's/.*, *\\\\([0-9.]*\\\\)%* id.*/\\\\1/' | awk '{print 100 - $1}'\"] \"\"\n    return $ parseUsage output\n\ngetRAMUsage :: IO Int\ngetRAMUsage = do\n    output <- readProcess \"sh\" [\"-c\", \"free | grep Mem | awk '{print $3/$2 * 100.0}'\"] \"\"\n    return $ parseUsage output\n\nparseUsage :: String -> Int\nparseUsage output = case readMaybe (takeWhile (/= '.') output) of\n    Just usage -> usage\n    Nothing -> 0\n\nresourceExceptionHandler :: SomeException -> IO ()\nresourceExceptionHandler ex = putStrLn $ \"Resource exception: \" ++ show ex\n```"
  },
  {
    "task": "Design a function that validates user input and manages any format exceptions.",
    "code": "```haskell\nimport Text.Read (readMaybe)\n\nvalidateInput :: String -> IO ()\nvalidateInput input = do\n    let maybeNumber = readMaybe input :: Maybe Int\n    case maybeNumber of\n        Just number -> putStrLn $ \"Valid number: \" ++ show number\n        Nothing -> putStrLn \"Input is not a valid number.\"\n\nmain :: IO ()\nmain = do\n    putStrLn \"Please enter a number:\"\n    input <- getLine\n    validateInput input\n```"
  },
  {
    "task": "Implement a service that interacts with third-party APIs and handles unexpected response exceptions.",
    "code": "```haskell\n{-# LANGUAGE OverloadedStrings #-}\n\nimport Control.Exception (try, SomeException)\nimport Network.HTTP.Conduit (simpleHttp)\nimport Data.ByteString.Lazy (ByteString)\n\n-- Function to fetch data from a third-party API\nfetchDataFromAPI :: String -> IO (Either SomeException ByteString)\nfetchDataFromAPI url = try $ simpleHttp url\n\n-- Main service function\nservice :: String -> IO ()\nservice url = do\n    result <- fetchDataFromAPI url\n    case result of\n        Left ex -> putStrLn $ \"An error occurred: \" ++ show ex\n        Right response -> putStrLn $ \"Successfully fetched data: \" ++ show response\n\n-- Example usage\nmain :: IO ()\nmain = service \"http://example.com/api\"\n```"
  },
  {
    "task": "Write a function that uploads files to a server and handles exceptions for unsupported file types.",
    "code": "```haskell\nimport Control.Exception\nimport System.IO.Error\n\ndata FileType = Supported | Unsupported deriving (Eq, Show)\n\nuploadFile :: FilePath -> IO ()\nuploadFile path = do\n    fileType <- getFileType path\n    case fileType of\n        Supported   -> putStrLn $ \"Uploading file: \" ++ path\n        Unsupported -> ioError $ userError \"Unsupported file type\"\n\ngetFileType :: FilePath -> IO FileType\ngetFileType path =\n    if isSupported path\n    then return Supported\n    else return Unsupported\n\nisSupported :: FilePath -> Bool\nisSupported path = any (`isSuffixOf` path) [\".txt\", \".jpg\", \".png\"]\n\nuploadWithExceptionHandling :: FilePath -> IO ()\nuploadWithExceptionHandling path = do\n    result <- try (uploadFile path) :: IO (Either IOError ())\n    case result of\n        Left ex  -> putStrLn $ \"Exception caught: \" ++ show ex\n        Right _  -> putStrLn $ \"File uploaded successfully: \" ++ path\n```"
  },
  {
    "task": "Create a program that simulates network traffic and manages packet loss exceptions.",
    "code": "```haskell\nimport Control.Exception\nimport System.Random\n\ndata NetworkException = PacketLoss deriving (Show)\n\ninstance Exception NetworkException\n\nsimulateTraffic :: IO ()\nsimulateTraffic = do\n    result <- try sendPacket :: IO (Either NetworkException ())\n    case result of\n        Left PacketLoss -> putStrLn \"Packet loss occurred. Retrying...\"\n        Right _         -> putStrLn \"Packet sent successfully.\"\n\nsendPacket :: IO ()\nsendPacket = do\n    packetLoss <- randomRIO (1, 10) :: IO Int\n    if packetLoss == 1\n        then throwIO PacketLoss\n        else return ()\n\nmain :: IO ()\nmain = simulateTraffic\n```"
  },
  {
    "task": "Develop a function that processes XML data and catches any structural exceptions.",
    "code": "```haskell\nimport Text.XML.Light\nimport Control.Exception\n\nprocessXML :: String -> IO (Maybe Element)\nprocessXML xmlData = handle handler $ do\n    let parsedXML = parseXMLDoc xmlData\n    return parsedXML\n  where\n    handler :: SomeException -> IO (Maybe Element)\n    handler _ = return Nothing\n```"
  },
  {
    "task": "Design a program that handles exceptions when accessing environment variables.",
    "code": "```haskell\nimport System.Environment (getEnv)\nimport Control.Exception (catch, IOException)\n\n-- Function to safely get an environment variable\nsafeGetEnv :: String -> IO (Either String String)\nsafeGetEnv var = (Right <$> getEnv var) `catch` handler\n  where\n    handler :: IOException -> IO (Either String String)\n    handler _ = return $ Left $ \"Environment variable \" ++ var ++ \" not found.\"\n\nmain :: IO ()\nmain = do\n    result <- safeGetEnv \"MY_ENV_VAR\"\n    case result of\n        Right value -> putStrLn $ \"Value: \" ++ value\n        Left err -> putStrLn err\n```"
  },
  {
    "task": "Write a function that calculates factorial and manages exceptions for negative input values.",
    "code": "```haskell\nimport Control.Exception\n\ndata FactorialException = NegativeInputException deriving (Show)\n\ninstance Exception FactorialException\n\nfactorial :: Integer -> IO Integer\nfactorial n\n  | n < 0     = throw NegativeInputException\n  | otherwise = return (product [1..n])\n\nmain :: IO ()\nmain = do\n  let input = -5\n  result <- try (factorial input) :: IO (Either FactorialException Integer)\n  case result of\n    Left _  -> putStrLn \"Error: Negative input is not allowed.\"\n    Right f -> putStrLn (\"Factorial is: \" ++ show f)\n```"
  },
  {
    "task": "Create a software tool that converts file formats and handles unsupported format exceptions.",
    "code": "```haskell\nimport System.IO\nimport Control.Exception\n\ndata FileFormat = TXT | CSV | JSON | UnsupportedFormat deriving (Eq, Show)\n\nconvertFile :: FilePath -> FilePath -> IO ()\nconvertFile inputFile outputFile = do\n    content <- readFile inputFile\n    let inputFormat = detectFormat inputFile\n    let outputFormat = detectFormat outputFile\n    handleUnsupportedFormat inputFormat outputFormat $ do\n        let convertedContent = convertContent inputFormat outputFormat content\n        writeFile outputFile convertedContent\n\ndetectFormat :: FilePath -> FileFormat\ndetectFormat path\n    | \".txt\" `isSuffixOf` path = TXT\n    | \".csv\" `isSuffixOf` path = CSV\n    | \".json\" `isSuffixOf` path = JSON\n    | otherwise = UnsupportedFormat\n\nconvertContent :: FileFormat -> FileFormat -> String -> String\nconvertContent TXT CSV content = \"Converted to CSV: \" ++ content\nconvertContent TXT JSON content = \"Converted to JSON: \" ++ content\nconvertContent CSV TXT content = \"Converted to TXT: \" ++ content\nconvertContent CSV JSON content = \"Converted to JSON: \" ++ content\nconvertContent JSON TXT content = \"Converted to TXT: \" ++ content\nconvertContent JSON CSV content = \"Converted to CSV: \" ++ content\nconvertContent _ _ content = content\n\nhandleUnsupportedFormat :: FileFormat -> FileFormat -> IO () -> IO ()\nhandleUnsupportedFormat inputFormat outputFormat action = \n    if inputFormat == UnsupportedFormat || outputFormat == UnsupportedFormat\n    then putStrLn \"Error: Unsupported file format.\"\n    else action\n\nmain :: IO ()\nmain = do\n    let inputFile = \"input.txt\"\n    let outputFile = \"output.csv\"\n    convertFile inputFile outputFile\n```"
  },
  {
    "task": "Implement a function that sends HTTP requests and catches exceptions for invalid response status codes.",
    "code": "```haskell\n{-# LANGUAGE OverloadedStrings #-}\n\nimport Network.HTTP.Client\nimport Network.HTTP.Client.TLS\nimport Network.HTTP.Types.Status (statusCode)\nimport Control.Exception (catch)\nimport Control.Monad.IO.Class (liftIO)\nimport Control.Monad.Catch (SomeException)\n\nsendHttpRequest :: String -> IO ()\nsendHttpRequest url = do\n    manager <- newManager tlsManagerSettings\n    request <- parseRequest url\n    response <- catch (httpLbs request manager) handleException\n    liftIO $ putStrLn $ \"Response Code: \" ++ show (statusCode $ responseStatus response)\n\nhandleException :: SomeException -> IO (Response L.ByteString)\nhandleException e = do\n    putStrLn $ \"Caught exception: \" ++ show e\n    return $ responseLBS status500 [] \"Internal Server Error\"\n```"
  },
  {
    "task": "Develop a program that interacts with a message queue and handles message delivery exceptions.",
    "code": "```haskell\nimport Control.Exception\nimport Control.Concurrent\nimport Control.Concurrent.STM\nimport Control.Concurrent.STM.TQueue\n\ndata Message = Message String deriving Show\ndata DeliveryException = DeliveryFailed String deriving Show\n\ninstance Exception DeliveryException\n\nsendMessage :: TQueue Message -> Message -> IO ()\nsendMessage queue msg = atomically $ writeTQueue queue msg\n\nprocessMessage :: Message -> IO ()\nprocessMessage (Message content) = do\n    putStrLn $ \"Processing message: \" ++ content\n    if content == \"fail\"\n        then throwIO (DeliveryFailed \"Failed to deliver message\")\n        else putStrLn \"Message delivered successfully\"\n\nmain :: IO ()\nmain = do\n    queue <- atomically newTQueue\n    forkIO $ forever $ do\n        msg <- atomically $ readTQueue queue\n        catch (processMessage msg) handler\n    mapM_ (sendMessage queue . Message) [\"Hello\", \"World\", \"fail\", \"Haskell\"]\n    threadDelay 1000000\n  where\n    handler :: DeliveryException -> IO ()\n    handler (DeliveryFailed err) = putStrLn $ \"Exception caught: \" ++ err\n```"
  },
  {
    "task": "Write a function that reads user input and catches exceptions for unexpected data types.",
    "code": "```haskell\nimport Control.Exception\n\nmain :: IO ()\nmain = do\n  putStrLn \"Please enter a number:\"\n  input <- getLine\n  handle (handler input) $ do\n    let number = read input :: Int\n    putStrLn $ \"You entered the number: \" ++ show number\n\nhandler :: String -> SomeException -> IO ()\nhandler input _ = putStrLn $ \"Invalid input: \" ++ input ++ \". Please enter a valid number.\"\n```"
  },
  {
    "task": "Create a system that processes transactions and manages exceptions for insufficient funds.",
    "code": "```haskell\nimport Control.Exception\n\ndata TransactionError = InsufficientFunds deriving Show\n\ninstance Exception TransactionError\n\ntype Account = Double\n\nprocessTransaction :: Account -> Double -> IO Account\nprocessTransaction balance amount = do\n    if balance < amount\n        then throwIO InsufficientFunds\n        else return (balance - amount)\n\nmain :: IO ()\nmain = do\n    let initialBalance = 100.0\n    putStrLn \"Attempting to process transaction of 150.0\"\n    result <- try (processTransaction initialBalance 150.0) :: IO (Either TransactionError Account)\n    case result of\n        Left err -> putStrLn $ \"Transaction failed: \" ++ show err\n        Right newBalance -> putStrLn $ \"Transaction succeeded. New balance: \" ++ show newBalance\n```"
  },
  {
    "task": "Design a function that generates random numbers and handles exceptions when the range is invalid.",
    "code": "```haskell\nimport System.Random (randomRIO)\nimport Control.Exception (catch, SomeException)\n\ngenerateRandomNumber :: Int -> Int -> IO (Either String Int)\ngenerateRandomNumber minVal maxVal = catch (do\n    if minVal > maxVal then\n        return $ Left \"Invalid range: minVal is greater than maxVal\"\n    else do\n        num <- randomRIO (minVal, maxVal)\n        return $ Right num\n    ) handler\n  where\n    handler :: SomeException -> IO (Either String Int)\n    handler _ = return $ Left \"An exception occurred during random number generation\"\n```"
  },
  {
    "task": "Implement a program that performs image processing and catches exceptions for unsupported file dimensions.",
    "code": "```haskell\nimport Control.Exception\nimport Data.Typeable\n\ndata UnsupportedDimensionException = UnsupportedDimensionException String\n  deriving (Show, Typeable)\n\ninstance Exception UnsupportedDimensionException\n\nprocessImage :: (Int, Int) -> IO ()\nprocessImage (width, height)\n  | width > 4000 || height > 4000 = throwIO (UnsupportedDimensionException \"Unsupported file dimensions\")\n  | otherwise = putStrLn \"Processing Image...\"\n\nmain :: IO ()\nmain = do\n  let dimensions = (5000, 3000) -- Example dimensions\n  result <- try (processImage dimensions) :: IO (Either UnsupportedDimensionException ())\n  case result of\n    Left ex -> putStrLn $ \"Caught exception: \" ++ show ex\n    Right _ -> putStrLn \"Image processed successfully\"\n```"
  },
  {
    "task": "Write a function that manipulates strings and manages exceptions for invalid operations.",
    "code": "```haskell\nimport Control.Exception\n\ndata StringManipulationError = InvalidOperation String deriving (Show)\n\ninstance Exception StringManipulationError\n\nmanipulateString :: String -> IO String\nmanipulateString str = do\n  result <- try (evaluate (performOperation str)) :: IO (Either SomeException String)\n  case result of\n    Left ex -> return $ \"Caught exception: \" ++ show ex\n    Right val -> return val\n\nperformOperation :: String -> String\nperformOperation str\n  | null str = throw (InvalidOperation \"Cannot perform operation on an empty string\")\n  | otherwise = reverse str\n```"
  },
  {
    "task": "Create a script that automates tasks and handles exceptions for missing dependencies.",
    "code": "```haskell\nimport Control.Exception\nimport System.Process\nimport System.Exit\n\ncheckDependency :: String -> IO ()\ncheckDependency dep = do\n  result <- try (readProcess \"command\" [\"-v\", dep] \"\") :: IO (Either SomeException String)\n  case result of\n    Left _  -> putStrLn $ \"Dependency missing: \" ++ dep\n    Right _ -> putStrLn $ \"Dependency found: \" ++ dep\n\nmain :: IO ()\nmain = do\n  let dependencies = [\"git\", \"curl\", \"make\"]\n  mapM_ checkDependency dependencies\n```"
  },
  {
    "task": "Develop a function that accesses nested data structures and manages key access exceptions.",
    "code": "```haskell\nimport Control.Exception\nimport Data.Maybe (fromMaybe)\nimport qualified Data.Map as Map\n\ntype NestedData = Map.Map String (Map.Map String String)\n\naccessNestedData :: NestedData -> String -> String -> IO (Maybe String)\naccessNestedData nestedData outerKey innerKey = do\n    try (evaluate (Map.lookup outerKey nestedData)) >>= \\case\n        Left (SomeException _) -> return Nothing\n        Right outerMap -> return $ do\n            innerMap <- outerMap\n            Map.lookup innerKey innerMap\n\nmain :: IO ()\nmain = do\n    let nestedData = Map.fromList [(\"outer\", Map.fromList [(\"inner\", \"value\")])]\n    result <- accessNestedData nestedData \"outer\" \"inner\"\n    putStrLn $ \"Result: \" ++ fromMaybe \"Key not found\" result\n```"
  },
  {
    "task": "Design a program that synchronizes data between sources and handles data mismatch exceptions.",
    "code": "```haskell\nimport Control.Exception\n\n-- Define a custom exception for data mismatch\ndata DataMismatchException = DataMismatchException String deriving (Show)\n\ninstance Exception DataMismatchException\n\n-- Function to simulate data synchronization\nsynchronizeData :: String -> String -> IO ()\nsynchronizeData sourceData targetData = do\n    if sourceData == targetData\n        then putStrLn \"Data synchronized successfully.\"\n        else throwIO (DataMismatchException \"Data mismatch detected during synchronization.\")\n\n-- Main function to handle exceptions\nmain :: IO ()\nmain = do\n    let sourceData = \"source_data\"\n    let targetData = \"target_data\"\n    result <- try (synchronizeData sourceData targetData) :: IO (Either DataMismatchException ())\n    case result of\n        Left ex  -> putStrLn $ \"Caught exception: \" ++ show ex\n        Right _  -> putStrLn \"Process completed without exceptions.\"\n```"
  },
  {
    "task": "Write a function that interacts with hardware devices and handles connection failure exceptions.",
    "code": "```haskell\nimport Control.Exception (Exception, catch, throwIO)\nimport Data.Typeable (Typeable)\n\ndata ConnectionException = ConnectionFailure deriving (Show, Typeable)\n\ninstance Exception ConnectionException\n\nconnectToDevice :: IO ()\nconnectToDevice = do\n    putStrLn \"Attempting to connect to the device...\"\n    -- Simulate a connection failure\n    throwIO ConnectionFailure\n\nhandleDeviceConnection :: IO ()\nhandleDeviceConnection = catch connectToDevice handleFailure\n  where\n    handleFailure :: ConnectionException -> IO ()\n    handleFailure ConnectionFailure = putStrLn \"Failed to connect to the device. Please check the connection and try again.\"\n\nmain :: IO ()\nmain = handleDeviceConnection\n```"
  },
  {
    "task": "Create a tool that compresses files and manages exceptions for unsupported compression formats.",
    "code": "```haskell\nimport System.IO\nimport System.Environment\nimport Control.Exception\nimport Codec.Compression.GZip\nimport qualified Data.ByteString.Lazy as BL\n\ndata UnsupportedFormat = UnsupportedFormat deriving (Show)\n\ninstance Exception UnsupportedFormat\n\ncompressFile :: FilePath -> IO ()\ncompressFile filePath = do\n    contents <- BL.readFile filePath\n    BL.writeFile (filePath ++ \".gz\") (compress contents)\n\nhandleUnsupported :: SomeException -> IO ()\nhandleUnsupported e = putStrLn $ \"Error: \" ++ show e\n\nmain :: IO ()\nmain = do\n    args <- getArgs\n    let filePath = if null args then error \"No file provided\" else head args\n    catch (compressFile filePath) handleUnsupported\n```"
  },
  {
    "task": "Implement a function that parses command-line arguments and handles missing argument exceptions.",
    "code": "```haskell\nimport System.Environment (getArgs)\nimport Control.Exception (catch, IOException)\n\nmain :: IO ()\nmain = do\n    args <- catch getArgs handleException\n    case args of\n        [arg] -> putStrLn $ \"Argument received: \" ++ arg\n        _     -> putStrLn \"Error: Exactly one argument is required.\"\n\nhandleException :: IOException -> IO [String]\nhandleException _ = do\n    putStrLn \"Error: Failed to get command-line arguments.\"\n    return []\n```"
  },
  {
    "task": "Develop a program that simulates user interactions and manages timing exceptions.",
    "code": "```haskell\nimport Control.Exception\nimport Control.Concurrent\nimport System.Timeout\n\n-- Simulate user interactions\nuserInteraction :: IO ()\nuserInteraction = do\n    putStrLn \"Simulating user interaction...\"\n    threadDelay 2000000  -- simulate a delay of 2 seconds\n    putStrLn \"User interaction completed.\"\n\n-- Manage timing exceptions\nhandleTimeout :: IO () -> Int -> IO ()\nhandleTimeout action timeLimit = do\n    result <- timeout timeLimit action\n    case result of\n        Nothing -> putStrLn \"Operation timed out.\"\n        Just _  -> return ()\n\nmain :: IO ()\nmain = do\n    putStrLn \"Starting program...\"\n    handle (\\(SomeException e) -> putStrLn $ \"An error occurred: \" ++ show e) $\n        handleTimeout userInteraction 1000000  -- set timeout to 1 second\n    putStrLn \"Program finished.\"\n```"
  },
  {
    "task": "Write a function that encrypts data and handles exceptions for unsupported encryption algorithms.",
    "code": "```haskell\nimport Control.Exception\nimport Data.Typeable\n\ndata EncryptionError = UnsupportedAlgorithmError String deriving (Show, Typeable)\n\ninstance Exception EncryptionError\n\nencryptData :: String -> String -> IO (Either EncryptionError String)\nencryptData algorithm dataToEncrypt = try $ evaluate $ encrypt algorithm dataToEncrypt\n\nencrypt :: String -> String -> String\nencrypt \"AES\" dataToEncrypt = \"encryptedWithAES:\" ++ dataToEncrypt\nencrypt \"DES\" dataToEncrypt = \"encryptedWithDES:\" ++ dataToEncrypt\nencrypt algorithm _ = throw $ UnsupportedAlgorithmError $ \"Algorithm \" ++ algorithm ++ \" is not supported\"\n```"
  },
  {
    "task": "Create a system that aggregates data and manages exceptions for data inconsistency.",
    "code": "```haskell\nimport Control.Exception\nimport Data.Maybe (fromMaybe)\n\n-- Define a custom exception for data inconsistency\ndata DataInconsistencyException = DataInconsistencyException String\n  deriving (Show)\n\ninstance Exception DataInconsistencyException\n\n-- Function to aggregate data\naggregateData :: [Maybe Int] -> IO Int\naggregateData dataPoints = do\n  let aggregatedValue = sum $ map (fromMaybe 0) dataPoints\n  if any (== Nothing) dataPoints\n     then throwIO $ DataInconsistencyException \"Data inconsistency detected: Some data points are missing.\"\n     else return aggregatedValue\n\n-- Example usage\nmain :: IO ()\nmain = do\n  let dataPoints = [Just 10, Just 20, Nothing, Just 30]\n  result <- try (aggregateData dataPoints) :: IO (Either DataInconsistencyException Int)\n  case result of\n    Left ex  -> putStrLn $ \"Exception caught: \" ++ show ex\n    Right val -> putStrLn $ \"Aggregated value: \" ++ show val\n```"
  },
  {
    "task": "Design a program that processes real-time data streams and handles connection drop exceptions.",
    "code": "```haskell\nimport Control.Exception (SomeException, catch)\nimport Control.Concurrent (threadDelay)\nimport System.IO (hFlush, stdout)\n\n-- Simulate data stream processing\nprocessDataStream :: IO ()\nprocessDataStream = do\n    putStrLn \"Processing data stream...\"\n    hFlush stdout\n    -- Simulate a possible exception\n    threadDelay 1000000\n    error \"Connection dropped\"\n\n-- Main function with exception handling\nmain :: IO ()\nmain = do\n    putStrLn \"Starting data stream processing...\"\n    handleStream\n\nhandleStream :: IO ()\nhandleStream = processDataStream `catch` handleException\n\nhandleException :: SomeException -> IO ()\nhandleException e = do\n    putStrLn $ \"Exception occurred: \" ++ show e\n    putStrLn \"Retrying...\"\n    handleStream\n```"
  },
  {
    "task": "Implement a function that performs scientific calculations and manages precision exceptions.",
    "code": "```haskell\nimport Control.Exception\nimport System.IO.Error\n\ndata PrecisionException = PrecisionException String deriving (Show)\n\ninstance Exception PrecisionException\n\nperformCalculation :: Double -> IO Double\nperformCalculation x = do\n    result <- try (evaluate (scientificCalculation x)) :: IO (Either SomeException Double)\n    case result of\n        Left ex -> if isPrecisionError ex\n                   then throwIO (PrecisionException \"Precision error occurred during calculation.\")\n                   else throwIO ex\n        Right val -> return val\n\nscientificCalculation :: Double -> Double\nscientificCalculation x\n    | x < 1e-10 = error \"Precision error: input too small.\"\n    | otherwise = sqrt x * log x\n\nisPrecisionError :: SomeException -> Bool\nisPrecisionError ex = case fromException ex of\n    Just (ErrorCall msg) -> \"Precision error\" `elem` words msg\n    _ -> False\n```"
  },
  {
    "task": "Write a script that generates reports and handles exceptions for missing data sources.",
    "code": "```haskell\nimport Control.Exception (catch, IOException)\nimport System.IO (readFile)\nimport System.Directory (doesFileExist)\n\nmain :: IO ()\nmain = do\n    let dataSource = \"report_data.txt\"\n    exists <- doesFileExist dataSource\n    if not exists\n        then putStrLn \"Error: Data source is missing.\"\n        else generateReport dataSource `catch` handleIOException\n\ngenerateReport :: FilePath -> IO ()\ngenerateReport filePath = do\n    content <- readFile filePath\n    putStrLn \"Report Generated:\"\n    putStrLn content\n\nhandleIOException :: IOException -> IO ()\nhandleIOException _ = putStrLn \"Error: Unable to read the data source.\"\n```"
  },
  {
    "task": "Create a program that validates digital certificates and manages trust exceptions.",
    "code": "```haskell\nimport Control.Exception\nimport Data.List (isSuffixOf)\n\ndata Certificate = Certificate { certName :: String, isValid :: Bool } deriving (Show)\n\ndata CertificateException = InvalidCertificateException String | TrustException String deriving (Show)\n\ninstance Exception CertificateException\n\nvalidateCertificate :: Certificate -> IO ()\nvalidateCertificate (Certificate name valid) = do\n    if not valid\n        then throwIO (InvalidCertificateException $ \"Certificate \" ++ name ++ \" is invalid.\")\n        else putStrLn $ \"Certificate \" ++ name ++ \" is valid.\"\n\nmanageTrustExceptions :: [Certificate] -> IO ()\nmanageTrustExceptions certs = do\n    mapM_ handleCertificate certs\n  where\n    handleCertificate cert = catch (validateCertificate cert) handleException\n    \n    handleException :: CertificateException -> IO ()\n    handleException (InvalidCertificateException msg) = putStrLn msg\n    handleException (TrustException msg) = putStrLn $ \"Trust issue: \" ++ msg\n\nmain :: IO ()\nmain = do\n    let certificates = [Certificate \"cert1.pem\" True, Certificate \"cert2.pem\" False, Certificate \"cert3.pem\" True]\n    manageTrustExceptions certificates\n```"
  },
  {
    "task": "Develop a function that schedules tasks and handles exceptions for scheduling conflicts.",
    "code": "```haskell\nimport Control.Exception\nimport Data.Maybe (isNothing)\nimport qualified Data.Map as Map\n\ndata ScheduleError = ConflictError String deriving Show\n\ninstance Exception ScheduleError\n\ntype TimeSlot = (Int, Int) -- (start, end)\ntype Task = String\ntype Schedule = Map.Map TimeSlot Task\n\naddTask :: TimeSlot -> Task -> Schedule -> IO Schedule\naddTask timeSlot task schedule = do\n    let conflicting = Map.keys $ Map.filterWithKey (\\k _ -> overlaps k timeSlot) schedule\n    if null conflicting\n        then return $ Map.insert timeSlot task schedule\n        else throwIO $ ConflictError (\"Task conflict with existing task(s) at: \" ++ show conflicting)\n\noverlaps :: TimeSlot -> TimeSlot -> Bool\noverlaps (start1, end1) (start2, end2) =\n    not (end1 <= start2 || end2 <= start1)\n\nmain :: IO ()\nmain = do\n    let initialSchedule = Map.empty :: Schedule\n    result <- try (addTask (9, 11) \"Task 1\" initialSchedule) :: IO (Either ScheduleError Schedule)\n    case result of\n        Left err -> putStrLn $ \"Error: \" ++ show err\n        Right schedule -> do\n            putStrLn \"Task 1 scheduled successfully.\"\n            result2 <- try (addTask (10, 12) \"Task 2\" schedule) :: IO (Either ScheduleError Schedule)\n            case result2 of\n                Left err -> putStrLn $ \"Error: \" ++ show err\n                Right updatedSchedule -> putStrLn \"Task 2 scheduled successfully.\"\n```"
  },
  {
    "task": "Design a system that manages user sessions and handles session timeout exceptions.",
    "code": "```haskell\nimport Control.Exception\nimport Data.Time\nimport qualified Data.Map as Map\nimport System.IO.Unsafe (unsafePerformIO)\n\ndata Session = Session { userId :: String, lastActivity :: UTCTime }\ntype SessionId = String\ntype SessionStore = Map.Map SessionId Session\n\ndata SessionTimeoutException = SessionTimeoutException String deriving Show\n\ninstance Exception SessionTimeoutException\n\nsessionStore :: IORef SessionStore\nsessionStore = unsafePerformIO $ newIORef Map.empty\n\nstartSession :: String -> IO SessionId\nstartSession userId = do\n    currentTime <- getCurrentTime\n    let session = Session userId currentTime\n    sessionId <- generateSessionId\n    atomicModifyIORef' sessionStore (\\store -> (Map.insert sessionId session store, ()))\n    return sessionId\n\ncheckSessionTimeout :: SessionId -> IO ()\ncheckSessionTimeout sessionId = do\n    store <- readIORef sessionStore\n    case Map.lookup sessionId store of\n        Nothing -> throwIO $ SessionTimeoutException \"Session not found\"\n        Just session -> do\n            currentTime <- getCurrentTime\n            let diff = diffUTCTime currentTime (lastActivity session)\n            if diff > timeoutPeriod\n                then throwIO $ SessionTimeoutException \"Session timeout\"\n                else return ()\n\nupdateSessionActivity :: SessionId -> IO ()\nupdateSessionActivity sessionId = do\n    currentTime <- getCurrentTime\n    atomicModifyIORef' sessionStore (\\store -> (Map.adjust (\\s -> s { lastActivity = currentTime }) sessionId store, ()))\n\ntimeoutPeriod :: NominalDiffTime\ntimeoutPeriod = 30 * 60 -- 30 minutes\n\ngenerateSessionId :: IO SessionId\ngenerateSessionId = do\n    uuid <- randomIO :: IO UUID\n    return $ toString uuid\n```"
  },
  {
    "task": "Write a function that processes audio files and manages exceptions for unsupported audio formats.",
    "code": "```haskell\nimport Control.Exception\nimport System.IO.Error\n\ndata AudioFormat = MP3 | WAV | Unsupported deriving (Eq, Show)\n\nprocessAudioFile :: FilePath -> IO ()\nprocessAudioFile file = handle handler $ do\n    format <- determineAudioFormat file\n    if format == Unsupported\n        then throwIO (userError \"Unsupported audio format\")\n        else putStrLn (\"Processing \" ++ show format ++ \" file: \" ++ file)\n  where\n    handler :: IOError -> IO ()\n    handler e\n      | isUserError e = putStrLn $ \"Error: \" ++ ioeGetErrorString e\n      | otherwise     = ioError e\n\ndetermineAudioFormat :: FilePath -> IO AudioFormat\ndetermineAudioFormat file\n    | fileExtension == \".mp3\" = return MP3\n    | fileExtension == \".wav\" = return WAV\n    | otherwise               = return Unsupported\n  where\n    fileExtension = reverse . takeWhile (/= '.') . reverse $ file\n```"
  },
  {
    "task": "Create a service that sends notifications and handles exceptions for unreachable destinations.",
    "code": "```haskell\nimport Control.Exception\nimport System.IO.Error\n\ndata NotificationError = DestinationUnreachable String deriving (Show)\n\ninstance Exception NotificationError\n\nsendNotification :: String -> IO ()\nsendNotification destination = do\n    if destination == \"unreachable\"\n        then throwIO $ DestinationUnreachable \"Destination is unreachable\"\n        else putStrLn $ \"Notification sent to \" ++ destination\n\nsendNotificationWithHandler :: String -> IO ()\nsendNotificationWithHandler destination = do\n    result <- try (sendNotification destination) :: IO (Either NotificationError ())\n    case result of\n        Left (DestinationUnreachable msg) -> putStrLn $ \"Error: \" ++ msg\n        Right _ -> return ()\n\nmain :: IO ()\nmain = do\n    sendNotificationWithHandler \"valid_destination\"\n    sendNotificationWithHandler \"unreachable\"\n```"
  },
  {
    "task": "Implement a program that performs data migration and manages data transformation exceptions.",
    "code": "```haskell\nimport Control.Exception\n\n-- Custom exception for data transformation errors\ndata TransformationException = TransformationException String deriving (Show)\n\ninstance Exception TransformationException\n\n-- Function to simulate data transformation\ntransformData :: String -> IO String\ntransformData input = do\n  if input == \"bad data\"\n    then throwIO $ TransformationException \"Data transformation failed\"\n    else return $ \"Transformed: \" ++ input\n\n-- Function to perform data migration\nperformMigration :: [String] -> IO ()\nperformMigration [] = return ()\nperformMigration (x:xs) = do\n  result <- try (transformData x) :: IO (Either TransformationException String)\n  case result of\n    Left ex -> putStrLn $ \"Error: \" ++ show ex\n    Right transformed -> putStrLn transformed\n  performMigration xs\n\nmain :: IO ()\nmain = do\n  let dataToMigrate = [\"good data\", \"bad data\", \"another good data\"]\n  performMigration dataToMigrate\n```"
  },
  {
    "task": "Develop a function that processes video files and handles codec compatibility exceptions.",
    "code": "```haskell\nimport Control.Exception\n\ndata VideoFile = VideoFile FilePath\ndata CodecException = CodecException String deriving (Show)\n\ninstance Exception CodecException\n\nprocessVideoFile :: VideoFile -> IO ()\nprocessVideoFile (VideoFile path) = do\n    result <- try (checkCodecCompatibility path) :: IO (Either CodecException ())\n    case result of\n        Left ex  -> putStrLn $ \"Codec exception: \" ++ show ex\n        Right () -> putStrLn $ \"Processing video file: \" ++ path\n\ncheckCodecCompatibility :: FilePath -> IO ()\ncheckCodecCompatibility path = do\n    -- Simulate codec check; raise exception for unsupported codecs\n    let unsupported = path == \"unsupported.mp4\"\n    if unsupported\n        then throwIO $ CodecException \"Unsupported codec detected\"\n        else return ()\n```"
  },
  {
    "task": "Write a function that manages memory allocation and catches out-of-memory exceptions.",
    "code": "```haskell\nimport Control.Exception (catch, SomeException)\n\nallocateMemory :: IO ()\nallocateMemory = do\n    result <- catch allocate (handler \"Out of memory\")\n    putStrLn result\n  where\n    allocate :: IO String\n    allocate = do\n        -- Simulate memory allocation\n        let x = replicate (10^9) 'a' -- Adjust size for testing\n        return \"Memory allocated successfully\"\n\n    handler :: String -> SomeException -> IO String\n    handler msg _ = return msg\n```"
  },
  {
    "task": "Create a program that processes financial transactions and handles currency conversion exceptions.",
    "code": "```haskell\nimport Control.Exception\n\ndata Currency = USD | EUR | GBP deriving (Show, Read, Eq)\ndata Transaction = Transaction { amount :: Double, currency :: Currency } deriving Show\n\ndata ConversionException = UnsupportedCurrencyException String deriving Show\n\ninstance Exception ConversionException\n\nconvertCurrency :: Transaction -> Currency -> IO Transaction\nconvertCurrency (Transaction amt curr) targetCurrency\n  | curr == targetCurrency = return $ Transaction amt targetCurrency\n  | curr == USD && targetCurrency == EUR = return $ Transaction (amt * 0.85) EUR\n  | curr == USD && targetCurrency == GBP = return $ Transaction (amt * 0.75) GBP\n  | curr == EUR && targetCurrency == USD = return $ Transaction (amt * 1.18) USD\n  | curr == EUR && targetCurrency == GBP = return $ Transaction (amt * 0.88) GBP\n  | curr == GBP && targetCurrency == USD = return $ Transaction (amt * 1.33) USD\n  | curr == GBP && targetCurrency == EUR = return $ Transaction (amt * 1.14) EUR\n  | otherwise = throwIO $ UnsupportedCurrencyException (\"Unsupported currency conversion from \" ++ show curr ++ \" to \" ++ show targetCurrency)\n\nprocessTransaction :: Transaction -> Currency -> IO ()\nprocessTransaction trans targetCurrency = do\n  result <- try (convertCurrency trans targetCurrency) :: IO (Either ConversionException Transaction)\n  case result of\n    Left ex -> putStrLn $ \"Exception: \" ++ show ex\n    Right converted -> putStrLn $ \"Processed transaction: \" ++ show converted\n\nmain :: IO ()\nmain = do\n  let transaction = Transaction 100 USD\n  processTransaction transaction EUR\n  processTransaction transaction GBP\n  processTransaction transaction (read \"JPY\" :: Currency)  -- This will trigger an exception\n```"
  },
  {
    "task": "Design a function that interacts with cloud storage and manages access permission exceptions.",
    "code": "```haskell\nimport Control.Exception\nimport Network.CloudStorage -- hypothetical module\n\ndata CloudStorageException = PermissionDenied | OtherException String\n    deriving (Show)\n\ninstance Exception CloudStorageException\n\ninteractWithCloudStorage :: IO ()\ninteractWithCloudStorage = do\n    result <- try accessCloudStorage :: IO (Either SomeException ())\n    case result of\n        Left ex -> handleException ex\n        Right _ -> putStrLn \"Access to cloud storage successful.\"\n\naccessCloudStorage :: IO ()\naccessCloudStorage = do\n    -- Hypothetical cloud storage access code\n    putStrLn \"Attempting to access cloud storage...\"\n    -- Simulate a permission exception\n    throwIO PermissionDenied\n\nhandleException :: SomeException -> IO ()\nhandleException ex\n    | Just PermissionDenied <- fromException ex = putStrLn \"Access denied: insufficient permissions.\"\n    | otherwise = putStrLn $ \"An error occurred: \" ++ show ex\n\nmain :: IO ()\nmain = interactWithCloudStorage\n```"
  },
  {
    "task": "Implement a script that automates deployment and handles exceptions for missing configuration files.",
    "code": "```haskell\nimport System.IO\nimport Control.Exception\n\nmain :: IO ()\nmain = handle handler $ do\n    config <- readFile \"config.txt\"\n    putStrLn \"Deploying with configuration:\"\n    putStrLn config\n    -- Deployment logic goes here\n\nhandler :: IOError -> IO ()\nhandler e\n    | isDoesNotExistError e = putStrLn \"Error: Configuration file is missing.\"\n    | otherwise             = ioError e\n```"
  },
  {
    "task": "Write a function that normalizes data and handles exceptions for invalid data ranges.",
    "code": "```haskell\nimport Control.Exception\n\ndata NormalizationError = InvalidRangeError String deriving Show\n\ninstance Exception NormalizationError\n\nnormalizeData :: (Ord a, Fractional a, Show a) => a -> a -> a -> IO a\nnormalizeData minBound maxBound value = do\n    if minBound >= maxBound\n        then throwIO $ InvalidRangeError \"Minimum bound must be less than maximum bound.\"\n        else if value < minBound || value > maxBound\n            then throwIO $ InvalidRangeError (\"Value \" ++ show value ++ \" out of range.\")\n            else return $ (value - minBound) / (maxBound - minBound)\n```"
  },
  {
    "task": "Create a system that monitors application performance and handles threshold breach exceptions.",
    "code": "```haskell\nimport Control.Exception\nimport Data.IORef\nimport System.Random\n\ndata AppException = ThresholdBreachException String\n    deriving (Show)\n\ninstance Exception AppException\n\nmonitorPerformance :: IORef Int -> Int -> IO ()\nmonitorPerformance thresholdRef breachThreshold = do\n    currentPerformance <- randomRIO (0, 100) -- Simulate performance metric\n    threshold <- readIORef thresholdRef\n    if currentPerformance > breachThreshold\n        then throwIO (ThresholdBreachException \"Performance threshold breached!\")\n        else putStrLn $ \"Performance is within limits: \" ++ show currentPerformance\n    writeIORef thresholdRef currentPerformance\n\nhandleExceptions :: IO () -> IO ()\nhandleExceptions action = action `catch` handleThresholdBreach\n\nhandleThresholdBreach :: AppException -> IO ()\nhandleThresholdBreach (ThresholdBreachException msg) = putStrLn $ \"Exception: \" ++ msg\n\nmain :: IO ()\nmain = do\n    thresholdRef <- newIORef 0\n    let breachThreshold = 80\n    handleExceptions (monitorPerformance thresholdRef breachThreshold)\n```"
  },
  {
    "task": "Develop a program that processes social media data and manages API limit exceptions.",
    "code": "```haskell\nimport Control.Exception\nimport Network.HTTP.Conduit (simpleHttp)\nimport Data.ByteString.Lazy (ByteString)\nimport Control.Concurrent (threadDelay)\n\ndata APIException = APILimitReached | OtherAPIException String deriving (Show)\n\ninstance Exception APIException\n\nfetchSocialMediaData :: String -> IO ByteString\nfetchSocialMediaData url = do\n    response <- try $ simpleHttp url\n    case response of\n        Left e -> handleAPIException (show (e :: SomeException))\n        Right body -> return body\n\nhandleAPIException :: String -> IO ByteString\nhandleAPIException errorMsg\n    | \"API limit\" `elem` words errorMsg = throwIO APILimitReached\n    | otherwise = throwIO $ OtherAPIException errorMsg\n\nprocessData :: ByteString -> IO ()\nprocessData = putStrLn . show\n\nmain :: IO ()\nmain = do\n    let url = \"https://api.socialmedia.com/data\"\n    result <- try $ fetchSocialMediaData url\n    case result of\n        Left APILimitReached -> do\n            putStrLn \"API limit reached, retrying after delay...\"\n            threadDelay (60 * 1000000)  -- Wait for 60 seconds\n            main\n        Left (OtherAPIException msg) -> putStrLn $ \"Failed to fetch data: \" ++ msg\n        Right dataFetched -> processData dataFetched\n```"
  },
  {
    "task": "Design a function that integrates with payment gateways and handles payment failure exceptions.",
    "code": "```haskell\nimport Control.Exception\n\ndata PaymentException = PaymentFailure String\n    deriving (Show)\n\ninstance Exception PaymentException\n\n-- Dummy function to simulate a payment process with a payment gateway\nprocessPayment :: IO Bool\nprocessPayment = do\n    -- Simulating a failure scenario\n    return False\n\n-- Function to handle payment processing\nhandlePayment :: IO ()\nhandlePayment = do\n    result <- try processPayment\n    case result of\n        Left (e :: SomeException) -> putStrLn $ \"An error occurred: \" ++ show e\n        Right success ->\n            if success\n                then putStrLn \"Payment processed successfully.\"\n                else throwIO (PaymentFailure \"Payment failed due to insufficient funds or network issue.\")\n\nmain :: IO ()\nmain = do\n    handlePayment `catch` \\(PaymentFailure msg) -> putStrLn $ \"Payment failed: \" ++ msg\n```"
  },
  {
    "task": "Write a function that backs up data and handles exceptions for unavailable storage media.",
    "code": "```haskell\nimport Control.Exception\nimport System.IO.Error (isDoesNotExistError)\n\nbackupData :: IO ()\nbackupData = do\n    putStrLn \"Starting backup...\"\n    result <- try backupProcess\n    case result of\n        Left e -> if isDoesNotExistError e\n                  then putStrLn \"Backup failed: Storage media unavailable.\"\n                  else putStrLn $ \"Backup failed: \" ++ show e\n        Right _ -> putStrLn \"Backup completed successfully.\"\n\nbackupProcess :: IO ()\nbackupProcess = do\n    -- Simulating a backup process that might throw an exception\n    -- Replace the line below with actual backup logic\n    putStrLn \"Backing up data...\"\n    -- Simulating exception for demonstration\n    ioError (userError \"Simulated storage media unavailable error\")\n```"
  },
  {
    "task": "Create a tool that manages software updates and handles exceptions for version conflicts.",
    "code": "```haskell\nimport Control.Exception\nimport Data.List\n\ndata UpdateException = VersionConflict String\n    deriving (Show)\n\ninstance Exception UpdateException\n\ntype Version = String\ntype Software = String\ntype Update = (Software, Version)\n\nmanageUpdates :: [Update] -> IO ()\nmanageUpdates updates = mapM_ applyUpdate updates\n\napplyUpdate :: Update -> IO ()\napplyUpdate update@(software, version) = do\n    currentVersion <- getCurrentVersion software\n    if versionConflict currentVersion version\n        then throwIO (VersionConflict $ \"Conflict for \" ++ software)\n        else putStrLn $ \"Updated \" ++ software ++ \" to version \" ++ version\n\ngetCurrentVersion :: Software -> IO Version\ngetCurrentVersion software = return \"1.0.0\" -- Dummy implementation\n\nversionConflict :: Version -> Version -> Bool\nversionConflict current new = current == new\n```"
  },
  {
    "task": "Implement a program that performs sentiment analysis and manages exceptions for ambiguous texts.",
    "code": "```haskell\nimport Control.Exception\nimport Data.List\nimport System.IO.Error\n\ndata Sentiment = Positive | Negative | Neutral deriving (Show, Eq)\n\nanalyzeSentiment :: String -> Sentiment\nanalyzeSentiment text\n  | \"good\" `isInfixOf` text = Positive\n  | \"bad\" `isInfixOf` text = Negative\n  | otherwise = Neutral\n\nmain :: IO ()\nmain = do\n  putStrLn \"Enter text for sentiment analysis:\"\n  input <- getLine\n  result <- try (evaluate (analyzeSentiment input)) :: IO (Either SomeException Sentiment)\n  case result of\n    Left ex  -> putStrLn $ \"An error occurred: \" ++ show ex\n    Right sentiment -> putStrLn $ \"The sentiment is: \" ++ show sentiment\n```"
  },
  {
    "task": "Develop a function that manages user authentication and handles credential mismatch exceptions.",
    "code": "```haskell\nimport Control.Exception\n\ndata AuthException = CredentialMismatchException deriving Show\n\ninstance Exception AuthException\n\nauthenticateUser :: String -> String -> IO ()\nauthenticateUser username password = do\n    if username == \"admin\" && password == \"password123\"\n        then putStrLn \"Authentication successful.\"\n        else throwIO CredentialMismatchException\n\nmain :: IO ()\nmain = do\n    putStrLn \"Enter username:\"\n    username <- getLine\n    putStrLn \"Enter password:\"\n    password <- getLine\n    catch (authenticateUser username password) handler\n  where\n    handler :: AuthException -> IO ()\n    handler CredentialMismatchException = putStrLn \"Authentication failed: Credential mismatch.\"\n```"
  },
  {
    "task": "Write a program that processes geographic data and handles exceptions for invalid coordinates.",
    "code": "```haskell\nimport Control.Exception\n\ndata GeoException = InvalidCoordinates deriving (Show)\n\ninstance Exception GeoException\n\nprocessGeoData :: (Double, Double) -> IO ()\nprocessGeoData (lat, lon)\n  | lat < -90 || lat > 90 || lon < -180 || lon > 180 = throwIO InvalidCoordinates\n  | otherwise = putStrLn $ \"Processing coordinates: \" ++ show (lat, lon)\n\nmain :: IO ()\nmain = do\n    let coordinates = [(45.0, -73.0), (91.0, 50.0), (60.0, -200.0)]\n    mapM_ (\\coord -> catch (processGeoData coord)\n                           (\\InvalidCoordinates -> putStrLn \"Caught an invalid coordinate exception\")) coordinates\n```"
  },
  {
    "task": "Create a script that manages network configurations and handles exceptions for invalid syntax.",
    "code": "```haskell\nimport Control.Exception\nimport System.IO.Error\n\n-- Dummy function to simulate network configuration management\nmanageNetworkConfig :: String -> IO ()\nmanageNetworkConfig config = \n    if config == \"invalid\"\n        then ioError (userError \"Invalid syntax in network configuration.\")\n        else putStrLn \"Network configuration applied successfully.\"\n\n-- Exception handler\nhandleConfigException :: IOError -> IO ()\nhandleConfigException e\n    | isUserError e = putStrLn $ \"Error: \" ++ ioeGetErrorString e\n    | otherwise = ioError e\n\nmain :: IO ()\nmain = do\n    let config = \"invalid\"  -- Example configuration, replace with actual input\n    catch (manageNetworkConfig config) handleConfigException\n```"
  },
  {
    "task": "Design a function that processes biometric data and handles exceptions for sensor errors.",
    "code": "```haskell\nimport Control.Exception\n\ndata SensorError = SensorError String deriving Show\n\ninstance Exception SensorError\n\nprocessBiometricData :: IO ()\nprocessBiometricData = do\n    result <- try getBiometricData :: IO (Either SensorError String)\n    case result of\n        Left err -> putStrLn $ \"Error processing data: \" ++ show err\n        Right data -> putStrLn $ \"Biometric Data: \" ++ data\n\ngetBiometricData :: IO String\ngetBiometricData = do\n    -- Simulate a sensor error\n    throwIO (SensorError \"Sensor malfunction detected!\")\n```"
  },
  {
    "task": "Implement a system that manages access control and handles exceptions for unauthorized access attempts.",
    "code": "```haskell\nimport Control.Exception\nimport Data.Maybe (isNothing)\n\ndata AccessError = UnauthorizedAccess String deriving (Show)\n\ninstance Exception AccessError\n\ntype User = String\ntype Resource = String\n\ndata Permission = Read | Write deriving (Eq, Show)\n\ntype AccessControlList = [(User, [(Resource, [Permission])])]\n\ncheckAccess :: AccessControlList -> User -> Resource -> Permission -> IO ()\ncheckAccess acl user resource permission = do\n    let userPermissions = lookup user acl\n    if isNothing userPermissions || not (hasPermission (fromJust userPermissions))\n    then throwIO (UnauthorizedAccess $ \"User \" ++ user ++ \" is not authorized for \" ++ show permission ++ \" on \" ++ resource)\n    else putStrLn $ \"Access granted for \" ++ user ++ \" to \" ++ show permission ++ \" on \" ++ resource\n  where\n    hasPermission perms = case lookup resource perms of\n        Just perms' -> permission `elem` perms'\n        Nothing -> False\n\nmain :: IO ()\nmain = do\n    let acl = [(\"Alice\", [(\"File.txt\", [Read, Write])]), (\"Bob\", [(\"File.txt\", [Read])])]\n    result <- try (checkAccess acl \"Alice\" \"File.txt\" Write) :: IO (Either AccessError ())\n    case result of\n        Left err -> print err\n        Right _ -> return ()\n    result <- try (checkAccess acl \"Bob\" \"File.txt\" Write) :: IO (Either AccessError ())\n    case result of\n        Left err -> print err\n        Right _ -> return ()\n    result <- try (checkAccess acl \"Charlie\" \"File.txt\" Read) :: IO (Either AccessError ())\n    case result of\n        Left err -> print err\n        Right _ -> return ()\n```"
  },
  {
    "task": "Write a function that performs load balancing and handles exceptions for unreachable nodes.",
    "code": "```haskell\nimport Control.Exception\nimport Data.List\n\ndata Node = Node { nodeId :: Int, isReachable :: Bool }\n\nloadBalance :: [Node] -> IO ()\nloadBalance nodes = handle handler $ do\n    let reachableNodes = filter isReachable nodes\n    if null reachableNodes\n        then throwIO $ userError \"No reachable nodes\"\n        else putStrLn \"Load balancing among reachable nodes\"\n\nhandler :: SomeException -> IO ()\nhandler ex = putStrLn $ \"Exception caught: \" ++ show ex\n\nmain :: IO ()\nmain = loadBalance [Node 1 False, Node 2 False, Node 3 True]\n```"
  },
  {
    "task": "Create a program that simulates virtual environments and manages resource allocation exceptions.",
    "code": "```haskell\nimport Control.Exception\nimport System.Random\n\ndata Resource = CPU | Memory | Disk deriving (Show, Enum, Bounded)\n\ndata AllocationException = InsufficientResources deriving (Show)\n\ninstance Exception AllocationException\n\nallocateResource :: Resource -> IO ()\nallocateResource resource = do\n    randNum <- randomRIO (1, 10) :: IO Int\n    if randNum > 5\n        then putStrLn $ \"Allocated \" ++ show resource\n        else throwIO InsufficientResources\n\nsimulateEnvironment :: IO ()\nsimulateEnvironment = do\n    putStrLn \"Simulating virtual environment...\"\n    mapM_ (handleResource) [minBound .. maxBound]\n  where\n    handleResource resource = handle handler $ allocateResource resource\n    handler :: AllocationException -> IO ()\n    handler _ = putStrLn \"Resource allocation failed due to insufficient resources.\"\n\nmain :: IO ()\nmain = simulateEnvironment\n```"
  },
  {
    "task": "Develop a tool that manages digital rights and handles exceptions for unauthorized content access.",
    "code": "```haskell\nimport Control.Exception\n\ndata AccessError = UnauthorizedAccess deriving (Show)\n\ninstance Exception AccessError\n\ncheckAccess :: Bool -> IO ()\ncheckAccess hasAccess = do\n    if not hasAccess\n        then throwIO UnauthorizedAccess\n        else putStrLn \"Access granted!\"\n\nmanageDigitalRights :: Bool -> IO ()\nmanageDigitalRights hasAccess = do\n    result <- try (checkAccess hasAccess) :: IO (Either AccessError ())\n    case result of\n        Left ex -> putStrLn $ \"Exception caught: \" ++ show ex\n        Right _ -> return ()\n\nmain :: IO ()\nmain = do\n    manageDigitalRights False\n    manageDigitalRights True\n```"
  },
  {
    "task": "Design a function that synchronizes clocks and handles exceptions for time drift.",
    "code": "```haskell\nimport Control.Exception\nimport Data.Time.Clock\nimport System.IO.Error\n\ndata ClockSyncException = TimeDriftException String\n    deriving (Show)\n\ninstance Exception ClockSyncException\n\nsynchronizeClocks :: IO ()\nsynchronizeClocks = do\n    result <- try synchronize :: IO (Either IOException UTCTime)\n    case result of\n        Left ex -> throwIO $ TimeDriftException (\"Time drift detected: \" ++ show ex)\n        Right syncTime -> putStrLn $ \"Clocks synchronized at: \" ++ show syncTime\n\nsynchronize :: IO UTCTime\nsynchronize = do\n    currentTime <- getCurrentTime\n    -- Simulate a possible IO error for demonstration\n    if utctDayTime currentTime < 0 then ioError $ userError \"Time drift error\"\n    else return currentTime\n```"
  },
  {
    "task": "Write a script that manages system backups and handles exceptions for insufficient backup space.",
    "code": "```haskell\nimport System.IO.Error (catchIOError, ioError)\nimport System.IO (hPutStrLn, stderr)\n\n-- Function to simulate checking available backup space\ncheckBackupSpace :: IO Bool\ncheckBackupSpace = do\n    -- Simulate a check that may fail\n    return False\n\n-- Function to perform the backup\nperformBackup :: IO ()\nperformBackup = putStrLn \"Performing backup...\"\n\n-- Function to manage the backup process with exception handling\nmanageBackup :: IO ()\nmanageBackup = do\n    hasSpace <- catchIOError checkBackupSpace handler\n    if hasSpace\n        then performBackup\n        else hPutStrLn stderr \"Error: Insufficient backup space.\"\n\n-- Handler for IO errors\nhandler :: IOError -> IO Bool\nhandler e = do\n    hPutStrLn stderr (\"IO Error: \" ++ show e)\n    return False\n\n-- Main function to run the backup manager\nmain :: IO ()\nmain = manageBackup\n```"
  },
  {
    "task": "Create a program that processes natural language text and handles parsing exceptions.",
    "code": "```haskell\nimport Control.Exception (SomeException, catch)\nimport Data.Char (isSpace)\n\n-- Function to simulate text processing\nprocessText :: String -> Either String String\nprocessText text\n    | null text = Left \"Input text is empty.\"\n    | otherwise = Right $ \"Processed text: \" ++ filter (not . isSpace) text\n\n-- Main function to handle exceptions\nmain :: IO ()\nmain = do\n    let inputText = \"   This is a sample text with some spaces.  \"\n    result <- (evaluateText inputText) `catch` handleParseException\n    putStrLn result\n\n-- Evaluating the text processing\nevaluateText :: String -> IO String\nevaluateText text = do\n    case processText text of\n        Left errMsg -> return $ \"Error: \" ++ errMsg\n        Right processed -> return processed\n\n-- Exception handler\nhandleParseException :: SomeException -> IO String\nhandleParseException ex = return $ \"An exception occurred: \" ++ show ex\n```"
  },
  {
    "task": "Implement a function that manages thread execution and handles race condition exceptions.",
    "code": "```haskell\nimport Control.Concurrent\nimport Control.Exception\nimport Control.Concurrent.STM\nimport Control.Monad\n\n-- Define a function to simulate some work\nworker :: TVar Int -> IO ()\nworker sharedVar = atomically $ modifyTVar' sharedVar (+1)\n\n-- Function to manage thread execution with exception handling\nmanageThreads :: IO ()\nmanageThreads = do\n    sharedVar <- atomically $ newTVar 0\n    let numThreads = 10\n    threads <- replicateM numThreads $ forkIO $ handleThread sharedVar\n    mapM_ wait threads\n    finalValue <- atomically $ readTVar sharedVar\n    putStrLn $ \"Final value: \" ++ show finalValue\n\n-- Function to handle exceptions for a single thread\nhandleThread :: TVar Int -> IO ()\nhandleThread sharedVar = do\n    result <- try (worker sharedVar) :: IO (Either SomeException ())\n    case result of\n        Left ex   -> putStrLn $ \"Thread failed with exception: \" ++ show ex\n        Right _   -> return ()\n\n-- Function to wait for a thread to finish\nwait :: ThreadId -> IO ()\nwait tid = do\n    mvar <- newEmptyMVar\n    forkFinally (return ()) (\\_ -> putMVar mvar ())\n    takeMVar mvar\n\nmain :: IO ()\nmain = manageThreads\n```"
  },
  {
    "task": "Develop a system that integrates with IoT devices and handles connectivity exceptions.",
    "code": "```haskell\nimport Control.Exception\nimport Network.HTTP.Client\nimport Network.HTTP.Types.Status (statusCode)\n\ndata IoTDevice = IoTDevice\n  { deviceId :: String\n  , deviceEndpoint :: String\n  }\n\nconnectToDevice :: IoTDevice -> IO ()\nconnectToDevice device = do\n  manager <- newManager defaultManagerSettings\n  request <- parseRequest (deviceEndpoint device)\n  response <- httpLbs request manager\n  let code = statusCode (responseStatus response)\n  if code == 200\n    then putStrLn $ \"Successfully connected to device: \" ++ deviceId device\n    else putStrLn $ \"Failed to connect to device: \" ++ deviceId device\n\nhandleConnectivityException :: SomeException -> IO ()\nhandleConnectivityException e = putStrLn $ \"Connectivity exception occurred: \" ++ show e\n\nconnectWithHandling :: IoTDevice -> IO ()\nconnectWithHandling device = catch (connectToDevice device) handleConnectivityException\n\nmain :: IO ()\nmain = do\n  let devices = [IoTDevice \"device1\" \"http://device1.local/status\"\n                ,IoTDevice \"device2\" \"http://device2.local/status\"]\n  mapM_ connectWithHandling devices\n```"
  },
  {
    "task": "Write a function that manages application logging and handles exceptions for log overflow.",
    "code": "```haskell\nimport Control.Exception\nimport System.IO\nimport System.IO.Error\n\ndata LogException = LogOverflowException deriving (Show)\n\ninstance Exception LogException\n\nlogToFile :: FilePath -> String -> IO ()\nlogToFile filePath message = do\n    bracket (openFile filePath AppendMode) hClose $ \\handle -> do\n        hPutStrLn handle message\n\nhandleOverflow :: IOError -> IO ()\nhandleOverflow e\n    | isFullError e = throwIO LogOverflowException\n    | otherwise = ioError e\n\nwriteLog :: FilePath -> String -> IO ()\nwriteLog filePath message = do\n    catch (logToFile filePath message) handleOverflow\n    `catch` \\(LogOverflowException) -> putStrLn \"Log overflow occurred, unable to write log.\"\n\nmain :: IO ()\nmain = do\n    let filePath = \"application.log\"\n    writeLog filePath \"This is a log message.\"\n```"
  },
  {
    "task": "Create a tool that visualizes data and handles exceptions for unsupported visualization types.",
    "code": "```haskell\nimport Control.Exception\n\ndata VisualizationType = BarChart | LineGraph | PieChart deriving (Show, Eq)\n\ndata VisualizationException = UnsupportedVisualizationType String\n    deriving (Show)\n\ninstance Exception VisualizationException\n\nvisualizeData :: VisualizationType -> IO ()\nvisualizeData visType = case visType of\n    BarChart  -> putStrLn \"Visualizing Bar Chart\"\n    LineGraph -> putStrLn \"Visualizing Line Graph\"\n    PieChart  -> putStrLn \"Visualizing Pie Chart\"\n\nhandleException :: SomeException -> IO ()\nhandleException e = putStrLn $ \"Error: \" ++ show e\n\nmain :: IO ()\nmain = do\n    let visType = \"ScatterPlot\"  -- Simulating an unsupported type\n    result <- try (case visType of\n                    \"BarChart\"  -> visualizeData BarChart\n                    \"LineGraph\" -> visualizeData LineGraph\n                    \"PieChart\"  -> visualizeData PieChart\n                    _           -> throwIO $ UnsupportedVisualizationType visType) :: IO (Either SomeException ())\n    either handleException return result\n```"
  },
  {
    "task": "Design a program that performs genetic algorithm simulations and manages exception for invalid mutations.",
    "code": "```haskell\nimport Control.Exception\nimport System.Random\n\ndata GeneticAlgorithmException = InvalidMutationException\n  deriving (Show)\n\ninstance Exception GeneticAlgorithmException\n\ntype Genome = [Bool]\n\nmutate :: Genome -> IO Genome\nmutate genome = do\n  index <- randomRIO (0, length genome - 1)\n  return $ take index genome ++ [not (genome !! index)] ++ drop (index + 1) genome\n\nsimulate :: Genome -> IO Genome\nsimulate genome = do\n  mutatedGenome <- mutate genome\n  if isValidMutation mutatedGenome\n    then return mutatedGenome\n    else throwIO InvalidMutationException\n\nisValidMutation :: Genome -> Bool\nisValidMutation _ = True -- Replace with actual validation logic\n\nrunSimulation :: Genome -> IO ()\nrunSimulation genome = do\n  result <- try (simulate genome) :: IO (Either GeneticAlgorithmException Genome)\n  case result of\n    Left ex -> putStrLn $ \"Exception caught: \" ++ show ex\n    Right newGenome -> putStrLn $ \"New genome: \" ++ show newGenome\n\nmain :: IO ()\nmain = do\n  let initialGenome = [True, False, True, True]\n  runSimulation initialGenome\n```"
  },
  {
    "task": "Implement a function that manages distributed transactions and handles consistency exceptions.",
    "code": "```haskell\nimport Control.Exception\nimport Control.Concurrent\nimport Control.Monad\n\ndata TransactionError = ConsistencyException String deriving (Show)\n\ninstance Exception TransactionError\n\nperformDistributedTransaction :: IO ()\nperformDistributedTransaction = do\n    result <- try executeTransaction :: IO (Either TransactionError ())\n    case result of\n        Left e -> putStrLn $ \"Transaction failed: \" ++ show e\n        Right _ -> putStrLn \"Transaction succeeded\"\n\nexecuteTransaction :: IO ()\nexecuteTransaction = do\n    -- Simulating transaction steps\n    success <- simulateTransactionStep\n    unless success $ throwIO (ConsistencyException \"Consistency check failed\")\n\nsimulateTransactionStep :: IO Bool\nsimulateTransactionStep = do\n    -- Simulate a random failure\n    threadDelay 1000000\n    return False\n\nmain :: IO ()\nmain = performDistributedTransaction\n```"
  },
  {
    "task": "Write a function that handles secure communications and manages encryption key exceptions.",
    "code": "```haskell\nimport Control.Exception\nimport Data.Typeable\n\ndata SecureCommunicationException = MissingKey | InvalidKey\n    deriving (Show, Typeable)\n\ninstance Exception SecureCommunicationException\n\nhandleSecureCommunication :: Maybe String -> IO ()\nhandleSecureCommunication maybeKey = do\n    result <- try (secureCommunicate maybeKey) :: IO (Either SecureCommunicationException ())\n    case result of\n        Left MissingKey  -> putStrLn \"Error: Missing encryption key.\"\n        Left InvalidKey  -> putStrLn \"Error: Invalid encryption key.\"\n        Right _          -> putStrLn \"Secure communication successful.\"\n\nsecureCommunicate :: Maybe String -> IO ()\nsecureCommunicate (Just key) = do\n    if validKey key\n        then putStrLn \"Communicating securely...\"\n        else throwIO InvalidKey\nsecureCommunicate Nothing = throwIO MissingKey\n\nvalidKey :: String -> Bool\nvalidKey key = length key >= 10\n```"
  },
  {
    "task": "Create a system that processes sensor data and handles out-of-range value exceptions.",
    "code": "```haskell\nimport Control.Exception\n\ndata SensorException = OutOfRangeException String deriving Show\n\ninstance Exception SensorException\n\nprocessSensorData :: Double -> IO ()\nprocessSensorData value\n  | value < 0 || value > 100 = throwIO (OutOfRangeException \"Sensor value is out of range\")\n  | otherwise = putStrLn $ \"Processing sensor value: \" ++ show value\n\nmain :: IO ()\nmain = do\n  let sensorValues = [12.5, 150.0, 75.0, -5.0, 50.0]\n  mapM_ (\\v -> catch (processSensorData v) handler) sensorValues\n  where\n    handler :: SensorException -> IO ()\n    handler (OutOfRangeException msg) = putStrLn $ \"Error: \" ++ msg\n```"
  },
  {
    "task": "Develop a program that simulates weather patterns and handles model prediction exceptions.",
    "code": "```haskell\nimport Control.Exception\nimport System.Random\n\ndata WeatherCondition = Sunny | Rainy | Cloudy | Stormy deriving (Show, Enum, Bounded)\n\ninstance Random WeatherCondition where\n    random g = case randomR (fromEnum (minBound :: WeatherCondition), fromEnum (maxBound :: WeatherCondition)) g of\n        (r, g') -> (toEnum r, g')\n    randomR (a, b) g = case randomR (fromEnum a, fromEnum b) g of\n        (r, g') -> (toEnum r, g')\n\ndata PredictionException = InvalidPrediction deriving Show\n\ninstance Exception PredictionException\n\nsimulateWeather :: IO ()\nsimulateWeather = do\n    g <- newStdGen\n    let weather = take 10 $ randoms g :: [WeatherCondition]\n    handle handleException $ mapM_ predictWeather weather\n\npredictWeather :: WeatherCondition -> IO ()\npredictWeather condition = do\n    putStrLn $ \"Predicting weather: \" ++ show condition\n    case condition of\n        Stormy -> throwIO InvalidPrediction\n        _      -> putStrLn \"Prediction successful.\"\n\nhandleException :: PredictionException -> IO ()\nhandleException InvalidPrediction = putStrLn \"Exception: Unable to predict due to stormy conditions.\"\n\nmain :: IO ()\nmain = simulateWeather\n```"
  },
  {
    "task": "Design a function that manages API versioning and handles backward compatibility exceptions.",
    "code": "```haskell\nimport Control.Exception\n\ndata APIVersion = V1 | V2 | V3 deriving (Show, Eq)\n\ndata APIException = UnsupportedVersionException String\n  deriving (Show)\n\ninstance Exception APIException\n\ngetAPIHandler :: APIVersion -> IO ()\ngetAPIHandler version = do\n    let result = case version of\n            V1 -> Right \"Handler for API Version 1\"\n            V2 -> Right \"Handler for API Version 2\"\n            V3 -> Right \"Handler for API Version 3\"\n            _  -> Left $ UnsupportedVersionException \"Unsupported API version\"\n    either throwIO putStrLn result\n\nmanageAPIVersioning :: APIVersion -> IO ()\nmanageAPIVersioning version = do\n    catch (getAPIHandler version) handler\n  where\n    handler :: APIException -> IO ()\n    handler (UnsupportedVersionException msg) = putStrLn $ \"Error: \" ++ msg\n```"
  },
  {
    "task": "Write a tool that converts character encodings and handles unsupported encoding exceptions.",
    "code": "```haskell\nimport Control.Exception (catch, SomeException)\nimport Data.Text (Text)\nimport qualified Data.Text as T\nimport qualified Data.Text.Encoding as E\nimport qualified Data.ByteString as B\nimport System.IO (hPutStrLn, stderr)\n\nconvertEncoding :: B.ByteString -> Text -> Either String Text\nconvertEncoding input encoding = case encoding of\n    \"UTF-8\"    -> decode E.decodeUtf8\n    \"UTF-16LE\" -> decode E.decodeUtf16LE\n    \"UTF-16BE\" -> decode E.decodeUtf16BE\n    _          -> Left \"Unsupported encoding\"\n  where\n    decode f = either (Left . show) Right (f input)\n\nhandleException :: SomeException -> IO ()\nhandleException e = hPutStrLn stderr (\"Error: \" ++ show e)\n\nmain :: IO ()\nmain = do\n    let input = \"example text\" :: B.ByteString\n    let encoding = \"UTF-8\"\n    \n    let result = convertEncoding input encoding\n    case result of\n        Right text -> putStrLn $ \"Converted text: \" ++ T.unpack text\n        Left err   -> hPutStrLn stderr (\"Conversion error: \" ++ err)\n    `catch` handleException\n```"
  },
  {
    "task": "Create a program that handles dynamic content generation and manages template parsing exceptions.",
    "code": "```haskell\nimport Control.Exception\nimport System.IO\nimport Data.Maybe\n\ndata TemplateError = ParseException String deriving (Show)\n\ninstance Exception TemplateError\n\nparseTemplate :: String -> IO String\nparseTemplate content\n    | null content = throwIO $ ParseException \"Template content is empty\"\n    | otherwise = return content\n\ngenerateContent :: String -> IO String\ngenerateContent template = do\n    parsedTemplate <- parseTemplate template\n    return (\"Generated content based on: \" ++ parsedTemplate)\n\nhandleExceptions :: TemplateError -> IO ()\nhandleExceptions (ParseException msg) = putStrLn $ \"Error parsing template: \" ++ msg\n\nmain :: IO ()\nmain = do\n    let template = \"Hello, {{name}}!\"\n    result <- try (generateContent template) :: IO (Either TemplateError String)\n    case result of\n        Left err -> handleExceptions err\n        Right content -> putStrLn content\n```"
  },
  {
    "task": "Implement a script that schedules automated tests and handles exceptions for missing test cases.",
    "code": "```haskell\nimport Control.Exception (catch, SomeException)\nimport System.IO (hPutStrLn, stderr)\n\ndata TestCase = TestCase { testName :: String }\n\nscheduleTest :: TestCase -> IO ()\nscheduleTest testCase = putStrLn $ \"Scheduling test: \" ++ testName testCase\n\nmissingTestHandler :: SomeException -> IO ()\nmissingTestHandler e = hPutStrLn stderr $ \"Exception caught: \" ++ show e\n\nmain :: IO ()\nmain = do\n    let testCases = [Just (TestCase \"Test1\"), Nothing, Just (TestCase \"Test2\")]\n    mapM_ (handleTestCase . scheduleTest) testCases\n  where\n    handleTestCase testCaseAction = do\n        (catch (testCaseAction >>= maybe (error \"Missing test case\") return) missingTestHandler)\n```"
  },
  {
    "task": "Develop a system that manages virtual machine instances and handles provisioning exceptions.",
    "code": "```haskell\nimport Control.Exception\n\n-- Define a custom exception type\ndata VMException = ProvisioningError String deriving (Show)\n\ninstance Exception VMException\n\n-- Function to provision a virtual machine\nprovisionVM :: String -> IO ()\nprovisionVM vmName = do\n  putStrLn $ \"Provisioning VM: \" ++ vmName\n  if vmName == \"faultyVM\"\n    then throwIO (ProvisioningError \"Failed to provision VM due to resource constraints.\")\n    else putStrLn $ \"VM \" ++ vmName ++ \" provisioned successfully.\"\n\n-- Function to manage VM instances with exception handling\nmanageVMs :: [String] -> IO ()\nmanageVMs vmList = mapM_ handleVM vmList\n  where\n    handleVM vmName = catch (provisionVM vmName) handler\n\n    handler :: VMException -> IO ()\n    handler (ProvisioningError msg) = putStrLn $ \"Error provisioning VM: \" ++ msg\n\n-- Example usage\nmain :: IO ()\nmain = do\n  let vmList = [\"vm1\", \"vm2\", \"faultyVM\", \"vm3\"]\n  manageVMs vmList\n```"
  },
  {
    "task": "Write a function that processes credit scores and handles exceptions for missing credit history.",
    "code": "```haskell\nimport Control.Exception\nimport Data.Maybe (fromMaybe)\n\ndata CreditException = MissingCreditHistory deriving Show\n\ninstance Exception CreditException\n\nprocessCreditScore :: Maybe Int -> IO ()\nprocessCreditScore maybeScore = handle handler $ do\n    score <- evaluateCreditScore maybeScore\n    putStrLn $ \"Credit score processed: \" ++ show score\n\nevaluateCreditScore :: Maybe Int -> IO Int\nevaluateCreditScore maybeScore = case maybeScore of\n    Just score -> return score\n    Nothing -> throwIO MissingCreditHistory\n\nhandler :: CreditException -> IO ()\nhandler MissingCreditHistory = putStrLn \"Exception: Missing credit history.\"\n```"
  },
  {
    "task": "Create a tool that manages digital certificates and handles expiration exceptions.",
    "code": "```haskell\nimport Data.Time (UTCTime, getCurrentTime, diffUTCTime)\nimport Control.Exception (Exception, throwIO, catch)\n\ndata Certificate = Certificate {\n  certName :: String,\n  expirationDate :: UTCTime\n}\n\ndata CertificateException = CertificateExpired String\n  deriving Show\n\ninstance Exception CertificateException\n\ncheckCertificate :: Certificate -> IO ()\ncheckCertificate cert = do\n  currentTime <- getCurrentTime\n  if currentTime > expirationDate cert\n    then throwIO (CertificateExpired (certName cert))\n    else putStrLn $ \"Certificate \" ++ certName cert ++ \" is valid.\"\n\nmanageCertificates :: [Certificate] -> IO ()\nmanageCertificates certs = mapM_ handleCertificate certs\n  where\n    handleCertificate cert = catch (checkCertificate cert) handler\n    handler (CertificateExpired name) =\n      putStrLn $ \"Certificate expired: \" ++ name\n\nmain :: IO ()\nmain = do\n  -- Example certificates\n  let cert1 = Certificate \"Cert1\" (read \"2023-12-01 00:00:00 UTC\")\n  let cert2 = Certificate \"Cert2\" (read \"2021-01-01 00:00:00 UTC\")\n  manageCertificates [cert1, cert2]\n```"
  },
  {
    "task": "Design a program that processes genome sequences and handles exceptions for sequence alignment.",
    "code": "```haskell\nimport Control.Exception\n\ndata GenomeException = InvalidSequence String\n                     | AlignmentError String\n                     deriving (Show)\n\ninstance Exception GenomeException\n\nprocessGenomeSequence :: String -> IO ()\nprocessGenomeSequence sequence = do\n    result <- try (alignSequence sequence) :: IO (Either GenomeException String)\n    case result of\n        Left ex -> putStrLn $ \"An error occurred: \" ++ show ex\n        Right aligned -> putStrLn $ \"Aligned sequence: \" ++ aligned\n\nalignSequence :: String -> IO String\nalignSequence sequence\n    | not (isValidSequence sequence) = throwIO $ InvalidSequence \"Invalid genome sequence.\"\n    | otherwise = do\n        -- Simulate sequence alignment logic\n        if length sequence < 5\n            then throwIO $ AlignmentError \"Sequence too short for alignment.\"\n            else return $ \"Aligned_\" ++ sequence\n\nisValidSequence :: String -> Bool\nisValidSequence = all (`elem` \"ATCG\")\n\nmain :: IO ()\nmain = do\n    putStrLn \"Enter a genome sequence:\"\n    sequence <- getLine\n    processGenomeSequence sequence\n```"
  }
]