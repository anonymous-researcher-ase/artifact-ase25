[
  {
    "task": "Create a program that reads a CSV file using a library designed for parsing CSV data.",
    "code": "```fortran\nprogram read_csv\n    use, intrinsic :: iso_fortran_env, only: error_unit\n    use :: csv_module\n    implicit none\n\n    type(csv_file) :: csv\n    integer :: iostat\n    character(len=256) :: filename\n    character(len=256) :: line\n\n    filename = 'data.csv'\n    \n    call csv%open(filename, iostat)\n    if (iostat /= 0) then\n        write(error_unit, '(A,I0)') 'Error opening file: ', iostat\n        stop\n    end if\n\n    do\n        call csv%read_line(line, iostat)\n        if (iostat /= 0) exit\n        write(*, '(A)') trim(line)\n    end do\n\n    call csv%close()\nend program read_csv\n```"
  },
  {
    "task": "Implement a function that generates a random number using a standard library for random number generation.",
    "code": "```fortran\nprogram random_number_generator\n    use, intrinsic :: iso_fortran_env, only: real32\n    implicit none\n    real(real32) :: random_number\n\n    call random_number_sub(random_number)\n    print *, \"Generated random number: \", random_number\ncontains\n    subroutine random_number_sub(rand_num)\n        real(real32), intent(out) :: rand_num\n        real(real32) :: seed\n        call random_seed()\n        call random_number(rand_num)\n    end subroutine random_number_sub\nend program random_number_generator\n```"
  },
  {
    "task": "Use a third-party library to send an HTTP GET request to a public API and print the response.",
    "code": "```fortran\nprogram http_get_example\n  use iso_c_binding\n  use,intrinsic :: iso_fortran_env, only: int32, error_unit\n  implicit none\n  type(c_ptr) :: curl, res, headers = c_null_ptr\n  integer(c_int) :: code\n  character(len=1000) :: response\n  interface\n     function curl_easy_init() bind(c, name='curl_easy_init')\n       import :: c_ptr\n       type(c_ptr) :: curl_easy_init\n     end function\n     function curl_easy_setopt(curl, option, parameter) bind(c, name='curl_easy_setopt')\n       import :: c_ptr, c_int, c_char\n       type(c_ptr), value :: curl\n       integer(c_int), value :: option\n       type(c_ptr), value :: parameter\n       integer(c_int) :: curl_easy_setopt\n     end function\n     function curl_easy_perform(curl) bind(c, name='curl_easy_perform')\n       import :: c_ptr, c_int\n       type(c_ptr), value :: curl\n       integer(c_int) :: curl_easy_perform\n     end function\n     function curl_easy_cleanup(curl) bind(c, name='curl_easy_cleanup')\n       import :: c_ptr\n       type(c_ptr), value :: curl\n       integer(c_int) :: curl_easy_cleanup\n     end function\n  end interface\n\n  integer, parameter :: CURLOPT_URL = 10002\n  integer, parameter :: CURLOPT_WRITEFUNCTION = 20011\n  integer, parameter :: CURLE_OK = 0\n\n  interface\n    function write_callback(ptr, size, nmemb, userdata) bind(c, name='write_callback')\n      import :: c_ptr, c_size_t\n      type(c_ptr), value :: ptr\n      integer(c_size_t), value :: size, nmemb\n      type(c_ptr), value :: userdata\n      integer(c_size_t) :: write_callback\n    end function\n  end interface\n\n  interface\n    subroutine set_response(buf, size) bind(c, name='set_response')\n      import :: c_char, c_int\n      character(kind=c_char), dimension(size), intent(in) :: buf\n      integer(c_int), value :: size\n    end subroutine\n  end interface\n\n  interface\n    function strlen(s) bind(c, name='strlen')\n      import :: c_char, c_size_t\n      character(kind=c_char), dimension(*) :: s\n      integer(c_size_t) :: strlen\n    end function\n  end interface\n\n  external :: write_callback\n  response = \"\"\n  curl = curl_easy_init()\n  if (c_associated(curl)) then\n     call curl_easy_setopt(curl, CURLOPT_URL, c_loc(c_char('https://api.publicapis.org/entries'//c_null_char)))\n     call curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, c_funptr(write_callback))\n     res = curl_easy_perform(curl)\n     if (res == CURLE_OK) then\n        write(*,*) 'Response:', trim(response)\n     else\n        write(error_unit,*) 'Failed to perform request'\n     end if\n     call curl_easy_cleanup(curl)\n  else\n     write(error_unit,*) 'Failed to initialize CURL'\n  end if\n\ncontains\n\n  function write_callback(ptr, size, nmemb, userdata) bind(c)\n    use iso_c_binding, only: c_ptr, c_int, c_size_t, c_char\n    implicit none\n    type(c_ptr), value :: ptr, userdata\n    integer(c_size_t), value :: size, nmemb\n    integer(c_size_t) :: write_callback\n    character(kind=c_char), dimension(size*nmemb) :: buf\n    pointer(c_ptr_to_char), contiguous :: c_ptr_to_char\n    integer :: i\n\n    c_ptr_to_char => c_associated(ptr)\n    do i = 1, size*nmemb\n       buf(i) = c_ptr_to_char(i)\n    end do\n    call set_response(buf, size*nmemb)\n    write_callback = size * nmemb\n  end function\n\nend program http_get_example\n```"
  },
  {
    "task": "Write a script that extracts the text from a PDF file using a library for PDF manipulation.",
    "code": "```fortran\nprogram extract_pdf_text\n  use pdf_lib\n  implicit none\n  type(pdf_document) :: doc\n  character(len=:), allocatable :: text\n  integer :: status\n\n  ! Open the PDF file\n  status = open_pdf(doc, 'file.pdf')\n  if (status /= 0) then\n     print *, 'Error opening PDF file'\n     stop\n  end if\n\n  ! Extract text from the PDF\n  call extract_text(doc, text)\n  \n  ! Print the extracted text\n  print *, text\n\n  ! Close the PDF document\n  call close_pdf(doc)\nend program extract_pdf_text\n```"
  },
  {
    "task": "Develop a tool that resizes images by integrating an image processing library.",
    "code": "```fortran\nprogram image_resizer\n    use, intrinsic :: iso_c_binding\n    use image_library  ! Assume this is a fictional Fortran module for image processing\n    implicit none\n\n    type(c_ptr) :: image_in, image_out\n    integer(c_int) :: width, height, new_width, new_height, status\n\n    ! Load the image (from a file or other source)\n    image_in = load_image('input_image.jpg', width, height)\n\n    ! Set the new dimensions for the image\n    new_width = 800\n    new_height = 600\n\n    ! Resize the image\n    image_out = resize_image(image_in, new_width, new_height, status)\n\n    ! Check if resizing was successful\n    if (status /= 0) then\n        print *, 'Error: Image resizing failed.'\n        stop\n    end if\n\n    ! Save the resized image\n    call save_image(image_out, 'output_image.jpg')\n\n    ! Clean up resources\n    call free_image(image_in)\n    call free_image(image_out)\n\nend program image_resizer\n```"
  },
  {
    "task": "Create a program that connects to a database using a library for database interaction.",
    "code": "```fortran\nprogram database_connection\n    use iso_c_binding\n    implicit none\n\n    ! Declare variables for database connection\n    type(c_ptr) :: db\n    integer(c_int) :: rc\n\n    ! Initialize the SQLite library\n    call sqlite3_initialize()\n\n    ! Open a connection to the database\n    rc = sqlite3_open(\"example.db\", db)\n    if (rc /= 0) then\n        print *, \"Can't open database\"\n        stop\n    end if\n\n    ! Close the database connection\n    call sqlite3_close(db)\n\n    ! Finalize the SQLite library\n    call sqlite3_shutdown()\n\ncontains\n\n    function sqlite3_initialize() bind(c, name=\"sqlite3_initialize\")\n        integer(c_int) :: sqlite3_initialize\n    end function sqlite3_initialize\n\n    function sqlite3_open(dbname, db) bind(c, name=\"sqlite3_open\")\n        integer(c_int) :: sqlite3_open\n        character(kind=c_char), dimension(*) :: dbname\n        type(c_ptr), value :: db\n    end function sqlite3_open\n\n    function sqlite3_close(db) bind(c, name=\"sqlite3_close\")\n        integer(c_int) :: sqlite3_close\n        type(c_ptr), value :: db\n    end function sqlite3_close\n\n    function sqlite3_shutdown() bind(c, name=\"sqlite3_shutdown\")\n        integer(c_int) :: sqlite3_shutdown\n    end function sqlite3_shutdown\n\nend program database_connection\n```"
  },
  {
    "task": "Build an application that converts Markdown text to HTML using a Markdown parsing library.",
    "code": "```fortran\nprogram markdown_to_html\n    use, intrinsic :: iso_c_binding\n    implicit none\n\n    interface\n        function parse_markdown(input) bind(c, name='parse_markdown')\n            import :: c_char, c_ptr\n            type(c_ptr) :: parse_markdown\n            character(kind=c_char), dimension(*) :: input\n        end function parse_markdown\n    end interface\n\n    character(len=1000) :: markdown_text\n    type(c_ptr) :: html_ptr\n\n    markdown_text = \"# Hello, World!\\nThis is a **Markdown** text.\"\n\n    html_ptr = parse_markdown(markdown_text)\n\n    ! Here you would use the html_ptr to access the converted HTML\nend program markdown_to_html\n```"
  },
  {
    "task": "Use a library to transform XML data into JSON format for easier manipulation.",
    "code": "```fortran\nprogram xml_to_json\n  use iso_c_binding\n  implicit none\n\n  ! Declare XML and JSON strings\n  character(len=:), allocatable :: xml_data, json_data\n\n  ! Load the xml2json library\n  use xml2json_module\n\n  ! Sample XML data\n  xml_data = \"<root><element>value</element></root>\"\n\n  ! Transform XML to JSON\n  call xml_to_json(xml_data, json_data)\n\n  ! Output the JSON data\n  print *, json_data\n\ncontains\n\n  subroutine xml_to_json(xml, json)\n    character(len=*), intent(in) :: xml\n    character(len=:), allocatable, intent(out) :: json\n    integer(c_int) :: xml_length, json_length\n    type(c_ptr) :: xml_cptr, json_cptr\n\n    ! Convert Fortran strings to C pointers\n    xml_length = len_trim(xml)\n    xml_cptr = c_loc(xml)\n    ! Call the library function\n    call c_xml_to_json(xml_cptr, xml_length, json_cptr, json_length)\n    ! Allocate and copy the result back to a Fortran string\n    allocate(character(len=json_length) :: json)\n    call c_f_pointer(json_cptr, json, [json_length])\n  end subroutine xml_to_json\n\nend program xml_to_json\n```\n\nNote: The above code assumes the existence of a fictional library `xml2json_module` with a C function `c_xml_to_json` that performs the XML to JSON conversion."
  },
  {
    "task": "Implement a feature that schedules tasks at regular intervals using a scheduler library.",
    "code": "```fortran\nprogram task_scheduler\n    use iso_c_binding\n    implicit none\n\n    interface\n        subroutine schedule_task(interval, task) bind(c, name=\"schedule_task\")\n            import :: c_int\n            integer(c_int), value :: interval\n            external :: task\n        end subroutine schedule_task\n    end interface\n\n    external :: my_task\n\n    call schedule_task(5, my_task)\n\ncontains\n\n    subroutine my_task()\n        print *, \"Task executed\"\n    end subroutine my_task\n\nend program task_scheduler\n```"
  },
  {
    "task": "Develop a chat application that utilizes a library for WebSocket communication.",
    "code": "```fortran\nprogram ChatApplication\n  use iso_c_binding\n  implicit none\n\n  interface\n     subroutine websocket_connect(url) bind(c, name='ws_connect')\n       import :: c_char\n       character(kind=c_char), intent(in) :: url(*)\n     end subroutine websocket_connect\n\n     subroutine websocket_send(message) bind(c, name='ws_send')\n       import :: c_char\n       character(kind=c_char), intent(in) :: message(*)\n     end subroutine websocket_send\n\n     subroutine websocket_receive(buffer, bufsize) bind(c, name='ws_receive')\n       import :: c_char, c_int\n       character(kind=c_char), intent(out) :: buffer(*)\n       integer(c_int), intent(in) :: bufsize\n     end subroutine websocket_receive\n\n     subroutine websocket_disconnect() bind(c, name='ws_disconnect')\n     end subroutine websocket_disconnect\n  end interface\n\n  character(len=256) :: receive_buffer\n  character(len=256), parameter :: server_url = 'ws://chatserver.example.com'\n\n  call websocket_connect(server_url)\n\n  call websocket_send('Hello from Fortran!')\n\n  call websocket_receive(receive_buffer, len(receive_buffer))\n  print *, 'Received message: ', trim(receive_buffer)\n\n  call websocket_disconnect()\n\nend program ChatApplication\n```"
  },
  {
    "task": "Create a game that uses a library to handle physics simulations for realistic movements.",
    "code": "```fortran\nprogram physics_game\n    use, intrinsic :: iso_fortran_env, only: real64\n    use :: physics_library  ! Assume this is a fictional library for physics simulation\n    implicit none\n\n    type(PhysicsWorld) :: world\n    type(PhysicsObject) :: ball\n\n    call init_physics(world)\n\n    call create_object(world, ball, mass=1.0_real64, position=[0.0_real64, 10.0_real64], velocity=[0.0_real64, 0.0_real64])\n\n    do while (.not. is_game_over())\n        call update_physics(world, delta_time=0.016_real64)\n        call move_object(ball)\n        call render()\n    end do\n\n    call cleanup_physics(world)\n\ncontains\n\n    logical function is_game_over()\n        ! Placeholder for game over condition\n        is_game_over = .false.\n    end function is_game_over\n\n    subroutine render()\n        ! Placeholder for rendering the game\n    end subroutine render\n\nend program physics_game\n```"
  },
  {
    "task": "Write a function that hashes a string using a cryptographic hashing library.",
    "code": "```fortran\nprogram hash_example\n  use iso_c_binding\n  implicit none\n\n  interface\n     function EVP_Digest(data, count, md, md_size, type, impl) bind(c)\n       use iso_c_binding\n       type(c_ptr), value :: data\n       integer(c_int), value :: count\n       type(c_ptr) :: md\n       integer(c_int) :: md_size\n       type(c_ptr), value :: type, impl\n       integer(c_int) :: EVP_Digest\n     end function EVP_Digest\n\n     function EVP_get_digestbyname(name) bind(c)\n       use iso_c_binding\n       character(kind=c_char), dimension(*), value :: name\n       type(c_ptr) :: EVP_get_digestbyname\n     end function EVP_get_digestbyname\n  end interface\n\n  character(len=64) :: input_string\n  character(len=32) :: hash_result\n  integer(c_int) :: hash_length\n  type(c_ptr) :: md_context, sha256\n  integer(c_int) :: status\n\n  input_string = 'Fortran hashing example'\n\n  sha256 = EVP_get_digestbyname('sha256'//c_null_char)\n\n  call c_f_pointer(c_loc(hash_result), md_context)\n  status = EVP_Digest(c_loc(input_string), len(input_string), md_context, hash_length, sha256, c_null_ptr)\n\n  if (status /= 1) then\n     print *, 'Hashing failed'\n  else\n     print '(A)', 'Hash: ', hash_result\n  end if\nend program hash_example\n```"
  },
  {
    "task": "Build a program that validates email addresses using a library for regular expression matching.",
    "code": "```fortran\nprogram validate_email\n    use iso_c_binding\n    implicit none\n\n    interface\n        function regcomp(preg, pattern, cflags) bind(c, name=\"regcomp\")\n            use iso_c_binding\n            implicit none\n            integer(c_int) :: regcomp\n            type(c_ptr), value :: preg\n            character(kind=c_char), dimension(*), intent(in) :: pattern\n            integer(c_int), value :: cflags\n        end function regcomp\n\n        function regexec(preg, string, nmatch, pmatch, eflags) bind(c, name=\"regexec\")\n            use iso_c_binding\n            implicit none\n            integer(c_int) :: regexec\n            type(c_ptr), value :: preg\n            character(kind=c_char), dimension(*), intent(in) :: string\n            integer(c_int), value :: nmatch\n            type(c_ptr), value :: pmatch\n            integer(c_int), value :: eflags\n        end function regexec\n\n        function regfree(preg) bind(c, name=\"regfree\")\n            use iso_c_binding\n            implicit none\n            type(c_ptr), value :: preg\n        end function regfree\n    end interface\n\n    type(c_ptr) :: preg\n    character(len=100) :: email\n    integer(c_int) :: status\n    character(len=100), parameter :: pattern = '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    logical :: is_valid\n\n    preg = c_null_ptr\n    email = 'example@domain.com'\n\n    status = regcomp(preg, pattern//c_null_char, 0)\n    if (status /= 0) stop 'Failed to compile regex pattern'\n\n    status = regexec(preg, email//c_null_char, 0, c_null_ptr, 0)\n    is_valid = (status == 0)\n\n    call regfree(preg)\n\n    if (is_valid) then\n        print *, 'Email is valid.'\n    else\n        print *, 'Email is invalid.'\n    end if\nend program validate_email\n```"
  },
  {
    "task": "Implement a feature that reads and writes Excel files using a library tailored for Excel file manipulation.",
    "code": "```fortran\nprogram excel_integration\n    use, intrinsic :: iso_c_binding\n    use excel_module\n    implicit none\n\n    type(excel_handle) :: workbook\n    integer :: status\n\n    ! Initialize the Excel library\n    call excel_init(status)\n    if (status /= 0) stop \"Error initializing Excel library.\"\n\n    ! Open an Excel file for reading\n    call excel_open(workbook, \"input.xlsx\", status)\n    if (status /= 0) stop \"Error opening Excel file.\"\n\n    ! Perform operations on the Excel file\n    ! (e.g., read data, modify sheets, etc.)\n\n    ! Save changes to a new Excel file\n    call excel_save(workbook, \"output.xlsx\", status)\n    if (status /= 0) stop \"Error saving Excel file.\"\n\n    ! Close the Excel file\n    call excel_close(workbook, status)\n    if (status /= 0) stop \"Error closing Excel file.\"\n\n    ! Finalize the Excel library\n    call excel_finalize(status)\n    if (status /= 0) stop \"Error finalizing Excel library.\"\n\nend program excel_integration\n```"
  },
  {
    "task": "Use a library to translate text from one language to another in your application.",
    "code": "```fortran\nprogram translate_text\n    use iso_fortran_env\n    implicit none\n\n    ! Declare variables\n    character(len=256) :: input_text, translated_text\n    integer :: status\n    \n    ! Initialize variables\n    input_text = \"Hello, World!\"\n\n    ! Call the hypothetical translation library function\n    call translate(input_text, 'en', 'es', translated_text, status)\n\n    ! Print the translated text\n    if (status == 0) then\n        print *, translated_text\n    else\n        print *, \"Translation failed with status: \", status\n    end if\nend program translate_text\n\n! Hypothetical external procedure to interface with a translation library\nsubroutine translate(source, lang_from, lang_to, result, status)\n    character(len=*), intent(in) :: source, lang_from, lang_to\n    character(len=256), intent(out) :: result\n    integer, intent(out) :: status\n    ! Assume this subroutine interfaces with an external library\n    ! that performs the translation\nend subroutine translate\n```"
  },
  {
    "task": "Create a script that generates QR codes using a library for QR code creation.",
    "code": "```fortran\nprogram generate_qr_code\n    use, intrinsic :: iso_c_binding\n    implicit none\n\n    interface\n        subroutine generate_qr(input, output) bind(c, name=\"generate_qr\")\n            use iso_c_binding\n            character(kind=c_char), dimension(*), intent(in) :: input\n            character(kind=c_char), dimension(*), intent(out) :: output\n        end subroutine generate_qr\n    end interface\n\n    character(kind=c_char, len=100) :: inputString\n    character(kind=c_char, len=1000) :: outputImage\n\n    ! Assign a string to be encoded in the QR code\n    inputString = 'https://www.example.com'\n\n    ! Call the C function to generate the QR code\n    call generate_qr(inputString, outputImage)\n\nend program generate_qr_code\n```"
  },
  {
    "task": "Build an app that plays audio files using a library for audio processing.",
    "code": "```fortran\nprogram play_audio\n    use, intrinsic :: iso_c_binding\n    use, intrinsic :: iso_fortran_env, only: error_unit\n    implicit none\n\n    interface\n        function audio_init() bind(c, name='audio_init')\n            use iso_c_binding\n            integer(c_int) :: audio_init\n        end function\n\n        function audio_play(filename) bind(c, name='audio_play')\n            use iso_c_binding\n            character(kind=c_char), dimension(*) :: filename\n            integer(c_int) :: audio_play\n        end function\n\n        function audio_cleanup() bind(c, name='audio_cleanup')\n            use iso_c_binding\n            integer(c_int) :: audio_cleanup\n        end function\n    end interface\n\n    integer(c_int) :: status\n    character(len=256) :: file_name\n\n    ! Initialize the audio library\n    status = audio_init()\n    if (status /= 0) then\n        write(error_unit, *) \"Error initializing audio library\"\n        stop\n    end if\n\n    ! Set the audio file to be played\n    file_name = 'audiofile.wav' // c_null_char\n\n    ! Play the audio file\n    status = audio_play(file_name)\n    if (status /= 0) then\n        write(error_unit, *) \"Error playing audio file\"\n    end if\n\n    ! Clean up the audio library\n    status = audio_cleanup()\n    if (status /= 0) then\n        write(error_unit, *) \"Error during audio library cleanup\"\n    end if\nend program play_audio\n```"
  },
  {
    "task": "Develop a tool that scrapes web pages for specific data using a web scraping library.",
    "code": "```fortran\nprogram web_scraper\n    use iso_c_binding\n    implicit none\n\n    interface\n        function curl_easy_init() bind(C, name='curl_easy_init')\n            use iso_c_binding\n            type(c_ptr) :: curl_easy_init\n        end function curl_easy_init\n\n        function curl_easy_setopt(curl, option, parameter) bind(C, name='curl_easy_setopt')\n            use iso_c_binding\n            type(c_ptr), value :: curl\n            integer(c_int), value :: option\n            type(c_ptr), value :: parameter\n            integer(c_int) :: curl_easy_setopt\n        end function curl_easy_setopt\n\n        function curl_easy_perform(curl) bind(C, name='curl_easy_perform')\n            use iso_c_binding\n            type(c_ptr), value :: curl\n            integer(c_int) :: curl_easy_perform\n        end function curl_easy_perform\n\n        function curl_easy_cleanup(curl) bind(C, name='curl_easy_cleanup')\n            use iso_c_binding\n            type(c_ptr), value :: curl\n            integer(c_int) :: curl_easy_cleanup\n        end function curl_easy_cleanup\n\n        function curl_easy_strerror(code) bind(C, name='curl_easy_strerror')\n            use iso_c_binding\n            integer(c_int), value :: code\n            type(c_ptr) :: curl_easy_strerror\n        end function curl_easy_strerror\n    end interface\n\n    type(c_ptr) :: curl\n    integer(c_int) :: res\n    character(len=256) :: error_buffer\n\n    curl = curl_easy_init()\n    if (c_associated(curl)) then\n        res = curl_easy_setopt(curl, 10002_c_int, c_loc('http://example.com'))\n        res = curl_easy_perform(curl)\n        if (res /= 0_c_int) then\n            call c_f_pointer(curl_easy_strerror(res), error_buffer)\n            print *, 'Error:', trim(error_buffer)\n        endif\n        call curl_easy_cleanup(curl)\n    else\n        print *, 'Failed to initialize CURL'\n    endif\nend program web_scraper\n```"
  },
  {
    "task": "Implement a service that sends emails using a library that facilitates SMTP communication.",
    "code": "```fortran\nprogram send_email\n    use, intrinsic :: iso_c_binding\n    implicit none\n\n    interface\n        subroutine smtp_send(from, to, subject, message) bind(c)\n            import :: c_char\n            character(kind=c_char), dimension(*) :: from\n            character(kind=c_char), dimension(*) :: to\n            character(kind=c_char), dimension(*) :: subject\n            character(kind=c_char), dimension(*) :: message\n        end subroutine smtp_send\n    end interface\n\n    character(len=100, kind=c_char), parameter :: from = 'sender@example.com'//c_null_char\n    character(len=100, kind=c_char), parameter :: to = 'recipient@example.com'//c_null_char\n    character(len=100, kind=c_char), parameter :: subject = 'Test Email'//c_null_char\n    character(len=500, kind=c_char), parameter :: message = 'This is a test email message.'//c_null_char\n\n    call smtp_send(from, to, subject, message)\n\nend program send_email\n```"
  },
  {
    "task": "Create a program that visualizes data in charts using a charting library.",
    "code": "```fortran\nprogram chart_visualization\n    use iso_c_binding\n    implicit none\n\n    interface\n        subroutine plot_chart(x, y, n) bind(c, name=\"plot_chart\")\n            use iso_c_binding\n            real(c_double), intent(in) :: x(*), y(*)\n            integer(c_int), value :: n\n        end subroutine plot_chart\n    end interface\n\n    integer, parameter :: n = 10\n    real(c_double), dimension(n) :: x, y\n    integer :: i\n\n    ! Sample data\n    do i = 1, n\n        x(i) = real(i, kind=c_double)\n        y(i) = sin(x(i))\n    end do\n\n    call plot_chart(x, y, n)\nend program chart_visualization\n```"
  },
  {
    "task": "Write a script that compresses files into a zip archive using a standard library.",
    "code": "```fortran\nprogram zip_compress\n  use iso_c_binding\n  implicit none\n\n  interface\n     function system(command) bind(C, name=\"system\")\n       use iso_c_binding\n       integer(c_int) :: system\n       character(kind=c_char), dimension(*) :: command\n     end function system\n  end interface\n\n  character(len=512) :: command\n\n  ! Example: Compress 'file1.txt' and 'file2.txt' into 'archive.zip'\n  command = 'zip archive.zip file1.txt file2.txt'//char(0)\n\n  call system(command)\nend program zip_compress\n```"
  },
  {
    "task": "Use a library to parse command-line arguments in your application.",
    "code": "```fortran\nprogram parse_arguments\n  use, intrinsic :: iso_c_binding\n  use, intrinsic :: iso_fortran_env\n  implicit none\n\n  integer :: argc, i\n  type(c_ptr) :: argv\n  character(len=100) :: arg\n\n  ! Get the number of command-line arguments\n  argc = command_argument_count()\n\n  ! Loop over each argument\n  do i = 0, argc\n    call get_command_argument(i, arg)\n    print *, 'Argument', i, ':', trim(arg)\n  end do\n\nend program parse_arguments\n```"
  },
  {
    "task": "Build a weather application that displays data from a weather API using a library for JSON parsing.",
    "code": "```fortran\nprogram weather_app\n    use iso_c_binding\n    implicit none\n\n    ! Declare variables\n    character(len=256) :: api_url, json_data\n    integer :: stat\n\n    ! Initialize API URL\n    api_url = \"http://example-weather-api.com/data\"\n\n    ! Call the function to fetch JSON data\n    json_data = fetch_data(api_url, stat)\n\n    ! Check if data was fetched successfully\n    if (stat == 0) then\n        ! Parse the JSON data\n        call parse_json(json_data)\n    else\n        print *, \"Failed to fetch data from API.\"\n    end if\n\ncontains\n\n    function fetch_data(url, status) result(data)\n        character(len=*), intent(in) :: url\n        integer, intent(out) :: status\n        character(len=256) :: data\n\n        ! Use a C library to perform HTTP GET request\n        ! Here we assume the use of a C library that can perform HTTP requests\n        call c_http_get(url, data, status)\n    end function fetch_data\n\n    subroutine parse_json(json_str)\n        character(len=*), intent(in) :: json_str\n\n        ! Use a JSON parsing library\n        ! Here we assume the use of a JSON parsing library, e.g., json-fortran\n        call json_parse(json_str)\n\n    end subroutine parse_json\n\n    subroutine c_http_get(url, response, status) bind(c, name='http_get')\n        use iso_c_binding\n        character(kind=c_char, len=1), dimension(*) :: url\n        character(kind=c_char, len=1), dimension(*) :: response\n        integer(c_int), intent(out) :: status\n    end subroutine c_http_get\n\nend program weather_app\n```"
  },
  {
    "task": "Create a video player application using a library that handles video playback.",
    "code": "```fortran\nprogram VideoPlayer\n    use, intrinsic :: iso_c_binding\n    implicit none\n\n    interface\n        subroutine initialize_video_player() bind(c, name=\"initialize_video_player\")\n        end subroutine initialize_video_player\n\n        subroutine play_video(file_name) bind(c, name=\"play_video\")\n            import :: c_char\n            character(kind=c_char), intent(in) :: file_name(*)\n        end subroutine play_video\n\n        subroutine shutdown_video_player() bind(c, name=\"shutdown_video_player\")\n        end subroutine shutdown_video_player\n    end interface\n\n    character(len=256) :: file_name\n    character(kind=c_char), dimension(:), allocatable :: c_file_name\n\n    call initialize_video_player()\n\n    ! Assume the file name is passed or hardcoded here\n    file_name = 'sample_video.mp4'\n    allocate(c_file_name(len_trim(file_name)))\n    c_file_name = transfer(file_name, c_file_name)\n\n    call play_video(c_file_name)\n\n    deallocate(c_file_name)\n\n    call shutdown_video_player()\nend program VideoPlayer\n```"
  },
  {
    "task": "Develop a system that logs application events using a logging library for better traceability.",
    "code": "```fortran\nprogram logging_system\n    use, intrinsic :: iso_c_binding\n    use logging_lib\n\n    implicit none\n\n    call initialize_logging()\n\n    call log_event(\"Application started\", LOG_LEVEL_INFO)\n    call log_event(\"Performing operation X\", LOG_LEVEL_DEBUG)\n    call log_event(\"Operation X successful\", LOG_LEVEL_INFO)\n    call log_event(\"Error encountered in operation Y\", LOG_LEVEL_ERROR)\n\n    call finalize_logging()\n\ncontains\n\n    subroutine initialize_logging()\n        ! Initialize the logging system\n        call logging_lib_initialize()\n    end subroutine initialize_logging\n\n    subroutine log_event(message, level)\n        character(len=*), intent(in) :: message\n        integer, intent(in) :: level\n        ! Log the event with the specified message and level\n        call logging_lib_log(message, level)\n    end subroutine log_event\n\n    subroutine finalize_logging()\n        ! Finalize the logging system\n        call logging_lib_finalize()\n    end subroutine finalize_logging\n\nend program logging_system\n```"
  },
  {
    "task": "Implement a feature that encrypts and decrypts data using a library for encryption.",
    "code": "```fortran\nprogram encryption_demo\n    use, intrinsic :: iso_fortran_env, only: int8\n    use, intrinsic :: iso_c_binding, only: c_ptr, c_f_pointer, c_null_ptr\n    use encryption_lib  ! Hypothetical library for encryption\n\n    implicit none\n\n    integer(int8), parameter :: key_length = 16\n    character(len=key_length) :: key = '1234567890abcdef'\n\n    character(len=100) :: plaintext = 'This is a secret message.'\n    character(len=100) :: ciphertext\n    character(len=100) :: decryptedtext\n\n    c_ptr :: enc_handle, dec_handle\n\n    ! Initialize encryption and decryption handles\n    call init_encryption(enc_handle, key, key_length)\n    call init_decryption(dec_handle, key, key_length)\n\n    ! Encrypt the plaintext\n    call encrypt(enc_handle, plaintext, ciphertext)\n\n    ! Decrypt the ciphertext\n    call decrypt(dec_handle, ciphertext, decryptedtext)\n\n    ! Print the results\n    print *, 'Plaintext: ', plaintext\n    print *, 'Ciphertext: ', ciphertext\n    print *, 'Decrypted: ', decryptedtext\n\n    ! Clean up handles\n    call finalize_encryption(enc_handle)\n    call finalize_decryption(dec_handle)\n\ncontains\n\n    subroutine init_encryption(handle, key, key_len)\n        c_ptr, intent(out) :: handle\n        character(len=*), intent(in) :: key\n        integer, intent(in) :: key_len\n        ! Hypothetical encryption library initialization\n        ! call encrypted_init(handle, key, key_len)\n    end subroutine init_encryption\n\n    subroutine init_decryption(handle, key, key_len)\n        c_ptr, intent(out) :: handle\n        character(len=*), intent(in) :: key\n        integer, intent(in) :: key_len\n        ! Hypothetical decryption library initialization\n        ! call decrypted_init(handle, key, key_len)\n    end subroutine init_decryption\n\n    subroutine encrypt(handle, plaintext, ciphertext)\n        c_ptr, intent(in) :: handle\n        character(len=*), intent(in) :: plaintext\n        character(len=*), intent(out) :: ciphertext\n        ! Hypothetical encryption function\n        ! call encrypted_encrypt(handle, plaintext, ciphertext)\n    end subroutine encrypt\n\n    subroutine decrypt(handle, ciphertext, decryptedtext)\n        c_ptr, intent(in) :: handle\n        character(len=*), intent(in) :: ciphertext\n        character(len=*), intent(out) :: decryptedtext\n        ! Hypothetical decryption function\n        ! call decrypted_decrypt(handle, ciphertext, decryptedtext)\n    end subroutine decrypt\n\n    subroutine finalize_encryption(handle)\n        c_ptr, intent(inout) :: handle\n        ! Hypothetical encryption finalization\n        ! call encrypted_finalize(handle)\n    end subroutine finalize_encryption\n\n    subroutine finalize_decryption(handle)\n        c_ptr, intent(inout) :: handle\n        ! Hypothetical decryption finalization\n        ! call decrypted_finalize(handle)\n    end subroutine finalize_decryption\n\nend program encryption_demo\n```"
  },
  {
    "task": "Write a program that fetches and displays cryptocurrency prices using a third-party library for API interaction.",
    "code": "```fortran\nprogram CryptoPrices\n    use, intrinsic :: iso_c_binding\n    implicit none\n\n    ! Declare variables\n    character(len=256) :: api_url\n    character(len=1024) :: api_response\n    integer :: status\n\n    ! Initialize API URL\n    api_url = \"https://api.coingecko.com/api/v3/simple/price?ids=bitcoin,ethereum&vs_currencies=usd\"\n\n    ! Fetch cryptocurrency prices\n    call fetch_api_data(api_url, api_response, status)\n\n    ! Check if the API call was successful\n    if (status /= 0) then\n        print *, \"Error fetching data from API\"\n    else\n        print *, \"Cryptocurrency Prices: \", trim(api_response)\n    end if\n\ncontains\n\n    subroutine fetch_api_data(url, response, status)\n        character(len=*), intent(in) :: url\n        character(len=*), intent(out) :: response\n        integer, intent(out) :: status\n\n        ! Third-party library integration for HTTP request\n        interface\n            subroutine http_get_request(url, response, status) bind(c, name=\"http_get_request\")\n                import :: c_char, c_int\n                character(kind=c_char), dimension(*), intent(in) :: url\n                character(kind=c_char), dimension(*), intent(out) :: response\n                integer(kind=c_int), intent(out) :: status\n            end subroutine http_get_request\n        end interface\n\n        ! Call the HTTP GET request from the library\n        call http_get_request(url, response, status)\n\n    end subroutine fetch_api_data\n\nend program CryptoPrices\n```"
  },
  {
    "task": "Use a library to implement OAuth authentication for secure user login in your application.",
    "code": "```fortran\nprogram oauth_authentication\n  use iso_c_binding\n  use oauth_module  ! Hypothetical Fortran module for OAuth\n  implicit none\n\n  type(c_ptr) :: oauth_client\n  integer(c_int) :: status\n  character(kind=c_char), dimension(:), pointer :: auth_url\n  character(kind=c_char, len=256) :: access_token\n\n  ! Initialize OAuth client\n  oauth_client = oauth_create_client()\n\n  ! Obtain authorization URL\n  call oauth_get_authorization_url(oauth_client, auth_url, status)\n\n  if (status /= 0) then\n    print *, \"Error obtaining authorization URL\"\n    stop\n  end if\n\n  print *, \"Please visit the following URL to authorize the application:\"\n  print *, trim(c_string(auth_url))\n\n  ! Get access token (assuming the user has authorized the application)\n  call oauth_get_access_token(oauth_client, access_token, status)\n\n  if (status /= 0) then\n    print *, \"Error obtaining access token\"\n    stop\n  end if\n\n  print *, \"Access token obtained successfully: \", trim(access_token)\n\n  ! Clean up\n  call oauth_destroy_client(oauth_client)\n  nullify(auth_url)\n\nend program oauth_authentication\n```"
  },
  {
    "task": "Build a calculator that evaluates mathematical expressions using a math parsing library.",
    "code": "```fortran\nprogram calculator\n    use iso_c_binding\n    implicit none\n\n    interface\n        function eval_expression(expr) bind(c, name=\"eval_expression\")\n            use iso_c_binding\n            implicit none\n            character(kind=c_char), dimension(*) :: expr\n            real(c_double) :: eval_expression\n        end function eval_expression\n    end interface\n\n    character(len=256) :: input_expr\n    real(c_double) :: result\n\n    print *, 'Enter a mathematical expression:'\n    read(*, '(A)') input_expr\n\n    result = eval_expression(trim(adjustl(input_expr)) // c_null_char)\n    print *, 'Result:', result\nend program calculator\n```"
  },
  {
    "task": "Create a chatbot that integrates a natural language processing library for understanding user input.",
    "code": "```fortran\nprogram chatbot\n  use, intrinsic :: iso_c_binding\n  implicit none\n\n  interface\n    subroutine initialize_nlp() bind(c, name=\"initialize_nlp\")\n    end subroutine initialize_nlp\n\n    subroutine process_input(input, output) bind(c, name=\"process_input\")\n      import :: c_char\n      character(kind=c_char), dimension(*) :: input\n      character(kind=c_char), dimension(*) :: output\n    end subroutine process_input\n  end interface\n\n  character(len=256) :: user_input\n  character(len=256) :: response\n  integer :: stat\n\n  call initialize_nlp()\n\n  print *, \"Welcome to the Fortran Chatbot. Type 'exit' to quit.\"\n\n  do\n    print *, \"You: \"\n    read(*, '(A)') user_input\n    if (trim(user_input) == \"exit\") exit\n\n    call process_input(trim(adjustl(user_input)), response)\n\n    print *, \"Bot: \", trim(response)\n  end do\n\nend program chatbot\n```"
  },
  {
    "task": "Develop a tool that detects faces in images using a computer vision library.",
    "code": "```fortran\nprogram face_detection\n    use iso_c_binding\n    implicit none\n\n    interface\n        function cvLoadImage(filename) bind(C, name='cvLoadImage')\n            use iso_c_binding\n            type(c_ptr) :: cvLoadImage\n            character(kind=c_char), dimension(*) :: filename\n        end function cvLoadImage\n\n        function cvDetectFaces(image) bind(C, name='cvDetectFaces')\n            use iso_c_binding\n            integer(c_int) :: cvDetectFaces\n            type(c_ptr), value :: image\n        end function cvDetectFaces\n    end interface\n\n    type(c_ptr) :: image\n    integer(c_int) :: num_faces\n    character(len=256, kind=c_char) :: image_file\n\n    print *, 'Enter the image file path:'\n    read(*, '(A)') image_file\n\n    image = cvLoadImage(image_file)\n    if (c_associated(image)) then\n        num_faces = cvDetectFaces(image)\n        print *, 'Number of faces detected:', num_faces\n    else\n        print *, 'Failed to load image.'\n    end if\n\nend program face_detection\n```"
  },
  {
    "task": "Implement a program that converts date and time across different time zones using a library for date manipulation.",
    "code": "```fortran\nprogram timezone_conversion\n    use, intrinsic :: iso_fortran_env, only: real64\n    use :: datetime_module\n    implicit none\n\n    ! Declare variables for input and output\n    character(len=19) :: input_datetime\n    character(len=32) :: input_timezone, output_timezone\n    character(len=19) :: converted_datetime\n\n    ! Sample input date-time and time zones\n    input_datetime = '2023-10-05T08:00:00'\n    input_timezone = 'America/New_York'\n    output_timezone = 'Europe/London'\n\n    ! Call the subroutine to convert the date and time\n    call convert_timezone(input_datetime, input_timezone, output_timezone, converted_datetime)\n\n    ! Print the converted date and time\n    print *, 'Converted DateTime:', converted_datetime\n\ncontains\n\n    subroutine convert_timezone(input_dt, in_tz, out_tz, out_dt)\n        character(len=19), intent(in) :: input_dt\n        character(len=32), intent(in) :: in_tz, out_tz\n        character(len=19), intent(out) :: out_dt\n        ! Integration with an external library to handle date-time conversion\n        call datetime_module_convert(input_dt, in_tz, out_tz, out_dt)\n    end subroutine convert_timezone\n\nend program timezone_conversion\n```"
  },
  {
    "task": "Write a utility that uploads files to a cloud storage service using a library that interfaces with the service's API.",
    "code": "```fortran\nprogram CloudUploader\n  use iso_c_binding\n  implicit none\n\n  ! Declare the interface to the cloud storage library\n  interface\n    subroutine initialize_cloud_storage(api_key) bind(c, name='initialize_cloud_storage')\n      import :: c_char\n      character(kind=c_char), intent(in) :: api_key\n    end subroutine initialize_cloud_storage\n\n    subroutine upload_file(file_path, success) bind(c, name='upload_file')\n      import :: c_char, c_int\n      character(kind=c_char), intent(in) :: file_path\n      integer(kind=c_int), intent(out) :: success\n    end subroutine upload_file\n\n    subroutine finalize_cloud_storage() bind(c, name='finalize_cloud_storage')\n    end subroutine finalize_cloud_storage\n  end interface\n\n  character(len=256) :: api_key, file_path\n  integer :: success\n\n  ! Initialize the cloud storage service\n  api_key = 'your_api_key_here'\n  call initialize_cloud_storage(api_key)\n\n  ! Set the file path to be uploaded\n  file_path = 'path_to_your_file_here'\n\n  ! Upload the file\n  call upload_file(file_path, success)\n  if (success == 0) then\n    print *, 'File uploaded successfully.'\n  else\n    print *, 'Failed to upload file.'\n  end if\n\n  ! Finalize the cloud storage service\n  call finalize_cloud_storage()\n\nend program CloudUploader\n```"
  },
  {
    "task": "Create a real-time chat system using a library that supports asynchronous communication.",
    "code": "```fortran\nprogram real_time_chat\n  use iso_fortran_env\n  use, intrinsic :: iso_c_binding\n  use chat_lib  ! hypothetical library supporting async communication\n\n  implicit none\n\n  interface\n    subroutine init_chat_server(port) bind(c, name=\"init_chat_server\")\n      import :: c_int\n      integer(c_int), value :: port\n    end subroutine init_chat_server\n\n    subroutine start_chat_server() bind(c, name=\"start_chat_server\")\n    end subroutine start_chat_server\n\n    subroutine init_chat_client(server_ip, port) bind(c, name=\"init_chat_client\")\n      import :: c_char, c_int\n      character(kind=c_char), dimension(*), intent(in) :: server_ip\n      integer(c_int), value :: port\n    end subroutine init_chat_client\n\n    subroutine send_message(message) bind(c, name=\"send_message\")\n      import :: c_char\n      character(kind=c_char), dimension(*), intent(in) :: message\n    end subroutine send_message\n\n    subroutine receive_message(buffer, buffer_size) bind(c, name=\"receive_message\")\n      import :: c_char, c_int\n      character(kind=c_char), dimension(*), intent(out) :: buffer\n      integer(c_int), value :: buffer_size\n    end subroutine receive_message\n  end interface\n\n  character(kind=c_char, len=256) :: message\n  integer :: chat_mode\n  integer(c_int) :: port\n  character(kind=c_char, len=15) :: server_ip\n\n  print *, \"Select mode: (1) Server, (2) Client\"\n  read *, chat_mode\n\n  if (chat_mode == 1) then\n    print *, \"Enter port number:\"\n    read *, port\n    call init_chat_server(port)\n    call start_chat_server()\n  else if (chat_mode == 2) then\n    print *, \"Enter server IP:\"\n    read *, server_ip\n    print *, \"Enter port number:\"\n    read *, port\n    call init_chat_client(server_ip, port)\n  end if\n\n  do\n    if (chat_mode == 1) then\n      call receive_message(message, len(message))\n      print *, \"Received: \", trim(message)\n    else if (chat_mode == 2) then\n      print *, \"Enter message:\"\n      read *, message\n      call send_message(message)\n    end if\n  end do\nend program real_time_chat\n```"
  },
  {
    "task": "Use a library to generate and manipulate UUIDs for unique identification in your application.",
    "code": "```fortran\nprogram uuid_example\n    use, intrinsic :: iso_fortran_env, only: int64\n    use :: iso_c_binding\n    implicit none\n\n    interface\n        function uuid_generate() bind(c, name='uuid_generate')\n            use iso_c_binding, only: c_void\n            implicit none\n            type(c_void), value :: uuid_generate\n        end function uuid_generate\n\n        subroutine uuid_unparse(uuid, outstr) bind(c, name='uuid_unparse')\n            use iso_c_binding, only: c_char, c_void\n            implicit none\n            type(c_void), value :: uuid\n            character(kind=c_char), dimension(*), intent(out) :: outstr\n        end subroutine uuid_unparse\n    end interface\n\n    type(c_void) :: new_uuid\n    character(len=37, kind=c_char) :: uuid_str\n\n    new_uuid = uuid_generate()\n    call uuid_unparse(new_uuid, uuid_str)\n\n    print *, 'Generated UUID: ', trim(adjustl(uuid_str))\n\nend program uuid_example\n```"
  },
  {
    "task": "Build a desktop application that uses a library for creating graphical user interfaces.",
    "code": "```fortran\nprogram desktop_app\n    use iso_c_binding\n    implicit none\n\n    ! Import GTK library for GUI\n    interface\n        subroutine gtk_init(argc, argv) bind(c, name='gtk_init')\n            use iso_c_binding\n            integer(c_int), value :: argc\n            type(c_ptr), value :: argv\n        end subroutine gtk_init\n\n        function gtk_main_quit() bind(c, name='gtk_main_quit')\n            use iso_c_binding\n        end function gtk_main_quit\n\n        function gtk_main() bind(c, name='gtk_main')\n            use iso_c_binding\n        end function gtk_main\n\n        function gtk_window_new(window_type) bind(c, name='gtk_window_new')\n            use iso_c_binding\n            integer(c_int), value :: window_type\n            type(c_ptr) :: gtk_window_new\n        end function gtk_window_new\n\n        subroutine gtk_widget_show(widget) bind(c, name='gtk_widget_show')\n            use iso_c_binding\n            type(c_ptr), value :: widget\n        end subroutine gtk_widget_show\n\n        subroutine g_signal_connect_data(instance, detailed_signal, c_handler, data, closure, flags) &\n             bind(c, name='g_signal_connect_data')\n            use iso_c_binding\n            type(c_ptr), value :: instance\n            character(kind=c_char), dimension(*), intent(in) :: detailed_signal\n            type(c_funptr), value :: c_handler\n            type(c_ptr), value :: data\n            type(c_ptr), value :: closure\n            integer(c_int), value :: flags\n        end subroutine g_signal_connect_data\n    end interface\n\n    integer(c_int), parameter :: GTK_WINDOW_TOPLEVEL = 0\n    type(c_ptr) :: window\n\n    ! Initialize GTK\n    call gtk_init(0, c_null_ptr)\n\n    ! Create a new window\n    window = gtk_window_new(GTK_WINDOW_TOPLEVEL)\n\n    ! Connect the \"destroy\" event to gtk_main_quit\n    call g_signal_connect_data(window, \"destroy\"//c_null_char, c_funloc(gtk_main_quit), &\n                               c_null_ptr, c_null_ptr, 0)\n\n    ! Show the window\n    call gtk_widget_show(window)\n\n    ! Enter the GTK main loop\n    call gtk_main()\nend program desktop_app\n```"
  },
  {
    "task": "Develop an algorithm that finds the shortest path in a graph using a library that provides graph algorithms.",
    "code": "```fortran\nprogram shortest_path\n    use, intrinsic :: iso_c_binding\n    use graph_lib\n    implicit none\n\n    type(GraphType) :: graph\n    integer :: source, destination\n    real :: path_length\n\n    ! Initialize the graph\n    call initGraph(graph)\n\n    ! Set the source and destination nodes\n    source = 1\n    destination = 5\n\n    ! Call the library function to find the shortest path\n    call findShortestPath(graph, source, destination, path_length)\n\n    ! Output the shortest path length\n    print *, 'The shortest path length is:', path_length\n\n    ! Finalize the graph\n    call finalizeGraph(graph)\nend program shortest_path\n```"
  },
  {
    "task": "Create a digital clock application that uses a library for handling time events.",
    "code": "```fortran\nprogram digital_clock\n    use iso_fortran_env\n    use, intrinsic :: iso_c_binding\n    implicit none\n\n    interface\n        function sleep(seconds) bind(C, name=\"sleep\")\n            use iso_c_binding\n            integer(c_int) :: sleep\n            integer(c_int), value :: seconds\n        end function sleep\n    end interface\n\n    integer :: hours, minutes, seconds\n\n    call get_time(hours, minutes, seconds)\n    call display_time(hours, minutes, seconds)\n    \n    do\n        call sleep(1)\n        seconds = seconds + 1\n        if (seconds == 60) then\n            seconds = 0\n            minutes = minutes + 1\n        end if\n        if (minutes == 60) then\n            minutes = 0\n            hours = hours + 1\n        end if\n        if (hours == 24) then\n            hours = 0\n        end if\n        call display_time(hours, minutes, seconds)\n    end do\n\ncontains\n\n    subroutine get_time(h, m, s)\n        integer, intent(out) :: h, m, s\n        integer :: clock_time\n        call system_clock(count=clock_time)\n        s = mod(clock_time, 60)\n        m = mod(clock_time / 60, 60)\n        h = mod(clock_time / 3600, 24)\n    end subroutine get_time\n\n    subroutine display_time(h, m, s)\n        integer, intent(in) :: h, m, s\n        write(*,'(I2.2, \":\", I2.2, \":\", I2.2)') h, m, s\n    end subroutine display_time\n\nend program digital_clock\n```"
  },
  {
    "task": "Write a program that uses a library to convert between different units of measurement.",
    "code": "```fortran\nprogram unit_conversion\n    use iso_fortran_env\n    implicit none\n    real(real64) :: value, converted_value\n    integer :: choice\n\n    print *, \"Unit Conversion Program\"\n    print *, \"Choose conversion type:\"\n    print *, \"1. Meters to Feet\"\n    print *, \"2. Kilograms to Pounds\"\n    print *, \"3. Celsius to Fahrenheit\"\n    read *, choice\n    print *, \"Enter value to convert:\"\n    read *, value\n\n    select case(choice)\n    case(1)\n        converted_value = meters_to_feet(value)\n    case(2)\n        converted_value = kilograms_to_pounds(value)\n    case(3)\n        converted_value = celsius_to_fahrenheit(value)\n    case default\n        print *, \"Invalid choice\"\n        stop\n    end select\n\n    print *, \"Converted value:\", converted_value\n\ncontains\n\n    function meters_to_feet(m) result(ft)\n        real(real64), intent(in) :: m\n        real(real64) :: ft\n        ft = m * 3.28084\n    end function meters_to_feet\n\n    function kilograms_to_pounds(kg) result(lbs)\n        real(real64), intent(in) :: kg\n        real(real64) :: lbs\n        lbs = kg * 2.20462\n    end function kilograms_to_pounds\n\n    function celsius_to_fahrenheit(c) result(f)\n        real(real64), intent(in) :: c\n        real(real64) :: f\n        f = c * 9.0 / 5.0 + 32.0\n    end function celsius_to_fahrenheit\n\nend program unit_conversion\n```"
  },
  {
    "task": "Use a library to implement a caching mechanism for improving application performance.",
    "code": "```fortran\nprogram caching_example\n  use iso_c_binding\n  implicit none\n\n  interface\n     subroutine cache_set(key, value) bind(c, name='cache_set')\n       import :: c_char\n       character(kind=c_char), value :: key, value\n     end subroutine cache_set\n\n     function cache_get(key) result(value) bind(c, name='cache_get')\n       import :: c_char\n       character(kind=c_char), value :: key\n       character(kind=c_char), pointer :: value\n     end function cache_get\n  end interface\n\n  character(len=20) :: key, value, retrieved_value\n  character(kind=c_char), pointer :: c_value\n\n  key = 'example_key'\n  value = 'example_value'\n\n  call cache_set(key//c_null_char, value//c_null_char)\n  c_value => cache_get(key//c_null_char)\n  retrieved_value = c_value\n\n  print *, 'Retrieved value:', retrieved_value\n\nend program caching_example\n```"
  },
  {
    "task": "Build an e-commerce platform that integrates a payment processing library for handling transactions.",
    "code": "```fortran\nmodule payment_module\n  use iso_c_binding\n  implicit none\n\n  interface\n     subroutine init_payment_lib() bind(C, name=\"initPaymentLib\")\n     end subroutine init_payment_lib\n\n     subroutine process_transaction(amount, status) bind(C, name=\"processTransaction\")\n       import :: c_double, c_int\n       real(c_double), value :: amount\n       integer(c_int) :: status\n     end subroutine process_transaction\n  end interface\nend module payment_module\n\nprogram ecommerce_platform\n  use payment_module\n  implicit none\n\n  real(8) :: transaction_amount\n  integer(4) :: transaction_status\n\n  call init_payment_lib()\n\n  transaction_amount = 99.99\n  call process_transaction(transaction_amount, transaction_status)\n\n  if (transaction_status == 0) then\n     print*, \"Transaction successful.\"\n  else\n     print*, \"Transaction failed.\"\n  end if\nend program ecommerce_platform\n```"
  },
  {
    "task": "Create a to-do list application that stores data locally using a library for file management.",
    "code": "```fortran\nprogram ToDoListApp\n    use iso_fortran_env\n    implicit none\n    character(len=256) :: task\n    integer :: option\n\n    do\n        print *, 'To-Do List Application'\n        print *, '1. Add Task'\n        print *, '2. View Tasks'\n        print *, '3. Exit'\n        print *, 'Enter your choice:'\n        read *, option\n\n        select case (option)\n        case (1)\n            call add_task()\n        case (2)\n            call view_tasks()\n        case (3)\n            exit\n        case default\n            print *, 'Invalid option. Please try again.'\n        end select\n    end do\ncontains\n\n    subroutine add_task()\n        character(len=256) :: new_task\n        open(unit=10, file='tasks.txt', status='unknown', action='write', &\n             position='append')\n        print *, 'Enter the new task:'\n        read *, new_task\n        write(10, '(A)') trim(new_task)\n        close(10)\n    end subroutine add_task\n\n    subroutine view_tasks()\n        character(len=256) :: existing_task\n        open(unit=10, file='tasks.txt', status='old', action='read')\n        print *, 'Your Tasks:'\n        do\n            read(10, '(A)', IOSTAT=iostat) existing_task\n            if (iostat /= 0) exit\n            print *, trim(existing_task)\n        end do\n        close(10)\n    end subroutine view_tasks\n\nend program ToDoListApp\n```"
  },
  {
    "task": "Develop a system that monitors server health using a library that provides network utilities.",
    "code": "```fortran\nprogram server_health_monitor\n    use iso_c_binding\n    implicit none\n    interface\n        function get_network_status() bind(c, name='get_network_status')\n            use iso_c_binding\n            integer(c_int) :: get_network_status\n        end function get_network_status\n    end interface\n\n    integer :: status\n\n    call monitor_server_health()\n\ncontains\n\n    subroutine monitor_server_health()\n        use iso_c_binding\n        integer :: network_status\n\n        ! Monitor network status indefinitely\n        do\n            network_status = get_network_status()\n            if (network_status == 0) then\n                print *, \"Server is healthy\"\n            else\n                print *, \"Server has network issues\"\n            end if\n            call sleep(5)  ! Sleep for 5 seconds before next check\n        end do\n    end subroutine monitor_server_health\n\n    subroutine sleep(seconds)\n        integer, intent(in) :: seconds\n        integer(c_int) :: sleep_seconds\n        sleep_seconds = seconds\n        call sleep_c(sleep_seconds)\n    end subroutine sleep\n\n    interface\n        subroutine sleep_c(seconds) bind(c, name='sleep')\n            use iso_c_binding\n            integer(c_int), value :: seconds\n        end subroutine sleep_c\n    end interface\n\nend program server_health_monitor\n```"
  },
  {
    "task": "Implement a program that detects language from a given text using a language detection library.",
    "code": "```fortran\nprogram LanguageDetection\n    use iso_c_binding\n    implicit none\n\n    interface\n        function detect_language(text) bind(c, name=\"detect_language\")\n            use iso_c_binding\n            character(kind=c_char), dimension(*) :: text\n            character(kind=c_char), pointer :: detect_language\n        end function detect_language\n    end interface\n\n    character(len=1000) :: input_text\n    character(kind=c_char), pointer :: detected_language\n\n    print *, \"Enter text for detection:\"\n    read(*,'(A)') input_text\n\n    detected_language => detect_language(trim(adjustl(input_text))//c_null_char)\n    print *, \"Detected Language: \", detected_language\n\nend program LanguageDetection\n```"
  },
  {
    "task": "Write a script that sends notifications to a mobile device using a push notification library.",
    "code": "```fortran\nprogram send_notification\n  use, intrinsic :: iso_c_binding\n  implicit none\n  \n  interface\n    subroutine sendPushNotification(deviceToken, message) bind(c, name='send_push_notification')\n      import :: c_char\n      character(kind=c_char), dimension(*), intent(in) :: deviceToken\n      character(kind=c_char), dimension(*), intent(in) :: message\n    end subroutine sendPushNotification\n  end interface\n\n  character(kind=c_char, len=64) :: deviceToken\n  character(kind=c_char, len=256) :: message\n\n  ! Example device token and message\n  deviceToken = 'example_device_token_here'\n  message = 'This is a test notification.'\n\n  call sendPushNotification(deviceToken, message)\n\nend program send_notification\n```"
  },
  {
    "task": "Use a library to generate reports in PDF format from application data.",
    "code": "```fortran\nprogram generate_pdf_report\n  use pdf_library\n  implicit none\n\n  type(PDFDocument) :: doc\n  character(len=256) :: report_title\n  character(len=256) :: report_content\n\n  ! Initialize report data\n  report_title = \"Application Data Report\"\n  report_content = \"This is a generated report from application data.\"\n\n  ! Create a new PDF document\n  call createPDF(doc, report_title)\n\n  ! Add content to the PDF\n  call addContent(doc, report_content)\n\n  ! Save the PDF document\n  call savePDF(doc, \"application_report.pdf\")\n\nend program generate_pdf_report\n```"
  },
  {
    "task": "Build a program that performs statistical analysis on datasets using a statistical computing library.",
    "code": "```fortran\nprogram StatisticalAnalysis\n  use iso_c_binding\n  implicit none\n\n  ! Declare variables\n  integer :: n\n  real(C_DOUBLE), allocatable :: dataset(:)\n  real(C_DOUBLE) :: mean, stddev\n\n  ! External library functions\n  interface\n    function gsl_stats_mean(data, stride, n) bind(C, name='gsl_stats_mean')\n      import :: C_DOUBLE\n      real(C_DOUBLE) :: gsl_stats_mean\n      real(C_DOUBLE), dimension(*) :: data\n      integer(C_INT) :: stride, n\n    end function gsl_stats_mean\n\n    function gsl_stats_sd(data, stride, n) bind(C, name='gsl_stats_sd')\n      import :: C_DOUBLE\n      real(C_DOUBLE) :: gsl_stats_sd\n      real(C_DOUBLE), dimension(*) :: data\n      integer(C_INT) :: stride, n\n    end function gsl_stats_sd\n  end interface\n\n  ! Initialize dataset\n  n = 5\n  allocate(dataset(n))\n  dataset = [1.0_C_DOUBLE, 2.0_C_DOUBLE, 3.0_C_DOUBLE, 4.0_C_DOUBLE, 5.0_C_DOUBLE]\n\n  ! Perform statistical analysis\n  mean = gsl_stats_mean(dataset, 1, n)\n  stddev = gsl_stats_sd(dataset, 1, n)\n\n  ! Output results\n  print *, \"Mean: \", mean\n  print *, \"Standard Deviation: \", stddev\n\n  ! Deallocate dataset\n  deallocate(dataset)\nend program StatisticalAnalysis\n```"
  },
  {
    "task": "Create an image gallery application that uses a library for image caching and lazy loading.",
    "code": "```fortran\nprogram ImageGallery\n    use iso_c_binding\n    implicit none\n\n    interface\n        subroutine cache_image(image_path) bind(C, name='cache_image')\n            import :: c_char\n            character(kind=c_char), value :: image_path(*)\n        end subroutine cache_image\n\n        function load_image(image_path) bind(C, name='load_image')\n            import :: c_char, c_ptr\n            character(kind=c_char), value :: image_path(*)\n            type(c_ptr) :: load_image\n        end function load_image\n    end interface\n\n    character(len=256) :: image_paths(5) = [ &\n        \"image1.jpg\", \"image2.jpg\", \"image3.jpg\", &\n        \"image4.jpg\", \"image5.jpg\" &\n    ]\n    integer :: i\n\n    do i = 1, size(image_paths)\n        call cache_image(image_paths(i))\n    end do\n\n    do i = 1, size(image_paths)\n        call load_image(image_paths(i))\n    end do\nend program ImageGallery\n```"
  },
  {
    "task": "Develop a machine learning model that predicts outcomes using a machine learning library.",
    "code": "```fortran\nprogram machine_learning_model\n    use iso_c_binding\n    implicit none\n\n    ! Declare variables for input and output\n    real(c_double), allocatable :: features(:,:)\n    real(c_double), allocatable :: outcomes(:)\n    integer :: num_samples, num_features\n\n    ! Initialize the machine learning library\n    call initialize_ml_library()\n\n    ! Load or define your dataset\n    num_samples = 100\n    num_features = 10\n    allocate(features(num_samples, num_features))\n    allocate(outcomes(num_samples))\n\n    call load_data(features, outcomes)\n\n    ! Train the machine learning model\n    call train_model(features, outcomes, num_samples, num_features)\n\n    ! Predict outcomes using the trained model\n    call predict_outcomes(features, num_samples, num_features)\n\n    ! Finalize the machine learning library\n    call finalize_ml_library()\n\ncontains\n\n    subroutine initialize_ml_library()\n        ! Placeholder for library initialization\n    end subroutine initialize_ml_library\n\n    subroutine load_data(features, outcomes)\n        real(c_double), intent(out) :: features(:,:)\n        real(c_double), intent(out) :: outcomes(:)\n        ! Placeholder for loading or defining the dataset\n    end subroutine load_data\n\n    subroutine train_model(features, outcomes, num_samples, num_features)\n        real(c_double), intent(in) :: features(:,:)\n        real(c_double), intent(in) :: outcomes(:)\n        integer, intent(in) :: num_samples, num_features\n        ! Placeholder for training model using the library\n    end subroutine train_model\n\n    subroutine predict_outcomes(features, num_samples, num_features)\n        real(c_double), intent(in) :: features(:,:)\n        integer, intent(in) :: num_samples, num_features\n        ! Placeholder for predicting outcomes using the library\n    end subroutine predict_outcomes\n\n    subroutine finalize_ml_library()\n        ! Placeholder for library finalization\n    end subroutine finalize_ml_library\n\nend program machine_learning_model\n```"
  },
  {
    "task": "Implement a feature that automatically formats code according to style guidelines using a code formatter library.",
    "code": "```fortran\nprogram code_formatter\n    use iso_c_binding\n    implicit none\n\n    interface\n        function format_code(input_code) bind(c, name=\"format_code\")\n            import :: c_char\n            character(kind=c_char), pointer :: format_code\n            character(kind=c_char), intent(in) :: input_code\n        end function format_code\n    end interface\n\n    character(len=255) :: code_to_format\n    character(len=255), pointer :: formatted_code\n\n    print *, \"Enter the code to format:\"\n    read(*, '(A)') code_to_format\n\n    formatted_code => format_code(code_to_format)\n    print *, \"Formatted Code:\"\n    print *, formatted_code\nend program code_formatter\n```"
  },
  {
    "task": "Write a program that generates barcodes using a library for barcode generation.",
    "code": "```fortran\nprogram generate_barcode\n  use barcode_lib\n  implicit none\n\n  ! Declare variables\n  character(len=100) :: barcode_data\n  integer :: status\n\n  ! Initialize the barcode data\n  barcode_data = \"123456789012\"\n\n  ! Call the library function to generate barcode\n  call generate_barcode_from_data(barcode_data, status)\n\n  ! Check if the barcode generation was successful\n  if (status /= 0) then\n    print *, \"Error generating barcode\"\n  else\n    print *, \"Barcode generated successfully\"\n  end if\n\nend program generate_barcode\n```"
  },
  {
    "task": "Use a library to create interactive maps for displaying geographical data in your application.",
    "code": "```fortran\nprogram interactive_map\n    use iso_c_binding\n    implicit none\n    interface\n        subroutine create_interactive_map() bind(c, name=\"create_interactive_map\")\n        end subroutine create_interactive_map\n    end interface\n\n    call create_interactive_map()\nend program interactive_map\n```"
  },
  {
    "task": "Build a simulation that models fluid dynamics using a library for physics simulations.",
    "code": "```fortran\nprogram fluid_dynamics_simulation\n  use physics_simulation_lib\n  implicit none\n\n  type(FluidSimulation) :: simulation\n  real :: time_step\n  integer :: num_steps, i\n\n  ! Initialize the simulation\n  call initialize_simulation(simulation)\n\n  ! Set parameters for the simulation\n  time_step = 0.01\n  num_steps = 1000\n\n  ! Run the simulation\n  do i = 1, num_steps\n     call update_simulation(simulation, time_step)\n     call output_simulation_state(simulation)\n  end do\n\n  ! Finalize the simulation\n  call finalize_simulation(simulation)\n\nend program fluid_dynamics_simulation\n```"
  },
  {
    "task": "Create a program that reads barcodes from images using a library for barcode scanning.",
    "code": "```fortran\nprogram BarcodeReader\n    use iso_c_binding\n    implicit none\n\n    ! Declare variables\n    character(len=256) :: imagePath\n    character(len=256) :: barcodeData\n    type(c_ptr) :: barcodeImage\n    integer(c_int) :: result\n\n    ! Initialize the barcode library\n    call barcode_init()\n\n    ! Read the image path\n    print *, 'Enter the path to the image:'\n    read(*, '(A)') imagePath\n\n    ! Load the image\n    barcodeImage = barcode_load_image(trim(imagePath))\n\n    ! Check if the image was successfully loaded\n    if (c_associated(barcodeImage)) then\n        ! Scan the barcode\n        result = barcode_scan(barcodeImage, barcodeData)\n\n        if (result == 0) then\n            print *, 'Barcode data:', trim(barcodeData)\n        else\n            print *, 'Failed to scan barcode from image.'\n        end if\n\n        ! Release image resources\n        call barcode_free_image(barcodeImage)\n    else\n        print *, 'Failed to load image.'\n    end if\n\n    ! Finalize the barcode library\n    call barcode_finalize()\n    \ncontains\n\n    subroutine barcode_init()\n        ! Initialize the library (implementation specific)\n    end subroutine barcode_init\n\n    function barcode_load_image(path) result(image)\n        character(len=*), intent(in) :: path\n        type(c_ptr) :: image\n        ! Load image function (implementation specific)\n    end function barcode_load_image\n\n    function barcode_scan(image, data) result(status)\n        type(c_ptr), intent(in) :: image\n        character(len=256), intent(out) :: data\n        integer(c_int) :: status\n        ! Barcode scanning function (implementation specific)\n    end function barcode_scan\n\n    subroutine barcode_free_image(image)\n        type(c_ptr), intent(in) :: image\n        ! Free image resources (implementation specific)\n    end subroutine barcode_free_image\n\n    subroutine barcode_finalize()\n        ! Finalize the library (implementation specific)\n    end subroutine barcode_finalize\n\nend program BarcodeReader\n```"
  },
  {
    "task": "Develop a feature that performs spell checking using a library for text processing.",
    "code": "```fortran\nprogram SpellCheck\n    use iso_c_binding\n    implicit none\n\n    interface\n        function check_spelling(text) bind(c, name=\"check_spelling\")\n            import :: c_ptr\n            type(c_ptr) :: check_spelling\n        end function check_spelling\n    end interface\n\n    type(c_ptr) :: spell_checker\n    character(len=100) :: text\n    character(len=100) :: result\n\n    ! Example text to check\n    text = \"Ths is an exmple txt with sme spelling erors.\"\n\n    ! Call the spell checking library function\n    spell_checker = check_spelling(text)\n\n    ! Assume result is returned as a null-terminated string\n    call c_f_pointer(spell_checker, result)\n    print *, trim(adjustl(result))\n\nend program SpellCheck\n```"
  },
  {
    "task": "Implement a service that aggregates news articles from various sources using a library for web content aggregation.",
    "code": "```fortran\nprogram news_aggregator\n  use iso_c_binding\n  implicit none\n\n  ! Declare external C function for web content aggregation\n  interface\n    function aggregate_news() bind(C, name=\"aggregate_news\") \n      use iso_c_binding\n      character(kind=c_char, len=1), pointer :: aggregate_news(:)\n    end function aggregate_news\n  end interface\n\n  character(kind=c_char, len=1), pointer :: news_aggregate(:)\n\n  ! Call the C function to aggregate news\n  news_aggregate => aggregate_news()\n\n  ! Output the aggregated news\n  if (associated(news_aggregate)) then\n    print *, 'Aggregated News:'\n    call output_news(news_aggregate)\n  else\n    print *, 'Failed to aggregate news.'\n  endif\n\ncontains\n\n  subroutine output_news(news)\n    character(kind=c_char, len=1), pointer :: news(:)\n    integer :: i\n\n    i = 1\n    do while (i <= size(news))\n      write(*,'(A)', advance='no') news(i:i)\n      i = i + 1\n    end do\n    print *\n  end subroutine output_news\n\nend program news_aggregator\n```"
  },
  {
    "task": "Write a script that converts spoken language to text using a speech recognition library.",
    "code": "```fortran\nprogram SpeechToText\n    use iso_c_binding\n    implicit none\n\n    ! Declare interfaces for the speech recognition library functions\n    interface\n        function init_speech_recognition() bind(C, name=\"init_speech_recognition\")\n            use iso_c_binding\n            integer(c_int) :: init_speech_recognition\n        end function\n\n        function recognize_speech() bind(C, name=\"recognize_speech\")\n            use iso_c_binding\n            character(kind=c_char), pointer :: recognize_speech\n        end function\n\n        subroutine free_c_string(c_str) bind(C, name=\"free_c_string\")\n            use iso_c_binding\n            character(kind=c_char), pointer :: c_str\n        end subroutine\n    end interface\n\n    ! Initialize the speech recognition\n    if (init_speech_recognition() /= 0) then\n        print *, \"Error initializing speech recognition\"\n        stop\n    end if\n\n    ! Recognize speech and get the result as a C string\n    character(kind=c_char), pointer :: result\n    result => recognize_speech()\n\n    ! Print the recognized text\n    if (associated(result)) then\n        print *, \"Recognized Text:\", result\n        ! Free the allocated memory for the C string\n        call free_c_string(result)\n    else\n        print *, \"No speech recognized\"\n    end if\n\nend program SpeechToText\n```"
  },
  {
    "task": "Use a library to implement a feature that tracks user behavior in a web application.",
    "code": "```fortran\nmodule user_behavior_tracking\n  use iso_c_binding\n  implicit none\n\n  interface\n    function init_tracking() bind(c, name=\"init_tracking\")\n      import :: c_int\n      integer(c_int) :: init_tracking\n    end function init_tracking\n\n    function track_event(event) bind(c, name=\"track_event\")\n      import :: c_char, c_int\n      character(kind=c_char), dimension(*) :: event\n      integer(c_int) :: track_event\n    end function track_event\n\n    function stop_tracking() bind(c, name=\"stop_tracking\")\n      import :: c_int\n      integer(c_int) :: stop_tracking\n    end function stop_tracking\n  end interface\n\ncontains\n\n  subroutine start_tracking()\n    integer :: status\n    status = init_tracking()\n    if (status /= 0) then\n      print *, 'Error initializing tracking'\n      stop\n    end if\n  end subroutine start_tracking\n\n  subroutine log_event(event)\n    character(len=*) :: event\n    integer :: status\n    status = track_event(trim(adjustl(event)) // c_null_char)\n    if (status /= 0) then\n      print *, 'Error logging event: ', event\n    end if\n  end subroutine log_event\n\n  subroutine end_tracking()\n    integer :: status\n    status = stop_tracking()\n    if (status /= 0) then\n      print *, 'Error stopping tracking'\n    end if\n  end subroutine end_tracking\n\nend module user_behavior_tracking\n```"
  },
  {
    "task": "Build a program that analyzes sentiment in social media posts using a sentiment analysis library.",
    "code": "```fortran\nprogram SentimentAnalysis\n  use iso_c_binding\n  implicit none\n\n  interface\n    function init_sentiment_analysis() bind(c, name='init_sentiment_analysis')\n      use iso_c_binding\n      implicit none\n      integer(c_int) :: init_sentiment_analysis\n    end function\n\n    function analyze_sentiment(post) bind(c, name='analyze_sentiment')\n      use iso_c_binding\n      implicit none\n      character(kind=c_char), dimension(*), intent(in) :: post\n      integer(c_int) :: analyze_sentiment\n    end function\n\n    subroutine finalize_sentiment_analysis() bind(c, name='finalize_sentiment_analysis')\n      use iso_c_binding\n      implicit none\n    end subroutine\n  end interface\n\n  integer(c_int) :: init_status\n  integer(c_int) :: sentiment_score\n  character(kind=c_char, len=256) :: post\n\n  ! Initialize the sentiment analysis library\n  init_status = init_sentiment_analysis()\n  if (init_status /= 0) then\n    stop \"Failed to initialize sentiment analysis library\"\n  end if\n\n  ! Example social media post\n  post = \"I love programming in Fortran!\"\n\n  ! Analyze sentiment of the post\n  sentiment_score = analyze_sentiment(trim(post))\n\n  ! Output the sentiment score\n  print *, \"Sentiment Score: \", sentiment_score\n\n  ! Finalize the library\n  call finalize_sentiment_analysis()\n\nend program SentimentAnalysis\n```"
  },
  {
    "task": "Create a utility that detects plagiarism in text using a library for text comparison.",
    "code": "```fortran\nprogram plagiarism_detection\n    use iso_fortran_env\n    implicit none\n    character(len=:), allocatable :: text1, text2\n    real(real64) :: similarity\n\n    ! Allocate and read the texts\n    allocate(character(len=1024) :: text1, text2)\n    text1 = \"The quick brown fox jumps over the lazy dog.\"\n    text2 = \"The quick brown fox leaps over the lazy dog.\"\n\n    ! Call the text comparison library function\n    call text_compare(text1, text2, similarity)\n\n    ! Output the similarity score\n    print *, \"Text similarity score: \", similarity\n\ncontains\n\n    subroutine text_compare(t1, t2, score)\n        character(len=*), intent(in) :: t1, t2\n        real(real64), intent(out) :: score\n        ! Assuming a hypothetical library function is called here\n        ! score = some_library_function(t1, t2)\n        score = 0.9  ! Placeholder value for demonstration\n    end subroutine text_compare\n\nend program plagiarism_detection\n```"
  },
  {
    "task": "Develop a program that predicts weather trends using a library for time series forecasting.",
    "code": "```fortran\nprogram WeatherTrendPrediction\n    use, intrinsic :: iso_c_binding\n    implicit none\n\n    ! Declare external library procedures\n    interface\n        subroutine forecast(data, n, result) bind(c, name='forecast_time_series')\n            use iso_c_binding\n            real(c_double), dimension(*) :: data\n            integer(c_int), value :: n\n            real(c_double), dimension(*) :: result\n        end subroutine forecast\n    end interface\n\n    ! Local variables\n    real(c_double), dimension(100) :: weather_data, prediction\n    integer :: i\n\n    ! Initialize weather data (example data)\n    weather_data = (/ (1.0d0 * i, i=1,100) /)\n    \n    ! Call the external library function for time series forecasting\n    call forecast(weather_data, size(weather_data), prediction)\n\n    ! Output the prediction results\n    print *, \"Predicted Weather Trends:\"\n    do i = 1, size(prediction)\n        print *, \"Day \", i, \": \", prediction(i)\n    end do\n\nend program WeatherTrendPrediction\n```"
  },
  {
    "task": "Implement a feature that performs facial recognition using a library specialized for biometric analysis.",
    "code": "```fortran\nprogram FacialRecognition\n    use, intrinsic :: iso_c_binding\n    use biometric_lib_module  ! Hypothetical library for biometric analysis\n\n    implicit none\n\n    ! Declare variables\n    type(face_data) :: input_image\n    type(recognition_result) :: result\n\n    ! Initialize library\n    call initialize_biometric_system()\n\n    ! Load image data (Assumed to be handled by the library)\n    call load_image(input_image, 'path_to_image_file')\n\n    ! Perform facial recognition\n    call recognize_face(input_image, result)\n\n    ! Output recognition result\n    if (result%is_recognized) then\n        print *, \"Face recognized:\", result%identity\n    else\n        print *, \"Face not recognized.\"\n    end if\n\n    ! Finalize library\n    call finalize_biometric_system()\nend program FacialRecognition\n```"
  },
  {
    "task": "Write a program that interacts with blockchain networks using a library for blockchain communication.",
    "code": "```fortran\nprogram blockchain_integration\n    use, intrinsic :: iso_c_binding\n    use blockchain_lib\n\n    implicit none\n\n    type(c_ptr) :: blockchain_handle\n    integer :: status\n    character(len=128) :: network_url\n\n    network_url = 'http://example-blockchain-network.com'\n\n    ! Initialize the blockchain library\n    call blockchain_initialize()\n\n    ! Connect to the blockchain network\n    blockchain_handle = blockchain_connect(network_url, status)\n    if (status /= 0) then\n        print *, 'Error connecting to blockchain network.'\n        stop\n    end if\n\n    ! Perform operations with the blockchain_handle\n    call blockchain_operations(blockchain_handle)\n\n    ! Disconnect from the blockchain network\n    call blockchain_disconnect(blockchain_handle, status)\n    if (status /= 0) then\n        print *, 'Error disconnecting from blockchain network.'\n    end if\n\n    ! Finalize the blockchain library\n    call blockchain_finalize()\n\nend program blockchain_integration\n```"
  },
  {
    "task": "Use a library to perform image recognition tasks in your application.",
    "code": "```fortran\nprogram ImageRecognition\n    use iso_c_binding\n    implicit none\n\n    ! Declare variables for library integration\n    type(c_ptr) :: imageLibHandle\n    type(c_ptr) :: image\n    integer(c_int) :: status\n\n    ! Load the image recognition library\n    imageLibHandle = c_f_pointer(load_image_recognition_library(), c_ptr)\n\n    ! Check if the library was loaded successfully\n    if (c_associated(imageLibHandle)) then\n        ! Load an image using the library\n        image = c_f_pointer(load_image(imageLibHandle, \"example.jpg\"C), c_ptr)\n\n        ! Perform image recognition task\n        status = recognize_image(imageLibHandle, image)\n\n        ! Check the recognition status\n        if (status == 0) then\n            print *, \"Image recognition successful.\"\n        else\n            print *, \"Image recognition failed.\"\n        end if\n\n        ! Release the image\n        call release_image(imageLibHandle, image)\n\n        ! Unload the library\n        call unload_image_recognition_library(imageLibHandle)\n    else\n        print *, \"Failed to load the image recognition library.\"\n    end if\n\ncontains\n\n    function load_image_recognition_library() result(ptr)\n        type(c_ptr) :: ptr\n        ! Here you would implement the logic to load the library\n    end function\n\n    function load_image(handle, filename) result(ptr)\n        type(c_ptr) :: handle, ptr\n        character(kind=c_char), dimension(*) :: filename\n        ! Implement image loading logic\n    end function\n\n    function recognize_image(handle, image) result(status)\n        type(c_ptr) :: handle, image\n        integer(c_int) :: status\n        ! Implement image recognition logic\n    end function\n\n    subroutine release_image(handle, image)\n        type(c_ptr) :: handle, image\n        ! Implement image release logic\n    end subroutine\n\n    subroutine unload_image_recognition_library(handle)\n        type(c_ptr) :: handle\n        ! Implement library unloading logic\n    end subroutine\n\nend program ImageRecognition\n```"
  },
  {
    "task": "Build a program that converts audio files from one format to another using an audio conversion library.",
    "code": "```fortran\nprogram audio_converter\n  use iso_c_binding\n  implicit none\n\n  interface\n     subroutine init_library() bind(c, name=\"init_library\")\n     end subroutine init_library\n     subroutine convert_audio(input_file, output_file) bind(c, name=\"convert_audio\")\n       import :: c_char\n       character(kind=c_char), dimension(*) :: input_file\n       character(kind=c_char), dimension(*) :: output_file\n     end subroutine convert_audio\n     subroutine cleanup_library() bind(c, name=\"cleanup_library\")\n     end subroutine cleanup_library\n  end interface\n\n  character(len=100, kind=c_char) :: input_file = \"input.wav\"//c_null_char\n  character(len=100, kind=c_char) :: output_file = \"output.mp3\"//c_null_char\n\n  call init_library()\n  call convert_audio(input_file, output_file)\n  call cleanup_library()\n\nend program audio_converter\n```"
  },
  {
    "task": "Create a web application that uses a library for rendering 3D graphics.",
    "code": "```fortran\nprogram web_3d_graphics\n  use, intrinsic :: iso_c_binding\n  implicit none\n\n  ! Declare external C function for rendering\n  interface\n    subroutine render_3d() bind(C, name=\"render_3d\")\n    end subroutine render_3d\n  end interface\n\n  ! Initialize and call the rendering function\n  call render_3d()\n\nend program web_3d_graphics\n```"
  },
  {
    "task": "Develop a feature that performs currency conversion using a library for financial calculations.",
    "code": "```fortran\nprogram currency_conversion\n  use, intrinsic :: iso_fortran_env, only: real64\n  use financial_library_module, only: convert_currency\n  implicit none\n\n  real(real64) :: amount, converted_amount\n  character(len=3) :: from_currency, to_currency\n\n  ! Example values for conversion\n  amount = 100.0_real64\n  from_currency = 'USD'\n  to_currency = 'EUR'\n\n  ! Perform currency conversion\n  converted_amount = convert_currency(amount, from_currency, to_currency)\n\n  ! Output the result\n  print *, 'Converted amount: ', converted_amount\n\nend program currency_conversion\n```"
  },
  {
    "task": "Implement a program that manages user sessions using a library for session handling.",
    "code": "```fortran\nmodule session_handler\n    use iso_c_binding\n    implicit none\n    private\n    public :: initialize_session, create_session, end_session\n\n    type, bind(c) :: c_session\n        integer(c_int) :: id\n        character(len=100) :: username\n        logical(c_bool) :: active\n    end type c_session\n\n    interface\n        subroutine c_init_session() bind(c, name='initSession')\n        end subroutine c_init_session\n\n        function c_create_session(username) bind(c, name='createSession')\n            import :: c_char, c_session\n            character(kind=c_char), intent(in) :: username(*)\n            type(c_session) :: c_create_session\n        end function c_create_session\n\n        subroutine c_end_session(session) bind(c, name='endSession')\n            import :: c_session\n            type(c_session), intent(inout) :: session\n        end subroutine c_end_session\n    end interface\n\ncontains\n\n    subroutine initialize_session()\n        call c_init_session()\n    end subroutine initialize_session\n\n    function create_session(username) result(session)\n        character(len=*), intent(in) :: username\n        type(c_session) :: session\n        session = c_create_session(trim(adjustl(username)) // c_null_char)\n    end function create_session\n\n    subroutine end_session(session)\n        type(c_session), intent(inout) :: session\n        call c_end_session(session)\n    end subroutine end_session\n\nend module session_handler\n\nprogram user_session_management\n    use session_handler\n    implicit none\n\n    type(c_session) :: session\n\n    call initialize_session()\n    session = create_session('user123')\n    ! Perform operations with the session...\n    call end_session(session)\n\nend program user_session_management\n```"
  },
  {
    "task": "Write a script that automates browser actions using a browser automation library.",
    "code": "```fortran\nprogram browser_automation\n    use iso_c_binding\n    implicit none\n\n    interface\n        subroutine initialize_browser() bind(c, name='initialize_browser')\n        end subroutine initialize_browser\n        subroutine open_url(url) bind(c, name='open_url')\n            use iso_c_binding\n            character(kind=c_char), dimension(*) :: url\n        end subroutine open_url\n        subroutine click_element(selector) bind(c, name='click_element')\n            use iso_c_binding\n            character(kind=c_char), dimension(*) :: selector\n        end subroutine click_element\n        subroutine close_browser() bind(c, name='close_browser')\n        end subroutine close_browser\n    end interface\n\n    call initialize_browser()\n    call open_url('http://example.com'//c_null_char)\n    call click_element('#submit-button'//c_null_char)\n    call close_browser()\nend program browser_automation\n```"
  },
  {
    "task": "Use a library to implement data serialization and deserialization in your application.",
    "code": "```fortran\nprogram serialization_example\n    use iso_c_binding\n    use, intrinsic :: iso_fortran_env, only: int32, int64, real64\n    implicit none\n\n    ! Declare a derived type for serialization\n    type :: Employee\n        integer(int32) :: id\n        character(len=100) :: name\n        real(real64) :: salary\n    end type Employee\n\n    ! Declare an example employee\n    type(Employee) :: emp\n\n    ! Assume intrinsic library procedures for serialization/deserialization\n    call serialize(emp)\n    call deserialize(emp)\n\ncontains\n\n    ! Mockup serialization procedure\n    subroutine serialize(emp)\n        type(Employee), intent(in) :: emp\n        ! Serialization logic here (e.g., convert to JSON/XML)\n    end subroutine serialize\n\n    ! Mockup deserialization procedure\n    subroutine deserialize(emp)\n        type(Employee), intent(out) :: emp\n        ! Deserialization logic here (e.g., parse JSON/XML)\n    end subroutine deserialize\n\nend program serialization_example\n```"
  },
  {
    "task": "Build an application that generates interactive reports using a library for data visualization.",
    "code": "```fortran\nprogram interactive_reports\n    use, intrinsic :: iso_c_binding\n    implicit none\n\n    ! Declare variables\n    integer :: ierr\n    real, dimension(:), allocatable :: data_x, data_y\n\n    ! Initialize data\n    call generate_data(data_x, data_y)\n\n    ! Initialize the visualization library\n    call initialize_visualization_library(ierr)\n    if (ierr /= 0) stop \"Error initializing visualization library\"\n\n    ! Create an interactive report\n    call create_interactive_report(data_x, data_y, ierr)\n    if (ierr /= 0) stop \"Error creating interactive report\"\n\n    ! Finalize the visualization library\n    call finalize_visualization_library(ierr)\n    if (ierr /= 0) stop \"Error finalizing visualization library\"\n\ncontains\n\n    subroutine generate_data(x, y)\n        real, dimension(:), allocatable, intent(out) :: x, y\n        integer :: i, n\n\n        n = 100\n        allocate(x(n), y(n))\n        do i = 1, n\n            x(i) = real(i)\n            y(i) = sin(real(i) * 0.1)\n        end do\n    end subroutine generate_data\n\n    subroutine initialize_visualization_library(ierr)\n        integer, intent(out) :: ierr\n        ! Placeholder for library initialization\n        ierr = 0\n    end subroutine initialize_visualization_library\n\n    subroutine create_interactive_report(x, y, ierr)\n        real, dimension(:), intent(in) :: x, y\n        integer, intent(out) :: ierr\n        ! Placeholder for report creation using the library\n        ierr = 0\n    end subroutine create_interactive_report\n\n    subroutine finalize_visualization_library(ierr)\n        integer, intent(out) :: ierr\n        ! Placeholder for library finalization\n        ierr = 0\n    end subroutine finalize_visualization_library\n\nend program interactive_reports\n```"
  },
  {
    "task": "Create a system that backs up and restores data using a library for file system operations.",
    "code": "```fortran\nprogram BackupRestoreSystem\n    use, intrinsic :: iso_fortran_env, only: int8\n    implicit none\n    integer(int8) :: status\n\n    call backup_data('source_directory', 'backup.tar')\n    call restore_data('backup.tar', 'restore_directory')\n\ncontains\n\n    subroutine backup_data(source, backup_file)\n        character(len=*), intent(in) :: source, backup_file\n        character(len=255) :: command\n        command = 'tar -cvf ' // trim(backup_file) // ' ' // trim(source)\n        call execute_command_line(command, exitstat=status)\n        if (status /= 0) then\n            print *, \"Backup failed with status: \", status\n        else\n            print *, \"Backup successful.\"\n        end if\n    end subroutine backup_data\n\n    subroutine restore_data(backup_file, restore_dir)\n        character(len=*), intent(in) :: backup_file, restore_dir\n        character(len=255) :: command\n        command = 'tar -xvf ' // trim(backup_file) // ' -C ' // trim(restore_dir)\n        call execute_command_line(command, exitstat=status)\n        if (status /= 0) then\n            print *, \"Restore failed with status: \", status\n        else\n            print *, \"Restore successful.\"\n        end if\n    end subroutine restore_data\n\nend program BackupRestoreSystem\n```"
  },
  {
    "task": "Develop a feature that performs real-time language translation using a translation library.",
    "code": "```fortran\nprogram real_time_translation\n  use iso_c_binding\n  implicit none\n\n  interface\n    function translate_text(input_text, source_lang, target_lang) bind(c, name=\"translate_text\")\n      use iso_c_binding\n      character(kind=c_char), dimension(*), intent(in) :: input_text\n      character(kind=c_char), dimension(*), intent(in) :: source_lang\n      character(kind=c_char), dimension(*), intent(in) :: target_lang\n      character(kind=c_char), dimension(100) :: translate_text\n    end function translate_text\n  end interface\n\n  character(len=100) :: text, source, target, translated_text\n\n  text = 'Hello, world!'\n  source = 'en'\n  target = 'es'\n\n  translated_text = translate_text(trim(adjustl(text)//c_null_char), &\n                                   trim(adjustl(source)//c_null_char), &\n                                   trim(adjustl(target)//c_null_char))\n\n  print *, 'Translated Text: ', translated_text\n\nend program real_time_translation\n```"
  },
  {
    "task": "Implement a program that tracks stock market prices using a library for financial data retrieval.",
    "code": "```fortran\nprogram StockMarketTracker\n    use iso_c_binding\n    implicit none\n    interface\n        function get_stock_price(stock_symbol) bind(c, name=\"get_stock_price\")\n            use iso_c_binding\n            real(c_double) :: get_stock_price\n            character(kind=c_char), dimension(*) :: stock_symbol\n        end function get_stock_price\n    end interface\n\n    real(c_double) :: price\n    character(len=10) :: stock_symbol\n\n    stock_symbol = \"AAPL\"\n    price = get_stock_price(stock_symbol)\n\n    print *, \"Stock price for \", stock_symbol, \" is: \", price\n\nend program StockMarketTracker\n```"
  },
  {
    "task": "Write a script that generates and validates JSON Web Tokens using a library for JWT handling.",
    "code": "```fortran\nprogram jwt_example\n    use iso_c_binding\n    implicit none\n    type(c_ptr) :: jwt_lib, jwt, jwt_valid\n    interface\n        function jwt_new() bind(c, name=\"jwt_new\")\n            use iso_c_binding\n            type(c_ptr) :: jwt_new\n        end function jwt_new\n\n        function jwt_add_grant(jwt, key, value) bind(c, name=\"jwt_add_grant\")\n            use iso_c_binding\n            integer(c_int) :: jwt_add_grant\n            type(c_ptr), value :: jwt\n            character(kind=c_char), dimension(*), intent(in) :: key, value\n        end function jwt_add_grant\n\n        function jwt_encode_str(jwt) bind(c, name=\"jwt_encode_str\")\n            use iso_c_binding\n            type(c_ptr) :: jwt_encode_str\n            type(c_ptr), value :: jwt\n        end function jwt_encode_str\n\n        function jwt_free_str(str) bind(c, name=\"jwt_free_str\")\n            use iso_c_binding\n            integer(c_int) :: jwt_free_str\n            type(c_ptr), value :: str\n        end function jwt_free_str\n\n        function jwt_decode(jwt, token) bind(c, name=\"jwt_decode\")\n            use iso_c_binding\n            integer(c_int) :: jwt_decode\n            type(c_ptr), value :: jwt\n            character(kind=c_char), dimension(*), intent(in) :: token\n        end function jwt_decode\n    end interface\n\n    character(kind=c_char, dimension(100)) :: token\n    type(c_ptr) :: encoded_token\n\n    jwt_lib = c_null_ptr\n    jwt = jwt_new()\n    call jwt_add_grant(jwt, \"sub\" // c_null_char, \"1234567890\" // c_null_char)\n    call jwt_add_grant(jwt, \"name\" // c_null_char, \"John Doe\" // c_null_char)\n    call jwt_add_grant(jwt, \"admin\" // c_null_char, \"true\" // c_null_char)\n\n    encoded_token = jwt_encode_str(jwt)\n    if (encoded_token /= c_null_ptr) then\n        call c_f_pointer(encoded_token, token)\n        print *, \"Encoded JWT: \", token\n        call jwt_free_str(encoded_token)\n    endif\n\n    jwt_valid = jwt_new()\n    if (jwt_decode(jwt_valid, token) == 0) then\n        print *, \"JWT is valid\"\n    else\n        print *, \"JWT is invalid\"\n    endif\nend program jwt_example\n```"
  },
  {
    "task": "Use a library to build a feature that synchronizes data across multiple devices.",
    "code": "```fortran\nprogram data_synchronization\n    use mpi\n    implicit none\n\n    integer :: ierr, num_procs, rank, tag\n    integer, parameter :: root = 0\n    integer :: data(10), synchronized_data(10)\n    integer :: i\n\n    call MPI_Init(ierr)\n    call MPI_Comm_size(MPI_COMM_WORLD, num_procs, ierr)\n    call MPI_Comm_rank(MPI_COMM_WORLD, rank, ierr)\n\n    if (rank == root) then\n        ! Initialize data\n        do i = 1, 10\n            data(i) = i * 2\n        end do\n    end if\n\n    ! Broadcast data from root to all other processes\n    call MPI_Bcast(data, 10, MPI_INTEGER, root, MPI_COMM_WORLD, ierr)\n\n    ! Simulate synchronization processing\n    synchronized_data = data + rank\n\n    ! Gather synchronized data back to root\n    call MPI_Gather(synchronized_data, 10, MPI_INTEGER, synchronized_data, 10, MPI_INTEGER, root, MPI_COMM_WORLD, ierr)\n\n    if (rank == root) then\n        print *, \"Synchronized data across devices:\"\n        do i = 1, num_procs\n            print *, synchronized_data((i-1)*10+1:i*10)\n        end do\n    end if\n\n    call MPI_Finalize(ierr)\nend program data_synchronization\n```"
  },
  {
    "task": "Build a program that implements pattern recognition using a library for machine learning.",
    "code": "```fortran\nprogram pattern_recognition\n  use iso_c_binding\n  implicit none\n\n  interface\n    subroutine ml_initialize() bind(c, name='ml_initialize')\n    end subroutine ml_initialize\n\n    subroutine ml_train(data, labels, n_samples, n_features) bind(c, name='ml_train')\n      use iso_c_binding\n      real(c_double), dimension(*), intent(in) :: data\n      real(c_double), dimension(*), intent(in) :: labels\n      integer(c_int), value, intent(in) :: n_samples\n      integer(c_int), value, intent(in) :: n_features\n    end subroutine ml_train\n\n    subroutine ml_predict(data, n_samples, n_features, predictions) bind(c, name='ml_predict')\n      use iso_c_binding\n      real(c_double), dimension(*), intent(in) :: data\n      integer(c_int), value, intent(in) :: n_samples\n      integer(c_int), value, intent(in) :: n_features\n      real(c_double), dimension(*), intent(out) :: predictions\n    end subroutine ml_predict\n  end interface\n\n  real(c_double), dimension(6) :: train_data = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0]\n  real(c_double), dimension(2) :: train_labels = [0.0, 1.0]\n  real(c_double), dimension(3) :: test_data = [2.5, 3.5, 4.5]\n  real(c_double), dimension(1) :: predictions\n  integer(c_int) :: n_train_samples, n_test_samples, n_features\n\n  n_train_samples = 2\n  n_test_samples = 1\n  n_features = 3\n\n  call ml_initialize()\n  call ml_train(train_data, train_labels, n_train_samples, n_features)\n  call ml_predict(test_data, n_test_samples, n_features, predictions)\n\n  print *, \"Predictions: \", predictions\n\nend program pattern_recognition\n```"
  },
  {
    "task": "Create an email client that uses a library for IMAP and POP3 communication.",
    "code": "```fortran\nprogram email_client\n  use, intrinsic :: iso_c_binding\n  use imap_pop3_library\n\n  implicit none\n\n  type(c_ptr) :: imap_handle, pop3_handle\n  integer(c_int) :: status\n\n  ! Initialize IMAP and POP3 handles\n  imap_handle = imap_init()\n  pop3_handle = pop3_init()\n\n  ! Connect to IMAP server\n  status = imap_connect(imap_handle, \"imap.example.com\", 993, \"username\", \"password\")\n  if (status /= 0) then\n    print *, \"Failed to connect to IMAP server\"\n    stop\n  end if\n\n  ! Connect to POP3 server\n  status = pop3_connect(pop3_handle, \"pop3.example.com\", 995, \"username\", \"password\")\n  if (status /= 0) then\n    print *, \"Failed to connect to POP3 server\"\n    stop\n  end if\n\n  ! Fetch emails using IMAP\n  call imap_fetch_emails(imap_handle)\n\n  ! Fetch emails using POP3\n  call pop3_fetch_emails(pop3_handle)\n\n  ! Disconnect from servers\n  call imap_disconnect(imap_handle)\n  call pop3_disconnect(pop3_handle)\n\n  ! Clean up\n  call imap_cleanup(imap_handle)\n  call pop3_cleanup(pop3_handle)\n\nend program email_client\n```"
  },
  {
    "task": "Develop a feature that analyzes network traffic using a library for network monitoring.",
    "code": "```fortran\nprogram NetworkTrafficAnalyzer\n    use iso_c_binding\n    implicit none\n    interface\n        function pcap_open_live(device, snaplen, promisc, to_ms, errbuf) bind(C, name='pcap_open_live')\n            use iso_c_binding\n            implicit none\n            character(kind=c_char), dimension(*), intent(in) :: device\n            integer(c_int), value :: snaplen\n            integer(c_int), value :: promisc\n            integer(c_int), value :: to_ms\n            character(kind=c_char), dimension(*), intent(out) :: errbuf\n            type(c_ptr) :: pcap_open_live\n        end function pcap_open_live\n\n        subroutine pcap_close(p) bind(C, name='pcap_close')\n            use iso_c_binding\n            implicit none\n            type(c_ptr), value :: p\n        end subroutine pcap_close\n\n        function pcap_next(p, header) bind(C, name='pcap_next')\n            use iso_c_binding\n            implicit none\n            type(c_ptr), value :: p\n            type(c_ptr) :: pcap_next\n            integer(c_int), dimension(2), intent(out) :: header\n        end function pcap_next\n    end interface\n\n    character(len=100), parameter :: device = 'eth0'\n    character(kind=c_char), dimension(256) :: errbuf\n    type(c_ptr) :: handle\n    integer(c_int) :: header(2)\n    type(c_ptr) :: packet\n\n    handle = pcap_open_live(device//c_null_char, 65535_c_int, 1_c_int, 1000_c_int, errbuf)\n    if (c_associated(handle)) then\n        packet = pcap_next(handle, header)\n        if (c_associated(packet)) then\n            ! Analyze packet here\n        end if\n        call pcap_close(handle)\n    else\n        print *, 'Error opening device:', trim(adjustl(errbuf))\n    end if\nend program NetworkTrafficAnalyzer\n```"
  },
  {
    "task": "Implement a program that manages user authentication and authorization using a security library.",
    "code": "```fortran\nprogram authentication\n    use iso_c_binding\n    implicit none\n\n    interface\n        function init_security() bind(c, name='init_security')\n            import :: c_int\n            integer(c_int) :: init_security\n        end function init_security\n\n        function authenticate_user(username, password) bind(c, name='authenticate_user')\n            import :: c_char, c_int\n            character(kind=c_char), dimension(*), intent(in) :: username\n            character(kind=c_char), dimension(*), intent(in) :: password\n            integer(c_int) :: authenticate_user\n        end function authenticate_user\n\n        function authorize_user(token) bind(c, name='authorize_user')\n            import :: c_char, c_int\n            character(kind=c_char), dimension(*), intent(in) :: token\n            integer(c_int) :: authorize_user\n        end function authorize_user\n    end interface\n\n    integer :: status\n    character(len=256) :: username, password, token\n\n    ! Initialize the security library\n    status = init_security()\n    if (status /= 0) stop \"Failed to initialize security library\"\n\n    ! Example user credentials\n    username = \"user1\"\n    password = \"securepassword\"\n\n    ! Authenticate the user\n    status = authenticate_user(username, password)\n    if (status /= 0) stop \"Authentication failed\"\n\n    ! Assume token is received after authentication\n    token = \"example_token\"\n\n    ! Authorize the user\n    status = authorize_user(token)\n    if (status /= 0) stop \"Authorization failed\"\n\n    print *, \"User authenticated and authorized successfully.\"\n\nend program authentication\n```"
  },
  {
    "task": "Write a script that generates word clouds from text data using a library for text visualization.",
    "code": "```fortran\nprogram word_cloud\n    use, intrinsic :: iso_c_binding\n    implicit none\n\n    interface\n        subroutine generate_word_cloud(text) bind(c, name=\"generate_word_cloud\")\n            import :: c_char\n            character(kind=c_char), dimension(*) :: text\n        end subroutine generate_word_cloud\n    end interface\n\n    character(len=256) :: input_text\n\n    print *, 'Enter text data:'\n    read(*, '(A)') input_text\n\n    call generate_word_cloud(trim(adjustl(input_text))//char(0_c_char))\n\nend program word_cloud\n```"
  },
  {
    "task": "Use a library to create a feature that schedules and sends automated emails.",
    "code": "```fortran\nprogram email_scheduler\n  use, intrinsic :: iso_c_binding\n  implicit none\n\n  interface\n     subroutine send_email(to, subject, message) bind(c, name=\"send_email\")\n       import :: c_char\n       character(kind=c_char), dimension(*) :: to, subject, message\n     end subroutine send_email\n  end interface\n\n  character(len=256) :: recipient, email_subject, email_message\n\n  recipient = \"example@example.com\"\n  email_subject = \"Scheduled Email\"\n  email_message = \"This is an automated email sent by Fortran.\"\n\n  call send_email(recipient, email_subject, email_message)\n\ncontains\n\n  ! Note: The actual implementation of send_email would require linking\n  ! with a C library that handles email sending, which is not included here.\n\nend program email_scheduler\n```"
  },
  {
    "task": "Build a mobile application that accesses device sensors using a library for hardware interaction.",
    "code": "```fortran\nprogram MobileSensorApp\n  use iso_c_binding\n  implicit none\n\n  interface\n    integer(c_int) function init_hardware() bind(c, name='init_hardware')\n    end function init_hardware\n\n    integer(c_int) function read_sensor_data() bind(c, name='read_sensor_data')\n    end function read_sensor_data\n  end interface\n\n  integer(c_int) :: status\n  integer(c_int) :: sensor_data\n\n  status = init_hardware()\n  if (status /= 0) then\n    print *, 'Failed to initialize hardware'\n    stop\n  end if\n\n  do\n    sensor_data = read_sensor_data()\n    print *, 'Sensor Data: ', sensor_data\n    ! Add delay or condition to break loop if needed\n  end do\n\nend program MobileSensorApp\n```"
  },
  {
    "task": "Create a system that audits and logs file system changes using a library for filesystem monitoring.",
    "code": "```fortran\nprogram filesystem_audit\n    use iso_c_binding\n    implicit none\n\n    interface\n        subroutine inotify_init() bind(C, name=\"inotify_init\")\n            use iso_c_binding\n            integer(c_int) :: inotify_init\n        end subroutine inotify_init\n\n        subroutine inotify_add_watch(fd, pathname, mask) bind(C, name=\"inotify_add_watch\")\n            use iso_c_binding\n            integer(c_int), value :: fd\n            character(kind=c_char), dimension(*) :: pathname\n            integer(c_int), value :: mask\n            integer(c_int) :: inotify_add_watch\n        end subroutine inotify_add_watch\n\n        subroutine inotify_rm_watch(fd, wd) bind(C, name=\"inotify_rm_watch\")\n            use iso_c_binding\n            integer(c_int), value :: fd\n            integer(c_int), value :: wd\n            integer(c_int) :: inotify_rm_watch\n        end subroutine inotify_rm_watch\n\n        subroutine read(fd, buf, count) bind(C, name=\"read\")\n            use iso_c_binding\n            integer(c_int), value :: fd\n            type(c_ptr), value :: buf\n            integer(c_size_t), value :: count\n            integer(c_ssize_t) :: read\n        end subroutine read\n    end interface\n\n    integer(c_int) :: fd, wd\n    integer(c_int), parameter :: buf_size = 1024\n    character(len=buf_size) :: buffer\n    integer(c_int) :: num_bytes\n    character(len=100) :: path\n\n    fd = inotify_init()\n    if (fd < 0) stop \"Failed to initialize inotify\"\n\n    path = \"/path/to/monitor\"\n    wd = inotify_add_watch(fd, path, 15)  ! IN_MODIFY | IN_CREATE | IN_DELETE\n\n    if (wd < 0) stop \"Failed to add watch\"\n\n    do\n        num_bytes = read(fd, c_loc(buffer), buf_size)\n        if (num_bytes > 0) then\n            print*, \"Filesystem change detected: \", trim(buffer)\n        end if\n    end do\n\n    call inotify_rm_watch(fd, wd)\nend program filesystem_audit\n```"
  },
  {
    "task": "Develop a feature that visualizes geospatial data using a library for geographic information systems.",
    "code": "```fortran\nprogram geospatial_visualization\n  use iso_c_binding\n  implicit none\n\n  ! Import required GIS library\n  interface\n    subroutine plot_geospatial_data() bind(c, name=\"plot_geospatial_data\")\n    end subroutine plot_geospatial_data\n  end interface\n\n  ! Main program execution\n  call plot_geospatial_data()\n\nend program geospatial_visualization\n```"
  },
  {
    "task": "Implement a program that performs clustering analysis using a library for statistical computing.",
    "code": "```fortran\nprogram clustering_analysis\n  use iso_c_binding\n  implicit none\n\n  ! Declare variables\n  integer :: n, k, i, j\n  real(c_double), dimension(:,:), allocatable :: data, clusters\n  real(c_double), dimension(:), allocatable :: means\n\n  ! Initialize number of points and clusters\n  n = 100\n  k = 3\n\n  ! Allocate and initialize data and cluster arrays\n  allocate(data(n, 2))\n  allocate(clusters(k, 2))\n  allocate(means(k))\n\n  ! Initialize data (dummy data for demonstration)\n  call random_number(data)\n\n  ! Perform clustering analysis using a library (e.g., LAPACK)\n  ! For demonstration, we use a simple k-means like approach\n\n  ! Initial cluster centers (random selection from data points)\n  call random_number(means)\n  do i = 1, k\n     clusters(i, :) = data(int(means(i) * n), :)\n  end do\n\n  ! Simple iterative algorithm to update clusters\n  do i = 1, 10\n     ! Assign points to nearest cluster\n     ! Update cluster centers (means)\n     ! For simplicity, this part is omitted\n  end do\n\n  ! Deallocate arrays\n  deallocate(data)\n  deallocate(clusters)\n  deallocate(means)\n\nend program clustering_analysis\n```"
  },
  {
    "task": "Write a script that monitors and analyzes CPU and memory usage using a library for system diagnostics.",
    "code": "```fortran\nprogram system_monitor\n    use iso_c_binding\n    implicit none\n\n    interface\n        subroutine get_cpu_usage(cpu_usage) bind(c, name='get_cpu_usage')\n            use iso_c_binding\n            real(c_double), intent(out) :: cpu_usage\n        end subroutine get_cpu_usage\n\n        subroutine get_memory_usage(mem_usage) bind(c, name='get_memory_usage')\n            use iso_c_binding\n            real(c_double), intent(out) :: mem_usage\n        end subroutine get_memory_usage\n    end interface\n\n    real(c_double) :: cpu_usage, mem_usage\n\n    call get_cpu_usage(cpu_usage)\n    call get_memory_usage(mem_usage)\n\n    print *, \"CPU Usage: \", cpu_usage, \"%\"\n    print *, \"Memory Usage: \", mem_usage, \"MB\"\n\nend program system_monitor\n```"
  },
  {
    "task": "Use a library to implement a feature that provides voice commands in your application.",
    "code": "```fortran\nprogram voice_command\n  use iso_c_binding\n  use voice_library\n  implicit none\n\n  integer(c_int) :: status\n  character(len=100) :: command\n\n  call initialize_voice_library()\n\n  print *, \"Speak your command:\"\n  status = get_voice_command(command)\n\n  if (status == 0) then\n     print *, \"You said:\", trim(command)\n  else\n     print *, \"Error capturing voice command\"\n  end if\n\n  call finalize_voice_library()\n\ncontains\n\n  subroutine initialize_voice_library()\n    ! Call library initialization function\n    call voice_library_initialize()\n  end subroutine initialize_voice_library\n\n  subroutine finalize_voice_library()\n    ! Call library finalization function\n    call voice_library_finalize()\n  end subroutine finalize_voice_library\n\n  integer(c_int) function get_voice_command(command)\n    character(len=100), intent(out) :: command\n    ! Interface with library to capture voice command\n    call voice_library_capture(command, get_voice_command)\n  end function get_voice_command\n\nend program voice_command\n```"
  },
  {
    "task": "Build a tool that converts video files to different resolutions using a video processing library.",
    "code": "```fortran\nprogram VideoConverter\n    use ISO_C_BINDING\n    implicit none\n    interface\n        subroutine init_video_library() bind(C, name=\"init_video_library\")\n        end subroutine init_video_library\n        subroutine load_video(fileName) bind(C, name=\"load_video\")\n            import\n            character(kind=C_CHAR), dimension(*), intent(in) :: fileName\n        end subroutine load_video\n        subroutine convert_resolution(width, height) bind(C, name=\"convert_resolution\")\n            import\n            integer(C_INT), value :: width, height\n        end subroutine convert_resolution\n        subroutine save_video(outputFileName) bind(C, name=\"save_video\")\n            import\n            character(kind=C_CHAR), dimension(*), intent(in) :: outputFileName\n        end subroutine save_video\n    end interface\n\n    character(kind=C_CHAR, len=100) :: inputFile, outputFile\n    integer(C_INT) :: newWidth, newHeight\n\n    inputFile = \"input.mp4\"C\n    outputFile = \"output.mp4\"C\n    newWidth = 1280\n    newHeight = 720\n\n    call init_video_library()\n    call load_video(inputFile)\n    call convert_resolution(newWidth, newHeight)\n    call save_video(outputFile)\nend program VideoConverter\n```"
  },
  {
    "task": "Create a program that detects and classifies objects in images using a library for image recognition.",
    "code": "```fortran\nprogram image_recognition\n    use, intrinsic :: iso_c_binding\n    implicit none\n\n    interface\n        subroutine load_image(filename, image) bind(C, name=\"load_image\")\n            import :: c_char, c_ptr\n            character(kind=c_char), dimension(*) :: filename\n            type(c_ptr) :: image\n        end subroutine load_image\n\n        subroutine detect_objects(image, objects) bind(C, name=\"detect_objects\")\n            import :: c_ptr\n            type(c_ptr), value :: image\n            type(c_ptr) :: objects\n        end subroutine detect_objects\n\n        subroutine classify_objects(objects) bind(C, name=\"classify_objects\")\n            import :: c_ptr\n            type(c_ptr), value :: objects\n        end subroutine classify_objects\n    end interface\n\n    character(len=256) :: image_file\n    type(c_ptr) :: image, objects\n\n    ! Initialize the image file path\n    image_file = 'path/to/image.jpg' // c_null_char\n\n    ! Load the image\n    call load_image(image_file, image)\n\n    ! Detect objects in the image\n    call detect_objects(image, objects)\n\n    ! Classify the detected objects\n    call classify_objects(objects)\n\nend program image_recognition\n```"
  },
  {
    "task": "Develop a feature that generates synthetic test data using a data generation library.",
    "code": "```fortran\nprogram synthetic_data_generation\n  use, intrinsic :: iso_fortran_env, only: int32\n  use random_number_generator\n  implicit none\n\n  integer(int32) :: i, n\n  real(real32), allocatable :: data(:)\n\n  ! Initialize the random number generator\n  call random_seed()\n\n  ! Number of data points to generate\n  n = 100\n\n  ! Allocate array\n  allocate(data(n))\n\n  ! Generate synthetic test data\n  call generate_synthetic_data(data, n)\n\n  ! Output generated data\n  do i = 1, n\n    print *, data(i)\n  end do\n\ncontains\n\n  subroutine generate_synthetic_data(data_array, size)\n    real(real32), intent(out) :: data_array(:)\n    integer(int32), intent(in) :: size\n    integer(int32) :: i\n\n    ! Generate random data\n    do i = 1, size\n      call random_number(data_array(i))\n    end do\n  end subroutine generate_synthetic_data\n\nend program synthetic_data_generation\n```"
  },
  {
    "task": "Implement a script that interacts with IoT devices using a library for IoT communication.",
    "code": "```fortran\nprogram IoTCommunication\n  use IoTLibrary\n  implicit none\n\n  integer :: deviceID\n  character(len=100) :: message\n  logical :: status\n\n  call InitializeIoT()\n\n  deviceID = GetDeviceID(\"sensor01\")\n  call ConnectToDevice(deviceID, status)\n  \n  if (status) then\n    call SendMessage(deviceID, \"Turn on\")\n    call ReceiveMessage(deviceID, message)\n    print *, \"Received message: \", trim(message)\n  else\n    print *, \"Failed to connect to device.\"\n  end if\n\n  call DisconnectDevice(deviceID)\n  call FinalizeIoT()\nend program IoTCommunication\n```"
  },
  {
    "task": "Write a program that compresses and decompresses data using a data compression library.",
    "code": "```fortran\nprogram compress_decompress\n    use iso_c_binding\n    implicit none\n\n    interface\n        function compress(data, data_len, compressed, compressed_len) bind(c, name='compress')\n            use iso_c_binding\n            integer(c_int) :: compress\n            integer(c_char), dimension(*) :: data\n            integer(c_size_t), value :: data_len\n            integer(c_char), dimension(*) :: compressed\n            integer(c_size_t), value :: compressed_len\n        end function compress\n\n        function decompress(compressed, compressed_len, data, data_len) bind(c, name='decompress')\n            use iso_c_binding\n            integer(c_int) :: decompress\n            integer(c_char), dimension(*) :: compressed\n            integer(c_size_t), value :: compressed_len\n            integer(c_char), dimension(*) :: data\n            integer(c_size_t), value :: data_len\n        end function decompress\n    end interface\n\n    character(kind=c_char), dimension(:), allocatable :: data, compressed, decompressed\n    integer(c_size_t) :: data_len, compressed_len, decompressed_len\n    integer(c_int) :: status\n\n    ! Allocate and initialize data\n    data_len = 100\n    allocate(character(kind=c_char) :: data(data_len))\n    data = \"This is the original data that needs to be compressed.\"\n\n    ! Allocate compressed data array\n    compressed_len = 200\n    allocate(character(kind=c_char) :: compressed(compressed_len))\n\n    ! Compress the data\n    status = compress(data, data_len, compressed, compressed_len)\n\n    ! Allocate decompressed data array\n    decompressed_len = 100\n    allocate(character(kind=c_char) :: decompressed(decompressed_len))\n\n    ! Decompress the data\n    status = decompress(compressed, compressed_len, decompressed, decompressed_len)\n\n    ! Deallocate arrays\n    deallocate(data, compressed, decompressed)\nend program compress_decompress\n```"
  },
  {
    "task": "Use a library to implement a feature that generates dynamic web content from templates.",
    "code": "```fortran\nprogram generate_dynamic_web_content\n    use, intrinsic :: iso_c_binding\n    use :: my_template_library\n    implicit none\n\n    type(c_ptr) :: template, output\n    character(len=255) :: template_file, content\n\n    ! Initialize the template library\n    call init_template_library()\n\n    ! Load the template from a file\n    template_file = 'template.html'\n    template = load_template(template_file)\n\n    ! Generate dynamic content\n    output = generate_content(template)\n\n    ! Convert output to a Fortran string\n    call c_f_pointer(output, content)\n\n    ! Display or use the generated content\n    print *, 'Generated Content: ', trim(content)\n\n    ! Cleanup\n    call destroy_template(template)\n    call finalize_template_library()\nend program generate_dynamic_web_content\n```"
  },
  {
    "task": "Build an application that integrates with social media platforms using a library for API communication.",
    "code": "```fortran\nprogram social_media_integration\n    use iso_c_binding\n    implicit none\n\n    interface\n        subroutine init_social_media_lib() bind(c, name=\"init_social_media_lib\")\n        end subroutine init_social_media_lib\n\n        subroutine send_message(api_key, message) bind(c, name=\"send_message\")\n            import :: c_char\n            character(kind=c_char), value :: api_key(*)\n            character(kind=c_char), value :: message(*)\n        end subroutine send_message\n    end interface\n\n    ! Initialize the social media library\n    call init_social_media_lib()\n\n    ! Define the API key and message to be sent\n    character(len=100), parameter :: api_key = \"your_api_key_here\"\n    character(len=256), parameter :: message = \"Hello from Fortran!\"\n\n    ! Send a message using the social media API\n    call send_message(api_key, message)\n\nend program social_media_integration\n```"
  }
]