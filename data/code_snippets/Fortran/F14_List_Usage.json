[
  {
    "task": "Create a list of the first ten positive integers and calculate their sum.",
    "code": "```fortran\nprogram sum_of_integers\n    implicit none\n    integer, dimension(10) :: numbers\n    integer :: i, total\n\n    ! Initialize the list with the first ten positive integers\n    do i = 1, 10\n        numbers(i) = i\n    end do\n\n    ! Calculate the sum of the list\n    total = sum(numbers)\n\n    ! Output the result\n    print *, \"The sum of the first ten positive integers is:\", total\nend program sum_of_integers\n```"
  },
  {
    "task": "Write a program to reverse the order of elements in a given list.",
    "code": "```fortran\nprogram reverse_list\n    implicit none\n    integer, parameter :: n = 5\n    integer :: original_list(n) = [1, 2, 3, 4, 5]\n    integer :: reversed_list(n)\n    integer :: i\n\n    do i = 1, n\n        reversed_list(i) = original_list(n - i + 1)\n    end do\n\n    print *, \"Original list: \", original_list\n    print *, \"Reversed list: \", reversed_list\nend program reverse_list\n```"
  },
  {
    "task": "Implement a function that takes a list and returns the list with duplicates removed.",
    "code": "```fortran\nmodule list_utils\n  implicit none\ncontains\n\n  function remove_duplicates(arr) result(unique_arr)\n    integer, dimension(:), intent(in) :: arr\n    integer, dimension(:), allocatable :: unique_arr\n    integer :: i, num_unique, n\n    integer, dimension(:), allocatable :: temp_arr\n\n    n = size(arr)\n    allocate(temp_arr(n))\n    num_unique = 0\n\n    do i = 1, n\n      if (.not. any(temp_arr(1:num_unique) == arr(i))) then\n        num_unique = num_unique + 1\n        temp_arr(num_unique) = arr(i)\n      end if\n    end do\n\n    allocate(unique_arr(num_unique))\n    unique_arr = temp_arr(1:num_unique)\n\n  end function remove_duplicates\n\nend module list_utils\n```"
  },
  {
    "task": "Create a list of names and sort them in alphabetical order.",
    "code": "```fortran\nprogram sort_names\n    implicit none\n    character(len=20), dimension(5) :: names\n    integer :: i, j\n    character(len=20) :: temp\n\n    ! Initialize the list of names\n    names = ['Charlie', 'Alice', 'Bob', 'David', 'Eve']\n\n    ! Sort the names in alphabetical order using a simple bubble sort\n    do i = 1, size(names) - 1\n        do j = 1, size(names) - i\n            if (names(j) > names(j+1)) then\n                temp = names(j)\n                names(j) = names(j+1)\n                names(j+1) = temp\n            end if\n        end do\n    end do\n\n    ! Print the sorted list of names\n    do i = 1, size(names)\n        print *, names(i)\n    end do\nend program sort_names\n```"
  },
  {
    "task": "Write a function that appends a new element to an existing list.",
    "code": "```fortran\nmodule list_module\n    implicit none\ncontains\n    subroutine append_element(list, new_element)\n        integer, allocatable, intent(inout) :: list(:)\n        integer, intent(in) :: new_element\n        integer, allocatable :: temp(:)\n        integer :: n\n\n        n = size(list)\n        allocate(temp(n + 1))\n        temp(1:n) = list\n        temp(n + 1) = new_element\n        deallocate(list)\n        allocate(list(n + 1))\n        list = temp\n        deallocate(temp)\n    end subroutine append_element\nend module list_module\n```"
  },
  {
    "task": "Generate a list of the first 20 even numbers.",
    "code": "```fortran\nprogram even_numbers\n    implicit none\n    integer, dimension(20) :: even_list\n    integer :: i\n\n    do i = 1, 20\n        even_list(i) = 2 * i\n    end do\n\n    print *, even_list\nend program even_numbers\n```"
  },
  {
    "task": "Create a nested list (a list of lists) and access an element from the inner list.",
    "code": "```fortran\nprogram nested_list_example\n    implicit none\n    integer, dimension(2, 2) :: nested_list\n    integer :: element\n\n    ! Initialize the nested list\n    nested_list(1, 1) = 1\n    nested_list(1, 2) = 2\n    nested_list(2, 1) = 3\n    nested_list(2, 2) = 4\n\n    ! Access an element from the inner list\n    element = nested_list(2, 1)  ! Accessing the first element of the second inner list\n\n    print *, 'The accessed element is: ', element\nend program nested_list_example\n```"
  },
  {
    "task": "Write a program that finds the maximum value in a list of integers.",
    "code": "```fortran\nprogram find_max_in_list\n    implicit none\n    integer, parameter :: n = 10\n    integer :: i, max_value\n    integer, dimension(n) :: list\n\n    ! Initialize the list with some values\n    list = (/ 5, 3, 8, 2, 9, 1, 7, 6, 4, 0 /)\n\n    ! Assume the first element is the maximum\n    max_value = list(1)\n\n    ! Iterate through the list to find the maximum value\n    do i = 2, n\n        if (list(i) > max_value) then\n            max_value = list(i)\n        end if\n    end do\n\n    ! Output the result\n    print *, 'The maximum value in the list is:', max_value\nend program find_max_in_list\n```"
  },
  {
    "task": "Implement a function to merge two lists into a single list without duplicates.",
    "code": "```fortran\nprogram merge_lists\n    implicit none\n    integer, allocatable :: list1(:), list2(:), merged_list(:)\n    integer :: n1, n2\n\n    ! Example lists\n    list1 = [1, 2, 3, 4]\n    list2 = [3, 4, 5, 6]\n\n    call merge_without_duplicates(list1, list2, merged_list)\n\n    print *, \"Merged list without duplicates:\", merged_list\n\ncontains\n\n    subroutine merge_without_duplicates(l1, l2, merged)\n        integer, intent(in) :: l1(:), l2(:)\n        integer, allocatable, intent(out) :: merged(:)\n        integer :: i, j, size_merged, num\n\n        size_merged = 0\n        allocate(merged(size(l1) + size(l2)))\n\n        ! Add elements from the first list\n        do i = 1, size(l1)\n            if (.not. any(merged(1:size_merged) == l1(i))) then\n                size_merged = size_merged + 1\n                merged(size_merged) = l1(i)\n            end if\n        end do\n\n        ! Add elements from the second list\n        do i = 1, size(l2)\n            if (.not. any(merged(1:size_merged) == l2(i))) then\n                size_merged = size_merged + 1\n                merged(size_merged) = l2(i)\n            end if\n        end do\n\n        ! Resize the merged list to remove uninitialized elements\n        call move_alloc(merged(1:size_merged), merged)\n    end subroutine merge_without_duplicates\n\nend program merge_lists\n```"
  },
  {
    "task": "Create a list from user input, then display the list in reverse order.",
    "code": "```fortran\nprogram reverse_list\n    implicit none\n    integer, allocatable :: list(:)\n    integer :: i, n\n\n    print *, \"Enter the number of elements:\"\n    read *, n\n    allocate(list(n))\n\n    print *, \"Enter the elements:\"\n    do i = 1, n\n        read *, list(i)\n    end do\n\n    print *, \"List in reverse order:\"\n    do i = n, 1, -1\n        print *, list(i)\n    end do\n\n    deallocate(list)\nend program reverse_list\n```"
  },
  {
    "task": "Write a function that takes a list and returns a new list containing only the even numbers.",
    "code": "```fortran\nmodule list_utils\n  implicit none\ncontains\n  function filter_even_numbers(input_list) result(even_list)\n    integer, dimension(:), intent(in) :: input_list\n    integer, allocatable, dimension(:) :: even_list\n    integer :: i, count\n\n    count = count(input_list == 0 .or. mod(input_list, 2) == 0)\n    allocate(even_list(count))\n\n    count = 1\n    do i = 1, size(input_list)\n      if (input_list(i) == 0 .or. mod(input_list(i), 2) == 0) then\n        even_list(count) = input_list(i)\n        count = count + 1\n      end if\n    end do\n  end function filter_even_numbers\nend module list_utils\n```"
  },
  {
    "task": "Generate a list of squares for the numbers 1 through 10.",
    "code": "```fortran\nprogram list_of_squares\n    implicit none\n    integer, dimension(10) :: squares\n    integer :: i\n\n    do i = 1, 10\n        squares(i) = i * i\n    end do\n\n    print *, squares\nend program list_of_squares\n```"
  },
  {
    "task": "Create a list of floating-point numbers and find their average.",
    "code": "```fortran\nprogram average_of_list\n    implicit none\n    real, dimension(:), allocatable :: float_list\n    real :: sum\n    integer :: i, n\n\n    n = 5\n    allocate(float_list(n))\n    float_list = [1.0, 2.5, 3.0, 4.5, 5.0]\n\n    sum = 0.0\n    do i = 1, n\n        sum = sum + float_list(i)\n    end do\n\n    print *, \"Average:\", sum / n\n\n    deallocate(float_list)\nend program average_of_list\n```"
  },
  {
    "task": "Implement a program to rotate the elements of a list to the right by a given number of steps.",
    "code": "```fortran\nprogram rotate_list\n    implicit none\n    integer, parameter :: n = 5\n    integer, dimension(n) :: list\n    integer :: steps, i, temp\n\n    ! Initialize the list and steps\n    list = (/ 1, 2, 3, 4, 5 /)\n    steps = 2\n\n    ! Perform the rotation\n    do i = 1, steps\n        temp = list(n)\n        list(2:n) = list(1:n-1)\n        list(1) = temp\n    end do\n\n    ! Output the rotated list\n    print *, list\nend program rotate_list\n```"
  },
  {
    "task": "Write a function that checks if a list is a palindrome (reads the same forwards and backwards).",
    "code": "```fortran\nmodule palindrome_module\n    implicit none\ncontains\n    logical function is_palindrome(list)\n        integer, dimension(:), intent(in) :: list\n        integer :: n, i\n\n        n = size(list)\n        is_palindrome = .true.\n\n        do i = 1, n / 2\n            if (list(i) /= list(n - i + 1)) then\n                is_palindrome = .false.\n                return\n            end if\n        end do\n    end function is_palindrome\nend module palindrome_module\n```"
  },
  {
    "task": "Create a list of random integers and count how many are greater than 50.",
    "code": "```fortran\nprogram count_greater_than_50\n    implicit none\n    integer, parameter :: n = 100\n    integer :: i, count\n    integer, dimension(n) :: random_integers\n\n    call random_seed()\n    call random_number(random_integers)\n    random_integers = int(random_integers * 100)\n\n    count = 0\n    do i = 1, n\n        if (random_integers(i) > 50) then\n            count = count + 1\n        end if\n    end do\n\n    print *, \"Number of integers greater than 50:\", count\nend program count_greater_than_50\n```"
  },
  {
    "task": "Write a program that removes the first occurrence of a specified element from a list.",
    "code": "```fortran\nprogram remove_element\n    implicit none\n    integer, allocatable :: list(:)\n    integer :: i, n, element, position\n\n    ! Sample list and element to remove\n    list = [1, 2, 3, 4, 5, 6, 3, 7]\n    element = 3\n\n    ! Find the position of the first occurrence of the element\n    position = -1\n    do i = 1, size(list)\n        if (list(i) == element) then\n            position = i\n            exit\n        end if\n    end do\n\n    ! Remove the element if found\n    if (position /= -1) then\n        list = [list(1:position-1), list(position+1:)]\n    end if\n\n    ! Output the modified list\n    do i = 1, size(list)\n        print *, list(i)\n    end do\n\nend program remove_element\n```"
  },
  {
    "task": "Implement a function that takes two lists and returns a list containing their intersection.",
    "code": "```fortran\nprogram list_intersection\n    implicit none\n    integer, allocatable :: list1(:), list2(:), result(:)\n    integer :: n, m\n\n    ! Example lists\n    list1 = [1, 2, 3, 4, 5]\n    list2 = [3, 4, 5, 6, 7]\n\n    result = intersection(list1, list2)\n\n    print *, \"Intersection: \", result\ncontains\n\n    function intersection(list1, list2) result(intersect)\n        integer, intent(in) :: list1(:), list2(:)\n        integer, allocatable :: intersect(:)\n        integer :: i, j, k\n\n        allocate(intersect(min(size(list1), size(list2))))\n        k = 0\n        do i = 1, size(list1)\n            do j = 1, size(list2)\n                if (list1(i) == list2(j)) then\n                    if (.not. any(intersect(1:k) == list1(i))) then\n                        k = k + 1\n                        intersect(k) = list1(i)\n                    end if\n                end if\n            end do\n        end do\n        if (k > 0) then\n            intersect = intersect(1:k)\n        else\n            deallocate(intersect)\n            allocate(intersect(0))\n        end if\n    end function intersection\n\nend program list_intersection\n```"
  },
  {
    "task": "Create a list of prime numbers less than 100.",
    "code": "```fortran\nprogram prime_list\n    implicit none\n    integer, parameter :: nmax = 100\n    integer :: n, i, j\n    logical :: is_prime\n    integer, allocatable :: primes(:)\n    \n    allocate(primes(nmax))\n    n = 0\n\n    do i = 2, nmax-1\n        is_prime = .true.\n        do j = 2, int(sqrt(real(i)))\n            if (mod(i, j) == 0) then\n                is_prime = .false.\n                exit\n            end if\n        end do\n        if (is_prime) then\n            n = n + 1\n            primes(n) = i\n        end if\n    end do\n    \n    if (n > 0) then\n        print *, \"Prime numbers less than 100:\"\n        print *, primes(:n)\n    end if\n\n    deallocate(primes)\nend program prime_list\n```"
  },
  {
    "task": "Write a function to split a list into two lists: one with even numbers and one with odd numbers.",
    "code": "```fortran\nmodule list_splitter\n  implicit none\ncontains\n\n  subroutine split_even_odd(input_list, even_list, odd_list)\n    integer, intent(in) :: input_list(:)\n    integer, allocatable, intent(out) :: even_list(:), odd_list(:)\n    integer :: i, even_count, odd_count\n\n    even_count = count(mod(input_list, 2) == 0)\n    odd_count = size(input_list) - even_count\n\n    allocate(even_list(even_count))\n    allocate(odd_list(odd_count))\n\n    even_count = 0\n    odd_count = 0\n    do i = 1, size(input_list)\n      if (mod(input_list(i), 2) == 0) then\n        even_count = even_count + 1\n        even_list(even_count) = input_list(i)\n      else\n        odd_count = odd_count + 1\n        odd_list(odd_count) = input_list(i)\n      end if\n    end do\n  end subroutine split_even_odd\n\nend module list_splitter\n```"
  },
  {
    "task": "Create a list of strings and convert all the strings to uppercase.",
    "code": "```fortran\nprogram uppercase_list\n    implicit none\n    character(len=20), dimension(3) :: str_list\n    integer :: i\n\n    str_list = ['hello', 'world', 'fortran']\n\n    do i = 1, size(str_list)\n        str_list(i) = adjustl(upcase(str_list(i)))\n    end do\n\n    print *, str_list\nend program uppercase_list\n```"
  },
  {
    "task": "Implement a program that removes all elements from a list that are less than a specified value.",
    "code": "```fortran\nprogram filter_list\n    implicit none\n    integer, allocatable :: list(:), filtered_list(:)\n    integer :: i, n, count, threshold\n\n    ! Initialize the list and threshold\n    list = [3, 5, 7, 2, 8, 1, 4]\n    threshold = 4\n    n = size(list)\n\n    ! Count elements greater than or equal to threshold\n    count = 0\n    do i = 1, n\n        if (list(i) >= threshold) then\n            count = count + 1\n        end if\n    end do\n\n    ! Allocate filtered_list with the count size\n    allocate(filtered_list(count))\n\n    ! Populate filtered_list with elements meeting the condition\n    count = 0\n    do i = 1, n\n        if (list(i) >= threshold) then\n            count = count + 1\n            filtered_list(count) = list(i)\n        end if\n    end do\n\n    ! Output the filtered list\n    print *, 'Filtered list:', filtered_list\n\n    ! Deallocate arrays\n    deallocate(filtered_list)\nend program filter_list\n```"
  },
  {
    "task": "Write a function that takes a list and returns a new list with elements in random order.",
    "code": "```fortran\nprogram shuffle_list\n  implicit none\n  integer, allocatable :: list(:), shuffled_list(:)\n  integer :: i, n\n\n  n = 10\n  allocate(list(n))\n  allocate(shuffled_list(n))\n\n  ! Initialize the list with some values\n  do i = 1, n\n     list(i) = i\n  end do\n\n  call shuffle(list, shuffled_list)\n\n  ! Print shuffled list\n  print *, 'Shuffled List: ', shuffled_list\n\ncontains\n\n  subroutine shuffle(input_list, output_list)\n    integer, intent(in) :: input_list(:)\n    integer, intent(out) :: output_list(:)\n    integer :: i, j, temp\n\n    output_list = input_list\n\n    do i = size(output_list), 2, -1\n       call random_number(temp)\n       j = 1 + int(temp * i)\n       ! Swap elements\n       temp = output_list(i)\n       output_list(i) = output_list(j)\n       output_list(j) = temp\n    end do\n\n  end subroutine shuffle\n\nend program shuffle_list\n```"
  },
  {
    "task": "Create a list of tuples where each tuple contains a number and its square.",
    "code": "```fortran\nprogram list_of_tuples\n  implicit none\n  integer, parameter :: n = 10\n  integer :: i\n  integer, dimension(n, 2) :: list\n\n  do i = 1, n\n     list(i, 1) = i\n     list(i, 2) = i**2\n  end do\n\n  print *, list\nend program list_of_tuples\n```"
  },
  {
    "task": "Write a program to multiply all elements in a list by a given factor.",
    "code": "```fortran\nprogram multiply_list\n    implicit none\n    integer, parameter :: n = 5\n    integer :: i, factor\n    integer, dimension(n) :: list\n\n    ! Initialize the list and factor\n    list = (/1, 2, 3, 4, 5/)\n    factor = 3\n\n    ! Multiply each element in the list by the factor\n    do i = 1, n\n        list(i) = list(i) * factor\n    end do\n\n    ! Output the modified list\n    print *, 'Modified list: ', list\n\nend program multiply_list\n```"
  },
  {
    "task": "Implement a function that flattens a nested list.",
    "code": "```fortran\nmodule list_operations\n    implicit none\ncontains\n\n    recursive subroutine flatten_list(nested, flat)\n        integer, allocatable :: nested(:)\n        integer, allocatable :: flat(:)\n        integer :: i, n, m\n        integer, allocatable :: temp(:)\n        \n        n = size(nested)\n        allocate(flat(0))\n        \n        do i = 1, n\n            if (allocated(nested(i)%list)) then\n                call flatten_list(nested(i)%list, temp)\n                m = size(temp)\n                call append(flat, temp)\n            else\n                call append(flat, [nested(i)%value])\n            end if\n        end do\n    end subroutine flatten_list\n\n    subroutine append(list, items)\n        integer, allocatable :: list(:)\n        integer, allocatable :: items(:)\n        integer :: n, m\n        \n        n = size(list)\n        m = size(items)\n        call move_alloc(list, list)\n        allocate(list(n+m))\n        list(1:n) = items\n        list(n+1:n+m) = items\n    end subroutine append\n\nend module list_operations\n```"
  },
  {
    "task": "Create a list of dates and sort them chronologically.",
    "code": "```fortran\nprogram sort_dates\n    implicit none\n    character(len=10), dimension(5) :: dates\n    integer :: i, j\n    character(len=10) :: temp\n\n    dates = [\"2023-12-25\", \"2021-01-01\", \"2022-07-04\", \"2023-11-11\", \"2022-02-14\"]\n\n    do i = 1, size(dates) - 1\n        do j = i + 1, size(dates)\n            if (dates(i) > dates(j)) then\n                temp = dates(i)\n                dates(i) = dates(j)\n                dates(j) = temp\n            end if\n        end do\n    end do\n\n    print *, dates\nend program sort_dates\n```"
  },
  {
    "task": "Write a function that finds the index of the first occurrence of a given element in a list.",
    "code": "```fortran\nprogram find_index\n    implicit none\n    integer :: idx\n    integer, allocatable :: list(:)\n    integer :: element\n\n    list = [3, 5, 7, 9, 5, 1]\n    element = 5\n    idx = index_of_first(list, element)\n    print *, \"Index:\", idx\n\ncontains\n\n    function index_of_first(arr, elem) result(idx)\n        integer, intent(in) :: arr(:)\n        integer, intent(in) :: elem\n        integer :: idx\n        integer :: i\n\n        idx = -1\n        do i = 1, size(arr)\n            if (arr(i) == elem) then\n                idx = i\n                return\n            end if\n        end do\n    end function index_of_first\n\nend program find_index\n```"
  },
  {
    "task": "Generate a list of Fibonacci numbers up to a specified limit.",
    "code": "```fortran\nprogram fibonacci_list\n    implicit none\n    integer, parameter :: limit = 1000\n    integer, allocatable :: fibonacci(:)\n    integer :: a, b, c, n\n\n    a = 0\n    b = 1\n    n = 0\n    allocate(fibonacci(0))\n    do while (a <= limit)\n        n = n + 1\n        call append_to_fibonacci(fibonacci, n, a)\n        c = a + b\n        a = b\n        b = c\n    end do\n\n    print *, \"Fibonacci numbers up to\", limit, \":\"\n    print *, fibonacci\n\ncontains\n\n    subroutine append_to_fibonacci(arr, size, value)\n        integer, allocatable :: arr(:)\n        integer, intent(inout) :: size\n        integer, intent(in) :: value\n        integer, allocatable :: temp(:)\n\n        allocate(temp(size))\n        temp = arr\n        deallocate(arr)\n        allocate(arr(size))\n        arr(1:size-1) = temp(1:size-1)\n        arr(size) = value\n        deallocate(temp)\n    end subroutine append_to_fibonacci\n\nend program fibonacci_list\n```"
  },
  {
    "task": "Create a list of booleans and determine if all are True.",
    "code": "```fortran\nprogram check_all_true\n    implicit none\n    logical :: bool_list(5)\n    logical :: all_true\n    integer :: i\n\n    ! Initialize the list of booleans\n    bool_list = [.true., .true., .true., .true., .true.]\n\n    ! Check if all elements are true\n    all_true = .true.\n    do i = 1, size(bool_list)\n        if (.not. bool_list(i)) then\n            all_true = .false.\n            exit\n        end if\n    end do\n\n    print *, \"All elements are true:\", all_true\nend program check_all_true\n```"
  },
  {
    "task": "Write a program to concatenate two lists.",
    "code": "```fortran\nprogram concatenate_lists\n    implicit none\n    integer, dimension(:), allocatable :: list1, list2, list_concat\n    integer :: n1, n2\n\n    ! Initialize the lists\n    n1 = 3\n    n2 = 4\n    allocate(list1(n1))\n    allocate(list2(n2))\n    list1 = [1, 2, 3]\n    list2 = [4, 5, 6, 7]\n\n    ! Concatenate the lists\n    allocate(list_concat(n1 + n2))\n    list_concat(1:n1) = list1\n    list_concat(n1+1:n1+n2) = list2\n\n    ! Output the concatenated list\n    print *, \"Concatenated list: \", list_concat\n\n    ! Deallocate arrays\n    deallocate(list1, list2, list_concat)\nend program concatenate_lists\n```"
  },
  {
    "task": "Implement a function that returns the length of a list without using built-in functions.",
    "code": "```fortran\nmodule list_operations\ncontains\n    function list_length(lst) result(len)\n        integer, dimension(:), intent(in) :: lst\n        integer :: len, i\n        \n        len = 0\n        do i = 1, size(lst)\n            len = len + 1\n        end do\n    end function list_length\nend module list_operations\n```"
  },
  {
    "task": "Create a list of words and find the longest word.",
    "code": "```fortran\nprogram find_longest_word\n    implicit none\n    character(len=20), dimension(:), allocatable :: words\n    character(len=20) :: longest\n    integer :: i, num_words\n\n    num_words = 4\n    allocate(words(num_words))\n    words = [\"apple\", \"banana\", \"cherry\", \"date\"]\n\n    longest = words(1)\n    do i = 2, num_words\n        if (len_trim(words(i)) > len_trim(longest)) then\n            longest = words(i)\n        end if\n    end do\n\n    print *, \"The longest word is:\", trim(longest)\nend program find_longest_word\n```"
  },
  {
    "task": "Write a function that takes a list and a predicate function, returning a list of elements that satisfy the predicate.",
    "code": "```fortran\nmodule list_module\n  implicit none\ncontains\n  function filter_list(lst, predicate) result(filtered_lst)\n    integer, dimension(:), intent(in) :: lst\n    logical, external :: predicate\n    integer, allocatable, dimension(:) :: filtered_lst\n    integer, dimension(:), allocatable :: temp_lst\n    integer :: i, count\n\n    count = 0\n    allocate(temp_lst(size(lst)))\n\n    do i = 1, size(lst)\n      if (predicate(lst(i))) then\n        count = count + 1\n        temp_lst(count) = lst(i)\n      end if\n    end do\n\n    allocate(filtered_lst(count))\n    if (count > 0) filtered_lst = temp_lst(1:count)\n\n    deallocate(temp_lst)\n  end function filter_list\nend module list_module\n```"
  },
  {
    "task": "Generate a list of strings and filter out those with less than 5 characters.",
    "code": "```fortran\nprogram filter_strings\n    implicit none\n    character(len=100), dimension(:), allocatable :: string_list, filtered_list\n    integer :: i, count\n\n    string_list = [ \"apple\", \"dog\", \"banana\", \"cat\", \"elephant\" ]\n    allocate(filtered_list(size(string_list)))\n    count = 0\n\n    do i = 1, size(string_list)\n        if (len_trim(string_list(i)) >= 5) then\n            count = count + 1\n            filtered_list(count) = string_list(i)\n        end if\n    end do\n\n    if (count > 0) then\n        filtered_list = filtered_list(:count)\n    else\n        deallocate(filtered_list)\n        allocate(filtered_list(0))\n    end if\n\n    ! Output filtered list (for testing purposes)\n    do i = 1, size(filtered_list)\n        print *, filtered_list(i)\n    end do\n\nend program filter_strings\n```"
  },
  {
    "task": "Create a list of mixed data types and separate them into lists by type.",
    "code": "```fortran\nprogram separate_types\n    implicit none\n    integer, parameter :: n = 5\n    character(len=10), dimension(n) :: input_list = (/ '123', 'abc', '45.6', 'def', '789' /)\n    integer, dimension(:), allocatable :: integer_list\n    real, dimension(:), allocatable :: real_list\n    character(len=10), dimension(:), allocatable :: string_list\n    integer :: i, int_val, int_count, real_count, string_count\n    real :: real_val\n    character(len=10) :: str_val\n\n    int_count = 0\n    real_count = 0\n    string_count = 0\n\n    do i = 1, n\n        read(input_list(i), '(I10)', IOSTAT=int_val) int_val\n        if (int_val == 0) then\n            int_count = int_count + 1\n        else\n            read(input_list(i), '(F10.2)', IOSTAT=real_val) real_val\n            if (real_val == 0.0) then\n                real_count = real_count + 1\n            else\n                string_count = string_count + 1\n            end if\n        end if\n    end do\n\n    allocate(integer_list(int_count))\n    allocate(real_list(real_count))\n    allocate(string_list(string_count))\n\n    int_count = 0\n    real_count = 0\n    string_count = 0\n\n    do i = 1, n\n        read(input_list(i), '(I10)', IOSTAT=int_val) int_val\n        if (int_val == 0) then\n            int_count = int_count + 1\n            integer_list(int_count) = int_val\n        else\n            read(input_list(i), '(F10.2)', IOSTAT=real_val) real_val\n            if (real_val == 0.0) then\n                real_count = real_count + 1\n                real_list(real_count) = real_val\n            else\n                string_count = string_count + 1\n                string_list(string_count) = input_list(i)\n            end if\n        end if\n    end do\nend program separate_types\n```"
  },
  {
    "task": "Write a program to find the common elements between two lists.",
    "code": "```fortran\nprogram common_elements\n  implicit none\n  integer, allocatable :: list1(:), list2(:), common(:)\n  integer :: i, j, n1, n2, count\n\n  ! Sample input sizes\n  n1 = 5\n  n2 = 6\n\n  ! Allocate lists\n  allocate(list1(n1))\n  allocate(list2(n2))\n\n  ! Sample lists\n  list1 = [1, 3, 5, 7, 9]\n  list2 = [0, 2, 3, 4, 5, 10]\n\n  ! Allocate maximum possible size for common elements\n  allocate(common(min(n1, n2)))\n  count = 0\n\n  ! Find common elements\n  do i = 1, n1\n     do j = 1, n2\n        if (list1(i) == list2(j)) then\n           count = count + 1\n           common(count) = list1(i)\n           exit\n        end if\n     end do\n  end do\n\n  ! Output common elements\n  if (count > 0) then\n     print *, 'Common elements: ', common(1:count)\n  else\n     print *, 'No common elements found.'\n  end if\n\n  ! Deallocate lists\n  deallocate(list1, list2, common)\nend program common_elements\n```"
  },
  {
    "task": "Implement a function to rotate the elements of a list to the left by a given number of steps.",
    "code": "```fortran\nmodule list_operations\n  implicit none\ncontains\n  subroutine rotate_left(list, steps)\n    integer, intent(inout) :: list(:)\n    integer, intent(in) :: steps\n    integer :: n, temp(:)\n    n = size(list)\n    allocate(temp(n))\n    temp = list\n    list(:) = temp(modulo(steps:n+steps-1, n) + 1)\n    deallocate(temp)\n  end subroutine rotate_left\nend module list_operations\n```"
  },
  {
    "task": "Create a list of numbers and find the product of all the elements.",
    "code": "```fortran\nprogram product_of_list\n    implicit none\n    integer, dimension(5) :: numbers\n    integer :: product, i\n\n    numbers = (/ 2, 3, 4, 5, 6 /)\n    product = 1\n\n    do i = 1, size(numbers)\n        product = product * numbers(i)\n    end do\n\n    print *, \"Product of the list is:\", product\nend program product_of_list\n```"
  },
  {
    "task": "Write a function that removes all occurrences of a specified element from a list.",
    "code": "```fortran\nmodule list_operations\n    implicit none\ncontains\n    subroutine remove_element(list, element, new_list)\n        integer, intent(in) :: list(:)\n        integer, intent(in) :: element\n        integer, allocatable, intent(out) :: new_list(:)\n        integer :: i, count\n\n        count = 0\n        do i = 1, size(list)\n            if (list(i) /= element) then\n                count = count + 1\n            end if\n        end do\n\n        allocate(new_list(count))\n        count = 0\n        do i = 1, size(list)\n            if (list(i) /= element) then\n                count = count + 1\n                new_list(count) = list(i)\n            end if\n        end do\n    end subroutine remove_element\nend module list_operations\n```"
  },
  {
    "task": "Generate a list of random numbers and find the median value.",
    "code": "```fortran\nprogram find_median\n  implicit none\n  integer, parameter :: n = 10\n  real :: numbers(n)\n  real :: median\n  integer :: i\n\n  call random_seed()\n  call random_number(numbers)\n\n  call sort_numbers(numbers)\n\n  if (mod(n, 2) == 0) then\n    median = (numbers(n/2) + numbers(n/2 + 1)) / 2.0\n  else\n    median = numbers((n+1)/2)\n  end if\n\n  print *, 'Median value:', median\n\ncontains\n\n  subroutine sort_numbers(arr)\n    real, intent(inout) :: arr(:)\n    integer :: i, j\n    real :: temp\n\n    do i = 1, size(arr) - 1\n      do j = i + 1, size(arr)\n        if (arr(i) > arr(j)) then\n          temp = arr(i)\n          arr(i) = arr(j)\n          arr(j) = temp\n        end if\n      end do\n    end do\n  end subroutine sort_numbers\n\nend program find_median\n```"
  },
  {
    "task": "Create a list of dictionaries and sort them by a specific key.",
    "code": "```fortran\nprogram sort_dicts\n    implicit none\n    type :: dictionary\n        character(len=50) :: key\n        integer :: value\n    end type dictionary\n\n    type(dictionary), allocatable :: dicts(:)\n    integer :: n, i\n\n    n = 3\n    allocate(dicts(n))\n\n    dicts(1) = dictionary('apple', 3)\n    dicts(2) = dictionary('banana', 1)\n    dicts(3) = dictionary('cherry', 2)\n\n    call sort_dicts_by_key(dicts, n)\n\n    do i = 1, n\n        print *, trim(dicts(i)%key), dicts(i)%value\n    end do\n\ncontains\n\n    subroutine sort_dicts_by_key(d, n)\n        type(dictionary), intent(inout) :: d(:)\n        integer, intent(in) :: n\n        integer :: i, j\n        type(dictionary) :: temp\n\n        do i = 1, n-1\n            do j = i+1, n\n                if (d(i)%key > d(j)%key) then\n                    temp = d(i)\n                    d(i) = d(j)\n                    d(j) = temp\n                end if\n            end do\n        end do\n    end subroutine sort_dicts_by_key\n\nend program sort_dicts\n```"
  },
  {
    "task": "Write a program to split a list into chunks of a specified size.",
    "code": "```fortran\nprogram split_list_into_chunks\n  implicit none\n  integer, parameter :: list_size = 10\n  integer, parameter :: chunk_size = 3\n  integer :: list(list_size), i, j, num_chunks\n  integer :: start_index, end_index\n\n  ! Initialize the list\n  do i = 1, list_size\n     list(i) = i\n  end do\n\n  ! Calculate number of chunks\n  num_chunks = (list_size + chunk_size - 1) / chunk_size\n\n  ! Split list into chunks\n  do i = 0, num_chunks - 1\n     start_index = i * chunk_size + 1\n     end_index = min((i + 1) * chunk_size, list_size)\n     \n     print *, \"Chunk\", i + 1, \": \", (list(j), j = start_index, end_index)\n  end do\n\nend program split_list_into_chunks\n```"
  },
  {
    "task": "Implement a function that takes a list and returns a dictionary with the frequency of each element.",
    "code": "```fortran\nmodule frequency_module\n  implicit none\ncontains\n  function calculate_frequency(list, n) result(freq)\n    integer, intent(in) :: list(:)\n    integer, intent(in) :: n\n    integer :: freq(2, n)\n    integer :: i, j, count, unique_count\n\n    unique_count = 0\n    do i = 1, n\n      count = 0\n      do j = 1, unique_count\n        if (freq(1, j) == list(i)) then\n          count = freq(2, j) + 1\n          freq(2, j) = count\n          exit\n        end if\n      end do\n      if (count == 0) then\n        unique_count = unique_count + 1\n        freq(1, unique_count) = list(i)\n        freq(2, unique_count) = 1\n      end if\n    end do\n    freq = freq(:, 1:unique_count)\n  end function calculate_frequency\nend module frequency_module\n```"
  },
  {
    "task": "Create a list of integers and replace all negative numbers with zero.",
    "code": "```fortran\nprogram replace_negatives\n    implicit none\n    integer, dimension(10) :: numbers\n    integer :: i\n\n    ! Initialize the list with some integers\n    numbers = (/ -3, 5, -1, 7, -9, 0, 12, -4, 8, 6 /)\n\n    ! Replace negative numbers with zero\n    do i = 1, size(numbers)\n        if (numbers(i) < 0) then\n            numbers(i) = 0\n        end if\n    end do\n\n    ! Output the modified list\n    print *, numbers\n\nend program replace_negatives\n```"
  },
  {
    "task": "Write a function that returns the first n elements of a list.",
    "code": "```fortran\nmodule list_module\ncontains\n    function first_n_elements(lst, n) result(sublist)\n        integer, intent(in) :: lst(:)\n        integer, intent(in) :: n\n        integer :: sublist(n)\n        integer :: i\n\n        do i = 1, n\n            sublist(i) = lst(i)\n        end do\n    end function first_n_elements\nend module list_module\n```"
  },
  {
    "task": "Generate a list of strings and join them into a single string with spaces.",
    "code": "```fortran\nprogram join_strings\n    implicit none\n    character(len=100), dimension(5) :: str_list\n    character(len=500) :: result\n    integer :: i\n\n    str_list = (/'This', 'is', 'a', 'list', 'example'/)\n    result = trim(str_list(1))\n\n    do i = 2, size(str_list)\n        result = trim(result) // ' ' // trim(str_list(i))\n    end do\n\n    print *, result\nend program join_strings\n```"
  },
  {
    "task": "Create a list of lists and find the sum of each inner list.",
    "code": "```fortran\nprogram list_of_lists\n    implicit none\n    integer, dimension(:,:), allocatable :: list_of_lists\n    integer, dimension(:), allocatable :: inner_list\n    integer :: i, j, sum, num_lists, list_size\n\n    ! Initialize list of lists\n    num_lists = 3\n    list_size = 4\n    allocate(list_of_lists(num_lists, list_size))\n    list_of_lists = reshape([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], &\n                            shape(list_of_lists))\n\n    ! Iterate over each inner list and find the sum\n    do i = 1, num_lists\n        allocate(inner_list(list_size))\n        inner_list = list_of_lists(i, :)\n        sum = 0\n        do j = 1, list_size\n            sum = sum + inner_list(j)\n        end do\n        print *, 'Sum of list', i, ':', sum\n        deallocate(inner_list)\n    end do\n\nend program list_of_lists\n```"
  },
  {
    "task": "Write a function that finds the second largest number in a list.",
    "code": "```fortran\nprogram find_second_largest\n    implicit none\n    integer, parameter :: n = 5\n    integer :: numbers(n) = [5, 3, 7, 2, 8]\n    integer :: result\n\n    result = second_largest(numbers, n)\n    print *, 'The second largest number is: ', result\ncontains\n    function second_largest(arr, size) result(second_max)\n        integer, intent(in) :: arr(:)\n        integer, intent(in) :: size\n        integer :: second_max\n        integer :: max1, max2, i\n\n        max1 = -huge(0)\n        max2 = -huge(0)\n\n        do i = 1, size\n            if (arr(i) > max1) then\n                max2 = max1\n                max1 = arr(i)\n            else if (arr(i) > max2 .and. arr(i) < max1) then\n                max2 = arr(i)\n            end if\n        end do\n        second_max = max2\n    end function second_largest\nend program find_second_largest\n```"
  },
  {
    "task": "Generate a list of numbers and remove the duplicates while maintaining order.",
    "code": "```fortran\nprogram remove_duplicates\n    implicit none\n    integer, parameter :: n = 10\n    integer :: numbers(n) = [1, 2, 3, 2, 4, 5, 1, 6, 7, 5]\n    integer :: unique(n), unique_count, i, j\n    logical :: is_duplicate\n\n    unique_count = 0\n\n    do i = 1, n\n        is_duplicate = .false.\n        do j = 1, unique_count\n            if (numbers(i) == unique(j)) then\n                is_duplicate = .true.\n                exit\n            end if\n        end do\n        if (.not. is_duplicate) then\n            unique_count = unique_count + 1\n            unique(unique_count) = numbers(i)\n        end if\n    end do\n\n    print *, \"Unique numbers in order:\"\n    do i = 1, unique_count\n        print *, unique(i)\n    end do\nend program remove_duplicates\n```"
  },
  {
    "task": "Create a list of integers and partition it into two lists: one with numbers above the average and one below.",
    "code": "```fortran\nprogram partition_list\n    implicit none\n    integer, parameter :: n = 10\n    integer :: numbers(n) = [1, 5, 9, 14, 20, 25, 30, 35, 40, 45]\n    integer :: above_avg(n), below_avg(n)\n    real :: average\n    integer :: i, count_above, count_below\n\n    ! Calculate the average\n    average = sum(numbers) / real(n)\n\n    ! Initialize counters\n    count_above = 0\n    count_below = 0\n\n    ! Partition the list\n    do i = 1, n\n        if (numbers(i) > average) then\n            count_above = count_above + 1\n            above_avg(count_above) = numbers(i)\n        else if (numbers(i) < average) then\n            count_below = count_below + 1\n            below_avg(count_below) = numbers(i)\n        end if\n    end do\n\n    ! Print the results\n    print *, \"Numbers above average:\"\n    print *, above_avg(1:count_above)\n    print *, \"Numbers below average:\"\n    print *, below_avg(1:count_below)\nend program partition_list\n```"
  },
  {
    "task": "Write a program to find the longest increasing subsequence in a list of numbers.",
    "code": "```fortran\nprogram longest_increasing_subsequence\n  implicit none\n  integer, parameter :: n = 10\n  integer :: arr(n) = [10, 22, 9, 33, 21, 50, 41, 60, 80, 3]\n  integer :: lis(n)\n  integer :: i, j, max_lis, result\n\n  lis = 1\n\n  do i = 2, n\n     do j = 1, i - 1\n        if (arr(i) > arr(j) .and. lis(i) < lis(j) + 1) then\n           lis(i) = lis(j) + 1\n        end if\n     end do\n  end do\n\n  max_lis = lis(1)\n  do i = 2, n\n     if (lis(i) > max_lis) then\n        max_lis = lis(i)\n     end if\n  end do\n\n  result = max_lis\n  print *, 'Length of longest increasing subsequence is ', result\n\nend program longest_increasing_subsequence\n```"
  },
  {
    "task": "Implement a function to zip two lists into a single list of tuples.",
    "code": "```fortran\nmodule list_utils\n  implicit none\ncontains\n  function zip_lists(list1, list2) result(zipped_list)\n    integer, dimension(:), intent(in) :: list1, list2\n    integer, dimension(:,:), allocatable :: zipped_list\n    integer :: min_size, i\n\n    min_size = min(size(list1), size(list2))\n    allocate(zipped_list(2, min_size))\n    \n    do i = 1, min_size\n        zipped_list(1, i) = list1(i)\n        zipped_list(2, i) = list2(i)\n    end do\n  end function zip_lists\nend module list_utils\n```"
  },
  {
    "task": "Create a list of characters and count the vowels.",
    "code": "```fortran\nprogram count_vowels\n    implicit none\n    character(len=1), dimension(:), allocatable :: char_list\n    integer :: i, vowel_count\n\n    char_list = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', &\n                 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']\n    vowel_count = 0\n\n    do i = 1, size(char_list)\n        select case (char_list(i))\n        case ('a', 'e', 'i', 'o', 'u')\n            vowel_count = vowel_count + 1\n        end select\n    end do\n\n    print *, \"Number of vowels:\", vowel_count\nend program count_vowels\n```"
  },
  {
    "task": "Write a function that returns the last n elements of a list.",
    "code": "```fortran\nmodule list_module\ncontains\n    function last_n_elements(list, n) result(last_elements)\n        integer, intent(in) :: list(:)\n        integer, intent(in) :: n\n        integer, allocatable :: last_elements(:)\n        integer :: list_size\n\n        list_size = size(list)\n        if (n <= 0) then\n            allocate(last_elements(0))\n        else if (n >= list_size) then\n            allocate(last_elements(list_size))\n            last_elements = list\n        else\n            allocate(last_elements(n))\n            last_elements = list(list_size-n+1:list_size)\n        end if\n    end function last_n_elements\nend module list_module\n```"
  },
  {
    "task": "Generate a list of numbers and split it into two lists: one with positive numbers and one with negative numbers.",
    "code": "```fortran\nprogram split_numbers\n  implicit none\n  integer, dimension(:), allocatable :: numbers, positive_numbers, negative_numbers\n  integer :: i, n, pos_count, neg_count\n\n  ! Initialize list of numbers\n  numbers = [ -3, 5, -1, 7, -9, 2, 0 ]\n\n  ! Allocate space for positive and negative numbers\n  allocate(positive_numbers(size(numbers)))\n  allocate(negative_numbers(size(numbers)))\n\n  ! Initialize counters\n  pos_count = 0\n  neg_count = 0\n\n  ! Split numbers into two lists\n  do i = 1, size(numbers)\n    if (numbers(i) > 0) then\n      pos_count = pos_count + 1\n      positive_numbers(pos_count) = numbers(i)\n    else if (numbers(i) < 0) then\n      neg_count = neg_count + 1\n      negative_numbers(neg_count) = numbers(i)\n    end if\n  end do\n\n  ! Resize arrays to fit the number of elements\n  call move_alloc(positive_numbers(:pos_count), positive_numbers)\n  call move_alloc(negative_numbers(:neg_count), negative_numbers)\n\n  ! Output results (optional)\n  print *, \"Positive Numbers: \", positive_numbers\n  print *, \"Negative Numbers: \", negative_numbers\n\nend program split_numbers\n```"
  },
  {
    "task": "Create a list of random integers and find the mode.",
    "code": "```fortran\nprogram find_mode\n    implicit none\n    integer, parameter :: n = 100\n    integer :: i, max_count, mode, count\n    integer, dimension(n) :: numbers\n    integer, dimension(-50:50) :: frequency\n\n    call random_number(numbers)\n    numbers = int(numbers * 100) - 50\n\n    frequency = 0\n    do i = 1, n\n        frequency(numbers(i)) = frequency(numbers(i)) + 1\n    end do\n\n    max_count = 0\n    mode = 0\n    do i = -50, 50\n        if (frequency(i) > max_count) then\n            max_count = frequency(i)\n            mode = i\n        end if\n    end do\n\n    print *, \"Mode:\", mode\nend program find_mode\n```"
  },
  {
    "task": "Write a program to find the shortest path in a grid using a list to represent the path.",
    "code": "```fortran\nprogram shortest_path\n  implicit none\n  integer, parameter :: n = 5\n  integer, dimension(n, n) :: grid\n  integer, dimension(:), allocatable :: path\n  integer :: i, j, path_length\n\n  ! Initialize grid with arbitrary values\n  grid = reshape((/ 1, 3, 5, 8, 10, &\n                   2, 1, 3, 4, 3, &\n                   5, 1, 1, 2, 2, &\n                   9, 3, 4, 1, 1, &\n                   5, 2, 3, 4, 1 /), (/ n, n /))\n\n  ! Initialize shortest path\n  path_length = 2 * n - 1\n  allocate(path(path_length))\n  path = 0\n\n  ! Compute a path from (1,1) to (n,n)\n  i = 1\n  j = 1\n  path(1) = grid(i, j)\n\n  do while (i < n .or. j < n)\n    if (i < n .and. (j == n .or. grid(i + 1, j) <= grid(i, j + 1))) then\n      i = i + 1\n    else\n      j = j + 1\n    end if\n    path(i + j - 1) = grid(i, j)\n  end do\n\n  ! Output the path\n  print *, 'Shortest path: ', path\n\n  ! Clean up\n  deallocate(path)\nend program shortest_path\n```"
  },
  {
    "task": "Implement a function that takes a list and returns a list with elements doubled.",
    "code": "```fortran\nprogram double_list\n    implicit none\n    integer, allocatable :: input_list(:), output_list(:)\n    integer :: i, n\n    \n    ! Example usage:\n    n = 5\n    allocate(input_list(n))\n    input_list = [1, 2, 3, 4, 5]\n    \n    output_list = double_elements(input_list)\n    \n    print *, output_list\n    deallocate(input_list, output_list)\ncontains\n    function double_elements(list) result(doubled_list)\n        integer, intent(in) :: list(:)\n        integer, allocatable :: doubled_list(:)\n        integer :: i\n        \n        allocate(doubled_list(size(list)))\n        do i = 1, size(list)\n            doubled_list(i) = 2 * list(i)\n        end do\n    end function double_elements\nend program double_list\n```"
  },
  {
    "task": "Create a list of integers and sort them in descending order.",
    "code": "```fortran\nprogram sort_list\n    implicit none\n    integer, allocatable :: num_list(:)\n    integer :: i, n\n\n    n = 5\n    allocate(num_list(n))\n    num_list = [4, 1, 3, 5, 2]\n\n    call sort_descending(num_list)\n\n    print *, num_list\n\ncontains\n\n    subroutine sort_descending(arr)\n        integer, intent(inout) :: arr(:)\n        integer :: i, j, temp\n\n        do i = 1, size(arr) - 1\n            do j = i + 1, size(arr)\n                if (arr(i) < arr(j)) then\n                    temp = arr(i)\n                    arr(i) = arr(j)\n                    arr(j) = temp\n                end if\n            end do\n        end do\n    end subroutine sort_descending\n\nend program sort_list\n```"
  },
  {
    "task": "Write a function that takes a list of intervals and merges overlapping intervals.",
    "code": "```fortran\nmodule interval_module\n  implicit none\ncontains\n\n  subroutine mergeIntervals(intervals, mergedIntervals, n, mergedCount)\n    integer, intent(in) :: n\n    real, dimension(:,:), intent(in) :: intervals\n    real, dimension(:,:), allocatable, intent(out) :: mergedIntervals\n    integer, intent(out) :: mergedCount\n    real, dimension(:,:), allocatable :: sortedIntervals\n    integer :: i, j, k, tempIdx\n    real :: tempStart, tempEnd\n\n    allocate(sortedIntervals(n, 2))\n    allocate(mergedIntervals(n, 2))\n    \n    ! Copy input intervals to allow sorting\n    sortedIntervals = intervals\n    \n    ! Sort intervals by the start value\n    do i = 1, n-1\n      do j = i + 1, n\n        if (sortedIntervals(i, 1) > sortedIntervals(j, 1)) then\n          tempStart = sortedIntervals(i, 1)\n          tempEnd = sortedIntervals(i, 2)\n          sortedIntervals(i, 1) = sortedIntervals(j, 1)\n          sortedIntervals(i, 2) = sortedIntervals(j, 2)\n          sortedIntervals(j, 1) = tempStart\n          sortedIntervals(j, 2) = tempEnd\n        end if\n      end do\n    end do\n\n    ! Initialize the first interval\n    mergedIntervals(1, 1) = sortedIntervals(1, 1)\n    mergedIntervals(1, 2) = sortedIntervals(1, 2)\n    k = 1\n\n    ! Merge overlapping intervals\n    do i = 2, n\n      if (sortedIntervals(i, 1) <= mergedIntervals(k, 2)) then\n        mergedIntervals(k, 2) = max(mergedIntervals(k, 2), sortedIntervals(i, 2))\n      else\n        k = k + 1\n        mergedIntervals(k, 1) = sortedIntervals(i, 1)\n        mergedIntervals(k, 2) = sortedIntervals(i, 2)\n      end if\n    end do\n\n    mergedCount = k\n    deallocate(sortedIntervals)\n  end subroutine mergeIntervals\n\nend module interval_module\n```"
  },
  {
    "task": "Generate a list of random numbers and find the range (difference between max and min).",
    "code": "```fortran\nprogram random_range\n    implicit none\n    integer, parameter :: n = 10\n    real :: numbers(n)\n    real :: min_val, max_val\n    integer :: i\n\n    call random_seed()\n    call random_number(numbers)\n\n    min_val = numbers(1)\n    max_val = numbers(1)\n\n    do i = 2, n\n        if (numbers(i) < min_val) min_val = numbers(i)\n        if (numbers(i) > max_val) max_val = numbers(i)\n    end do\n\n    print *, 'Range: ', max_val - min_val\nend program random_range\n```"
  },
  {
    "task": "Create a list of strings and remove any that are palindromes.",
    "code": "```fortran\nprogram remove_palindromes\n    implicit none\n    character(len=:), allocatable :: strList(:)\n    character(len=100) :: tempStr\n    integer :: i, n\n\n    ! Define the list of strings\n    allocate(strList(5))\n    strList = ['level', 'hello', 'world', 'radar', 'fortran']\n\n    ! Remove palindromes\n    n = size(strList)\n    do i = n, 1, -1\n        tempStr = strList(i)\n        if (is_palindrome(trim(tempStr))) then\n            strList(i:) = [strList(i+1:)]\n            n = n - 1\n        end if\n    end do\n    if (n /= size(strList)) then\n        call move_alloc(from=strList, to=strList(1:n))\n    end if\n\n    ! Output the result\n    do i = 1, size(strList)\n        print *, strList(i)\n    end do\n\ncontains\n\n    logical function is_palindrome(str)\n        character(len=*), intent(in) :: str\n        integer :: j, lenStr\n\n        lenStr = len_trim(str)\n        is_palindrome = .true.\n        do j = 1, lenStr / 2\n            if (str(j:j) /= str(lenStr-j+1:lenStr-j+1)) then\n                is_palindrome = .false.\n                exit\n            end if\n        end do\n    end function is_palindrome\n\nend program remove_palindromes\n```"
  },
  {
    "task": "Write a program to cyclically permute the elements of a list.",
    "code": "```fortran\nprogram cyclic_permute\n    implicit none\n    integer, parameter :: n = 5\n    integer :: i\n    integer :: list(n), permuted_list(n)\n\n    ! Initialize the list with some values\n    list = (/ 1, 2, 3, 4, 5 /)\n\n    ! Perform cyclic permutation\n    permuted_list(1) = list(n)\n    permuted_list(2:n) = list(1:n-1)\n\n    ! Print the permuted list\n    do i = 1, n\n        print *, permuted_list(i)\n    end do\nend program cyclic_permute\n```"
  },
  {
    "task": "Implement a function to create a list of cumulative sums from a list of numbers.",
    "code": "```fortran\nprogram cumulative_sum\n  implicit none\n  integer, dimension(:), allocatable :: numbers, cumsum\n  integer :: i, n\n  \n  print *, \"Enter the number of elements:\"\n  read *, n\n  allocate(numbers(n))\n  allocate(cumsum(n))\n  \n  print *, \"Enter the elements of the list:\"\n  read *, numbers\n  \n  call cumulative_sum_list(numbers, cumsum)\n  \n  print *, \"Cumulative sums:\"\n  print *, cumsum\n\ncontains\n\n  subroutine cumulative_sum_list(input_list, output_list)\n    integer, dimension(:), intent(in) :: input_list\n    integer, dimension(:), intent(out) :: output_list\n    integer :: i\n\n    output_list(1) = input_list(1)\n    do i = 2, size(input_list)\n      output_list(i) = output_list(i - 1) + input_list(i)\n    end do\n  end subroutine cumulative_sum_list\n\nend program cumulative_sum\n```"
  },
  {
    "task": "Create a list of numbers and shift all zeros to the end.",
    "code": "```fortran\nprogram shift_zeros\n    implicit none\n    integer, parameter :: n = 10\n    integer :: i, count\n    integer, dimension(n) :: numbers, result\n\n    ! Initialize the list of numbers\n    numbers = [0, 1, 0, 3, 12, 0, 5, 0, 6, 8]\n\n    count = 1\n    do i = 1, n\n        if (numbers(i) /= 0) then\n            result(count) = numbers(i)\n            count = count + 1\n        end if\n    end do\n\n    do i = count, n\n        result(i) = 0\n    end do\n\n    print *, result\nend program shift_zeros\n```"
  },
  {
    "task": "Write a program to simulate a queue using a list.",
    "code": "```fortran\nprogram queue_simulation\n    implicit none\n    type :: node\n        integer :: data\n        type(node), pointer :: next => null()\n    end type node\n\n    type(node), pointer :: head => null()\n    type(node), pointer :: tail => null()\n\n    call enqueue(10)\n    call enqueue(20)\n    call enqueue(30)\n    call dequeue()\n    call display_queue()\n\ncontains\n\n    subroutine enqueue(value)\n        integer, intent(in) :: value\n        type(node), pointer :: new_node\n\n        allocate(new_node)\n        new_node%data = value\n        new_node%next => null()\n\n        if (.not. associated(head)) then\n            head => new_node\n            tail => new_node\n        else\n            tail%next => new_node\n            tail => new_node\n        end if\n    end subroutine enqueue\n\n    subroutine dequeue()\n        type(node), pointer :: temp\n\n        if (.not. associated(head)) then\n            print *, 'Queue is empty.'\n            return\n        endif\n\n        temp => head\n        head => head%next\n        deallocate(temp)\n\n        if (.not. associated(head)) then\n            tail => null()\n        endif\n    end subroutine dequeue\n\n    subroutine display_queue()\n        type(node), pointer :: current\n\n        current => head\n        if (.not. associated(current)) then\n            print *, 'Queue is empty.'\n            return\n        endif\n\n        print *, 'Queue contents:'\n        do while (associated(current))\n            print *, current%data\n            current => current%next\n        end do\n    end subroutine display_queue\n\nend program queue_simulation\n```"
  },
  {
    "task": "Generate a list of numbers and identify all prime numbers.",
    "code": "```fortran\nprogram prime_numbers\n  implicit none\n  integer, parameter :: n = 100\n  integer :: i, j\n  logical :: is_prime\n  integer :: numbers(n)\n  integer :: primes(n)\n  integer :: prime_count\n\n  ! Initialize the list of numbers from 2 to n\n  do i = 1, n\n     numbers(i) = i + 1\n  end do\n\n  prime_count = 0\n\n  ! Identify prime numbers\n  do i = 1, n\n     is_prime = .true.\n     do j = 2, numbers(i) - 1\n        if (mod(numbers(i), j) == 0) then\n           is_prime = .false.\n           exit\n        end if\n     end do\n     if (is_prime) then\n        prime_count = prime_count + 1\n        primes(prime_count) = numbers(i)\n     end if\n  end do\n\n  ! Output the prime numbers\n  do i = 1, prime_count\n     print *, primes(i)\n  end do\n\nend program prime_numbers\n```"
  },
  {
    "task": "Create a list of strings and group them by their starting letter.",
    "code": "```fortran\nprogram group_strings_by_letter\n    implicit none\n    character(len=100), dimension(5) :: strings\n    character(len=1), dimension(5) :: starting_letters\n    integer :: i, j\n    character(len=100), dimension(:), allocatable :: group\n\n    strings = ['apple', 'apricot', 'banana', 'blueberry', 'avocado']\n    starting_letters = ['a', 'a', 'b', 'b', 'a']\n\n    do i = 1, size(starting_letters)\n        if (allocated(group)) deallocate(group)\n        allocate(group(0))\n        do j = 1, size(strings)\n            if (starting_letters(j) == starting_letters(i)) then\n                call add_to_group(group, strings(j))\n            end if\n        end do\n        print *, 'Group ', starting_letters(i), ':', group\n    end do\n\ncontains\n\n    subroutine add_to_group(group, word)\n        character(len=100), dimension(:), allocatable :: group\n        character(len=*), intent(in) :: word\n        integer :: n\n\n        n = size(group)\n        call move_alloc(from=group, to=group, source=group)\n        allocate(group(n + 1))\n        group(n + 1) = word\n    end subroutine add_to_group\n\nend program group_strings_by_letter\n```"
  },
  {
    "task": "Write a function that takes a list and returns a new list with all elements squared.",
    "code": "```fortran\nmodule list_operations\n  implicit none\ncontains\n  function square_list(input_list) result(output_list)\n    integer, intent(in) :: input_list(:)\n    integer :: output_list(size(input_list))\n    integer :: i\n\n    do i = 1, size(input_list)\n      output_list(i) = input_list(i)**2\n    end do\n  end function square_list\nend module list_operations\n```"
  },
  {
    "task": "Generate a list of timestamps and find the time difference between consecutive elements.",
    "code": "```fortran\nprogram timestamp_differences\n    implicit none\n    integer, parameter :: n = 5\n    character(len=19) :: timestamps(n)\n    integer :: i\n    real :: time_diffs(n-1)\n\n    timestamps = [ \"2023-10-01 12:00:00\", \"2023-10-01 12:05:30\", \"2023-10-01 12:10:00\", &\n                   \"2023-10-01 12:15:45\", \"2023-10-01 12:20:00\" ]\n\n    do i = 1, n-1\n        call calc_time_diff(timestamps(i), timestamps(i+1), time_diffs(i))\n    end do\n\n    do i = 1, n-1\n        print *, \"Difference between \", i, \" and \", i+1, \" is \", time_diffs(i), \" seconds\"\n    end do\n\ncontains\n\n    subroutine calc_time_diff(ts1, ts2, diff)\n        character(len=19), intent(in) :: ts1, ts2\n        real, intent(out) :: diff\n        integer :: h1, m1, s1, h2, m2, s2\n\n        read(ts1, '(I4, 1X, I2, 1X, I2, I2, 1X, I2, 1X, I2)') h1, m1, s1\n        read(ts2, '(I4, 1X, I2, 1X, I2, I2, 1X, I2, 1X, I2)') h2, m2, s2\n\n        diff = (h2-h1)*3600 + (m2-m1)*60 + (s2-s1)\n    end subroutine calc_time_diff\n\nend program timestamp_differences\n```"
  },
  {
    "task": "Create a list of numbers and rotate it such that the smallest number is first.",
    "code": "```fortran\nprogram rotate_list\n    implicit none\n    integer, parameter :: n = 5\n    integer :: numbers(n), i, min_val, min_idx\n\n    ! Initialize the list of numbers\n    numbers = [3, 1, 4, 5, 2]\n\n    ! Find the smallest number and its index\n    min_val = numbers(1)\n    min_idx = 1\n    do i = 2, n\n        if (numbers(i) < min_val) then\n            min_val = numbers(i)\n            min_idx = i\n        end if\n    end do\n\n    ! Rotate the list so the smallest number is first\n    if (min_idx > 1) then\n        numbers = [numbers(min_idx:n), numbers(1:min_idx-1)]\n    end if\n\n    ! Output the rotated list\n    print *, numbers\n\nend program rotate_list\n```"
  },
  {
    "task": "Write a program to find all unique pairs in a list that sum up to a specific target.",
    "code": "```fortran\nprogram find_pairs\n    implicit none\n    integer, parameter :: n = 10\n    integer :: i, j, target, list(n)\n    logical :: found\n    list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    target = 10\n\n    print *, \"Unique pairs that sum to \", target, \":\"\n    do i = 1, n-1\n        do j = i+1, n\n            if (list(i) + list(j) == target) then\n                print *, \"(\", list(i), \",\", list(j), \")\"\n            endif\n        end do\n    end do\nend program find_pairs\n```"
  },
  {
    "task": "Implement a function that returns true if a list contains a cycle.",
    "code": "```fortran\nmodule cycle_check\n  implicit none\ncontains\n  logical function has_cycle(list)\n    type(list_node), pointer :: list\n    type(list_node), pointer :: slow, fast\n\n    slow => list\n    fast => list\n\n    do while (associated(fast) .and. associated(fast%next))\n      slow => slow%next\n      fast => fast%next%next\n      if (associated(slow, fast)) then\n        has_cycle = .true.\n        return\n      end if\n    end do\n\n    has_cycle = .false.\n  end function has_cycle\n\n  type list_node\n    integer :: value\n    type(list_node), pointer :: next => null()\n  end type list_node\nend module cycle_check\n```"
  },
  {
    "task": "Create a list of numbers and find the contiguous subarray with the maximum sum.",
    "code": "```fortran\nprogram max_subarray\n  implicit none\n  integer, parameter :: n = 6\n  integer :: arr(n) = [2, -1, 2, 3, 4, -5]\n  integer :: max_sum, current_sum, i\n\n  max_sum = arr(1)\n  current_sum = arr(1)\n\n  do i = 2, n\n     current_sum = max(arr(i), current_sum + arr(i))\n     max_sum = max(max_sum, current_sum)\n  end do\n\n  print *, \"Maximum subarray sum is:\", max_sum\nend program max_subarray\n```"
  },
  {
    "task": "Write a function that takes a list and a number, and finds two numbers in the list that sum to the given number.",
    "code": "```fortran\nprogram find_sum_pair\n  implicit none\n  integer, allocatable :: list(:)\n  integer :: n, target, i\n\n  allocate(list(5))\n  list = [2, 7, 11, 15, 3]\n  target = 9\n\n  call find_two_numbers(list, target, n)\n\ncontains\n\n  subroutine find_two_numbers(arr, target, n)\n    integer, intent(in) :: arr(:)\n    integer, intent(in) :: target\n    integer :: n, i, j\n\n    do i = 1, size(arr)\n      do j = i + 1, size(arr)\n        if (arr(i) + arr(j) == target) then\n          print *, \"Numbers found: \", arr(i), arr(j)\n          return\n        end if\n      end do\n    end do\n\n    print *, \"No suitable numbers found.\"\n  end subroutine find_two_numbers\n\nend program find_sum_pair\n```"
  },
  {
    "task": "Generate a list of even numbers and filter out those that are greater than a specific value.",
    "code": "```fortran\nprogram filter_even_numbers\n    implicit none\n    integer, parameter :: n = 20, max_value = 10\n    integer :: i\n    integer, allocatable :: evens(:)\n    integer :: count\n\n    count = 0\n    allocate(evens(n/2))\n    do i = 2, n, 2\n        count = count + 1\n        evens(count) = i\n    end do\n\n    print *, \"Filtered even numbers:\"\n    do i = 1, count\n        if (evens(i) <= max_value) then\n            print *, evens(i)\n        end if\n    end do\n\n    deallocate(evens)\nend program filter_even_numbers\n```"
  },
  {
    "task": "Create a list of characters and reverse the vowels only.",
    "code": "```fortran\nprogram reverse_vowels\n  implicit none\n  character(len=12) :: char_list\n  character(len=12) :: vowels\n  integer :: i, j\n\n  char_list = \"FortranLang\"\n  vowels = \"\"\n  j = 0\n\n  ! Extract vowels from the list\n  do i = 1, len(char_list)\n    if (index(\"AEIOUaeiou\", char_list(i:i)) > 0) then\n      j = j + 1\n      vowels(j:j) = char_list(i:i)\n    end if\n  end do\n\n  ! Reverse vowels in the original list\n  j = 0\n  do i = len(char_list), 1, -1\n    if (index(\"AEIOUaeiou\", char_list(i:i)) > 0) then\n      j = j + 1\n      char_list(i:i) = vowels(j:j)\n    end if\n  end do\n\n  print *, trim(char_list)\nend program reverse_vowels\n```"
  },
  {
    "task": "Write a program to find all permutations of a list of elements.",
    "code": "```fortran\nprogram permutations\n  implicit none\n  integer, parameter :: n = 3\n  integer :: i\n  integer :: elements(n) = [1, 2, 3]\n  call permute(elements, 1, n)\ncontains\n  recursive subroutine permute(arr, start, end)\n    integer, intent(inout) :: arr(:)\n    integer, intent(in) :: start, end\n    integer :: i, temp\n    if (start == end) then\n      print *, arr\n    else\n      do i = start, end\n        call swap(arr(start), arr(i))\n        call permute(arr, start + 1, end)\n        call swap(arr(start), arr(i))\n      end do\n    end if\n  end subroutine permute\n\n  subroutine swap(a, b)\n    integer, intent(inout) :: a, b\n    integer :: temp\n    temp = a\n    a = b\n    b = temp\n  end subroutine swap\nend program permutations\n```"
  },
  {
    "task": "Implement a function that takes a list and returns the most frequently occurring element.",
    "code": "```fortran\nmodule list_utils\n    implicit none\ncontains\n    function most_frequent_element(list, n) result(most_frequent)\n        integer, intent(in) :: list(:)\n        integer, intent(in) :: n\n        integer :: most_frequent\n        integer :: i, j, count, max_count\n\n        max_count = 0\n        most_frequent = list(1)\n\n        do i = 1, n\n            count = 0\n            do j = 1, n\n                if (list(i) == list(j)) then\n                    count = count + 1\n                end if\n            end do\n            if (count > max_count) then\n                max_count = count\n                most_frequent = list(i)\n            end if\n        end do\n    end function most_frequent_element\nend module list_utils\n```"
  },
  {
    "task": "Create a list of numbers and calculate the variance.",
    "code": "```fortran\nprogram calculate_variance\n    implicit none\n    real, dimension(:), allocatable :: numbers\n    real :: mean, variance\n    integer :: n, i\n\n    ! Initialize the list of numbers\n    n = 5\n    allocate(numbers(n))\n    numbers = [1.0, 2.0, 3.0, 4.0, 5.0]\n\n    ! Calculate the mean\n    mean = sum(numbers) / n\n\n    ! Calculate the variance\n    variance = sum((numbers - mean)**2) / n\n\n    ! Output the variance\n    print *, \"Variance:\", variance\n\n    ! Deallocate the list\n    deallocate(numbers)\nend program calculate_variance\n```"
  },
  {
    "task": "Write a function to concatenate a list of lists into a single list.",
    "code": "```fortran\nmodule list_module\n    implicit none\ncontains\n    function concatenate_lists(lists) result(concatenated_list)\n        integer, allocatable :: concatenated_list(:)\n        integer, allocatable :: lists(:,:)\n        integer :: i, total_size, start_pos\n\n        ! Calculate the total size of the concatenated list\n        total_size = sum(size(lists(:,i), 1), i=1, size(lists, 2))\n\n        ! Allocate the concatenated list\n        allocate(concatenated_list(total_size))\n\n        ! Concatenate all lists\n        start_pos = 1\n        do i = 1, size(lists, 2)\n            concatenated_list(start_pos:start_pos+size(lists(:,i), 1)-1) = lists(:,i)\n            start_pos = start_pos + size(lists(:,i), 1)\n        end do\n    end function concatenate_lists\nend module list_module\n```"
  },
  {
    "task": "Generate a list of numbers and replace each element with the product of all other elements.",
    "code": "```fortran\nprogram product_of_others\n    implicit none\n    integer, parameter :: n = 5\n    integer :: i, j\n    integer :: numbers(n) = [1, 2, 3, 4, 5]\n    integer :: result(n)\n    integer :: product\n\n    do i = 1, n\n        product = 1\n        do j = 1, n\n            if (j /= i) then\n                product = product * numbers(j)\n            end if\n        end do\n        result(i) = product\n    end do\n\n    print *, result\nend program product_of_others\n```"
  },
  {
    "task": "Create a list of strings and find the common prefix.",
    "code": "```fortran\nprogram find_common_prefix\n    implicit none\n    character(len=100), dimension(3) :: str_list = (/ 'flower', 'flow', 'flight' /)\n    character(len=100) :: prefix\n    integer :: i, j, min_length\n\n    prefix = str_list(1)\n    min_length = len(trim(prefix))\n\n    do i = 2, size(str_list)\n        min_length = min(min_length, len(trim(str_list(i))))\n        \n        do j = 1, min_length\n            if (str_list(i)(j:j) /= prefix(j:j)) then\n                prefix = prefix(1:j-1)\n                exit\n            end if\n        end do\n    end do\n\n    print *, 'The common prefix is: ', trim(prefix)\nend program find_common_prefix\n```"
  },
  {
    "task": "Write a program to partition a list into two lists based on a predicate function.",
    "code": "```fortran\nprogram partition_list\n  implicit none\n  integer, parameter :: n = 10\n  integer :: i, lst(n), lst_true(n), lst_false(n)\n  logical :: predicate\n  integer :: index_true, index_false\n\n  lst = (/ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 /)\n  index_true = 0\n  index_false = 0\n\n  do i = 1, n\n    if (predicate(lst(i))) then\n      index_true = index_true + 1\n      lst_true(index_true) = lst(i)\n    else\n      index_false = index_false + 1\n      lst_false(index_false) = lst(i)\n    end if\n  end do\n\n  print *, 'List True:', lst_true(1:index_true)\n  print *, 'List False:', lst_false(1:index_false)\n\ncontains\n\n  pure logical function predicate(x)\n    integer, intent(in) :: x\n    predicate = (mod(x, 2) == 0)\n  end function predicate\n\nend program partition_list\n```"
  },
  {
    "task": "Implement a function to find the kth smallest element in a list.",
    "code": "```fortran\nprogram kth_smallest\n    implicit none\n    integer, allocatable :: arr(:)\n    integer :: k, n, result\n\n    ! Example usage\n    n = 6\n    allocate(arr(n))\n    arr = [3, 1, 4, 1, 5, 9]\n    k = 3\n    result = kth_smallest_function(arr, n, k)\n    print *, 'The ', k, 'th smallest element is ', result\nend program kth_smallest\n\nrecursive function kth_smallest_function(arr, n, k) result(kth_smallest)\n    integer, intent(in) :: arr(:)\n    integer, intent(in) :: n, k\n    integer :: kth_smallest\n    integer :: pivot, left, right\n    integer, allocatable :: less(:), greater(:)\n    integer :: len_less, len_greater\n\n    if (n == 1) then\n        kth_smallest = arr(1)\n        return\n    end if\n\n    pivot = arr(1)\n    less = pack(arr, arr < pivot)\n    greater = pack(arr, arr > pivot)\n\n    len_less = size(less)\n    len_greater = size(greater)\n\n    if (k <= len_less) then\n        kth_smallest = kth_smallest_function(less, len_less, k)\n    else if (k > len_less + 1) then\n        kth_smallest = kth_smallest_function(greater, len_greater, k - len_less - 1)\n    else\n        kth_smallest = pivot\n    end if\nend function kth_smallest_function\n```"
  },
  {
    "task": "Create a list of integers and find the length of the longest contiguous sequence.",
    "code": "```fortran\nprogram longest_contiguous_sequence\n    implicit none\n    integer, parameter :: n = 10\n    integer :: list(n) = [1, 2, 2, 2, 3, 4, 4, 5, 5, 5]\n    integer :: i, current_length, max_length\n\n    current_length = 1\n    max_length = 1\n\n    do i = 2, n\n        if (list(i) == list(i-1)) then\n            current_length = current_length + 1\n        else\n            if (current_length > max_length) then\n                max_length = current_length\n            end if\n            current_length = 1\n        end if\n    end do\n\n    if (current_length > max_length) then\n        max_length = current_length\n    end if\n\n    print *, 'Length of the longest contiguous sequence:', max_length\nend program longest_contiguous_sequence\n```"
  },
  {
    "task": "Write a function that rotates elements in a list while maintaining the relative order of non-rotated elements.",
    "code": "```fortran\nprogram rotate_list\n  implicit none\n  integer, allocatable :: list(:)\n  integer :: n, k\n\n  print *, \"Enter the number of elements:\"\n  read *, n\n  allocate(list(n))\n\n  print *, \"Enter the elements of the list:\"\n  read *, list\n\n  print *, \"Enter the number of rotations:\"\n  read *, k\n\n  call rotate(list, n, k)\n  print *, \"Rotated list:\"\n  print *, list\n\ncontains\n\n  subroutine rotate(arr, size, num_rotations)\n    integer, intent(inout) :: arr(:)\n    integer, intent(in) :: size, num_rotations\n    integer :: i, j, temp, rotations\n\n    rotations = mod(num_rotations, size)\n    if (rotations == 0) return\n\n    do i = 1, rotations\n      temp = arr(1)\n      do j = 1, size - 1\n        arr(j) = arr(j + 1)\n      end do\n      arr(size) = temp\n    end do\n  end subroutine rotate\n\nend program rotate_list\n```"
  },
  {
    "task": "Generate a list of random numbers and sort them while maintaining the original index positions.",
    "code": "```fortran\nprogram sort_random_numbers_with_indices\n    implicit none\n    integer, parameter :: n = 10\n    integer :: i\n    real :: random_numbers(n)\n    integer :: original_indices(n)\n    integer :: sorted_indices(n)\n\n    call random_seed()\n    call random_number(random_numbers)\n\n    do i = 1, n\n        original_indices(i) = i\n    end do\n\n    call sort_with_indices(random_numbers, original_indices, sorted_indices, n)\n\n    print *, 'Original Numbers and Indices:'\n    do i = 1, n\n        print *, 'Number:', random_numbers(i), 'Index:', original_indices(i)\n    end do\n\n    print *, 'Sorted Numbers and Original Indices:'\n    do i = 1, n\n        print *, 'Number:', random_numbers(sorted_indices(i)), 'Original Index:', original_indices(sorted_indices(i))\n    end do\ncontains\n    subroutine sort_with_indices(arr, orig_indices, sorted_indices, size)\n        real, intent(in) :: arr(size)\n        integer, intent(in) :: orig_indices(size)\n        integer, intent(out) :: sorted_indices(size)\n        integer :: i, j, temp_index\n        real :: temp_value\n\n        do i = 1, size\n            sorted_indices(i) = i\n        end do\n\n        do i = 1, size - 1\n            do j = i + 1, size\n                if (arr(sorted_indices(i)) > arr(sorted_indices(j))) then\n                    temp_index = sorted_indices(i)\n                    sorted_indices(i) = sorted_indices(j)\n                    sorted_indices(j) = temp_index\n                end if\n            end do\n        end do\n    end subroutine sort_with_indices\nend program sort_random_numbers_with_indices\n```"
  },
  {
    "task": "Create a list of numbers and find all subsets that sum up to a specific target.",
    "code": "```fortran\nprogram subset_sum\n    implicit none\n    integer, parameter :: n = 5, target = 5\n    integer :: numbers(n) = [1, 2, 3, 4, 5]\n    integer :: subset(n), sum, i, j\n\n    call find_subsets(numbers, n, target)\n    \ncontains\n\n    subroutine find_subsets(arr, size, target)\n        integer, intent(in) :: arr(:), size, target\n        integer :: subset(size)\n        call subset_sum_recursive(arr, subset, size, 0, 0, target)\n    end subroutine find_subsets\n\n    recursive subroutine subset_sum_recursive(arr, subset, size, index, start, target)\n        integer, intent(in) :: arr(:), size, target, start\n        integer, intent(inout) :: subset(:), index\n        integer :: i, sum\n\n        sum = 0\n        do i = 1, index\n            sum = sum + subset(i)\n        end do\n\n        if (sum == target) then\n            print *, 'Subset found: ', subset(1:index)\n        end if\n\n        do i = start, size - 1\n            subset(index + 1) = arr(i + 1)\n            call subset_sum_recursive(arr, subset, size, index + 1, i + 1, target)\n        end do\n    end subroutine subset_sum_recursive\n\nend program subset_sum\n```"
  },
  {
    "task": "Write a program to simulate a stack using a list.",
    "code": "```fortran\nprogram stack_simulation\n  implicit none\n  integer, parameter :: max_size = 100\n  integer :: stack(max_size)\n  integer :: top, choice, value\n\n  top = 0\n\n  do\n     print *, \"1. Push\"\n     print *, \"2. Pop\"\n     print *, \"3. Display\"\n     print *, \"4. Exit\"\n     print *, \"Enter your choice: \"\n     read *, choice\n\n     select case (choice)\n     case (1)\n        if (top < max_size) then\n           print *, \"Enter value to push: \"\n           read *, value\n           top = top + 1\n           stack(top) = value\n        else\n           print *, \"Stack Overflow\"\n        end if\n     case (2)\n        if (top > 0) then\n           value = stack(top)\n           top = top - 1\n           print *, \"Popped value: \", value\n        else\n           print *, \"Stack Underflow\"\n        end if\n     case (3)\n        if (top > 0) then\n           print *, \"Stack contents:\"\n           do i = 1, top\n              print *, stack(i)\n           end do\n        else\n           print *, \"Stack is empty\"\n        end if\n     case (4)\n        exit\n     case default\n        print *, \"Invalid choice\"\n     end select\n  end do\nend program stack_simulation\n```"
  }
]