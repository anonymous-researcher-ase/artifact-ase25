[
  {
    "task": "Write a function that reads a file and handles the exception if the file is not found.",
    "code": "```fortran\nprogram handle_file_exception\n    implicit none\n    call read_file(\"example.txt\")\ncontains\n    subroutine read_file(filename)\n        character(len=*), intent(in) :: filename\n        integer :: unit, ios\n        character(len=100) :: line\n\n        inquire(iolength=unit) unit = 10\n\n        open(unit=unit, file=filename, status='old', action='read', iostat=ios)\n        if (ios /= 0) then\n            print *, \"Error: File not found.\"\n            return\n        end if\n\n        do\n            read(unit, '(A)', iostat=ios) line\n            if (ios /= 0) exit\n            print *, trim(line)\n        end do\n\n        close(unit)\n    end subroutine read_file\nend program handle_file_exception\n```"
  },
  {
    "task": "Create a program that divides two numbers and catches any division by zero errors.",
    "code": "```fortran\nprogram divide_numbers\n    implicit none\n    real :: numerator, denominator, result\n    integer :: io_status\n    \n    print *, \"Enter numerator:\"\n    read *, numerator\n    print *, \"Enter denominator:\"\n    read *, denominator\n    \n    io_status = 0\n    if (denominator == 0.0) then\n        io_status = 1\n    else\n        result = numerator / denominator\n    end if\n    \n    if (io_status /= 0) then\n        print *, \"Error: Division by zero!\"\n    else\n        print *, \"Result:\", result\n    end if\nend program divide_numbers\n```"
  },
  {
    "task": "Design a function to parse an integer from a string and manage invalid input exceptions.",
    "code": "```fortran\nprogram parse_integer_example\n    implicit none\n    character(len=100) :: input_string\n    integer :: number\n    logical :: success\n\n    input_string = \"123abc\"\n    call parse_integer(input_string, number, success)\n\n    if (success) then\n        print *, \"Parsed integer:\", number\n    else\n        print *, \"Invalid input: Cannot parse integer\"\n    end if\n\ncontains\n\n    subroutine parse_integer(str, num, success)\n        character(len=*), intent(in) :: str\n        integer, intent(out) :: num\n        logical, intent(out) :: success\n        integer :: ios\n\n        read(str, '(I)', iostat=ios) num\n        if (ios /= 0) then\n            success = .false.\n            num = 0\n        else\n            success = .true.\n        end if\n    end subroutine parse_integer\n\nend program parse_integer_example\n```"
  },
  {
    "task": "Implement an API call and catch exceptions related to network errors or timeouts.",
    "code": "```fortran\nprogram api_call\n    use,intrinsic :: iso_fortran_env, only: error_unit\n    implicit none\n\n    ! Declare variables\n    integer :: status\n    character(len=256) :: url\n    logical :: success\n\n    ! Initialize variables\n    url = \"http://example.com/api\"\n    success = .false.\n\n    ! Attempt to make the API call\n    call make_api_call(url, status, success)\n\n    ! Check for exceptions (network errors or timeouts)\n    if (.not. success) then\n        write(error_unit, *) \"Error: Failed to make API call.\"\n        select case (status)\n        case (1)\n            write(error_unit, *) \"Network error occurred.\"\n        case (2)\n            write(error_unit, *) \"Timeout occurred.\"\n        case default\n            write(error_unit, *) \"Unknown error.\"\n        end select\n    else\n        write(*, *) \"API call was successful.\"\n    end if\n\ncontains\n\n    subroutine make_api_call(url, status, success)\n        character(len=*), intent(in) :: url\n        integer, intent(out) :: status\n        logical, intent(out) :: success\n\n        ! Simulate an API call\n        ! For demonstration, we'll randomly choose success or failure\n        call random_number(success)\n        if (success < 0.5) then\n            success = .false.\n            call random_number(success)\n            if (success < 0.5) then\n                status = 1  ! Network error\n            else\n                status = 2  ! Timeout\n            end if\n        else\n            success = .true.\n            status = 0  ! No error\n        end if\n    end subroutine make_api_call\n\nend program api_call\n```"
  },
  {
    "task": "Develop a program that opens a database connection and handles any connection failure exceptions.",
    "code": "```fortran\nprogram DatabaseConnection\n    implicit none\n    character(len=256) :: db_url\n    integer :: io_stat\n    logical :: connected\n\n    db_url = \"database_url\"\n\n    call connect_to_database(db_url, connected, io_stat)\n\n    if (io_stat /= 0) then\n        print *, \"Error: Failed to connect to the database.\"\n    else\n        print *, \"Successfully connected to the database.\"\n    end if\n\ncontains\n\n    subroutine connect_to_database(url, success, io_stat)\n        character(len=*), intent(in) :: url\n        logical, intent(out) :: success\n        integer, intent(out) :: io_stat\n\n        io_stat = 0\n        success = .false.\n\n        ! Simulated connection logic\n        if (url /= \"database_url\") then\n            io_stat = 1\n        else\n            success = .true.\n        end if\n    end subroutine connect_to_database\n\nend program DatabaseConnection\n```"
  },
  {
    "task": "Write a function that accesses an array by index and catches out-of-bounds exceptions.",
    "code": "```fortran\nprogram HandleException\n    implicit none\n\n    integer, dimension(5) :: myArray = [1, 2, 3, 4, 5]\n    integer :: result\n    integer :: index\n\n    ! Example usage\n    index = 6\n    result = accessArray(myArray, index)\n    print *, \"Access result: \", result\n\ncontains\n\n    function accessArray(arr, idx) result(value)\n        integer, dimension(:), intent(in) :: arr\n        integer, intent(in) :: idx\n        integer :: value\n\n        value = 0\n        if (idx >= 1 .and. idx <= size(arr)) then\n            value = arr(idx)\n        else\n            print *, \"Error: Index out of bounds\"\n        end if\n    end function accessArray\n\nend program HandleException\n```"
  },
  {
    "task": "Create a function that converts a string to a date object and manages format exceptions.",
    "code": "```fortran\nmodule date_module\n  implicit none\n\ncontains\n\n  subroutine convert_to_date(date_str, year, month, day, error_flag)\n    character(len=*), intent(in) :: date_str\n    integer, intent(out) :: year, month, day\n    logical, intent(out) :: error_flag\n    integer :: io_status\n\n    ! Initialize error flag\n    error_flag = .false.\n\n    ! Attempt to read the date\n    read(date_str, '(I4.4, 1X, I2.2, 1X, I2.2)', iostat=io_status) year, month, day\n\n    ! Check if an error occurred during reading\n    if (io_status /= 0) then\n      error_flag = .true.\n      year = -1\n      month = -1\n      day = -1\n    end if\n\n  end subroutine convert_to_date\n\nend module date_module\n```"
  },
  {
    "task": "Design a program that writes data to a file and catches any file permission exceptions.",
    "code": "```fortran\nprogram file_write_with_exception_handling\n    implicit none\n    integer :: unit_number, ios\n    character(len=100) :: filename\n\n    ! Assign a file name\n    filename = 'output.txt'\n\n    ! Open the file with write permission and a unique unit number\n    open(newunit=unit_number, file=filename, status='unknown', action='write', iostat=ios)\n\n    ! Check for file permission errors\n    if (ios /= 0) then\n        print *, 'Error opening file:', filename, 'I/O status:', ios\n        stop\n    end if\n\n    ! Write some data to the file\n    write(unit_number, '(A)') 'Hello, Fortran!'\n\n    ! Close the file\n    close(unit_number)\nend program file_write_with_exception_handling\n```"
  },
  {
    "task": "Implement a module that retrieves data from a URL and handles malformed URL exceptions.",
    "code": "```fortran\nmodule url_handler\n  implicit none\ncontains\n  subroutine retrieve_data(url)\n    character(len=*), intent(in) :: url\n    integer :: status\n\n    ! Attempt to open the URL\n    call open_url(url, status)\n\n    if (status /= 0) then\n      print *, \"Error: Malformed URL or unable to access URL: \", url\n    else\n      print *, \"Data retrieved successfully from: \", url\n    end if\n  end subroutine retrieve_data\n\n  subroutine open_url(url, status)\n    character(len=*), intent(in) :: url\n    integer, intent(out) :: status\n\n    ! Simulate opening the URL\n    if (len_trim(url) < 5 .or. url(1:4) /= \"http\") then\n      status = 1\n    else\n      status = 0\n    end if\n  end subroutine open_url\n\nend module url_handler\n```"
  },
  {
    "task": "Write a function to calculate the square root of a number and catch any negative input exceptions.",
    "code": "```fortran\nprogram main\n    implicit none\n    real :: result\n    result = safe_sqrt(-4.0)\n    print *, \"Result:\", result\nend program main\n\nfunction safe_sqrt(x) result(sqrt_result)\n    implicit none\n    real, intent(in) :: x\n    real :: sqrt_result\n\n    if (x < 0.0) then\n        print *, \"Error: Negative input encountered.\"\n        sqrt_result = -1.0 ! Indicate an error\n    else\n        sqrt_result = sqrt(x)\n    end if\nend function safe_sqrt\n```"
  },
  {
    "task": "Develop a program that sends an email and manages exceptions for invalid email addresses.",
    "code": "```fortran\nprogram sendEmail\n  implicit none\n  character(len=100) :: emailAddress\n  logical :: isValid\n\n  write(*,*) \"Enter email address:\"\n  read(*,*) emailAddress\n\n  isValid = validateEmail(emailAddress)\n\n  if (.not. isValid) then\n     write(*,*) \"Error: Invalid email address\"\n     stop\n  else\n     call sendEmailProcedure(emailAddress)\n     write(*,*) \"Email sent successfully!\"\n  end if\n\ncontains\n\n  logical function validateEmail(email)\n    character(len=*), intent(in) :: email\n    logical :: hasAt, hasDot\n    integer :: atPos, dotPos\n\n    ! Simple validation for example purposes\n    hasAt = index(email, '@') > 0\n    hasDot = index(email, '.') > 0\n    atPos = index(email, '@')\n    dotPos = index(email, '.', atPos)\n    \n    validateEmail = hasAt .and. hasDot .and. dotPos > atPos\n  end function validateEmail\n\n  subroutine sendEmailProcedure(email)\n    character(len=*), intent(in) :: email\n    ! Dummy routine for sending email\n    ! In a real application, this would interface with an email server\n  end subroutine sendEmailProcedure\n\nend program sendEmail\n```"
  },
  {
    "task": "Create a calculator application that handles invalid operations gracefully.",
    "code": "```fortran\nprogram calculator\n    implicit none\n    character(len=10) :: operation\n    real :: num1, num2, result\n    logical :: validInput\n\n    print *, \"Enter first number:\"\n    read *, num1\n    print *, \"Enter second number:\"\n    read *, num2\n    print *, \"Enter operation (+, -, *, /):\"\n    read *, operation\n\n    validInput = .true.\n    select case (trim(operation))\n    case ('+')\n        result = num1 + num2\n    case ('-')\n        result = num1 - num2\n    case ('*')\n        result = num1 * num2\n    case ('/')\n        if (num2 /= 0.0) then\n            result = num1 / num2\n        else\n            print *, \"Error: Division by zero.\"\n            validInput = .false.\n        end if\n    case default\n        print *, \"Error: Invalid operation.\"\n        validInput = .false.\n    end select\n\n    if (validInput) then\n        print *, \"Result:\", result\n    end if\nend program calculator\n```"
  },
  {
    "task": "Design a function that tries to parse JSON data and catches parsing errors.",
    "code": "```fortran\nmodule json_parser\n  use iso_fortran_env, only: stderr => output_unit\n  implicit none\ncontains\n  subroutine parse_json(json_data)\n    character(len=*), intent(in) :: json_data\n    integer :: i\n    logical :: has_error\n    has_error = .false.\n\n    ! A simplified representation of JSON parsing\n    do i = 1, len(json_data)\n      if (json_data(i:i) == '{' .or. json_data(i:i) == '}') then\n        cycle\n      else if (json_data(i:i) == '\"') then\n        cycle\n      else\n        has_error = .true.\n        exit\n      end if\n    end do\n\n    if (has_error) then\n      call handle_exception(\"Parsing error: Invalid JSON structure.\")\n    else\n      call print *, \"JSON parsed successfully.\"\n    end if\n  end subroutine parse_json\n\n  subroutine handle_exception(message)\n    character(len=*), intent(in) :: message\n    call print(stderr), trim(message)\n  end subroutine handle_exception\n\nend module json_parser\n```"
  },
  {
    "task": "Implement a system that processes user input and handles any type conversion exceptions.",
    "code": "```fortran\nprogram exception_handling\n    implicit none\n    character(len=100) :: user_input\n    integer :: converted_value, ios\n\n    print *, 'Enter an integer: '\n    read(*, '(A)') user_input\n\n    read(user_input, '(I10)', IOSTAT=ios) converted_value\n    if (ios /= 0) then\n        print *, 'Error: Invalid input. Please enter a valid integer.'\n    else\n        print *, 'You entered: ', converted_value\n    endif\nend program exception_handling\n```"
  },
  {
    "task": "Write a function that fetches data from a database and manages exceptions for missing records.",
    "code": "```fortran\nmodule database_module\n  implicit none\n\ncontains\n\n  function fetch_data(record_id) result(data)\n    integer, intent(in) :: record_id\n    real :: data\n    logical :: record_exists\n\n    ! Simulate checking for record existence\n    record_exists = .false. ! Assume the record does not exist for demonstration\n\n    if (.not. record_exists) then\n      print *, \"Exception: Record with ID\", record_id, \"is missing.\"\n      data = -1.0\n    else\n      ! Simulate fetching data\n      data = 42.0\n    end if\n\n  end function fetch_data\n\nend module database_module\n\nprogram main\n  use database_module\n  implicit none\n\n  real :: result\n  integer :: record_id\n\n  record_id = 1\n  result = fetch_data(record_id)\n  print *, \"Fetched data:\", result\n\nend program main\n```"
  },
  {
    "task": "Create a program that connects to a remote server and handles authentication failure exceptions.",
    "code": "```fortran\nprogram RemoteServerConnection\n    implicit none\n    character(len=100) :: serverAddress\n    integer :: status\n\n    serverAddress = \"http://example.com\"\n\n    call connectToServer(serverAddress, status)\n\n    if (status /= 0) then\n        print *, \"Error: Authentication failed.\"\n        stop\n    end if\n\n    print *, \"Connected successfully.\"\n\ncontains\n\n    subroutine connectToServer(server, status)\n        character(len=*), intent(in) :: server\n        integer, intent(out) :: status\n\n        ! Simulate a connection attempt and authentication check\n        ! Here we simply set status to a non-zero value to simulate failure\n        status = 1\n\n    end subroutine connectToServer\n\nend program RemoteServerConnection\n```"
  },
  {
    "task": "Develop a function to download a file from the internet and handle file not found exceptions.",
    "code": "```fortran\nprogram download_file\n    use iso_fortran_env, only : error_unit\n    implicit none\n    character(len=256) :: url\n    integer :: status\n\n    url = \"http://example.com/file.txt\"\n\n    call download_and_handle_exception(url, status)\n\n    if (status /= 0) then\n        write(error_unit, *) \"File not found or an error occurred during download.\"\n    else\n        write(*, *) \"File downloaded successfully.\"\n    end if\n\ncontains\n\n    subroutine download_and_handle_exception(url, status)\n        character(len=*), intent(in) :: url\n        integer, intent(out) :: status\n\n        ! Simulating file download and exception handling\n        ! This is a placeholder for actual download logic\n        status = 1 ! Simulate file not found error\n\n        if (status /= 0) then\n            ! Handle exception: File not found\n            write(error_unit, *) \"Exception: File not found for URL: \", trim(url)\n        end if\n    end subroutine download_and_handle_exception\n\nend program download_file\n```"
  },
  {
    "task": "Design a program that attempts to connect to an API and handles rate limit exceptions.",
    "code": "```fortran\nprogram api_connection\n    implicit none\n    integer :: status\n\n    ! Attempt to connect to the API\n    status = connect_to_api()\n\n    ! Check for rate limit exception\n    if (status == 429) then\n        print *, \"Rate limit exceeded. Please try again later.\"\n    else if (status /= 0) then\n        print *, \"Failed to connect to API. Error code:\", status\n    else\n        print *, \"Successfully connected to API.\"\n    end if\n\ncontains\n\n    integer function connect_to_api()\n        ! Simulate API connection\n        ! Returning 429 to simulate rate limit exception\n        connect_to_api = 429\n    end function connect_to_api\n\nend program api_connection\n```"
  },
  {
    "task": "Write a function that reads from a configuration file and manages key not found exceptions.",
    "code": "```fortran\nmodule config_handler\n  implicit none\ncontains\n\n  function read_config_value(file_name, key) result(value)\n    character(len=*), intent(in) :: file_name\n    character(len=*), intent(in) :: key\n    character(len=256) :: value\n    character(len=256) :: line, read_key, read_value\n    integer :: unit, ios\n\n    value = 'Key not found'\n    inquire(file=file_name, opened=ios)\n    if (ios == 0) then\n      open(newunit=unit, file=file_name, status='old', action='read', iostat=ios)\n      if (ios /= 0) then\n        stop 'Error opening file'\n      end if\n      do\n        read(unit, '(A)', iostat=ios) line\n        if (ios /= 0) exit\n        read(line, '(A=256,A=256)', iostat=ios) read_key, read_value\n        if (ios /= 0) cycle\n        if (trim(read_key) == trim(key)) then\n          value = trim(read_value)\n          exit\n        end if\n      end do\n      close(unit)\n    end if\n\n  end function read_config_value\n\nend module config_handler\n```"
  },
  {
    "task": "Create an application that processes a list of tasks and catches any task execution exceptions.",
    "code": "```fortran\nprogram TaskProcessor\n    implicit none\n    integer, parameter :: n_tasks = 5\n    character(len=30) :: tasks(n_tasks) = [ &\n        \"Task 1\", \"Task 2\", \"Task 3\", \"Task 4\", \"Task 5\" &\n    ]\n    integer :: i\n    logical :: task_success\n\n    do i = 1, n_tasks\n        task_success = .false.\n        call execute_task(tasks(i), task_success)\n        if (.not. task_success) then\n            print *, \"Exception caught during execution of \", tasks(i)\n        end if\n    end do\n\ncontains\n\n    subroutine execute_task(task, success)\n        character(len=*), intent(in) :: task\n        logical, intent(out) :: success\n\n        success = .false.\n        ! Simulated task execution with a chance of failure\n        if (mod(len_trim(task), 2) == 0) then\n            success = .true.\n            print *, \"Successfully executed \", task\n        else\n            ! Simulating an exception\n            call handle_exception(task)\n        end if\n    end subroutine execute_task\n\n    subroutine handle_exception(task)\n        character(len=*), intent(in) :: task\n        print *, \"Handling exception for \", task\n    end subroutine handle_exception\n\nend program TaskProcessor\n```"
  },
  {
    "task": "Implement a program that performs batch processing and handles individual item processing exceptions.",
    "code": "```fortran\nprogram batch_processing\n    implicit none\n    integer :: i, n\n    integer, allocatable :: items(:)\n    logical :: success\n\n    n = 10\n    allocate(items(n))\n    call random_number(items)\n    items = int(items * 100)\n\n    do i = 1, n\n        call process_item(items(i), success)\n        if (.not. success) then\n            print *, 'Exception in processing item: ', items(i)\n        else\n            print *, 'Processed item: ', items(i)\n        end if\n    end do\n\ncontains\n\n    subroutine process_item(item, success)\n        integer, intent(in) :: item\n        logical, intent(out) :: success\n\n        success = .true.\n        if (mod(item, 2) == 0) then\n            ! Simulate an exception for even numbers\n            success = .false.\n        end if\n    end subroutine process_item\n\nend program batch_processing\n```"
  },
  {
    "task": "Develop a function that performs mathematical operations and catches arithmetic exceptions.",
    "code": "```fortran\nprogram exception_handling_example\n  implicit none\n  real :: result\n\n  result = safe_divide(10.0, 0.0)\n  print *, \"Result: \", result\n\ncontains\n\n  real function safe_divide(a, b)\n    real, intent(in) :: a, b\n    real :: temp_result\n    integer :: ierr\n\n    ierr = 0\n    safe_divide = 0.0\n\n    ! Attempt division\n    temp_result = a / b\n\n    ! Check for exception\n    if (b == 0.0) then\n      ierr = 1\n      print *, \"Error: Division by zero.\"\n    end if\n\n    if (ierr == 0) then\n      safe_divide = temp_result\n    end if\n\n  end function safe_divide\n\nend program exception_handling_example\n```"
  },
  {
    "task": "Write a program that logs error messages when exceptions occur during data processing.",
    "code": "```fortran\nprogram exception_handling\n    implicit none\n    integer :: i, divisor, result\n    character(len=100) :: error_message\n\n    ! Example data processing with potential division by zero\n    divisor = 0\n\n    ! Exception handling using Fortran 2003 features\n    block\n        ! Attempt to divide by divisor\n        if (divisor == 0) then\n            ! Simulating an error\n            error_message = \"Error: Division by zero encountered.\"\n            call log_error(error_message)\n        else\n            result = 100 / divisor\n            print *, \"Result is: \", result\n        end if\n    end block\n\ncontains\n\n    subroutine log_error(message)\n        character(len=*), intent(in) :: message\n        print *, \"Logging error:\", message\n    end subroutine log_error\n\nend program exception_handling\n```"
  },
  {
    "task": "Create a script that monitors system resources and handles exceptions when limits are exceeded.",
    "code": "```fortran\nprogram MonitorSystemResources\n  implicit none\n  integer :: ierr\n\n  ! Example of monitoring CPU usage (this is a placeholder, as Fortran does not directly support system calls)\n  real :: cpu_usage\n  cpu_usage = 0.0\n\n  ! Exception handling block\n  ierr = 0\n  call monitor_cpu_usage(cpu_usage, ierr)\n  if (ierr /= 0) then\n    print *, \"Error: CPU usage monitoring failed with code\", ierr\n  else if (cpu_usage > 90.0) then\n    print *, \"Warning: CPU usage exceeded limit:\", cpu_usage\n  else\n    print *, \"CPU usage is within the limit:\", cpu_usage\n  end if\n\ncontains\n\n  subroutine monitor_cpu_usage(usage, ierr)\n    real, intent(out) :: usage\n    integer, intent(out) :: ierr\n    \n    ! Placeholder logic to simulate monitoring and error\n    usage = 95.0\n    ierr = 0\n\n    ! Simulate an error condition\n    if (usage > 100.0) then\n      ierr = 1\n    end if\n  end subroutine monitor_cpu_usage\n\nend program MonitorSystemResources\n```"
  },
  {
    "task": "Design a function that validates user input and manages any format exceptions.",
    "code": "```fortran\nprogram validate_input\n    implicit none\n\n    integer :: user_input\n    logical :: valid\n\n    valid = .false.\n    do while (.not. valid)\n        print *, \"Enter an integer value:\"\n        read(*, '(I10)', IOSTAT=iostat) user_input\n\n        if (iostat /= 0) then\n            print *, \"Invalid input. Please enter a valid integer.\"\n        else\n            valid = .true.\n        end if\n    end do\n\n    print *, \"You entered a valid integer:\", user_input\nend program validate_input\n```"
  },
  {
    "task": "Implement a service that interacts with third-party APIs and handles unexpected response exceptions.",
    "code": "```fortran\nmodule api_service\n  implicit none\ncontains\n\n  subroutine call_third_party_api()\n    implicit none\n    integer :: status\n\n    ! Simulated API call\n    call simulate_api_call(status)\n\n    select case (status)\n    case (0)\n      print *, \"API call successful.\"\n    case (1)\n      print *, \"API call failed: Network Error\"\n    case (2)\n      print *, \"API call failed: Timeout\"\n    case default\n      print *, \"API call failed: Unexpected Error\"\n    end select\n\n  end subroutine call_third_party_api\n\n  subroutine simulate_api_call(status)\n    implicit none\n    integer, intent(out) :: status\n\n    ! Simulate different status codes\n    ! 0: Success, 1: Network Error, 2: Timeout, other: Unexpected\n    call random_number(status)\n    status = int(status * 4)  ! Generates a number between 0 and 3\n\n  end subroutine simulate_api_call\n\nend module api_service\n\n\nprogram main\n  use api_service\n  implicit none\n\n  call call_third_party_api()\n\nend program main\n```"
  },
  {
    "task": "Write a function that uploads files to a server and handles exceptions for unsupported file types.",
    "code": "```fortran\nmodule file_module\n  implicit none\n  private\n  public :: upload_file\n\ncontains\n\n  subroutine upload_file(filename)\n    character(len=*), intent(in) :: filename\n    character(len=256) :: extension\n    integer :: i, ios\n\n    ! Extract file extension\n    i = index(filename, '.', back=.true.)\n    if (i > 0) then\n      extension = filename(i+1:)\n    else\n      extension = ''\n    end if\n\n    ! Check for supported file types\n    select case (trim(extension))\n    case ('txt', 'csv', 'dat')\n      call upload_to_server(filename, ios)\n      if (ios /= 0) then\n        print *, 'Error: Failed to upload file.'\n      else\n        print *, 'File uploaded successfully.'\n      end if\n    case default\n      print *, 'Error: Unsupported file type.'\n    end select\n\n  contains\n\n    subroutine upload_to_server(fname, ios)\n      character(len=*), intent(in) :: fname\n      integer, intent(out) :: ios\n      ! Simulate file upload\n      ios = 0\n      ! Actual server upload code would go here\n    end subroutine upload_to_server\n\n  end subroutine upload_file\n\nend module file_module\n```"
  },
  {
    "task": "Create a program that simulates network traffic and manages packet loss exceptions.",
    "code": "```fortran\nprogram NetworkTrafficSimulation\n  implicit none\n  integer :: i, numPackets, lostPackets\n  real :: packetLossProbability\n  logical :: success\n\n  numPackets = 1000\n  packetLossProbability = 0.1\n  lostPackets = 0\n\n  do i = 1, numPackets\n    call simulatePacketTransmission(packetLossProbability, success)\n    if (.not. success) then\n      call handlePacketLossException(i)\n      lostPackets = lostPackets + 1\n    end if\n  end do\n\n  print *, \"Total Packets:\", numPackets\n  print *, \"Lost Packets:\", lostPackets\n  print *, \"Successful Packets:\", numPackets - lostPackets\n\ncontains\n\n  subroutine simulatePacketTransmission(probability, success)\n    real, intent(in) :: probability\n    logical, intent(out) :: success\n    real :: randomValue\n\n    call random_number(randomValue)\n\n    if (randomValue < probability) then\n      success = .false.\n    else\n      success = .true.\n    end if\n  end subroutine simulatePacketTransmission\n\n  subroutine handlePacketLossException(packetNumber)\n    integer, intent(in) :: packetNumber\n    print *, \"Exception: Packet\", packetNumber, \"lost.\"\n  end subroutine handlePacketLossException\n\nend program NetworkTrafficSimulation\n```"
  },
  {
    "task": "Develop a function that processes XML data and catches any structural exceptions.",
    "code": "```fortran\nprogram xml_handler\n    implicit none\n\n    call process_xml()\n\ncontains\n\n    subroutine process_xml()\n        implicit none\n        character(len=256) :: xml_data\n        logical :: is_valid\n\n        ! Simulate reading XML data\n        xml_data = \"<xml><data>Example</data></xml>\"\n\n        ! Attempt to process the XML data\n        is_valid = .false.\n        call xml_exception_handler(xml_data, is_valid)\n\n        if (.not. is_valid) then\n            print *, \"Error: Invalid XML structure.\"\n        else\n            print *, \"XML processed successfully.\"\n        end if\n    end subroutine process_xml\n\n    subroutine xml_exception_handler(data, valid)\n        implicit none\n        character(len=*), intent(in) :: data\n        logical, intent(out) :: valid\n\n        ! Simulate checking XML structure\n        valid = .true.\n        if (index(data, \"<xml>\") == 0 .or. index(data, \"</xml>\") == 0) then\n            valid = .false.\n        endif\n\n        ! Simulate catching an exception\n        if (.not. valid) then\n            valid = .false.\n        endif\n    end subroutine xml_exception_handler\n\nend program xml_handler\n```"
  },
  {
    "task": "Design a program that handles exceptions when accessing environment variables.",
    "code": "```fortran\nprogram env_var_exception_handling\n    implicit none\n    character(len=100) :: env_value\n    integer :: stat\n\n    call get_environment_variable('MY_ENV_VAR', env_value, status=stat)\n\n    if (stat /= 0) then\n        print *, \"Error: Environment variable 'MY_ENV_VAR' not found.\"\n    else\n        print *, \"Environment variable 'MY_ENV_VAR' value: \", trim(env_value)\n    end if\n\nend program env_var_exception_handling\n```"
  },
  {
    "task": "Write a function that calculates factorial and manages exceptions for negative input values.",
    "code": "```fortran\nmodule factorial_module\ncontains\n    recursive function factorial(n) result(fact)\n        integer, intent(in) :: n\n        integer :: fact\n        if (n < 0) then\n            print *, \"Error: Factorial of a negative number is undefined.\"\n            stop\n        else if (n == 0) then\n            fact = 1\n        else\n            fact = n * factorial(n - 1)\n        end if\n    end function factorial\nend module factorial_module\n\nprogram main\n    use factorial_module\n    integer :: num, result\n\n    print *, \"Enter a non-negative integer:\"\n    read *, num\n\n    result = factorial(num)\n    print *, \"Factorial of\", num, \"is\", result\nend program main\n```"
  },
  {
    "task": "Create a software tool that converts file formats and handles unsupported format exceptions.",
    "code": "```fortran\nprogram FileFormatConverter\n    implicit none\n    character(len=256) :: inputFile, outputFile\n    character(len=10) :: inputFormat, outputFormat\n    \n    print *, 'Enter input file name:'\n    read *, inputFile\n    print *, 'Enter output file name:'\n    read *, outputFile\n    print *, 'Enter input format:'\n    read *, inputFormat\n    print *, 'Enter output format:'\n    read *, outputFormat\n\n    call ConvertFileFormat(inputFile, outputFile, inputFormat, outputFormat)\n\ncontains\n\n    subroutine ConvertFileFormat(inputFile, outputFile, inputFormat, outputFormat)\n        implicit none\n        character(len=*), intent(in) :: inputFile, outputFile\n        character(len=*), intent(in) :: inputFormat, outputFormat\n        logical :: supported\n        \n        call CheckFormatSupport(inputFormat, supported)\n        if (.not. supported) then\n            print *, 'Exception: Unsupported input format'\n            return\n        end if\n\n        call CheckFormatSupport(outputFormat, supported)\n        if (.not. supported) then\n            print *, 'Exception: Unsupported output format'\n            return\n        end if\n\n        print *, 'Converting', inputFile, 'from', inputFormat, 'to', outputFormat\n        ! Conversion logic goes here\n\n    end subroutine ConvertFileFormat\n\n    subroutine CheckFormatSupport(format, supported)\n        implicit none\n        character(len=*), intent(in) :: format\n        logical, intent(out) :: supported\n\n        select case (format)\n        case ('txt', 'csv', 'xml', 'json')\n            supported = .true.\n        case default\n            supported = .false.\n        end select\n    end subroutine CheckFormatSupport\n\nend program FileFormatConverter\n```"
  },
  {
    "task": "Implement a function that sends HTTP requests and catches exceptions for invalid response status codes.",
    "code": "```fortran\nmodule http_module\n  use, intrinsic :: iso_fortran_env, only: stderr => output_unit\n  implicit none\ncontains\n\n  subroutine send_http_request(url)\n    character(len=*), intent(in) :: url\n    integer :: status_code\n    logical :: success\n\n    ! Simulate sending HTTP request and getting a status code\n    call simulate_http_request(url, status_code)\n\n    ! Exception handling for invalid response status codes\n    call handle_http_exception(status_code, success)\n    if (.not. success) then\n      write(stderr, *) \"Error: Invalid response status code:\", status_code\n    end if\n  end subroutine send_http_request\n\n  subroutine simulate_http_request(url, status_code)\n    character(len=*), intent(in) :: url\n    integer, intent(out) :: status_code\n\n    ! Simulate different status codes\n    if (url == \"http://example.com/success\") then\n      status_code = 200\n    else\n      status_code = 404\n    end if\n  end subroutine simulate_http_request\n\n  subroutine handle_http_exception(status_code, success)\n    integer, intent(in) :: status_code\n    logical, intent(out) :: success\n\n    if (status_code /= 200) then\n      success = .false.\n    else\n      success = .true.\n    end if\n  end subroutine handle_http_exception\n\nend module http_module\n```"
  },
  {
    "task": "Develop a program that interacts with a message queue and handles message delivery exceptions.",
    "code": "```fortran\nprogram message_queue\n    use iso_fortran_env, only: error_unit\n    implicit none\n\n    ! Hypothetical message queue interaction interfaces\n    interface\n        subroutine send_message(queue, message)\n            character(len=*), intent(in) :: queue\n            character(len=*), intent(in) :: message\n        end subroutine send_message\n        \n        subroutine receive_message(queue, message, status)\n            character(len=*), intent(in) :: queue\n            character(len=100), intent(out) :: message\n            integer, intent(out) :: status\n        end subroutine receive_message\n    end interface\n\n    character(len=100) :: message\n    integer :: status\n\n    ! Example of sending a message\n    call send_message(\"my_queue\", \"Hello, World!\")\n\n    ! Example of receiving a message with exception handling\n    call receive_message(\"my_queue\", message, status)\n    if (status /= 0) then\n        write(error_unit, '(A)') \"Error: Message delivery failed.\"\n    else\n        write(*, '(A)') \"Received message: \"//trim(message)\n    end if\n\nend program message_queue\n```"
  },
  {
    "task": "Write a function that reads user input and catches exceptions for unexpected data types.",
    "code": "```fortran\nprogram handle_exceptions\n    implicit none\n    integer :: user_input\n    logical :: valid_input\n\n    valid_input = .false.\n\n    do while (.not. valid_input)\n        print *, 'Enter an integer value: '\n        read(*, '(I10)', IOSTAT=status) user_input\n\n        if (status == 0) then\n            valid_input = .true.\n            print *, 'You entered: ', user_input\n        else\n            print *, 'Invalid input. Please enter a valid integer.'\n            read(*, *) ! Clear the input buffer\n        end if\n    end do\n\nend program handle_exceptions\n```"
  },
  {
    "task": "Create a system that processes transactions and manages exceptions for insufficient funds.",
    "code": "```fortran\nprogram TransactionSystem\n    implicit none\n\n    real :: balance, amount\n    character(len=100) :: input\n\n    balance = 1000.0\n\n    print *, \"Enter transaction amount:\"\n    read(*,*) input\n    read(input, *) amount\n\n    call processTransaction(balance, amount)\n\ncontains\n\n    subroutine processTransaction(balance, amount)\n        real, intent(inout) :: balance\n        real, intent(in) :: amount\n\n        if (amount > balance) then\n            call insufficientFundsHandler()\n        else\n            balance = balance - amount\n            print *, \"Transaction successful!\"\n            print *, \"New balance:\", balance\n        end if\n    end subroutine processTransaction\n\n    subroutine insufficientFundsHandler()\n        print *, \"Error: Insufficient funds for this transaction.\"\n    end subroutine insufficientFundsHandler\n\nend program TransactionSystem\n```"
  },
  {
    "task": "Design a function that generates random numbers and handles exceptions when the range is invalid.",
    "code": "```fortran\nprogram RandomNumberGenerator\n    implicit none\n    integer :: low, high\n    real :: rand_num\n\n    print *, 'Enter the lower and upper bounds for random number generation:'\n    read *, low, high\n\n    call generate_random(low, high, rand_num)\n\n    if (rand_num /= -1.0) then\n        print *, 'Random number generated:', rand_num\n    else\n        print *, 'Invalid range entered.'\n    end if\n\ncontains\n\n    subroutine generate_random(low, high, rand_num)\n        implicit none\n        integer, intent(in) :: low, high\n        real, intent(out) :: rand_num\n\n        if (low >= high) then\n            rand_num = -1.0\n        else\n            call random_seed()\n            call random_number(rand_num)\n            rand_num = low + rand_num * (high - low)\n        endif\n    end subroutine generate_random\n\nend program RandomNumberGenerator\n```"
  },
  {
    "task": "Implement a program that performs image processing and catches exceptions for unsupported file dimensions.",
    "code": "```fortran\nprogram ImageProcessing\n  implicit none\n  integer :: status\n  integer, parameter :: unsupported_dimensions = 1\n\n  call processImage(status)\n\ncontains\n\n  subroutine processImage(status)\n    integer, intent(out) :: status\n    integer :: width, height\n\n    ! Assume here that width and height are obtained from the file\n    width = 3000\n    height = 3000\n\n    ! Check for unsupported dimensions\n    if (width > 2000 .or. height > 2000) then\n      status = unsupported_dimensions\n    else\n      status = 0\n      ! Continue with image processing\n    end if\n\n    ! Exception handling\n    if (status == unsupported_dimensions) then\n      print *, \"Error: Unsupported file dimensions.\"\n      return\n    endif\n\n  end subroutine processImage\n\nend program ImageProcessing\n```"
  },
  {
    "task": "Write a function that manipulates strings and manages exceptions for invalid operations.",
    "code": "```fortran\nmodule string_utils\n  implicit none\ncontains\n\n  subroutine manipulate_string(input_str, output_str, error_flag)\n    character(len=*), intent(in) :: input_str\n    character(len=:), allocatable, intent(out) :: output_str\n    logical, intent(out) :: error_flag\n    integer :: i, len\n    character(len=1) :: temp\n\n    error_flag = .false.\n    len = len_trim(input_str)\n\n    if (len <= 0) then\n      error_flag = .true.\n      return\n    end if\n\n    allocate(character(len=len) :: output_str)\n    output_str = input_str\n\n    ! Attempt to reverse the string\n    do i = 1, len/2\n      temp = output_str(i:i)\n      output_str(i:i) = output_str(len-i+1:len-i+1)\n      output_str(len-i+1:len-i+1) = temp\n    end do\n\n  end subroutine manipulate_string\n\nend module string_utils\n```"
  },
  {
    "task": "Create a script that automates tasks and handles exceptions for missing dependencies.",
    "code": "```fortran\nprogram TaskAutomation\n    implicit none\n    integer :: status\n\n    ! Try to call an external dependency\n    call executeTask(status)\n\n    ! Check for errors using status code\n    if (status /= 0) then\n        print *, \"Error: Missing dependency or execution failed.\"\n    else\n        print *, \"Task executed successfully.\"\n    end if\n\ncontains\n\n    subroutine executeTask(status)\n        integer, intent(out) :: status\n        character(len=100) :: command\n        integer :: commandStatus\n        \n        command = 'external_dependency_command'\n\n        ! Execute the system command and capture the status\n        call execute_command_line(command, exitstat=commandStatus)\n\n        ! Check if the command executed successfully\n        if (commandStatus /= 0) then\n            status = 1  ! Indicating an error\n        else\n            status = 0  ! Indicating success\n        end if\n    end subroutine executeTask\n\nend program TaskAutomation\n```"
  },
  {
    "task": "Develop a function that accesses nested data structures and manages key access exceptions.",
    "code": "```fortran\nmodule exception_handling_module\n  implicit none\ncontains\n  subroutine access_nested_data(key)\n    character(len=*), intent(in) :: key\n    character(len=100) :: value\n    integer :: ios\n\n    ! Simulate a nested data structure using a Fortran derived type\n    type :: nested_data\n      character(len=100) :: key1\n      character(len=100) :: key2\n    end type nested_data\n\n    type(nested_data) :: data\n\n    ! Initialize the nested data structure\n    data%key1 = \"value1\"\n    data%key2 = \"value2\"\n\n    ! Exception handling for key access\n    ios = 0\n    select case (key)\n    case (\"key1\")\n      value = data%key1\n    case (\"key2\")\n      value = data%key2\n    case default\n      ios = 1  ! Exception: key not found\n    end select\n\n    if (ios /= 0) then\n      print*, \"Exception: Key not found\"\n    else\n      print*, \"Accessed value: \", value\n    endif\n  end subroutine access_nested_data\nend module exception_handling_module\n```"
  },
  {
    "task": "Design a program that synchronizes data between sources and handles data mismatch exceptions.",
    "code": "```fortran\nprogram DataSynchronization\n    implicit none\n    integer :: status\n    logical :: dataMatch\n\n    ! Example data sources\n    integer :: source1(5) = [1, 2, 3, 4, 5]\n    integer :: source2(5) = [1, 2, 3, 8, 5]\n\n    ! Synchronization with error handling\n    call synchronizeData(source1, source2, status)\n\ncontains\n\n    subroutine synchronizeData(src1, src2, stat)\n        integer, intent(in) :: src1(:), src2(:)\n        integer, intent(out) :: stat\n        logical :: mismatch\n        integer :: i\n\n        mismatch = .false.\n        do i = 1, size(src1)\n            if (src1(i) /= src2(i)) then\n                mismatch = .true.\n                exit\n            end if\n        end do\n\n        if (mismatch) then\n            call handleMismatch()\n            stat = 1\n        else\n            ! Synchronization logic here\n            print *, 'Data synchronized successfully.'\n            stat = 0\n        end if\n\n    end subroutine synchronizeData\n\n    subroutine handleMismatch()\n        print *, 'Data mismatch detected. Exception handled.'\n    end subroutine handleMismatch\n\nend program DataSynchronization\n```"
  },
  {
    "task": "Write a function that interacts with hardware devices and handles connection failure exceptions.",
    "code": "```fortran\nmodule hardware_module\n  implicit none\ncontains\n  subroutine connect_to_device()\n    implicit none\n    integer :: io_status\n\n    ! Attempt to open connection to a hardware device\n    open(unit=10, file='/dev/hardware_device', status='old', action='readwrite', iostat=io_status)\n    if (io_status /= 0) then\n      call handle_connection_failure(io_status)\n      return\n    end if\n    \n    ! Connection successful, perform operations\n    ! ... (hardware interaction code here)\n\n    ! Close the connection\n    close(unit=10)\n  end subroutine connect_to_device\n\n  subroutine handle_connection_failure(io_status)\n    implicit none\n    integer, intent(in) :: io_status\n\n    print *, 'Error: Connection to hardware device failed with status', io_status\n    ! Additional error handling logic can be added here\n  end subroutine handle_connection_failure\nend module hardware_module\n```"
  },
  {
    "task": "Create a tool that compresses files and manages exceptions for unsupported compression formats.",
    "code": "```fortran\nprogram FileCompressor\n    implicit none\n    character(len=100) :: filename\n    character(len=20) :: format\n    integer :: ios\n    logical :: supported\n\n    print *, \"Enter the filename:\"\n    read(*, '(A)') filename\n    print *, \"Enter the compression format (e.g., zip, gzip):\"\n    read(*, '(A)') format\n\n    supported = check_supported_format(format)\n\n    if (.not. supported) then\n        print *, \"Error: Unsupported compression format!\"\n        stop\n    end if\n\n    call compress_file(filename, format, ios)\n\n    if (ios /= 0) then\n        print *, \"Error: Compression failed with IOSTAT =\", ios\n    else\n        print *, \"File compressed successfully.\"\n    end if\n\ncontains\n\n    function check_supported_format(fmt) result(supported)\n        character(len=*), intent(in) :: fmt\n        logical :: supported\n        supported = (fmt == \"zip\" .or. fmt == \"gzip\")\n    end function check_supported_format\n\n    subroutine compress_file(fname, fmt, ios)\n        character(len=*), intent(in) :: fname, fmt\n        integer, intent(out) :: ios\n        ios = 0\n        ! Mock compression logic (as actual compression needs external library)\n        if (fmt == \"zip\") then\n            ! Call zip compression routine\n        else if (fmt == \"gzip\") then\n            ! Call gzip compression routine\n        else\n            ios = -1\n        end if\n    end subroutine compress_file\n\nend program FileCompressor\n```"
  },
  {
    "task": "Implement a function that parses command-line arguments and handles missing argument exceptions.",
    "code": "```fortran\nprogram parse_arguments\n    implicit none\n    integer :: argc, i\n    character(len=255), allocatable :: argv(:)\n\n    call get_command_argument_count(argc)\n    allocate(argv(argc))\n\n    do i = 1, argc\n        call get_command_argument(i, argv(i))\n    end do\n\n    call handle_arguments(argc, argv)\n\ncontains\n\n    subroutine handle_arguments(count, args)\n        integer, intent(in) :: count\n        character(len=255), intent(in) :: args(:)\n\n        if (count == 0) then\n            print *, \"Exception: No command-line arguments provided.\"\n            stop\n        else\n            print *, \"Command-line arguments:\"\n            print *, args\n        end if\n    end subroutine handle_arguments\n\nend program parse_arguments\n```"
  },
  {
    "task": "Develop a program that simulates user interactions and manages timing exceptions.",
    "code": "```fortran\nprogram user_interaction\n    implicit none\n    integer :: status\n    real :: time_limit, elapsed_time\n\n    ! Initialize timing variables\n    time_limit = 5.0\n    elapsed_time = 0.0\n\n    call simulate_interaction(status, elapsed_time)\n\n    if (status /= 0) then\n        print *, \"An exception occurred during interaction.\"\n    else\n        print *, \"User interaction completed successfully.\"\n    end if\n\ncontains\n\n    subroutine simulate_interaction(status, elapsed_time)\n        integer, intent(out) :: status\n        real, intent(inout) :: elapsed_time\n        real :: start_time, end_time\n\n        status = 0\n        call cpu_time(start_time)\n\n        ! Simulate interaction\n        pause_interaction()\n\n        call cpu_time(end_time)\n        elapsed_time = end_time - start_time\n\n        if (elapsed_time > time_limit) then\n            status = 1\n        end if\n    end subroutine simulate_interaction\n\n    subroutine pause_interaction()\n        ! Simulate a delay in interaction\n        call sleep(6)\n    end subroutine pause_interaction\n\n    subroutine sleep(seconds)\n        integer, intent(in) :: seconds\n        integer :: i\n        do i = 1, seconds * 100000000\n            ! Busy wait\n        end do\n    end subroutine sleep\n\nend program user_interaction\n```"
  },
  {
    "task": "Write a function that encrypts data and handles exceptions for unsupported encryption algorithms.",
    "code": "```fortran\nmodule encryption_module\n  implicit none\ncontains\n  function encrypt_data(data, algorithm) result(encrypted_data)\n    character(len=*), intent(in) :: data\n    character(len=*), intent(in) :: algorithm\n    character(len=:), allocatable :: encrypted_data\n    \n    encrypted_data = \"\"\n    select case (trim(algorithm))\n    case (\"AES\")\n      encrypted_data = \"[AES_ENCRYPTED]\" // data\n    case (\"DES\")\n      encrypted_data = \"[DES_ENCRYPTED]\" // data\n    case default\n      call handle_unsupported_algorithm(algorithm)\n    end select\n  end function encrypt_data\n\n  subroutine handle_unsupported_algorithm(algorithm)\n    character(len=*), intent(in) :: algorithm\n    print *, \"Error: Unsupported encryption algorithm - \", algorithm\n    stop 1\n  end subroutine handle_unsupported_algorithm\n\nend module encryption_module\n```"
  },
  {
    "task": "Create a system that aggregates data and manages exceptions for data inconsistency.",
    "code": "```fortran\nprogram DataAggregator\n    implicit none\n    integer, parameter :: n = 10\n    integer :: i, data(n), sum\n    logical :: success\n\n    ! Initialize data for demonstration\n    data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    sum = 0\n    success = .true.\n\n    ! Aggregate data and handle potential exceptions\n    do i = 1, n\n        call aggregateData(data(i), sum, success)\n        if (.not. success) then\n            print *, \"Data inconsistency detected at index:\", i\n            exit\n        end if\n    end do\n\n    if (success) print *, \"Total sum is:\", sum\n\ncontains\n\n    subroutine aggregateData(value, total, status)\n        integer, intent(in) :: value\n        integer, intent(inout) :: total\n        logical, intent(out) :: status\n\n        status = .true.\n\n        ! Simulate an exception for demonstration\n        if (value < 0) then\n            status = .false.\n        else\n            total = total + value\n        end if\n    end subroutine aggregateData\n\nend program DataAggregator\n```"
  },
  {
    "task": "Design a program that processes real-time data streams and handles connection drop exceptions.",
    "code": "```fortran\nprogram DataStreamProcessor\n    implicit none\n    logical :: connection_active\n    real :: data\n\n    call initialize_connection(connection_active)\n\n    do while (.true.)\n        call process_data_stream(connection_active, data)\n        if (.not. connection_active) then\n            call handle_connection_exception()\n            call reconnect(connection_active)\n        endif\n    end do\n\ncontains\n\n    subroutine initialize_connection(conn_active)\n        logical, intent(out) :: conn_active\n        ! Initialize connection to data stream\n        conn_active = .true.\n    end subroutine initialize_connection\n\n    subroutine process_data_stream(conn_active, data)\n        logical, intent(inout) :: conn_active\n        real, intent(out) :: data\n\n        ! Simulate data stream processing\n        if (rand() < 0.05) then\n            conn_active = .false.\n        else\n            data = rand()\n        endif\n    end subroutine process_data_stream\n\n    subroutine handle_connection_exception()\n        ! Handle the exception of connection drop\n        print *, \"Connection dropped, attempting to reconnect...\"\n    end subroutine handle_connection_exception\n\n    subroutine reconnect(conn_active)\n        logical, intent(out) :: conn_active\n        ! Simulate reconnection attempt\n        conn_active = .true.\n    end subroutine reconnect\n\n    real function rand()\n        call random_number(rand)\n    end function rand\n\nend program DataStreamProcessor\n```"
  },
  {
    "task": "Implement a function that performs scientific calculations and manages precision exceptions.",
    "code": "```fortran\nprogram scientific_calculations\n  implicit none\n  real(8) :: result\n  logical :: precision_error\n\n  call calculate(result, precision_error)\n\n  if (precision_error) then\n     print *, \"Precision error encountered in calculations.\"\n  else\n     print *, \"Calculation result: \", result\n  end if\n\ncontains\n\n  subroutine calculate(res, prec_err)\n    real(8), intent(out) :: res\n    logical, intent(out) :: prec_err\n    real(8) :: x, y\n\n    prec_err = .false.\n    x = 1.0d0\n    y = 3.0d0\n    \n    ! Example calculation\n    res = x / y\n\n    ! Check for precision error\n    if (abs(res - (x / y)) > 1.0d-15) then\n       prec_err = .true.\n    end if\n\n  end subroutine calculate\n\nend program scientific_calculations\n```"
  },
  {
    "task": "Write a script that generates reports and handles exceptions for missing data sources.",
    "code": "```fortran\nprogram ReportGenerator\n    implicit none\n    character(len=256) :: data_source\n    logical :: data_exists\n\n    data_source = \"data.txt\"\n    data_exists = .false.\n\n    call check_data_source(data_source, data_exists)\n\n    if (data_exists) then\n        call generate_report(data_source)\n    else\n        print *, \"Error: Missing data source.\"\n    end if\n\ncontains\n\n    subroutine check_data_source(source, exists)\n        character(len=*), intent(in) :: source\n        logical, intent(out) :: exists\n        inquire(file=source, exist=exists)\n    end subroutine check_data_source\n\n    subroutine generate_report(source)\n        character(len=*), intent(in) :: source\n        ! Here would be the logic to generate the report\n        print *, \"Generating report from\", source\n    end subroutine generate_report\n\nend program ReportGenerator\n```"
  },
  {
    "task": "Create a program that validates digital certificates and manages trust exceptions.",
    "code": "```fortran\nprogram CertificateValidator\n    implicit none\n    character(len=100) :: certificate\n    logical :: isValid\n\n    print *, \"Enter the digital certificate:\"\n    read *, certificate\n\n    call validateCertificate(certificate, isValid)\n\n    if (.not. isValid) then\n        call handleException(certificate)\n    else\n        print *, \"Certificate is valid.\"\n    end if\n\ncontains\n\n    subroutine validateCertificate(cert, isValid)\n        character(len=100), intent(in) :: cert\n        logical, intent(out) :: isValid\n\n        ! Placeholder logic for certificate validation\n        if (cert == \"trusted_certificate\") then\n            isValid = .true.\n        else\n            isValid = .false.\n        end if\n    end subroutine validateCertificate\n\n    subroutine handleException(cert)\n        character(len=100), intent(in) :: cert\n        character(len=1) :: response\n\n        print *, \"Certificate not trusted. Add to exceptions? (y/n)\"\n        read *, response\n\n        if (response == 'y') then\n            print *, \"Certificate added to trust exceptions.\"\n        else\n            print *, \"Certificate not added to exceptions.\"\n        end if\n    end subroutine handleException\n\nend program CertificateValidator\n```"
  },
  {
    "task": "Develop a function that schedules tasks and handles exceptions for scheduling conflicts.",
    "code": "```fortran\nmodule scheduler\n  implicit none\n  private\n  public :: schedule_task\n\ncontains\n\n  subroutine schedule_task(task_id, start_time, end_time, status)\n    implicit none\n    integer, intent(in) :: task_id\n    integer, intent(in) :: start_time, end_time\n    logical, intent(out) :: status\n\n    ! Array to store scheduled tasks\n    integer, allocatable :: scheduled_tasks(:,:)\n    integer :: i, num_tasks\n    logical :: conflict\n\n    ! Exception handling for memory allocation\n    status = .false.\n    conflict = .false.\n\n    ! Allocate if not already allocated\n    if (.not. allocated(scheduled_tasks)) then\n      allocate(scheduled_tasks(0:1, 0))\n    end if\n\n    num_tasks = size(scheduled_tasks, 2)\n\n    ! Check for scheduling conflicts\n    do i = 1, num_tasks\n      if (.not. conflict) then\n        if ((start_time < scheduled_tasks(2, i) .and. &\n             end_time > scheduled_tasks(1, i)) .or. &\n            (task_id == scheduled_tasks(1, i))) then\n          conflict = .true.\n        end if\n      end if\n    end do\n\n    if (conflict) then\n      write(*,*) \"Scheduling conflict detected for task:\", task_id\n      return\n    end if\n\n    ! Add the task to the schedule if no conflict\n    call add_task(task_id, start_time, end_time, scheduled_tasks)\n    status = .true.\n    \n  end subroutine schedule_task\n\n  subroutine add_task(task_id, start_time, end_time, scheduled_tasks)\n    implicit none\n    integer, intent(in) :: task_id, start_time, end_time\n    integer, allocatable, intent(inout) :: scheduled_tasks(:,:)\n    integer :: num_tasks\n\n    num_tasks = size(scheduled_tasks, 2)\n    call extend_array(scheduled_tasks, num_tasks + 1)\n    scheduled_tasks(:, num_tasks + 1) = (/start_time, end_time/)\n\n  end subroutine add_task\n\n  subroutine extend_array(array, new_size)\n    implicit none\n    integer, allocatable, intent(inout) :: array(:,:)\n    integer, intent(in) :: new_size\n    integer, allocatable :: temp(:,:)\n\n    allocate(temp(2, new_size))\n    temp(:, 1:size(array, 2)) = array\n    array = temp\n  end subroutine extend_array\n\nend module scheduler\n```"
  },
  {
    "task": "Design a system that manages user sessions and handles session timeout exceptions.",
    "code": "```fortran\nmodule session_module\n  implicit none\n  private\n  public :: start_session, end_session, check_session\n\n  type :: session\n     character(len=256) :: user_id\n     real :: start_time\n  end type session\n\n  type(session), allocatable :: current_session\n\ncontains\n\n  subroutine start_session(user_id)\n    character(len=*), intent(in) :: user_id\n    real :: current_time\n\n    call get_current_time(current_time)\n\n    allocate(current_session)\n    current_session%user_id = user_id\n    current_session%start_time = current_time\n\n  end subroutine start_session\n\n  subroutine end_session()\n    if (allocated(current_session)) then\n      deallocate(current_session)\n    endif\n  end subroutine end_session\n\n  subroutine check_session()\n    real :: current_time\n    real :: session_duration\n    real, parameter :: timeout_limit = 3600.0  ! 1 hour\n\n    if (.not. allocated(current_session)) then\n      print *, \"Error: No active session.\"\n      return\n    endif\n\n    call get_current_time(current_time)\n    session_duration = current_time - current_session%start_time\n\n    if (session_duration > timeout_limit) then\n      print *, \"Session timeout. Ending session.\"\n      call end_session()\n    else\n      print *, \"Session active. Duration:\", session_duration\n    endif\n\n  end subroutine check_session\n\n  subroutine get_current_time(current_time)\n    real, intent(out) :: current_time\n    ! Mock current time for demonstration\n    current_time = 7200.0\n  end subroutine get_current_time\n\nend module session_module\n\nprogram session_manager\n  use session_module\n  implicit none\n\n  call start_session(\"user123\")\n  call check_session()\n  call end_session()\n\nend program session_manager\n```"
  },
  {
    "task": "Write a function that processes audio files and manages exceptions for unsupported audio formats.",
    "code": "```fortran\nmodule audio_processor\n  implicit none\ncontains\n\n  subroutine process_audio_file(filename)\n    character(len=*), intent(in) :: filename\n    integer :: ios, unit\n\n    open(newunit=unit, file=filename, status='old', action='read', iostat=ios)\n    if (ios /= 0) then\n      call handle_exception('Error: Unable to open file.')\n      return\n    end if\n\n    ! Here you would typically read the file and check the format.\n    ! For demonstration, let's assume unsupported format leads to ios = 1\n    ios = 1\n\n    if (ios == 1) then\n      call handle_exception('Error: Unsupported audio format.')\n      close(unit)\n      return\n    end if\n\n    ! Process the audio file here.\n\n    close(unit)\n  end subroutine process_audio_file\n\n  subroutine handle_exception(message)\n    character(len=*), intent(in) :: message\n    print *, message\n  end subroutine handle_exception\n\nend module audio_processor\n```"
  },
  {
    "task": "Create a service that sends notifications and handles exceptions for unreachable destinations.",
    "code": "```fortran\nprogram NotificationService\n    implicit none\n\n    character(len=256) :: destination\n    logical :: success\n\n    ! Initialize destination\n    destination = \"some_destination\"\n\n    ! Try to send the notification\n    success = sendNotification(destination)\n\n    ! Check if the notification was successful\n    if (.not. success) then\n        call handleException(destination)\n    end if\n\ncontains\n\n    function sendNotification(dest) result(success)\n        character(len=*), intent(in) :: dest\n        logical :: success\n\n        ! Simulate sending notification\n        success = .true.  ! Assume success, replace with actual logic\n\n        ! Simulate an unreachable destination\n        if (dest == \"unreachable\") then\n            success = .false.\n        end if\n    end function sendNotification\n\n    subroutine handleException(dest)\n        character(len=*), intent(in) :: dest\n\n        print *, \"Error: Unable to reach destination:\", trim(dest)\n    end subroutine handleException\n\nend program NotificationService\n```"
  },
  {
    "task": "Implement a program that performs data migration and manages data transformation exceptions.",
    "code": "```fortran\nprogram DataMigration\n    implicit none\n    integer :: i, inputData(5), transformedData(5)\n    character(len=100) :: errorMsg\n\n    ! Sample input data\n    inputData = [1, 2, 3, 4, 5]\n    \n    do i = 1, 5\n        call transformData(inputData(i), transformedData(i), errorMsg)\n        if (len_trim(errorMsg) > 0) then\n            print *, 'Error in data transformation:', trim(errorMsg)\n        else\n            print *, 'Data transformed successfully:', transformedData(i)\n        end if\n    end do\n\ncontains\n\n    subroutine transformData(input, output, errorMsg)\n        integer, intent(in) :: input\n        integer, intent(out) :: output\n        character(len=100), intent(out) :: errorMsg\n\n        errorMsg = ''\n        ! Dummy transformation: square the input\n        ! Introduce an artificial error for demonstration\n        if (input == 3) then\n            errorMsg = 'Transformation error for input value 3'\n            output = -1\n        else\n            output = input * input\n        end if\n    end subroutine transformData\n\nend program DataMigration\n```"
  },
  {
    "task": "Develop a function that processes video files and handles codec compatibility exceptions.",
    "code": "```fortran\nmodule video_processing\n  implicit none\ncontains\n  subroutine process_video(filename)\n    character(len=*), intent(in) :: filename\n    integer :: ios\n    logical :: codec_compatible\n\n    call check_codec_compatibility(filename, codec_compatible, ios)\n\n    if (ios /= 0) then\n      print *, 'Error: Unable to process the video file due to codec incompatibility.'\n    else\n      print *, 'Video file processed successfully.'\n    end if\n\n  end subroutine process_video\n\n  subroutine check_codec_compatibility(filename, compatible, ios)\n    character(len=*), intent(in) :: filename\n    logical, intent(out) :: compatible\n    integer, intent(out) :: ios\n\n    ios = 0\n    compatible = .false.\n\n    ! Simulate codec compatibility check\n    if (filename == \"compatible_video\") then\n      compatible = .true.\n    else\n      ios = 1\n    end if\n\n  end subroutine check_codec_compatibility\n\nend module video_processing\n```"
  },
  {
    "task": "Write a function that manages memory allocation and catches out-of-memory exceptions.",
    "code": "```fortran\nmodule memory_manager\n  implicit none\ncontains\n  subroutine manage_memory(n)\n    integer, intent(in) :: n\n    real, allocatable :: array(:)\n    logical :: allocation_success\n\n    allocation_success = .true.\n    allocate(array(n), stat=allocation_status)\n\n    if (allocation_status /= 0) then\n      allocation_success = .false.\n      print *, \"Error: Out of memory\"\n    else\n      print *, \"Memory allocated successfully\"\n    end if\n\n    if (allocation_success) then\n      ! Perform operations with the array\n      deallocate(array)\n    endif\n  end subroutine manage_memory\nend module memory_manager\n```"
  },
  {
    "task": "Create a program that processes financial transactions and handles currency conversion exceptions.",
    "code": "```fortran\nprogram financial_transactions\n    implicit none\n    real :: amount, converted_amount\n    character(len=3) :: currency\n    integer :: iostat\n\n    print *, 'Enter amount and currency (e.g., 100 USD):'\n    read *, amount, currency\n\n    call convert_currency(amount, currency, converted_amount, iostat)\n\n    if (iostat /= 0) then\n        print *, 'Error: Invalid currency or conversion issue.'\n    else\n        print *, 'Converted Amount:', converted_amount\n    end if\nend program financial_transactions\n\nsubroutine convert_currency(amount, currency, converted_amount, iostat)\n    implicit none\n    real, intent(in) :: amount\n    character(len=3), intent(in) :: currency\n    real, intent(out) :: converted_amount\n    integer, intent(out) :: iostat\n\n    iostat = 0\n    select case (currency)\n    case ('USD')\n        converted_amount = amount * 0.85  ! USD to EUR conversion rate\n    case ('EUR')\n        converted_amount = amount * 1.18  ! EUR to USD conversion rate\n    case default\n        iostat = 1\n    end select\nend subroutine convert_currency\n```"
  },
  {
    "task": "Design a function that interacts with cloud storage and manages access permission exceptions.",
    "code": "```fortran\nmodule cloud_storage\n  implicit none\n  private\n  public :: access_cloud_storage\n\ncontains\n\n  function access_cloud_storage(file_name) result(status)\n    character(len=*), intent(in) :: file_name\n    integer :: status\n    integer :: ios\n    character(len=256) :: errmsg\n\n    ! Placeholder for cloud storage interaction\n    ! Attempt to open the file to simulate accessing cloud storage\n    open(unit=10, file=file_name, status='old', iostat=ios, iomsg=errmsg)\n    \n    if (ios /= 0) then\n      write(*,*) 'Error accessing cloud storage:', trim(errmsg)\n      status = ios\n    else\n      write(*,*) 'Access to cloud storage successful.'\n      status = 0\n      close(10)\n    end if\n\n  end function access_cloud_storage\n\nend module cloud_storage\n```"
  },
  {
    "task": "Implement a script that automates deployment and handles exceptions for missing configuration files.",
    "code": "```fortran\nprogram deployment\n    implicit none\n    character(len=256) :: config_file\n    integer :: io_status\n\n    config_file = 'config.txt'\n\n    open(unit=10, file=config_file, status='old', action='read', iostat=io_status)\n\n    if (io_status /= 0) then\n        print *, 'Error: Configuration file not found.'\n        stop\n    end if\n\n    ! Proceed with deployment steps here.\n    \n    close(10)\nend program deployment\n```"
  },
  {
    "task": "Write a function that normalizes data and handles exceptions for invalid data ranges.",
    "code": "```fortran\nmodule data_normalization\n  implicit none\ncontains\n\n  function normalize_data(data, n) result(normalized)\n    real, intent(in) :: data(:)\n    integer, intent(in) :: n\n    real :: normalized(size(data))\n    real :: min_val, max_val\n    integer :: i\n\n    min_val = minval(data)\n    max_val = maxval(data)\n\n    if (n <= 0) then\n      print *, \"Error: Invalid size\"\n      stop\n    end if\n\n    if (max_val == min_val) then\n      print *, \"Error: Invalid data range\"\n      stop\n    end if\n\n    do i = 1, n\n      normalized(i) = (data(i) - min_val) / (max_val - min_val)\n    end do\n\n  end function normalize_data\n\nend module data_normalization\n```"
  },
  {
    "task": "Create a system that monitors application performance and handles threshold breach exceptions.",
    "code": "```fortran\nprogram PerformanceMonitor\n    implicit none\n    real :: performance_metric\n    real, parameter :: threshold = 75.0\n    logical :: threshold_breached\n\n    ! Simulate performance monitoring\n    performance_metric = 80.0\n\n    ! Check for threshold breach\n    threshold_breached = .false.\n\n    ! Exception handling for threshold breach\n    call check_threshold(performance_metric, threshold, threshold_breached)\n\n    if (threshold_breached) then\n        call handle_exception(performance_metric)\n    else\n        print *, \"Performance is within acceptable limits.\"\n    end if\n\ncontains\n\n    subroutine check_threshold(metric, limit, breached)\n        real, intent(in) :: metric, limit\n        logical, intent(out) :: breached\n\n        if (metric > limit) then\n            breached = .true.\n        else\n            breached = .false.\n        end if\n    end subroutine check_threshold\n\n    subroutine handle_exception(metric)\n        real, intent(in) :: metric\n\n        print *, \"Exception: Performance metric\", metric, \"exceeds threshold!\"\n        ! Additional exception handling code can be added here\n    end subroutine handle_exception\n\nend program PerformanceMonitor\n```"
  },
  {
    "task": "Develop a program that processes social media data and manages API limit exceptions.",
    "code": "```fortran\nprogram SocialMediaDataProcessing\n  implicit none\n  integer :: api_limit, i\n  integer, parameter :: max_attempts = 5\n  logical :: api_limit_exceeded\n\n  api_limit = 100  ! Example value, this should be fetched from the API\n  api_limit_exceeded = .false.\n\n  do i = 1, max_attempts\n    call process_data(api_limit, api_limit_exceeded)\n    if (.not. api_limit_exceeded) exit\n    ! Handle exception by waiting and retrying\n    call handle_api_limit_exception()\n  end do\n\n  if (api_limit_exceeded) then\n    print *, \"Failed to process data due to API limit.\"\n  else\n    print *, \"Data processing successful.\"\n  endif\n\ncontains\n\n  subroutine process_data(api_limit, exceeded)\n    integer, intent(in) :: api_limit\n    logical, intent(out) :: exceeded\n    ! Simulate data processing and check API limit\n    exceeded = .false.\n    if (api_limit < 10) then\n      exceeded = .true.\n    endif\n  end subroutine process_data\n\n  subroutine handle_api_limit_exception()\n    ! Simulate waiting or other strategies to handle API limit\n    print *, \"API limit exceeded, waiting to retry...\"\n  end subroutine handle_api_limit_exception\n\nend program SocialMediaDataProcessing\n```"
  },
  {
    "task": "Design a function that integrates with payment gateways and handles payment failure exceptions.",
    "code": "```fortran\nmodule payment_module\n  implicit none\ncontains\n\n  subroutine process_payment(amount, is_successful)\n    real :: amount\n    logical :: is_successful\n    \n    ! Simulate a payment process\n    call initiate_payment(amount, is_successful)\n    \n    ! Exception handling for payment failure\n    if (.not. is_successful) then\n      call handle_payment_failure()\n    end if\n\n  end subroutine process_payment\n\n  subroutine initiate_payment(amount, is_successful)\n    real :: amount\n    logical :: is_successful\n\n    ! Simulation: Randomly determine success or failure\n    if (mod(int(amount), 2) == 0) then\n      is_successful = .true.\n    else\n      is_successful = .false.\n    end if\n  end subroutine initiate_payment\n\n  subroutine handle_payment_failure()\n    print *, \"Payment failed. Please try again or contact support.\"\n  end subroutine handle_payment_failure\n\nend module payment_module\n```"
  },
  {
    "task": "Write a function that backs up data and handles exceptions for unavailable storage media.",
    "code": "```fortran\nprogram BackupData\n    implicit none\n    call perform_backup()\n\ncontains\n\n    subroutine perform_backup()\n        implicit none\n        logical :: storage_available\n        \n        ! Simulate check for storage availability\n        storage_available = .false.\n\n        ! Exception handling for storage availability\n        block\n            if (.not. storage_available) then\n                call error_stop(\"Storage media is unavailable.\")\n            else\n                call backup_data()\n            end if\n        end block\n    end subroutine perform_backup\n\n    subroutine backup_data()\n        implicit none\n        ! Backup logic would be implemented here\n        print *, \"Data backup successful.\"\n    end subroutine backup_data\n\n    subroutine error_stop(msg)\n        implicit none\n        character(len=*), intent(in) :: msg\n        print *, \"Error: \", msg\n        stop\n    end subroutine error_stop\n\nend program BackupData\n```"
  },
  {
    "task": "Create a tool that manages software updates and handles exceptions for version conflicts.",
    "code": "```fortran\nmodule update_manager\n  implicit none\n  private\n  public :: manage_updates\n\ncontains\n\n  subroutine manage_updates(current_version, new_version)\n    character(len=*), intent(in) :: current_version, new_version\n    integer :: ios\n    character(len=256) :: errmsg\n\n    call handle_update(current_version, new_version, ios, errmsg)\n\n    if (ios /= 0) then\n      print *, \"Error: \", trim(errmsg)\n    else\n      print *, \"Update successful from version \", trim(current_version), \" to \", trim(new_version)\n    end if\n  end subroutine manage_updates\n\n  subroutine handle_update(curr_ver, new_ver, ios, errmsg)\n    character(len=*), intent(in) :: curr_ver, new_ver\n    integer, intent(out) :: ios\n    character(len=256), intent(out) :: errmsg\n\n    ios = 0\n    errmsg = \"\"\n\n    if (curr_ver == new_ver) then\n      ios = 1\n      errmsg = \"Version conflict: current version and new version are the same.\"\n      return\n    end if\n\n  end subroutine handle_update\n\nend module update_manager\n\nprogram main\n  use update_manager\n  implicit none\n\n  call manage_updates(\"1.0.0\", \"1.0.0\")\n  call manage_updates(\"1.0.0\", \"1.1.0\")\n\nend program main\n```"
  },
  {
    "task": "Implement a program that performs sentiment analysis and manages exceptions for ambiguous texts.",
    "code": "```fortran\nprogram SentimentAnalysis\n    implicit none\n    character(len=100) :: text\n    character(len=10) :: sentiment\n    logical :: ambiguous\n\n    write(*,*) \"Enter text for sentiment analysis:\"\n    read(*,*) text\n\n    call analyze_sentiment(text, sentiment, ambiguous)\n\n    if (ambiguous) then\n        write(*,*) \"Error: The text is too ambiguous to determine sentiment.\"\n    else\n        write(*,*) \"The sentiment of the text is: \", sentiment\n    end if\n\ncontains\n\n    subroutine analyze_sentiment(text, sentiment, ambiguous)\n        character(len=100), intent(in) :: text\n        character(len=10), intent(out) :: sentiment\n        logical, intent(out) :: ambiguous\n        integer :: i, positive_count, negative_count\n        character(len=10), dimension(2) :: positive_words = (/ 'good', 'happy' /)\n        character(len=10), dimension(2) :: negative_words = (/ 'bad', 'sad' /)\n\n        positive_count = 0\n        negative_count = 0\n        ambiguous = .false.\n\n        do i = 1, size(positive_words)\n            if (index(text, trim(positive_words(i))) > 0) positive_count = positive_count + 1\n        end do\n\n        do i = 1, size(negative_words)\n            if (index(text, trim(negative_words(i))) > 0) negative_count = negative_count + 1\n        end do\n\n        if (positive_count > 0 .and. negative_count > 0) then\n            ambiguous = .true.\n            return\n        else if (positive_count > negative_count) then\n            sentiment = 'Positive'\n        else if (negative_count > positive_count) then\n            sentiment = 'Negative'\n        else\n            ambiguous = .true.\n        end if\n    end subroutine analyze_sentiment\n\nend program SentimentAnalysis\n```"
  },
  {
    "task": "Develop a function that manages user authentication and handles credential mismatch exceptions.",
    "code": "```fortran\nmodule auth_module\n  implicit none\n  private\n  public :: authenticate_user\n\ncontains\n\n  subroutine authenticate_user(username, password, is_authenticated)\n    character(len=*), intent(in) :: username, password\n    logical, intent(out) :: is_authenticated\n    character(len=100) :: stored_username, stored_password\n    character(len=256) :: error_message\n\n    ! Simulate stored credentials\n    stored_username = \"admin\"\n    stored_password = \"securepassword\"\n\n    ! Initialize authentication status\n    is_authenticated = .false.\n\n    ! Exception handling for credential mismatch\n    block\n      if (trim(username) /= stored_username .or. trim(password) /= stored_password) then\n        error_message = \"Credential mismatch: Invalid username or password.\"\n        print *, error_message\n        exit\n      else\n        is_authenticated = .true.\n      end if\n    end block\n\n  end subroutine authenticate_user\n\nend module auth_module\n```"
  },
  {
    "task": "Write a program that processes geographic data and handles exceptions for invalid coordinates.",
    "code": "```fortran\nprogram process_geographic_data\n    implicit none\n    real :: latitude, longitude\n    character(len=256) :: error_message\n    logical :: invalid_coordinates\n\n    ! Initialize coordinates\n    latitude = -95.0\n    longitude = 185.0\n\n    ! Process data with exception handling\n    invalid_coordinates = .false.\n    error_message = \"\"\n\n    if (latitude < -90.0 .or. latitude > 90.0) then\n        invalid_coordinates = .true.\n        error_message = \"Error: Invalid latitude. Must be between -90 and 90.\"\n    else if (longitude < -180.0 .or. longitude > 180.0) then\n        invalid_coordinates = .true.\n        error_message = \"Error: Invalid longitude. Must be between -180 and 180.\"\n    end if\n\n    if (invalid_coordinates) then\n        print *, error_message\n    else\n        print *, \"Processing coordinates: \", latitude, longitude\n    end if\n\nend program process_geographic_data\n```"
  },
  {
    "task": "Create a script that manages network configurations and handles exceptions for invalid syntax.",
    "code": "```fortran\nprogram network_config\n    implicit none\n    character(len=256) :: config_line\n    logical :: is_valid\n    integer :: io_status\n\n    ! Open the configuration file\n    open(unit=10, file='network_config.txt', status='old', action='read', iostat=io_status)\n    if (io_status /= 0) then\n        print *, \"Error: Unable to open configuration file.\"\n        stop\n    end if\n\n    ! Read and process each line of the configuration file\n    do\n        read(10, '(A)', iostat=io_status) config_line\n        if (io_status /= 0) exit\n\n        ! Validate the configuration line\n        is_valid = validate_config(config_line)\n        if (.not. is_valid) then\n            print *, \"Warning: Invalid configuration syntax - \", trim(config_line)\n        else\n            ! Process the valid configuration line\n            call process_config(config_line)\n        end if\n    end do\n\n    close(10)\nend program network_config\n\nlogical function validate_config(line)\n    implicit none\n    character(len=*), intent(in) :: line\n    ! Dummy validation logic: treat non-empty lines as valid\n    validate_config = (len(trim(line)) > 0)\nend function validate_config\n\nsubroutine process_config(line)\n    implicit none\n    character(len=*), intent(in) :: line\n    ! Dummy processing logic: print the line\n    print *, \"Processing: \", trim(line)\nend subroutine process_config\n```"
  },
  {
    "task": "Design a function that processes biometric data and handles exceptions for sensor errors.",
    "code": "```fortran\nprogram BiometricProcessor\n  implicit none\n\n  call processBiometricData()\n\ncontains\n\n  subroutine processBiometricData()\n    implicit none\n    real :: sensorData\n    integer :: ioStatus\n\n    ! Simulate reading biometric data\n    open(unit=10, status='old', file='biometric_data.txt', action='read', iostat=ioStatus)\n    if (ioStatus /= 0) then\n      print *, \"Error opening file. Sensor error!\"\n      return\n    end if\n\n    read(10, *, iostat=ioStatus) sensorData\n    if (ioStatus /= 0) then\n      print *, \"Error reading data. Sensor error!\"\n      close(10)\n      return\n    end if\n\n    close(10)\n    print *, \"Biometric data processed successfully: \", sensorData\n\n  end subroutine processBiometricData\n\nend program BiometricProcessor\n```"
  },
  {
    "task": "Implement a system that manages access control and handles exceptions for unauthorized access attempts.",
    "code": "```fortran\nmodule access_control\n    implicit none\n    private\n    public :: check_access\n\ncontains\n\n    subroutine check_access(user_role, required_role)\n        character(len=*), intent(in) :: user_role, required_role\n        logical :: has_access\n\n        has_access = .false.\n\n        try\n            if (user_role == required_role) then\n                has_access = .true.\n            else\n                call unauthorized_access_exception()\n            end if\n\n        catch(unauthorized_access_exception)\n            print *, \"Exception: Unauthorized access attempt detected.\"\n            has_access = .false.\n\n        end try\n    end subroutine check_access\n\n    subroutine unauthorized_access_exception()\n        write(*,*) \"Unauthorized Access Exception\"\n        stop\n    end subroutine unauthorized_access_exception\n\nend module access_control\n```"
  },
  {
    "task": "Write a function that performs load balancing and handles exceptions for unreachable nodes.",
    "code": "```fortran\nmodule load_balancer\n  implicit none\ncontains\n\n  subroutine perform_load_balancing(nodes, loads, balanced_loads)\n    integer, intent(in) :: nodes(:)\n    real, intent(in) :: loads(:)\n    real, intent(out) :: balanced_loads(size(loads))\n    integer :: i, status\n\n    ! Assume nodes and loads have the same size\n    balanced_loads = loads\n\n    do i = 1, size(nodes)\n      status = 0\n      call balance_node(nodes(i), loads(i), balanced_loads(i), status)\n      if (status /= 0) then\n        print *, \"Warning: Node\", nodes(i), \"is unreachable.\"\n      end if\n    end do\n  end subroutine perform_load_balancing\n\n  subroutine balance_node(node, load, new_load, status)\n    integer, intent(in) :: node\n    real, intent(in) :: load\n    real, intent(out) :: new_load\n    integer, intent(out) :: status\n\n    ! Simulate load balancing and exception handling\n    if (is_unreachable(node)) then\n      status = 1\n      new_load = load\n    else\n      status = 0\n      new_load = load / 2.0  ! Example balancing logic\n    end if\n  end subroutine balance_node\n\n  logical function is_unreachable(node)\n    integer, intent(in) :: node\n\n    ! Simulate condition for an unreachable node\n    is_unreachable = (mod(node, 5) == 0)\n  end function is_unreachable\n\nend module load_balancer\n```"
  },
  {
    "task": "Create a program that simulates virtual environments and manages resource allocation exceptions.",
    "code": "```fortran\nprogram VirtualEnvironmentSimulator\n    implicit none\n    integer :: status\n    real, allocatable :: resources(:)\n    \n    ! Simulate environment setup\n    status = setupEnvironment(resources)\n    \n    select case (status)\n        case (0)\n            print *, \"Environment setup successful.\"\n            ! Proceed with simulation\n        case (1)\n            print *, \"Error: Resource allocation failed.\"\n        case default\n            print *, \"Unknown error occurred.\"\n    end select\n\ncontains\n\n    function setupEnvironment(resources) result(status)\n        real, allocatable :: resources(:)\n        integer :: status\n\n        status = 0\n        ! Attempt to allocate resources\n        allocate(resources(10), stat=status)\n        \n        if (status /= 0) then\n            status = 1\n        end if\n    end function setupEnvironment\n\nend program VirtualEnvironmentSimulator\n```"
  },
  {
    "task": "Develop a tool that manages digital rights and handles exceptions for unauthorized content access.",
    "code": "```fortran\nprogram DigitalRightsManager\n    implicit none\n    character(len=20) :: userRole\n    logical :: accessGranted\n\n    ! Simulate user role\n    userRole = 'guest'  ! Example role, change as needed\n\n    ! Attempt access and handle exceptions\n    call handleAccess(userRole, accessGranted)\n\ncontains\n\n    subroutine handleAccess(role, access)\n        character(len=20), intent(in) :: role\n        logical, intent(out) :: access\n        logical :: isAuthorized\n\n        ! Authorize based on role\n        isAuthorized = authorizeUser(role)\n\n        ! Handle exception if unauthorized\n        if (.not. isAuthorized) then\n            print *, 'Exception: Unauthorized access attempt detected.'\n            access = .false.\n        else\n            print *, 'Access granted for role: ', role\n            access = .true.\n        end if\n    end subroutine handleAccess\n\n    function authorizeUser(role) result(isAuthorized)\n        character(len=20), intent(in) :: role\n        logical :: isAuthorized\n\n        select case (role)\n        case ('admin')\n            isAuthorized = .true.\n        case ('user')\n            isAuthorized = .true.\n        case ('guest')\n            isAuthorized = .false.\n        case default\n            isAuthorized = .false.\n        end select\n    end function authorizeUser\n\nend program DigitalRightsManager\n```"
  },
  {
    "task": "Design a function that synchronizes clocks and handles exceptions for time drift.",
    "code": "```fortran\nmodule clock_sync_module\n  implicit none\ncontains\n  subroutine synchronize_clocks()\n    implicit none\n    real :: local_time, server_time\n    logical :: success\n\n    ! Initialize times (dummy values for illustration)\n    local_time = 12.0\n    server_time = 12.1\n\n    call sync_time(local_time, server_time, success)\n\n    if (.not. success) then\n      print *, \"Error: Time drift cannot be corrected.\"\n    else\n      print *, \"Clocks synchronized successfully.\"\n    end if\n  end subroutine synchronize_clocks\n\n  subroutine sync_time(local_time, server_time, success)\n    implicit none\n    real, intent(in) :: local_time, server_time\n    logical, intent(out) :: success\n    real :: drift\n\n    ! Calculate time drift\n    drift = abs(local_time - server_time)\n\n    ! Handle exception for time drift\n    if (drift > 0.05) then\n      success = .false.\n    else\n      success = .true.\n      ! Synchronize the clocks (dummy adjustment for illustration)\n      local_time = server_time\n    end if\n  end subroutine sync_time\nend module clock_sync_module\n\nprogram main\n  use clock_sync_module\n  implicit none\n\n  call synchronize_clocks()\nend program main\n```"
  },
  {
    "task": "Write a script that manages system backups and handles exceptions for insufficient backup space.",
    "code": "```fortran\nprogram backup_manager\n    implicit none\n    integer :: error_code\n\n    call manage_backups(error_code)\n    if (error_code /= 0) then\n        print *, \"Exception: Insufficient backup space.\"\n    else\n        print *, \"Backup completed successfully.\"\n    end if\n\ncontains\n\n    subroutine manage_backups(err_code)\n        integer, intent(out) :: err_code\n        logical :: has_space\n\n        ! Simulated check for backup space\n        has_space = check_backup_space()\n\n        if (.not. has_space) then\n            err_code = 1\n        else\n            ! Simulated backup operation\n            err_code = 0\n        end if\n    end subroutine manage_backups\n\n    logical function check_backup_space()\n        ! Simulated condition for backup space availability\n        check_backup_space = .false.  ! Assume no space\n    end function check_backup_space\n\nend program backup_manager\n```"
  },
  {
    "task": "Create a program that processes natural language text and handles parsing exceptions.",
    "code": "```fortran\nprogram TextProcessor\n    implicit none\n    character(len=100) :: text\n    character(len=20) :: token\n    integer :: status\n\n    print *, 'Enter a text:'\n    read(*, '(A)') text\n\n    call parseText(text, status)\n\n    if (status /= 0) then\n        print *, 'Error: Parsing exception encountered.'\n    else\n        print *, 'Text processed successfully.'\n    end if\n\ncontains\n\n    subroutine parseText(text, status)\n        implicit none\n        character(len=*), intent(in) :: text\n        integer, intent(out) :: status\n\n        integer :: i, length\n\n        status = 0\n        length = len_trim(text)\n\n        do i = 1, length\n            if (text(i:i) == ' ') cycle\n            if (iachar(text(i:i)) < iachar('A') .or. iachar(text(i:i)) > iachar('z')) then\n                status = 1\n                return\n            end if\n        end do\n    end subroutine parseText\n\nend program TextProcessor\n```"
  },
  {
    "task": "Implement a function that manages thread execution and handles race condition exceptions.",
    "code": "```fortran\nmodule concurrency_module\n  use, intrinsic :: iso_fortran_env, only: error_unit\n  implicit none\ncontains\n\n  subroutine manage_threads()\n\n    integer :: thread_id, num_threads, i\n    logical :: race_condition_detected\n\n    ! Initialize variables\n    race_condition_detected = .false.\n    num_threads = 4\n\n    call random_seed()\n\n    ! Simulate thread execution\n    do i = 1, num_threads\n      thread_id = i\n      call execute_thread(thread_id, race_condition_detected)\n      if (race_condition_detected) then\n        call handle_exception(\"Race condition detected in thread \" // trim(adjustl(itoa(thread_id))))\n      end if\n    end do\n\n  end subroutine manage_threads\n\n  subroutine execute_thread(thread_id, race_condition_detected)\n    integer, intent(in) :: thread_id\n    logical, intent(out) :: race_condition_detected\n    real :: rand_val\n\n    call random_number(rand_val)\n    if (rand_val < 0.2) then\n      race_condition_detected = .true.\n    else\n      race_condition_detected = .false.\n    end if\n\n  end subroutine execute_thread\n\n  subroutine handle_exception(message)\n    character(len=*), intent(in) :: message\n    write(error_unit, *) \"Exception: \", message\n  end subroutine handle_exception\n\n  function itoa(i) result(str)\n    integer, intent(in) :: i\n    character(len=20) :: str\n    write(str, '(I0)') i\n  end function itoa\n\nend module concurrency_module\n```"
  },
  {
    "task": "Develop a system that integrates with IoT devices and handles connectivity exceptions.",
    "code": "```fortran\nprogram IoTIntegration\n  implicit none\n  integer :: ioStatus\n  character(len=256) :: message\n\n  ! Simulate connecting to an IoT device\n  call connectToDevice(ioStatus)\n\n  select case (ioStatus)\n  case (0)\n    print *, \"Connection successful.\"\n  case (1)\n    message = \"Connection failed: Device not found.\"\n    call handleException(message)\n  case (2)\n    message = \"Connection failed: Timeout occurred.\"\n    call handleException(message)\n  case default\n    message = \"Connection failed: Unknown error.\"\n    call handleException(message)\n  end select\n\ncontains\n\n  subroutine connectToDevice(status)\n    integer, intent(out) :: status\n    ! Simulate some connection logic\n    status = 1  ! Example: Simulate a \"Device not found\" error\n  end subroutine connectToDevice\n\n  subroutine handleException(msg)\n    character(len=*), intent(in) :: msg\n    print *, \"Exception: \", msg\n  end subroutine handleException\n\nend program IoTIntegration\n```"
  },
  {
    "task": "Write a function that manages application logging and handles exceptions for log overflow.",
    "code": "```fortran\nmodule LoggerModule\n  implicit none\n  integer, parameter :: max_logs = 100\n  integer :: log_count = 0\n  character(len=256), dimension(max_logs) :: logs\n\ncontains\n\n  subroutine log_message(message)\n    character(len=*), intent(in) :: message\n    logical :: overflow\n\n    overflow = .false.\n\n    if (log_count < max_logs) then\n      log_count = log_count + 1\n      logs(log_count) = message\n    else\n      overflow = .true.\n    end if\n\n    call handle_exception(overflow)\n\n  end subroutine log_message\n\n  subroutine handle_exception(overflow)\n    logical, intent(in) :: overflow\n\n    if (overflow) then\n      print *, \"Log overflow error: Maximum log entries reached.\"\n    end if\n\n  end subroutine handle_exception\n\nend module LoggerModule\n```"
  },
  {
    "task": "Create a tool that visualizes data and handles exceptions for unsupported visualization types.",
    "code": "```fortran\nprogram data_visualization_tool\n  implicit none\n  character(len=20) :: visualization_type\n\n  print *, 'Enter the visualization type (e.g., bar, line, scatter):'\n  read *, visualization_type\n\n  call visualize_data(visualization_type)\n\ncontains\n\n  subroutine visualize_data(type)\n    character(len=20), intent(in) :: type\n\n    select case (trim(type))\n    case ('bar')\n      call visualize_bar()\n    case ('line')\n      call visualize_line()\n    case ('scatter')\n      call visualize_scatter()\n    case default\n      call handle_unsupported_type(type)\n    end select\n  end subroutine visualize_data\n\n  subroutine visualize_bar()\n    print *, 'Visualizing data as a bar chart...'\n    ! Bar chart visualization logic here\n  end subroutine visualize_bar\n\n  subroutine visualize_line()\n    print *, 'Visualizing data as a line chart...'\n    ! Line chart visualization logic here\n  end subroutine visualize_line\n\n  subroutine visualize_scatter()\n    print *, 'Visualizing data as a scatter plot...'\n    ! Scatter plot visualization logic here\n  end subroutine visualize_scatter\n\n  subroutine handle_unsupported_type(type)\n    character(len=20), intent(in) :: type\n    print *, 'Error: Unsupported visualization type -', trim(type)\n  end subroutine handle_unsupported_type\n\nend program data_visualization_tool\n```"
  },
  {
    "task": "Design a program that performs genetic algorithm simulations and manages exception for invalid mutations.",
    "code": "```fortran\nprogram genetic_algorithm\n  implicit none\n  integer, parameter :: population_size = 100, chromosome_length = 10\n  integer :: population(population_size, chromosome_length)\n  integer :: i, j, mutation_position\n  logical :: success\n\n  call initialize_population(population)\n\n  do\n     success = .true.\n     do i = 1, population_size\n        call mutate_chromosome(population(i, :), success)\n        if (.not. success) then\n           print *, \"Error: Invalid mutation occurred in chromosome \", i\n        end if\n     end do\n     \n     if (success) exit\n  end do\n  \ncontains\n\n  subroutine initialize_population(population)\n    integer, intent(out) :: population(population_size, chromosome_length)\n    integer :: i, j\n    do i = 1, population_size\n       do j = 1, chromosome_length\n          population(i, j) = int(random_number() * 2)\n       end do\n    end do\n  end subroutine initialize_population\n\n  subroutine mutate_chromosome(chromosome, success)\n    integer, intent(inout) :: chromosome(chromosome_length)\n    logical, intent(out) :: success\n    integer :: mutation_position\n\n    mutation_position = int(random_number() * chromosome_length) + 1\n    if (mutation_position < 1 .or. mutation_position > chromosome_length) then\n       success = .false.\n       return\n    end if\n\n    chromosome(mutation_position) = 1 - chromosome(mutation_position)\n    success = .true.\n  end subroutine mutate_chromosome\n\n  real function random_number()\n    random_number = rand()\n  end function random_number\n\nend program genetic_algorithm\n```"
  },
  {
    "task": "Implement a function that manages distributed transactions and handles consistency exceptions.",
    "code": "```fortran\nmodule transaction_module\n  implicit none\n  private\n  public :: manage_distributed_transaction\n\n  integer, parameter :: consistency_error = 1\n\ncontains\n\n  subroutine manage_distributed_transaction()\n    implicit none\n    integer :: status\n\n    ! Initialize transaction\n    call initialize_transaction(status)\n\n    ! Error handling block\n    block\n      ! Check for consistency exception\n      if (status == consistency_error) then\n        print *, \"Consistency exception occurred. Rolling back transaction.\"\n        call rollback_transaction()\n        exit\n      endif\n\n      ! Commit transaction if no exceptions\n      call commit_transaction()\n    end block\n\n  end subroutine manage_distributed_transaction\n\n  subroutine initialize_transaction(status)\n    integer, intent(out) :: status\n    ! Simulate initialization of transaction\n    status = 0\n    ! Simulate a consistency error\n    status = consistency_error\n  end subroutine initialize_transaction\n\n  subroutine rollback_transaction()\n    ! Simulate rolling back a transaction\n    print *, \"Transaction rolled back.\"\n  end subroutine rollback_transaction\n\n  subroutine commit_transaction()\n    ! Simulate committing a transaction\n    print *, \"Transaction committed.\"\n  end subroutine commit_transaction\n\nend module transaction_module\n\nprogram main\n  use transaction_module\n  implicit none\n\n  call manage_distributed_transaction()\n\nend program main\n```"
  },
  {
    "task": "Write a function that handles secure communications and manages encryption key exceptions.",
    "code": "```fortran\nmodule secure_communications\n  implicit none\ncontains\n\n  function handle_secure_communication(message, key) result(status)\n    character(len=*), intent(in) :: message\n    integer, intent(in) :: key\n    logical :: status\n\n    status = .false.\n\n    ! Exception handling for encryption key\n    block\n      integer :: encryption_key\n      character(len=256) :: encrypted_message\n\n      ! Attempt to use the encryption key\n      if (key < 0) then\n        print *, \"Error: Invalid encryption key.\"\n        exit\n      endif\n\n      encryption_key = key\n      encrypted_message = encrypt_message(message, encryption_key)\n      print *, \"Encrypted Message: \", encrypted_message\n\n      status = .true.\n    end block\n\n  end function handle_secure_communication\n\n  function encrypt_message(msg, key) result(encrypted_msg)\n    character(len=*), intent(in) :: msg\n    integer, intent(in) :: key\n    character(len=256) :: encrypted_msg\n\n    ! Simple encryption logic here (for demonstration)\n    encrypted_msg = msg // \"_encrypted_with_key_\" // trim(adjustl(itoa(key)))\n\n  end function encrypt_message\n\n  function itoa(num) result(str)\n    integer, intent(in) :: num\n    character(len=32) :: str\n\n    write(str, '(I0)') num\n\n  end function itoa\n\nend module secure_communications\n```"
  },
  {
    "task": "Create a system that processes sensor data and handles out-of-range value exceptions.",
    "code": "```fortran\nprogram sensor_data_processing\n  implicit none\n\n  real :: sensor_value\n  logical :: is_out_of_range\n\n  ! Simulate reading a sensor value\n  sensor_value = 150.0\n\n  ! Process sensor data with exception handling for out-of-range values\n  call process_sensor_data(sensor_value)\n\ncontains\n\n  subroutine process_sensor_data(value)\n    real, intent(in) :: value\n    logical :: out_of_range_exception\n\n    out_of_range_exception = .false.\n\n    ! Check for out-of-range values\n    if (value < 0.0 .or. value > 100.0) then\n      out_of_range_exception = .true.\n    end if\n\n    ! Handle exception\n    if (out_of_range_exception) then\n      print *, \"Exception: Sensor value out of range! Value =\", value\n    else\n      print *, \"Sensor value is within range: Value =\", value\n    end if\n  end subroutine process_sensor_data\n\nend program sensor_data_processing\n```"
  },
  {
    "task": "Develop a program that simulates weather patterns and handles model prediction exceptions.",
    "code": "```fortran\nprogram weather_simulation\n  implicit none\n  integer :: ierr\n  real :: temperature, humidity, wind_speed\n\n  ! Initialize variables\n  temperature = 20.0\n  humidity = 50.0\n  wind_speed = 10.0\n\n  call simulate_weather(temperature, humidity, wind_speed, ierr)\n  if (ierr /= 0) then\n    print *, \"An error occurred during weather simulation: \", ierr\n  else\n    print *, \"Simulation completed successfully.\"\n    print *, \"Temperature: \", temperature\n    print *, \"Humidity: \", humidity\n    print *, \"Wind Speed: \", wind_speed\n  end if\n\ncontains\n\n  subroutine simulate_weather(t, h, w, ierr)\n    real, intent(inout) :: t, h, w\n    integer, intent(out) :: ierr\n\n    ierr = 0\n    ! Simulate changes in weather patterns\n    t = t + 5.0 * (random() - 0.5)\n    h = h + 10.0 * (random() - 0.5)\n    w = w + 3.0 * (random() - 0.5)\n\n    ! Example of handling a prediction exception\n    if (t < -50.0 .or. t > 50.0) then\n      ierr = 1\n      return\n    endif\n    if (h < 0.0 .or. h > 100.0) then\n      ierr = 2\n      return\n    endif\n    if (w < 0.0 .or. w > 150.0) then\n      ierr = 3\n      return\n    endif\n  end subroutine simulate_weather\n\n  real function random()\n    call random_seed()\n    call random_number(random)\n  end function random\n\nend program weather_simulation\n```"
  },
  {
    "task": "Design a function that manages API versioning and handles backward compatibility exceptions.",
    "code": "```fortran\nmodule api_versioning\n  implicit none\n  private\n  public :: check_api_version\n\ncontains\n\n  subroutine check_api_version(version)\n    integer, intent(in) :: version\n    integer :: current_version\n\n    current_version = 3\n\n    if (version < 1) then\n      call handle_exception(\"Invalid API version: must be >= 1\")\n    elseif (version > current_version) then\n      call handle_exception(\"API version not supported: newer than current version\")\n    elseif (version < current_version) then\n      call handle_exception(\"API version deprecated: consider upgrading\")\n    else\n      print *, \"API version is current and supported.\"\n    end if\n\n  end subroutine check_api_version\n\n  subroutine handle_exception(message)\n    character(len=*), intent(in) :: message\n    print *, \"Exception handled: \", trim(message)\n  end subroutine handle_exception\n\nend module api_versioning\n```"
  },
  {
    "task": "Write a tool that converts character encodings and handles unsupported encoding exceptions.",
    "code": "```fortran\nprogram EncodingConverter\n    implicit none\n    character(len=100) :: input, output\n    integer :: ios\n\n    print *, \"Enter input string:\"\n    read *, input\n\n    ! Convert from ASCII to UTF-8\n    call convert_encoding(input, output, ios)\n\n    if (ios /= 0) then\n        print *, \"Error: Unsupported encoding.\"\n    else\n        print *, \"Converted string:\", trim(output)\n    end if\nend program EncodingConverter\n\nsubroutine convert_encoding(input, output, ios)\n    implicit none\n    character(len=*), intent(in) :: input\n    character(len=100), intent(out) :: output\n    integer, intent(out) :: ios\n\n    ios = 0\n    ! Simulate unsupported encoding\n    if (index(input, '?') /= 0) then\n        ios = 1\n        return\n    end if\n\n    ! Simple conversion logic for demonstration\n    output = input\nend subroutine convert_encoding\n```"
  },
  {
    "task": "Create a program that handles dynamic content generation and manages template parsing exceptions.",
    "code": "```fortran\nprogram TemplateParser\n    implicit none\n    character(len=256) :: template\n    character(len=256) :: content\n    logical :: parsingSuccessful\n\n    ! Initialize template and content\n    template = \"Hello, {name}!\"\n    content = \"World\"\n    \n    ! Call the function to parse the template\n    parsingSuccessful = parseTemplate(template, content)\n\n    if (parsingSuccessful) then\n        print *, \"Parsed Content: \", template\n    else\n        print *, \"Failed to parse the template.\"\n    end if\n\ncontains\n\n    logical function parseTemplate(template, content)\n        character(len=*), intent(inout) :: template\n        character(len=*), intent(in) :: content\n        integer :: startPos, endPos\n        logical :: success\n\n        success = .true.\n        startPos = index(template, \"{\")\n        endPos = index(template, \"}\")\n\n        if (startPos > 0 .and. endPos > startPos) then\n            template = template(1:startPos-1) // content // template(endPos+1:)\n        else\n            success = .false.\n        end if\n\n        parseTemplate = success\n    end function parseTemplate\n\nend program TemplateParser\n```"
  },
  {
    "task": "Implement a script that schedules automated tests and handles exceptions for missing test cases.",
    "code": "```fortran\nprogram automated_test_scheduler\n    implicit none\n\n    integer :: test_case, num_test_cases\n    logical :: test_exists\n\n    num_test_cases = 10\n\n    do test_case = 1, num_test_cases\n        call schedule_test(test_case)\n    end do\n\ncontains\n\n    subroutine schedule_test(test_case)\n        integer, intent(in) :: test_case\n        logical :: test_exists\n\n        call check_test_exists(test_case, test_exists)\n\n        if (test_exists) then\n            print *, \"Scheduling Test Case\", test_case\n        else\n            call handle_exception(test_case)\n        end if\n    end subroutine schedule_test\n\n    subroutine check_test_exists(test_case, test_exists)\n        integer, intent(in) :: test_case\n        logical, intent(out) :: test_exists\n\n        test_exists = (mod(test_case, 2) == 0)\n    end subroutine check_test_exists\n\n    subroutine handle_exception(test_case)\n        integer, intent(in) :: test_case\n\n        print *, \"Exception: Missing Test Case\", test_case\n    end subroutine handle_exception\n\nend program automated_test_scheduler\n```"
  },
  {
    "task": "Develop a system that manages virtual machine instances and handles provisioning exceptions.",
    "code": "```fortran\nprogram vm_manager\n  implicit none\n\n  type :: VMInstance\n    integer :: id\n    logical :: isProvisioned = .false.\n  end type VMInstance\n\n  type(VMInstance), allocatable :: vmInstances(:)\n  integer :: numVMs\n  integer :: i\n\n  print *, \"Enter the number of VM instances to manage:\"\n  read *, numVMs\n\n  allocate(vmInstances(numVMs))\n\n  do i = 1, numVMs\n    call provisionVM(vmInstances(i))\n  end do\n\ncontains\n\n  subroutine provisionVM(vm)\n    type(VMInstance), intent(inout) :: vm\n    integer :: status\n\n    ! Simulate provisioning attempt\n    call random_number(status)\n    status = int(status * 10.0)\n\n    select case (status)\n    case (0:7)\n      vm%isProvisioned = .true.\n      print *, \"VM\", vm%id, \"provisioned successfully.\"\n    case default\n      call handleProvisioningError(vm)\n    end select\n\n  end subroutine provisionVM\n\n  subroutine handleProvisioningError(vm)\n    type(VMInstance), intent(inout) :: vm\n\n    print *, \"Error provisioning VM\", vm%id\n  end subroutine handleProvisioningError\n\nend program vm_manager\n```"
  },
  {
    "task": "Write a function that processes credit scores and handles exceptions for missing credit history.",
    "code": "```fortran\nmodule credit_score_module\n  implicit none\ncontains\n  function process_credit_score(score) result(status)\n    integer, intent(in) :: score\n    integer :: status\n\n    if (score == -1) then\n      write(*, '(A)', advance='no') \"Exception: Missing credit history\"\n      status = -1\n    else\n      status = score\n    end if\n\n  end function process_credit_score\nend module credit_score_module\n```"
  },
  {
    "task": "Create a tool that manages digital certificates and handles expiration exceptions.",
    "code": "```fortran\nprogram certificate_manager\n    implicit none\n    character(len=100) :: certificate\n    character(len=15) :: expiration_date\n    character(len=15) :: current_date\n    logical :: expired\n\n    ! Example certificate data\n    certificate = \"Cert123\"\n    expiration_date = \"2023-10-01\"\n    current_date = \"2023-11-01\"\n\n    expired = .false.\n\n    call check_certificate_expiration(expiration_date, current_date, expired)\n\ncontains\n\n    subroutine check_certificate_expiration(expiry_date, current_date, is_expired)\n        implicit none\n        character(len=15), intent(in) :: expiry_date, current_date\n        logical, intent(out) :: is_expired\n\n        if (current_date > expiry_date) then\n            is_expired = .true.\n            call handle_expiration_exception()\n        else\n            is_expired = .false.\n        end if\n    end subroutine check_certificate_expiration\n\n    subroutine handle_expiration_exception()\n        implicit none\n        print *, \"Exception: Certificate has expired.\"\n    end subroutine handle_expiration_exception\n\nend program certificate_manager\n```"
  },
  {
    "task": "Design a program that processes genome sequences and handles exceptions for sequence alignment.",
    "code": "```fortran\nprogram GenomeSequenceAlignment\n    implicit none\n    character(len=100) :: sequence1, sequence2\n    logical :: alignmentSuccess\n\n    ! Initialize sequences\n    sequence1 = \"ACGTGTCGTAACGT\"\n    sequence2 = \"ACGTTAGCTACG\"\n\n    ! Try to align sequences and handle exceptions\n    call alignSequences(sequence1, sequence2, alignmentSuccess)\n\n    if (alignmentSuccess) then\n        print *, \"Sequences aligned successfully.\"\n    else\n        print *, \"Sequence alignment failed.\"\n    end if\n\ncontains\n\n    subroutine alignSequences(seq1, seq2, success)\n        character(len=*), intent(in) :: seq1, seq2\n        logical, intent(out) :: success\n        integer :: status\n\n        success = .false.\n        status = 0\n\n        ! Exception handling block\n        block\n            use, intrinsic :: iso_fortran_env, only : error_unit\n\n            ! Attempt alignment\n            if (len(seq1) /= len(seq2)) then\n                write(error_unit, *) \"Error: Sequences must be of equal length\"\n                exit\n            end if\n\n            ! Simulate alignment processing\n            status = 1  ! Simulate a successful alignment\n\n            if (status /= 0) then\n                success = .true.\n            end if\n\n        end block\n    end subroutine alignSequences\n\nend program GenomeSequenceAlignment\n```"
  }
]