[
  {
    "task": "Create a base class for a vehicle with methods for speed and fuel efficiency, then derive a car class that overrides these methods to provide specific implementations.",
    "code": "```fortran\nmodule vehicle_module\n  implicit none\n  type :: Vehicle\n  contains\n    procedure :: speed => vehicle_speed\n    procedure :: fuel_efficiency => vehicle_fuel_efficiency\n  end type Vehicle\n\n  type, extends(Vehicle) :: Car\n  contains\n    procedure :: speed => car_speed\n    procedure :: fuel_efficiency => car_fuel_efficiency\n  end type Car\n\ncontains\n\n  function vehicle_speed(self) result(s)\n    class(Vehicle), intent(in) :: self\n    real :: s\n    s = 0.0  ! Default speed implementation for Vehicle\n  end function vehicle_speed\n\n  function vehicle_fuel_efficiency(self) result(e)\n    class(Vehicle), intent(in) :: self\n    real :: e\n    e = 0.0  ! Default fuel efficiency for Vehicle\n  end function vehicle_fuel_efficiency\n\n  function car_speed(self) result(s)\n    class(Car), intent(in) :: self\n    real :: s\n    s = 120.0  ! Specific speed implementation for Car\n  end function car_speed\n\n  function car_fuel_efficiency(self) result(e)\n    class(Car), intent(in) :: self\n    real :: e\n    e = 15.0  ! Specific fuel efficiency for Car\n  end function car_fuel_efficiency\n\nend module vehicle_module\n```"
  },
  {
    "task": "Design a base class for a multimedia file with properties like duration and format, then extend it with a video class that includes resolution and frame rate.",
    "code": "```fortran\nmodule multimedia_module\n  implicit none\n\n  type :: MultimediaFile\n    character(len=20) :: format\n    real :: duration\n  contains\n    procedure :: printDetails\n  end type MultimediaFile\n\n  type, extends(MultimediaFile) :: VideoFile\n    character(len=20) :: resolution\n    real :: frame_rate\n  contains\n    procedure :: printDetails => printVideoDetails\n  end type VideoFile\n\ncontains\n\n  subroutine printDetails(self)\n    class(MultimediaFile), intent(in) :: self\n    print *, \"Format: \", self%format\n    print *, \"Duration: \", self%duration\n  end subroutine printDetails\n\n  subroutine printVideoDetails(self)\n    class(VideoFile), intent(in) :: self\n    call self%MultimediaFile%printDetails()\n    print *, \"Resolution: \", self%resolution\n    print *, \"Frame Rate: \", self%frame_rate\n  end subroutine printVideoDetails\n\nend module multimedia_module\n```"
  },
  {
    "task": "Develop a superclass for bank accounts with methods for deposit and withdrawal, then create a savings account subclass that overrides the withdrawal method to incorporate interest deductions.",
    "code": "```fortran\nmodule BankModule\n    implicit none\n    private\n    public :: BankAccount, SavingsAccount\n\n    type :: BankAccount\n    private\n        real :: balance\n    contains\n        procedure :: deposit\n        procedure :: withdraw\n    end type BankAccount\n\n    type, extends(BankAccount) :: SavingsAccount\n    private\n        real :: interestRate\n    contains\n        procedure :: withdraw => SavingsWithdraw\n    end type SavingsAccount\n\ncontains\n\n    subroutine deposit(self, amount)\n        class(BankAccount), intent(inout) :: self\n        real, intent(in) :: amount\n        self%balance = self%balance + amount\n    end subroutine deposit\n\n    subroutine withdraw(self, amount)\n        class(BankAccount), intent(inout) :: self\n        real, intent(in) :: amount\n        self%balance = self%balance - amount\n    end subroutine withdraw\n\n    subroutine SavingsWithdraw(self, amount)\n        class(SavingsAccount), intent(inout) :: self\n        real, intent(in) :: amount\n        self%balance = self%balance - amount * (1.0 + self%interestRate)\n    end subroutine SavingsWithdraw\n\nend module BankModule\n```"
  },
  {
    "task": "Implement a base class for a geometric shape with methods to calculate area and perimeter, then create a rectangle subclass that provides specific calculations for these methods.",
    "code": "```fortran\nmodule geometric_shapes\n  implicit none\n  private\n  public :: shape, rectangle\n\n  type, abstract :: shape\n  contains\n    procedure(area), deferred :: calc_area\n    procedure(perimeter), deferred :: calc_perimeter\n  end type shape\n\n  abstract interface\n    function area(this) result(a)\n      import :: shape\n      class(shape), intent(in) :: this\n      real :: a\n    end function area\n\n    function perimeter(this) result(p)\n      import :: shape\n      class(shape), intent(in) :: this\n      real :: p\n    end function perimeter\n  end interface\n\n  type, extends(shape) :: rectangle\n    real :: length = 0.0\n    real :: width = 0.0\n  contains\n    procedure :: calc_area => rectangle_area\n    procedure :: calc_perimeter => rectangle_perimeter\n  end type rectangle\n\ncontains\n\n  function rectangle_area(this) result(a)\n    class(rectangle), intent(in) :: this\n    real :: a\n    a = this%length * this%width\n  end function rectangle_area\n\n  function rectangle_perimeter(this) result(p)\n    class(rectangle), intent(in) :: this\n    real :: p\n    p = 2.0 * (this%length + this%width)\n  end function rectangle_perimeter\n\nend module geometric_shapes\n```"
  },
  {
    "task": "Construct a parent class for employees with a method to calculate salary, then derive a manager class that overrides this method to include bonuses.",
    "code": "```fortran\nmodule EmployeeModule\n    implicit none\n\n    type :: Employee\n    contains\n        procedure :: calculateSalary => calculateSalary_Employee\n    end type Employee\n\n    type, extends(Employee) :: Manager\n    contains\n        procedure :: calculateSalary => calculateSalary_Manager\n    end type Manager\n\ncontains\n\n    real function calculateSalary_Employee(this, baseSalary) result(salary)\n        class(Employee), intent(in) :: this\n        real, intent(in) :: baseSalary\n        salary = baseSalary\n    end function calculateSalary_Employee\n\n    real function calculateSalary_Manager(this, baseSalary, bonus) result(salary)\n        class(Manager), intent(in) :: this\n        real, intent(in) :: baseSalary\n        real, intent(in) :: bonus\n        salary = baseSalary + bonus\n    end function calculateSalary_Manager\n\nend module EmployeeModule\n```"
  },
  {
    "task": "Set up a base class for a library item with properties like title and author, and extend it with a book subclass that adds a number of pages property.",
    "code": "```fortran\nmodule LibraryModule\n    implicit none\n\n    type :: LibraryItem\n        character(len=:), allocatable :: title\n        character(len=:), allocatable :: author\n    end type LibraryItem\n\n    type, extends(LibraryItem) :: Book\n        integer :: numberOfPages\n    end type Book\n\nend module LibraryModule\n```"
  },
  {
    "task": "Create a foundation class for an electronic device with a method to turn on and off, and derive a smartphone class that overrides the turn on method to require a passcode.",
    "code": "```fortran\nmodule ElectronicDeviceModule\n  implicit none\n  private\n  public :: ElectronicDevice, Smartphone\n\n  type :: ElectronicDevice\n  contains\n    procedure :: turn_on => device_turn_on\n    procedure :: turn_off => device_turn_off\n  end type ElectronicDevice\n\n  type, extends(ElectronicDevice) :: Smartphone\n  contains\n    procedure :: turn_on => smartphone_turn_on\n  end type Smartphone\n\ncontains\n\n  subroutine device_turn_on(this)\n    class(ElectronicDevice), intent(inout) :: this\n    print *, \"Device is turned on\"\n  end subroutine device_turn_on\n\n  subroutine device_turn_off(this)\n    class(ElectronicDevice), intent(inout) :: this\n    print *, \"Device is turned off\"\n  end subroutine device_turn_off\n\n  subroutine smartphone_turn_on(this)\n    class(Smartphone), intent(inout) :: this\n    character(len=20) :: passcode\n    print *, \"Enter passcode to turn on smartphone:\"\n    read *, passcode\n    if (passcode == \"1234\") then\n      print *, \"Smartphone is turned on\"\n    else\n      print *, \"Incorrect passcode\"\n    end if\n  end subroutine smartphone_turn_on\n\nend module ElectronicDeviceModule\n```"
  },
  {
    "task": "Design a base class for an animal with a method to make a sound, then create a dog subclass that overrides this method to bark.",
    "code": "```fortran\nmodule AnimalModule\n    implicit none\n    type :: Animal\n    contains\n        procedure :: makeSound\n    end type Animal\n\n    type, extends(Animal) :: Dog\n    contains\n        procedure :: makeSound => bark\n    end type Dog\n\ncontains\n\n    subroutine makeSound(this)\n        class(Animal), intent(inout) :: this\n        print *, 'This animal makes a sound.'\n    end subroutine makeSound\n\n    subroutine bark(this)\n        class(Dog), intent(inout) :: this\n        print *, 'Woof! Woof!'\n    end subroutine bark\n\nend module AnimalModule\n```"
  },
  {
    "task": "Develop a superclass for meals with a method to calculate calories, then create a dessert subclass that overrides it to add extra sugar calories.",
    "code": "```fortran\nMODULE MealModule\n  IMPLICIT NONE\n  TYPE :: Meal\n  CONTAINS\n    PROCEDURE :: calculate_calories\n  END TYPE Meal\n\n  TYPE, EXTENDS(Meal) :: Dessert\n  CONTAINS\n    PROCEDURE :: calculate_calories => calculate_dessert_calories\n  END TYPE Dessert\n\nCONTAINS\n\n  FUNCTION calculate_calories(this) RESULT(calories)\n    CLASS(Meal), INTENT(IN) :: this\n    INTEGER :: calories\n    ! Default calorie calculation\n    calories = 100\n  END FUNCTION calculate_calories\n\n  FUNCTION calculate_dessert_calories(this) RESULT(calories)\n    CLASS(Dessert), INTENT(IN) :: this\n    INTEGER :: calories\n    ! Base calories plus extra sugar\n    calories = 100 + 50\n  END FUNCTION calculate_dessert_calories\n\nEND MODULE MealModule\n```"
  },
  {
    "task": "Implement a base class for a transportation mode with a method to calculate travel time, then extend it with a plane subclass that overrides the method to calculate based on speed.",
    "code": "```fortran\nMODULE TransportationModule\n  IMPLICIT NONE\n\n  TYPE :: TransportationMode\n  CONTAINS\n    PROCEDURE :: travelTime => baseTravelTime\n  END TYPE TransportationMode\n\n  TYPE, EXTENDS(TransportationMode) :: Plane\n  CONTAINS\n    PROCEDURE :: travelTime => planeTravelTime\n  END TYPE Plane\n\nCONTAINS\n\n  FUNCTION baseTravelTime(this, distance) RESULT(time)\n    CLASS(TransportationMode), INTENT(IN) :: this\n    REAL, INTENT(IN) :: distance\n    REAL :: time\n\n    ! Default travel time calculation (arbitrary value for demonstration)\n    time = distance / 50.0\n\n  END FUNCTION baseTravelTime\n\n  FUNCTION planeTravelTime(this, distance, speed) RESULT(time)\n    CLASS(Plane), INTENT(IN) :: this\n    REAL, INTENT(IN) :: distance, speed\n    REAL :: time\n\n    ! Travel time calculation for Plane\n    time = distance / speed\n\n  END FUNCTION planeTravelTime\n\nEND MODULE TransportationModule\n\nPROGRAM Main\n  USE TransportationModule\n  IMPLICIT NONE\n\n  TYPE(Plane) :: myPlane\n  REAL :: distance, speed, time\n\n  distance = 1000.0\n  speed = 500.0\n  time = myPlane%travelTime(distance, speed)\n  PRINT *, 'Travel time by plane:', time\n\nEND PROGRAM Main\n```"
  },
  {
    "task": "Construct a parent class for a musical instrument with a method to play sound, then derive a piano class that overrides the method to play specific notes.",
    "code": "```fortran\nmodule InstrumentModule\n    implicit none\n    private\n    public :: MusicalInstrument, Piano\n\n    type :: MusicalInstrument\n    contains\n        procedure :: play_sound => play_sound_default\n    end type MusicalInstrument\n\n    type, extends(MusicalInstrument) :: Piano\n    contains\n        procedure :: play_sound => play_sound_piano\n    end type Piano\n\ncontains\n\n    subroutine play_sound_default(this)\n        class(MusicalInstrument), intent(in) :: this\n        print *, \"Playing a generic sound from the instrument.\"\n    end subroutine play_sound_default\n\n    subroutine play_sound_piano(this)\n        class(Piano), intent(in) :: this\n        print *, \"Playing C, E, G notes on the piano.\"\n    end subroutine play_sound_piano\n\nend module InstrumentModule\n```"
  },
  {
    "task": "Set up a base class for a user account with a method to reset password, and extend it with an admin account subclass that overrides it to include security questions.",
    "code": "```fortran\nmodule AccountModule\n    implicit none\n    type :: UserAccount\n    contains\n        procedure :: resetPassword\n    end type UserAccount\n\n    type, extends(UserAccount) :: AdminAccount\n    contains\n        procedure :: resetPassword => resetPasswordWithSecurity\n    end type AdminAccount\n\ncontains\n\n    subroutine resetPassword(this)\n        class(UserAccount), intent(inout) :: this\n        ! Implementation for resetting password for a user account\n        print *, \"Password reset for user account.\"\n    end subroutine resetPassword\n\n    subroutine resetPasswordWithSecurity(this)\n        class(AdminAccount), intent(inout) :: this\n        ! Implementation for resetting password with security questions for an admin account\n        print *, \"Password reset for admin account with security questions.\"\n    end subroutine resetPasswordWithSecurity\n\nend module AccountModule\n```"
  },
  {
    "task": "Create a foundational class for a beverage with properties like volume and temperature, and derive a coffee class that overrides the temperature property to be hot.",
    "code": "```fortran\nmodule BeverageModule\n    implicit none\n    private\n    public :: Beverage, Coffee\n\n    type :: Beverage\n        real :: volume\n        real :: temperature\n    contains\n        procedure :: printBeverage => printBeverageImpl\n    end type Beverage\n\n    type, extends(Beverage) :: Coffee\n    contains\n        procedure :: printBeverage => printCoffeeImpl\n    end type Coffee\n\ncontains\n\n    subroutine printBeverageImpl(self)\n        class(Beverage), intent(in) :: self\n        print *, 'Volume:', self%volume, 'Temperature:', self%temperature\n    end subroutine printBeverageImpl\n\n    subroutine printCoffeeImpl(self)\n        class(Coffee), intent(in) :: self\n        print *, 'Volume:', self%volume, 'Temperature: Hot'\n    end subroutine printCoffeeImpl\n\nend module BeverageModule\n```"
  },
  {
    "task": "Design a base class for a service appointment with a method to schedule time, then create a doctor appointment subclass that overrides this method to include consultation duration.",
    "code": "```fortran\nmodule appointment_module\n    implicit none\n\n    type :: ServiceAppointment\n    contains\n        procedure :: schedule_time => base_schedule_time\n    end type ServiceAppointment\n\n    type, extends(ServiceAppointment) :: DoctorAppointment\n        integer :: consultation_duration\n    contains\n        procedure :: schedule_time => doctor_schedule_time\n    end type DoctorAppointment\n\ncontains\n\n    subroutine base_schedule_time(this)\n        class(ServiceAppointment), intent(inout) :: this\n        print *, \"Scheduling base service appointment time.\"\n    end subroutine base_schedule_time\n\n    subroutine doctor_schedule_time(this)\n        class(DoctorAppointment), intent(inout) :: this\n        print *, \"Scheduling doctor appointment time with consultation duration:\", this%consultation_duration\n    end subroutine doctor_schedule_time\n\nend module appointment_module\n```"
  },
  {
    "task": "Develop a superclass for electronic gadgets with a method to calculate battery life, then extend it with a laptop class that overrides this method to consider usage patterns.",
    "code": "```fortran\nmodule gadget_module\n    implicit none\n\n    type :: ElectronicGadget\n    contains\n        procedure :: calculate_battery_life\n    end type ElectronicGadget\n\n    type, extends(ElectronicGadget) :: Laptop\n    contains\n        procedure :: calculate_battery_life => laptop_battery_life\n    end type Laptop\n\ncontains\n\n    subroutine calculate_battery_life(this)\n        class(ElectronicGadget), intent(inout) :: this\n        print *, \"Calculating battery life for a generic electronic gadget.\"\n    end subroutine calculate_battery_life\n\n    subroutine laptop_battery_life(this)\n        class(Laptop), intent(inout) :: this\n        print *, \"Calculating battery life for a laptop, considering usage patterns.\"\n    end subroutine laptop_battery_life\n\nend module gadget_module\n\nprogram test_inheritance\n    use gadget_module\n    implicit none\n\n    type(ElectronicGadget) :: gadget\n    type(Laptop) :: myLaptop\n\n    call gadget%calculate_battery_life()\n    call myLaptop%calculate_battery_life()\n\nend program test_inheritance\n```"
  },
  {
    "task": "Implement a base class for a website component with a method to render content, then create a blog post subclass that overrides this method to include author information.",
    "code": "```fortran\nmodule Components\n  implicit none\n  type, abstract :: WebsiteComponent\n  contains\n    procedure(render), deferred :: render_content\n  end type WebsiteComponent\n\n  abstract interface\n    subroutine render(self)\n      import :: WebsiteComponent\n      class(WebsiteComponent), intent(inout) :: self\n    end subroutine render\n  end interface\n\n  type, extends(WebsiteComponent) :: BlogPost\n    character(len=256) :: author\n  contains\n    procedure :: render_content => render_blogpost\n  end type BlogPost\n\ncontains\n\n  subroutine render_blogpost(self)\n    class(BlogPost), intent(inout) :: self\n    print *, \"Rendering Blog Post with Author: \", self%author\n  end subroutine render_blogpost\n\nend module Components\n```"
  },
  {
    "task": "Construct a parent class for a recipe with methods for ingredients and instructions, then derive a cake recipe class that overrides these methods to add baking steps.",
    "code": "```fortran\nmodule recipe_module\n    implicit none\n\n    type :: Recipe\n    contains\n        procedure :: ingredients => recipe_ingredients\n        procedure :: instructions => recipe_instructions\n    end type Recipe\n\n    type, extends(Recipe) :: CakeRecipe\n    contains\n        procedure :: ingredients => cake_ingredients\n        procedure :: instructions => cake_instructions\n    end type CakeRecipe\n\ncontains\n\n    subroutine recipe_ingredients(this)\n        class(Recipe), intent(in) :: this\n        print *, \"Generic ingredients for a recipe.\"\n    end subroutine recipe_ingredients\n\n    subroutine recipe_instructions(this)\n        class(Recipe), intent(in) :: this\n        print *, \"Generic instructions for a recipe.\"\n    end subroutine recipe_instructions\n\n    subroutine cake_ingredients(this)\n        class(CakeRecipe), intent(in) :: this\n        print *, \"Ingredients for a cake: flour, sugar, eggs, butter.\"\n    end subroutine cake_ingredients\n\n    subroutine cake_instructions(this)\n        class(CakeRecipe), intent(in) :: this\n        print *, \"Instructions for a cake: Mix ingredients, bake at 350F for 30 minutes.\"\n    end subroutine cake_instructions\n\nend module recipe_module\n```"
  },
  {
    "task": "Set up a base class for a plant with methods for sunlight and water needs, and extend it with a cactus subclass that overrides these methods to require less water.",
    "code": "```fortran\nmodule plant_module\n    implicit none\n\n    type :: Plant\n    contains\n        procedure :: sunlightNeeds => plantSunlight\n        procedure :: waterNeeds => plantWater\n    end type Plant\n\n    type, extends(Plant) :: Cactus\n    contains\n        procedure :: waterNeeds => cactusWater\n    end type Cactus\n\ncontains\n\n    subroutine plantSunlight(this)\n        class(Plant), intent(in) :: this\n        print *, \"Plant needs full sunlight.\"\n    end subroutine plantSunlight\n\n    subroutine plantWater(this)\n        class(Plant), intent(in) :: this\n        print *, \"Plant needs regular watering.\"\n    end subroutine plantWater\n\n    subroutine cactusWater(this)\n        class(Cactus), intent(in) :: this\n        print *, \"Cactus needs minimal watering.\"\n    end subroutine cactusWater\n\nend module plant_module\n```"
  },
  {
    "task": "Create a foundational class for a building with properties like height and material, and derive a skyscraper class that overrides the height property to be significantly taller.",
    "code": "```fortran\nmodule BuildingModule\n    implicit none\n\n    type :: Building\n        real :: height\n        character(len=20) :: material\n    contains\n        procedure :: getHeight => getBuildingHeight\n        procedure :: getMaterial => getBuildingMaterial\n    end type Building\n\n    type, extends(Building) :: Skyscraper\n    contains\n        procedure :: getHeight => getSkyscraperHeight\n    end type Skyscraper\n\ncontains\n\n    function getBuildingHeight(this) result(h)\n        class(Building), intent(in) :: this\n        real :: h\n        h = this%height\n    end function getBuildingHeight\n\n    function getBuildingMaterial(this) result(m)\n        class(Building), intent(in) :: this\n        character(len=20) :: m\n        m = this%material\n    end function getBuildingMaterial\n\n    function getSkyscraperHeight(this) result(h)\n        class(Skyscraper), intent(in) :: this\n        real :: h\n        h = this%height * 10.0\n    end function getSkyscraperHeight\n\nend module BuildingModule\n```"
  },
  {
    "task": "Design a base class for a payment method with a method to process transactions, then create a credit card subclass that overrides this method to include credit limits.",
    "code": "```fortran\nmodule PaymentModule\n  implicit none\n  private\n  public :: PaymentMethod, CreditCard\n\n  type :: PaymentMethod\n  contains\n    procedure :: processTransaction => processTransactionBase\n  end type PaymentMethod\n\n  type, extends(PaymentMethod) :: CreditCard\n    real :: creditLimit\n  contains\n    procedure :: processTransaction => processTransactionCreditCard\n  end type CreditCard\n\ncontains\n\n  subroutine processTransactionBase(this, amount)\n    class(PaymentMethod), intent(in) :: this\n    real, intent(in) :: amount\n    ! Base transaction processing logic\n    print *, 'Processing transaction of amount: ', amount\n  end subroutine processTransactionBase\n\n  subroutine processTransactionCreditCard(this, amount)\n    class(CreditCard), intent(in) :: this\n    real, intent(in) :: amount\n    ! Transaction processing for credit card with credit limit check\n    if (amount <= this%creditLimit) then\n      print *, 'Transaction approved for amount: ', amount\n    else\n      print *, 'Transaction denied. Amount exceeds credit limit.'\n    endif\n  end subroutine processTransactionCreditCard\n\nend module PaymentModule\n```"
  },
  {
    "task": "Develop a superclass for a computer program with methods for input and output, then extend it with a game subclass that overrides these methods to include player interactions.",
    "code": "```fortran\nmodule program_module\n    implicit none\n    type :: Program\n    contains\n        procedure :: input => program_input\n        procedure :: output => program_output\n    end type Program\n\ncontains\n\n    subroutine program_input(this)\n        class(Program), intent(inout) :: this\n        ! Basic input method placeholder\n    end subroutine program_input\n\n    subroutine program_output(this)\n        class(Program), intent(inout) :: this\n        ! Basic output method placeholder\n    end subroutine program_output\n\nend module program_module\n\nmodule game_module\n    use program_module\n    implicit none\n    type, extends(Program) :: Game\n    contains\n        procedure :: input => game_input\n        procedure :: output => game_output\n    end type Game\n\ncontains\n\n    subroutine game_input(this)\n        class(Game), intent(inout) :: this\n        ! Game-specific input method with player interactions\n    end subroutine game_input\n\n    subroutine game_output(this)\n        class(Game), intent(inout) :: this\n        ! Game-specific output method with player interactions\n    end subroutine game_output\n\nend module game_module\n```"
  },
  {
    "task": "Implement a base class for a dining establishment with a method to calculate wait time, then create a fast food subclass that overrides this method to be shorter.",
    "code": "```fortran\nmodule DiningEstablishmentModule\n    implicit none\n    type :: DiningEstablishment\n    contains\n        procedure :: calculate_wait_time\n    end type DiningEstablishment\n\n    type, extends(DiningEstablishment) :: FastFood\n    contains\n        procedure :: calculate_wait_time => fastfood_wait_time\n    end type FastFood\n\ncontains\n\n    function calculate_wait_time(this) result(wait_time)\n        class(DiningEstablishment), intent(in) :: this\n        integer :: wait_time\n        wait_time = 30\n    end function calculate_wait_time\n\n    function fastfood_wait_time(this) result(wait_time)\n        class(FastFood), intent(in) :: this\n        integer :: wait_time\n        wait_time = 10\n    end function fastfood_wait_time\n\nend module DiningEstablishmentModule\n\nprogram main\n    use DiningEstablishmentModule\n    implicit none\n    type(DiningEstablishment) :: restaurant\n    type(FastFood) :: fastFoodRestaurant\n\n    print *, \"Restaurant wait time:\", restaurant%calculate_wait_time()\n    print *, \"Fast food wait time:\", fastFoodRestaurant%calculate_wait_time()\nend program main\n```"
  },
  {
    "task": "Construct a parent class for a social media profile with methods for posting and liking, then derive a business profile class that overrides these methods to include promotions.",
    "code": "```fortran\nmodule SocialMediaProfile\n    implicit none\n    private\n    public :: Profile, BusinessProfile\n\n    type :: Profile\n    contains\n        procedure :: post\n        procedure :: like\n    end type Profile\n\n    type, extends(Profile) :: BusinessProfile\n    contains\n        procedure :: post => businessPost\n        procedure :: like => businessLike\n    end type BusinessProfile\n\ncontains\n\n    subroutine post(this)\n        class(Profile), intent(inout) :: this\n        print *, \"Posting on social media profile...\"\n    end subroutine post\n\n    subroutine like(this)\n        class(Profile), intent(inout) :: this\n        print *, \"Liking a post on social media profile...\"\n    end subroutine like\n\n    subroutine businessPost(this)\n        class(BusinessProfile), intent(inout) :: this\n        print *, \"Posting on business profile with promotions...\"\n    end subroutine businessPost\n\n    subroutine businessLike(this)\n        class(BusinessProfile), intent(inout) :: this\n        print *, \"Liking a post on business profile with promotions...\"\n    end subroutine businessLike\n\nend module SocialMediaProfile\n```"
  },
  {
    "task": "Set up a base class for an educational course with methods for syllabus and grading, and extend it with an online course subclass that overrides these methods for remote learning.",
    "code": "```fortran\nmodule CourseModule\n  implicit none\n\n  type :: Course\n  contains\n    procedure :: syllabus => course_syllabus\n    procedure :: grading => course_grading\n  end type Course\n\n  type, extends(Course) :: OnlineCourse\n  contains\n    procedure :: syllabus => online_course_syllabus\n    procedure :: grading => online_course_grading\n  end type OnlineCourse\n\ncontains\n\n  subroutine course_syllabus(this)\n    class(Course), intent(in) :: this\n    print *, \"Syllabus for in-person course.\"\n  end subroutine course_syllabus\n\n  subroutine course_grading(this)\n    class(Course), intent(in) :: this\n    print *, \"Grading for in-person course.\"\n  end subroutine course_grading\n\n  subroutine online_course_syllabus(this)\n    class(OnlineCourse), intent(in) :: this\n    print *, \"Syllabus for online course.\"\n  end subroutine online_course_syllabus\n\n  subroutine online_course_grading(this)\n    class(OnlineCourse), intent(in) :: this\n    print *, \"Grading for online course.\"\n  end subroutine online_course_grading\n\nend module CourseModule\n```"
  },
  {
    "task": "Create a foundational class for a sports team with properties like team name and coach, and derive a football team class that overrides the coach property with a specific person.",
    "code": "```fortran\nmodule SportsTeamModule\n  implicit none\n  type :: SportsTeam\n    character(len=100) :: teamName\n    character(len=100) :: coach\n  end type SportsTeam\n\n  type, extends(SportsTeam) :: FootballTeam\n    character(len=100) :: coach\n  end type FootballTeam\nend module SportsTeamModule\n\nprogram Main\n  use SportsTeamModule\n  implicit none\n\n  type(FootballTeam) :: myFootballTeam\n\n  myFootballTeam%teamName = \"Eagles\"\n  myFootballTeam%coach = \"John Doe\"  ! Overriding the coach property\n\n  print *, \"Football Team Name: \", myFootballTeam%teamName\n  print *, \"Football Team Coach: \", myFootballTeam%coach\nend program Main\n```"
  },
  {
    "task": "Design a base class for a document with methods for printing and saving, then create a PDF document subclass that overrides these methods to include encryption.",
    "code": "```fortran\nmodule DocumentModule\n    implicit none\n    type :: Document\n    contains\n        procedure :: print => print_document\n        procedure :: save => save_document\n    end type Document\n\n    type, extends(Document) :: PDFDocument\n    contains\n        procedure :: print => print_pdf\n        procedure :: save => save_pdf\n    end type PDFDocument\n\ncontains\n\n    subroutine print_document(this)\n        class(Document), intent(inout) :: this\n        print *, \"Printing document...\"\n    end subroutine print_document\n\n    subroutine save_document(this)\n        class(Document), intent(inout) :: this\n        print *, \"Saving document...\"\n    end subroutine save_document\n\n    subroutine print_pdf(this)\n        class(PDFDocument), intent(inout) :: this\n        print *, \"Printing PDF document with encryption...\"\n    end subroutine print_pdf\n\n    subroutine save_pdf(this)\n        class(PDFDocument), intent(inout) :: this\n        print *, \"Saving PDF document with encryption...\"\n    end subroutine save_pdf\n\nend module DocumentModule\n```"
  },
  {
    "task": "Develop a superclass for a retail product with methods for pricing and discount, then extend it with an electronics product class that overrides the discount method to offer more.",
    "code": "// [ERROR] Connection error."
  },
  {
    "task": "Implement a base class for a subscription service with a method to renew membership, then create a monthly subscription subclass that overrides this method for automatic renewal.",
    "code": "```fortran\nmodule SubscriptionModule\n    implicit none\n    private\n    public :: Subscription, MonthlySubscription\n\n    type :: Subscription\n    contains\n        procedure :: renewMembership\n    end type Subscription\n\n    type, extends(Subscription) :: MonthlySubscription\n    contains\n        procedure :: renewMembership => autoRenewMembership\n    end type MonthlySubscription\n\ncontains\n\n    subroutine renewMembership(this)\n        class(Subscription), intent(inout) :: this\n        print *, \"Membership renewed for the base subscription.\"\n    end subroutine renewMembership\n\n    subroutine autoRenewMembership(this)\n        class(MonthlySubscription), intent(inout) :: this\n        print *, \"Membership automatically renewed for the monthly subscription.\"\n    end subroutine autoRenewMembership\n\nend module SubscriptionModule\n\nprogram Main\n    use SubscriptionModule\n    implicit none\n\n    type(Subscription) :: baseSub\n    type(MonthlySubscription) :: monthlySub\n\n    call baseSub%renewMembership()\n    call monthlySub%renewMembership()\n\nend program Main\n```"
  },
  {
    "task": "Construct a parent class for a language translator with a method to translate text, then derive a French translator class that overrides this method for French language specifics.",
    "code": "```fortran\nmodule TranslatorModule\n    implicit none\n\n    type :: LanguageTranslator\n    contains\n        procedure :: translateText => baseTranslateText\n    end type LanguageTranslator\n\ncontains\n\n    subroutine baseTranslateText(this, text)\n        class(LanguageTranslator), intent(in) :: this\n        character(len=*), intent(in) :: text\n        ! Default translation logic\n        print *, \"Translating text: \", trim(text)\n    end subroutine baseTranslateText\n\nend module TranslatorModule\n\nmodule FrenchTranslatorModule\n    use TranslatorModule\n    implicit none\n\n    type, extends(LanguageTranslator) :: FrenchTranslator\n    contains\n        procedure :: translateText => frenchTranslateText\n    end type FrenchTranslator\n\ncontains\n\n    subroutine frenchTranslateText(this, text)\n        class(FrenchTranslator), intent(in) :: this\n        character(len=*), intent(in) :: text\n        ! French-specific translation logic\n        print *, \"Traduction du texte: \", trim(text)\n    end subroutine frenchTranslateText\n\nend module FrenchTranslatorModule\n```"
  },
  {
    "task": "Set up a base class for a customer order with methods for placing and tracking, and extend it with a food order subclass that overrides tracking for delivery status.",
    "code": "```fortran\nmodule OrderModule\n    implicit none\n    private\n    public :: CustomerOrder, FoodOrder\n\n    type :: CustomerOrder\n    contains\n        procedure :: placeOrder\n        procedure :: trackOrder\n    end type CustomerOrder\n\n    type, extends(CustomerOrder) :: FoodOrder\n    contains\n        procedure :: trackOrder => trackFoodOrder\n    end type FoodOrder\n\ncontains\n\n    subroutine placeOrder(this)\n        class(CustomerOrder), intent(inout) :: this\n        print *, \"Order has been placed.\"\n    end subroutine placeOrder\n\n    subroutine trackOrder(this)\n        class(CustomerOrder), intent(inout) :: this\n        print *, \"Tracking general order status.\"\n    end subroutine trackOrder\n\n    subroutine trackFoodOrder(this)\n        class(FoodOrder), intent(inout) :: this\n        print *, \"Tracking food order delivery status.\"\n    end subroutine trackFoodOrder\n\nend module OrderModule\n```"
  },
  {
    "task": "Create a foundational class for an artwork with properties like artist and medium, and derive a painting class that overrides the medium property to be 'canvas'.",
    "code": "```fortran\nmodule artwork_module\n    implicit none\n\n    type :: Artwork\n        character(len=100) :: artist\n        character(len=100) :: medium\n    contains\n        procedure :: display => display_artwork\n    end type Artwork\n\n    type, extends(Artwork) :: Painting\n    contains\n        procedure :: display => display_painting\n    end type Painting\n\ncontains\n\n    subroutine display_artwork(self)\n        class(Artwork), intent(in) :: self\n        print *, \"Artist: \", self%artist\n        print *, \"Medium: \", self%medium\n    end subroutine display_artwork\n\n    subroutine display_painting(self)\n        class(Painting), intent(in) :: self\n        print *, \"Artist: \", self%artist\n        print *, \"Medium: canvas\"\n    end subroutine display_painting\n\nend module artwork_module\n\nprogram main\n    use artwork_module\n    implicit none\n\n    type(Painting) :: myPainting\n\n    myPainting%artist = \"Leonardo da Vinci\"\n    call myPainting%display()\n\nend program main\n```"
  },
  {
    "task": "Design a base class for a computer network with methods for connectivity and bandwidth, then create a wireless network subclass that overrides these methods for signal strength.",
    "code": "```fortran\nmodule NetworkModule\n    implicit none\n\n    type :: ComputerNetwork\n    contains\n        procedure :: connectivity\n        procedure :: bandwidth\n    end type ComputerNetwork\n\n    type, extends(ComputerNetwork) :: WirelessNetwork\n    contains\n        procedure :: connectivity => wireless_connectivity\n        procedure :: bandwidth => wireless_bandwidth\n    end type WirelessNetwork\n\ncontains\n\n    subroutine connectivity(this)\n        class(ComputerNetwork), intent(inout) :: this\n        print *, \"Base network connectivity method.\"\n    end subroutine connectivity\n\n    subroutine bandwidth(this)\n        class(ComputerNetwork), intent(inout) :: this\n        print *, \"Base network bandwidth method.\"\n    end subroutine bandwidth\n\n    subroutine wireless_connectivity(this)\n        class(WirelessNetwork), intent(inout) :: this\n        print *, \"Wireless network connectivity based on signal strength.\"\n    end subroutine wireless_connectivity\n\n    subroutine wireless_bandwidth(this)\n        class(WirelessNetwork), intent(inout) :: this\n        print *, \"Wireless network bandwidth based on signal strength.\"\n    end subroutine wireless_bandwidth\n\nend module NetworkModule\n\nprogram InheritanceExample\n    use NetworkModule\n    implicit none\n\n    type(ComputerNetwork) :: network\n    type(WirelessNetwork) :: wireless\n\n    call network%connectivity()\n    call network%bandwidth()\n\n    call wireless%connectivity()\n    call wireless%bandwidth()\n\nend program InheritanceExample\n```"
  },
  {
    "task": "Develop a superclass for a messaging app with methods for sending and receiving messages, then extend it with a secure messaging subclass that overrides these methods for encryption.",
    "code": "```fortran\nmodule MessagingApp\n  type :: Message\n    character(len=256) :: content\n  contains\n    procedure :: send => send_message\n    procedure :: receive => receive_message\n  end type Message\n\n  abstract interface\n    subroutine send_message(this, msg)\n      import :: Message\n      class(Message), intent(inout) :: this\n      character(len=*) :: msg\n    end subroutine send_message\n\n    subroutine receive_message(this, msg)\n      import :: Message\n      class(Message), intent(inout) :: this\n      character(len=*) :: msg\n    end subroutine receive_message\n  end interface\n\ncontains\n\n  subroutine send_message(this, msg)\n    class(Message), intent(inout) :: this\n    character(len=*) :: msg\n    print *, \"Sending message:\", msg\n  end subroutine send_message\n\n  subroutine receive_message(this, msg)\n    class(Message), intent(inout) :: this\n    character(len=*) :: msg\n    print *, \"Receiving message:\", msg\n  end subroutine receive_message\n\nend module MessagingApp\n\n\nmodule SecureMessagingApp\n  use MessagingApp\n  type, extends(Message) :: SecureMessage\n  contains\n    procedure :: send => send_secure_message\n    procedure :: receive => receive_secure_message\n  end type SecureMessage\n\ncontains\n\n  subroutine send_secure_message(this, msg)\n    class(SecureMessage), intent(inout) :: this\n    character(len=*) :: msg\n    print *, \"Sending encrypted message:\", msg\n  end subroutine send_secure_message\n\n  subroutine receive_secure_message(this, msg)\n    class(SecureMessage), intent(inout) :: this\n    character(len=*) :: msg\n    print *, \"Receiving encrypted message:\", msg\n  end subroutine receive_secure_message\n\nend module SecureMessagingApp\n```"
  },
  {
    "task": "Implement a base class for a travel itinerary with methods for destinations and activities, then create a vacation itinerary subclass that overrides these methods for leisure activities.",
    "code": "```fortran\nmodule ItineraryModule\n    implicit none\n\n    type :: TravelItinerary\n    contains\n        procedure :: destinations, activities\n    end type TravelItinerary\n\n    type, extends(TravelItinerary) :: VacationItinerary\n    contains\n        procedure :: destinations => vacation_destinations\n        procedure :: activities => vacation_activities\n    end type VacationItinerary\n\ncontains\n\n    subroutine destinations(this)\n        class(TravelItinerary), intent(inout) :: this\n        print *, \"Generic travel destinations\"\n    end subroutine destinations\n\n    subroutine activities(this)\n        class(TravelItinerary), intent(inout) :: this\n        print *, \"Generic travel activities\"\n    end subroutine activities\n\n    subroutine vacation_destinations(this)\n        class(VacationItinerary), intent(inout) :: this\n        print *, \"Leisure vacation destinations\"\n    end subroutine vacation_destinations\n\n    subroutine vacation_activities(this)\n        class(VacationItinerary), intent(inout) :: this\n        print *, \"Leisure vacation activities\"\n    end subroutine vacation_activities\n\nend module ItineraryModule\n\nprogram main\n    use ItineraryModule\n    implicit none\n\n    class(TravelItinerary), allocatable :: itinerary\n    class(VacationItinerary), allocatable :: vacation\n\n    allocate(itinerary)\n    call itinerary%destinations()\n    call itinerary%activities()\n\n    allocate(vacation)\n    call vacation%destinations()\n    call vacation%activities()\nend program main\n```"
  },
  {
    "task": "Construct a parent class for a healthcare record with methods for patient data and treatment history, then derive a pediatric record class that overrides these methods for child-specific data.",
    "code": "```fortran\nmodule healthcare_module\n    implicit none\n    private\n    public :: healthcare_record, pediatric_record\n\n    type :: healthcare_record\n    contains\n        procedure, public :: patient_data => patient_data_base\n        procedure, public :: treatment_history => treatment_history_base\n    end type healthcare_record\n\n    type, extends(healthcare_record) :: pediatric_record\n    contains\n        procedure, public :: patient_data => patient_data_pediatric\n        procedure, public :: treatment_history => treatment_history_pediatric\n    end type pediatric_record\n\ncontains\n\n    subroutine patient_data_base(this)\n        class(healthcare_record), intent(inout) :: this\n        ! Base implementation for general patient data\n    end subroutine patient_data_base\n\n    subroutine treatment_history_base(this)\n        class(healthcare_record), intent(inout) :: this\n        ! Base implementation for general treatment history\n    end subroutine treatment_history_base\n\n    subroutine patient_data_pediatric(this)\n        class(pediatric_record), intent(inout) :: this\n        ! Override for child-specific patient data\n    end subroutine patient_data_pediatric\n\n    subroutine treatment_history_pediatric(this)\n        class(pediatric_record), intent(inout) :: this\n        ! Override for child-specific treatment history\n    end subroutine treatment_history_pediatric\n\nend module healthcare_module\n```"
  },
  {
    "task": "Set up a base class for a culinary dish with methods for preparation and serving, and extend it with an appetizer subclass that overrides these methods for smaller portions.",
    "code": "```fortran\nmodule culinary_module\n  implicit none\n\n  type :: Dish\n  contains\n    procedure :: prepare => prepare_dish\n    procedure :: serve => serve_dish\n  end type Dish\n\n  type, extends(Dish) :: Appetizer\n  contains\n    procedure :: prepare => prepare_appetizer\n    procedure :: serve => serve_appetizer\n  end type Appetizer\n\ncontains\n\n  subroutine prepare_dish(this)\n    class(Dish), intent(inout) :: this\n    print *, \"Preparing the dish...\"\n  end subroutine prepare_dish\n\n  subroutine serve_dish(this)\n    class(Dish), intent(inout) :: this\n    print *, \"Serving the dish...\"\n  end subroutine serve_dish\n\n  subroutine prepare_appetizer(this)\n    class(Appetizer), intent(inout) :: this\n    print *, \"Preparing the appetizer in smaller portions...\"\n  end subroutine prepare_appetizer\n\n  subroutine serve_appetizer(this)\n    class(Appetizer), intent(inout) :: this\n    print *, \"Serving the appetizer in smaller portions...\"\n  end subroutine serve_appetizer\n\nend module culinary_module\n```"
  },
  {
    "task": "Create a foundational class for a book collection with properties like genre and author, and derive a mystery collection class that overrides the genre property to be 'mystery'.",
    "code": "```fortran\nmodule BookCollectionModule\n    implicit none\n\n    type :: BookCollection\n        character(len=50) :: genre\n        character(len=50) :: author\n    contains\n        procedure :: getGenre\n        procedure :: getAuthor\n    end type BookCollection\n\n    type, extends(BookCollection) :: MysteryCollection\n    contains\n        procedure :: getGenre => getGenreMystery\n    end type MysteryCollection\n\ncontains\n\n    function getGenre(this) result(genre)\n        class(BookCollection), intent(in) :: this\n        character(len=50) :: genre\n        genre = this%genre\n    end function getGenre\n\n    function getAuthor(this) result(author)\n        class(BookCollection), intent(in) :: this\n        character(len=50) :: author\n        author = this%author\n    end function getAuthor\n\n    function getGenreMystery(this) result(genre)\n        class(MysteryCollection), intent(in) :: this\n        character(len=50) :: genre\n        genre = 'mystery'\n    end function getGenreMystery\n\nend module BookCollectionModule\n```"
  },
  {
    "task": "Design a base class for a file storage system with methods for saving and deleting files, then create a cloud storage subclass that overrides these methods for remote access.",
    "code": "```fortran\nmodule storage_module\n  implicit none\n  type :: FileStorage\n  contains\n    procedure :: save => save_file\n    procedure :: delete => delete_file\n  end type FileStorage\n\n  type, extends(FileStorage) :: CloudStorage\n  contains\n    procedure :: save => save_cloud\n    procedure :: delete => delete_cloud\n  end type CloudStorage\n\ncontains\n\n  subroutine save_file(this)\n    class(FileStorage), intent(inout) :: this\n    print *, 'Saving file locally...'\n  end subroutine save_file\n\n  subroutine delete_file(this)\n    class(FileStorage), intent(inout) :: this\n    print *, 'Deleting file locally...'\n  end subroutine delete_file\n\n  subroutine save_cloud(this)\n    class(CloudStorage), intent(inout) :: this\n    print *, 'Saving file to cloud...'\n  end subroutine save_cloud\n\n  subroutine delete_cloud(this)\n    class(CloudStorage), intent(inout) :: this\n    print *, 'Deleting file from cloud...'\n  end subroutine delete_cloud\n\nend module storage_module\n```"
  },
  {
    "task": "Develop a superclass for a seasonal sale event with methods for discounts and promotions, then extend it with a summer sale subclass that overrides these methods for summer items.",
    "code": "```fortran\nmodule SaleEventModule\n    implicit none\n    private\n    public :: SaleEvent, SummerSale\n\n    type :: SaleEvent\n    contains\n        procedure :: discount => saleDiscount\n        procedure :: promotion => salePromotion\n    end type SaleEvent\n\n    type, extends(SaleEvent) :: SummerSale\n    contains\n        procedure :: discount => summerDiscount\n        procedure :: promotion => summerPromotion\n    end type SummerSale\n\ncontains\n\n    subroutine saleDiscount(this)\n        class(SaleEvent), intent(inout) :: this\n        print *, \"Standard discount applied.\"\n    end subroutine saleDiscount\n\n    subroutine salePromotion(this)\n        class(SaleEvent), intent(inout) :: this\n        print *, \"Standard promotion applied.\"\n    end subroutine salePromotion\n\n    subroutine summerDiscount(this)\n        class(SummerSale), intent(inout) :: this\n        print *, \"Summer discount applied.\"\n    end subroutine summerDiscount\n\n    subroutine summerPromotion(this)\n        class(SummerSale), intent(inout) :: this\n        print *, \"Summer promotion applied.\"\n    end subroutine summerPromotion\n\nend module SaleEventModule\n\nprogram TestSale\n    use SaleEventModule\n    implicit none\n\n    type(SaleEvent) :: event\n    type(SummerSale) :: summerEvent\n\n    call event%discount()\n    call event%promotion()\n\n    call summerEvent%discount()\n    call summerEvent%promotion()\n\nend program TestSale\n```"
  },
  {
    "task": "Implement a base class for a personal budget with methods for income and expenses, then create a student budget subclass that overrides these methods for tuition and fees.",
    "code": "```fortran\nmodule BudgetModule\n    implicit none\n\n    type :: PersonalBudget\n    contains\n        procedure :: income => personalIncome\n        procedure :: expenses => personalExpenses\n    end type PersonalBudget\n\n    type, extends(PersonalBudget) :: StudentBudget\n    contains\n        procedure :: income => studentIncome\n        procedure :: expenses => studentExpenses\n    end type StudentBudget\n\ncontains\n\n    subroutine personalIncome(this)\n        class(PersonalBudget), intent(inout) :: this\n        print *, \"Calculating personal income.\"\n    end subroutine personalIncome\n\n    subroutine personalExpenses(this)\n        class(PersonalBudget), intent(inout) :: this\n        print *, \"Calculating personal expenses.\"\n    end subroutine personalExpenses\n\n    subroutine studentIncome(this)\n        class(StudentBudget), intent(inout) :: this\n        print *, \"Calculating student income.\"\n    end subroutine studentIncome\n\n    subroutine studentExpenses(this)\n        class(StudentBudget), intent(inout) :: this\n        print *, \"Calculating student expenses including tuition and fees.\"\n    end subroutine studentExpenses\n\nend module BudgetModule\n\n\nprogram BudgetTest\n    use BudgetModule\n    implicit none\n\n    class(PersonalBudget), allocatable :: budget\n    class(StudentBudget), allocatable :: studentBudget\n\n    allocate(budget)\n    allocate(studentBudget)\n\n    call budget%income()\n    call budget%expenses()\n\n    call studentBudget%income()\n    call studentBudget%expenses()\n\nend program BudgetTest\n```"
  },
  {
    "task": "Construct a parent class for a fitness routine with methods for exercises and duration, then derive a yoga routine class that overrides these methods for flexibility exercises.",
    "code": "```fortran\nmodule FitnessModule\n  implicit none\n  private\n  public :: FitnessRoutine, YogaRoutine\n\n  type :: FitnessRoutine\n  contains\n    procedure :: exercises => fitness_exercises\n    procedure :: duration => fitness_duration\n  end type FitnessRoutine\n\n  type, extends(FitnessRoutine) :: YogaRoutine\n  contains\n    procedure :: exercises => yoga_exercises\n    procedure :: duration => yoga_duration\n  end type YogaRoutine\n\ncontains\n\n  subroutine fitness_exercises(this)\n    class(FitnessRoutine), intent(inout) :: this\n    print *, \"General fitness exercises\"\n  end subroutine fitness_exercises\n\n  subroutine fitness_duration(this)\n    class(FitnessRoutine), intent(inout) :: this\n    print *, \"General fitness duration\"\n  end subroutine fitness_duration\n\n  subroutine yoga_exercises(this)\n    class(YogaRoutine), intent(inout) :: this\n    print *, \"Flexibility exercises\"\n  end subroutine yoga_exercises\n\n  subroutine yoga_duration(this)\n    class(YogaRoutine), intent(inout) :: this\n    print *, \"Yoga duration\"\n  end subroutine yoga_duration\n\nend module FitnessModule\n```"
  },
  {
    "task": "Set up a base class for a transportation ticket with methods for pricing and validity, and extend it with an airline ticket subclass that overrides these methods for baggage allowance.",
    "code": "```fortran\nmodule TransportationModule\n  implicit none\n\n  type :: Ticket\n  contains\n    procedure :: pricing => base_pricing\n    procedure :: validity => base_validity\n  end type Ticket\n\n  type, extends(Ticket) :: AirlineTicket\n  contains\n    procedure :: pricing => airline_pricing\n    procedure :: validity => airline_validity\n    procedure :: baggage_allowance\n  end type AirlineTicket\n\ncontains\n\n  real function base_pricing(this)\n    class(Ticket), intent(in) :: this\n    base_pricing = 100.0  ! Base price\n  end function base_pricing\n\n  logical function base_validity(this)\n    class(Ticket), intent(in) :: this\n    base_validity = .true.  ! Always valid\n  end function base_validity\n\n  real function airline_pricing(this)\n    class(AirlineTicket), intent(in) :: this\n    airline_pricing = 250.0  ! Airline specific price\n  end function airline_pricing\n\n  logical function airline_validity(this)\n    class(AirlineTicket), intent(in) :: this\n    airline_validity = .true.  ! Airline specific validity\n  end function airline_validity\n\n  subroutine baggage_allowance(this)\n    class(AirlineTicket), intent(in) :: this\n    print *, \"Baggage allowance: 20kg\"\n  end subroutine baggage_allowance\n\nend module TransportationModule\n\nprogram TestInheritance\n  use TransportationModule\n  implicit none\n\n  class(Ticket), allocatable :: ticket\n  class(AirlineTicket), allocatable :: airlineTicket\n\n  allocate(ticket)\n  print *, \"Base Ticket Price: \", ticket%pricing()\n  print *, \"Base Ticket Validity: \", ticket%validity()\n\n  allocate(airlineTicket)\n  print *, \"Airline Ticket Price: \", airlineTicket%pricing()\n  print *, \"Airline Ticket Validity: \", airlineTicket%validity()\n  call airlineTicket%baggage_allowance()\n\nend program TestInheritance\n```"
  },
  {
    "task": "Create a foundational class for a digital photo album with properties like album name and date, and derive a vacation album class that overrides the date property to be specific.",
    "code": "```fortran\nmodule AlbumModule\n    implicit none\n\n    type :: PhotoAlbum\n        character(len=50) :: albumName\n        character(len=10) :: date\n    contains\n        procedure :: display => displayPhotoAlbum\n    end type PhotoAlbum\n\n    type, extends(PhotoAlbum) :: VacationAlbum\n        character(len=20) :: vacationDate\n    contains\n        procedure :: display => displayVacationAlbum\n    end type VacationAlbum\n\ncontains\n\n    subroutine displayPhotoAlbum(self)\n        class(PhotoAlbum), intent(in) :: self\n        print *, \"Album Name:\", self%albumName\n        print *, \"Date:\", self%date\n    end subroutine displayPhotoAlbum\n\n    subroutine displayVacationAlbum(self)\n        class(VacationAlbum), intent(in) :: self\n        print *, \"Album Name:\", self%albumName\n        print *, \"Vacation Date:\", self%vacationDate\n    end subroutine displayVacationAlbum\n\nend module AlbumModule\n```"
  },
  {
    "task": "Design a base class for a home appliance with methods for power usage and warranty, then create a refrigerator subclass that overrides these methods for energy efficiency.",
    "code": "```fortran\nMODULE HomeApplianceModule\n  IMPLICIT NONE\n  TYPE, PUBLIC :: HomeAppliance\n  CONTAINS\n    PROCEDURE :: powerUsage => basePowerUsage\n    PROCEDURE :: warranty => baseWarranty\n  END TYPE HomeAppliance\n\n  TYPE, EXTENDS(HomeAppliance) :: Refrigerator\n  CONTAINS\n    PROCEDURE :: powerUsage => refrigeratorPowerUsage\n    PROCEDURE :: warranty => refrigeratorWarranty\n  END TYPE Refrigerator\n\nCONTAINS\n\n  SUBROUTINE basePowerUsage(this)\n    CLASS(HomeAppliance), INTENT(IN) :: this\n    PRINT *, 'Base power usage calculation'\n  END SUBROUTINE basePowerUsage\n\n  SUBROUTINE baseWarranty(this)\n    CLASS(HomeAppliance), INTENT(IN) :: this\n    PRINT *, 'Base warranty information'\n  END SUBROUTINE baseWarranty\n\n  SUBROUTINE refrigeratorPowerUsage(this)\n    CLASS(Refrigerator), INTENT(IN) :: this\n    PRINT *, 'Refrigerator energy efficiency power usage'\n  END SUBROUTINE refrigeratorPowerUsage\n\n  SUBROUTINE refrigeratorWarranty(this)\n    CLASS(Refrigerator), INTENT(IN) :: this\n    PRINT *, 'Refrigerator specific warranty information'\n  END SUBROUTINE refrigeratorWarranty\n\nEND MODULE HomeApplianceModule\n```"
  },
  {
    "task": "Develop a superclass for a software update with methods for versioning and patch notes, then extend it with a security update subclass that overrides these methods for vulnerabilities.",
    "code": "```fortran\nmodule UpdateModule\n  implicit none\n\n  type :: SoftwareUpdate\n  contains\n    procedure :: getVersion\n    procedure :: getPatchNotes\n  end type SoftwareUpdate\n\n  type, extends(SoftwareUpdate) :: SecurityUpdate\n  contains\n    procedure :: getVersion => getSecurityVersion\n    procedure :: getPatchNotes => getVulnerabilityNotes\n  end type SecurityUpdate\n\ncontains\n\n  subroutine getVersion(this)\n    class(SoftwareUpdate), intent(in) :: this\n    print *, \"Software Update Version 1.0\"\n  end subroutine getVersion\n\n  subroutine getPatchNotes(this)\n    class(SoftwareUpdate), intent(in) :: this\n    print *, \"General improvements and bug fixes.\"\n  end subroutine getPatchNotes\n\n  subroutine getSecurityVersion(this)\n    class(SecurityUpdate), intent(in) :: this\n    print *, \"Security Update Version 1.1\"\n  end subroutine getSecurityVersion\n\n  subroutine getVulnerabilityNotes(this)\n    class(SecurityUpdate), intent(in) :: this\n    print *, \"Fixed critical vulnerabilities.\"\n  end subroutine getVulnerabilityNotes\n\nend module UpdateModule\n```"
  },
  {
    "task": "Implement a base class for a musical performance with methods for rehearsal and execution, then create a concert performance subclass that overrides these methods for live audience.",
    "code": "```fortran\nmodule PerformanceModule\n    implicit none\n\n    type :: MusicalPerformance\n    contains\n        procedure :: rehearsal => baseRehearsal\n        procedure :: execution => baseExecution\n    end type MusicalPerformance\n\n    type, extends(MusicalPerformance) :: ConcertPerformance\n    contains\n        procedure :: rehearsal => concertRehearsal\n        procedure :: execution => concertExecution\n    end type ConcertPerformance\n\ncontains\n\n    subroutine baseRehearsal(this)\n        class(MusicalPerformance), intent(inout) :: this\n        print *, \"Rehearsing musical performance...\"\n    end subroutine baseRehearsal\n\n    subroutine baseExecution(this)\n        class(MusicalPerformance), intent(inout) :: this\n        print *, \"Executing musical performance...\"\n    end subroutine baseExecution\n\n    subroutine concertRehearsal(this)\n        class(ConcertPerformance), intent(inout) :: this\n        print *, \"Rehearsing concert performance for live audience...\"\n    end subroutine concertRehearsal\n\n    subroutine concertExecution(this)\n        class(ConcertPerformance), intent(inout) :: this\n        print *, \"Executing concert performance for live audience...\"\n    end subroutine concertExecution\n\nend module PerformanceModule\n```"
  },
  {
    "task": "Construct a parent class for an academic degree with methods for course requirements and credits, then derive a master's degree class that overrides these methods for advanced studies.",
    "code": "```fortran\nmodule DegreeModule\n    implicit none\n    private\n    public :: AcademicDegree, MastersDegree\n\n    type :: AcademicDegree\n    contains\n        procedure :: course_requirements\n        procedure :: credits\n    end type AcademicDegree\n\n    type, extends(AcademicDegree) :: MastersDegree\n    contains\n        procedure :: course_requirements => masters_course_requirements\n        procedure :: credits => masters_credits\n    end type MastersDegree\n\ncontains\n\n    subroutine course_requirements(this)\n        class(AcademicDegree), intent(in) :: this\n        print *, \"Standard course requirements for an academic degree.\"\n    end subroutine course_requirements\n\n    subroutine credits(this)\n        class(AcademicDegree), intent(in) :: this\n        print *, \"Standard credit requirements for an academic degree.\"\n    end subroutine credits\n\n    subroutine masters_course_requirements(this)\n        class(MastersDegree), intent(in) :: this\n        print *, \"Advanced course requirements for a master's degree.\"\n    end subroutine masters_course_requirements\n\n    subroutine masters_credits(this)\n        class(MastersDegree), intent(in) :: this\n        print *, \"Advanced credit requirements for a master's degree.\"\n    end subroutine masters_credits\n\nend module DegreeModule\n```"
  },
  {
    "task": "Set up a base class for a weather forecast with methods for temperature and conditions, and extend it with a winter forecast subclass that overrides these methods for snow conditions.",
    "code": "```fortran\nmodule WeatherForecast\n    implicit none\n    type :: BaseForecast\n    contains\n        procedure :: getTemperature\n        procedure :: getConditions\n    end type BaseForecast\n\n    type, extends(BaseForecast) :: WinterForecast\n    contains\n        procedure :: getTemperature => getWinterTemperature\n        procedure :: getConditions => getWinterConditions\n    end type WinterForecast\n\ncontains\n\n    function getTemperature(this) result(temp)\n        class(BaseForecast), intent(in) :: this\n        real :: temp\n        temp = 20.0  ! Placeholder for base temperature\n    end function getTemperature\n\n    function getConditions(this) result(cond)\n        class(BaseForecast), intent(in) :: this\n        character(len=20) :: cond\n        cond = \"Sunny\"  ! Placeholder for base conditions\n    end function getConditions\n\n    function getWinterTemperature(this) result(temp)\n        class(WinterForecast), intent(in) :: this\n        real :: temp\n        temp = -5.0  ! Placeholder for winter temperature\n    end function getWinterTemperature\n\n    function getWinterConditions(this) result(cond)\n        class(WinterForecast), intent(in) :: this\n        character(len=20) :: cond\n        cond = \"Snowy\"  ! Placeholder for winter conditions\n    end function getWinterConditions\n\nend module WeatherForecast\n```"
  },
  {
    "task": "Create a foundational class for a personal diary with properties like date and entries, and derive a travel diary class that overrides the date property with travel dates.",
    "code": "```fortran\nmodule diary_module\n    implicit none\n    private\n    public :: personal_diary, travel_diary\n\n    type :: personal_diary\n        character(len=10) :: date\n        character(len=100) :: entries\n    contains\n        procedure :: show_entries\n    end type personal_diary\n\n    type, extends(personal_diary) :: travel_diary\n        character(len=10) :: travel_date\n    contains\n        procedure :: show_entries => show_travel_entries\n    end type travel_diary\n\ncontains\n\n    subroutine show_entries(self)\n        class(personal_diary), intent(in) :: self\n        print *, \"Date: \", self%date\n        print *, \"Entries: \", self%entries\n    end subroutine show_entries\n\n    subroutine show_travel_entries(self)\n        class(travel_diary), intent(in) :: self\n        print *, \"Travel Date: \", self%travel_date\n        print *, \"Entries: \", self%entries\n    end subroutine show_travel_entries\n\nend module diary_module\n```"
  },
  {
    "task": "Design a base class for a pet with methods for feeding and grooming, then create a cat subclass that overrides these methods with specific food preferences.",
    "code": "```fortran\nmodule PetModule\n    implicit none\n    private\n    public :: Pet, Cat\n\n    type :: Pet\n    contains\n        procedure :: feed => pet_feed\n        procedure :: groom => pet_groom\n    end type Pet\n\n    type, extends(Pet) :: Cat\n    contains\n        procedure :: feed => cat_feed\n        procedure :: groom => cat_groom\n    end type Cat\n\ncontains\n\n    subroutine pet_feed(this)\n        class(Pet), intent(inout) :: this\n        print*, \"Feeding the pet.\"\n    end subroutine pet_feed\n\n    subroutine pet_groom(this)\n        class(Pet), intent(inout) :: this\n        print*, \"Grooming the pet.\"\n    end subroutine pet_groom\n\n    subroutine cat_feed(this)\n        class(Cat), intent(inout) :: this\n        print*, \"Feeding the cat with cat food.\"\n    end subroutine cat_feed\n\n    subroutine cat_groom(this)\n        class(Cat), intent(inout) :: this\n        print*, \"Grooming the cat.\"\n    end subroutine cat_groom\n\nend module PetModule\n```"
  },
  {
    "task": "Develop a superclass for a software library with methods for installation and updates, then extend it with a graphics library subclass that overrides these methods for rendering capabilities.",
    "code": "```fortran\nmodule LibraryModule\n    implicit none\n    type :: Library\n    contains\n        procedure :: install => installLibrary\n        procedure :: update => updateLibrary\n    end type Library\n\n    type, extends(Library) :: GraphicsLibrary\n    contains\n        procedure :: install => installGraphicsLibrary\n        procedure :: update => updateGraphicsLibrary\n    end type GraphicsLibrary\n\ncontains\n\n    subroutine installLibrary(this)\n        class(Library), intent(inout) :: this\n        print *, 'Installing library...'\n    end subroutine installLibrary\n\n    subroutine updateLibrary(this)\n        class(Library), intent(inout) :: this\n        print *, 'Updating library...'\n    end subroutine updateLibrary\n\n    subroutine installGraphicsLibrary(this)\n        class(GraphicsLibrary), intent(inout) :: this\n        print *, 'Installing graphics library with rendering capabilities...'\n    end subroutine installGraphicsLibrary\n\n    subroutine updateGraphicsLibrary(this)\n        class(GraphicsLibrary), intent(inout) :: this\n        print *, 'Updating graphics library with rendering capabilities...'\n    end subroutine updateGraphicsLibrary\n\nend module LibraryModule\n```"
  },
  {
    "task": "Implement a base class for a political campaign with methods for fundraising and events, then create a presidential campaign subclass that overrides these methods for national scale.",
    "code": "```fortran\nmodule CampaignModule\n  implicit none\n  private\n  public :: PoliticalCampaign, PresidentialCampaign\n\n  type :: PoliticalCampaign\n  contains\n    procedure :: fundraise => pc_fundraise\n    procedure :: hold_event => pc_hold_event\n  end type PoliticalCampaign\n\n  type, extends(PoliticalCampaign) :: PresidentialCampaign\n  contains\n    procedure :: fundraise => pc_presidential_fundraise\n    procedure :: hold_event => pc_presidential_hold_event\n  end type PresidentialCampaign\n\ncontains\n\n  subroutine pc_fundraise(self)\n    class(PoliticalCampaign), intent(inout) :: self\n    print *, 'Fundraising at the local level.'\n  end subroutine pc_fundraise\n\n  subroutine pc_hold_event(self)\n    class(PoliticalCampaign), intent(inout) :: self\n    print *, 'Holding a local event.'\n  end subroutine pc_hold_event\n\n  subroutine pc_presidential_fundraise(self)\n    class(PresidentialCampaign), intent(inout) :: self\n    print *, 'Fundraising at the national level.'\n  end subroutine pc_presidential_fundraise\n\n  subroutine pc_presidential_hold_event(self)\n    class(PresidentialCampaign), intent(inout) :: self\n    print *, 'Holding a national event.'\n  end subroutine pc_presidential_hold_event\n\nend module CampaignModule\n\nprogram main\n  use CampaignModule\n  implicit none\n\n  type(PoliticalCampaign) :: localCampaign\n  type(PresidentialCampaign) :: nationalCampaign\n\n  call localCampaign%fundraise()\n  call localCampaign%hold_event()\n\n  call nationalCampaign%fundraise()\n  call nationalCampaign%hold_event()\n\nend program main\n```"
  },
  {
    "task": "Construct a parent class for an automotive part with methods for durability and replacement, then derive an engine part class that overrides these methods for performance.",
    "code": "```fortran\nmodule automotive_parts\n  implicit none\n\n  type :: AutomotivePart\n  contains\n    procedure :: durability => part_durability\n    procedure :: replacement => part_replacement\n  end type AutomotivePart\n\n  type, extends(AutomotivePart) :: EnginePart\n  contains\n    procedure :: durability => engine_durability\n    procedure :: replacement => engine_replacement\n  end type EnginePart\n\ncontains\n\n  subroutine part_durability(this)\n    class(AutomotivePart), intent(in) :: this\n    print *, \"Generic part durability\"\n  end subroutine part_durability\n\n  subroutine part_replacement(this)\n    class(AutomotivePart), intent(in) :: this\n    print *, \"Generic part replacement\"\n  end subroutine part_replacement\n\n  subroutine engine_durability(this)\n    class(EnginePart), intent(in) :: this\n    print *, \"Engine part durability\"\n  end subroutine engine_durability\n\n  subroutine engine_replacement(this)\n    class(EnginePart), intent(in) :: this\n    print *, \"Engine part replacement\"\n  end subroutine engine_replacement\n\nend module automotive_parts\n```"
  },
  {
    "task": "Set up a base class for an online tutorial with methods for lessons and quizzes, and extend it with a coding tutorial subclass that overrides these methods for interactive exercises.",
    "code": "```fortran\nmodule tutorial_module\n  implicit none\n\n  type :: Tutorial\n  contains\n    procedure :: lesson => tutorial_lesson\n    procedure :: quiz => tutorial_quiz\n  end type Tutorial\n\n  type, extends(Tutorial) :: CodingTutorial\n  contains\n    procedure :: lesson => coding_tutorial_lesson\n    procedure :: quiz => coding_tutorial_quiz\n  end type CodingTutorial\n\ncontains\n\n  subroutine tutorial_lesson(self)\n    class(Tutorial), intent(inout) :: self\n    print *, \"General tutorial lesson.\"\n  end subroutine tutorial_lesson\n\n  subroutine tutorial_quiz(self)\n    class(Tutorial), intent(inout) :: self\n    print *, \"General tutorial quiz.\"\n  end subroutine tutorial_quiz\n\n  subroutine coding_tutorial_lesson(self)\n    class(CodingTutorial), intent(inout) :: self\n    print *, \"Interactive coding tutorial lesson.\"\n  end subroutine coding_tutorial_lesson\n\n  subroutine coding_tutorial_quiz(self)\n    class(CodingTutorial), intent(inout) :: self\n    print *, \"Interactive coding tutorial quiz.\"\n  end subroutine coding_tutorial_quiz\n\nend module tutorial_module\n```"
  },
  {
    "task": "Create a foundational class for a personal collection with properties like item type and value, and derive a stamp collection class that overrides the item type property to be 'stamps'.",
    "code": "```fortran\nmodule CollectionModule\n    implicit none\n    private\n    public :: PersonalCollection, StampCollection\n\n    type :: PersonalCollection\n        character(len=100) :: itemType\n        real :: value\n    contains\n        procedure :: getDetails\n    end type PersonalCollection\n\n    type, extends(PersonalCollection) :: StampCollection\n    contains\n        procedure :: getDetails => getStampDetails\n    end type StampCollection\n\ncontains\n\n    subroutine getDetails(self)\n        class(PersonalCollection), intent(in) :: self\n        print *, 'Item Type: ', self%itemType\n        print *, 'Value: ', self%value\n    end subroutine getDetails\n\n    subroutine getStampDetails(self)\n        class(StampCollection), intent(in) :: self\n        print *, 'Item Type: stamps'\n        print *, 'Value: ', self%value\n    end subroutine getStampDetails\n\nend module CollectionModule\n\nprogram Main\n    use CollectionModule\n    implicit none\n\n    type(PersonalCollection) :: myCollection\n    type(StampCollection) :: myStampCollection\n\n    myCollection%itemType = 'generic'\n    myCollection%value = 150.0\n\n    myStampCollection%value = 200.0\n\n    call myCollection%getDetails()\n    call myStampCollection%getDetails()\n\nend program Main\n```"
  },
  {
    "task": "Design a base class for a video game character with methods for health and abilities, then create a warrior character subclass that overrides these methods for strength.",
    "code": "```fortran\nmodule CharacterModule\n  implicit none\n\n  type :: Character\n  contains\n    procedure :: health => character_health\n    procedure :: abilities => character_abilities\n  end type Character\n\n  type, extends(Character) :: Warrior\n  contains\n    procedure :: health => warrior_health\n    procedure :: abilities => warrior_abilities\n  end type Warrior\n\ncontains\n\n  subroutine character_health(this)\n    class(Character), intent(inout) :: this\n    print *, \"Character health: 100\"\n  end subroutine character_health\n\n  subroutine character_abilities(this)\n    class(Character), intent(inout) :: this\n    print *, \"Character abilities: General abilities\"\n  end subroutine character_abilities\n\n  subroutine warrior_health(this)\n    class(Warrior), intent(inout) :: this\n    print *, \"Warrior health: 150\"\n  end subroutine warrior_health\n\n  subroutine warrior_abilities(this)\n    class(Warrior), intent(inout) :: this\n    print *, \"Warrior abilities: Strength and combat skills\"\n  end subroutine warrior_abilities\n\nend module CharacterModule\n\nprogram Game\n  use CharacterModule\n  implicit none\n\n  type(Character) :: baseCharacter\n  type(Warrior) :: warriorCharacter\n\n  call baseCharacter%health()\n  call baseCharacter%abilities()\n\n  call warriorCharacter%health()\n  call warriorCharacter%abilities()\n\nend program Game\n```"
  },
  {
    "task": "Develop a superclass for an event planner with methods for scheduling and budgeting, then extend it with a wedding planner subclass that overrides these methods for ceremony details.",
    "code": "```fortran\nmodule EventPlannerModule\n    implicit none\n\n    type :: EventPlanner\n    contains\n        procedure, nopass :: schedule => schedule_event\n        procedure, nopass :: budget => plan_budget\n    end type EventPlanner\n\ncontains\n\n    subroutine schedule_event()\n        print *, \"Scheduling an event in the Event Planner.\"\n    end subroutine schedule_event\n\n    subroutine plan_budget()\n        print *, \"Planning a budget in the Event Planner.\"\n    end subroutine plan_budget\n\nend module EventPlannerModule\n\nmodule WeddingPlannerModule\n    use EventPlannerModule\n    implicit none\n\n    type, extends(EventPlanner) :: WeddingPlanner\n    contains\n        procedure, nopass :: schedule => schedule_wedding\n        procedure, nopass :: budget => plan_wedding_budget\n    end type WeddingPlanner\n\ncontains\n\n    subroutine schedule_wedding()\n        print *, \"Scheduling a wedding with ceremony details.\"\n    end subroutine schedule_wedding\n\n    subroutine plan_wedding_budget()\n        print *, \"Planning a wedding budget with ceremony details.\"\n    end subroutine plan_wedding_budget\n\nend module WeddingPlannerModule\n\nprogram EventPlanning\n    use WeddingPlannerModule\n    implicit none\n\n    type(WeddingPlanner) :: myWeddingPlanner\n\n    call myWeddingPlanner%schedule()\n    call myWeddingPlanner%budget()\n\nend program EventPlanning\n```"
  },
  {
    "task": "Implement a base class for a software feature with methods for functionality and user feedback, then create a beta feature subclass that overrides these methods for testing.",
    "code": "```fortran\nMODULE FeatureModule\n  TYPE, PUBLIC :: BaseFeature\n  CONTAINS\n    PROCEDURE :: functionality => baseFunctionality\n    PROCEDURE :: userFeedback => baseUserFeedback\n  END TYPE BaseFeature\n\n  TYPE, EXTENDS(BaseFeature) :: BetaFeature\n  CONTAINS\n    PROCEDURE :: functionality => betaFunctionality\n    PROCEDURE :: userFeedback => betaUserFeedback\n  END TYPE BetaFeature\n\nCONTAINS\n\n  SUBROUTINE baseFunctionality(this)\n    CLASS(BaseFeature), INTENT(IN) :: this\n    PRINT *, \"Base Feature Functionality\"\n  END SUBROUTINE baseFunctionality\n\n  SUBROUTINE baseUserFeedback(this)\n    CLASS(BaseFeature), INTENT(IN) :: this\n    PRINT *, \"Base Feature User Feedback\"\n  END SUBROUTINE baseUserFeedback\n\n  SUBROUTINE betaFunctionality(this)\n    CLASS(BetaFeature), INTENT(IN) :: this\n    PRINT *, \"Beta Feature Functionality for Testing\"\n  END SUBROUTINE betaFunctionality\n\n  SUBROUTINE betaUserFeedback(this)\n    CLASS(BetaFeature), INTENT(IN) :: this\n    PRINT *, \"Beta Feature User Feedback for Testing\"\n  END SUBROUTINE betaUserFeedback\n\nEND MODULE FeatureModule\n```"
  },
  {
    "task": "Construct a parent class for a gardening tool with methods for usage and maintenance, then derive a lawn mower class that overrides these methods for grass cutting.",
    "code": "```fortran\nmodule gardening_tools\n    implicit none\n\n    type :: GardeningTool\n    contains\n        procedure :: use => use_tool\n        procedure :: maintain => maintain_tool\n    end type GardeningTool\n\n    type, extends(GardeningTool) :: LawnMower\n    contains\n        procedure :: use => use_mower\n        procedure :: maintain => maintain_mower\n    end type LawnMower\n\ncontains\n\n    subroutine use_tool(this)\n        class(GardeningTool), intent(inout) :: this\n        print *, \"Using the gardening tool.\"\n    end subroutine use_tool\n\n    subroutine maintain_tool(this)\n        class(GardeningTool), intent(inout) :: this\n        print *, \"Maintaining the gardening tool.\"\n    end subroutine maintain_tool\n\n    subroutine use_mower(this)\n        class(LawnMower), intent(inout) :: this\n        print *, \"Using the lawn mower to cut grass.\"\n    end subroutine use_mower\n\n    subroutine maintain_mower(this)\n        class(LawnMower), intent(inout) :: this\n        print *, \"Maintaining the lawn mower.\"\n    end subroutine maintain_mower\n\nend module gardening_tools\n\nprogram main\n    use gardening_tools\n    implicit none\n\n    type(LawnMower) :: myMower\n\n    call myMower%use()\n    call myMower%maintain()\n    \nend program main\n```"
  },
  {
    "task": "Set up a base class for a household chore with methods for time and effort, and extend it with a cleaning chore subclass that overrides these methods for dirt removal.",
    "code": "```fortran\nmodule chores_module\n  implicit none\n\n  type :: HouseholdChore\n  contains\n    procedure :: time => time_base\n    procedure :: effort => effort_base\n  end type HouseholdChore\n\n  type, extends(HouseholdChore) :: CleaningChore\n  contains\n    procedure :: time => time_cleaning\n    procedure :: effort => effort_cleaning\n  end type CleaningChore\n\ncontains\n\n  function time_base(this) result(t)\n    class(HouseholdChore), intent(in) :: this\n    real :: t\n    t = 1.0  ! Base chore time\n  end function time_base\n\n  function effort_base(this) result(e)\n    class(HouseholdChore), intent(in) :: this\n    real :: e\n    e = 1.0  ! Base chore effort\n  end function effort_base\n\n  function time_cleaning(this) result(t)\n    class(CleaningChore), intent(in) :: this\n    real :: t\n    t = 2.0  ! Cleaning chore time\n  end function time_cleaning\n\n  function effort_cleaning(this) result(e)\n    class(CleaningChore), intent(in) :: this\n    real :: e\n    e = 3.0  ! Cleaning chore effort\n  end function effort_cleaning\n\nend module chores_module\n```"
  },
  {
    "task": "Create a foundational class for a personal project with properties like name and deadline, and derive a coding project class that overrides the deadline property for milestones.",
    "code": "```fortran\nmodule ProjectModule\n    implicit none\n\n    type :: BaseProject\n        character(len=100) :: name\n        character(len=20) :: deadline\n    contains\n        procedure :: print_info\n    end type BaseProject\n\n    type, extends(BaseProject) :: CodingProject\n        character(len=20) :: milestone_deadline\n    contains\n        procedure :: print_info => print_coding_info\n    end type CodingProject\n\ncontains\n\n    subroutine print_info(this)\n        class(BaseProject), intent(in) :: this\n        print *, 'Project Name:', this%name\n        print *, 'Deadline:', this%deadline\n    end subroutine print_info\n\n    subroutine print_coding_info(this)\n        class(CodingProject), intent(in) :: this\n        print *, 'Coding Project Name:', this%name\n        print *, 'Overall Deadline:', this%deadline\n        print *, 'Milestone Deadline:', this%milestone_deadline\n    end subroutine print_coding_info\n\nend module ProjectModule\n```"
  },
  {
    "task": "Design a base class for a holiday celebration with methods for traditions and activities, then create a Christmas celebration subclass that overrides these methods for gift exchange.",
    "code": "```fortran\nmodule holiday_module\n  implicit none\n  type :: HolidayCelebration\n  contains\n    procedure :: traditions => holiday_traditions\n    procedure :: activities => holiday_activities\n  end type HolidayCelebration\n\n  type, extends(HolidayCelebration) :: ChristmasCelebration\n  contains\n    procedure :: traditions => christmas_traditions\n    procedure :: activities => christmas_activities\n  end type ChristmasCelebration\n\ncontains\n\n  subroutine holiday_traditions(self)\n    class(HolidayCelebration), intent(inout) :: self\n    print*, \"General holiday traditions.\"\n  end subroutine holiday_traditions\n\n  subroutine holiday_activities(self)\n    class(HolidayCelebration), intent(inout) :: self\n    print*, \"General holiday activities.\"\n  end subroutine holiday_activities\n\n  subroutine christmas_traditions(self)\n    class(ChristmasCelebration), intent(inout) :: self\n    print*, \"Christmas traditions include decorating the tree and singing carols.\"\n  end subroutine christmas_traditions\n\n  subroutine christmas_activities(self)\n    class(ChristmasCelebration), intent(inout) :: self\n    print*, \"Christmas activities include gift exchange and family gatherings.\"\n  end subroutine christmas_activities\n\nend module holiday_module\n```"
  },
  {
    "task": "Develop a superclass for a customer feedback system with methods for collecting and analyzing, then extend it with a product feedback subclass that overrides these methods for reviews.",
    "code": "```fortran\nmodule FeedbackSystem\n    implicit none\n    type :: CustomerFeedback\n    contains\n        procedure :: collectFeedback\n        procedure :: analyzeFeedback\n    end type CustomerFeedback\n\ncontains\n\n    subroutine collectFeedback(this)\n        class(CustomerFeedback), intent(inout) :: this\n        print *, \"Collecting general feedback from customer.\"\n    end subroutine collectFeedback\n\n    subroutine analyzeFeedback(this)\n        class(CustomerFeedback), intent(inout) :: this\n        print *, \"Analyzing general customer feedback.\"\n    end subroutine analyzeFeedback\n\nend module FeedbackSystem\n\nmodule ProductFeedbackModule\n    use FeedbackSystem\n    implicit none\n    type, extends(CustomerFeedback) :: ProductFeedback\n    contains\n        procedure :: collectFeedback => collectProductFeedback\n        procedure :: analyzeFeedback => analyzeProductFeedback\n    end type ProductFeedback\n\ncontains\n\n    subroutine collectProductFeedback(this)\n        class(ProductFeedback), intent(inout) :: this\n        print *, \"Collecting product-specific feedback from customer.\"\n    end subroutine collectProductFeedback\n\n    subroutine analyzeProductFeedback(this)\n        class(ProductFeedback), intent(inout) :: this\n        print *, \"Analyzing product-specific customer feedback.\"\n    end subroutine analyzeProductFeedback\n\nend module ProductFeedbackModule\n\nprogram FeedbackSystemDemo\n    use ProductFeedbackModule\n    implicit none\n\n    type(CustomerFeedback) :: generalFeedback\n    type(ProductFeedback) :: productFeedback\n\n    call generalFeedback%collectFeedback()\n    call generalFeedback%analyzeFeedback()\n\n    call productFeedback%collectFeedback()\n    call productFeedback%analyzeFeedback()\n\nend program FeedbackSystemDemo\n```"
  },
  {
    "task": "Implement a base class for a civic service with methods for public engagement and policy, then create a community service subclass that overrides these methods for local impact.",
    "code": "```fortran\nmodule CivicServiceModule\n    implicit none\n    private\n    public :: CivicService, CommunityService\n    type :: CivicService\n    contains\n        procedure :: public_engagement => CivicService_public_engagement\n        procedure :: policy => CivicService_policy\n    end type CivicService\n\n    type, extends(CivicService) :: CommunityService\n    contains\n        procedure :: public_engagement => CommunityService_public_engagement\n        procedure :: policy => CommunityService_policy\n    end type CommunityService\n\ncontains\n\n    subroutine CivicService_public_engagement(this)\n        class(CivicService), intent(in) :: this\n        print *, \"Public engagement on a national level.\"\n    end subroutine CivicService_public_engagement\n\n    subroutine CivicService_policy(this)\n        class(CivicService), intent(in) :: this\n        print *, \"National policy making.\"\n    end subroutine CivicService_policy\n\n    subroutine CommunityService_public_engagement(this)\n        class(CommunityService), intent(in) :: this\n        print *, \"Public engagement on a local level.\"\n    end subroutine CommunityService_public_engagement\n\n    subroutine CommunityService_policy(this)\n        class(CommunityService), intent(in) :: this\n        print *, \"Local policy making.\"\n    end subroutine CommunityService_policy\n\nend module CivicServiceModule\n```"
  },
  {
    "task": "Construct a parent class for a culinary ingredient with methods for flavor and preparation, then derive a spice ingredient class that overrides these methods for seasoning.",
    "code": "```fortran\nmodule ingredient_module\n    implicit none\n    type :: Ingredient\n    contains\n        procedure :: flavor => ingredient_flavor\n        procedure :: preparation => ingredient_preparation\n    end type Ingredient\n\ncontains\n\n    subroutine ingredient_flavor(this)\n        class(Ingredient), intent(in) :: this\n        print *, \"General flavor of the ingredient.\"\n    end subroutine ingredient_flavor\n\n    subroutine ingredient_preparation(this)\n        class(Ingredient), intent(in) :: this\n        print *, \"General preparation of the ingredient.\"\n    end subroutine ingredient_preparation\n\nend module ingredient_module\n\nmodule spice_module\n    use ingredient_module\n    implicit none\n    type, extends(Ingredient) :: Spice\n    contains\n        procedure :: flavor => spice_flavor\n        procedure :: preparation => spice_preparation\n    end type Spice\n\ncontains\n\n    subroutine spice_flavor(this)\n        class(Spice), intent(in) :: this\n        print *, \"Specific flavor for spice seasoning.\"\n    end subroutine spice_flavor\n\n    subroutine spice_preparation(this)\n        class(Spice), intent(in) :: this\n        print *, \"Specific preparation for spice seasoning.\"\n    end subroutine spice_preparation\n\nend module spice_module\n\nprogram culinary_program\n    use spice_module\n    implicit none\n    type(Spice) :: my_spice\n\n    call my_spice%flavor()\n    call my_spice%preparation()\nend program culinary_program\n```"
  },
  {
    "task": "Set up a base class for a scientific experiment with methods for hypothesis and testing, and extend it with a chemistry experiment subclass that overrides these methods for reactions.",
    "code": "```fortran\nmodule experiment_module\n    implicit none\n    type :: Experiment\n    contains\n        procedure :: hypothesis\n        procedure :: testing\n    end type Experiment\n\n    type, extends(Experiment) :: ChemistryExperiment\n    contains\n        procedure :: hypothesis => chemistry_hypothesis\n        procedure :: testing => chemistry_testing\n    end type ChemistryExperiment\n\ncontains\n\n    subroutine hypothesis(this)\n        class(Experiment), intent(inout) :: this\n        print *, \"General hypothesis for a scientific experiment.\"\n    end subroutine hypothesis\n\n    subroutine testing(this)\n        class(Experiment), intent(inout) :: this\n        print *, \"General testing method for a scientific experiment.\"\n    end subroutine testing\n\n    subroutine chemistry_hypothesis(this)\n        class(ChemistryExperiment), intent(inout) :: this\n        print *, \"Hypothesis for a chemistry reaction experiment.\"\n    end subroutine chemistry_hypothesis\n\n    subroutine chemistry_testing(this)\n        class(ChemistryExperiment), intent(inout) :: this\n        print *, \"Testing method for a chemistry reaction experiment.\"\n    end subroutine chemistry_testing\n\nend module experiment_module\n```"
  },
  {
    "task": "Create a foundational class for an inventory system with properties like item ID and quantity, and derive a warehouse inventory class that overrides the quantity property for bulk storage.",
    "code": "```fortran\nmodule InventoryModule\n    implicit none\n\n    type :: Inventory\n        integer :: itemID\n        integer :: quantity\n    contains\n        procedure :: display => displayInventory\n    end type Inventory\n\n    type, extends(Inventory) :: WarehouseInventory\n        integer :: bulkQuantity\n    contains\n        procedure :: display => displayWarehouseInventory\n    end type WarehouseInventory\n\ncontains\n\n    subroutine displayInventory(this)\n        class(Inventory), intent(in) :: this\n        print *, \"Item ID: \", this%itemID\n        print *, \"Quantity: \", this%quantity\n    end subroutine displayInventory\n\n    subroutine displayWarehouseInventory(this)\n        class(WarehouseInventory), intent(in) :: this\n        print *, \"Item ID: \", this%itemID\n        print *, \"Bulk Quantity: \", this%bulkQuantity\n    end subroutine displayWarehouseInventory\n\nend module InventoryModule\n```"
  },
  {
    "task": "Design a base class for a travel agency with methods for itinerary and bookings, then create a luxury travel subclass that overrides these methods for premium services.",
    "code": "```fortran\nmodule travel_agency_module\n    implicit none\n\n    type :: TravelAgency\n    contains\n        procedure :: itinerary => base_itinerary\n        procedure :: bookings => base_bookings\n    end type TravelAgency\n\n    type, extends(TravelAgency) :: LuxuryTravel\n    contains\n        procedure :: itinerary => luxury_itinerary\n        procedure :: bookings => luxury_bookings\n    end type LuxuryTravel\n\ncontains\n\n    subroutine base_itinerary(self)\n        class(TravelAgency), intent(inout) :: self\n        print *, \"Base itinerary for standard travel services.\"\n    end subroutine base_itinerary\n\n    subroutine base_bookings(self)\n        class(TravelAgency), intent(inout) :: self\n        print *, \"Base booking process for standard travel services.\"\n    end subroutine base_bookings\n\n    subroutine luxury_itinerary(self)\n        class(LuxuryTravel), intent(inout) :: self\n        print *, \"Luxury itinerary with premium services.\"\n    end subroutine luxury_itinerary\n\n    subroutine luxury_bookings(self)\n        class(LuxuryTravel), intent(inout) :: self\n        print *, \"Luxury booking process with premium services.\"\n    end subroutine luxury_bookings\n\nend module travel_agency_module\n\nprogram main\n    use travel_agency_module\n    implicit none\n\n    type(TravelAgency) :: agency\n    type(LuxuryTravel) :: luxury_agency\n\n    call agency%itinerary()\n    call agency%bookings()\n\n    call luxury_agency%itinerary()\n    call luxury_agency%bookings()\nend program main\n```"
  },
  {
    "task": "Develop a superclass for an educational tool with methods for teaching and assessment, then extend it with a math tool subclass that overrides these methods for problem-solving.",
    "code": "```fortran\nmodule EducationToolModule\n    implicit none\n    type, public :: EducationTool\n    contains\n        procedure :: teach => teach_education\n        procedure :: assess => assess_education\n    end type EducationTool\n\n    type, extends(EducationTool) :: MathTool\n    contains\n        procedure :: teach => teach_math\n        procedure :: assess => assess_math\n    end type MathTool\n\ncontains\n\n    subroutine teach_education(this)\n        class(EducationTool), intent(inout) :: this\n        print *, 'Teaching general education content.'\n    end subroutine teach_education\n\n    subroutine assess_education(this)\n        class(EducationTool), intent(inout) :: this\n        print *, 'Assessing general education knowledge.'\n    end subroutine assess_education\n\n    subroutine teach_math(this)\n        class(MathTool), intent(inout) :: this\n        print *, 'Teaching math problem-solving.'\n    end subroutine teach_math\n\n    subroutine assess_math(this)\n        class(MathTool), intent(inout) :: this\n        print *, 'Assessing math problem-solving skills.'\n    end subroutine assess_math\n\nend module EducationToolModule\n```"
  },
  {
    "task": "Implement a base class for a community project with methods for planning and execution, then create a park renovation subclass that overrides these methods for landscaping.",
    "code": "```fortran\nmodule CommunityProjectModule\n  implicit none\n  private\n  public :: CommunityProject, ParkRenovation\n\n  type :: CommunityProject\n  contains\n    procedure :: plan => community_plan\n    procedure :: execute => community_execute\n  end type CommunityProject\n\n  type, extends(CommunityProject) :: ParkRenovation\n  contains\n    procedure :: plan => park_plan\n    procedure :: execute => park_execute\n  end type ParkRenovation\n\ncontains\n\n  subroutine community_plan(this)\n    class(CommunityProject), intent(inout) :: this\n    print *, \"General community project planning.\"\n  end subroutine community_plan\n\n  subroutine community_execute(this)\n    class(CommunityProject), intent(inout) :: this\n    print *, \"General community project execution.\"\n  end subroutine community_execute\n\n  subroutine park_plan(this)\n    class(ParkRenovation), intent(inout) :: this\n    print *, \"Planning park landscaping renovation.\"\n  end subroutine park_plan\n\n  subroutine park_execute(this)\n    class(ParkRenovation), intent(inout) :: this\n    print *, \"Executing park landscaping renovation.\"\n  end subroutine park_execute\n\nend module CommunityProjectModule\n```"
  },
  {
    "task": "Construct a parent class for a digital marketing strategy with methods for targeting and engagement, then derive a social media strategy class that overrides these methods for platforms.",
    "code": "```fortran\nmodule DigitalMarketingStrategy\n    implicit none\n    type :: Strategy\n    contains\n        procedure :: target => target_general\n        procedure :: engage => engage_general\n    end type Strategy\n\ncontains\n\n    subroutine target_general(this)\n        class(Strategy), intent(inout) :: this\n        print *, 'General targeting strategy'\n    end subroutine target_general\n\n    subroutine engage_general(this)\n        class(Strategy), intent(inout) :: this\n        print *, 'General engagement strategy'\n    end subroutine engage_general\n\nend module DigitalMarketingStrategy\n\nmodule SocialMediaStrategy\n    use DigitalMarketingStrategy\n    implicit none\n    type, extends(Strategy) :: SocialStrategy\n    contains\n        procedure :: target => target_social\n        procedure :: engage => engage_social\n    end type SocialStrategy\n\ncontains\n\n    subroutine target_social(this)\n        class(SocialStrategy), intent(inout) :: this\n        print *, 'Social media targeting strategy'\n    end subroutine target_social\n\n    subroutine engage_social(this)\n        class(SocialStrategy), intent(inout) :: this\n        print *, 'Social media engagement strategy'\n    end subroutine engage_social\n\nend module SocialMediaStrategy\n```"
  },
  {
    "task": "Set up a base class for a scientific publication with methods for research and review, and extend it with a journal article subclass that overrides these methods for peer review.",
    "code": "```fortran\nmodule PublicationModule\n    implicit none\n    type :: ScientificPublication\n    contains\n        procedure :: research\n        procedure :: review\n    end type ScientificPublication\n\n    type, extends(ScientificPublication) :: JournalArticle\n    contains\n        procedure :: peer_review => review\n    end type JournalArticle\n\ncontains\n\n    subroutine research(this)\n        class(ScientificPublication), intent(inout) :: this\n        print *, 'Conducting research in scientific publication.'\n    end subroutine research\n\n    subroutine review(this)\n        class(ScientificPublication), intent(inout) :: this\n        print *, 'Reviewing scientific publication.'\n    end subroutine review\n\n    subroutine peer_review(this)\n        class(JournalArticle), intent(inout) :: this\n        print *, 'Conducting peer review for journal article.'\n    end subroutine peer_review\n\nend module PublicationModule\n```"
  },
  {
    "task": "Create a foundational class for a software module with properties like name and dependencies, and derive a user interface module class that overrides the dependencies property for UI libraries.",
    "code": "```fortran\nmodule Modules\n    implicit none\n\n    type :: BaseModule\n        character(len=:), allocatable :: name\n        character(len=:), allocatable :: dependencies\n    contains\n        procedure :: set_name\n        procedure :: set_dependencies\n        procedure :: get_name\n        procedure :: get_dependencies\n    end type BaseModule\n\n    type, extends(BaseModule) :: UIModule\n    contains\n        procedure :: set_dependencies => ui_set_dependencies\n    end type UIModule\n\ncontains\n\n    subroutine set_name(this, name)\n        class(BaseModule), intent(inout) :: this\n        character(len=*), intent(in) :: name\n        this%name = name\n    end subroutine set_name\n\n    subroutine set_dependencies(this, dependencies)\n        class(BaseModule), intent(inout) :: this\n        character(len=*), intent(in) :: dependencies\n        this%dependencies = dependencies\n    end subroutine set_dependencies\n\n    subroutine get_name(this, name)\n        class(BaseModule), intent(in) :: this\n        character(len=:), allocatable, intent(out) :: name\n        name = this%name\n    end subroutine get_name\n\n    subroutine get_dependencies(this, dependencies)\n        class(BaseModule), intent(in) :: this\n        character(len=:), allocatable, intent(out) :: dependencies\n        dependencies = this%dependencies\n    end subroutine get_dependencies\n\n    subroutine ui_set_dependencies(this, dependencies)\n        class(UIModule), intent(inout) :: this\n        character(len=*), intent(in) :: dependencies\n        this%dependencies = dependencies // ' + UI libraries'\n    end subroutine ui_set_dependencies\n\nend module Modules\n```"
  },
  {
    "task": "Design a base class for a fashion line with methods for design and production, then create a summer collection subclass that overrides these methods for seasonal trends.",
    "code": "```fortran\nmodule fashion\n  implicit none\n  type :: BaseFashionLine\n  contains\n    procedure :: design => baseDesign\n    procedure :: production => baseProduction\n  end type BaseFashionLine\n\n  type, extends(BaseFashionLine) :: SummerCollection\n  contains\n    procedure :: design => summerDesign\n    procedure :: production => summerProduction\n  end type SummerCollection\n\ncontains\n\n  subroutine baseDesign(this)\n    class(BaseFashionLine), intent(inout) :: this\n    print *, \"Designing base fashion line\"\n  end subroutine baseDesign\n\n  subroutine baseProduction(this)\n    class(BaseFashionLine), intent(inout) :: this\n    print *, \"Producing base fashion line\"\n  end subroutine baseProduction\n\n  subroutine summerDesign(this)\n    class(SummerCollection), intent(inout) :: this\n    print *, \"Designing summer collection with seasonal trends\"\n  end subroutine summerDesign\n\n  subroutine summerProduction(this)\n    class(SummerCollection), intent(inout) :: this\n    print *, \"Producing summer collection with seasonal trends\"\n  end subroutine summerProduction\n\nend module fashion\n\nprogram FashionTest\n  use fashion\n  implicit none\n  type(BaseFashionLine) :: baseLine\n  type(SummerCollection) :: summerLine\n\n  call baseLine%design()\n  call baseLine%production()\n\n  call summerLine%design()\n  call summerLine%production()\n\nend program FashionTest\n```"
  },
  {
    "task": "Develop a superclass for a family tree with methods for ancestry and descendants, then extend it with a royal lineage subclass that overrides these methods for historical accuracy.",
    "code": "```fortran\nmodule FamilyTreeModule\n  implicit none\n\n  type :: FamilyTree\n  contains\n    procedure :: ancestry => family_ancestry\n    procedure :: descendants => family_descendants\n  end type FamilyTree\n\n  type, extends(FamilyTree) :: RoyalLineage\n  contains\n    procedure :: ancestry => royal_ancestry\n    procedure :: descendants => royal_descendants\n  end type RoyalLineage\n\ncontains\n\n  subroutine family_ancestry(this)\n    class(FamilyTree), intent(in) :: this\n    print *, \"General family ancestry method.\"\n  end subroutine family_ancestry\n\n  subroutine family_descendants(this)\n    class(FamilyTree), intent(in) :: this\n    print *, \"General family descendants method.\"\n  end subroutine family_descendants\n\n  subroutine royal_ancestry(this)\n    class(RoyalLineage), intent(in) :: this\n    print *, \"Royal lineage ancestry method with historical adjustments.\"\n  end subroutine royal_ancestry\n\n  subroutine royal_descendants(this)\n    class(RoyalLineage), intent(in) :: this\n    print *, \"Royal lineage descendants method with historical adjustments.\"\n  end subroutine royal_descendants\n\nend module FamilyTreeModule\n\nprogram Main\n  use FamilyTreeModule\n  implicit none\n\n  class(FamilyTree), pointer :: generalFamily\n  class(RoyalLineage), pointer :: royalFamily\n\n  allocate(generalFamily)\n  call generalFamily%ancestry()\n  call generalFamily%descendants()\n\n  allocate(royalFamily)\n  call royalFamily%ancestry()\n  call royalFamily%descendants()\n\nend program Main\n```"
  },
  {
    "task": "Implement a base class for a musical score with methods for composition and arrangement, then create a symphony subclass that overrides these methods for orchestration.",
    "code": "```fortran\nmodule MusicModule\n    implicit none\n    type :: MusicalScore\n    contains\n        procedure :: compose\n        procedure :: arrange\n    end type MusicalScore\n\n    type, extends(MusicalScore) :: Symphony\n    contains\n        procedure :: compose => compose_symphony\n        procedure :: arrange => arrange_symphony\n    end type Symphony\n\ncontains\n\n    subroutine compose(this)\n        class(MusicalScore), intent(inout) :: this\n        print *, \"Composing a musical score.\"\n    end subroutine compose\n\n    subroutine arrange(this)\n        class(MusicalScore), intent(inout) :: this\n        print *, \"Arranging a musical score.\"\n    end subroutine arrange\n\n    subroutine compose_symphony(this)\n        class(Symphony), intent(inout) :: this\n        print *, \"Composing a symphony with orchestration.\"\n    end subroutine compose_symphony\n\n    subroutine arrange_symphony(this)\n        class(Symphony), intent(inout) :: this\n        print *, \"Arranging a symphony for orchestration.\"\n    end subroutine arrange_symphony\n\nend module MusicModule\n```"
  },
  {
    "task": "Construct a parent class for a historical record with methods for events and dates, then derive a war history class that overrides these methods for battles.",
    "code": "```fortran\nmodule HistoricalRecordModule\n    implicit none\n    type :: HistoricalRecord\n    contains\n        procedure :: events => recordEvents\n        procedure :: dates => recordDates\n    end type HistoricalRecord\n\n    type, extends(HistoricalRecord) :: WarHistory\n    contains\n        procedure :: events => battleEvents\n        procedure :: dates => battleDates\n    end type WarHistory\ncontains\n\n    subroutine recordEvents(this)\n        class(HistoricalRecord), intent(in) :: this\n        print *, \"General historical events\"\n    end subroutine recordEvents\n\n    subroutine recordDates(this)\n        class(HistoricalRecord), intent(in) :: this\n        print *, \"General historical dates\"\n    end subroutine recordDates\n\n    subroutine battleEvents(this)\n        class(WarHistory), intent(in) :: this\n        print *, \"Specific battle events\"\n    end subroutine battleEvents\n\n    subroutine battleDates(this)\n        class(WarHistory), intent(in) :: this\n        print *, \"Specific battle dates\"\n    end subroutine battleDates\n\nend module HistoricalRecordModule\n```"
  },
  {
    "task": "Set up a base class for a pet adoption service with methods for application and approval, and extend it with a dog adoption subclass that overrides these methods for breed compatibility.",
    "code": "```fortran\nmodule PetAdoptionService\n    implicit none\n    type :: PetAdoption\n    contains\n        procedure :: application\n        procedure :: approval\n    end type PetAdoption\n\n    type, extends(PetAdoption) :: DogAdoption\n    contains\n        procedure :: application => dogApplication\n        procedure :: approval => dogApproval\n    end type DogAdoption\n\ncontains\n\n    subroutine application(this)\n        class(PetAdoption), intent(inout) :: this\n        print *, \"Applying for pet adoption.\"\n    end subroutine application\n\n    subroutine approval(this)\n        class(PetAdoption), intent(inout) :: this\n        print *, \"Approving pet adoption.\"\n    end subroutine approval\n\n    subroutine dogApplication(this)\n        class(DogAdoption), intent(inout) :: this\n        print *, \"Applying for dog adoption considering breed compatibility.\"\n    end subroutine dogApplication\n\n    subroutine dogApproval(this)\n        class(DogAdoption), intent(inout) :: this\n        print *, \"Approving dog adoption with breed compatibility check.\"\n    end subroutine dogApproval\n\nend module PetAdoptionService\n\nprogram Main\n    use PetAdoptionService\n    implicit none\n    type(PetAdoption) :: generalPet\n    type(DogAdoption) :: specificDog\n\n    call generalPet%application()\n    call generalPet%approval()\n\n    call specificDog%application()\n    call specificDog%approval()\nend program Main\n```"
  },
  {
    "task": "Create a foundational class for a financial report with properties like fiscal year and summary, and derive an annual report class that overrides the fiscal year property for yearly data.",
    "code": "```fortran\nmodule financial_report_module\n    implicit none\n\n    type :: FinancialReport\n        character(len=100) :: summary\n    contains\n        procedure :: get_fiscal_year\n    end type FinancialReport\n\n    type, extends(FinancialReport) :: AnnualReport\n    contains\n        procedure :: get_fiscal_year => get_annual_fiscal_year\n    end type AnnualReport\n\ncontains\n\n    pure function get_fiscal_year(this) result(fiscal_year)\n        class(FinancialReport), intent(in) :: this\n        character(len=4) :: fiscal_year\n        fiscal_year = \"2021\"\n    end function get_fiscal_year\n\n    pure function get_annual_fiscal_year(this) result(fiscal_year)\n        class(AnnualReport), intent(in) :: this\n        character(len=4) :: fiscal_year\n        fiscal_year = \"2022\"\n    end function get_annual_fiscal_year\n\nend module financial_report_module\n```"
  },
  {
    "task": "Design a base class for a movie franchise with methods for casting and production, then create a sequel subclass that overrides these methods for continuity.",
    "code": "```fortran\nmodule MovieFranchise\n  implicit none\n  type :: Movie\n  contains\n    procedure :: casting => baseCasting\n    procedure :: production => baseProduction\n  end type Movie\n\n  type, extends(Movie) :: Sequel\n  contains\n    procedure :: casting => sequelCasting\n    procedure :: production => sequelProduction\n  end type Sequel\n\ncontains\n\n  subroutine baseCasting(this)\n    class(Movie), intent(inout) :: this\n    print *, \"Base movie casting process\"\n  end subroutine baseCasting\n\n  subroutine baseProduction(this)\n    class(Movie), intent(inout) :: this\n    print *, \"Base movie production process\"\n  end subroutine baseProduction\n\n  subroutine sequelCasting(this)\n    class(Sequel), intent(inout) :: this\n    print *, \"Sequel movie casting process with continuity\"\n  end subroutine sequelCasting\n\n  subroutine sequelProduction(this)\n    class(Sequel), intent(inout) :: this\n    print *, \"Sequel movie production process with continuity\"\n  end subroutine sequelProduction\n\nend module MovieFranchise\n```"
  },
  {
    "task": "Develop a superclass for a real estate listing with methods for pricing and description, then extend it with a luxury listing subclass that overrides these methods for high-end features.",
    "code": "```fortran\nmodule real_estate_module\n    implicit none\n\n    type :: RealEstateListing\n    contains\n        procedure :: pricing => real_estate_pricing\n        procedure :: description => real_estate_description\n    end type RealEstateListing\n\n    type, extends(RealEstateListing) :: LuxuryListing\n    contains\n        procedure :: pricing => luxury_pricing\n        procedure :: description => luxury_description\n    end type LuxuryListing\n\ncontains\n\n    subroutine real_estate_pricing(this)\n        class(RealEstateListing), intent(in) :: this\n        print *, \"Standard pricing for real estate listing.\"\n    end subroutine real_estate_pricing\n\n    subroutine real_estate_description(this)\n        class(RealEstateListing), intent(in) :: this\n        print *, \"Standard description of real estate listing.\"\n    end subroutine real_estate_description\n\n    subroutine luxury_pricing(this)\n        class(LuxuryListing), intent(in) :: this\n        print *, \"Luxury pricing for high-end real estate listing.\"\n    end subroutine luxury_pricing\n\n    subroutine luxury_description(this)\n        class(LuxuryListing), intent(in) :: this\n        print *, \"Luxury description of high-end real estate listing.\"\n    end subroutine luxury_description\n\nend module real_estate_module\n\nprogram main\n    use real_estate_module\n    implicit none\n\n    class(RealEstateListing), pointer :: listing\n    class(LuxuryListing), pointer :: luxury\n\n    allocate(listing)\n    call listing%pricing()\n    call listing%description()\n\n    allocate(luxury)\n    call luxury%pricing()\n    call luxury%description()\n\nend program main\n```"
  },
  {
    "task": "Implement a base class for a mobile app with methods for user interface and performance, then create a gaming app subclass that overrides these methods for graphics and speed.",
    "code": "```fortran\nmodule AppModule\n    implicit none\n\n    type :: MobileApp\n    contains\n        procedure :: userInterface => baseUserInterface\n        procedure :: performance => basePerformance\n    end type MobileApp\n\n    type, extends(MobileApp) :: GamingApp\n    contains\n        procedure :: userInterface => gamingUserInterface\n        procedure :: performance => gamingPerformance\n    end type GamingApp\n\ncontains\n\n    subroutine baseUserInterface(this)\n        class(MobileApp), intent(inout) :: this\n        print *, \"Base mobile app user interface.\"\n    end subroutine baseUserInterface\n\n    subroutine basePerformance(this)\n        class(MobileApp), intent(inout) :: this\n        print *, \"Base mobile app performance.\"\n    end subroutine basePerformance\n\n    subroutine gamingUserInterface(this)\n        class(GamingApp), intent(inout) :: this\n        print *, \"Gaming app user interface with enhanced graphics.\"\n    end subroutine gamingUserInterface\n\n    subroutine gamingPerformance(this)\n        class(GamingApp), intent(inout) :: this\n        print *, \"Gaming app performance optimized for speed.\"\n    end subroutine gamingPerformance\n\nend module AppModule\n\nprogram main\n    use AppModule\n    implicit none\n\n    type(MobileApp) :: basicApp\n    type(GamingApp) :: gameApp\n\n    call basicApp%userInterface()\n    call basicApp%performance()\n\n    call gameApp%userInterface()\n    call gameApp%performance()\nend program main\n```"
  },
  {
    "task": "Construct a parent class for a corporate policy with methods for compliance and enforcement, then derive an HR policy class that overrides these methods for employee relations.",
    "code": "```fortran\nmodule corporate_policy_module\n  implicit none\n  type, public :: CorporatePolicy\n  contains\n    procedure :: compliance => corporate_compliance\n    procedure :: enforcement => corporate_enforcement\n  end type CorporatePolicy\n\ncontains\n\n  subroutine corporate_compliance(this)\n    class(CorporatePolicy), intent(inout) :: this\n    print *, \"General corporate compliance\"\n  end subroutine corporate_compliance\n\n  subroutine corporate_enforcement(this)\n    class(CorporatePolicy), intent(inout) :: this\n    print *, \"General corporate enforcement\"\n  end subroutine corporate_enforcement\n\nend module corporate_policy_module\n\nmodule hr_policy_module\n  use corporate_policy_module\n  implicit none\n  type, extends(CorporatePolicy) :: HRPolicy\n  contains\n    procedure :: compliance => hr_compliance\n    procedure :: enforcement => hr_enforcement\n  end type HRPolicy\n\ncontains\n\n  subroutine hr_compliance(this)\n    class(HRPolicy), intent(inout) :: this\n    print *, \"HR specific compliance\"\n  end subroutine hr_compliance\n\n  subroutine hr_enforcement(this)\n    class(HRPolicy), intent(inout) :: this\n    print *, \"HR specific enforcement\"\n  end subroutine hr_enforcement\n\nend module hr_policy_module\n```"
  },
  {
    "task": "Set up a base class for a scientific calculator with methods for basic operations and advanced functions, and extend it with a graphing calculator subclass that overrides these methods for plotting.",
    "code": "```fortran\nmodule calculator_module\n    implicit none\n\n    type :: ScientificCalculator\n    contains\n        procedure :: add\n        procedure :: subtract\n        procedure :: multiply\n        procedure :: divide\n        procedure :: advanced_function\n    end type ScientificCalculator\n\n    type, extends(ScientificCalculator) :: GraphingCalculator\n    contains\n        procedure :: plot => plot_override\n    end type GraphingCalculator\n\ncontains\n\n    function add(this, x, y) result(res)\n        class(ScientificCalculator), intent(in) :: this\n        real, intent(in) :: x, y\n        real :: res\n        res = x + y\n    end function add\n\n    function subtract(this, x, y) result(res)\n        class(ScientificCalculator), intent(in) :: this\n        real, intent(in) :: x, y\n        real :: res\n        res = x - y\n    end function subtract\n\n    function multiply(this, x, y) result(res)\n        class(ScientificCalculator), intent(in) :: this\n        real, intent(in) :: x, y\n        real :: res\n        res = x * y\n    end function multiply\n\n    function divide(this, x, y) result(res)\n        class(ScientificCalculator), intent(in) :: this\n        real, intent(in) :: x, y\n        real :: res\n        if (y /= 0.0) then\n            res = x / y\n        else\n            res = 0.0\n        end if\n    end function divide\n\n    function advanced_function(this, x) result(res)\n        class(ScientificCalculator), intent(in) :: this\n        real, intent(in) :: x\n        real :: res\n        res = sin(x)  ! Example advanced function\n    end function advanced_function\n\n    subroutine plot_override(this, data)\n        class(GraphingCalculator), intent(in) :: this\n        real, intent(in) :: data(:)\n        ! Plotting logic goes here\n    end subroutine plot_override\n\nend module calculator_module\n```"
  },
  {
    "task": "Create a foundational class for a children's book with properties like age group and illustrations, and derive a picture book class that overrides the illustrations property to be more prominent.",
    "code": "```fortran\nmodule BookModule\n    implicit none\n\n    type :: ChildrenBook\n        character(len=:), allocatable :: ageGroup\n        logical :: illustrations\n    contains\n        procedure :: display => displayChildrenBook\n    end type ChildrenBook\n\n    type, extends(ChildrenBook) :: PictureBook\n        logical :: prominentIllustrations\n    contains\n        procedure :: display => displayPictureBook\n    end type PictureBook\n\ncontains\n\n    subroutine displayChildrenBook(this)\n        class(ChildrenBook), intent(in) :: this\n        print *, \"Children's Book\"\n        print *, \"Age Group: \", this%ageGroup\n        print *, \"Illustrations: \", this%illustrations\n    end subroutine displayChildrenBook\n\n    subroutine displayPictureBook(this)\n        class(PictureBook), intent(in) :: this\n        print *, \"Picture Book\"\n        print *, \"Age Group: \", this%ageGroup\n        print *, \"Prominent Illustrations: \", this%prominentIllustrations\n    end subroutine displayPictureBook\n\nend module BookModule\n\nprogram Main\n    use BookModule\n    implicit none\n\n    type(ChildrenBook) :: book1\n    type(PictureBook) :: book2\n\n    book1%ageGroup = \"4-8\"\n    book1%illustrations = .true.\n    call book1%display()\n\n    book2%ageGroup = \"3-7\"\n    book2%prominentIllustrations = .true.\n    call book2%display()\n\nend program Main\n```"
  },
  {
    "task": "Design a base class for a cooking class with methods for ingredients and techniques, then create a baking class subclass that overrides these methods for dough preparation.",
    "code": "```fortran\nmodule CookingClass\n    implicit none\n    type :: Cooking\n    contains\n        procedure :: ingredients => generalIngredients\n        procedure :: techniques => generalTechniques\n    end type Cooking\n\n    type, extends(Cooking) :: Baking\n    contains\n        procedure :: ingredients => doughIngredients\n        procedure :: techniques => doughTechniques\n    end type Baking\n\ncontains\n\n    subroutine generalIngredients(self)\n        class(Cooking), intent(inout) :: self\n        print *, \"Ingredients: General cooking ingredients.\"\n    end subroutine generalIngredients\n\n    subroutine generalTechniques(self)\n        class(Cooking), intent(inout) :: self\n        print *, \"Techniques: General cooking techniques.\"\n    end subroutine generalTechniques\n\n    subroutine doughIngredients(self)\n        class(Baking), intent(inout) :: self\n        print *, \"Ingredients: Flour, water, yeast, salt.\"\n    end subroutine doughIngredients\n\n    subroutine doughTechniques(self)\n        class(Baking), intent(inout) :: self\n        print *, \"Techniques: Knead dough, let it rise.\"\n    end subroutine doughTechniques\n\nend module CookingClass\n\nprogram Main\n    use CookingClass\n    implicit none\n    type(Cooking) :: myCooking\n    type(Baking) :: myBaking\n\n    call myCooking%ingredients()\n    call myCooking%techniques()\n\n    call myBaking%ingredients()\n    call myBaking%techniques()\nend program Main\n```"
  },
  {
    "task": "Develop a superclass for a public transportation system with methods for routes and schedules, then extend it with a metro system subclass that overrides these methods for urban areas.",
    "code": "```fortran\nmodule TransportationSystem\n    implicit none\n    \n    type :: PublicTransport\n    contains\n        procedure :: routes => PT_routes\n        procedure :: schedules => PT_schedules\n    end type PublicTransport\n\n    type, extends(PublicTransport) :: MetroSystem\n    contains\n        procedure :: routes => Metro_routes\n        procedure :: schedules => Metro_schedules\n    end type MetroSystem\n\ncontains\n\n    subroutine PT_routes(this)\n        class(PublicTransport), intent(in) :: this\n        print *, \"General public transport routes.\"\n    end subroutine PT_routes\n\n    subroutine PT_schedules(this)\n        class(PublicTransport), intent(in) :: this\n        print *, \"General public transport schedules.\"\n    end subroutine PT_schedules\n\n    subroutine Metro_routes(this)\n        class(MetroSystem), intent(in) :: this\n        print *, \"Urban metro system routes.\"\n    end subroutine Metro_routes\n\n    subroutine Metro_schedules(this)\n        class(MetroSystem), intent(in) :: this\n        print *, \"Urban metro system schedules.\"\n    end subroutine Metro_schedules\n\nend module TransportationSystem\n\nprogram main\n    use TransportationSystem\n    implicit none\n\n    type(PublicTransport) :: pt\n    type(MetroSystem) :: metro\n\n    call pt%routes()\n    call pt%schedules()\n\n    call metro%routes()\n    call metro%schedules()\n\nend program main\n```"
  },
  {
    "task": "Implement a base class for a music store inventory with methods for stock and sales, then create a vinyl record subclass that overrides these methods for collectible items.",
    "code": "```fortran\nmodule MusicStoreInventory\n  implicit none\n  private\n  public :: StoreItem, VinylRecord\n\n  type :: StoreItem\n  contains\n    procedure :: stock => store_stock\n    procedure :: sales => store_sales\n  end type StoreItem\n\n  type, extends(StoreItem) :: VinylRecord\n  contains\n    procedure :: stock => vinyl_stock\n    procedure :: sales => vinyl_sales\n  end type VinylRecord\n\ncontains\n\n  subroutine store_stock(this)\n    class(StoreItem), intent(inout) :: this\n    print *, \"Generic stock management for store items.\"\n  end subroutine store_stock\n\n  subroutine store_sales(this)\n    class(StoreItem), intent(inout) :: this\n    print *, \"Generic sales management for store items.\"\n  end subroutine store_sales\n\n  subroutine vinyl_stock(this)\n    class(VinylRecord), intent(inout) :: this\n    print *, \"Specialized stock management for collectible vinyl records.\"\n  end subroutine vinyl_stock\n\n  subroutine vinyl_sales(this)\n    class(VinylRecord), intent(inout) :: this\n    print *, \"Specialized sales management for collectible vinyl records.\"\n  end subroutine vinyl_sales\n\nend module MusicStoreInventory\n\nprogram MusicStore\n  use MusicStoreInventory\n  implicit none\n\n  class(StoreItem), allocatable :: item\n  class(VinylRecord), allocatable :: vinyl\n\n  allocate(item, source=StoreItem())\n  allocate(vinyl, source=VinylRecord())\n\n  call item%stock()\n  call item%sales()\n\n  call vinyl%stock()\n  call vinyl%sales()\n\nend program MusicStore\n```"
  },
  {
    "task": "Construct a parent class for a legal contract with methods for terms and conditions, then derive a rental agreement class that overrides these methods for tenant rights.",
    "code": "```fortran\nmodule ContractModule\n    implicit none\n    private\n    public :: LegalContract, RentalAgreement\n\n    type :: LegalContract\n    contains\n        procedure :: terms_and_conditions\n    end type LegalContract\n\n    type, extends(LegalContract) :: RentalAgreement\n    contains\n        procedure :: terms_and_conditions => rental_terms_and_conditions\n    end type RentalAgreement\n\ncontains\n\n    subroutine terms_and_conditions(this)\n        class(LegalContract), intent(in) :: this\n        print *, \"General legal contract terms and conditions.\"\n    end subroutine terms_and_conditions\n\n    subroutine rental_terms_and_conditions(this)\n        class(RentalAgreement), intent(in) :: this\n        print *, \"Rental agreement terms including tenant rights.\"\n    end subroutine rental_terms_and_conditions\n\nend module ContractModule\n```"
  },
  {
    "task": "Set up a base class for a journalism piece with methods for reporting and editing, and extend it with an investigative article subclass that overrides these methods for in-depth analysis.",
    "code": "```fortran\nmodule JournalismModule\n  implicit none\n\n  type :: JournalismPiece\n  contains\n    procedure :: report => baseReport\n    procedure :: edit => baseEdit\n  end type JournalismPiece\n\n  type, extends(JournalismPiece) :: InvestigativeArticle\n  contains\n    procedure :: report => inDepthReport\n    procedure :: edit => inDepthEdit\n  end type InvestigativeArticle\n\ncontains\n\n  subroutine baseReport(self)\n    class(JournalismPiece), intent(inout) :: self\n    print *, \"Reporting the news piece.\"\n  end subroutine baseReport\n\n  subroutine baseEdit(self)\n    class(JournalismPiece), intent(inout) :: self\n    print *, \"Editing the news piece.\"\n  end subroutine baseEdit\n\n  subroutine inDepthReport(self)\n    class(InvestigativeArticle), intent(inout) :: self\n    print *, \"Reporting in-depth analysis for investigative article.\"\n  end subroutine inDepthReport\n\n  subroutine inDepthEdit(self)\n    class(InvestigativeArticle), intent(inout) :: self\n    print *, \"Editing with in-depth analysis for investigative article.\"\n  end subroutine inDepthEdit\n\nend module JournalismModule\n```"
  },
  {
    "task": "Create a foundational class for a wildlife reserve with properties like area and species, and derive a bird sanctuary class that overrides the species property for avians.",
    "code": "```fortran\nmodule WildlifeModule\n    implicit none\n    private\n    public :: WildlifeReserve, BirdSanctuary\n\n    type :: WildlifeReserve\n        real :: area\n        character(len=100) :: species\n    contains\n        procedure, public :: print_info\n    end type WildlifeReserve\n\n    type, extends(WildlifeReserve) :: BirdSanctuary\n    contains\n        procedure, public :: print_info => print_bird_info\n    end type BirdSanctuary\n\ncontains\n\n    subroutine print_info(self)\n        class(WildlifeReserve), intent(in) :: self\n        print *, 'Area:', self%area\n        print *, 'Species:', self%species\n    end subroutine print_info\n\n    subroutine print_bird_info(self)\n        class(BirdSanctuary), intent(in) :: self\n        print *, 'Area:', self%area\n        print *, 'Species: Avian'\n    end subroutine print_bird_info\n\nend module WildlifeModule\n```"
  },
  {
    "task": "Design a base class for a subscription box service with methods for curation and delivery, then create a gourmet food box subclass that overrides these methods for artisanal products.",
    "code": "```fortran\nmodule subscription_module\n    implicit none\n\n    type :: SubscriptionBox\n    contains\n        procedure :: curation => base_curation\n        procedure :: delivery => base_delivery\n    end type SubscriptionBox\n\n    type, extends(SubscriptionBox) :: GourmetFoodBox\n    contains\n        procedure :: curation => gourmet_curation\n        procedure :: delivery => gourmet_delivery\n    end type GourmetFoodBox\n\ncontains\n\n    subroutine base_curation(this)\n        class(SubscriptionBox), intent(inout) :: this\n        print *, \"Base curation process.\"\n    end subroutine base_curation\n\n    subroutine base_delivery(this)\n        class(SubscriptionBox), intent(inout) :: this\n        print *, \"Base delivery process.\"\n    end subroutine base_delivery\n\n    subroutine gourmet_curation(this)\n        class(GourmetFoodBox), intent(inout) :: this\n        print *, \"Gourmet curation for artisanal products.\"\n    end subroutine gourmet_curation\n\n    subroutine gourmet_delivery(this)\n        class(GourmetFoodBox), intent(inout) :: this\n        print *, \"Gourmet delivery for artisanal products.\"\n    end subroutine gourmet_delivery\n\nend module subscription_module\n```"
  },
  {
    "task": "Develop a superclass for a fitness app with methods for tracking and motivation, then extend it with a running app subclass that overrides these methods for pace and distance.",
    "code": "```fortran\nmodule FitnessApp\n    implicit none\n    type, public :: Fitness\n    contains\n        procedure :: track => track_fitness\n        procedure :: motivate => motivate_fitness\n    end type Fitness\n\n    type, extends(Fitness) :: Running\n    contains\n        procedure :: track => track_running\n        procedure :: motivate => motivate_running\n    end type Running\n\ncontains\n\n    subroutine track_fitness(this)\n        class(Fitness), intent(inout) :: this\n        print *, \"Tracking general fitness activity.\"\n    end subroutine track_fitness\n\n    subroutine motivate_fitness(this)\n        class(Fitness), intent(inout) :: this\n        print *, \"Stay motivated for your fitness goals!\"\n    end subroutine motivate_fitness\n\n    subroutine track_running(this)\n        class(Running), intent(inout) :: this\n        print *, \"Tracking running: pace and distance.\"\n    end subroutine track_running\n\n    subroutine motivate_running(this)\n        class(Running), intent(inout) :: this\n        print *, \"Keep pushing your limits in running!\"\n    end subroutine motivate_running\n\nend module FitnessApp\n```"
  },
  {
    "task": "Implement a base class for a digital portfolio with methods for showcasing and updating, then create an artist portfolio subclass that overrides these methods for galleries.",
    "code": "```fortran\nmodule PortfolioModule\n    implicit none\n    type :: DigitalPortfolio\n    contains\n        procedure :: showcase => showcasePortfolio\n        procedure :: update => updatePortfolio\n    end type DigitalPortfolio\n\n    type, extends(DigitalPortfolio) :: ArtistPortfolio\n    contains\n        procedure :: showcase => showcaseGallery\n        procedure :: update => updateGallery\n    end type ArtistPortfolio\n\ncontains\n\n    subroutine showcasePortfolio(this)\n        class(DigitalPortfolio), intent(in) :: this\n        print *, \"Showcasing digital portfolio.\"\n    end subroutine showcasePortfolio\n\n    subroutine updatePortfolio(this)\n        class(DigitalPortfolio), intent(in) :: this\n        print *, \"Updating digital portfolio.\"\n    end subroutine updatePortfolio\n\n    subroutine showcaseGallery(this)\n        class(ArtistPortfolio), intent(in) :: this\n        print *, \"Showcasing artist gallery.\"\n    end subroutine showcaseGallery\n\n    subroutine updateGallery(this)\n        class(ArtistPortfolio), intent(in) :: this\n        print *, \"Updating artist gallery.\"\n    end subroutine updateGallery\n\nend module PortfolioModule\n```"
  },
  {
    "task": "Construct a parent class for a gaming console with methods for performance and compatibility, then derive a next-gen console class that overrides these methods for new features.",
    "code": "```fortran\nmodule gaming_console_mod\n  implicit none\n\n  type :: GamingConsole\n  contains\n    procedure :: performance => base_performance\n    procedure :: compatibility => base_compatibility\n  end type GamingConsole\n\n  type, extends(GamingConsole) :: NextGenConsole\n  contains\n    procedure :: performance => nextgen_performance\n    procedure :: compatibility => nextgen_compatibility\n  end type NextGenConsole\n\ncontains\n\n  subroutine base_performance(this)\n    class(GamingConsole), intent(inout) :: this\n    print *, \"Base gaming console performance.\"\n  end subroutine base_performance\n\n  subroutine base_compatibility(this)\n    class(GamingConsole), intent(inout) :: this\n    print *, \"Base gaming console compatibility.\"\n  end subroutine base_compatibility\n\n  subroutine nextgen_performance(this)\n    class(NextGenConsole), intent(inout) :: this\n    print *, \"Next-gen console enhanced performance.\"\n  end subroutine nextgen_performance\n\n  subroutine nextgen_compatibility(this)\n    class(NextGenConsole), intent(inout) :: this\n    print *, \"Next-gen console enhanced compatibility.\"\n  end subroutine nextgen_compatibility\n\nend module gaming_console_mod\n```"
  },
  {
    "task": "Set up a base class for a cultural festival with methods for events and participation, and extend it with a music festival subclass that overrides these methods for performances.",
    "code": "```fortran\nmodule festival_module\n    implicit none\n\n    type :: CulturalFestival\n    contains\n        procedure :: events => cultural_events\n        procedure :: participation => cultural_participation\n    end type CulturalFestival\n\n    type, extends(CulturalFestival) :: MusicFestival\n    contains\n        procedure :: events => music_events\n        procedure :: participation => music_participation\n    end type MusicFestival\n\ncontains\n\n    subroutine cultural_events(this)\n        class(CulturalFestival), intent(inout) :: this\n        print *, \"Cultural festival events include art exhibitions and workshops.\"\n    end subroutine cultural_events\n\n    subroutine cultural_participation(this)\n        class(CulturalFestival), intent(inout) :: this\n        print *, \"Participation in cultural festival includes attending various cultural activities.\"\n    end subroutine cultural_participation\n\n    subroutine music_events(this)\n        class(MusicFestival), intent(inout) :: this\n        print *, \"Music festival events include concerts and musical performances.\"\n    end subroutine music_events\n\n    subroutine music_participation(this)\n        class(MusicFestival), intent(inout) :: this\n        print *, \"Participation in music festival includes attending concerts and performances.\"\n    end subroutine music_participation\n\nend module festival_module\n```"
  }
]