[
  {
    "task": "Write a program that reads a user's name and age from the input, then prints a greeting message using both values.",
    "code": "```fortran\nprogram greet_user\n    implicit none\n    character(len=100) :: name\n    integer :: age\n\n    print *, 'Enter your name:'\n    read *, name\n    print *, 'Enter your age:'\n    read *, age\n\n    print *, 'Hello, ', trim(name), '! You are ', age, ' years old.'\nend program greet_user\n```"
  },
  {
    "task": "Create a script that continuously reads numbers from the input and prints their running total until a negative number is entered.",
    "code": "```fortran\nprogram RunningTotal\n    implicit none\n    real :: num, total\n\n    total = 0.0\n    print *, \"Enter numbers to sum. Enter a negative number to stop.\"\n\n    do\n        read *, num\n        if (num < 0.0) exit\n        total = total + num\n        print *, \"Running total:\", total\n    end do\n\n    print *, \"Final total:\", total\nend program RunningTotal\n```"
  },
  {
    "task": "Design a program that asks the user for a sentence and outputs the number of words it contains.",
    "code": "```fortran\nprogram count_words\n    implicit none\n    character(len=1000) :: sentence\n    integer :: num_words\n\n    print *, \"Enter a sentence:\"\n    read(*, '(A)') sentence\n\n    num_words = count_words_in_sentence(trim(adjustl(sentence)))\n\n    print *, \"The number of words is:\", num_words\n\ncontains\n\n    integer function count_words_in_sentence(sentence)\n        character(len=*) :: sentence\n        integer :: i, len_sentence, count\n        logical :: in_word\n\n        len_sentence = len(sentence)\n        count = 0\n        in_word = .false.\n\n        do i = 1, len_sentence\n            if (sentence(i:i) /= ' ') then\n                if (.not. in_word) then\n                    count = count + 1\n                    in_word = .true.\n                end if\n            else\n                in_word = .false.\n            end if\n        end do\n\n        count_words_in_sentence = count\n    end function count_words_in_sentence\n\nend program count_words\n```"
  },
  {
    "task": "Build a command-line tool that reads a list of integers and outputs them in sorted order.",
    "code": "```fortran\nprogram sort_integers\n    implicit none\n    integer, allocatable :: numbers(:)\n    integer :: num, i, ios\n\n    ! Read integers from standard input\n    allocate(numbers(0))\n    do\n        read(*, *, IOSTAT=ios) num\n        if (ios /= 0) exit\n        call add_number(numbers, num)\n    end do\n\n    ! Sort the numbers\n    call sort(numbers)\n\n    ! Output the sorted numbers\n    do i = 1, size(numbers)\n        print *, numbers(i)\n    end do\n\ncontains\n    subroutine add_number(arr, num)\n        integer, allocatable :: arr(:)\n        integer :: num\n        integer :: n\n\n        n = size(arr)\n        call move_alloc(arr, arr)\n        allocate(arr(n+1))\n        arr(1:n) = arr(:n)\n        arr(n+1) = num\n    end subroutine add_number\n\n    subroutine sort(arr)\n        integer, allocatable :: arr(:)\n        integer :: i, j, temp\n\n        do i = 1, size(arr)-1\n            do j = i+1, size(arr)\n                if (arr(i) > arr(j)) then\n                    temp = arr(i)\n                    arr(i) = arr(j)\n                    arr(j) = temp\n                end if\n            end do\n        end do\n    end subroutine sort\nend program sort_integers\n```"
  },
  {
    "task": "Develop a program that reads a file name from the input, then prints the number of lines in that file.",
    "code": "```fortran\nprogram count_lines\n    implicit none\n    character(len=256) :: filename\n    integer :: unit, ios, line_count\n    character(len=256) :: line\n\n    ! Read the file name from input\n    print *, 'Enter the file name:'\n    read(*, '(A)') filename\n\n    ! Open the file\n    open(newunit=unit, file=trim(filename), status='old', action='read', iostat=ios)\n    if (ios /= 0) then\n        print *, 'Error opening file.'\n        stop\n    end if\n\n    ! Count the number of lines\n    line_count = 0\n    do\n        read(unit, '(A)', iostat=ios) line\n        if (ios /= 0) exit\n        line_count = line_count + 1\n    end do\n\n    ! Close the file\n    close(unit)\n\n    ! Print the number of lines\n    print *, 'Number of lines:', line_count\nend program count_lines\n```"
  },
  {
    "task": "Implement a calculator that reads two numbers and an operator (+, -, *, /) from the input and prints the result.",
    "code": "```fortran\nprogram calculator\n    implicit none\n    real :: num1, num2, result\n    character(len=1) :: operator\n\n    print *, 'Enter first number: '\n    read *, num1\n    print *, 'Enter operator (+, -, *, /): '\n    read *, operator\n    print *, 'Enter second number: '\n    read *, num2\n\n    select case (operator)\n    case ('+')\n        result = num1 + num2\n    case ('-')\n        result = num1 - num2\n    case ('*')\n        result = num1 * num2\n    case ('/')\n        if (num2 /= 0.0) then\n            result = num1 / num2\n        else\n            print *, 'Error: Division by zero.'\n            stop\n        end if\n    case default\n        print *, 'Error: Invalid operator.'\n        stop\n    end select\n\n    print *, 'Result: ', result\nend program calculator\n```"
  },
  {
    "task": "Write a script that reads a user's full name and prints it in reverse order.",
    "code": "```fortran\nprogram ReverseName\n    implicit none\n    character(len=100) :: fullName\n    character(len=100) :: reversedName\n    integer :: i, lenName\n\n    print *, \"Enter your full name:\"\n    read(*,'(A)') fullName\n\n    lenName = len_trim(fullName)\n    reversedName = \"\"\n    do i = lenName, 1, -1\n        reversedName(lenName-i+1:lenName-i+1) = fullName(i:i)\n    end do\n\n    print *, \"Reversed name:\", trim(reversedName)\nend program ReverseName\n```"
  },
  {
    "task": "Create a program that asks for a word and checks if it is a palindrome, printing the appropriate message.",
    "code": "```fortran\nprogram palindrome_check\n    implicit none\n    character(len=100) :: word\n    character(len=100) :: reversed_word\n    integer :: i, len_word\n\n    print *, \"Enter a word: \"\n    read *, word\n\n    len_word = len_trim(word)\n    reversed_word = word(len_word:len_word)\n\n    do i = len_word - 1, 1, -1\n        reversed_word = trim(reversed_word) // word(i:i)\n    end do\n\n    if (trim(adjustl(word)) == trim(reversed_word)) then\n        print *, \"The word is a palindrome.\"\n    else\n        print *, \"The word is not a palindrome.\"\n    end if\nend program palindrome_check\n```"
  },
  {
    "task": "Develop a tool that reads multiple lines of text and outputs the longest line.",
    "code": "```fortran\nprogram longest_line\n    implicit none\n    character(len=1024) :: line, longest_line\n    integer :: stat, max_length\n\n    max_length = 0\n    longest_line = ''\n\n    do\n        read(*, '(A)', IOSTAT=stat) line\n        if (stat /= 0) exit\n        if (len_trim(line) > max_length) then\n            max_length = len_trim(line)\n            longest_line = line\n        end if\n    end do\n\n    if (max_length > 0) then\n        print *, 'Longest line: ', trim(longest_line)\n    else\n        print *, 'No lines were read.'\n    end if\nend program longest_line\n```"
  },
  {
    "task": "Design a script that reads a number 'n' and prints the first 'n' Fibonacci numbers.",
    "code": "```fortran\nprogram fibonacci\n    implicit none\n    integer :: n, i\n    integer :: a, b, c\n\n    print *, 'Enter the number of Fibonacci numbers to generate:'\n    read *, n\n\n    if (n <= 0) then\n        print *, 'Please enter a positive integer.'\n    else\n        a = 0\n        b = 1\n        if (n >= 1) print *, a\n        if (n >= 2) print *, b\n        do i = 3, n\n            c = a + b\n            print *, c\n            a = b\n            b = c\n        end do\n    end if\nend program fibonacci\n```"
  },
  {
    "task": "Write a program that takes a list of numbers from the input and prints only the even ones.",
    "code": "```fortran\nprogram print_even_numbers\n    implicit none\n    integer :: num, ios\n    print *, 'Enter list of numbers, end with a non-numeric input:'\n\n    do\n        read(*, *, IOSTAT=ios) num\n        if (ios /= 0) exit\n        if (mod(num, 2) == 0) then\n            print *, num\n        end if\n    end do\nend program print_even_numbers\n```"
  },
  {
    "task": "Create a script that reads a date (day, month, year) and prints the day of the week for that date.",
    "code": "```fortran\nprogram DayOfWeek\n  implicit none\n  integer :: day, month, year, dayOfWeek\n  character(len=10) :: weekDay\n\n  print *, 'Enter day, month, year:'\n  read *, day, month, year\n\n  call getDayOfWeek(day, month, year, dayOfWeek)\n\n  select case (dayOfWeek)\n  case (0)\n     weekDay = 'Sunday'\n  case (1)\n     weekDay = 'Monday'\n  case (2)\n     weekDay = 'Tuesday'\n  case (3)\n     weekDay = 'Wednesday'\n  case (4)\n     weekDay = 'Thursday'\n  case (5)\n     weekDay = 'Friday'\n  case (6)\n     weekDay = 'Saturday'\n  end select\n\n  print *, 'The day of the week is', trim(weekDay)\n\ncontains\n\n  subroutine getDayOfWeek(d, m, y, dow)\n    integer, intent(in) :: d, m, y\n    integer, intent(out) :: dow\n    integer :: k, mAdjusted, c, yAdjusted\n\n    if (m < 3) then\n       mAdjusted = m + 12\n       yAdjusted = y - 1\n    else\n       mAdjusted = m\n       yAdjusted = y\n    end if\n\n    k = yAdjusted - (yAdjusted / 100) * 100\n    c = yAdjusted / 100\n\n    dow = d + 13 * (mAdjusted + 1) / 5 + k + k / 4 + c / 4 - 2 * c\n    dow = mod(dow, 7)\n    if (dow < 0) dow = dow + 7\n\n  end subroutine getDayOfWeek\n\nend program DayOfWeek\n```"
  },
  {
    "task": "Develop a program that reads a paragraph and counts the frequency of each letter in the text.",
    "code": "```fortran\nprogram letter_frequency\n    implicit none\n    character(len=1000) :: paragraph\n    integer :: i, ascii_value\n    integer, dimension(26) :: letter_count = 0\n\n    print *, 'Enter a paragraph:'\n    read(*, '(A)') paragraph\n\n    do i = 1, len(paragraph)\n        ascii_value = ichar(paragraph(i:i))\n        if (ascii_value >= ichar('A') .and. ascii_value <= ichar('Z')) then\n            letter_count(ascii_value - ichar('A') + 1) = letter_count(ascii_value - ichar('A') + 1) + 1\n        else if (ascii_value >= ichar('a') .and. ascii_value <= ichar('z')) then\n            letter_count(ascii_value - ichar('a') + 1) = letter_count(ascii_value - ichar('a') + 1) + 1\n        end if\n    end do\n\n    print *, 'Frequency of each letter:'\n    do i = 1, 26\n        print '(A1, \": \", I0)', char(ichar('a') + i - 1), letter_count(i)\n    end do\n\nend program letter_frequency\n```"
  },
  {
    "task": "Build a tool that reads a text and a word, then prints the number of times the word appears in the text.",
    "code": "```fortran\nprogram word_counter\n    implicit none\n    character(len=1000) :: text\n    character(len=100) :: word\n    integer :: count, position\n\n    write(*,*) 'Enter the text:'\n    read(*,'(A)') text\n    write(*,*) 'Enter the word to count:'\n    read(*,'(A)') word\n\n    count = 0\n    position = index(text, trim(word))\n    \n    do while (position /= 0)\n        count = count + 1\n        position = index(text(position+len_trim(word):), trim(word))\n        if (position /= 0) position = position + len_trim(word)\n    end do\n\n    write(*,*) 'The word \"', trim(word), '\" appears ', count, ' times in the text.'\nend program word_counter\n```"
  },
  {
    "task": "Implement a script that reads a temperature in Celsius and converts it to Fahrenheit, printing the result.",
    "code": "```fortran\nprogram TemperatureConversion\n    implicit none\n    real :: celsius, fahrenheit\n\n    print *, 'Enter temperature in Celsius:'\n    read *, celsius\n\n    fahrenheit = celsius * 9.0 / 5.0 + 32.0\n\n    print *, 'Temperature in Fahrenheit:', fahrenheit\nend program TemperatureConversion\n```"
  },
  {
    "task": "Write a program that continuously reads input until the word 'exit' is entered, then prints all entered inputs.",
    "code": "```fortran\nprogram read_input\n    implicit none\n    character(len=100) :: input\n    character(len=100), allocatable :: inputs(:)\n    integer :: count\n\n    count = 0\n    allocate(inputs(0))\n\n    do\n        read(*, '(A)') input\n        if (trim(input) == 'exit') exit\n        count = count + 1\n        call move_alloc(from=inputs, to=inputs)\n        allocate(inputs(count))\n        inputs(count) = input\n    end do\n\n    print *, \"Entered inputs:\"\n    do count = 1, size(inputs)\n        print *, trim(inputs(count))\n    end do\nend program read_input\n```"
  },
  {
    "task": "Create a tool that prompts for a filename, reads the file, and prints its content in uppercase.",
    "code": "```fortran\nprogram read_and_print_uppercase\n    implicit none\n    character(len=100) :: filename\n    character(len=1000) :: line\n    integer :: unit_number, ios\n    print *, 'Enter the filename:'\n    read(*, '(A)') filename\n    open(newunit=unit_number, file=trim(filename), status='old', iostat=ios)\n    if (ios /= 0) then\n        print *, 'Error opening file.'\n        stop\n    end if\n    do\n        read(unit_number, '(A)', iostat=ios) line\n        if (ios /= 0) exit\n        print '(A)', adjustl(uppercase(trim(line)))\n    end do\n    close(unit_number)\ncontains\n    pure function uppercase(s) result(res)\n        character(len=*), intent(in) :: s\n        character(len=len(s)) :: res\n        integer :: i\n        res = s\n        do i = 1, len(s)\n            if (iachar(res(i:i)) >= iachar('a') .and. iachar(res(i:i)) <= iachar('z')) then\n                res(i:i) = achar(iachar(res(i:i)) - iachar('a') + iachar('A'))\n            endif\n        end do\n    end function uppercase\nend program read_and_print_uppercase\n```"
  },
  {
    "task": "Develop a program that reads a series of email addresses and prints the unique domain names.",
    "code": "```fortran\nprogram unique_domains\n    implicit none\n    character(len=256) :: email\n    character(len=256) :: domain\n    character(len=100), dimension(:), allocatable :: domains\n    integer :: i, n, j\n    logical :: found\n\n    allocate(domains(0))\n    n = 0\n\n    print *, 'Enter email addresses (enter \"END\" to stop):'\n\n    do\n        read(*, '(A)') email\n        if (trim(email) == 'END') exit\n\n        call get_domain(email, domain)\n\n        found = .false.\n        do i = 1, n\n            if (trim(domains(i)) == trim(domain)) then\n                found = .true.\n                exit\n            end if\n        end do\n\n        if (.not. found) then\n            n = n + 1\n            call extend_array(domains, n)\n            domains(n) = trim(domain)\n        end if\n    end do\n\n    print *, 'Unique domain names:'\n    do i = 1, n\n        print *, trim(domains(i))\n    end do\n\ncontains\n\n    subroutine get_domain(email, domain)\n        character(len=*), intent(in) :: email\n        character(len=*), intent(out) :: domain\n        integer :: pos\n\n        pos = index(email, '@')\n        if (pos > 0) then\n            domain = email(pos+1:)\n        else\n            domain = ''\n        end if\n    end subroutine get_domain\n\n    subroutine extend_array(arr, new_size)\n        character(len=100), dimension(:), allocatable, intent(inout) :: arr\n        integer, intent(in) :: new_size\n        character(len=100), dimension(:), allocatable :: temp\n\n        allocate(temp(size(arr)))\n        temp = arr\n        deallocate(arr)\n        allocate(arr(new_size))\n        arr(:size(temp)) = temp\n    end subroutine extend_array\n\nend program unique_domains\n```"
  },
  {
    "task": "Design a script that reads a string and prints whether it contains all the letters of the alphabet.",
    "code": "```fortran\nprogram check_alphabet\n    implicit none\n    character(len=1000) :: input_string\n    integer :: i\n    logical :: all_letters_present\n    logical, dimension(26) :: letters_present = .false.\n\n    print *, 'Enter a string:'\n    read(*,'(A)') input_string\n\n    do i = 1, len_trim(input_string)\n        if (iachar(input_string(i:i)) >= iachar('a') .and. iachar(input_string(i:i)) <= iachar('z')) then\n            letters_present(iachar(input_string(i:i)) - iachar('a') + 1) = .true.\n        else if (iachar(input_string(i:i)) >= iachar('A') .and. iachar(input_string(i:i)) <= iachar('Z')) then\n            letters_present(iachar(input_string(i:i)) - iachar('A') + 1) = .true.\n        end if\n    end do\n\n    all_letters_present = .true.\n    do i = 1, 26\n        if (.not. letters_present(i)) then\n            all_letters_present = .false.\n            exit\n        end if\n    end do\n\n    if (all_letters_present) then\n        print *, 'The string contains all the letters of the alphabet.'\n    else\n        print *, 'The string does not contain all the letters of the alphabet.'\n    end if\nend program check_alphabet\n```"
  },
  {
    "task": "Write a program that reads a number and prints its factorial.",
    "code": "```fortran\nprogram factorial\n    implicit none\n    integer :: num, i\n    integer(kind=8) :: fact\n\n    print *, \"Enter a number:\"\n    read *, num\n\n    fact = 1\n    do i = 2, num\n        fact = fact * i\n    end do\n\n    print *, \"The factorial of\", num, \"is\", fact\nend program factorial\n```"
  },
  {
    "task": "Create a tool that reads a list of names and prints them in alphabetical order.",
    "code": "```fortran\nprogram sort_names\n  implicit none\n  character(len=100), allocatable :: names(:)\n  integer :: num_names, i\n\n  ! Read the number of names\n  print *, 'Enter number of names:'\n  read *, num_names\n\n  allocate(names(num_names))\n\n  ! Read each name\n  do i = 1, num_names\n    print *, 'Enter name ', i, ':'\n    read *, names(i)\n  end do\n\n  ! Sort the names in alphabetical order\n  call sort_alphabetically(names, num_names)\n\n  ! Print the sorted names\n  print *, 'Names in alphabetical order:'\n  do i = 1, num_names\n    print *, trim(names(i))\n  end do\n\ncontains\n\n  subroutine sort_alphabetically(arr, n)\n    character(len=100), intent(inout) :: arr(n)\n    integer, intent(in) :: n\n    integer :: i, j\n    character(len=100) :: temp\n\n    do i = 1, n-1\n      do j = i+1, n\n        if (arr(i) > arr(j)) then\n          temp = arr(i)\n          arr(i) = arr(j)\n          arr(j) = temp\n        end if\n      end do\n    end do\n  end subroutine sort_alphabetically\n\nend program sort_names\n```"
  },
  {
    "task": "Develop a program that asks for a sentence and prints each word on a new line.",
    "code": "```fortran\nprogram print_words\n    implicit none\n    character(len=256) :: sentence\n    character(len=32) :: word\n    integer :: i, length, start, end\n\n    print *, 'Enter a sentence:'\n    read(*,'(A)') sentence\n\n    length = len_trim(sentence)\n    start = 1\n\n    do i = 1, length+1\n        if (i > length .or. sentence(i:i) == ' ') then\n            end = i - 1\n            if (start <= end) then\n                word = sentence(start:end)\n                print *, trim(word)\n            end if\n            start = i + 1\n        end if\n    end do\nend program print_words\n```"
  },
  {
    "task": "Build a script that reads a time in 12-hour format and converts it to 24-hour format.",
    "code": "```fortran\nprogram time_conversion\n    implicit none\n    character(len=8) :: time12\n    character(len=2) :: period\n    integer :: hour, minute\n\n    print *, 'Enter time in 12-hour format (hh:mm AM/PM):'\n    read(*, '(A8)') time12\n\n    read(time12(1:2), '(I2)') hour\n    read(time12(4:5), '(I2)') minute\n    period = time12(7:8)\n\n    if (period == 'PM' .and. hour /= 12) then\n        hour = hour + 12\n    else if (period == 'AM' .and. hour == 12) then\n        hour = 0\n    end if\n\n    print '(I2.2, \":\", I2.2)', hour, minute\nend program time_conversion\n```"
  },
  {
    "task": "Implement a program that reads two strings and checks if they are anagrams, printing the result.",
    "code": "```fortran\nprogram anagram_check\n    implicit none\n    character(len=100) :: str1, str2\n    integer :: len1, len2, i\n    logical :: is_anagram\n\n    print *, 'Enter first string:'\n    read(*, '(A)') str1\n    print *, 'Enter second string:'\n    read(*, '(A)') str2\n\n    len1 = len_trim(str1)\n    len2 = len_trim(str2)\n\n    if (len1 /= len2) then\n        is_anagram = .false.\n    else\n        call sort_string(str1, len1)\n        call sort_string(str2, len2)\n        is_anagram = (str1(1:len1) == str2(1:len2))\n    end if\n\n    if (is_anagram) then\n        print *, 'The strings are anagrams.'\n    else\n        print *, 'The strings are not anagrams.'\n    end if\ncontains\n    subroutine sort_string(s, n)\n        character(len=100) :: s\n        integer :: n, i, j\n        character :: temp\n        do i = 1, n-1\n            do j = i + 1, n\n                if (s(i:i) > s(j:j)) then\n                    temp = s(i:i)\n                    s(i:i) = s(j:j)\n                    s(j:j) = temp\n                end if\n            end do\n        end do\n    end subroutine sort_string\nend program anagram_check\n```"
  },
  {
    "task": "Write a tool that reads a paragraph and prints the first and last sentence.",
    "code": "```fortran\nprogram FirstLastSentence\n    implicit none\n    character(len=1000) :: paragraph\n    character(len=1000) :: firstSentence, lastSentence\n    integer :: firstPeriod, lastPeriod\n\n    print *, \"Enter a paragraph:\"\n    read(*, '(A)') paragraph\n\n    firstPeriod = index(paragraph, '.')\n    lastPeriod = len_trim(paragraph) - index(reverse(paragraph), '.')\n\n    if (firstPeriod > 0) then\n        firstSentence = paragraph(:firstPeriod)\n    else\n        firstSentence = \"No sentence found.\"\n    end if\n\n    if (lastPeriod < len_trim(paragraph)) then\n        lastSentence = paragraph(lastPeriod+1:)\n    else\n        lastSentence = \"No sentence found.\"\n    end if\n\n    print *, \"First sentence:\", trim(firstSentence)\n    print *, \"Last sentence:\", trim(lastSentence)\nend program FirstLastSentence\n```"
  },
  {
    "task": "Create a program that reads a binary number and converts it to decimal.",
    "code": "```fortran\nprogram binary_to_decimal\n  implicit none\n  character(len=32) :: binary_input\n  integer :: decimal_output, i\n\n  print *, 'Enter a binary number:'\n  read(*, '(A)') binary_input\n\n  decimal_output = 0\n  do i = 1, len_trim(binary_input)\n     if (binary_input(i:i) == '1') then\n        decimal_output = decimal_output * 2 + 1\n     else if (binary_input(i:i) == '0') then\n        decimal_output = decimal_output * 2\n     else\n        print *, 'Invalid binary number'\n        stop\n     end if\n  end do\n\n  print *, 'Decimal equivalent:', decimal_output\nend program binary_to_decimal\n```"
  },
  {
    "task": "Develop a script that reads a series of scores and prints the average score.",
    "code": "```fortran\nprogram calculate_average\n  implicit none\n  real :: score, total\n  integer :: count\n  total = 0.0\n  count = 0\n\n  print *, 'Enter scores (enter a negative number to end):'\n\n  do\n    read *, score\n    if (score < 0.0) exit\n    total = total + score\n    count = count + 1\n  end do\n\n  if (count > 0) then\n    print *, 'Average score:', total / count\n  else\n    print *, 'No scores were entered.'\n  end if\nend program calculate_average\n```"
  },
  {
    "task": "Design a program that reads a list of integers and prints the prime numbers.",
    "code": "```fortran\nprogram find_primes\n  implicit none\n  integer, allocatable :: numbers(:)\n  integer :: i, n, num, count\n\n  print *, 'Enter the number of integers:'\n  read *, n\n  allocate(numbers(n))\n\n  print *, 'Enter the integers:'\n  do i = 1, n\n     read *, numbers(i)\n  end do\n\n  print *, 'Prime numbers are:'\n  do i = 1, n\n     num = numbers(i)\n     if (num > 1) then\n        count = 0\n        do while(count < 2)\n           count = 0\n           do j = 2, num - 1\n              if (mod(num, j) == 0) then\n                 count = count + 1\n                 exit\n              end if\n           end do\n           if (count == 0) then\n              print *, num\n           end if\n           exit\n        end do\n     end if\n  end do\n\n  deallocate(numbers)\nend program find_primes\n```"
  },
  {
    "task": "Write a script that reads a word and prints its Pig Latin translation.",
    "code": "```fortran\nprogram pig_latin\n    implicit none\n    character(len=100) :: word, pig_latin_word\n\n    ! Read a word from the user\n    print *, 'Enter a word:'\n    read(*, '(A)') word\n\n    ! Convert to Pig Latin\n    if (index('AEIOUaeiou', word(1:1)) > 0) then\n        pig_latin_word = trim(adjustl(word)) // 'way'\n    else\n        pig_latin_word = trim(adjustl(word(2:))) // word(1:1) // 'ay'\n    end if\n\n    ! Print the Pig Latin translation\n    print *, 'Pig Latin:', pig_latin_word\nend program pig_latin\n```"
  },
  {
    "task": "Create a tool that reads a matrix of numbers and prints its transpose.",
    "code": "```fortran\nprogram transpose_matrix\n    implicit none\n    integer, parameter :: n = 3, m = 3\n    real, dimension(n, m) :: matrix\n    real, dimension(m, n) :: transposed\n    integer :: i, j\n\n    ! Read the matrix\n    print *, 'Enter elements of the matrix:'\n    do i = 1, n\n        read(*,*) (matrix(i, j), j = 1, m)\n    end do\n\n    ! Transpose the matrix\n    do i = 1, n\n        do j = 1, m\n            transposed(j, i) = matrix(i, j)\n        end do\n    end do\n\n    ! Print the transposed matrix\n    print *, 'Transposed matrix:'\n    do i = 1, m\n        write(*,*) (transposed(i, j), j = 1, n)\n    end do\n\nend program transpose_matrix\n```"
  },
  {
    "task": "Implement a program that reads a URL and prints the domain name.",
    "code": "```fortran\nprogram domain_extractor\n    implicit none\n    character(len=256) :: url\n    character(len=256) :: domain\n    integer :: start, end, len_url\n\n    print *, 'Enter a URL:'\n    read(*, '(A)') url\n\n    len_url = len_trim(url)\n\n    start = index(url, '//') + 2\n    if (start == 2) then\n        start = 1\n    end if\n\n    end = index(url(start:), '/') - 1\n    if (end == -1) then\n        end = len_url - start + 1\n    end if\n\n    domain = url(start:start+end-1)\n\n    print *, 'Domain name is:', trim(domain)\nend program domain_extractor\n```"
  },
  {
    "task": "Write a script that reads a number and prints its multiplication table up to 12.",
    "code": "```fortran\nprogram multiplication_table\n    implicit none\n    integer :: num, i\n\n    print *, 'Enter a number:'\n    read *, num\n\n    do i = 1, 12\n        print *, num, 'x', i, '=', num * i\n    end do\nend program multiplication_table\n```"
  },
  {
    "task": "Develop a program that reads a list of dates and prints them in order of occurrence.",
    "code": "```fortran\nprogram sort_dates\n    implicit none\n    integer, parameter :: max_dates = 100\n    integer :: n, i, j\n    character(len=10) :: dates(max_dates), temp\n\n    ! Read the number of dates\n    read(*, *) n\n\n    ! Read the dates\n    do i = 1, n\n        read(*, '(A)') dates(i)\n    end do\n\n    ! Sort the dates\n    do i = 1, n-1\n        do j = i+1, n\n            if (dates(i) > dates(j)) then\n                temp = dates(i)\n                dates(i) = dates(j)\n                dates(j) = temp\n            end if\n        end do\n    end do\n\n    ! Print the sorted dates\n    do i = 1, n\n        write(*, '(A)') trim(dates(i))\n    end do\nend program sort_dates\n```"
  },
  {
    "task": "Create a tool that reads a text and prints it with each sentence capitalized.",
    "code": "```fortran\nprogram capitalize_sentences\n    implicit none\n    character(len=1000) :: text\n    character(len=1) :: char\n    integer :: i, length\n\n    print *, 'Enter a text (end input with a blank line):'\n    text = ''\n    do\n        read(*,'(A)') char\n        if (char .eq. '') exit\n        text = trim(text) // char\n    end do\n\n    length = len_trim(text)\n    if (length == 0) then\n        print *, 'No text provided.'\n        stop\n    end if\n\n    text(1:1) = adjustl(to_upper(text(1:1)))\n\n    do i = 2, length\n        if (text(i-1:i-1) == '.' .or. text(i-1:i-1) == '?' .or. text(i-1:i-1) == '!') then\n            if (i < length) then\n                text(i+1:i+1) = adjustl(to_upper(text(i+1:i+1)))\n            end if\n        end if\n    end do\n\n    print *, 'Capitalized Text:'\n    print *, text\n\ncontains\n\n    function to_upper(c)\n        character(len=1) :: c, to_upper\n        if (c >= 'a' .and. c <= 'z') then\n            to_upper = char(iachar(c) - 32)\n        else\n            to_upper = c\n        end if\n    end function to_upper\n\nend program capitalize_sentences\n```"
  },
  {
    "task": "Design a program that reads a list of words and prints them in reverse alphabetical order.",
    "code": "```fortran\nprogram reverse_alphabetical_order\n    implicit none\n    character(len=100), dimension(:), allocatable :: words\n    integer :: n, i\n\n    print *, \"Enter the number of words:\"\n    read *, n\n    allocate(words(n))\n\n    print *, \"Enter the words:\"\n    do i = 1, n\n        read *, words(i)\n    end do\n\n    call sort_words_reverse(words, n)\n\n    print *, \"Words in reverse alphabetical order:\"\n    do i = 1, n\n        print *, words(i)\n    end do\n\ncontains\n\n    subroutine sort_words_reverse(arr, size)\n        character(len=100), dimension(size) :: arr\n        integer :: size, i, j\n        character(len=100) :: temp\n\n        do i = 1, size - 1\n            do j = i + 1, size\n                if (arr(i) < arr(j)) then\n                    temp = arr(i)\n                    arr(i) = arr(j)\n                    arr(j) = temp\n                end if\n            end do\n        end do\n    end subroutine sort_words_reverse\n\nend program reverse_alphabetical_order\n```"
  },
  {
    "task": "Write a script that asks for two times and prints the difference in minutes.",
    "code": "```fortran\nprogram time_difference\n  implicit none\n  integer :: hour1, minute1, hour2, minute2\n  integer :: total_minutes1, total_minutes2, difference\n\n  print *, 'Enter first time (HH MM):'\n  read *, hour1, minute1\n  print *, 'Enter second time (HH MM):'\n  read *, hour2, minute2\n\n  total_minutes1 = hour1 * 60 + minute1\n  total_minutes2 = hour2 * 60 + minute2\n\n  difference = abs(total_minutes1 - total_minutes2)\n\n  print *, 'Difference in minutes:', difference\nend program time_difference\n```"
  },
  {
    "task": "Build a program that reads a text and prints the number of vowels and consonants.",
    "code": "```fortran\nprogram count_vowels_consonants\n    implicit none\n    character(len=1000) :: text\n    integer :: i, vowel_count, consonant_count\n\n    ! Initialize counts\n    vowel_count = 0\n    consonant_count = 0\n\n    ! Read the text from standard input\n    print *, 'Enter text: '\n    read(*, '(A)') text\n\n    ! Iterate through each character in the text\n    do i = 1, len_trim(text)\n        select case (text(i:i))\n            case ('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')\n                vowel_count = vowel_count + 1\n            case ('b':'z', 'B':'Z')\n                if (text(i:i) /= 'e' .and. text(i:i) /= 'i' .and. text(i:i) /= 'o' .and. text(i:i) /= 'u' &\n                 .and. text(i:i) /= 'E' .and. text(i:i) /= 'I' .and. text(i:i) /= 'O' .and. text(i:i) /= 'U') then\n                    consonant_count = consonant_count + 1\n                end if\n        end select\n    end do\n\n    ! Output the counts\n    print *, 'Number of vowels: ', vowel_count\n    print *, 'Number of consonants: ', consonant_count\nend program count_vowels_consonants\n```"
  },
  {
    "task": "Implement a tool that reads a JSON object from input and prints its keys.",
    "code": "```fortran\nprogram json_keys_printer\n  use iso_c_binding\n  implicit none\n  integer :: ios\n  character(len=1000) :: json_input\n  character(len=100) :: keys(100)\n  integer :: i, key_count\n  \n  ! Read a JSON object from input\n  read(*, '(A)', IOSTAT=ios) json_input\n  if (ios /= 0) then\n     print *, \"Error reading input\"\n     stop\n  end if\n  \n  key_count = 0\n  \n  ! Parse the JSON string for keys (simple simulation)\n  do i = 1, len(json_input)\n     if (json_input(i:i) == '\"') then\n        i = i + 1\n        call extract_key(i, json_input, keys, key_count)\n     end if\n  end do\n  \n  ! Print the keys\n  do i = 1, key_count\n     print *, trim(keys(i))\n  end do\n\ncontains\n\n  subroutine extract_key(i, json_input, keys, key_count)\n    integer, intent(inout) :: i, key_count\n    character(len=*), intent(in) :: json_input\n    character(len=100), intent(inout) :: keys(100)\n    integer :: j\n\n    j = 1\n    do while (json_input(i:i) /= '\"' .and. i <= len(json_input))\n       keys(key_count + 1)(j:j) = json_input(i:i)\n       j = j + 1\n       i = i + 1\n    end do\n    if (json_input(i:i) == '\"') then\n       key_count = key_count + 1\n    end if\n  end subroutine extract_key\n\nend program json_keys_printer\n```"
  },
  {
    "task": "Write a program that reads a CSV file from input and prints each row as a dictionary.",
    "code": "```fortran\nprogram csv_to_dict\n    implicit none\n    integer :: i, ios, n\n    character(len=1024) :: line\n    character(len=50), allocatable :: headers(:), values(:)\n\n    open(unit=10, file='input.csv', status='old', action='read', iostat=ios)\n    if (ios /= 0) then\n        print *, \"Error opening file.\"\n        stop\n    end if\n\n    read(10, '(A)', iostat=ios) line\n    if (ios /= 0) then\n        print *, \"Error reading headers.\"\n        stop\n    end if\n\n    n = count(line == ',') + 1\n    allocate(headers(n))\n    call split_line(line, headers)\n\n    do\n        read(10, '(A)', iostat=ios) line\n        if (ios /= 0) exit\n        allocate(values(n))\n        call split_line(line, values)\n        print *, \"{\"\n        do i = 1, n\n            print *, ' \"', trim(headers(i)), '\": \"', trim(values(i)), '\"'\n            if (i < n) print *, \",\"\n        end do\n        print *, \" }\"\n        deallocate(values)\n    end do\n\n    close(10)\n    deallocate(headers)\ncontains\n    subroutine split_line(line, parts)\n        character(len=*), intent(in) :: line\n        character(len=50), allocatable, intent(out) :: parts(:)\n        integer :: i, start, n\n\n        n = count(line == ',') + 1\n        allocate(parts(n))\n        start = 1\n        do i = 1, n\n            call scan_to_delim(line, start, parts(i))\n        end do\n    end subroutine split_line\n\n    subroutine scan_to_delim(line, start, part)\n        character(len=*), intent(in) :: line\n        integer, intent(inout) :: start\n        character(len=50), intent(out) :: part\n        integer :: end_pos\n\n        end_pos = index(line(start:), ',')\n        if (end_pos == 0) then\n            part = line(start:)\n            start = len(line) + 1\n        else\n            part = line(start:start + end_pos - 2)\n            start = start + end_pos\n        end if\n    end subroutine scan_to_delim\nend program csv_to_dict\n```"
  },
  {
    "task": "Create a script that reads a sentence and prints it with the words in reverse order.",
    "code": "```fortran\nprogram reverse_words\n    implicit none\n    character(len=1000) :: sentence\n    character(len=100), dimension(100) :: words\n    integer :: i, num_words\n\n    print *, 'Enter a sentence:'\n    read(*,'(A)') sentence\n\n    num_words = 0\n    do while (len_trim(sentence) > 0)\n        num_words = num_words + 1\n        read(sentence, '(A)', IOSTAT=i) words(num_words)\n        if (i /= 0) exit\n        sentence = adjustl(trim(sentence(len_trim(words(num_words)) + 1:)))\n    end do\n\n    print *, 'Reversed sentence:'\n    do i = num_words, 1, -1\n        print *, trim(words(i)),\n    end do\nend program reverse_words\n```"
  },
  {
    "task": "Develop a tool that reads a list of numbers and prints their median.",
    "code": "```fortran\nprogram calculate_median\n    implicit none\n    integer :: n, i, j, temp\n    real, allocatable :: numbers(:)\n\n    ! Read the number of elements\n    print *, 'Enter the number of elements:'\n    read(*,*) n\n\n    ! Allocate the array\n    allocate(numbers(n))\n\n    ! Read the numbers\n    print *, 'Enter the numbers:'\n    do i = 1, n\n        read(*,*) numbers(i)\n    end do\n\n    ! Sort the numbers using a simple bubble sort\n    do i = 1, n-1\n        do j = 1, n-i\n            if (numbers(j) > numbers(j+1)) then\n                temp = numbers(j)\n                numbers(j) = numbers(j+1)\n                numbers(j+1) = temp\n            end if\n        end do\n    end do\n\n    ! Calculate and print the median\n    if (mod(n, 2) == 0) then\n        print *, 'Median:', (numbers(n/2) + numbers(n/2 + 1)) / 2.0\n    else\n        print *, 'Median:', numbers((n+1)/2)\n    end if\n\n    ! Deallocate the array\n    deallocate(numbers)\nend program calculate_median\n```"
  },
  {
    "task": "Design a program that reads a sequence of characters and prints the first non-repeated character.",
    "code": "```fortran\nprogram first_non_repeated_character\n    implicit none\n    character(len=:), allocatable :: input\n    character(len=1) :: result\n    integer :: i, j, length\n    logical :: found\n\n    ! Read a sequence of characters\n    read(*, '(A)') input\n    length = len(input)\n    found = .false.\n\n    ! Find the first non-repeated character\n    do i = 1, length\n        found = .true.\n        do j = 1, length\n            if (i /= j .and. input(i:i) == input(j:j)) then\n                found = .false.\n                exit\n            end if\n        end do\n        if (found) then\n            result = input(i:i)\n            exit\n        end if\n    end do\n\n    ! Print the result\n    if (found) then\n        print *, 'First non-repeated character:', result\n    else\n        print *, 'No non-repeated character found.'\n    end if\nend program first_non_repeated_character\n```"
  },
  {
    "task": "Write a script that reads a list of tuples and prints them sorted by the second element.",
    "code": "```fortran\nprogram sort_tuples\n    implicit none\n    integer, parameter :: n = 5\n    integer :: i\n    integer :: second(n)\n    character(len=20) :: first(n)\n    character(len=20) :: temp_first\n    integer :: temp_second\n\n    do i = 1, n\n        read(*,*) first(i), second(i)\n    end do\n\n    call sort_by_second(first, second, n)\n\n    do i = 1, n\n        print *, first(i), second(i)\n    end do\n\ncontains\n\n    subroutine sort_by_second(first, second, n)\n        integer, intent(in) :: n\n        character(len=20), intent(inout) :: first(n)\n        integer, intent(inout) :: second(n)\n        integer :: i, j\n\n        do i = 1, n-1\n            do j = i+1, n\n                if (second(i) > second(j)) then\n                    temp_second = second(i)\n                    second(i) = second(j)\n                    second(j) = temp_second\n\n                    temp_first = first(i)\n                    first(i) = first(j)\n                    first(j) = temp_first\n                end if\n            end do\n        end do\n    end subroutine sort_by_second\n\nend program sort_tuples\n```"
  },
  {
    "task": "Create a program that reads a list of cities and prints them grouped by their starting letter.",
    "code": "```fortran\nprogram group_cities\n    implicit none\n    character(len=100), allocatable :: cities(:)\n    character(len=100) :: city\n    character(len=1) :: current_letter, first_letter\n    integer :: i, n\n\n    ! Read number of cities\n    print *, 'Enter number of cities:'\n    read *, n\n    allocate(cities(n))\n\n    ! Read cities\n    print *, 'Enter list of cities:'\n    do i = 1, n\n        read *, cities(i)\n    end do\n\n    ! Sort cities\n    call sort_cities(cities)\n\n    ! Group and print cities by starting letter\n    first_letter = ''\n    do i = 1, n\n        current_letter = cities(i)(1:1)\n        if (current_letter /= first_letter) then\n            print *, 'Cities starting with ', current_letter, ':'\n            first_letter = current_letter\n        end if\n        print *, '- ', trim(cities(i))\n    end do\n\ncontains\n\n    subroutine sort_cities(arr)\n        character(len=100), intent(inout) :: arr(:)\n        integer :: i, j\n        character(len=100) :: temp\n\n        do i = 1, size(arr) - 1\n            do j = i + 1, size(arr)\n                if (arr(i) > arr(j)) then\n                    temp = arr(i)\n                    arr(i) = arr(j)\n                    arr(j) = temp\n                end if\n            end do\n        end do\n    end subroutine sort_cities\n\nend program group_cities\n```"
  },
  {
    "task": "Build a tool that reads a text and prints the longest word.",
    "code": "```fortran\nprogram LongestWord\n    implicit none\n    character(len=1000) :: text\n    character(len=100) :: word, longest\n    integer :: i, j, maxlen\n\n    ! Read a line of text\n    read(*, '(A)') text\n\n    maxlen = 0\n    longest = \"\"\n    word = \"\"\n    j = 1\n\n    ! Loop through each character in the text\n    do i = 1, len_trim(text)\n        if (text(i:i) == ' ' .or. i == len_trim(text)) then\n            if (i == len_trim(text) .and. text(i:i) /= ' ') then\n                word(j:j) = text(i:i)\n                j = j + 1\n            end if\n            if (j - 1 > maxlen) then\n                maxlen = j - 1\n                longest = word(:maxlen)\n            end if\n            j = 1\n            word = \"\"\n        else\n            word(j:j) = text(i:i)\n            j = j + 1\n        end if\n    end do\n\n    ! Print the longest word\n    print *, trim(longest)\n\nend program LongestWord\n```"
  },
  {
    "task": "Implement a program that reads a string and prints the number of unique characters.",
    "code": "```fortran\nprogram unique_characters\n    implicit none\n    character(len=100) :: input_string\n    integer :: i, j, length, count\n    logical :: is_unique\n\n    print *, \"Enter a string:\"\n    read(*, '(A)') input_string\n    length = len_trim(adjustl(input_string))\n    count = 0\n\n    do i = 1, length\n        is_unique = .true.\n        do j = 1, i - 1\n            if (input_string(i:i) == input_string(j:j)) then\n                is_unique = .false.\n                exit\n            end if\n        end do\n        if (is_unique) count = count + 1\n    end do\n\n    print *, \"Number of unique characters:\", count\n\nend program unique_characters\n```"
  },
  {
    "task": "Write a script that reads two strings and prints the longest common substring.",
    "code": "```fortran\nprogram longest_common_substring\n    implicit none\n    character(len=100) :: str1, str2\n    character(len=100) :: lcs\n    integer :: i, j, k, len1, len2, max_len, start\n\n    write(*,*) 'Enter first string:'\n    read(*,*) str1\n    write(*,*) 'Enter second string:'\n    read(*,*) str2\n\n    len1 = len_trim(str1)\n    len2 = len_trim(str2)\n    max_len = 0\n    start = 0\n\n    do i = 1, len1\n        do j = 1, len2\n            k = 0\n            do while (i + k <= len1 .and. j + k <= len2 .and. str1(i+k:i+k) == str2(j+k:j+k))\n                k = k + 1\n            end do\n            if (k > max_len) then\n                max_len = k\n                start = i\n            end if\n        end do\n    end do\n\n    lcs = str1(start:start+max_len-1)\n    write(*,*) 'Longest common substring: ', lcs\nend program longest_common_substring\n```"
  },
  {
    "task": "Develop a program that reads a chessboard position and prints all possible moves for a knight.",
    "code": "```fortran\nprogram knight_moves\n  implicit none\n  integer :: i, j, x, y\n  character(2) :: position\n  integer, dimension(8, 2) :: moves\n  integer, dimension(:), allocatable :: possible_moves\n\n  moves = reshape([ &\n       2,  1, -2,  1,  2, -1, -2, -1, &\n       1,  2,  1, -2, -1,  2, -1, -2 &\n    ], shape=[8, 2])\n\n  print *, \"Enter knight position (e.g., e4):\"\n  read(*,*) position\n\n  x = ichar(position(1:1)) - ichar('a') + 1\n  read(position(2:2), *) y\n\n  allocate(possible_moves(0))\n  do i = 1, 8\n    if (x + moves(i, 1) >= 1 .and. x + moves(i, 1) <= 8) then\n      if (y + moves(i, 2) >= 1 .and. y + moves(i, 2) <= 8) then\n        allocate(possible_moves(size(possible_moves) + 1))\n        possible_moves(size(possible_moves)) = i\n      end if\n    end if\n  end do\n\n  print *, \"Possible moves for knight at \", trim(position), \":\"\n  do i = 1, size(possible_moves)\n    j = possible_moves(i)\n    print \"(A1,I1)\", char(x + moves(j, 1) + ichar('a') - 1), y + moves(j, 2)\n  end do\nend program knight_moves\n```"
  },
  {
    "task": "Create a tool that reads a list of numbers and prints the mode.",
    "code": "```fortran\nprogram find_mode\n    implicit none\n    integer, allocatable :: numbers(:)\n    integer :: n, i, mode, max_count, current_count, current_number\n\n    print *, 'Enter the number of elements:'\n    read *, n\n    allocate(numbers(n))\n\n    print *, 'Enter the numbers:'\n    do i = 1, n\n        read *, numbers(i)\n    end do\n\n    max_count = 0\n    mode = numbers(1)\n\n    do i = 1, n\n        current_number = numbers(i)\n        current_count = count(numbers == current_number)\n        if (current_count > max_count) then\n            max_count = current_count\n            mode = current_number\n        end if\n    end do\n\n    print *, 'The mode is:', mode\n\n    deallocate(numbers)\nend program find_mode\n```"
  },
  {
    "task": "Design a program that reads a list of file paths and prints the largest file.",
    "code": "```fortran\nprogram largest_file\n    implicit none\n    character(len=256) :: line\n    character(len=256) :: largest_file\n    character(len=256) :: filename\n    integer :: ios\n    integer(kind=8) :: largest_size, file_size\n    logical :: end_of_file\n\n    largest_size = -1\n    largest_file = ''\n    \n    open(unit=10, file='file_paths.txt', status='old', action='read', iostat=ios)\n    if (ios /= 0) stop 'Error opening file_paths.txt'\n\n    do\n        read(10, '(A)', iostat=ios, end=100) line\n        if (ios /= 0) exit\n        call get_file_size(trim(adjustl(line)), file_size, end_of_file)\n        if (end_of_file) then\n            largest_file = trim(adjustl(line))\n            largest_size = file_size\n        else if (file_size > largest_size) then\n            largest_size = file_size\n            largest_file = trim(adjustl(line))\n        end if\n    end do\n\n100 continue\n    close(10)\n\n    if (largest_size > -1) then\n        print *, 'Largest file:', trim(adjustl(largest_file))\n    else\n        print *, 'No valid files found.'\n    end if\n\ncontains\n\n    subroutine get_file_size(filename, size, end_of_file)\n        character(len=*), intent(in) :: filename\n        integer(kind=8), intent(out) :: size\n        logical, intent(out) :: end_of_file\n        integer :: ios\n        inquire(file=filename, size=size, iostat=ios)\n        end_of_file = (ios /= 0)\n    end subroutine get_file_size\n\nend program largest_file\n```"
  },
  {
    "task": "Write a script that reads a list of prices and prints the total cost with tax.",
    "code": "```fortran\nprogram calculate_total_with_tax\n    implicit none\n    real :: tax_rate, price, total_cost, total_with_tax\n    integer :: num_prices, i\n\n    tax_rate = 0.08\n    total_cost = 0.0\n\n    print *, 'Enter number of prices:'\n    read *, num_prices\n\n    do i = 1, num_prices\n        print *, 'Enter price', i, ':'\n        read *, price\n        total_cost = total_cost + price\n    end do\n\n    total_with_tax = total_cost * (1.0 + tax_rate)\n    print *, 'Total cost with tax:', total_with_tax\n\nend program calculate_total_with_tax\n```"
  },
  {
    "task": "Build a program that reads a list of temperatures and prints them in Fahrenheit.",
    "code": "```fortran\nprogram temperature_conversion\n  implicit none\n  integer :: n, i\n  real :: celsius, fahrenheit\n\n  print *, 'Enter the number of temperatures:'\n  read *, n\n\n  do i = 1, n\n     print *, 'Enter temperature in Celsius:'\n     read *, celsius\n     fahrenheit = celsius * 9.0 / 5.0 + 32.0\n     print *, 'Temperature in Fahrenheit:', fahrenheit\n  end do\n\nend program temperature_conversion\n```"
  },
  {
    "task": "Implement a tool that reads a list of book titles and prints them sorted by length.",
    "code": "```fortran\nprogram SortBookTitles\n    implicit none\n    character(len=256), allocatable :: titles(:)\n    character(len=256) :: tempTitle\n    integer :: n, i, j\n\n    ! Read the number of titles\n    print *, 'Enter number of book titles:'\n    read *, n\n\n    ! Allocate array for titles\n    allocate(titles(n))\n\n    ! Read titles\n    print *, 'Enter the book titles:'\n    do i = 1, n\n        read *, titles(i)\n    end do\n\n    ! Sort titles by length\n    do i = 1, n-1\n        do j = i+1, n\n            if (len_trim(titles(i)) > len_trim(titles(j))) then\n                tempTitle = titles(i)\n                titles(i) = titles(j)\n                titles(j) = tempTitle\n            end if\n        end do\n    end do\n\n    ! Print sorted titles\n    print *, 'Sorted book titles by length:'\n    do i = 1, n\n        print *, trim(titles(i))\n    end do\n\n    ! Deallocate the array\n    deallocate(titles)\nend program SortBookTitles\n```"
  },
  {
    "task": "Write a program that reads a directory path and prints all file names.",
    "code": "```fortran\nprogram list_files\n    implicit none\n    integer :: i, ierr\n    character(len=256) :: path\n    character(len=256) :: filenames(100)\n    integer :: num_files\n\n    print *, 'Enter directory path:'\n    read(*, '(A)') path\n\n    inquire(directory=path, file=filenames, number=num_files, iostat=ierr)\n    if (ierr /= 0) then\n        print *, 'Error reading directory.'\n        stop\n    end if\n\n    print *, 'Files in directory:'\n    do i = 1, num_files\n        print *, trim(filenames(i))\n    end do\nend program list_files\n```"
  },
  {
    "task": "Create a script that reads a list of URLs and prints those with a secure connection.",
    "code": "```fortran\nprogram SecureURLs\n    implicit none\n    integer, parameter :: max_urls = 100, max_length = 200\n    character(len=max_length) :: url\n    character(len=max_length), dimension(max_urls) :: urls\n    integer :: num_urls, i\n\n    num_urls = 0\n    print *, \"Enter URLs (one per line), end with an empty line:\"\n    do\n        read(*, '(A)') url\n        if (len_trim(url) == 0) exit\n        num_urls = num_urls + 1\n        urls(num_urls) = url\n    end do\n\n    print *, \"Secure URLs:\"\n    do i = 1, num_urls\n        if (len_trim(urls(i)) >= 5 .and. urls(i)(:5) == 'https') then\n            print *, trim(urls(i))\n        end if\n    end do\nend program SecureURLs\n```"
  },
  {
    "task": "Develop a tool that reads a sequence of numbers and prints if it is strictly increasing.",
    "code": "```fortran\nprogram check_increasing\n  implicit none\n  integer :: n, i\n  real, allocatable :: numbers(:)\n  logical :: is_increasing\n\n  ! Read the number of elements\n  print *, \"Enter the number of elements:\"\n  read *, n\n\n  ! Allocate array to hold numbers\n  allocate(numbers(n))\n\n  ! Read the sequence of numbers\n  print *, \"Enter the numbers:\"\n  do i = 1, n\n     read *, numbers(i)\n  end do\n\n  ! Check if the sequence is strictly increasing\n  is_increasing = .true.\n  do i = 1, n - 1\n     if (numbers(i) >= numbers(i + 1)) then\n        is_increasing = .false.\n        exit\n     end if\n  end do\n\n  ! Print the result\n  if (is_increasing) then\n     print *, \"The sequence is strictly increasing.\"\n  else\n     print *, \"The sequence is not strictly increasing.\"\n  end if\n\n  ! Deallocate array\n  deallocate(numbers)\n\nend program check_increasing\n```"
  },
  {
    "task": "Design a program that reads a list of products and prints them grouped by category.",
    "code": "```fortran\nprogram product_grouping\n    implicit none\n    integer, parameter :: max_products = 100\n    character(len=50) :: products(max_products)\n    character(len=50) :: categories(max_products)\n    integer :: i, n\n\n    ! Read number of products\n    print *, \"Enter number of products:\"\n    read(*,*) n\n\n    if (n > max_products) then\n        print *, \"Exceeds maximum number of products!\"\n        stop\n    end if\n\n    ! Read product names and categories\n    do i = 1, n\n        print *, \"Enter product name and category (separated by space):\"\n        read(*,*) products(i), categories(i)\n    end do\n\n    ! Print products grouped by category\n    print *, \"Products grouped by category:\"\n    do i = 1, n\n        if (categories(i) /= '') then\n            print *, \"Category:\", trim(categories(i))\n            print *, \"Products:\"\n            call print_category_products(categories(i), products, categories, n)\n            print *, \"\"\n            call remove_category(categories, categories(i), n)\n        end if\n    end do\nend program product_grouping\n\nsubroutine print_category_products(category, products, categories, n)\n    character(len=50), intent(in) :: category\n    character(len=50), intent(in) :: products(n), categories(n)\n    integer, intent(in) :: n\n    integer :: i\n\n    do i = 1, n\n        if (categories(i) == category) then\n            print *, ' - ', trim(products(i))\n        end if\n    end do\nend subroutine print_category_products\n\nsubroutine remove_category(categories, category, n)\n    character(len=50), intent(inout) :: categories(n)\n    character(len=50), intent(in) :: category\n    integer, intent(in) :: n\n    integer :: i\n\n    do i = 1, n\n        if (categories(i) == category) then\n            categories(i) = ''\n        end if\n    end do\nend subroutine remove_category\n```"
  },
  {
    "task": "Write a script that reads a sentence and prints it with alternating word capitalization.",
    "code": "```fortran\nprogram alternate_capitalization\n    implicit none\n    character(len=500) :: sentence\n    character(len=500) :: output\n    integer :: i, n, word_count\n    character(len=1) :: current_char\n\n    print *, 'Enter a sentence:'\n    read(*, '(A)') sentence\n\n    word_count = 0\n    n = len_trim(sentence)\n    output = ''\n\n    do i = 1, n\n        current_char = sentence(i:i)\n\n        if (current_char == ' ') then\n            output(i:i) = current_char\n        else\n            if (word_count == 0 .or. sentence(i-1:i-1) == ' ') then\n                word_count = word_count + 1\n            end if\n\n            if (mod(word_count, 2) == 1) then\n                output(i:i) = adjustl(current_char)\n            else\n                output(i:i) = adjustl(lowercase(current_char))\n            end if\n        end if\n    end do\n\n    print *, trim(output)\nend program alternate_capitalization\n```"
  },
  {
    "task": "Create a program that reads a list of grades and prints the highest and lowest grade.",
    "code": "```fortran\nprogram GradeAnalysis\n  implicit none\n  integer, allocatable :: grades(:)\n  integer :: n, i, highest, lowest\n\n  print *, 'Enter the number of grades:'\n  read *, n\n  allocate(grades(n))\n\n  print *, 'Enter the grades:'\n  do i = 1, n\n     read *, grades(i)\n  end do\n\n  highest = grades(1)\n  lowest = grades(1)\n\n  do i = 2, n\n     if (grades(i) > highest) then\n        highest = grades(i)\n     end if\n     if (grades(i) < lowest) then\n        lowest = grades(i)\n     end if\n  end do\n\n  print *, 'The highest grade is:', highest\n  print *, 'The lowest grade is:', lowest\n\n  deallocate(grades)\nend program GradeAnalysis\n```"
  },
  {
    "task": "Build a tool that reads a text and prints the number of sentences.",
    "code": "```fortran\nprogram CountSentences\n    implicit none\n    character(len=1000) :: text\n    integer :: sentence_count, i\n\n    ! Read the input text\n    print *, \"Enter the text:\"\n    read(*,'(A)') text\n\n    ! Initialize the sentence count\n    sentence_count = 0\n\n    ! Count sentences by looking for '.', '!', '?'\n    do i = 1, len_trim(text)\n        if (text(i:i) == '.' .or. text(i:i) == '!' .or. text(i:i) == '?') then\n            sentence_count = sentence_count + 1\n        end if\n    end do\n\n    ! Print the number of sentences\n    print *, \"Number of sentences:\", sentence_count\nend program CountSentences\n```"
  },
  {
    "task": "Implement a program that reads a list of integers and prints the sum of all odd numbers.",
    "code": "```fortran\nprogram sum_of_odds\n    implicit none\n    integer, allocatable :: numbers(:)\n    integer :: n, i, sum\n\n    print *, \"Enter the number of integers:\"\n    read(*,*) n\n    allocate(numbers(n))\n\n    print *, \"Enter the integers:\"\n    read(*,*) numbers\n\n    sum = 0\n    do i = 1, n\n        if (mod(numbers(i), 2) /= 0) then\n            sum = sum + numbers(i)\n        end if\n    end do\n\n    print *, \"Sum of odd numbers:\", sum\n\n    deallocate(numbers)\nend program sum_of_odds\n```"
  },
  {
    "task": "Write a script that reads a text and prints the shortest sentence.",
    "code": "```fortran\nprogram shortest_sentence\n    implicit none\n    character(len=1000) :: text\n    character(len=1000), allocatable :: sentences(:)\n    character(len=1000) :: shortest_sentence\n    integer :: i, num_sentences, min_length\n    \n    print *, 'Enter the text:'\n    read *, text\n\n    call split_into_sentences(text, sentences, num_sentences)\n    \n    if (num_sentences > 0) then\n        shortest_sentence = sentences(1)\n        min_length = len(trim(shortest_sentence))\n        \n        do i = 2, num_sentences\n            if (len(trim(sentences(i))) < min_length) then\n                shortest_sentence = sentences(i)\n                min_length = len(trim(sentences(i)))\n            end if\n        end do\n        \n        print *, 'Shortest sentence: ', trim(shortest_sentence)\n    else\n        print *, 'No sentences found.'\n    end if\nend program shortest_sentence\n\nsubroutine split_into_sentences(text, sentences, num_sentences)\n    implicit none\n    character(len=*), intent(in) :: text\n    character(len=1000), allocatable, intent(out) :: sentences(:)\n    integer, intent(out) :: num_sentences\n    character(len=1) :: ch\n    integer :: i, start, end_pos\n    \n    num_sentences = 0\n    allocate(sentences(100))\n    start = 1\n    \n    do i = 1, len(text)\n        ch = text(i:i)\n        if (ch == '.' .or. ch == '?' .or. ch == '!') then\n            end_pos = i\n            num_sentences = num_sentences + 1\n            sentences(num_sentences) = text(start:end_pos)\n            start = i + 1\n        end if\n    end do\n    \n    if (num_sentences == 0) then\n        deallocate(sentences)\n    else\n        call trim_array(sentences, num_sentences)\n    end if\nend subroutine split_into_sentences\n\nsubroutine trim_array(sentences, size)\n    implicit none\n    character(len=1000), allocatable, intent(inout) :: sentences(:)\n    integer, intent(in) :: size\n    integer :: i\n    \n    do i = 1, size\n        sentences(i) = adjustl(trim(sentences(i)))\n    end do\nend subroutine trim_array\n```"
  },
  {
    "task": "Develop a program that reads a list of dictionaries and prints them sorted by a specific key.",
    "code": "```fortran\nprogram sort_dictionaries\n    implicit none\n    integer, parameter :: max_dicts = 100, max_length = 256\n    character(len=max_length) :: keys(max_dicts), values(max_dicts)\n    integer :: n, i, j\n    character(len=max_length) :: temp_key, temp_value\n\n    ! Read number of dictionaries\n    read(*,*) n\n\n    ! Read dictionaries\n    do i = 1, n\n        read(*,*) keys(i), values(i)\n    end do\n\n    ! Sort dictionaries by keys using simple bubble sort\n    do i = 1, n-1\n        do j = 1, n-i\n            if (keys(j) > keys(j+1)) then\n                temp_key = keys(j)\n                keys(j) = keys(j+1)\n                keys(j+1) = temp_key\n\n                temp_value = values(j)\n                values(j) = values(j+1)\n                values(j+1) = temp_value\n            endif\n        end do\n    end do\n\n    ! Print sorted dictionaries\n    do i = 1, n\n        print *, keys(i), values(i)\n    end do\n\nend program sort_dictionaries\n```"
  },
  {
    "task": "Create a tool that reads a sequence of strings and prints the common prefix.",
    "code": "```fortran\nprogram common_prefix\n    implicit none\n    character(len=100), dimension(:), allocatable :: strings\n    character(len=100) :: prefix\n    integer :: n, i, j\n    logical :: match\n\n    ! Read number of strings\n    read(*,*) n\n    allocate(strings(n))\n\n    ! Read strings\n    do i = 1, n\n        read(*,*) strings(i)\n    end do\n\n    ! Determine the common prefix\n    prefix = strings(1)\n    do j = 1, len(prefix)\n        match = .true.\n        do i = 2, n\n            if (j > len_trim(strings(i)) .or. strings(i)(j:j) /= prefix(j:j)) then\n                match = .false.\n                exit\n            end if\n        end do\n        if (.not. match) exit\n    end do\n\n    ! Print the common prefix\n    print *, prefix(:j-1)\nend program common_prefix\n```"
  },
  {
    "task": "Design a program that reads a number and prints all of its divisors.",
    "code": "```fortran\nprogram divisors\n    implicit none\n    integer :: num, i\n\n    print *, 'Enter a number:'\n    read *, num\n\n    print *, 'Divisors are:'\n    do i = 1, num\n        if (mod(num, i) == 0) then\n            print *, i\n        end if\n    end do\nend program divisors\n```"
  },
  {
    "task": "Write a script that reads a text and prints each word with its length.",
    "code": "```fortran\nprogram WordLength\n    implicit none\n    character(len=100) :: line\n    character(len=20), dimension(:), allocatable :: words\n    integer :: i, num_words\n\n    print *, \"Enter text:\"\n    read(*,'(A)') line\n\n    call split(line, words, num_words)\n\n    do i = 1, num_words\n        print *, trim(words(i)), len_trim(words(i))\n    end do\n\ncontains\n\n    subroutine split(input_line, word_list, n_words)\n        character(len=*), intent(in) :: input_line\n        character(len=20), dimension(:), allocatable, intent(out) :: word_list\n        integer, intent(out) :: n_words\n        integer :: pos, start, endpos\n\n        allocate(word_list(100))\n        n_words = 0\n        pos = 1\n\n        do\n            call scan_word(input_line, pos, start, endpos)\n            if (start == 0) exit\n            n_words = n_words + 1\n            word_list(n_words) = input_line(start:endpos)\n            pos = endpos + 1\n        end do\n\n        if (n_words > 0) then\n            call move_alloc(word_list, word_list(1:n_words))\n        end if\n    end subroutine split\n\n    subroutine scan_word(input_line, start_pos, start_word, end_word)\n        character(len=*), intent(in) :: input_line\n        integer, intent(inout) :: start_pos\n        integer, intent(out) :: start_word, end_word\n        integer :: i, len_line\n\n        len_line = len_trim(input_line)\n        start_word = 0\n        end_word = 0\n\n        do i = start_pos, len_line\n            if (input_line(i:i) /= ' ') then\n                start_word = i\n                exit\n            end if\n        end do\n\n        if (start_word == 0) return\n\n        do i = start_word, len_line\n            if (input_line(i:i) == ' ') then\n                end_word = i - 1\n                exit\n            end if\n        end do\n\n        if (end_word == 0) end_word = len_line\n    end subroutine scan_word\n\nend program WordLength\n```"
  },
  {
    "task": "Build a program that reads a list of colors and prints them in a rainbow order.",
    "code": "```fortran\nprogram rainbow_colors\n    implicit none\n    character(len=20), dimension(:), allocatable :: colors\n    integer :: n, i\n\n    print *, \"Enter the number of colors:\"\n    read *, n\n\n    allocate(colors(n))\n    print *, \"Enter the colors:\"\n\n    do i = 1, n\n        read *, colors(i)\n    end do\n\n    call sort_colors(colors, n)\n\n    print *, \"Colors in rainbow order:\"\n    do i = 1, n\n        print *, colors(i)\n    end do\n\ncontains\n\n    subroutine sort_colors(colors, n)\n        character(len=20), dimension(n) :: colors\n        integer :: n, i, j\n        character(len=20) :: temp\n        character(len=20), dimension(7) :: rainbow_order\n\n        rainbow_order = (/ \"red\", \"orange\", \"yellow\", \"green\", \"blue\", \"indigo\", \"violet\" /)\n\n        do i = 1, n-1\n            do j = i+1, n\n                if (index(rainbow_order, trim(colors(j))) < index(rainbow_order, trim(colors(i)))) then\n                    temp = colors(i)\n                    colors(i) = colors(j)\n                    colors(j) = temp\n                end if\n            end do\n        end do\n    end subroutine sort_colors\n\nend program rainbow_colors\n```"
  },
  {
    "task": "Implement a tool that reads a list of names and prints them with their initials.",
    "code": "```fortran\nprogram print_initials\n    implicit none\n    character(len=50) :: name\n    character(len=1) :: first_initial, last_initial\n    integer :: i, length_name\n\n    print *, 'Enter names (type \"exit\" to stop):'\n\n    do\n        read(*, '(A)') name\n        if (trim(adjustl(name)) == 'exit') exit\n\n        length_name = len_trim(name)\n        first_initial = name(1:1)\n\n        do i = length_name, 1, -1\n            if (name(i:i) == ' ') then\n                last_initial = name(i+1:i+1)\n                exit\n            end if\n        end do\n\n        print *, 'Name:', trim(name), 'Initials:', first_initial // '.' // last_initial // '.'\n    end do\nend program print_initials\n```"
  },
  {
    "task": "Write a program that reads a series of coordinates and prints the center point.",
    "code": "```fortran\nprogram center_point\n    implicit none\n    integer :: n, i\n    real :: x_sum, y_sum, z_sum, x, y, z\n\n    x_sum = 0.0\n    y_sum = 0.0\n    z_sum = 0.0\n\n    print *, \"Enter the number of coordinates:\"\n    read *, n\n\n    do i = 1, n\n        print *, \"Enter coordinate \", i, \" (x y z):\"\n        read *, x, y, z\n        x_sum = x_sum + x\n        y_sum = y_sum + y\n        z_sum = z_sum + z\n    end do\n\n    if (n > 0) then\n        print *, \"Center Point: (\", x_sum / real(n), \", \", y_sum / real(n), \", \", z_sum / real(n), \")\"\n    else\n        print *, \"No coordinates entered.\"\n    end if\nend program center_point\n```"
  },
  {
    "task": "Create a script that reads a sentence and prints it with each vowel replaced by its uppercase form.",
    "code": "```fortran\nprogram replace_vowels\n    implicit none\n    character(len=100) :: sentence\n    integer :: i, len_sentence\n\n    ! Read a sentence from the user\n    print *, 'Enter a sentence:'\n    read *, sentence\n\n    len_sentence = len_trim(sentence)\n\n    ! Replace vowels with uppercase\n    do i = 1, len_sentence\n        select case (sentence(i:i))\n        case ('a')\n            sentence(i:i) = 'A'\n        case ('e')\n            sentence(i:i) = 'E'\n        case ('i')\n            sentence(i:i) = 'I'\n        case ('o')\n            sentence(i:i) = 'O'\n        case ('u')\n            sentence(i:i) = 'U'\n        case ('A','E','I','O','U')\n            cycle\n        end select\n    end do\n\n    ! Print the modified sentence\n    print *, 'Modified sentence: ', trim(sentence)\nend program replace_vowels\n```"
  },
  {
    "task": "Develop a tool that reads a mathematical expression and evaluates its result.",
    "code": "```fortran\nprogram evaluate_expression\n  implicit none\n  character(len=100) :: expression\n  real :: result\n  logical :: valid\n\n  print *, 'Enter a mathematical expression to evaluate:'\n  read(*, '(A)') expression\n\n  call evaluate(expression, result, valid)\n\n  if (valid) then\n    print *, 'The result of the expression is:', result\n  else\n    print *, 'Invalid expression.'\n  end if\ncontains\n\n  subroutine evaluate(expr, res, is_valid)\n    character(len=*), intent(in) :: expr\n    real, intent(out) :: res\n    logical, intent(out) :: is_valid\n    integer :: status\n\n    ! Using an internal command to evaluate the expression; adjust if needed\n    call execute_command_line('echo ' // trim(expr) // ' | bc -l', &\n                              wait=.true., exitstat=status)\n\n    if (status == 0) then\n      read(unit=5, fmt=*, iostat=status) res\n      is_valid = (status == 0)\n    else\n      is_valid = .false.\n    end if\n  end subroutine evaluate\n\nend program evaluate_expression\n```"
  },
  {
    "task": "Design a program that reads a text and prints the first three words.",
    "code": "```fortran\nprogram ReadAndPrintWords\n    implicit none\n    character(len=100) :: line\n    character(len=20) :: word1, word2, word3\n    integer :: ios\n\n    ! Read a line of text\n    read(*, '(A)', IOSTAT=ios) line\n    if (ios /= 0) stop \"Error reading input.\"\n\n    ! Read the first three words\n    read(line, '(A20, A20, A20)', IOSTAT=ios) word1, word2, word3\n\n    ! Print the first three words\n    print *, trim(word1), trim(word2), trim(word3)\nend program ReadAndPrintWords\n```"
  },
  {
    "task": "Write a script that reads a list of numbers and prints them without duplicates.",
    "code": "```fortran\nprogram unique_numbers\n    implicit none\n    integer, allocatable :: numbers(:)\n    integer :: n, i, j, num\n    logical :: is_unique\n\n    ! Read the number of elements\n    read(*,*) n\n    allocate(numbers(n))\n    \n    ! Read the numbers into the array\n    do i = 1, n\n        read(*,*) numbers(i)\n    end do\n\n    ! Print unique numbers\n    do i = 1, n\n        is_unique = .true.\n        do j = 1, i-1\n            if (numbers(i) == numbers(j)) then\n                is_unique = .false.\n                exit\n            end if\n        end do\n        if (is_unique) then\n            print *, numbers(i)\n        end if\n    end do\n\n    deallocate(numbers)\nend program unique_numbers\n```"
  },
  {
    "task": "Create a program that reads a string and prints it with spaces between each character.",
    "code": "```fortran\nprogram spaced_string\n    implicit none\n    character(len=100) :: inputString\n    integer :: i, lenString\n\n    ! Read the input string\n    print *, 'Enter a string:'\n    read(*, '(A)') inputString\n\n    ! Determine the length of the string\n    lenString = len_trim(inputString)\n\n    ! Print each character with a space between\n    do i = 1, lenString\n        if (i < lenString) then\n            write(*, '(A, 1X)', advance='no') inputString(i:i)\n        else\n            write(*, '(A)') inputString(i:i)\n        end if\n    end do\n\nend program spaced_string\n```"
  },
  {
    "task": "Build a tool that reads a list of events with dates and prints them by chronological order.",
    "code": "```fortran\nprogram sort_events\n    implicit none\n    integer, parameter :: max_events = 100\n    character(len=100) :: events(max_events)\n    character(len=10) :: dates(max_events)\n    integer :: num_events, i, j\n    character(len=100) :: temp_event\n    character(len=10) :: temp_date\n\n    ! Read number of events\n    print *, \"Enter the number of events:\"\n    read *, num_events\n\n    ! Read events and dates\n    do i = 1, num_events\n        print *, \"Enter event \", i, \" description:\"\n        read *, events(i)\n        print *, \"Enter event \", i, \" date (YYYY-MM-DD):\"\n        read *, dates(i)\n    end do\n\n    ! Sort events by date\n    do i = 1, num_events - 1\n        do j = i + 1, num_events\n            if (dates(i) > dates(j)) then\n                temp_date = dates(i)\n                dates(i) = dates(j)\n                dates(j) = temp_date\n                temp_event = events(i)\n                events(i) = events(j)\n                events(j) = temp_event\n            end if\n        end do\n    end do\n\n    ! Print sorted events\n    print *, \"Events by chronological order:\"\n    do i = 1, num_events\n        print *, dates(i), events(i)\n    end do\nend program sort_events\n```"
  },
  {
    "task": "Implement a program that reads a list of fractions and prints their sum as a reduced fraction.",
    "code": "```fortran\nprogram sum_fractions\n    implicit none\n    integer, parameter :: dp = kind(1.0d0)\n    integer :: num, den, gcd, i, n\n    integer, allocatable :: numerators(:), denominators(:)\n    integer :: total_num, total_den\n\n    print *, \"Enter the number of fractions:\"\n    read(*, *) n\n    allocate(numerators(n))\n    allocate(denominators(n))\n\n    print *, \"Enter the numerators and denominators:\"\n    do i = 1, n\n        read(*, *) numerators(i), denominators(i)\n    end do\n\n    total_num = 0\n    total_den = 1\n\n    do i = 1, n\n        total_num = total_num * denominators(i) + numerators(i) * total_den\n        total_den = total_den * denominators(i)\n    end do\n\n    call compute_gcd(total_num, total_den, gcd)\n    total_num = total_num / gcd\n    total_den = total_den / gcd\n\n    print *, \"Sum of fractions as a reduced fraction:\"\n    print *, total_num, \"/\", total_den\n\n    contains\n\n    recursive subroutine compute_gcd(a, b, gcd)\n        integer, intent(in) :: a, b\n        integer, intent(out) :: gcd\n        if (b == 0) then\n            gcd = abs(a)\n        else\n            call compute_gcd(b, mod(a, b), gcd)\n        end if\n    end subroutine compute_gcd\nend program sum_fractions\n```"
  },
  {
    "task": "Write a script that reads a text and prints it with each consonant doubled.",
    "code": "```fortran\nprogram DoubleConsonants\n    implicit none\n    character(len=1000) :: inputText\n    character(len=1000) :: outputText\n    integer :: i, j, length\n\n    print *, 'Enter text:'\n    read(*, '(A)') inputText\n\n    length = len_trim(inputText)\n    j = 1\n\n    do i = 1, length\n        select case (inputText(i:i))\n        case ('b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z', &\n              'B', 'C', 'D', 'F', 'G', 'H', 'J', 'K', 'L', 'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'V', 'W', 'X', 'Y', 'Z')\n            outputText(j:j+1) = inputText(i:i)//inputText(i:i)\n            j = j + 2\n        case default\n            outputText(j:j) = inputText(i:i)\n            j = j + 1\n        end select\n    end do\n\n    outputText(j:) = ''\n\n    print *, 'Output text:'\n    print *, trim(outputText)\nend program DoubleConsonants\n```"
  },
  {
    "task": "Develop a program that reads a number and prints its representation in Roman numerals.",
    "code": "```fortran\nprogram RomanNumerals\n    implicit none\n    integer :: num\n    character(len=100) :: roman\n\n    print *, \"Enter a number:\"\n    read *, num\n\n    call int_to_roman(num, roman)\n    print *, \"Roman numeral:\", trim(roman)\n\ncontains\n\n    subroutine int_to_roman(n, roman)\n        integer, intent(in) :: n\n        character(len=100), intent(out) :: roman\n        integer :: num\n        character(len=10), dimension(13) :: roman_symbols = &\n            ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']\n        integer, dimension(13) :: values = [1000, 900, 500, 400, 100, 90, &\n                                             50, 40, 10, 9, 5, 4, 1]\n        integer :: i\n\n        roman = \"\"\n        num = n\n\n        do i = 1, 13\n            do while (num >= values(i))\n                roman = trim(roman) // roman_symbols(i)\n                num = num - values(i)\n            end do\n        end do\n    end subroutine int_to_roman\n\nend program RomanNumerals\n```"
  },
  {
    "task": "Create a tool that reads a list of words and prints them with each letter in reverse order.",
    "code": "```fortran\nprogram ReverseLetters\n    implicit none\n    character(len=100) :: word\n    integer :: i, length\n\n    print *, 'Enter words (end with a blank line):'\n    do\n        read(*, '(A)') word\n        if (len_trim(word) == 0) exit\n        length = len_trim(word)\n        call reverse_and_print(word, length)\n    end do\ncontains\n    subroutine reverse_and_print(str, len)\n        character(len=*), intent(in) :: str\n        integer, intent(in) :: len\n        integer :: j\n        character(len=len) :: reversed\n        do j = 1, len\n            reversed(j:j) = str(len-j+1:len-j+1)\n        end do\n        print *, reversed\n    end subroutine reverse_and_print\nend program ReverseLetters\n```"
  },
  {
    "task": "Design a program that reads a set of points and prints the one closest to the origin.",
    "code": "```fortran\nprogram closest_point\n    implicit none\n    integer :: n, i, closest_index\n    real :: x, y, distance, min_distance\n\n    ! Read the number of points\n    print *, \"Enter the number of points:\"\n    read *, n\n\n    ! Initialize minimum distance to a large value\n    min_distance = 1.0e30\n\n    ! Loop over each point\n    do i = 1, n\n        ! Read x and y coordinates\n        print *, \"Enter the coordinates of point \", i, \":\"\n        read *, x, y\n\n        ! Calculate the distance from the origin\n        distance = sqrt(x*x + y*y)\n\n        ! Find the closest point\n        if (distance < min_distance) then\n            min_distance = distance\n            closest_index = i\n        end if\n    end do\n\n    ! Print the index of the closest point\n    print *, \"The closest point is point number \", closest_index\n\nend program closest_point\n```"
  },
  {
    "task": "Write a script that reads a text and prints the frequency of each word.",
    "code": "```fortran\nprogram word_frequency\n    implicit none\n    character(len=1000) :: text\n    character(len=50), dimension(:), allocatable :: words\n    character(len=50) :: word\n    integer :: i, j, n, word_count\n    integer, allocatable :: frequencies(:)\n    logical :: found\n\n    print *, \"Enter text: \"\n    read(*, '(A)') text\n\n    call split_text(text, words, n)\n\n    allocate(frequencies(n))\n    frequencies = 0\n\n    do i = 1, n\n        found = .false.\n        do j = 1, word_count\n            if (trim(words(i)) == trim(words(j))) then\n                frequencies(j) = frequencies(j) + 1\n                found = .true.\n                exit\n            end if\n        end do\n\n        if (.not. found) then\n            word_count = word_count + 1\n            words(word_count) = trim(words(i))\n            frequencies(word_count) = 1\n        end if\n    end do\n\n    print *, \"Word Frequencies:\"\n    do i = 1, word_count\n        print *, trim(words(i)), frequencies(i)\n    end do\n\ncontains\n\n    subroutine split_text(text, words, n)\n        character(len=*), intent(in) :: text\n        character(len=50), dimension(:), allocatable, intent(out) :: words\n        integer, intent(out) :: n\n        character(len=50) :: temp_word\n        integer :: i, length\n\n        allocate(words(1000))\n        temp_word = ''\n        n = 0\n        length = len_trim(text)\n\n        do i = 1, length\n            if (text(i:i) /= ' ') then\n                temp_word = trim(adjustl(temp_word)) // text(i:i)\n            else\n                if (len_trim(temp_word) > 0) then\n                    n = n + 1\n                    words(n) = trim(temp_word)\n                    temp_word = ''\n                end if\n            end if\n        end do\n\n        if (len_trim(temp_word) > 0) then\n            n = n + 1\n            words(n) = trim(temp_word)\n        end if\n\n        if (n > 0) then\n            call move_alloc(words, words(1:n))\n        end if\n    end subroutine split_text\n\nend program word_frequency\n```"
  },
  {
    "task": "Build a program that reads a list of integers and prints the second smallest.",
    "code": "```fortran\nprogram second_smallest\n    implicit none\n    integer, allocatable :: numbers(:)\n    integer :: n, i, min1, min2, temp\n\n    ! Read number of integers\n    print *, 'Enter the number of integers:'\n    read *, n\n    allocate(numbers(n))\n\n    ! Read integers\n    print *, 'Enter the integers:'\n    do i = 1, n\n        read *, numbers(i)\n    end do\n\n    ! Initialize min1 and min2\n    if (numbers(1) < numbers(2)) then\n        min1 = numbers(1)\n        min2 = numbers(2)\n    else\n        min1 = numbers(2)\n        min2 = numbers(1)\n    end if\n\n    ! Find second smallest\n    do i = 3, n\n        if (numbers(i) < min1) then\n            min2 = min1\n            min1 = numbers(i)\n        else if (numbers(i) < min2) then\n            min2 = numbers(i)\n        end if\n    end do\n\n    ! Output the second smallest\n    print *, 'The second smallest integer is:', min2\n\n    ! Deallocate array\n    deallocate(numbers)\nend program second_smallest\n```"
  },
  {
    "task": "Implement a tool that reads a string and prints all its substrings.",
    "code": "```fortran\nprogram substrings\n    implicit none\n    character(len=100) :: inputString\n    integer :: i, j, length\n\n    print *, 'Enter a string:'\n    read(*, '(A)') inputString\n\n    length = len_trim(inputString)\n\n    do i = 1, length\n        do j = i, length\n            print '(A)', inputString(i:j)\n        end do\n    end do\nend program substrings\n```"
  },
  {
    "task": "Write a program that reads a number and generates a random number up to that number.",
    "code": "```fortran\nprogram RandomNumberGenerator\n    implicit none\n    integer :: userInput\n    real :: randomNumber\n\n    print *, 'Enter a positive integer:'\n    read *, userInput\n\n    call random_seed()\n    call random_number(randomNumber)\n\n    print *, 'Random number up to', userInput, ':', int(randomNumber * userInput)\nend program RandomNumberGenerator\n```"
  },
  {
    "task": "Create a script that reads a sentence and prints it with each word reversed.",
    "code": "```fortran\nprogram reverse_words\n    implicit none\n    character(len=100) :: sentence\n    character(len=100) :: reversed_sentence\n    character(len=20)  :: word\n    integer :: i, j, k, len_sentence, len_word\n\n    ! Read a sentence from standard input\n    print *, 'Enter a sentence:'\n    read(*, '(A)') sentence\n\n    len_sentence = len_trim(sentence)\n    reversed_sentence = ''\n    i = 1\n\n    ! Process each word in the sentence\n    do while (i <= len_sentence)\n        ! Find the next word\n        len_word = 0\n        do while (i <= len_sentence .and. sentence(i:i) /= ' ')\n            len_word = len_word + 1\n            word(len_word:len_word) = sentence(i:i)\n            i = i + 1\n        end do\n\n        ! Reverse the current word\n        do j = len_word, 1, -1\n            k = len(word) - len_trim(reversed_sentence) + j - len_word\n            reversed_sentence(k:k) = word(j:j)\n        end do\n\n        ! Add a space after the word if not at the end of the sentence\n        if (i <= len_sentence) then\n            reversed_sentence(len_trim(reversed_sentence) + 1:len_trim(reversed_sentence) + 1) = ' '\n            i = i + 1\n        end if\n    end do\n\n    ! Print the reversed sentence\n    print *, trim(reversed_sentence)\nend program reverse_words\n```"
  },
  {
    "task": "Develop a tool that reads a text and prints it with each sentence on a new line.",
    "code": "```fortran\nprogram sentence_splitter\n    implicit none\n    character(len=1000) :: input_text\n    character(len=1) :: char\n    integer :: i, len_text\n\n    print *, \"Enter the text: \"\n    read(*,'(A)') input_text\n\n    len_text = len_trim(input_text)\n    do i = 1, len_text\n        char = input_text(i:i)\n        write(*,'(A)', advance='no') char\n        if (char == '.' .or. char == '?' .or. char == '!') then\n            write(*,'(A)') ''\n        end if\n    end do\nend program sentence_splitter\n```"
  },
  {
    "task": "Design a program that reads a list of numbers and prints the product of all negative numbers.",
    "code": "```fortran\nprogram product_of_negatives\n  implicit none\n  integer :: i, n\n  real :: number, product\n\n  product = 1.0\n  print *, \"Enter the number of elements:\"\n  read *, n\n  print *, \"Enter the numbers:\"\n\n  do i = 1, n\n    read *, number\n    if (number < 0) then\n      product = product * number\n    end if\n  end do\n\n  print *, \"Product of negative numbers:\", product\nend program product_of_negatives\n```"
  },
  {
    "task": "Write a script that reads a dictionary and prints the keys and values in sorted order.",
    "code": "```fortran\nprogram sorted_dict_io\n    implicit none\n    integer :: i, n\n    character(len=100) :: key(100)\n    character(len=100) :: value(100)\n    character(len=100) :: temp_key, temp_value\n\n    ! Read the number of key-value pairs\n    print *, 'Enter number of key-value pairs:'\n    read *, n\n\n    ! Read the key-value pairs\n    print *, 'Enter key-value pairs:'\n    do i = 1, n\n        read *, key(i), value(i)\n    end do\n\n    ! Sort the key-value pairs\n    call sort_dict(n, key, value)\n\n    ! Print sorted key-value pairs\n    print *, 'Sorted key-value pairs:'\n    do i = 1, n\n        print *, key(i), ':', value(i)\n    end do\n\ncontains\n\n    subroutine sort_dict(n, key, value)\n        integer, intent(in) :: n\n        character(len=100), intent(inout) :: key(n), value(n)\n        integer :: i, j\n        character(len=100) :: temp_key, temp_value\n        \n        do i = 1, n - 1\n            do j = i + 1, n\n                if (key(i) > key(j)) then\n                    temp_key = key(i)\n                    key(i) = key(j)\n                    key(j) = temp_key\n\n                    temp_value = value(i)\n                    value(i) = value(j)\n                    value(j) = temp_value\n                end if\n            end do\n        end do\n    end subroutine sort_dict\n\nend program sorted_dict_io\n```"
  },
  {
    "task": "Create a program that reads a text and prints the number of unique words.",
    "code": "```fortran\nprogram unique_words\n    implicit none\n    character(len=1000) :: text\n    character(len=50) :: word\n    integer :: i, j, num_words, unique_count\n    character(len=50), allocatable :: words(:)\n    logical :: is_unique\n\n    print *, \"Enter text:\"\n    read(*, '(A)') text\n\n    num_words = 0\n    allocate(words(100))\n\n    i = 1\n    do while (i <= len(text))\n        if (text(i:i) /= ' ') then\n            j = i\n            do while (j <= len(text) .and. text(j:j) /= ' ')\n                j = j + 1\n            end do\n            word = text(i:j-1)\n            if (num_words > 0) then\n                is_unique = .true.\n                do k = 1, num_words\n                    if (trim(adjustl(words(k))) == trim(adjustl(word))) then\n                        is_unique = .false.\n                        exit\n                    end if\n                end do\n                if (is_unique) then\n                    num_words = num_words + 1\n                    words(num_words) = word\n                end if\n            else\n                num_words = num_words + 1\n                words(num_words) = word\n            end if\n            i = j\n        else\n            i = i + 1\n        end if\n    end do\n\n    unique_count = num_words\n\n    print *, \"Number of unique words:\", unique_count\n\n    deallocate(words)\nend program unique_words\n```"
  }
]