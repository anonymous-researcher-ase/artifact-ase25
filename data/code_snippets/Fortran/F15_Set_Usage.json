[
  {
    "task": "Create a set to store unique usernames and demonstrate adding new ones.",
    "code": "```fortran\nprogram unique_usernames\n    implicit none\n    type :: username_set\n        character(len=:), allocatable :: usernames(:)\n    contains\n        procedure :: add_username\n        procedure :: print_usernames\n    end type username_set\n\n    type(username_set) :: uset\n\n    call uset%add_username('user1')\n    call uset%add_username('user2')\n    call uset%add_username('user1')  ! Attempt to add a duplicate\n\n    call uset%print_usernames()\n\ncontains\n\n    subroutine add_username(this, new_username)\n        class(username_set), intent(inout) :: this\n        character(len=*), intent(in) :: new_username\n        integer :: i\n\n        do i = 1, size(this%usernames)\n            if (this%usernames(i) == new_username) return\n        end do\n\n        if (allocated(this%usernames)) then\n            this%usernames = [this%usernames, new_username]\n        else\n            allocate(character(len=len(new_username)) :: this%usernames(1))\n            this%usernames(1) = new_username\n        end if\n    end subroutine add_username\n\n    subroutine print_usernames(this)\n        class(username_set), intent(in) :: this\n        integer :: i\n\n        print *, 'Usernames in set:'\n        do i = 1, size(this%usernames)\n            print *, this%usernames(i)\n        end do\n    end subroutine print_usernames\n\nend program unique_usernames\n```"
  },
  {
    "task": "Write a function that returns the union of two sets of integers.",
    "code": "```fortran\nmodule set_operations\n  implicit none\ncontains\n  function union_of_sets(set1, set2) result(union_set)\n    integer, dimension(:), intent(in) :: set1, set2\n    integer, allocatable, dimension(:) :: union_set\n    integer :: i, n, count\n    logical :: exists\n\n    allocate(union_set(size(set1) + size(set2)))\n    count = 0\n\n    do i = 1, size(set1)\n      count = count + 1\n      union_set(count) = set1(i)\n    end do\n\n    do i = 1, size(set2)\n      exists = any(union_set(1:count) == set2(i))\n      if (.not. exists) then\n        count = count + 1\n        union_set(count) = set2(i)\n      end if\n    end do\n\n    if (count < size(union_set)) then\n      union_set = union_set(1:count)\n    end if\n  end function union_of_sets\nend module set_operations\n```"
  },
  {
    "task": "Given two sets of strings, find their intersection.",
    "code": "```fortran\nprogram set_intersection\n    implicit none\n    character(len=50), dimension(:), allocatable :: set1, set2, intersection\n    integer :: i, j, n1, n2, n_intersection\n\n    ! Example sets\n    n1 = 3\n    n2 = 3\n    allocate(set1(n1))\n    allocate(set2(n2))\n\n    set1 = ['apple', 'banana', 'cherry']\n    set2 = ['banana', 'cherry', 'date']\n\n    ! Find intersection\n    allocate(intersection(min(n1, n2)))\n    n_intersection = 0\n\n    do i = 1, n1\n        do j = 1, n2\n            if (set1(i) == set2(j)) then\n                n_intersection = n_intersection + 1\n                intersection(n_intersection) = set1(i)\n                exit\n            end if\n        end do\n    end do\n\n    ! Output the intersection\n    do i = 1, n_intersection\n        print *, intersection(i)\n    end do\n\n    ! Deallocate arrays\n    deallocate(set1, set2, intersection)\n\nend program set_intersection\n```"
  },
  {
    "task": "Implement a set to track visited web pages and check if a page has been visited.",
    "code": "```fortran\nmodule visited_pages\n    implicit none\n    type :: page_set\n        character(len=:), allocatable :: pages(:)\n    contains\n        procedure :: add_page\n        procedure :: has_been_visited\n    end type page_set\ncontains\n    subroutine add_page(this, page)\n        class(page_set), intent(inout) :: this\n        character(len=*), intent(in) :: page\n        integer :: i\n\n        ! Check if the page is already in the set\n        do i = 1, size(this%pages)\n            if (this%pages(i) == page) return\n        end do\n\n        ! Add the page to the set\n        if (allocated(this%pages)) then\n            this%pages = [this%pages, page]\n        else\n            allocate(character(len=len(page)) :: this%pages(1))\n            this%pages = page\n        end if\n    end subroutine add_page\n\n    logical function has_been_visited(this, page)\n        class(page_set), intent(in) :: this\n        character(len=*), intent(in) :: page\n        integer :: i\n\n        has_been_visited = .false.\n        do i = 1, size(this%pages)\n            if (this%pages(i) == page) then\n                has_been_visited = .true.\n                return\n            end if\n        end do\n    end function has_been_visited\nend module visited_pages\n\nprogram track_web_pages\n    use visited_pages\n    implicit none\n\n    type(page_set) :: visited\n    character(len=100) :: page\n    logical :: visited_status\n\n    call visited%add_page(\"http://example.com\")\n    call visited%add_page(\"http://fortran-lang.org\")\n\n    page = \"http://example.com\"\n    visited_status = visited%has_been_visited(page)\n    print *, \"Has \", trim(page), \" been visited?\", visited_status\n\n    page = \"http://unknown.com\"\n    visited_status = visited%has_been_visited(page)\n    print *, \"Has \", trim(page), \" been visited?\", visited_status\nend program track_web_pages\n```"
  },
  {
    "task": "Create a set from a list of numbers and remove duplicates.",
    "code": "```fortran\nprogram remove_duplicates\n    implicit none\n    integer, allocatable :: numbers(:)\n    integer :: i, n\n    character(len=10), allocatable :: set(:)\n    character(len=10) :: num\n\n    ! Sample list of numbers\n    numbers = [3, 5, 7, 3, 5, 9, 1, 9, 2]\n\n    ! Allocate the set with the same size initially\n    allocate(set(size(numbers)))\n\n    n = 0\n    do i = 1, size(numbers)\n        write(num, '(I10)') numbers(i)\n        if (.not. any(trim(set(:n)) == trim(adjustl(num)))) then\n            n = n + 1\n            set(n) = trim(adjustl(num))\n        end if\n    end do\n\n    ! Deallocate unused set entries\n    if (n < size(set)) then\n        call move_alloc(set, set(:n))\n    end if\n\n    print *, trim(set)\nend program remove_duplicates\n```"
  },
  {
    "task": "Check if a set is a subset of another set.",
    "code": "```fortran\nprogram check_subset\n    implicit none\n    integer, parameter :: n1 = 5, n2 = 8\n    integer :: set1(n1) = [1, 2, 3, 4, 5]\n    integer :: set2(n2) = [1, 2, 3, 4, 5, 6, 7, 8]\n    integer :: i, j\n    logical :: is_subset\n\n    is_subset = .true.\n\n    do i = 1, n1\n        do j = 1, n2\n            if (set1(i) == set2(j)) exit\n        end do\n        if (j > n2) then\n            is_subset = .false.\n            exit\n        end if\n    end do\n\n    if (is_subset) then\n        print *, \"Set1 is a subset of Set2\"\n    else\n        print *, \"Set1 is not a subset of Set2\"\n    end if\nend program check_subset\n```"
  },
  {
    "task": "Demonstrate adding and removing elements from a set of book titles.",
    "code": "```fortran\nprogram bookSetUsage\n    implicit none\n    character(len=100), dimension(:), allocatable :: bookSet\n    character(len=100) :: newBook\n    integer :: i, n\n\n    allocate(bookSet(0))\n\n    ! Add elements to the set\n    call addBook(bookSet, \"The Great Gatsby\")\n    call addBook(bookSet, \"1984\")\n    call addBook(bookSet, \"To Kill a Mockingbird\")\n\n    ! Remove an element from the set\n    call removeBook(bookSet, \"1984\")\n\n    ! Print the set\n    n = size(bookSet)\n    print *, \"Current set of book titles:\"\n    do i = 1, n\n        print *, trim(bookSet(i))\n    end do\n\ncontains\n\n    subroutine addBook(set, book)\n        character(len=100), dimension(:), allocatable :: set\n        character(len=100), intent(in) :: book\n        integer :: found\n\n        found = searchBook(set, book)\n        if (found == 0) then\n            set = [set, book]\n        end if\n    end subroutine addBook\n\n    subroutine removeBook(set, book)\n        character(len=100), dimension(:), allocatable :: set\n        character(len=100), intent(in) :: book\n        integer :: found, i\n\n        found = searchBook(set, book)\n        if (found > 0) then\n            do i = found, size(set) - 1\n                set(i) = set(i + 1)\n            end do\n            set = set(:size(set) - 1)\n        end if\n    end subroutine removeBook\n\n    integer function searchBook(set, book)\n        character(len=100), dimension(:), allocatable :: set\n        character(len=100), intent(in) :: book\n        integer :: i\n\n        searchBook = 0\n        do i = 1, size(set)\n            if (trim(set(i)) == trim(book)) then\n                searchBook = i\n                return\n            end if\n        end do\n    end function searchBook\n\nend program bookSetUsage\n```"
  },
  {
    "task": "Create a set and show how to clear all its elements.",
    "code": "```fortran\nprogram set_example\n  implicit none\n  integer, allocatable :: set(:)\n  \n  ! Initialize the set with some values\n  allocate(set(3))\n  set = [1, 2, 3]\n  \n  ! Clear the set by deallocating\n  deallocate(set)\n  \n  ! Optionally, reallocate as an empty set\n  allocate(set(0))\n  \nend program set_example\n```"
  },
  {
    "task": "Write a program to find the difference between two sets of employee IDs.",
    "code": "```fortran\nprogram set_difference\n    implicit none\n    integer, parameter :: n1 = 5, n2 = 4\n    integer :: i, j, len_diff, set1(n1), set2(n2), diff(n1)\n\n    ! Initialize sets\n    set1 = (/101, 102, 103, 104, 105/)\n    set2 = (/103, 106, 107, 108/)\n\n    ! Find difference set1 - set2\n    len_diff = 0\n    do i = 1, n1\n        ! Check if set1(i) is not in set2\n        do j = 1, n2\n            if (set1(i) == set2(j)) exit\n        end do\n        if (j > n2) then\n            len_diff = len_diff + 1\n            diff(len_diff) = set1(i)\n        end if\n    end do\n\n    ! Output the difference\n    print *, 'Difference (set1 - set2):'\n    do i = 1, len_diff\n        print *, diff(i)\n    end do\n\nend program set_difference\n```"
  },
  {
    "task": "Implement a set to store unique email addresses and check membership.",
    "code": "```fortran\nprogram emailSet\n    implicit none\n    character(len=100), allocatable :: emailSet(:)\n    character(len=100) :: email\n    logical :: isMember\n    integer :: i\n\n    emailSet = [character(len=100) :: ]\n\n    call addEmail(emailSet, \"example@example.com\")\n    call addEmail(emailSet, \"user@example.com\")\n\n    isMember = checkMember(emailSet, \"example@example.com\")\n    print *, \"Is 'example@example.com' a member? \", isMember\n\n    isMember = checkMember(emailSet, \"notmember@example.com\")\n    print *, \"Is 'notmember@example.com' a member? \", isMember\n\ncontains\n\n    subroutine addEmail(emailSet, email)\n        character(len=100), allocatable :: emailSet(:)\n        character(len=100), intent(in) :: email\n        logical :: isMember\n        integer :: i\n\n        isMember = .false.\n        do i = 1, size(emailSet)\n            if (emailSet(i) == email) then\n                isMember = .true.\n                exit\n            end if\n        end do\n\n        if (.not. isMember) then\n            emailSet = [emailSet, email]\n        end if\n    end subroutine addEmail\n\n    function checkMember(emailSet, email) result(isMember)\n        character(len=100), allocatable :: emailSet(:)\n        character(len=100), intent(in) :: email\n        logical :: isMember\n        integer :: i\n\n        isMember = .false.\n        do i = 1, size(emailSet)\n            if (emailSet(i) == email) then\n                isMember = .true.\n                exit\n            end if\n        end do\n    end function checkMember\n\nend program emailSet\n```"
  },
  {
    "task": "Use a set to determine if two lists have any common elements.",
    "code": "```fortran\nprogram common_elements\n    implicit none\n    integer, parameter :: n = 5\n    integer :: list1(n) = [1, 2, 3, 4, 5]\n    integer :: list2(n) = [5, 6, 7, 8, 9]\n    integer :: i\n    logical :: common_found = .false.\n\n    contains\n\n    logical function is_in_set(val, set, set_size)\n        integer, intent(in) :: val, set(:)\n        integer, intent(in) :: set_size\n        integer :: j\n        is_in_set = .false.\n        do j = 1, set_size\n            if (set(j) == val) then\n                is_in_set = .true.\n                return\n            end if\n        end do\n    end function is_in_set\n\n    subroutine create_set(list, set, set_size)\n        integer, intent(in) :: list(:)\n        integer, intent(out) :: set(:)\n        integer, intent(out) :: set_size\n        integer :: j, k\n        logical :: in_set\n        set_size = 0\n        k = 1\n        do j = 1, size(list)\n            in_set = is_in_set(list(j), set, set_size)\n            if (.not. in_set) then\n                set(k) = list(j)\n                set_size = set_size + 1\n                k = k + 1\n            end if\n        end do\n    end subroutine create_set\n\n    integer, dimension(n) :: set1, set2\n    integer :: set_size1, set_size2\n\n    call create_set(list1, set1, set_size1)\n    call create_set(list2, set2, set_size2)\n\n    do i = 1, set_size1\n        if (is_in_set(set1(i), set2, set_size2)) then\n            common_found = .true.\n            exit\n        end if\n    end do\n\n    if (common_found) then\n        print *, \"Lists have common elements.\"\n    else\n        print *, \"Lists have no common elements.\"\n    end if\nend program common_elements\n```"
  },
  {
    "task": "Create a set to represent a group of students and update it with new entries.",
    "code": "```fortran\nprogram manage_students\n    implicit none\n    integer, parameter :: max_students = 100\n    character(len=20) :: students(max_students)\n    integer :: i, num_students\n    character(len=20) :: new_entries(3)\n    \n    ! Initialize student set\n    num_students = 0\n\n    ! Add initial students\n    students(1) = \"Alice\"\n    students(2) = \"Bob\"\n    students(3) = \"Charlie\"\n    num_students = 3\n\n    ! New entries to be added\n    new_entries(1) = \"David\"\n    new_entries(2) = \"Eve\"\n    new_entries(3) = \"Alice\"  ! Duplicate entry\n    \n    ! Update student set with new entries\n    do i = 1, 3\n        if (.not. any(trim(new_entries(i)) == trim(students(1:num_students)))) then\n            num_students = num_students + 1\n            students(num_students) = new_entries(i)\n        end if\n    end do\n\n    ! Output the student set\n    print *, \"Students:\"\n    do i = 1, num_students\n        print *, trim(students(i))\n    end do\nend program manage_students\n```"
  },
  {
    "task": "Write a function to find symmetric difference between two sets of colors.",
    "code": "```fortran\nmodule set_operations\n  implicit none\n  private\n  public :: symmetric_difference\n\ncontains\n\n  function symmetric_difference(set1, set2) result(diff_set)\n    character(len=*), dimension(:), intent(in) :: set1, set2\n    character(len=:), allocatable :: diff_set(:)\n    integer :: i, j, n, m, count\n    logical :: found\n\n    n = size(set1)\n    m = size(set2)\n    count = 0\n\n    allocate(character(len=len(set1(1))) :: diff_set(n + m))\n\n    do i = 1, n\n      found = .false.\n      do j = 1, m\n        if (set1(i) == set2(j)) then\n          found = .true.\n          exit\n        end if\n      end do\n      if (.not. found) then\n        count = count + 1\n        diff_set(count) = set1(i)\n      end if\n    end do\n\n    do j = 1, m\n      found = .false.\n      do i = 1, n\n        if (set2(j) == set1(i)) then\n          found = .true.\n          exit\n        end if\n      end do\n      if (.not. found) then\n        count = count + 1\n        diff_set(count) = set2(j)\n      end if\n    end do\n\n    if (count < n + m) then\n      call move_alloc(diff_set(:count), diff_set)\n    end if\n\n  end function symmetric_difference\n\nend module set_operations\n```"
  },
  {
    "task": "Implement a set to store unique product codes and demonstrate iteration over it.",
    "code": "```fortran\nprogram set_usage\n    implicit none\n    integer, parameter :: max_codes = 100\n    integer :: product_codes(max_codes)\n    integer :: num_codes, i, code, input_code\n    logical :: exists\n\n    num_codes = 0\n\n    print *, \"Enter product codes (non-positive number to end):\"\n    \n    do\n        read *, input_code\n        if (input_code <= 0) exit\n        exists = .false.\n        \n        do i = 1, num_codes\n            if (product_codes(i) == input_code) then\n                exists = .true.\n                exit\n            end if\n        end do\n        \n        if (.not. exists) then\n            num_codes = num_codes + 1\n            product_codes(num_codes) = input_code\n        end if\n    end do\n\n    print *, \"Unique product codes:\"\n    do i = 1, num_codes\n        print *, product_codes(i)\n    end do\nend program set_usage\n```"
  },
  {
    "task": "Create a set and demonstrate the use of the `discard` method.",
    "code": "```fortran\nprogram set_usage\n    implicit none\n    integer, dimension(:), allocatable :: set\n    integer :: element\n\n    ! Initialize the set with some elements\n    set = [1, 2, 3, 4, 5]\n\n    ! Element to discard\n    element = 3\n\n    ! Discard method demonstration\n    call discard(set, element)\n\ncontains\n\n    subroutine discard(set, element)\n        integer, dimension(:), allocatable :: set\n        integer :: element\n        integer :: i, n\n\n        n = size(set)\n\n        do i = 1, n\n            if (set(i) == element) then\n                set = [set(1:i-1), set(i+1:n)]\n                return\n            end if\n        end do\n    end subroutine discard\n\nend program set_usage\n```"
  },
  {
    "task": "Given a list of numbers, create a set and check if a specific number is present.",
    "code": "```fortran\nprogram check_number_in_set\n    implicit none\n    integer :: number_to_check\n    integer, dimension(:), allocatable :: numbers\n    integer :: i\n    integer, allocatable :: unique_numbers(:)\n    logical :: found\n\n    ! Example initialization\n    numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    number_to_check = 5\n\n    ! Create a set (unique numbers)\n    call create_set(numbers, unique_numbers)\n\n    ! Check if number_to_check is in the set\n    found = .false.\n    do i = 1, size(unique_numbers)\n        if (unique_numbers(i) == number_to_check) then\n            found = .true.\n            exit\n        end if\n    end do\n\n    if (found) then\n        print *, \"Number\", number_to_check, \"is present in the set.\"\n    else\n        print *, \"Number\", number_to_check, \"is not present in the set.\"\n    end if\ncontains\n    subroutine create_set(input_list, output_set)\n        integer, dimension(:), intent(in) :: input_list\n        integer, allocatable, intent(out) :: output_set(:)\n        integer :: i, j\n        logical :: is_unique\n\n        ! Initialize the output set with the same size as input\n        allocate(output_set(size(input_list)))\n        output_set = 0\n        j = 0\n\n        do i = 1, size(input_list)\n            ! Check if input_list(i) is already in output_set\n            is_unique = .true.\n            if (j > 0) then\n                if (any(output_set(1:j) == input_list(i))) then\n                    is_unique = .false.\n                end if\n            end if\n\n            ! If it's unique, add to output_set\n            if (is_unique) then\n                j = j + 1\n                output_set(j) = input_list(i)\n            end if\n        end do\n\n        ! Resize output_set to contain only the unique elements\n        if (j > 0) then\n            call move_alloc(output_set, output_set(1:j))\n        else\n            deallocate(output_set)\n        end if\n    end subroutine create_set\nend program check_number_in_set\n```"
  },
  {
    "task": "Use a set to find all unique words in a sentence.",
    "code": "```fortran\nprogram unique_words\n    implicit none\n    character(len=100) :: sentence\n    character(len=20), allocatable :: words(:)\n    character(len=20), allocatable :: unique_words(:)\n    integer :: i, j, num_words, num_unique\n    logical :: is_unique\n\n    sentence = \"Use a set to find all unique words in a sentence\"\n    call split(sentence, words, num_words)\n\n    allocate(unique_words(num_words))\n    num_unique = 0\n\n    do i = 1, num_words\n        is_unique = .true.\n        do j = 1, num_unique\n            if (trim(words(i)) == trim(unique_words(j))) then\n                is_unique = .false.\n                exit\n            end if\n        end do\n        if (is_unique) then\n            num_unique = num_unique + 1\n            unique_words(num_unique) = words(i)\n        end if\n    end do\n\n    do i = 1, num_unique\n        print *, trim(unique_words(i))\n    end do\n\ncontains\n\n    subroutine split(sentence, words, num_words)\n        implicit none\n        character(len=*), intent(in) :: sentence\n        character(len=20), allocatable, intent(out) :: words(:)\n        integer, intent(out) :: num_words\n        integer :: i, n, start, len_sentence\n        character(len=20) :: word\n\n        len_sentence = len_trim(sentence)\n        allocate(words(len_sentence))\n        n = 0\n        start = 1\n        do i = 1, len_sentence\n            if (i == len_sentence .or. sentence(i:i) == ' ') then\n                word = sentence(start:i-1)\n                if (len_trim(word) > 0) then\n                    n = n + 1\n                    words(n) = word\n                end if\n                start = i + 1\n            end if\n        end do\n        num_words = n\n    end subroutine split\n\nend program unique_words\n```"
  },
  {
    "task": "Create a set from a sequence of characters and demonstrate set operations.",
    "code": "```fortran\nprogram SetUsageDemo\n    implicit none\n    character(len=1) :: charSet(5) = ['a', 'b', 'c', 'd', 'e']\n    character(len=1) :: anotherSet(5) = ['c', 'd', 'e', 'f', 'g']\n    character(len=1) :: unionSet(10), intersectionSet(5), differenceSet(5)\n    integer :: i, j, k, countUnion, countIntersection, countDifference\n\n    countUnion = 0\n    countIntersection = 0\n    countDifference = 0\n\n    ! Union operation\n    do i = 1, size(charSet)\n        unionSet(countUnion + 1) = charSet(i)\n        countUnion = countUnion + 1\n    end do\n    do i = 1, size(anotherSet)\n        if (.not. any(anotherSet(i) == unionSet(:countUnion))) then\n            unionSet(countUnion + 1) = anotherSet(i)\n            countUnion = countUnion + 1\n        end if\n    end do\n\n    ! Intersection operation\n    do i = 1, size(charSet)\n        if (any(charSet(i) == anotherSet)) then\n            intersectionSet(countIntersection + 1) = charSet(i)\n            countIntersection = countIntersection + 1\n        end if\n    end do\n\n    ! Difference operation\n    do i = 1, size(charSet)\n        if (.not. any(charSet(i) == anotherSet)) then\n            differenceSet(countDifference + 1) = charSet(i)\n            countDifference = countDifference + 1\n        end if\n    end do\n\n    ! Output results\n    print *, 'Union: ', unionSet(:countUnion)\n    print *, 'Intersection: ', intersectionSet(:countIntersection)\n    print *, 'Difference: ', differenceSet(:countDifference)\n\nend program SetUsageDemo\n```"
  },
  {
    "task": "Write a function to merge two sets and return the result.",
    "code": "```fortran\nmodule set_operations\n  implicit none\ncontains\n  function merge_sets(set1, set2) result(merged_set)\n    integer, allocatable :: set1(:), set2(:)\n    integer, allocatable :: merged_set(:)\n    integer :: i, n, count\n    logical :: is_in_set\n\n    allocate(merged_set(size(set1) + size(set2)))\n    count = 0\n\n    do i = 1, size(set1)\n      count = count + 1\n      merged_set(count) = set1(i)\n    end do\n\n    do i = 1, size(set2)\n      is_in_set = any(set2(i) == merged_set(:count))\n      if (.not. is_in_set) then\n        count = count + 1\n        merged_set(count) = set2(i)\n      end if\n    end do\n\n    call move_alloc(merged_set(:count), merged_set)\n  end function merge_sets\nend module set_operations\n```"
  },
  {
    "task": "Implement a set to hold unique IP addresses and demonstrate basic operations.",
    "code": "```fortran\nprogram ip_set_demo\n    implicit none\n    type :: IPSet\n        character(len=:), allocatable :: addresses(:)\n    contains\n        procedure :: add_ip\n        procedure :: contains_ip\n        procedure :: remove_ip\n        procedure :: print_ips\n    end type IPSet\n\n    type(IPSet) :: myIPSet\n\n    call myIPSet%add_ip(\"192.168.1.1\")\n    call myIPSet%add_ip(\"10.0.0.1\")\n    call myIPSet%add_ip(\"192.168.1.1\")\n    call myIPSet%print_ips()\n    if (myIPSet%contains_ip(\"10.0.0.1\")) then\n        print *, \"IP 10.0.0.1 found in set.\"\n    else\n        print *, \"IP 10.0.0.1 not found in set.\"\n    end if\n    call myIPSet%remove_ip(\"10.0.0.1\")\n    call myIPSet%print_ips()\n\ncontains\n\n    subroutine add_ip(this, ip)\n        class(IPSet), intent(inout) :: this\n        character(len=*), intent(in) :: ip\n        integer :: i\n        logical :: found\n\n        found = .false.\n        do i = 1, size(this%addresses)\n            if (this%addresses(i) == ip) then\n                found = .true.\n                exit\n            end if\n        end do\n\n        if (.not. found) then\n            if (.not. allocated(this%addresses)) then\n                allocate(character(len=len(ip)) :: this%addresses(1))\n                this%addresses(1) = ip\n            else\n                call move_alloc(this%addresses, this%addresses)\n                allocate(character(len=len(ip)) :: this%addresses(size(this%addresses) + 1))\n                this%addresses(size(this%addresses)) = ip\n            end if\n        end if\n    end subroutine add_ip\n\n    function contains_ip(this, ip) result(found)\n        class(IPSet), intent(in) :: this\n        character(len=*), intent(in) :: ip\n        logical :: found\n        integer :: i\n\n        found = .false.\n        do i = 1, size(this%addresses)\n            if (this%addresses(i) == ip) then\n                found = .true.\n                exit\n            end if\n        end do\n    end function contains_ip\n\n    subroutine remove_ip(this, ip)\n        class(IPSet), intent(inout) :: this\n        character(len=*), intent(in) :: ip\n        integer :: i, j\n\n        do i = 1, size(this%addresses)\n            if (this%addresses(i) == ip) then\n                do j = i, size(this%addresses) - 1\n                    this%addresses(j) = this%addresses(j + 1)\n                end do\n                call move_alloc(this%addresses, this%addresses)\n                if (size(this%addresses) > 1) then\n                    allocate(character(len=len(ip)) :: this%addresses(size(this%addresses) - 1))\n                else\n                    deallocate(this%addresses)\n                end if\n                exit\n            end if\n        end do\n    end subroutine remove_ip\n\n    subroutine print_ips(this)\n        class(IPSet), intent(in) :: this\n        integer :: i\n\n        if (allocated(this%addresses)) then\n            print *, \"IP Addresses in set:\"\n            do i = 1, size(this%addresses)\n                print *, this%addresses(i)\n            end do\n        else\n            print *, \"No IP Addresses in set.\"\n        end if\n    end subroutine print_ips\n\nend program ip_set_demo\n```"
  },
  {
    "task": "Create a set and demonstrate how to find the size of the set.",
    "code": "```fortran\nprogram set_example\n    implicit none\n    integer, parameter :: set_size = 100\n    integer :: set_array(set_size), unique_elements(set_size)\n    integer :: i, num_elements, num_unique, current_element\n\n    ! Initialize the set_array with some values\n    num_elements = 10\n    set_array(1:num_elements) = (/ 1, 2, 3, 4, 5, 3, 2, 8, 9, 1 /)\n\n    ! Find unique elements\n    num_unique = 0\n    do i = 1, num_elements\n        current_element = set_array(i)\n        if (.not. any(unique_elements(1:num_unique) == current_element)) then\n            num_unique = num_unique + 1\n            unique_elements(num_unique) = current_element\n        end if\n    end do\n\n    ! Output the size of the unique set\n    print *, \"The size of the set is: \", num_unique\nend program set_example\n```"
  },
  {
    "task": "Write a program to check if two sets of dates are disjoint.",
    "code": "```fortran\nprogram check_disjoint_sets\n    implicit none\n    integer, parameter :: date_length = 10\n    character(len=date_length), dimension(:), allocatable :: set1, set2\n    integer :: i, j, n1, n2\n    logical :: disjoint\n\n    ! Example data, replace with actual input if needed\n    n1 = 3\n    n2 = 3\n    allocate(set1(n1))\n    allocate(set2(n2))\n\n    set1 = [character(len=date_length) :: '2023-10-01', '2023-10-02', '2023-10-03']\n    set2 = [character(len=date_length) :: '2023-10-04', '2023-10-05', '2023-10-06']\n\n    disjoint = .true.\n    do i = 1, n1\n        do j = 1, n2\n            if (set1(i) == set2(j)) then\n                disjoint = .false.\n                exit\n            end if\n        end do\n        if (.not. disjoint) exit\n    end do\n\n    if (disjoint) then\n        print *, \"The sets are disjoint.\"\n    else\n        print *, \"The sets are not disjoint.\"\n    end if\n\n    deallocate(set1)\n    deallocate(set2)\nend program check_disjoint_sets\n```"
  },
  {
    "task": "Create a set to manage a collection of tags and demonstrate addition and removal.",
    "code": "```fortran\nprogram manage_tags\n    implicit none\n    type :: TagSet\n        character(len=:), allocatable :: tags(:)\n    contains\n        procedure :: add_tag\n        procedure :: remove_tag\n        procedure :: print_tags\n    end type TagSet\n\n    type(TagSet) :: myTags\n\n    call myTags%add_tag(\"fortran\")\n    call myTags%add_tag(\"code\")\n    call myTags%print_tags()\n    call myTags%remove_tag(\"fortran\")\n    call myTags%print_tags()\n\ncontains\n\n    subroutine add_tag(this, tag)\n        class(TagSet), intent(inout) :: this\n        character(len=*), intent(in) :: tag\n        integer :: i\n\n        do i = 1, size(this%tags)\n            if (this%tags(i) == tag) return\n        end do\n\n        if (allocated(this%tags)) then\n            this%tags = [this%tags, tag]\n        else\n            allocate(character(len=len(tag)) :: this%tags(1))\n            this%tags(1) = tag\n        end if\n    end subroutine add_tag\n\n    subroutine remove_tag(this, tag)\n        class(TagSet), intent(inout) :: this\n        character(len=*), intent(in) :: tag\n        integer :: i, j\n\n        if (.not. allocated(this%tags)) return\n\n        do i = 1, size(this%tags)\n            if (this%tags(i) == tag) then\n                do j = i, size(this%tags) - 1\n                    this%tags(j) = this%tags(j + 1)\n                end do\n                if (size(this%tags) > 1) then\n                    this%tags = this%tags(:size(this%tags) - 1)\n                else\n                    deallocate(this%tags)\n                end if\n                return\n            end if\n        end do\n    end subroutine remove_tag\n\n    subroutine print_tags(this)\n        class(TagSet), intent(in) :: this\n        integer :: i\n\n        if (.not. allocated(this%tags)) then\n            print *, \"No tags available.\"\n            return\n        end if\n\n        print *, \"Tags:\"\n        do i = 1, size(this%tags)\n            print *, this%tags(i)\n        end do\n    end subroutine print_tags\nend program manage_tags\n```"
  },
  {
    "task": "Implement a set to track unique inventory items in a store.",
    "code": "```fortran\nprogram unique_inventory\n    implicit none\n    integer, parameter :: max_items = 100\n    integer :: inventory(max_items)\n    integer :: item, num_items, i, found\n\n    num_items = 0\n    inventory = 0\n\n    do\n        print *, \"Enter item number (0 to quit):\"\n        read *, item\n        if (item == 0) exit\n\n        found = 0\n        do i = 1, num_items\n            if (inventory(i) == item) then\n                found = 1\n                exit\n            end if\n        end do\n\n        if (found == 0) then\n            if (num_items < max_items) then\n                num_items = num_items + 1\n                inventory(num_items) = item\n            else\n                print *, \"Inventory is full!\"\n            end if\n        else\n            print *, \"Item already in inventory.\"\n        end if\n    end do\n\n    print *, \"Unique inventory items:\"\n    do i = 1, num_items\n        print *, inventory(i)\n    end do\nend program unique_inventory\n```"
  },
  {
    "task": "Create a set of numbers and demonstrate conversion to a list.",
    "code": "```fortran\nprogram set_to_list\n    implicit none\n    integer, dimension(:), allocatable :: num_list\n    integer, dimension(5) :: num_array\n    integer :: i\n\n    ! Initialize a set of numbers using an array\n    num_array = (/ 1, 2, 3, 4, 5 /)\n\n    ! Allocate the list and copy the set into it\n    allocate(num_list(size(num_array)))\n    num_list = num_array\n\n    ! Print the list to demonstrate the conversion\n    do i = 1, size(num_list)\n        print *, num_list(i)\n    end do\n\nend program set_to_list\n```"
  },
  {
    "task": "Write a function that returns all elements present in either of two sets but not both.",
    "code": "```fortran\nmodule set_operations\n    implicit none\ncontains\n    function symmetric_difference(set1, set2) result(diff)\n        integer, allocatable :: set1(:), set2(:), diff(:)\n        integer :: i, j, count\n        logical :: in_set\n\n        count = 0\n        allocate(diff(size(set1) + size(set2)))\n\n        do i = 1, size(set1)\n            in_set = .false.\n            do j = 1, size(set2)\n                if (set1(i) == set2(j)) then\n                    in_set = .true.\n                    exit\n                end if\n            end do\n            if (.not. in_set) then\n                count = count + 1\n                diff(count) = set1(i)\n            end if\n        end do\n\n        do j = 1, size(set2)\n            in_set = .false.\n            do i = 1, size(set1)\n                if (set2(j) == set1(i)) then\n                    in_set = .true.\n                    exit\n                end if\n            end do\n            if (.not. in_set) then\n                count = count + 1\n                diff(count) = set2(j)\n            end if\n        end do\n\n        if (count > 0) then\n            call move_alloc(diff(:count), diff)\n        else\n            deallocate(diff)\n        end if\n    end function symmetric_difference\nend module set_operations\n```"
  },
  {
    "task": "Use a set to manage a collection of unique transaction IDs.",
    "code": "```fortran\nprogram manage_transaction_ids\n    implicit none\n    integer, parameter :: max_ids = 100\n    integer :: transaction_ids(max_ids)\n    integer :: transaction_id, i, num_ids\n    logical :: found\n\n    num_ids = 0\n\n    do\n        print *, \"Enter a transaction ID (enter -1 to exit):\"\n        read *, transaction_id\n        if (transaction_id == -1) exit\n\n        found = .false.\n        do i = 1, num_ids\n            if (transaction_ids(i) == transaction_id) then\n                found = .true.\n                exit\n            end if\n        end do\n\n        if (.not. found) then\n            num_ids = num_ids + 1\n            if (num_ids > max_ids) then\n                print *, \"Maximum number of unique IDs reached.\"\n                exit\n            end if\n            transaction_ids(num_ids) = transaction_id\n        end if\n    end do\n\n    print *, \"Unique transaction IDs:\"\n    do i = 1, num_ids\n        print *, transaction_ids(i)\n    end do\n\nend program manage_transaction_ids\n```"
  },
  {
    "task": "Create a set of integers and demonstrate the `pop` operation.",
    "code": "```fortran\nprogram set_usage\n    implicit none\n    integer, dimension(:), allocatable :: myset\n    integer :: i, n, position\n\n    ! Initialize the set\n    myset = [1, 2, 3, 4, 5]\n    n = size(myset)\n\n    ! Demonstrate the pop operation by removing an element from the set\n    position = 3  ! For example, remove the element at position 3\n\n    ! Shift elements to remove the element at the specified position\n    do i = position, n - 1\n        myset(i) = myset(i + 1)\n    end do\n\n    ! Resize the set\n    n = n - 1\n    call move_alloc(myset, myset(1:n))\n\n    ! Output the set after pop operation\n    print *, myset\n\nend program set_usage\n```"
  },
  {
    "task": "Write a program to find the maximum element in a set of floating-point numbers.",
    "code": "```fortran\nprogram max_in_set\n    implicit none\n    real, dimension(:), allocatable :: numbers\n    real :: max_val\n    integer :: n, i\n\n    print *, \"Enter the number of elements in the set:\"\n    read *, n\n    allocate(numbers(n))\n\n    print *, \"Enter the elements of the set:\"\n    do i = 1, n\n        read *, numbers(i)\n    end do\n\n    max_val = numbers(1)\n    do i = 2, n\n        if (numbers(i) > max_val) then\n            max_val = numbers(i)\n        end if\n    end do\n\n    print *, \"The maximum element in the set is:\", max_val\n\n    deallocate(numbers)\nend program max_in_set\n```"
  },
  {
    "task": "Create a set and demonstrate the use of the `update` method with another set.",
    "code": "```fortran\nprogram set_usage\n    implicit none\n    integer, parameter :: n = 100\n    integer :: set1(n), set2(n)\n    integer :: i, j, count1, count2\n\n    ! Initialize sets\n    count1 = 3\n    count2 = 2\n    set1 = [1, 2, 3, (0, i = 4, n)]\n    set2 = [3, 4, (0, i = 3, n)]\n\n    ! Update set1 with elements from set2\n    do i = 1, count2\n        if (.not. any(set1(1:count1) == set2(i))) then\n            count1 = count1 + 1\n            set1(count1) = set2(i)\n        end if\n    end do\n\n    ! Output the updated set1\n    do i = 1, count1\n        if (set1(i) /= 0) then\n            print *, set1(i)\n        end if\n    end do\nend program set_usage\n```"
  },
  {
    "task": "Implement a set to keep track of unique file extensions in a directory.",
    "code": "```fortran\nprogram unique_file_extensions\n    implicit none\n    character(len=256) :: command, line\n    character(len=50) :: ext\n    integer :: i, stat\n    type :: extension_set\n        character(len=50), allocatable :: extensions(:)\n    end type extension_set\n    type(extension_set) :: ext_set\n    \n    allocate(ext_set%extensions(0))\n    \n    command = \"ls | awk -F. '/\\./ {print $NF}' | sort | uniq\"\n    \n    open(unit=10, file=\"extensions.txt\", status=\"replace\")\n    call execute_command_line(command, wait=.true., exitstat=stat, &\n                              output_unit=10)\n    close(10)\n    \n    open(unit=20, file=\"extensions.txt\", status=\"old\")\n    do\n        read(20, '(A)', iostat=stat) line\n        if (stat /= 0) exit\n        ext = adjustl(trim(line))\n        if (.not. any(ext == ext_set%extensions)) then\n            call add_to_set(ext_set, ext)\n        end if\n    end do\n    close(20)\n    \n    print *, \"Unique extensions found:\"\n    do i = 1, size(ext_set%extensions)\n        print *, trim(ext_set%extensions(i))\n    end do\ncontains\n    subroutine add_to_set(ext_set, new_ext)\n        type(extension_set), intent(inout) :: ext_set\n        character(len=50), intent(in) :: new_ext\n        integer :: n\n        \n        n = size(ext_set%extensions)\n        call move_alloc(from=ext_set%extensions, to=ext_set%extensions, &\n                        source=ext_set%extensions, mold=ext_set%extensions)\n        allocate(ext_set%extensions(n+1))\n        ext_set%extensions(1:n) = ext_set%extensions(:)\n        ext_set%extensions(n+1) = new_ext\n    end subroutine add_to_set\nend program unique_file_extensions\n```"
  },
  {
    "task": "Create a set of strings and demonstrate how to iterate over it in reverse order.",
    "code": "```fortran\nprogram reverse_set_iteration\n    implicit none\n    character(len=:), allocatable :: strArray(:)\n    integer :: i\n\n    strArray = [\"apple\", \"banana\", \"cherry\"]\n\n    do i = size(strArray), 1, -1\n        print *, trim(strArray(i))\n    end do\nend program reverse_set_iteration\n```"
  },
  {
    "task": "Write a function to check if a set is empty.",
    "code": "```fortran\nprogram check_set_empty\n  implicit none\n  logical :: is_empty\n  type :: integer_set\n     integer, allocatable :: elements(:)\n  end type integer_set\n  type(integer_set) :: my_set\n\n  my_set%elements = [1, 2, 3]  ! Example set initialization\n  is_empty = set_is_empty(my_set)\n  print *, 'Is the set empty? ', is_empty\n\ncontains\n\n  logical function set_is_empty(set)\n    type(integer_set), intent(in) :: set\n    set_is_empty = .not. allocated(set%elements) .or. size(set%elements) == 0\n  end function set_is_empty\n\nend program check_set_empty\n```"
  },
  {
    "task": "Use a set to filter out duplicate entries from a list of participants.",
    "code": "```fortran\nprogram filter_duplicates\n  implicit none\n  integer, allocatable :: participants(:), unique_participants(:)\n  integer :: i, num_participants\n  type :: int_set\n     integer, allocatable :: elements(:)\n  end type int_set\n\n  type(int_set) :: set\n\n  set%elements = [integer ::]\n\n  num_participants = 6\n  participants = [1, 2, 3, 2, 4, 1]\n\n  call add_to_set(set, participants)\n\n  unique_participants = set%elements\n\n  print *, \"Unique participants:\", unique_participants\n\ncontains\n\n  subroutine add_to_set(set, values)\n    type(int_set), intent(inout) :: set\n    integer, intent(in) :: values(:)\n    integer :: i\n\n    do i = 1, size(values)\n       call add_element(set, values(i))\n    end do\n  end subroutine add_to_set\n\n  subroutine add_element(set, value)\n    type(int_set), intent(inout) :: set\n    integer, intent(in) :: value\n    integer :: idx\n\n    if (.not. any(set%elements == value)) then\n       idx = size(set%elements) + 1\n       allocate(set%elements(idx))\n       set%elements(idx) = value\n    end if\n  end subroutine add_element\n\nend program filter_duplicates\n```"
  },
  {
    "task": "Create a set of tuples and demonstrate basic set operations.",
    "code": "```fortran\nprogram set_demo\n    implicit none\n    type :: tuple\n        integer :: a\n        integer :: b\n    end type tuple\n\n    type(tuple), allocatable :: set1(:)\n    type(tuple), allocatable :: set2(:)\n    type(tuple), allocatable :: union_set(:)\n    type(tuple), allocatable :: intersection_set(:)\n    type(tuple), allocatable :: difference_set(:)\n\n    integer :: i\n\n    allocate(set1(3))\n    allocate(set2(3))\n\n    set1(1) = tuple(1, 2)\n    set1(2) = tuple(3, 4)\n    set1(3) = tuple(5, 6)\n\n    set2(1) = tuple(3, 4)\n    set2(2) = tuple(7, 8)\n    set2(3) = tuple(5, 6)\n\n    call set_union(set1, set2, union_set)\n    call set_intersection(set1, set2, intersection_set)\n    call set_difference(set1, set2, difference_set)\n\ncontains\n\n    subroutine set_union(s1, s2, result)\n        type(tuple), allocatable, intent(in) :: s1(:)\n        type(tuple), allocatable, intent(in) :: s2(:)\n        type(tuple), allocatable, intent(out) :: result(:)\n        integer :: i, j, k, count\n        logical :: found\n\n        count = size(s1) + size(s2)\n        allocate(result(count))\n        k = 0\n\n        do i = 1, size(s1)\n            k = k + 1\n            result(k) = s1(i)\n        end do\n\n        do i = 1, size(s2)\n            found = .false.\n            do j = 1, size(s1)\n                if (s2(i)%a == s1(j)%a .and. s2(i)%b == s1(j)%b) then\n                    found = .true.\n                    exit\n                end if\n            end do\n            if (.not. found) then\n                k = k + 1\n                result(k) = s2(i)\n            end if\n        end do\n\n        if (k < count) then\n            allocate(result(k))\n            result = result(1:k)\n        end if\n    end subroutine set_union\n\n    subroutine set_intersection(s1, s2, result)\n        type(tuple), allocatable, intent(in) :: s1(:)\n        type(tuple), allocatable, intent(in) :: s2(:)\n        type(tuple), allocatable, intent(out) :: result(:)\n        integer :: i, j, k\n        logical :: found\n\n        allocate(result(min(size(s1), size(s2))))\n        k = 0\n\n        do i = 1, size(s1)\n            found = .false.\n            do j = 1, size(s2)\n                if (s1(i)%a == s2(j)%a .and. s1(i)%b == s2(j)%b) then\n                    found = .true.\n                    exit\n                end if\n            end do\n            if (found) then\n                k = k + 1\n                result(k) = s1(i)\n            end if\n        end do\n\n        if (k < size(result)) then\n            allocate(result(k))\n            result = result(1:k)\n        end if\n    end subroutine set_intersection\n\n    subroutine set_difference(s1, s2, result)\n        type(tuple), allocatable, intent(in) :: s1(:)\n        type(tuple), allocatable, intent(in) :: s2(:)\n        type(tuple), allocatable, intent(out) :: result(:)\n        integer :: i, j, k\n        logical :: found\n\n        allocate(result(size(s1)))\n        k = 0\n\n        do i = 1, size(s1)\n            found = .false.\n            do j = 1, size(s2)\n                if (s1(i)%a == s2(j)%a .and. s1(i)%b == s2(j)%b) then\n                    found = .true.\n                    exit\n                end if\n            end do\n            if (.not. found) then\n                k = k + 1\n                result(k) = s1(i)\n            end if\n        end do\n\n        if (k < size(result)) then\n            allocate(result(k))\n            result = result(1:k)\n        end if\n    end subroutine set_difference\n\nend program set_demo\n```"
  },
  {
    "task": "Write a program to find the common elements between two sets of country names.",
    "code": "```fortran\nprogram common_countries\n    implicit none\n    character(len=20), dimension(:), allocatable :: set1, set2, common_set\n    integer :: i, j, n1, n2, count\n\n    ! Initialize the country sets\n    set1 = ['USA', 'Canada', 'Mexico', 'Brazil']\n    set2 = ['Canada', 'India', 'Mexico', 'Japan']\n\n    n1 = size(set1)\n    n2 = size(set2)\n    count = 0\n\n    allocate(character(len=20) :: common_set(min(n1, n2)))\n\n    ! Find common elements\n    do i = 1, n1\n        do j = 1, n2\n            if (set1(i) == set2(j)) then\n                count = count + 1\n                common_set(count) = set1(i)\n            end if\n        end do\n    end do\n\n    ! Resize the common set to the actual count of common elements\n    if (count > 0) then\n        call move_alloc(from=common_set, to=common_set(:count))\n        print *, 'Common countries: ', common_set\n    else\n        print *, 'No common countries found.'\n    end if\n\nend program common_countries\n```"
  },
  {
    "task": "Create a set of characters and demonstrate the use of the `issubset` method.",
    "code": "```fortran\nprogram character_set\n  implicit none\n  character(len=1), dimension(:), allocatable :: set1, set2\n  integer :: i\n  logical :: is_subset\n  \n  set1 = ['a', 'b', 'c']\n  set2 = ['a', 'b', 'c', 'd', 'e']\n\n  is_subset = .true.\n  do i = 1, size(set1)\n     if (.not. any(set1(i) == set2)) then\n        is_subset = .false.\n        exit\n     end if\n  end do\n\n  if (is_subset) then\n     print *, \"set1 is a subset of set2\"\n  else\n     print *, \"set1 is not a subset of set2\"\n  end if\nend program character_set\n```"
  },
  {
    "task": "Implement a set to manage a collection of unique hashtags from social media posts.",
    "code": "```fortran\nmodule hashtag_set\n    implicit none\n    private\n    public :: add_hashtag, remove_hashtag, contains_hashtag, display_hashtags\n\n    type :: hashtag_set_type\n        character(len=:), allocatable :: hashtags(:)\n    contains\n        procedure :: add => add_hashtag\n        procedure :: remove => remove_hashtag\n        procedure :: contains => contains_hashtag\n        procedure :: display => display_hashtags\n    end type hashtag_set_type\n\ncontains\n\n    subroutine add_hashtag(this, hashtag)\n        class(hashtag_set_type), intent(inout) :: this\n        character(len=*), intent(in) :: hashtag\n        integer :: i\n\n        if (.not. contains_hashtag(this, hashtag)) then\n            i = size(this%hashtags) + 1\n            call move_alloc(this%hashtags, this%hashtags, [i])\n            this%hashtags(i) = hashtag\n        end if\n    end subroutine add_hashtag\n\n    subroutine remove_hashtag(this, hashtag)\n        class(hashtag_set_type), intent(inout) :: this\n        character(len=*), intent(in) :: hashtag\n        integer :: i, index, n\n\n        index = -1\n        n = size(this%hashtags)\n\n        do i = 1, n\n            if (this%hashtags(i) == hashtag) then\n                index = i\n                exit\n            end if\n        end do\n\n        if (index /= -1) then\n            this%hashtags(index:) = this%hashtags(index+1:)\n            call move_alloc(this%hashtags, this%hashtags, [n-1])\n        end if\n    end subroutine remove_hashtag\n\n    logical function contains_hashtag(this, hashtag)\n        class(hashtag_set_type), intent(in) :: this\n        character(len=*), intent(in) :: hashtag\n        integer :: i\n\n        contains_hashtag = .false.\n\n        do i = 1, size(this%hashtags)\n            if (this%hashtags(i) == hashtag) then\n                contains_hashtag = .true.\n                exit\n            end if\n        end do\n    end function contains_hashtag\n\n    subroutine display_hashtags(this)\n        class(hashtag_set_type), intent(in) :: this\n        integer :: i\n\n        do i = 1, size(this%hashtags)\n            print *, trim(this%hashtags(i))\n        end do\n    end subroutine display_hashtags\n\nend module hashtag_set\n```"
  },
  {
    "task": "Create a set and demonstrate how to copy it to another set.",
    "code": "```fortran\nprogram set_copy\n    implicit none\n    integer, allocatable :: set1(:), set2(:)\n    integer :: i, n\n\n    ! Initialize set1 with some values\n    n = 5\n    allocate(set1(n))\n    set1 = [1, 2, 3, 4, 5]\n\n    ! Copy set1 into set2\n    allocate(set2(size(set1)))\n    set2 = set1\n\n    ! Output to demonstrate the copy\n    print *, \"Set1: \", set1\n    print *, \"Set2: \", set2\n\n    ! Deallocate arrays\n    deallocate(set1)\n    deallocate(set2)\nend program set_copy\n```"
  },
  {
    "task": "Write a function that accepts two sets and returns a new set with elements found in both.",
    "code": "```fortran\nmodule set_module\n    implicit none\ncontains\n    function intersection(set1, set2) result(set_intersection)\n        integer, dimension(:), allocatable :: set1, set2, set_intersection\n        integer, dimension(:), allocatable :: temp\n        integer :: i, j, k, count\n\n        allocate(temp(size(set1) + size(set2)))\n        count = 0\n\n        do i = 1, size(set1)\n            do j = 1, size(set2)\n                if (set1(i) == set2(j)) then\n                    count = count + 1\n                    temp(count) = set1(i)\n                    exit\n                end if\n            end do\n        end do\n\n        allocate(set_intersection(count))\n        set_intersection = temp(1:count)\n        deallocate(temp)\n    end function intersection\nend module set_module\n```"
  },
  {
    "task": "Use a set to determine the unique items purchased in a day.",
    "code": "```fortran\nprogram uniqueItems\n    implicit none\n    character(len=20), dimension(:), allocatable :: purchases\n    integer :: n, i\n    type :: itemSet\n        character(len=20), dimension(:), allocatable :: items\n    end type itemSet\n    type(itemSet) :: uniqueSet\n\n    print *, \"Enter the number of items purchased:\"\n    read *, n\n    allocate(purchases(n))\n    print *, \"Enter the items:\"\n    do i = 1, n\n        read *, purchases(i)\n    end do\n\n    call findUniqueItems(purchases, uniqueSet)\n\n    print *, \"Unique items purchased:\"\n    do i = 1, size(uniqueSet%items)\n        print *, uniqueSet%items(i)\n    end do\n\ncontains\n\n    subroutine findUniqueItems(purchases, uniqueSet)\n        character(len=20), dimension(:), intent(in) :: purchases\n        type(itemSet), intent(out) :: uniqueSet\n        integer :: i, j, count\n        logical :: isUnique\n\n        allocate(uniqueSet%items(0))\n        count = 0\n\n        do i = 1, size(purchases)\n            isUnique = .true.\n            do j = 1, count\n                if (purchases(i) == uniqueSet%items(j)) then\n                    isUnique = .false.\n                    exit\n                end if\n            end do\n            if (isUnique) then\n                count = count + 1\n                call addItem(uniqueSet, purchases(i), count)\n            end if\n        end do\n    end subroutine findUniqueItems\n\n    subroutine addItem(uniqueSet, item, count)\n        type(itemSet), intent(inout) :: uniqueSet\n        character(len=20), intent(in) :: item\n        integer, intent(in) :: count\n\n        if (count > size(uniqueSet%items)) then\n            allocate(character(len=20) :: uniqueSet%items(count))\n        end if\n        uniqueSet%items(count) = item\n    end subroutine addItem\n\nend program uniqueItems\n```"
  },
  {
    "task": "Create a set of student IDs and demonstrate set comprehension to filter IDs.",
    "code": "```fortran\nprogram student_ids\n    implicit none\n    integer, allocatable :: student_ids(:)\n    integer, allocatable :: filtered_ids(:)\n    integer :: i, n\n\n    ! Initialize set of student IDs\n    allocate(student_ids(5))\n    student_ids = [1001, 1002, 1003, 1004, 1005]\n\n    ! Set comprehension to filter IDs greater than 1002\n    n = count(student_ids > 1002)\n    allocate(filtered_ids(n))\n    filtered_ids = pack(student_ids, student_ids > 1002)\n\n    ! Output the filtered IDs\n    do i = 1, size(filtered_ids)\n        print *, filtered_ids(i)\n    end do\n\n    ! Deallocate arrays\n    deallocate(student_ids)\n    deallocate(filtered_ids)\n\nend program student_ids\n```"
  },
  {
    "task": "Write a program to check if a set of strings is a superset of another set.",
    "code": "```fortran\nprogram set_superset_check\n    implicit none\n    character(len=*), parameter :: set1(*) = ['apple', 'banana', 'cherry']\n    character(len=*), parameter :: set2(*) = ['apple', 'banana']\n    logical :: is_superset\n    integer :: i, found\n\n    is_superset = .true.\n    do i = 1, size(set2)\n        found = 0\n        found = count(set1 == set2(i))\n        if (found == 0) then\n            is_superset = .false.\n            exit\n        end if\n    end do\n\n    if (is_superset) then\n        print *, \"Set1 is a superset of Set2\"\n    else\n        print *, \"Set1 is not a superset of Set2\"\n    end if\nend program set_superset_check\n```"
  },
  {
    "task": "Create a set of unique words from a text file.",
    "code": "```fortran\nprogram unique_words\n    implicit none\n    character(len=100) :: line\n    character(len=20), allocatable :: words(:)\n    character(len=20), allocatable :: unique_words(:)\n    integer :: i, n, num_words\n    logical :: is_unique\n\n    open(unit=10, file='textfile.txt', status='old', action='read')\n    allocate(words(0))\n    num_words = 0\n\n    do\n        read(10, '(A)', iostat=n) line\n        if (n /= 0) exit\n        call extract_words(line, words, num_words)\n    end do\n    close(10)\n\n    call collect_unique_words(words, num_words, unique_words)\n\ncontains\n\n    subroutine extract_words(line, words, num_words)\n        character(len=*), intent(in) :: line\n        character(len=20), allocatable, intent(inout) :: words(:)\n        integer, intent(inout) :: num_words\n        character(len=20) :: word\n        integer :: pos, start, end\n\n        pos = 1\n        do while (pos <= len_trim(line))\n            call scan_word(line, pos, start, end)\n            if (start > 0) then\n                word = adjustl(line(start:end))\n                num_words = num_words + 1\n                if (num_words > size(words)) then\n                    allocate(character(len=20) :: words(num_words * 2))\n                end if\n                words(num_words) = word\n            end if\n        end do\n    end subroutine extract_words\n\n    subroutine scan_word(line, pos, start, end)\n        character(len=*), intent(in) :: line\n        integer, intent(inout) :: pos, start, end\n        integer :: i\n\n        start = 0\n        end = 0\n        do i = pos, len_trim(line)\n            if (line(i:i) /= ' ') then\n                if (start == 0) start = i\n                end = i\n            else if (start > 0) then\n                exit\n            end if\n        end do\n        pos = end + 1\n    end subroutine scan_word\n\n    subroutine collect_unique_words(words, num_words, unique_words)\n        character(len=20), allocatable, intent(in) :: words(:)\n        integer, intent(in) :: num_words\n        character(len=20), allocatable, intent(out) :: unique_words(:)\n        logical :: is_unique\n        integer :: i, j, unique_count\n\n        allocate(unique_words(num_words))\n        unique_count = 0\n\n        do i = 1, num_words\n            is_unique = .true.\n            do j = 1, unique_count\n                if (trim(words(i)) == trim(unique_words(j))) then\n                    is_unique = .false.\n                    exit\n                end if\n            end do\n            if (is_unique) then\n                unique_count = unique_count + 1\n                unique_words(unique_count) = words(i)\n            end if\n        end do\n\n        if (unique_count < num_words) then\n            allocate(character(len=20) :: unique_words(unique_count))\n            unique_words = unique_words(1:unique_count)\n        end if\n    end subroutine collect_unique_words\n\nend program unique_words\n```"
  },
  {
    "task": "Implement a set to store unique project identifiers and demonstrate membership testing.",
    "code": "```fortran\nprogram project_identifiers\n    implicit none\n    integer, parameter :: max_projects = 100\n    integer :: project_ids(max_projects)\n    integer :: num_projects, pid, i\n    logical :: is_member\n\n    num_projects = 0\n\n    ! Add some project identifiers\n    call add_project_id(101)\n    call add_project_id(202)\n    call add_project_id(303)\n    call add_project_id(101)  ! Duplicate, should not be added\n\n    ! Test membership\n    pid = 202\n    is_member = test_membership(pid)\n    print *, 'Is Project ID', pid, 'in set?', is_member\n\n    pid = 404\n    is_member = test_membership(pid)\n    print *, 'Is Project ID', pid, 'in set?', is_member\n\ncontains\n\n    subroutine add_project_id(new_id)\n        integer, intent(in) :: new_id\n        integer :: j\n        logical :: already_exists\n\n        already_exists = .false.\n        do j = 1, num_projects\n            if (project_ids(j) == new_id) then\n                already_exists = .true.\n                exit\n            end if\n        end do\n\n        if (.not. already_exists .and. num_projects < max_projects) then\n            num_projects = num_projects + 1\n            project_ids(num_projects) = new_id\n        end if\n    end subroutine add_project_id\n\n    function test_membership(id) result(is_in_set)\n        integer, intent(in) :: id\n        logical :: is_in_set\n        integer :: j\n\n        is_in_set = .false.\n        do j = 1, num_projects\n            if (project_ids(j) == id) then\n                is_in_set = .true.\n                exit\n            end if\n        end do\n    end function test_membership\n\nend program project_identifiers\n```"
  },
  {
    "task": "Create a set and demonstrate the `symmetric_difference_update` method.",
    "code": "```fortran\nprogram symmetric_difference_update_demo\n    implicit none\n    integer, parameter :: set_size = 6\n    integer :: set1(set_size) = [1, 2, 3, 4, 5, 6]\n    integer :: set2(set_size) = [4, 5, 6, 7, 8, 9]\n    integer :: i, j, n\n    logical :: found\n\n    n = set_size\n    do i = 1, n\n        found = .false.\n        do j = 1, n\n            if (set1(i) == set2(j)) then\n                found = .true.\n                exit\n            end if\n        end do\n        if (found) then\n            set1(i) = 0\n        end if\n    end do\n\n    do i = 1, n\n        found = .false.\n        do j = 1, n\n            if (set2(i) == set1(j)) then\n                found = .true.\n                exit\n            end if\n        end do\n        if (.not. found) then\n            write(*, *) set2(i)\n        end if\n    end do\n\n    do i = 1, n\n        if (set1(i) /= 0) then\n            write(*, *) set1(i)\n        end if\n    end do\nend program symmetric_difference_update_demo\n```"
  },
  {
    "task": "Write a function to remove all elements from a set that are also in another set.",
    "code": "```fortran\nmodule set_operations\n  implicit none\ncontains\n\n  subroutine remove_elements(set1, set2)\n    integer, allocatable :: set1(:)\n    integer, allocatable :: set2(:)\n    integer :: i, j, n\n\n    n = size(set1)\n    do i = 1, n\n      do j = 1, size(set2)\n        if (set1(i) == set2(j)) then\n          set1(i) = -1\n          exit\n        end if\n      end do\n    end do\n\n    set1 = pack(set1, set1 /= -1)\n  end subroutine remove_elements\n\nend module set_operations\n```"
  },
  {
    "task": "Use a set to keep track of unique error codes from server logs.",
    "code": "```fortran\nprogram unique_error_codes\n  implicit none\n  integer, parameter :: max_errors = 1000\n  integer :: error_codes(max_errors)\n  integer :: unique_errors(max_errors)\n  integer :: num_errors, num_unique, i, j\n  logical :: is_unique\n\n  ! Sample error codes from server logs\n  error_codes = (/ 404, 500, 404, 403, 500, 200, 301 /)\n  num_errors = 7\n\n  num_unique = 0\n  do i = 1, num_errors\n    is_unique = .true.\n    do j = 1, num_unique\n      if (error_codes(i) == unique_errors(j)) then\n        is_unique = .false.\n        exit\n      end if\n    end do\n    if (is_unique) then\n      num_unique = num_unique + 1\n      unique_errors(num_unique) = error_codes(i)\n    end if\n  end do\n\n  ! Output unique error codes\n  print *, \"Unique Error Codes:\"\n  do i = 1, num_unique\n    print *, unique_errors(i)\n  end do\nend program unique_error_codes\n```"
  },
  {
    "task": "Create a set and demonstrate how to find all unique pairs of elements.",
    "code": "```fortran\nprogram unique_pairs\n    implicit none\n    integer, parameter :: n = 5\n    integer :: i, j\n    integer, dimension(n) :: elements = [1, 2, 3, 2, 4]\n    integer, dimension(:), allocatable :: unique_elements\n    integer :: num_unique, count\n    logical :: is_unique\n\n    num_unique = 0\n    allocate(unique_elements(n))\n\n    ! Find unique elements\n    do i = 1, n\n        is_unique = .true.\n        do j = 1, num_unique\n            if (elements(i) == unique_elements(j)) then\n                is_unique = .false.\n                exit\n            end if\n        end do\n        if (is_unique) then\n            num_unique = num_unique + 1\n            unique_elements(num_unique) = elements(i)\n        end if\n    end do\n\n    ! Print all unique pairs\n    print *, \"Unique pairs:\"\n    do i = 1, num_unique - 1\n        do j = i + 1, num_unique\n            print *, unique_elements(i), unique_elements(j)\n        end do\n    end do\n\n    deallocate(unique_elements)\nend program unique_pairs\n```"
  },
  {
    "task": "Write a program to find the smallest element in a set of integers.",
    "code": "```fortran\nprogram find_smallest\n    implicit none\n    integer, allocatable :: numbers(:)\n    integer :: n, i, smallest\n\n    print *, 'Enter the number of elements:'\n    read *, n\n\n    allocate(numbers(n))\n    print *, 'Enter the elements:'\n    do i = 1, n\n        read *, numbers(i)\n    end do\n\n    smallest = numbers(1)\n    do i = 2, n\n        if (numbers(i) < smallest) then\n            smallest = numbers(i)\n        end if\n    end do\n\n    print *, 'The smallest element is:', smallest\n\n    deallocate(numbers)\nend program find_smallest\n```"
  },
  {
    "task": "Create a set and demonstrate the `add` method with multiple elements.",
    "code": "```fortran\nprogram set_usage\n    implicit none\n    integer, allocatable :: set(:)\n    integer :: i, number\n    logical :: exists\n\n    set = [1, 2, 3]  ! Initial set with some elements\n\n    ! Add elements to the set\n    do i = 4, 6\n        call add_to_set(set, i)\n    end do\n\n    contains\n\n    subroutine add_to_set(s, num)\n        integer, allocatable, intent(inout) :: s(:)\n        integer, intent(in) :: num\n        logical :: found\n        integer :: i\n\n        found = .false.\n        do i = 1, size(s)\n            if (s(i) == num) then\n                found = .true.\n                exit\n            end if\n        end do\n\n        if (.not. found) then\n            s = [s, num]\n        end if\n    end subroutine add_to_set\n\nend program set_usage\n```"
  },
  {
    "task": "Implement a set to manage a collection of unique author names.",
    "code": "```fortran\nmodule author_set\n  implicit none\n  private\n  public :: add_author, remove_author, is_author_in_set, print_authors\n\n  integer, parameter :: max_authors = 100\n  character(len=100), allocatable :: authors(:)\n  integer :: author_count = 0\n\ncontains\n\n  subroutine add_author(name)\n    character(len=100), intent(in) :: name\n    integer :: i\n\n    if (.not. is_author_in_set(name)) then\n      if (author_count >= max_authors) then\n        print *, \"Author set is full.\"\n        return\n      end if\n      author_count = author_count + 1\n      if (.not. allocated(authors)) allocate(authors(max_authors))\n      authors(author_count) = name\n    end if\n  end subroutine add_author\n\n  subroutine remove_author(name)\n    character(len=100), intent(in) :: name\n    integer :: i, j\n\n    do i = 1, author_count\n      if (authors(i) == name) then\n        do j = i, author_count - 1\n          authors(j) = authors(j + 1)\n        end do\n        author_count = author_count - 1\n        exit\n      end if\n    end do\n  end subroutine remove_author\n\n  logical function is_author_in_set(name)\n    character(len=100), intent(in) :: name\n    integer :: i\n\n    is_author_in_set = .false.\n    do i = 1, author_count\n      if (authors(i) == name) then\n        is_author_in_set = .true.\n        return\n      end if\n    end do\n  end function is_author_in_set\n\n  subroutine print_authors()\n    integer :: i\n\n    if (author_count == 0) then\n      print *, \"No authors in the set.\"\n    else\n      print *, \"Authors in the set:\"\n      do i = 1, author_count\n        print *, authors(i)\n      end do\n    end if\n  end subroutine print_authors\n\nend module author_set\n```"
  },
  {
    "task": "Create a set of integers and demonstrate converting it to a sorted list.",
    "code": "```fortran\nprogram set_to_sorted_list\n    implicit none\n    integer, allocatable :: int_set(:)\n    integer, allocatable :: sorted_list(:)\n    integer :: i\n\n    int_set = [7, 3, 5, 2, 9, 1]  ! Example set of integers\n\n    call sort_set(int_set, sorted_list)\n\n    print*, \"Sorted list: \", sorted_list\n\ncontains\n\n    subroutine sort_set(set, sorted)\n        integer, intent(in) :: set(:)\n        integer, allocatable, intent(out) :: sorted(:)\n        integer :: n\n\n        n = size(set)\n        allocate(sorted(n))\n        sorted = set\n\n        call quicksort(sorted, 1, n)\n\n    end subroutine sort_set\n\n    subroutine quicksort(arr, low, high)\n        integer, intent(inout) :: arr(:)\n        integer, intent(in) :: low, high\n        integer :: pivot, i, j, temp\n\n        if (low < high) then\n            pivot = arr(high)\n            i = low - 1\n\n            do j = low, high - 1\n                if (arr(j) <= pivot) then\n                    i = i + 1\n                    temp = arr(i)\n                    arr(i) = arr(j)\n                    arr(j) = temp\n                end if\n            end do\n\n            temp = arr(i + 1)\n            arr(i + 1) = arr(high)\n            arr(high) = temp\n\n            call quicksort(arr, low, i)\n            call quicksort(arr, i + 2, high)\n        end if\n    end subroutine quicksort\nend program set_to_sorted_list\n```"
  },
  {
    "task": "Write a function that returns the union of multiple sets.",
    "code": "```fortran\nmodule set_operations\n  implicit none\ncontains\n  function union_of_sets(sets) result(union_set)\n    implicit none\n    type(set_type)\n      integer :: elements(:)\n    end type set_type\n    type(set_type), dimension(:), intent(in) :: sets\n    integer, allocatable :: all_elements(:)\n    integer :: i, j, n\n    type(set_type) :: union_set\n    integer, allocatable :: temp(:)\n    \n    ! Concatenate all elements from the input sets\n    n = 0\n    do i = 1, size(sets)\n      n = n + size(sets(i)%elements)\n    end do\n    allocate(all_elements(n))\n    n = 0\n    do i = 1, size(sets)\n      do j = 1, size(sets(i)%elements)\n        n = n + 1\n        all_elements(n) = sets(i)%elements(j)\n      end do\n    end do\n\n    ! Remove duplicates by creating a set from the concatenated elements\n    call unique_elements(all_elements, temp)\n    union_set%elements = temp\n  end function union_of_sets\n\n  subroutine unique_elements(arr, unique_arr)\n    integer, intent(in) :: arr(:)\n    integer, allocatable, intent(out) :: unique_arr(:)\n    integer :: i, j, count, n\n    logical :: is_unique\n\n    n = size(arr)\n    allocate(unique_arr(n))\n    count = 0\n\n    do i = 1, n\n      is_unique = .true.\n      do j = 1, count\n        if (arr(i) == unique_arr(j)) then\n          is_unique = .false.\n          exit\n        end if\n      end do\n      if (is_unique) then\n        count = count + 1\n        unique_arr(count) = arr(i)\n      end if\n    end do\n    call move_alloc(unique_arr(1:count), unique_arr)\n  end subroutine unique_elements\nend module set_operations\n```"
  },
  {
    "task": "Use a set to identify unique characters in a string.",
    "code": "```fortran\nprogram unique_characters\n    implicit none\n    character(len=100) :: input_string\n    character(len=1), allocatable :: unique_chars(:)\n    integer :: i, j, count\n    logical :: is_unique\n\n    print *, \"Enter a string:\"\n    read(*,'(A)') input_string\n\n    allocate(unique_chars(0))\n\n    do i = 1, len_trim(input_string)\n        is_unique = .true.\n        do j = 1, size(unique_chars)\n            if (input_string(i:i) == unique_chars(j)) then\n                is_unique = .false.\n                exit\n            end if\n        end do\n        if (is_unique) then\n            count = size(unique_chars)\n            call move_alloc(unique_chars, unique_chars, source=[unique_chars, input_string(i:i)])\n        end if\n    end do\n\n    print *, \"Unique characters:\"\n    do i = 1, size(unique_chars)\n        print *, unique_chars(i)\n    end do\n\n    deallocate(unique_chars)\nend program unique_characters\n```"
  },
  {
    "task": "Create a set of prime numbers and demonstrate basic set operations.",
    "code": "```fortran\nprogram prime_set_operations\n  implicit none\n  integer, parameter :: max_val = 50\n  integer :: i, j\n  logical :: is_prime\n  integer, dimension(:), allocatable :: prime_numbers\n  integer :: prime_count = 0\n\n  allocate(prime_numbers(max_val))\n\n  ! Find prime numbers up to max_val\n  do i = 2, max_val\n    is_prime = .true.\n    do j = 2, int(sqrt(real(i)))\n      if (mod(i, j) == 0) then\n        is_prime = .false.\n        exit\n      end if\n    end do\n    if (is_prime) then\n      prime_count = prime_count + 1\n      prime_numbers(prime_count) = i\n    end if\n  end do\n\n  ! Deallocate unused space\n  deallocate(prime_numbers, stat=i)\n  allocate(prime_numbers(prime_count))\n  prime_numbers = [(i, i = 2, max_val, is_prime)]\n\n  ! Demonstrate basic set operations\n  print *, \"Prime numbers up to \", max_val, \":\"\n  print *, prime_numbers\n\n  ! Example of set operation: Union and Intersection\n  print *, \"Union with {2, 3, 5, 7, 11}:\"\n  print *, unique_union(prime_numbers, [2, 3, 5, 7, 11])\n\n  print *, \"Intersection with {2, 3, 5, 7, 11}:\"\n  print *, intersection(prime_numbers, [2, 3, 5, 7, 11])\n\ncontains\n\n  function unique_union(set1, set2) result(union_set)\n    integer, dimension(:), intent(in) :: set1, set2\n    integer, allocatable :: union_set(:)\n    integer :: temp_set(size(set1) + size(set2))\n    integer :: i, count\n\n    temp_set(1:size(set1)) = set1\n    count = size(set1)\n\n    do i = 1, size(set2)\n      if (.not. any(temp_set(1:count) == set2(i))) then\n        count = count + 1\n        temp_set(count) = set2(i)\n      end if\n    end do\n\n    allocate(union_set(count))\n    union_set = temp_set(1:count)\n  end function unique_union\n\n  function intersection(set1, set2) result(intersect_set)\n    integer, dimension(:), intent(in) :: set1, set2\n    integer, allocatable :: intersect_set(:)\n    integer :: temp_set(min(size(set1), size(set2)))\n    integer :: i, count\n\n    count = 0\n    do i = 1, size(set1)\n      if (any(set2 == set1(i))) then\n        count = count + 1\n        temp_set(count) = set1(i)\n      end if\n    end do\n\n    allocate(intersect_set(count))\n    intersect_set = temp_set(1:count)\n  end function intersection\n\nend program prime_set_operations\n```"
  },
  {
    "task": "Create a set and demonstrate how to check for non-membership.",
    "code": "```fortran\nprogram set_usage\n    implicit none\n    integer, allocatable :: myset(:)\n    integer :: element\n    logical :: is_member\n\n    ! Initialize the set\n    myset = [1, 2, 3, 4, 5]\n\n    ! Element to check\n    element = 6\n\n    ! Check for non-membership\n    is_member = any(myset == element)\n\n    if (.not. is_member) then\n        print *, \"Element is not in the set.\"\n    else\n        print *, \"Element is in the set.\"\n    end if\nend program set_usage\n```"
  },
  {
    "task": "Write a program to find the largest element in a set of numbers.",
    "code": "```fortran\nprogram largest_in_set\n    implicit none\n    integer, parameter :: n = 5\n    integer :: i\n    real :: numbers(n) = [3.5, 7.2, 1.4, 9.8, 6.1]\n    real :: largest\n\n    largest = numbers(1)\n    do i = 2, n\n        if (numbers(i) > largest) then\n            largest = numbers(i)\n        end if\n    end do\n\n    print *, 'The largest number is: ', largest\nend program largest_in_set\n```"
  },
  {
    "task": "Create a set of unique movie titles and demonstrate membership testing.",
    "code": "```fortran\nprogram unique_movie_titles\n    implicit none\n    character(len=100), allocatable :: movies(:)\n    character(len=100) :: title\n    integer :: i, num_movies\n    logical :: is_member\n\n    num_movies = 5\n    allocate(movies(num_movies))\n    \n    movies(1) = 'Inception'\n    movies(2) = 'The Matrix'\n    movies(3) = 'Interstellar'\n    movies(4) = 'Inception'  ! Duplicate entry\n    movies(5) = 'The Godfather'\n\n    call remove_duplicates(movies, num_movies)\n\n    title = 'The Matrix'\n    is_member = .false.\n    do i = 1, num_movies\n        if (movies(i) == title) then\n            is_member = .true.\n            exit\n        end if\n    end do\n\n    if (is_member) then\n        print *, title, 'is in the set.'\n    else\n        print *, title, 'is not in the set.'\n    end if\n\ncontains\n\n    subroutine remove_duplicates(arr, n)\n        character(len=*), intent(inout) :: arr(:)\n        integer, intent(inout) :: n\n        integer :: i, j, k\n\n        do i = 1, n - 1\n            do j = i + 1, n\n                if (arr(i) == arr(j) .and. arr(i) /= \"\") then\n                    arr(j) = \"\"\n                end if\n            end do\n        end do\n\n        k = 1\n        do i = 1, n\n            if (arr(i) /= \"\") then\n                arr(k) = arr(i)\n                k = k + 1\n            end if\n        end do\n\n        n = k - 1\n        call move_alloc(arr(1:n), arr)\n    end subroutine remove_duplicates\n\nend program unique_movie_titles\n```"
  },
  {
    "task": "Implement a set to store unique keys from a dictionary.",
    "code": "```fortran\nprogram set_usage\n    implicit none\n    integer, parameter :: n = 5\n    integer :: i\n    integer :: keys(n) = [1, 2, 3, 2, 4]\n    integer :: unique_keys(n)\n    integer :: num_unique = 0\n    logical :: found\n\n    do i = 1, n\n        found = .false.\n        if (num_unique > 0) then\n            if (any(unique_keys(1:num_unique) == keys(i))) cycle\n        end if\n        num_unique = num_unique + 1\n        unique_keys(num_unique) = keys(i)\n    end do\n\n    print *, \"Unique keys:\"\n    print *, unique_keys(1:num_unique)\nend program set_usage\n```"
  },
  {
    "task": "Create a set and demonstrate the `difference_update` method.",
    "code": "```fortran\nprogram set_difference_update\n    implicit none\n    integer, allocatable :: set1(:), set2(:)\n    integer :: i, j\n    logical :: found\n\n    set1 = [1, 2, 3, 4, 5]\n    set2 = [3, 4, 6, 7]\n\n    do i = 1, size(set2)\n        found = .false.\n        do j = 1, size(set1)\n            if (set2(i) == set1(j)) then\n                set1(j) = 0\n                found = .true.\n                exit\n            end if\n        end do\n    end do\n\n    ! Remove all zeros from set1\n    set1 = pack(set1, set1 /= 0)\n\n    print *, \"Set1 after difference update:\", set1\n\nend program set_difference_update\n```"
  },
  {
    "task": "Write a function to merge multiple sets into a single set.",
    "code": "```fortran\nmodule set_operations\n  implicit none\ncontains\n  function merge_sets(sets) result(merged_set)\n    type(set_type), dimension(:), intent(in) :: sets\n    type(set_type) :: merged_set\n    integer :: i, j\n\n    call initialize_set(merged_set)\n    do i = 1, size(sets)\n      do j = 1, sets(i)%size\n        call add_to_set(merged_set, sets(i)%elements(j))\n      end do\n    end do\n  end function merge_sets\n\n  subroutine initialize_set(s)\n    type(set_type), intent(out) :: s\n    s%size = 0\n  end subroutine initialize_set\n\n  subroutine add_to_set(s, element)\n    type(set_type), intent(inout) :: s\n    integer, intent(in) :: element\n    integer :: pos\n    if (.not. is_element_of_set(s, element)) then\n      s%size = s%size + 1\n      s%elements(s%size) = element\n    end if\n  end subroutine add_to_set\n\n  logical function is_element_of_set(s, element)\n    type(set_type), intent(in) :: s\n    integer, intent(in) :: element\n    integer :: i\n    is_element_of_set = .false.\n    do i = 1, s%size\n      if (s%elements(i) == element) then\n        is_element_of_set = .true.\n        exit\n      end if\n    end do\n  end function is_element_of_set\n\n  type set_type\n    integer, dimension(100) :: elements\n    integer :: size\n  end type set_type\n\nend module set_operations\n```"
  },
  {
    "task": "Use a set to filter out duplicate letters from a word.",
    "code": "```fortran\nprogram remove_duplicates\n    implicit none\n    character(len=*), parameter :: word = 'example'\n    character(len=26) :: result\n    integer :: i, idx\n    logical, dimension(26) :: used = .false.\n\n    result = ''\n    idx = 0\n    do i = 1, len(word)\n        if (.not. used(iachar(word(i:i)) - iachar('a') + 1)) then\n            idx = idx + 1\n            result(idx:idx) = word(i:i)\n            used(iachar(word(i:i)) - iachar('a') + 1) = .true.\n        end if\n    end do\n\n    print *, trim(result(:idx))\nend program remove_duplicates\n```"
  },
  {
    "task": "Create a set and demonstrate the use of the `isdisjoint` method.",
    "code": "```fortran\nprogram set_usage_example\n  implicit none\n  integer, allocatable :: set1(:), set2(:)\n  integer :: i\n\n  ! Initialize two sets\n  allocate(set1(5))\n  set1 = [1, 2, 3, 4, 5]\n\n  allocate(set2(3))\n  set2 = [6, 7, 8]\n\n  ! Check if two sets are disjoint\n  if (.not. any([(set1(i) == set2, i = 1, size(set1))])) then\n    print *, \"Sets are disjoint\"\n  else\n    print *, \"Sets are not disjoint\"\n  end if\n\nend program set_usage_example\n```"
  },
  {
    "task": "Write a program to find all elements that are only in one of two sets.",
    "code": "```fortran\nprogram unique_elements\n    implicit none\n    integer, allocatable :: set1(:), set2(:)\n    integer, allocatable :: result(:)\n    integer :: i, j, n1, n2, count\n\n    ! Example sets\n    allocate(set1(5))\n    allocate(set2(5))\n    set1 = [1, 2, 3, 4, 5]\n    set2 = [4, 5, 6, 7, 8]\n\n    ! Calculate result size (worst case, all unique)\n    allocate(result(size(set1) + size(set2)))\n    count = 0\n\n    ! Find elements unique to set1\n    do i = 1, size(set1)\n        if (.not. any(set1(i) == set2)) then\n            count = count + 1\n            result(count) = set1(i)\n        end if\n    end do\n\n    ! Find elements unique to set2\n    do j = 1, size(set2)\n        if (.not. any(set2(j) == set1)) then\n            count = count + 1\n            result(count) = set2(j)\n        end if\n    end do\n\n    ! Output unique elements\n    print *, 'Unique elements: ', result(1:count)\n\n    ! Deallocate arrays\n    deallocate(set1, set2, result)\nend program unique_elements\n```"
  },
  {
    "task": "Create a set of unique book authors and demonstrate basic set operations.",
    "code": "```fortran\nprogram set_usage\n    implicit none\n    type :: AuthorSet\n        character(len=:), allocatable :: authors(:)\n    contains\n        procedure :: add_author\n        procedure :: remove_author\n        procedure :: contains_author\n        procedure :: print_authors\n    end type AuthorSet\n\n    type(AuthorSet) :: authorSet\n\n    call authorSet%add_author(\"J.K. Rowling\")\n    call authorSet%add_author(\"George R.R. Martin\")\n    call authorSet%add_author(\"J.R.R. Tolkien\")\n    call authorSet%add_author(\"J.K. Rowling\")  ! Attempt to add a duplicate\n\n    call authorSet%print_authors()\n\n    print *, \"Contains 'J.K. Rowling': \", authorSet%contains_author(\"J.K. Rowling\")\n    print *, \"Contains 'Isaac Asimov': \", authorSet%contains_author(\"Isaac Asimov\")\n\n    call authorSet%remove_author(\"George R.R. Martin\")\n    call authorSet%print_authors()\n    \ncontains\n    subroutine add_author(this, author)\n        class(AuthorSet), intent(inout) :: this\n        character(len=*), intent(in) :: author\n        integer :: i\n\n        if (.not. this%contains_author(author)) then\n            if (allocated(this%authors)) then\n                i = size(this%authors) + 1\n                call move_alloc(this%authors, this%authors, mold=[this%authors, author])\n            else\n                allocate(this%authors(1))\n                i = 1\n            end if\n            this%authors(i) = author\n        end if\n    end subroutine add_author\n\n    subroutine remove_author(this, author)\n        class(AuthorSet), intent(inout) :: this\n        character(len=*), intent(in) :: author\n        integer :: i, n\n\n        if (allocated(this%authors)) then\n            n = size(this%authors)\n            do i = 1, n\n                if (this%authors(i) == author) then\n                    this%authors(i:n-1) = this%authors(i+1:n)\n                    allocate(this%authors(n-1), source=this%authors(1:n-1))\n                    exit\n                end if\n            end do\n        end if\n    end subroutine remove_author\n\n    logical function contains_author(this, author)\n        class(AuthorSet), intent(in) :: this\n        character(len=*), intent(in) :: author\n        integer :: i\n\n        contains_author = .false.\n        if (allocated(this%authors)) then\n            do i = 1, size(this%authors)\n                if (this%authors(i) == author) then\n                    contains_author = .true.\n                    exit\n                end if\n            end do\n        end if\n    end function contains_author\n\n    subroutine print_authors(this)\n        class(AuthorSet), intent(in) :: this\n        integer :: i\n\n        print *, \"Authors in set:\"\n        if (allocated(this%authors)) then\n            do i = 1, size(this%authors)\n                print *, trim(this%authors(i))\n            end do\n        else\n            print *, \"No authors in set.\"\n        end if\n    end subroutine print_authors\nend program set_usage\n```"
  },
  {
    "task": "Implement a set to store unique phone numbers and check for duplicates.",
    "code": "```fortran\nprogram phone_set\n  implicit none\n  character(len=15) :: phoneNumbers(100)\n  integer :: numPhones = 0\n  character(len=15) :: newPhone\n  logical :: isDuplicate\n  integer :: i\n\n  print *, 'Enter phone numbers (type \"done\" to finish):'\n  do\n    read *, newPhone\n    if (trim(newPhone) == 'done') exit\n    isDuplicate = .false.\n    do i = 1, numPhones\n      if (trim(phoneNumbers(i)) == trim(newPhone)) then\n        isDuplicate = .true.\n        exit\n      end if\n    end do\n    if (.not. isDuplicate) then\n      numPhones = numPhones + 1\n      phoneNumbers(numPhones) = trim(newPhone)\n      print *, 'Added:', trim(newPhone)\n    else\n      print *, 'Duplicate:', trim(newPhone)\n    end if\n  end do\n\n  print *, 'Unique phone numbers:'\n  do i = 1, numPhones\n    print *, trim(phoneNumbers(i))\n  end do\nend program phone_set\n```"
  },
  {
    "task": "Create a set of floating-point numbers and demonstrate rounding each element.",
    "code": "```fortran\nprogram RoundingSet\n  implicit none\n  real, dimension(:), allocatable :: numbers\n  real, dimension(:), allocatable :: roundedNumbers\n  integer :: i\n\n  allocate(numbers(5))\n  numbers = (/3.14159, 2.71828, 1.41421, 1.73205, 0.57721/)\n\n  allocate(roundedNumbers(size(numbers)))\n  do i = 1, size(numbers)\n    roundedNumbers(i) = round(numbers(i))\n  end do\n\n  do i = 1, size(roundedNumbers)\n    print *, roundedNumbers(i)\n  end do\n\nend program RoundingSet\n```"
  },
  {
    "task": "Write a function that returns a set of all vowels present in a given sentence.",
    "code": "```fortran\nmodule vowel_set_module\n    implicit none\ncontains\n    function get_vowel_set(sentence) result(vowels)\n        character(len=*), intent(in) :: sentence\n        character(len=5) :: all_vowels\n        character(len=1), dimension(:), allocatable :: vowels\n        integer :: i, count\n\n        all_vowels = 'aeiou'\n        count = 0\n        allocate(vowels(5))\n        vowels = ' '\n\n        do i = 1, len(sentence)\n            if (index(all_vowels, sentence(i:i)) > 0) then\n                if (index(vowels, sentence(i:i)) == 0) then\n                    count = count + 1\n                    vowels(count:count) = sentence(i:i)\n                end if\n            end if\n        end do\n\n        if (count < 5) then\n            vowels = vowels(:count)\n        end if\n    end function get_vowel_set\nend module vowel_set_module\n```"
  },
  {
    "task": "Use a set to track unique session IDs for a web application.",
    "code": "```fortran\nprogram track_unique_sessions\n    implicit none\n    integer, parameter :: max_sessions = 1000\n    integer :: session_ids(max_sessions)\n    integer :: session_id, n_sessions\n    logical :: is_unique\n    integer :: i\n\n    ! Initialize the number of unique sessions\n    n_sessions = 0\n\n    ! Example: Simulate adding some session IDs\n    do\n        ! Read session ID\n        read(*,*) session_id\n\n        ! Check if session ID is already in the set\n        is_unique = .true.\n        do i = 1, n_sessions\n            if (session_ids(i) == session_id) then\n                is_unique = .false.\n                exit\n            end if\n        end do\n\n        ! Add to set if unique\n        if (is_unique) then\n            n_sessions = n_sessions + 1\n            if (n_sessions <= max_sessions) then\n                session_ids(n_sessions) = session_id\n            else\n                print *, \"Maximum session limit reached.\"\n                exit\n            end if\n        end if\n\n        ! Exit condition or continue loop\n        if (session_id < 0) exit  ! Example exit condition\n    end do\n\n    ! Display unique session IDs\n    print *, \"Unique session IDs:\"\n    do i = 1, n_sessions\n        print *, session_ids(i)\n    end do\n\nend program track_unique_sessions\n```"
  },
  {
    "task": "Create a set of unique city names and demonstrate set operations with it.",
    "code": "```fortran\nprogram city_set_example\n    implicit none\n    type :: city_set\n        character(len=:), allocatable :: names(:)\n    contains\n        procedure :: add => add_city\n        procedure :: contains => contains_city\n        procedure :: remove => remove_city\n        procedure :: display => display_set\n    end type city_set\n\n    type(city_set) :: cities\n\n    call cities%add('New York')\n    call cities%add('Los Angeles')\n    call cities%add('Chicago')\n    call cities%add('New York')  ! Duplicate entry\n    call cities%display()\n\n    if (cities%contains('Chicago')) then\n        print *, 'Chicago is in the set.'\n    end if\n\n    call cities%remove('Chicago')\n    call cities%display()\n\ncontains\n\n    subroutine add_city(this, name)\n        class(city_set), intent(inout) :: this\n        character(len=*), intent(in) :: name\n        if (.not. this%contains(name)) then\n            if (allocated(this%names)) then\n                this%names = [this%names, name]\n            else\n                allocate(character(len=len(name)) :: this%names(1))\n                this%names(1) = name\n            end if\n        end if\n    end subroutine add_city\n\n    function contains_city(this, name) result(is_present)\n        class(city_set), intent(in) :: this\n        character(len=*), intent(in) :: name\n        logical :: is_present\n        is_present = any(this%names == name)\n    end function contains_city\n\n    subroutine remove_city(this, name)\n        class(city_set), intent(inout) :: this\n        character(len=*), intent(in) :: name\n        integer :: i\n        if (this%contains(name)) then\n            do i = 1, size(this%names)\n                if (this%names(i) == name) then\n                    this%names(i:) = this%names(i+1:)\n                    this%names = this%names(:size(this%names)-1)\n                    exit\n                end if\n            end do\n        end if\n    end subroutine remove_city\n\n    subroutine display_set(this)\n        class(city_set), intent(in) :: this\n        integer :: i\n        print *, 'City Set: '\n        do i = 1, size(this%names)\n            print *, this%names(i)\n        end do\n    end subroutine display_set\n\nend program city_set_example\n```"
  },
  {
    "task": "Write a program to find the common elements in three sets.",
    "code": "```fortran\nprogram find_common_elements\n    implicit none\n    integer, parameter :: n = 10\n    integer :: i\n    integer, dimension(n) :: set1, set2, set3, common\n    logical, dimension(n) :: check\n    integer :: count\n\n    ! Initialize the sets\n    set1 = (/1, 2, 3, 4, 5, 6, 7, 8, 9, 10/)\n    set2 = (/5, 6, 7, 8, 9, 10, 11, 12, 13, 14/)\n    set3 = (/8, 9, 10, 11, 12, 13, 14, 15, 16, 17/)\n\n    ! Initialize common element check array\n    check = .false.\n    count = 0\n\n    ! Find common elements\n    do i = 1, n\n        if (any(set1(i) == set2(:)) .and. any(set1(i) == set3(:))) then\n            count = count + 1\n            common(count) = set1(i)\n            check(count) = .true.\n        end if\n    end do\n\n    ! Print common elements\n    print *, 'Common elements:'\n    do i = 1, n\n        if (check(i)) print *, common(i)\n    end do\nend program find_common_elements\n```"
  },
  {
    "task": "Create a set and demonstrate how to remove an element by its value.",
    "code": "```fortran\nprogram set_usage\n    implicit none\n    integer, allocatable :: mySet(:)\n    integer :: i, n, value, index, found\n\n    n = 5\n    allocate(mySet(n))\n    mySet = [1, 2, 3, 4, 5]\n\n    ! Element to remove\n    value = 3\n    \n    ! Find the index of the value to remove\n    found = 0\n    do i = 1, size(mySet)\n        if (mySet(i) == value) then\n            index = i\n            found = 1\n            exit\n        end if\n    end do\n\n    ! Remove the element if found\n    if (found == 1) then\n        mySet(index:) = [mySet(index+1:), -1]\n        mySet = mySet(1:n-1)\n    end if\n\n    ! Print the set after removal\n    print *, mySet\nend program set_usage\n```"
  },
  {
    "task": "Implement a set to store a collection of unique ISBN numbers.",
    "code": "```fortran\nmodule isbn_set_module\n  implicit none\n  private\n  public :: isbn_set_t, add_isbn, contains_isbn\n\n  type :: isbn_set_t\n    character(len=:), allocatable :: isbns(:)\n  contains\n    procedure :: add => add_isbn\n    procedure :: contains => contains_isbn\n  end type isbn_set_t\n\ncontains\n\n  subroutine add_isbn(this, isbn)\n    class(isbn_set_t), intent(inout) :: this\n    character(len=*), intent(in) :: isbn\n    if (.not. contains_isbn(this, isbn)) then\n      this%isbns = [this%isbns, isbn]\n    end if\n  end subroutine add_isbn\n\n  logical function contains_isbn(this, isbn)\n    class(isbn_set_t), intent(in) :: this\n    character(len=*), intent(in) :: isbn\n    contains_isbn = any(this%isbns == isbn)\n  end function contains_isbn\n\nend module isbn_set_module\n\nprogram main\n  use isbn_set_module\n  implicit none\n\n  type(isbn_set_t) :: my_isbn_set\n\n  call my_isbn_set%add('978-3-16-148410-0')\n  call my_isbn_set%add('978-1-4028-9462-6')\n  call my_isbn_set%add('978-3-16-148410-0')  ! duplicate, will not be added\n\n  if (my_isbn_set%contains('978-3-16-148410-0')) then\n    print *, 'ISBN exists in the set.'\n  else\n    print *, 'ISBN does not exist in the set.'\n  end if\n\nend program main\n```"
  },
  {
    "task": "Create a set and demonstrate the `intersection_update` method.",
    "code": "```fortran\nprogram set_intersection_update\n    implicit none\n    integer, allocatable :: set1(:), set2(:), intersection(:)\n    integer :: i, j, n1, n2\n\n    ! Initialize two sets\n    set1 = [1, 2, 3, 4, 5]\n    set2 = [3, 4, 5, 6, 7]\n\n    ! Find intersection and update set1\n    n1 = size(set1)\n    n2 = size(set2)\n    allocate(intersection(min(n1, n2)))\n    j = 0\n    do i = 1, n1\n        if (any(set1(i) == set2)) then\n            j = j + 1\n            intersection(j) = set1(i)\n        end if\n    end do\n    if (j > 0) then\n        set1 = intersection(1:j)\n    else\n        deallocate(set1)\n    end if\n    deallocate(intersection)\n\n    ! Output the updated set1\n    print *, \"Updated set1 after intersection_update: \", set1\n\nend program set_intersection_update\n```"
  },
  {
    "task": "Write a function to generate a set of all unique elements in a list.",
    "code": "```fortran\nfunction unique_elements(arr) result(unique_set)\n    integer, intent(in) :: arr(:)\n    integer, allocatable :: unique_set(:)\n    integer :: temp_set(size(arr))\n    integer :: count, i, j, n\n\n    count = 0\n    do i = 1, size(arr)\n        if (.not. any(temp_set(1:count) == arr(i))) then\n            count = count + 1\n            temp_set(count) = arr(i)\n        end if\n    end do\n\n    allocate(unique_set(count))\n    unique_set = temp_set(1:count)\n    \nend function\n```"
  },
  {
    "task": "Use a set to determine the unique characters in two strings.",
    "code": "```fortran\nprogram unique_characters\n    implicit none\n    character(len=100) :: str1, str2\n    character(len=1), allocatable :: unique_chars(:)\n    integer :: i, j, k, n, m, unique_count\n    logical :: is_unique\n\n    str1 = \"example string one\"\n    str2 = \"another example\"\n    \n    n = len_trim(str1)\n    m = len_trim(str2)\n    unique_count = 0\n\n    allocate(unique_chars(n+m))\n    \n    do i = 1, n\n        is_unique = .true.\n        do j = 1, unique_count\n            if (str1(i:i) == unique_chars(j)) then\n                is_unique = .false.\n                exit\n            end if\n        end do\n        if (is_unique) then\n            unique_count = unique_count + 1\n            unique_chars(unique_count) = str1(i:i)\n        end if\n    end do\n\n    do i = 1, m\n        is_unique = .true.\n        do j = 1, unique_count\n            if (str2(i:i) == unique_chars(j)) then\n                is_unique = .false.\n                exit\n            end if\n        end do\n        if (is_unique) then\n            unique_count = unique_count + 1\n            unique_chars(unique_count) = str2(i:i)\n        end if\n    end do\n\n    print *, \"Unique Characters: \"\n    do i = 1, unique_count\n        print *, unique_chars(i)\n    end do\n\n    deallocate(unique_chars)\nend program unique_characters\n```"
  },
  {
    "task": "Create a set of unique animal names and demonstrate the `discard` method.",
    "code": "```fortran\nprogram unique_animals\n    implicit none\n    type :: string_set\n        character(len=:), allocatable :: elements(:)\n    contains\n        procedure :: init\n        procedure :: add\n        procedure :: discard\n        procedure :: size\n    end type string_set\n\n    type(string_set) :: animals\n    integer :: n\n\n    call animals%init()\n    call animals%add(\"lion\")\n    call animals%add(\"tiger\")\n    call animals%add(\"bear\")\n    call animals%add(\"lion\")  ! Duplicate will not be added\n\n    print *, \"Initial set size:\", animals%size()\n    call animals%discard(\"tiger\")\n    print *, \"Set size after discarding 'tiger':\", animals%size()\n\ncontains\n\n    subroutine init(this)\n        class(string_set), intent(inout) :: this\n        allocate(this%elements(0))\n    end subroutine init\n\n    subroutine add(this, element)\n        class(string_set), intent(inout) :: this\n        character(len=*), intent(in) :: element\n        integer :: i\n\n        do i = 1, size(this%elements)\n            if (this%elements(i) == element) return\n        end do\n\n        call add_element(this%elements, element)\n    end subroutine add\n\n    subroutine discard(this, element)\n        class(string_set), intent(inout) :: this\n        character(len=*), intent(in) :: element\n        integer :: i, n\n\n        n = size(this%elements)\n        do i = 1, n\n            if (this%elements(i) == element) then\n                call remove_element(this%elements, i)\n                return\n            end if\n        end do\n    end subroutine discard\n\n    function size(this) result(n)\n        class(string_set), intent(in) :: this\n        integer :: n\n        n = size(this%elements)\n    end function size\n\n    subroutine add_element(array, item)\n        character(len=*), allocatable, intent(inout) :: array(:)\n        character(len=*), intent(in) :: item\n        integer :: n\n        character(len=:), allocatable :: new_array(:)\n\n        n = size(array)\n        allocate(character(len=len(item)) :: new_array(n + 1))\n        if (n > 0) new_array(:n) = array\n        new_array(n + 1) = item\n        deallocate(array)\n        array = new_array\n    end subroutine add_element\n\n    subroutine remove_element(array, index)\n        character(len=*), allocatable, intent(inout) :: array(:)\n        integer, intent(in) :: index\n        integer :: n\n        character(len=:), allocatable :: new_array(:)\n\n        n = size(array) - 1\n        if (n < 0) return\n        allocate(character(len=len(array(1))) :: new_array(n))\n        if (index > 1) new_array(:index-1) = array(:index-1)\n        if (index <= n) new_array(index:) = array(index+1:)\n        deallocate(array)\n        array = new_array\n    end subroutine remove_element\n\nend program unique_animals\n```"
  },
  {
    "task": "Write a program to find all elements present in the first set but not in the second.",
    "code": "```fortran\nprogram set_difference\n    implicit none\n    integer, parameter :: n1 = 5, n2 = 5\n    integer :: set1(n1) = [1, 2, 3, 4, 5]\n    integer :: set2(n2) = [3, 4, 6, 7, 8]\n    integer :: i, j\n    logical :: found\n\n    print *, 'Elements in set1 but not in set2:'\n    do i = 1, n1\n        found = .false.\n        do j = 1, n2\n            if (set1(i) == set2(j)) then\n                found = .true.\n                exit\n            end if\n        end do\n        if (.not. found) then\n            print *, set1(i)\n        end if\n    end do\nend program set_difference\n```"
  },
  {
    "task": "Create a set of integers and demonstrate using it to eliminate duplicates from a list.",
    "code": "```fortran\nprogram eliminate_duplicates\n    implicit none\n    integer, allocatable :: list(:), unique_list(:)\n    integer :: i, size_of_list\n    type :: integer_set\n        integer, allocatable :: elements(:)\n    contains\n        procedure :: add_element\n        procedure :: contains\n    end type integer_set\n\n    type(integer_set) :: my_set\n\n    interface\n        subroutine add_element(this, value)\n            import :: integer_set\n            class(integer_set), intent(inout) :: this\n            integer, intent(in) :: value\n        end subroutine add_element\n\n        logical function contains(this, value)\n            import :: integer_set\n            class(integer_set), intent(in) :: this\n            integer, intent(in) :: value\n        end function contains\n    end interface\n\n    allocate(list(10))\n    list = [1, 2, 3, 2, 4, 5, 3, 6, 1, 7]\n    my_set%elements = [integer ::]\n\n    do i = 1, size(list)\n        call my_set%add_element(list(i))\n    end do\n\n    allocate(unique_list(size(my_set%elements)))\n    unique_list = my_set%elements\n\n    print *, \"Original list:\", list\n    print *, \"Unique list:\", unique_list\n\ncontains\n\n    subroutine add_element(this, value)\n        class(integer_set), intent(inout) :: this\n        integer, intent(in) :: value\n        if (.not. contains(this, value)) then\n            if (.not. allocated(this%elements)) then\n                allocate(this%elements(1))\n                this%elements = [value]\n            else\n                this%elements = [this%elements, value]\n            end if\n        end if\n    end subroutine add_element\n\n    logical function contains(this, value)\n        class(integer_set), intent(in) :: this\n        integer, intent(in) :: value\n        integer :: i\n        contains = .false.\n        if (allocated(this%elements)) then\n            do i = 1, size(this%elements)\n                if (this%elements(i) == value) then\n                    contains = .true.\n                    exit\n                end if\n            end do\n        end if\n    end function contains\n\nend program eliminate_duplicates\n```"
  },
  {
    "task": "Implement a set to manage a collection of unique car models.",
    "code": "```fortran\nmodule car_set\n    implicit none\n    type :: CarSet\n        character(len=:), allocatable :: models(:)\n    contains\n        procedure :: add_model\n        procedure :: remove_model\n        procedure :: contains_model\n    end type CarSet\n\ncontains\n\n    subroutine add_model(this, model)\n        class(CarSet), intent(inout) :: this\n        character(len=*), intent(in) :: model\n        integer :: i\n\n        do i = 1, size(this%models)\n            if (this%models(i) == model) return\n        end do\n\n        if (allocated(this%models)) then\n            allocate(character(len=len(model)) :: this%models(size(this%models) + 1))\n            this%models(size(this%models)) = model\n        else\n            allocate(character(len=len(model)) :: this%models(1))\n            this%models = model\n        end if\n    end subroutine add_model\n\n    subroutine remove_model(this, model)\n        class(CarSet), intent(inout) :: this\n        character(len=*), intent(in) :: model\n        integer :: i, j\n\n        do i = 1, size(this%models)\n            if (this%models(i) == model) then\n                do j = i, size(this%models) - 1\n                    this%models(j) = this%models(j + 1)\n                end do\n                if (size(this%models) == 1) then\n                    deallocate(this%models)\n                else\n                    allocate(character(len=len(model)) :: this%models(size(this%models) - 1))\n                end if\n                return\n            end if\n        end do\n    end subroutine remove_model\n\n    logical function contains_model(this, model)\n        class(CarSet), intent(in) :: this\n        character(len=*), intent(in) :: model\n        integer :: i\n\n        contains_model = .false.\n        do i = 1, size(this%models)\n            if (this%models(i) == model) then\n                contains_model = .true.\n                return\n            end if\n        end do\n    end function contains_model\n\nend module car_set\n```"
  },
  {
    "task": "Create a set and demonstrate the use of the `clear` method.",
    "code": "```fortran\nprogram set_demo\n    implicit none\n    integer, allocatable :: my_set(:)\n    integer :: elements(5) = [1, 2, 3, 4, 5]\n\n    ! Initialize the set\n    call set_create(my_set, elements)\n\n    ! Clear the set\n    call set_clear(my_set)\n\ncontains\n\n    subroutine set_create(set, values)\n        integer, allocatable :: set(:)\n        integer, intent(in) :: values(:)\n        allocate(set(size(values)))\n        set = values\n    end subroutine set_create\n\n    subroutine set_clear(set)\n        integer, allocatable :: set(:)\n        if (allocated(set)) deallocate(set)\n    end subroutine set_clear\n\nend program set_demo\n```"
  },
  {
    "task": "Write a function that finds the intersection of multiple sets.",
    "code": "```fortran\nmodule set_operations\n    implicit none\ncontains\n    function set_intersection(n_sets, sets) result(intersection)\n        integer, intent(in) :: n_sets\n        integer, dimension(:,:), intent(in) :: sets\n        integer, dimension(:), allocatable :: intersection\n        integer :: i, j, k, count\n        integer, dimension(:), allocatable :: current_set\n        logical :: found\n\n        if (n_sets == 0) then\n            allocate(intersection(0))\n            return\n        end if\n\n        intersection = sets(:, 1)\n        do i = 2, n_sets\n            current_set = sets(:, i)\n            allocate(intersection(0))\n            count = 0\n            do j = 1, size(current_set)\n                found = any(intersection == current_set(j))\n                if (.not. found) cycle\n                count = count + 1\n                allocate(intersection(count), source=pack(current_set(1:j), current_set(1:j) == current_set(j)))\n            end do\n        end do\n    end function set_intersection\nend module set_operations\n```"
  },
  {
    "task": "Use a set to identify unique words in a paragraph.",
    "code": "```fortran\nprogram unique_words\n    implicit none\n    character(len=1000) :: paragraph\n    character(len=50), allocatable :: words(:)\n    integer :: i, nwords\n    character(len=50) :: word\n    type :: set\n        character(len=50), allocatable :: items(:)\n        integer :: nitems\n    end type set\n    type(set) :: unique_set\n\n    paragraph = \"Fortran is a programming language. It is used for numerical computation in science and engineering. Fortran is powerful.\"\n    call split(paragraph, words, nwords)\n\n    allocate(unique_set%items(nwords))\n    unique_set%nitems = 0\n\n    do i = 1, nwords\n        word = trim(words(i))\n        if (.not. contains(unique_set, word)) then\n            unique_set%nitems = unique_set%nitems + 1\n            unique_set%items(unique_set%nitems) = word\n        end if\n    end do\n\n    do i = 1, unique_set%nitems\n        print *, trim(unique_set%items(i))\n    end do\n\ncontains\n\n    subroutine split(sentence, words, nwords)\n        character(len=*), intent(in) :: sentence\n        character(len=50), allocatable, intent(out) :: words(:)\n        integer, intent(out) :: nwords\n        character(len=50) :: tempword\n        integer :: i, j, len\n        len = len_trim(sentence)\n        nwords = 0\n        allocate(words(len / 2 + 1)) ! Rough estimate\n        j = 0\n        do i = 1, len\n            if (sentence(i:i) /= ' ' .and. sentence(i:i) /= '.' .and. sentence(i:i) /= ',') then\n                tempword(j+1:j+1) = sentence(i:i)\n                j = j + 1\n            else if (j > 0) then\n                nwords = nwords + 1\n                words(nwords) = tempword(1:j)\n                j = 0\n            end if\n        end do\n        if (j > 0) then\n            nwords = nwords + 1\n            words(nwords) = tempword(1:j)\n        end if\n        deallocate(words, mold=words(1:nwords))\n        allocate(words(nwords))\n        words = words(1:nwords)\n    end subroutine split\n\n    logical function contains(set, item)\n        type(set), intent(in) :: set\n        character(len=*), intent(in) :: item\n        integer :: i\n        contains = .false.\n        do i = 1, set%nitems\n            if (trim(set%items(i)) == trim(item)) then\n                contains = .true.\n                exit\n            end if\n        end do\n    end function contains\n\nend program unique_words\n```"
  },
  {
    "task": "Create a set of unique country codes and demonstrate membership testing.",
    "code": "```fortran\nprogram country_codes_set\n    implicit none\n    character(len=3), dimension(:), allocatable :: countryCodes\n    character(len=3) :: code\n    integer :: i, n\n    logical :: isMember\n\n    n = 5\n    allocate(countryCodes(n))\n    countryCodes = [ \"USA\", \"CAN\", \"MEX\", \"FRA\", \"DEU\" ]\n\n    code = \"CAN\"\n    isMember = .false.\n\n    do i = 1, size(countryCodes)\n        if (countryCodes(i) == code) then\n            isMember = .true.\n            exit\n        end if\n    end do\n\n    if (isMember) then\n        print *, code, \"is in the set.\"\n    else\n        print *, code, \"is not in the set.\"\n    end if\nend program country_codes_set\n```"
  },
  {
    "task": "Write a program to find the union of two sets and return it as a list.",
    "code": "```fortran\nprogram union_sets\n  implicit none\n  integer, parameter :: n = 5\n  integer :: set1(n) = [1, 2, 3, 4, 5]\n  integer :: set2(n) = [4, 5, 6, 7, 8]\n  integer, allocatable :: union_set(:)\n  integer :: i, j, k, size\n\n  size = n * 2\n  allocate(union_set(size))\n  k = 0\n\n  do i = 1, n\n     call add_to_union(set1(i))\n  end do\n\n  do i = 1, n\n     call add_to_union(set2(i))\n  end do\n\n  call print_union(k)\n\ncontains\n\n  subroutine add_to_union(element)\n    integer, intent(in) :: element\n    logical :: found\n    integer :: i\n    found = .false.\n    do i = 1, k\n       if (union_set(i) == element) then\n          found = .true.\n          exit\n       endif\n    end do\n    if (.not. found) then\n       k = k + 1\n       union_set(k) = element\n    end if\n  end subroutine add_to_union\n\n  subroutine print_union(num_elements)\n    integer, intent(in) :: num_elements\n    integer :: i\n    print *, \"Union of sets:\"\n    do i = 1, num_elements\n       print *, union_set(i)\n    end do\n  end subroutine print_union\n\nend program union_sets\n```"
  },
  {
    "task": "Create a set and demonstrate using it to check if all elements of another set are present.",
    "code": "```fortran\nprogram set_usage\n    implicit none\n    integer, parameter :: n = 5\n    integer :: i\n    integer, allocatable :: set1(:), set2(:)\n    logical :: all_present\n\n    allocate(set1(n))\n    allocate(set2(n))\n\n    ! Initialize set1\n    set1 = [1, 2, 3, 4, 5]\n\n    ! Initialize set2\n    set2 = [2, 4, 6, 8, 10]\n\n    ! Check if all elements of set2 are in set1\n    all_present = .true.\n    do i = 1, size(set2)\n        if (.not. any(set1 == set2(i))) then\n            all_present = .false.\n            exit\n        end if\n    end do\n\n    if (all_present) then\n        print *, \"All elements of set2 are present in set1.\"\n    else\n        print *, \"Not all elements of set2 are present in set1.\"\n    end if\n\n    deallocate(set1)\n    deallocate(set2)\nend program set_usage\n```"
  },
  {
    "task": "Implement a set to store unique coupon codes and demonstrate adding new codes.",
    "code": "```fortran\nprogram coupon_codes\n    implicit none\n    integer, parameter :: max_coupons = 100\n    character(len=10) :: coupons(max_coupons)\n    integer :: n_coupons, i\n    logical :: is_new\n\n    n_coupons = 0\n\n    call add_coupon('SAVE10')\n    call add_coupon('WELCOME')\n    call add_coupon('SAVE10')  ! Duplicate attempt\n    call add_coupon('HOLIDAY')\n\ncontains\n\n    subroutine add_coupon(code)\n        character(len=10), intent(in) :: code\n        integer :: i\n        logical :: found\n\n        found = .false.\n        do i = 1, n_coupons\n            if (coupons(i) == code) then\n                found = .true.\n                exit\n            end if\n        end do\n\n        if (.not. found) then\n            if (n_coupons < max_coupons) then\n                n_coupons = n_coupons + 1\n                coupons(n_coupons) = code\n                print *, 'Added code:', code\n            else\n                print *, 'Coupon list full. Cannot add more codes.'\n            end if\n        else\n            print *, 'Code already exists:', code\n        end if\n    end subroutine add_coupon\n\nend program coupon_codes\n```"
  },
  {
    "task": "Create a set and demonstrate the `copy` method.",
    "code": "```fortran\nprogram set_copy_demo\n  implicit none\n  type :: int_set\n     integer, allocatable :: elements(:)\n  contains\n     procedure :: add => add_element\n     procedure :: copy => copy_set\n  end type int_set\n\n  type(int_set) :: original_set, copied_set\n\n  call original_set%add(10)\n  call original_set%add(20)\n  call original_set%add(30)\n\n  copied_set = original_set%copy()\n\n  print *, \"Original set elements: \", original_set%elements\n  print *, \"Copied set elements: \", copied_set%elements\n\ncontains\n\n  subroutine add_element(this, value)\n    class(int_set), intent(inout) :: this\n    integer, intent(in) :: value\n    if (.not. any(this%elements == value)) then\n      if (allocated(this%elements)) then\n        this%elements = [this%elements, value]\n      else\n        allocate(this%elements(1))\n        this%elements(1) = value\n      end if\n    end if\n  end subroutine add_element\n\n  function copy_set(this) result(new_set)\n    class(int_set), intent(in) :: this\n    type(int_set) :: new_set\n    if (allocated(this%elements)) then\n      allocate(new_set%elements(size(this%elements)))\n      new_set%elements = this%elements\n    end if\n  end function copy_set\n\nend program set_copy_demo\n```"
  },
  {
    "task": "Write a function to remove duplicates from a list using a set.",
    "code": "```fortran\nfunction remove_duplicates(arr) result(unique_arr)\n    integer, dimension(:), intent(in) :: arr\n    integer, dimension(:), allocatable :: unique_arr\n    integer :: i\n    integer, allocatable :: temp(:)\n    integer, allocatable :: set(:)\n    integer :: size, count\n\n    allocate(temp(size(arr)))\n    count = 0\n\n    do i = 1, size(arr)\n        if (.not. any(temp(1:count) == arr(i))) then\n            count = count + 1\n            temp(count) = arr(i)\n        end if\n    end do\n\n    size = count\n    allocate(set(size))\n    set = temp(1:size)\n\n    unique_arr = set\nend function\n```"
  },
  {
    "task": "Use a set to identify unique numbers in a sequence.",
    "code": "```fortran\nprogram unique_numbers\n    implicit none\n    integer, allocatable :: sequence(:)\n    integer :: n, i\n    integer :: num\n    type :: Set\n        integer, allocatable :: elements(:)\n    contains\n        procedure :: add => add_to_set\n        procedure :: contains => set_contains\n    end type Set\n\n    type(Set) :: unique_set\n\n    print *, \"Enter the number of elements in the sequence:\"\n    read *, n\n\n    allocate(sequence(n))\n    allocate(unique_set%elements(0))\n\n    print *, \"Enter the elements of the sequence:\"\n    do i = 1, n\n        read *, sequence(i)\n    end do\n\n    do i = 1, n\n        call unique_set%add(sequence(i))\n    end do\n\n    print *, \"Unique elements are:\"\n    do i = 1, size(unique_set%elements)\n        print *, unique_set%elements(i)\n    end do\n\ncontains\n\n    subroutine add_to_set(this, value)\n        class(Set), intent(inout) :: this\n        integer, intent(in) :: value\n        if (.not. this%contains(value)) then\n            this%elements = [this%elements, value]\n        end if\n    end subroutine add_to_set\n\n    logical function set_contains(this, value)\n        class(Set), intent(in) :: this\n        integer, intent(in) :: value\n        integer :: i\n        set_contains = .false.\n        do i = 1, size(this%elements)\n            if (this%elements(i) == value) then\n                set_contains = .true.\n                return\n            end if\n        end do\n    end function set_contains\n\nend program unique_numbers\n```"
  },
  {
    "task": "Create a set of unique fruit names and demonstrate set operations with it.",
    "code": "```fortran\nprogram fruit_set_operations\n    implicit none\n    character(len=20), dimension(:), allocatable :: fruitSet\n    character(len=20), dimension(:), allocatable :: anotherSet\n    integer :: i\n\n    allocate(fruitSet(3))\n    fruitSet(1) = 'apple'\n    fruitSet(2) = 'banana'\n    fruitSet(3) = 'orange'\n\n    allocate(anotherSet(3))\n    anotherSet(1) = 'banana'\n    anotherSet(2) = 'kiwi'\n    anotherSet(3) = 'mango'\n\n    print *, 'Union of sets:'\n    call set_union(fruitSet, anotherSet)\n\n    print *, 'Intersection of sets:'\n    call set_intersection(fruitSet, anotherSet)\n\n    print *, 'Difference of sets:'\n    call set_difference(fruitSet, anotherSet)\n    \ncontains\n\n    subroutine set_union(set1, set2)\n        character(len=20), dimension(:), allocatable :: set1, set2\n        character(len=20) :: elem\n        integer :: i, j, n\n\n        allocate(character(len=20) :: result(size(set1) + size(set2)))\n        n = 0\n\n        do i = 1, size(set1)\n            result(n+1) = set1(i)\n            n = n + 1\n        end do\n\n        do i = 1, size(set2)\n            if (.not. any(set2(i) == result(1:n))) then\n                result(n+1) = set2(i)\n                n = n + 1\n            end if\n        end do\n\n        do i = 1, n\n            print *, trim(result(i))\n        end do\n    end subroutine set_union\n\n    subroutine set_intersection(set1, set2)\n        character(len=20), dimension(:), allocatable :: set1, set2\n        character(len=20) :: elem\n        integer :: i, j\n\n        do i = 1, size(set1)\n            if (any(set1(i) == set2)) then\n                print *, trim(set1(i))\n            end if\n        end do\n    end subroutine set_intersection\n\n    subroutine set_difference(set1, set2)\n        character(len=20), dimension(:), allocatable :: set1, set2\n        character(len=20) :: elem\n        integer :: i\n\n        do i = 1, size(set1)\n            if (.not. any(set1(i) == set2)) then\n                print *, trim(set1(i))\n            end if\n        end do\n    end subroutine set_difference\n\nend program fruit_set_operations\n```"
  }
]