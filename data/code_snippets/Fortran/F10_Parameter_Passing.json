[
  {
    "task": "Create a function that modifies the first element of an array passed to it. Explain how the changes are reflected in the original array.",
    "code": "```fortran\nprogram modify_array\n  implicit none\n  integer, dimension(5) :: arr = [1, 2, 3, 4, 5]\n  \n  print *, 'Original array: ', arr\n  call modify_first_element(arr)\n  print *, 'Modified array: ', arr\n\ncontains\n\n  subroutine modify_first_element(array)\n    integer, dimension(:), intent(inout) :: array\n    array(1) = 10\n  end subroutine modify_first_element\n\nend program modify_array\n```"
  },
  {
    "task": "Design a function that swaps the values of two variables using pass-by-reference. Demonstrate how the swap affects the original variables.",
    "code": "```fortran\nprogram SwapDemo\n    implicit none\n    integer :: a, b\n\n    a = 5\n    b = 10\n\n    print *, 'Before Swap:'\n    print *, 'a =', a, 'b =', b\n\n    call swap(a, b)\n\n    print *, 'After Swap:'\n    print *, 'a =', a, 'b =', b\n\ncontains\n\n    subroutine swap(x, y)\n        integer, intent(inout) :: x, y\n        integer :: temp\n\n        temp = x\n        x = y\n        y = temp\n    end subroutine swap\n\nend program SwapDemo\n```"
  },
  {
    "task": "Write a program that passes a large data structure to a function by value and by reference. Compare the performance and memory usage for both approaches.",
    "code": "```fortran\nprogram parameter_passing_example\n  implicit none\n  integer, parameter :: n = 1000\n  real :: large_array(n, n)\n  real :: start_time, end_time\n\n  call random_number(large_array)\n\n  ! Measure performance for passing by value\n  call cpu_time(start_time)\n  call by_value(large_array)\n  call cpu_time(end_time)\n  print *, 'Time for passing by value: ', end_time - start_time\n\n  ! Measure performance for passing by reference\n  call cpu_time(start_time)\n  call by_reference(large_array)\n  call cpu_time(end_time)\n  print *, 'Time for passing by reference: ', end_time - start_time\n\ncontains\n\n  subroutine by_value(arr)\n    real, intent(in) :: arr(n, n)\n    real :: sum\n    integer :: i, j\n\n    sum = 0.0\n    do i = 1, n\n      do j = 1, n\n        sum = sum + arr(i, j)\n      end do\n    end do\n  end subroutine by_value\n\n  subroutine by_reference(arr)\n    real, intent(inout) :: arr(n, n)\n    real :: sum\n    integer :: i, j\n\n    sum = 0.0\n    do i = 1, n\n      do j = 1, n\n        sum = sum + arr(i, j)\n      end do\n    end do\n  end subroutine by_reference\n\nend program parameter_passing_example\n```"
  },
  {
    "task": "Implement a function that accepts an integer and doubles its value. Show the difference in the original variable when using pass-by-value versus pass-by-reference.",
    "code": "```fortran\nmodule pass_module\n  implicit none\ncontains\n\n  subroutine double_by_value(x, result)\n    integer, value :: x\n    integer :: result\n    result = x * 2\n  end subroutine double_by_value\n\n  subroutine double_by_reference(x)\n    integer, intent(inout) :: x\n    x = x * 2\n  end subroutine double_by_reference\n\nend module pass_module\n\nprogram test_pass\n  use pass_module\n  implicit none\n\n  integer :: original, doubled\n\n  original = 10\n\n  ! Pass-by-value\n  call double_by_value(original, doubled)\n  print *, 'Pass-by-value: Original =', original, ', Doubled =', doubled\n\n  ! Pass-by-reference\n  call double_by_reference(original)\n  print *, 'Pass-by-reference: Original =', original\n\nend program test_pass\n```"
  },
  {
    "task": "Create a function that takes a list and returns a new list with elements doubled. Ensure the original list remains unchanged.",
    "code": "```fortran\nprogram double_elements\n    implicit none\n    integer, parameter :: n = 5\n    integer :: original_list(n) = [1, 2, 3, 4, 5]\n    integer :: doubled_list(n)\n    \n    call double_elements_function(original_list, doubled_list, n)\n    \n    print *, 'Original List: ', original_list\n    print *, 'Doubled List: ', doubled_list\n\ncontains\n\n    subroutine double_elements_function(input_list, output_list, size)\n        integer, intent(in) :: input_list(:)\n        integer, intent(out) :: output_list(:)\n        integer, intent(in) :: size\n        integer :: i\n        \n        do i = 1, size\n            output_list(i) = 2 * input_list(i)\n        end do\n    end subroutine double_elements_function\n\nend program double_elements\n```"
  },
  {
    "task": "Design a function that takes a string argument and appends a character to it. Illustrate the result when the string is passed by value.",
    "code": "```fortran\nprogram main\n    implicit none\n    character(len=100) :: originalString\n    character(len=1) :: charToAppend\n    character(len=100) :: newString\n\n    originalString = 'Hello'\n    charToAppend = '!'\n    newString = appendChar(originalString, charToAppend)\n\n    print *, 'Original String (unchanged): ', originalString\n    print *, 'New String (with character appended): ', newString\n\ncontains\n\n    function appendChar(str, char) result(newStr)\n        character(len=*), intent(in) :: str\n        character(len=1), intent(in) :: char\n        character(len=100) :: newStr\n        integer :: strLen\n\n        strLen = len_trim(str)\n        newStr = str\n        newStr(strLen+1:strLen+1) = char\n    end function appendChar\n\nend program main\n```"
  },
  {
    "task": "Write a function that increments a counter variable. Pass the variable by reference to see changes in the original variable.",
    "code": "```fortran\nprogram IncrementCounter\n  implicit none\n  integer :: counter\n\n  counter = 10\n  print *, \"Before increment:\", counter\n  call increment(counter)\n  print *, \"After increment:\", counter\n\ncontains\n\n  subroutine increment(counter)\n    integer, intent(inout) :: counter\n    counter = counter + 1\n  end subroutine increment\n\nend program IncrementCounter\n```"
  },
  {
    "task": "Develop a function that removes an item from a dictionary passed to it. Demonstrate how pass-by-reference affects the original dictionary.",
    "code": "```fortran\nmodule DictionaryModule\n  implicit none\n  type :: Dictionary\n     character(len=:), allocatable :: key(:)\n     real, allocatable :: value(:)\n  end type Dictionary\n\ncontains\n\n  subroutine removeItem(dict, itemKey)\n    type(Dictionary), intent(inout) :: dict\n    character(len=*), intent(in) :: itemKey\n    integer :: i, pos\n\n    pos = -1\n    do i = 1, size(dict%key)\n      if (dict%key(i) == itemKey) then\n        pos = i\n        exit\n      end if\n    end do\n\n    if (pos > 0) then\n      if (size(dict%key) > 1) then\n        dict%key = [dict%key(1:pos-1), dict%key(pos+1:)]\n        dict%value = [dict%value(1:pos-1), dict%value(pos+1:)]\n      else\n        deallocate(dict%key, dict%value)\n      end if\n    end if\n  end subroutine removeItem\n\nend module DictionaryModule\n\nprogram TestDictionary\n  use DictionaryModule\n  implicit none\n  type(Dictionary) :: myDict\n  integer :: i\n\n  allocate(character(len=10) :: myDict%key(3))\n  allocate(myDict%value(3))\n  myDict%key = ['item1', 'item2', 'item3']\n  myDict%value = [1.0, 2.0, 3.0]\n\n  call removeItem(myDict, 'item2')\n\n  do i = 1, size(myDict%key)\n    print *, trim(myDict%key(i)), myDict%value(i)\n  end do\n\nend program TestDictionary\n```"
  },
  {
    "task": "Create a program that passes a matrix to a function, which transposes it. Explain how the transposition affects the original matrix with pass-by-reference.",
    "code": "```fortran\nprogram matrix_transpose\n    implicit none\n    integer, parameter :: n = 3\n    integer :: i, j\n    real :: matrix(n, n), transposed_matrix(n, n)\n\n    ! Initialize the matrix\n    matrix = reshape((/ 1.0, 2.0, 3.0, &\n                       4.0, 5.0, 6.0, &\n                       7.0, 8.0, 9.0 /), (/n, n/))\n\n    call transpose_matrix(matrix, transposed_matrix)\n\n    print *, \"Original Matrix:\"\n    do i = 1, n\n        print *, (matrix(i, j), j = 1, n)\n    end do\n\n    print *, \"Transposed Matrix:\"\n    do i = 1, n\n        print *, (transposed_matrix(i, j), j = 1, n)\n    end do\n\ncontains\n\n    subroutine transpose_matrix(mat, trans)\n        real, intent(in) :: mat(n, n)\n        real, intent(out) :: trans(n, n)\n        integer :: i, j\n\n        do i = 1, n\n            do j = 1, n\n                trans(j, i) = mat(i, j)\n            end do\n        end do\n    end subroutine transpose_matrix\n\nend program matrix_transpose\n```"
  },
  {
    "task": "Implement a function that takes a float number and rounds it. Discuss the implications of passing the number by value.",
    "code": "```fortran\nprogram RoundExample\n  implicit none\n  real :: number, roundedNumber\n\n  number = 3.6\n  roundedNumber = roundNumber(number)\n  print *, 'Original number:', number\n  print *, 'Rounded number:', roundedNumber\n\ncontains\n\n  function roundNumber(num) result(rounded)\n    real, intent(in) :: num\n    real :: rounded\n\n    rounded = nint(num)\n  end function roundNumber\n\nend program RoundExample\n```"
  },
  {
    "task": "Design a function that accepts a dictionary and adds a key-value pair to it. Show the changes when the dictionary is passed by reference.",
    "code": "```fortran\nmodule dictionary_module\n  implicit none\n  type :: dictionary\n    character(len=:), allocatable :: keys(:)\n    character(len=:), allocatable :: values(:)\n  end type dictionary\ncontains\n  subroutine add_key_value_pair(dict, key, value)\n    type(dictionary), intent(inout) :: dict\n    character(len=*), intent(in) :: key, value\n    integer :: n\n    \n    n = size(dict%keys)\n    allocate(character(len=len(key)) :: dict%keys(n+1))\n    allocate(character(len=len(value)) :: dict%values(n+1))\n    \n    dict%keys(1:n) = dict%keys\n    dict%values(1:n) = dict%values\n    dict%keys(n+1) = key\n    dict%values(n+1) = value\n  end subroutine add_key_value_pair\n\n  subroutine print_dictionary(dict)\n    type(dictionary), intent(in) :: dict\n    integer :: i\n    \n    do i = 1, size(dict%keys)\n      print *, trim(dict%keys(i)), \":\", trim(dict%values(i))\n    end do\n  end subroutine print_dictionary\nend module dictionary_module\n\nprogram main\n  use dictionary_module\n  implicit none\n  type(dictionary) :: my_dict\n  \n  allocate(character(len=1) :: my_dict%keys(0))\n  allocate(character(len=1) :: my_dict%values(0))\n  \n  call add_key_value_pair(my_dict, \"name\", \"Alice\")\n  call add_key_value_pair(my_dict, \"age\", \"30\")\n  \n  call print_dictionary(my_dict)\nend program main\n```"
  },
  {
    "task": "Write a program that passes a string to a function that converts it to uppercase. Explain how this affects the original string with pass-by-value.",
    "code": "```fortran\nprogram UppercaseDemo\n    implicit none\n    character(len=100) :: originalString\n    character(len=100) :: upperString\n\n    ! Initialize the original string\n    originalString = 'Hello, World!'\n    \n    ! Call the function to convert to uppercase\n    upperString = toUppercase(originalString)\n\n    ! Print results\n    print *, 'Original String: ', originalString\n    print *, 'Uppercase String: ', upperString\n\ncontains\n\n    function toUppercase(inputString) result(uppercasedString)\n        character(len=100), intent(in) :: inputString\n        character(len=100) :: uppercasedString\n        integer :: i\n\n        ! Convert each character to uppercase\n        uppercasedString = inputString\n        do i = 1, len_trim(inputString)\n            if (iachar(uppercasedString(i:i)) >= iachar('a') .and. iachar(uppercasedString(i:i)) <= iachar('z')) then\n                uppercasedString(i:i) = achar(iachar(uppercasedString(i:i)) - 32)\n            end if\n        end do\n\n    end function toUppercase\n\nend program UppercaseDemo\n```"
  },
  {
    "task": "Create a function that receives a tuple and attempts to modify one of its elements. Discuss the outcome of using pass-by-value.",
    "code": "```fortran\nprogram main\n  implicit none\n\n  type :: Tuple\n    integer :: a = 1\n    integer :: b = 2\n  end type Tuple\n\n  type(Tuple) :: myTuple\n\n  ! Attempt to modify myTuple\n  call modifyTuple(myTuple)\n\n  print *, \"Tuple after modification attempt: \", myTuple%a, myTuple%b\n\ncontains\n\n  subroutine modifyTuple(t)\n    type(Tuple), intent(in) :: t\n\n    ! Attempt to modify t%a\n    ! t%a = 10  ! This line would cause a compilation error due to intent(in)\n  end subroutine modifyTuple\n\nend program main\n```"
  },
  {
    "task": "Develop a function that accepts an object and modifies one of its attributes. Illustrate how pass-by-reference alters the original object.",
    "code": "```fortran\nmodule mod_example\n  implicit none\n  type :: my_object\n    integer :: attribute\n  end type my_object\ncontains\n  subroutine modify_attribute(obj)\n    type(my_object), intent(inout) :: obj\n    obj%attribute = obj%attribute + 10\n  end subroutine modify_attribute\nend module mod_example\n\nprogram test_pass_by_reference\n  use mod_example\n  implicit none\n  type(my_object) :: obj\n\n  obj%attribute = 5\n  print *, \"Before modification: \", obj%attribute\n  call modify_attribute(obj)\n  print *, \"After modification: \", obj%attribute\nend program test_pass_by_reference\n```"
  },
  {
    "task": "Design a function that outputs the sum of all elements in an array passed by value. Confirm the original array remains unchanged.",
    "code": "```fortran\nprogram SumArray\n  implicit none\n  integer, parameter :: n = 5\n  integer :: arr(n) = [1, 2, 3, 4, 5]\n  integer :: result\n\n  result = sum_array_by_value(arr)\n  print *, \"Sum of array elements:\", result\n  print *, \"Original array:\", arr\n\ncontains\n\n  function sum_array_by_value(arr) result(sum)\n    integer, intent(in) :: arr(:)\n    integer :: sum\n    integer :: i\n\n    sum = 0\n    do i = 1, size(arr)\n      sum = sum + arr(i)\n    end do\n  end function sum_array_by_value\n\nend program SumArray\n```"
  },
  {
    "task": "Write a function that takes a boolean flag and toggles its value. Demonstrate the effect of pass-by-reference on the original flag.",
    "code": "```fortran\nprogram ToggleFlagDemo\n  implicit none\n  logical :: flag\n\n  flag = .true.\n  print *, 'Original flag:', flag\n  call Toggle(flag)\n  print *, 'Toggled flag:', flag\n\ncontains\n\n  subroutine Toggle(flag)\n    logical, intent(inout) :: flag\n    flag = .not. flag\n  end subroutine Toggle\n\nend program ToggleFlagDemo\n```"
  },
  {
    "task": "Create a function that takes an object and clones it. Modify the clone and show that the original object remains unaffected.",
    "code": "```fortran\nmodule object_module\n  type :: MyObject\n    integer :: value\n  end type MyObject\ncontains\n  subroutine clone_object(original, clone)\n    type(MyObject), intent(in) :: original\n    type(MyObject), intent(out) :: clone\n    clone = original\n  end subroutine clone_object\nend module object_module\n\nprogram main\n  use object_module\n  type(MyObject) :: original, cloned\n  original%value = 10\n  call clone_object(original, cloned)\n  cloned%value = 20\n\n  print *, 'Original value: ', original%value\n  print *, 'Cloned value: ', cloned%value\nend program main\n```"
  },
  {
    "task": "Implement a function that accepts a list of integers and removes all even numbers. Describe the difference in behavior when using pass-by-value and pass-by-reference.",
    "code": "```fortran\nprogram remove_even_numbers\n    implicit none\n    integer, allocatable :: arr(:)\n    integer :: i, n\n\n    ! Initialize array\n    n = 10\n    allocate(arr(n))\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n    ! Call function with pass-by-reference\n    call remove_evens_ref(arr)\n    print *, 'Array after remove_evens_ref:', arr\n\n    ! Reinitialize array\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n    ! Call function with pass-by-value (pass a copy)\n    call remove_evens_val(arr)\n    print *, 'Array after remove_evens_val (original):', arr\n\ncontains\n\n    subroutine remove_evens_ref(arr)\n        integer, allocatable, intent(inout) :: arr(:)\n        integer, allocatable :: temp(:)\n        integer :: i, count\n\n        count = 0\n        allocate(temp(size(arr)))\n        \n        do i = 1, size(arr)\n            if (mod(arr(i), 2) /= 0) then\n                count = count + 1\n                temp(count) = arr(i)\n            end if\n        end do\n\n        call move_alloc(temp(1:count), arr)\n    end subroutine remove_evens_ref\n\n    subroutine remove_evens_val(arr)\n        integer, allocatable, intent(in) :: arr(:)\n        integer, allocatable :: temp(:)\n        integer :: i, count\n\n        count = 0\n        allocate(temp(size(arr)))\n        \n        do i = 1, size(arr)\n            if (mod(arr(i), 2) /= 0) then\n                count = count + 1\n                temp(count) = arr(i)\n            end if\n        end do\n\n        ! Pass-by-value: This change doesn't affect the original array\n        ! call move_alloc(temp(1:count), arr)  ! Would normally do this if intent(out)\n    end subroutine remove_evens_val\n\nend program remove_even_numbers\n```"
  },
  {
    "task": "Develop a function that takes a complex number and returns its conjugate. Explain how pass-by-value affects the original complex number.",
    "code": "```fortran\nmodule complex_operations\n  implicit none\ncontains\n  function conjugate(c) result(conj)\n    complex, value :: c\n    complex :: conj\n\n    conj = conjg(c)\n  end function conjugate\nend module complex_operations\n\nprogram main\n  use complex_operations\n  implicit none\n  complex :: z, z_conjugate\n\n  z = (3.0, -4.0)\n  z_conjugate = conjugate(z)\n  \n  print *, 'Original:', z\n  print *, 'Conjugate:', z_conjugate\nend program main\n```"
  },
  {
    "task": "Design a program where a function receives a binary tree and inverts it. Discuss how pass-by-reference impacts the original tree structure.",
    "code": "```fortran\nmodule binary_tree_module\n    implicit none\n    type :: TreeNode\n        integer :: value\n        type(TreeNode), pointer :: left => null()\n        type(TreeNode), pointer :: right => null()\n    end type TreeNode\ncontains\n    subroutine invertTree(node)\n        type(TreeNode), pointer :: node\n        type(TreeNode), pointer :: temp\n\n        if (.not. associated(node)) return\n\n        ! Swap the left and right subtrees\n        temp => node%left\n        node%left => node%right\n        node%right => temp\n\n        ! Recursively invert the subtrees\n        call invertTree(node%left)\n        call invertTree(node%right)\n    end subroutine invertTree\nend module binary_tree_module\n\nprogram invert_binary_tree\n    use binary_tree_module\n    implicit none\n    type(TreeNode), pointer :: root\n\n    ! Initialize the binary tree (example)\n    allocate(root)\n    root%value = 1\n    allocate(root%left)\n    root%left%value = 2\n    allocate(root%right)\n    root%right%value = 3\n\n    ! Call the invertTree function\n    call invertTree(root)\n\n    ! Further processing can be done here\nend program invert_binary_tree\n```"
  },
  {
    "task": "Write a function that adds an element to a set passed to it. Show how pass-by-reference affects the original set.",
    "code": "```fortran\nmodule set_operations\n  implicit none\ncontains\n  subroutine add_to_set(set, elem)\n    integer, allocatable, intent(inout) :: set(:)\n    integer, intent(in) :: elem\n    integer, allocatable :: new_set(:)\n    integer :: i, found\n\n    ! Check if element is already in the set\n    found = 0\n    do i = 1, size(set)\n      if (set(i) == elem) then\n        found = 1\n        exit\n      end if\n    end do\n\n    ! If not found, add the element\n    if (found == 0) then\n      allocate(new_set(size(set) + 1))\n      if (size(set) > 0) then\n        new_set(1:size(set)) = set\n      end if\n      new_set(size(new_set)) = elem\n      deallocate(set)\n      allocate(set(size(new_set)))\n      set = new_set\n      deallocate(new_set)\n    end if\n  end subroutine add_to_set\nend module set_operations\n\nprogram test_set_operations\n  use set_operations\n  implicit none\n  integer, allocatable :: my_set(:)\n\n  allocate(my_set(3))\n  my_set = [1, 2, 3]\n\n  call add_to_set(my_set, 4)\n\n  ! Output the modified set\n  print *, \"Modified set: \", my_set\nend program test_set_operations\n```"
  },
  {
    "task": "Create a function that accepts an integer array and sorts it. Demonstrate the difference when the array is passed by value.",
    "code": "```fortran\nprogram SortArrayDemo\n    implicit none\n    integer, parameter :: n = 5\n    integer :: array(n) = [5, 2, 4, 3, 1]\n    integer :: sortedArray(n)\n    \n    print *, \"Original array:\"\n    call printArray(array)\n    \n    sortedArray = array  ! Copy array to demonstrate pass by value\n    call sortArray(sortedArray)\n    \n    print *, \"Sorted array (pass by value):\"\n    call printArray(sortedArray)\n    \n    print *, \"Original array (unchanged):\"\n    call printArray(array)\n    \ncontains\n\n    subroutine sortArray(a)\n        integer, intent(inout) :: a(:)\n        integer :: i, j, temp\n        \n        do i = 1, size(a)-1\n            do j = i+1, size(a)\n                if (a(i) > a(j)) then\n                    temp = a(i)\n                    a(i) = a(j)\n                    a(j) = temp\n                end if\n            end do\n        end do\n    end subroutine sortArray\n\n    subroutine printArray(a)\n        integer, intent(in) :: a(:)\n        integer :: i\n        print *, (a(i), i = 1, size(a))\n    end subroutine printArray\n\nend program SortArrayDemo\n```"
  },
  {
    "task": "Implement a function that takes a configuration object and toggles a setting. Illustrate the changes with pass-by-reference.",
    "code": "```fortran\nmodule config_module\n    type :: Config\n        logical :: setting\n    end type Config\nend module config_module\n\nprogram main\n    use config_module\n    implicit none\n\n    type(Config) :: myConfig\n\n    ! Initialize the configuration\n    myConfig%setting = .false.\n\n    ! Toggle the setting using pass-by-reference\n    call toggleSetting(myConfig)\n\n    ! Print the result\n    print *, \"Setting is now: \", myConfig%setting\n\ncontains\n\n    subroutine toggleSetting(c)\n        type(Config), intent(inout) :: c\n        c%setting = .not. c%setting\n    end subroutine toggleSetting\n\nend program main\n```"
  },
  {
    "task": "Design a function that receives a file path and reads its content. Explain how passing the path by value affects the outcome.",
    "code": "```fortran\nprogram read_file_example\n    implicit none\n    character(len=100) :: filePath\n    character(len=200) :: fileContent\n\n    ! Example file path\n    filePath = 'example.txt'\n\n    call read_file(filePath, fileContent)\n    print *, 'File Content: ', fileContent\n\ncontains\n\n    subroutine read_file(path, content)\n        character(len=*), intent(in) :: path\n        character(len=*), intent(out) :: content\n        integer :: unit, ios\n\n        unit = 10\n        open(unit, file=path, status='old', action='read', iostat=ios)\n        if (ios /= 0) then\n            content = 'Error opening file'\n            return\n        end if\n\n        read(unit, '(A)', iostat=ios) content\n        if (ios /= 0) then\n            content = 'Error reading file'\n        end if\n\n        close(unit)\n    end subroutine read_file\n\nend program read_file_example\n```"
  },
  {
    "task": "Write a program in which a function takes a stack and reverses its elements. Discuss the impact of pass-by-reference on the stack.",
    "code": "```fortran\nmodule stack_module\n  implicit none\n  integer, parameter :: stack_size = 100\n  type :: stack_type\n    integer :: elements(stack_size)\n    integer :: top = 0\n  end type stack_type\ncontains\n  subroutine push(s, item)\n    type(stack_type), intent(inout) :: s\n    integer, intent(in) :: item\n    if (s%top < stack_size) then\n      s%top = s%top + 1\n      s%elements(s%top) = item\n    endif\n  end subroutine push\n\n  subroutine pop(s, item)\n    type(stack_type), intent(inout) :: s\n    integer, intent(out) :: item\n    if (s%top > 0) then\n      item = s%elements(s%top)\n      s%top = s%top - 1\n    endif\n  end subroutine pop\n\n  subroutine reverse_stack(s)\n    type(stack_type), intent(inout) :: s\n    integer :: temp_stack(stack_size)\n    integer :: i, temp_top\n\n    temp_top = 0\n    do while (s%top > 0)\n      call pop(s, temp_stack(temp_top + 1))\n      temp_top = temp_top + 1\n    end do\n\n    do i = 1, temp_top\n      call push(s, temp_stack(i))\n    end do\n  end subroutine reverse_stack\nend module stack_module\n\nprogram main\n  use stack_module\n  implicit none\n  type(stack_type) :: my_stack\n  integer :: i\n\n  do i = 1, 5\n    call push(my_stack, i)\n  end do\n\n  call reverse_stack(my_stack)\n\n  do i = 1, 5\n    call pop(my_stack, i)\n    print *, i\n  end do\nend program main\n```"
  },
  {
    "task": "Create a function that takes a queue and dequeues an element. Show the result when the queue is passed by reference.",
    "code": "```fortran\nmodule queue_module\n    implicit none\n    integer, parameter :: MAX_QUEUE_SIZE = 100\n\n    type :: Queue\n        integer :: elements(MAX_QUEUE_SIZE)\n        integer :: front = 1\n        integer :: rear = 0\n    end type Queue\n\ncontains\n\n    subroutine enqueue(queue, value)\n        type(Queue), intent(inout) :: queue\n        integer, intent(in) :: value\n\n        if (queue%rear < MAX_QUEUE_SIZE) then\n            queue%rear = queue%rear + 1\n            queue%elements(queue%rear) = value\n        else\n            print *, 'Queue is full'\n        end if\n    end subroutine enqueue\n\n    subroutine dequeue(queue, value)\n        type(Queue), intent(inout) :: queue\n        integer, intent(out) :: value\n\n        if (queue%front <= queue%rear) then\n            value = queue%elements(queue%front)\n            queue%front = queue%front + 1\n        else\n            print *, 'Queue is empty'\n            value = -1\n        end if\n    end subroutine dequeue\n\nend module queue_module\n\nprogram main\n    use queue_module\n    implicit none\n    type(Queue) :: myQueue\n    integer :: dequeued_value\n\n    call enqueue(myQueue, 10)\n    call enqueue(myQueue, 20)\n    call enqueue(myQueue, 30)\n\n    call dequeue(myQueue, dequeued_value)\n    print *, 'Dequeued:', dequeued_value\n\n    call dequeue(myQueue, dequeued_value)\n    print *, 'Dequeued:', dequeued_value\n\n    call dequeue(myQueue, dequeued_value)\n    print *, 'Dequeued:', dequeued_value\n\nend program main\n```"
  },
  {
    "task": "Develop a function that accepts a hashmap and updates a value for a specific key. Illustrate the effects of pass-by-reference.",
    "code": "```fortran\nmodule hashmap_module\n    implicit none\n    type :: hashmap\n        character(len=:), allocatable :: keys(:)\n        integer :: values(:)\n    end type hashmap\ncontains\n    subroutine update_value(hm, key, new_value)\n        type(hashmap), intent(inout) :: hm\n        character(len=*), intent(in) :: key\n        integer, intent(in) :: new_value\n        integer :: i\n\n        do i = 1, size(hm%keys)\n            if (hm%keys(i) == key) then\n                hm%values(i) = new_value\n                exit\n            end if\n        end do\n    end subroutine update_value\n\n    subroutine print_hashmap(hm)\n        type(hashmap), intent(in) :: hm\n        integer :: i\n\n        do i = 1, size(hm%keys)\n            print*, hm%keys(i), \":\", hm%values(i)\n        end do\n    end subroutine print_hashmap\nend module hashmap_module\n\nprogram main\n    use hashmap_module\n    implicit none\n    type(hashmap) :: hm\n    character(len=20) :: keys(3) = [ \"key1\", \"key2\", \"key3\" ]\n    integer :: values(3) = [ 10, 20, 30 ]\n\n    allocate(character(len=20) :: hm%keys(3))\n    hm%keys = keys\n    hm%values = values\n\n    print*, \"Before update:\"\n    call print_hashmap(hm)\n\n    call update_value(hm, \"key2\", 99)\n    \n    print*, \"After update:\"\n    call print_hashmap(hm)\nend program main\n```"
  },
  {
    "task": "Design a function that receives a JSON object and adds a new property. Discuss the implications of modifying the object by reference.",
    "code": "```fortran\nprogram ModifyJson\n    use iso_c_binding\n    implicit none\n    \n    type, bind(c) :: c_ptr\n        type(c_ptr) :: base\n    end type c_ptr\n\n    interface\n        subroutine modify_json(json_obj, key, value) bind(c, name='modify_json')\n            import\n            type(c_ptr), value :: json_obj\n            character(len=*), intent(in) :: key, value\n        end subroutine modify_json\n    end interface\n\n    type(c_ptr) :: json_obj\n\n    ! Here you would initialize `json_obj` with actual JSON object\n\n    call modify_json(json_obj, \"new_property\", \"new_value\")\n\nend program ModifyJson\n```"
  },
  {
    "task": "Write a program where a function accepts a graph and adds a node. Explain how pass-by-reference affects the original graph structure.",
    "code": "```fortran\nMODULE GraphModule\n  IMPLICIT NONE\n  TYPE :: Node\n    INTEGER :: id\n  END TYPE Node\n\n  TYPE :: Graph\n    TYPE(Node), ALLOCATABLE :: nodes(:)\n  END TYPE Graph\nCONTAINS\n\n  SUBROUTINE AddNode(graph, new_id)\n    TYPE(Graph), INTENT(INOUT) :: graph\n    INTEGER, INTENT(IN) :: new_id\n    TYPE(Node) :: new_node\n\n    new_node = Node(new_id)\n    \n    IF (.NOT. ALLOCATED(graph%nodes)) THEN\n      ALLOCATE(graph%nodes(1))\n      graph%nodes(1) = new_node\n    ELSE\n      CALL AddNodeToArray(graph%nodes, new_node)\n    END IF\n  END SUBROUTINE AddNode\n\n  SUBROUTINE AddNodeToArray(nodes, new_node)\n    TYPE(Node), ALLOCATABLE, INTENT(INOUT) :: nodes(:)\n    TYPE(Node), INTENT(IN) :: new_node\n    INTEGER :: n\n\n    n = SIZE(nodes)\n    ALLOCATE(nodes(n+1))\n    nodes(n+1) = new_node\n  END SUBROUTINE AddNodeToArray\n\nEND MODULE GraphModule\n\nPROGRAM Main\n  USE GraphModule\n  IMPLICIT NONE\n  TYPE(Graph) :: myGraph\n\n  CALL AddNode(myGraph, 1)\n  CALL AddNode(myGraph, 2)\n\n  PRINT *, \"Graph has\", SIZE(myGraph%nodes), \"nodes\"\nEND PROGRAM Main\n```"
  },
  {
    "task": "Create a function that accepts a set of coordinates and shifts them. Demonstrate how pass-by-value ensures the original set is unchanged.",
    "code": "```fortran\nprogram shift_coordinates\n  implicit none\n  real :: x, y, x_shifted, y_shifted\n\n  x = 5.0\n  y = 3.0\n\n  call shift_by_value(x, y, 2.0, 1.0, x_shifted, y_shifted)\n\n  print *, \"Original coordinates: \", x, y\n  print *, \"Shifted coordinates: \", x_shifted, y_shifted\n\ncontains\n\n  subroutine shift_by_value(x, y, dx, dy, x_new, y_new)\n    real, value :: x, y, dx, dy\n    real :: x_new, y_new\n\n    x_new = x + dx\n    y_new = y + dy\n  end subroutine shift_by_value\n\nend program shift_coordinates\n```"
  },
  {
    "task": "Implement a function that takes a date object and sets it to the next day. Discuss the effects of pass-by-reference on the date object.",
    "code": "```fortran\nmodule date_module\n  implicit none\n  type :: Date\n    integer :: year\n    integer :: month\n    integer :: day\n  end type Date\ncontains\n  subroutine set_next_day(date)\n    type(Date), intent(inout) :: date\n    integer :: days_in_month(12)\n    data days_in_month /31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31/\n\n    date%day = date%day + 1\n\n    if (date%month == 2 .and. is_leap_year(date%year)) then\n      if (date%day > 29) then\n        date%day = 1\n        date%month = date%month + 1\n      end if\n    else\n      if (date%day > days_in_month(date%month)) then\n        date%day = 1\n        date%month = date%month + 1\n      end if\n    end if\n\n    if (date%month > 12) then\n      date%month = 1\n      date%year = date%year + 1\n    end if\n  end subroutine set_next_day\n\n  logical function is_leap_year(year)\n    integer, intent(in) :: year\n    is_leap_year = (mod(year, 4) == 0 .and. (mod(year, 100) /= 0 .or. mod(year, 400) == 0))\n  end function is_leap_year\nend module date_module\n\nprogram test_date\n  use date_module\n  implicit none\n  type(Date) :: today\n\n  ! Set an example date\n  today%year = 2023\n  today%month = 10\n  today%day = 31\n\n  print *, 'Today: ', today%year, today%month, today%day\n  call set_next_day(today)\n  print *, 'Next Day: ', today%year, today%month, today%day\nend program test_date\n```"
  },
  {
    "task": "Develop a function that receives a polynomial represented as a list of coefficients and differentiates it. Show how the original list remains unchanged with pass-by-value.",
    "code": "```fortran\nprogram polynomial_derivative\n  implicit none\n  real, dimension(:), allocatable :: coeffs, deriv_coeffs\n\n  ! Example polynomial: 3x^2 + 2x + 1 represented by coefficients [3, 2, 1]\n  coeffs = [3.0, 2.0, 1.0]\n\n  ! Call the function to differentiate\n  call differentiate(coeffs, deriv_coeffs)\n\n  ! Output the original and differentiated coefficients\n  print *, \"Original coefficients: \", coeffs\n  print *, \"Differentiated coefficients: \", deriv_coeffs\n\ncontains\n\n  subroutine differentiate(poly, deriv)\n    real, dimension(:), intent(in) :: poly\n    real, dimension(:), allocatable :: deriv\n    integer :: i, n\n\n    n = size(poly)\n    if (n <= 1) then\n      ! Derivative of a constant is zero\n      deriv = [0.0]\n    else\n      allocate(deriv(n-1))\n      do i = 1, n-1\n        deriv(i) = poly(i) * real(n-i)\n      end do\n    end if\n\n  end subroutine differentiate\n\nend program polynomial_derivative\n```"
  },
  {
    "task": "Design a function that accepts a stack and clears it. Explain how pass-by-reference affects the original stack.",
    "code": "```fortran\nmodule stack_module\n  implicit none\n  integer, parameter :: stack_size = 100\n  type :: stack_type\n    integer :: items(stack_size)\n    integer :: top = 0\n  end type stack_type\ncontains\n  subroutine clear_stack(stack)\n    type(stack_type), intent(inout) :: stack\n\n    stack%top = 0\n\n  end subroutine clear_stack\nend module stack_module\n\nprogram test_stack\n  use stack_module\n  implicit none\n  type(stack_type) :: my_stack\n\n  call clear_stack(my_stack)\n\nend program test_stack\n```"
  },
  {
    "task": "Write a function that takes a linked list and appends a new node. Demonstrate the impact of pass-by-reference on the list.",
    "code": "```fortran\nmodule linked_list_module\n    implicit none\n    type :: Node\n        integer :: value\n        type(Node), pointer :: next => null()\n    end type Node\ncontains\n    subroutine append_node(head, new_value)\n        type(Node), pointer :: head\n        integer, intent(in) :: new_value\n        type(Node), pointer :: current, new_node\n\n        allocate(new_node)\n        new_node%value = new_value\n        new_node%next => null()\n\n        if (.not. associated(head)) then\n            head => new_node\n        else\n            current => head\n            do while (associated(current%next))\n                current => current%next\n            end do\n            current%next => new_node\n        end if\n    end subroutine append_node\n\n    subroutine print_list(head)\n        type(Node), pointer :: head\n        type(Node), pointer :: current\n\n        current => head\n        do while (associated(current))\n            print *, current%value\n            current => current%next\n        end do\n    end subroutine print_list\nend module linked_list_module\n\nprogram test_linked_list\n    use linked_list_module\n    implicit none\n\n    type(Node), pointer :: head => null()\n\n    call append_node(head, 10)\n    call append_node(head, 20)\n    call append_node(head, 30)\n\n    call print_list(head)\nend program test_linked_list\n```"
  },
  {
    "task": "Create a function that receives a URL and extracts the domain name. Discuss the effects of pass-by-value on the URL string.",
    "code": "```fortran\nprogram extract_domain\n    implicit none\n    character(len=100) :: url\n    character(len=100) :: domain\n\n    ! Example URL\n    url = \"https://www.example.com/path/to/resource\"\n\n    ! Call the function to extract the domain\n    call get_domain(url, domain)\n    \n    ! Output the extracted domain\n    print *, 'Domain: ', trim(domain)\n    \ncontains\n\n    subroutine get_domain(url, domain)\n        character(len=*), intent(in) :: url\n        character(len=*), intent(out) :: domain\n        integer :: start, end\n\n        ! Find the start and end of the domain within the URL\n        start = index(url, \"//\") + 2\n        end = index(url(start:), \"/\")\n        \n        if (end == 0) then\n            end = len_trim(url) - start + 1\n        else\n            end = end - 1\n        end if\n\n        ! Extract the domain name\n        domain = url(start:start+end-1)\n    end subroutine get_domain\n\nend program extract_domain\n```"
  },
  {
    "task": "Implement a function that takes a priority queue and changes the priority of an element. Illustrate the effects using pass-by-reference.",
    "code": "```fortran\nmodule priority_queue_mod\n    implicit none\n    type :: PriorityQueue\n        integer, allocatable :: elements(:)\n        integer, allocatable :: priorities(:)\n    end type PriorityQueue\ncontains\n    subroutine change_priority(queue, element, new_priority)\n        type(PriorityQueue), intent(inout) :: queue\n        integer, intent(in) :: element\n        integer, intent(in) :: new_priority\n        integer :: i\n\n        do i = 1, size(queue%elements)\n            if (queue%elements(i) == element) then\n                queue%priorities(i) = new_priority\n                return\n            end if\n        end do\n    end subroutine change_priority\n\n    subroutine display_queue(queue)\n        type(PriorityQueue), intent(in) :: queue\n        integer :: i\n\n        print *, \"Element\", \"Priority\"\n        do i = 1, size(queue%elements)\n            print *, queue%elements(i), queue%priorities(i)\n        end do\n    end subroutine display_queue\nend module priority_queue_mod\n\nprogram main\n    use priority_queue_mod\n    implicit none\n\n    type(PriorityQueue) :: pq\n    integer :: elements(3) = [1, 2, 3]\n    integer :: priorities(3) = [10, 20, 30]\n\n    allocate(pq%elements(3))\n    allocate(pq%priorities(3))\n    pq%elements = elements\n    pq%priorities = priorities\n\n    print *, \"Before changing priority:\"\n    call display_queue(pq)\n\n    call change_priority(pq, 2, 50)\n\n    print *, \"After changing priority:\"\n    call display_queue(pq)\nend program main\n```"
  },
  {
    "task": "Develop a function that accepts a circular buffer and reads an element. Explain how pass-by-reference influences the buffer.",
    "code": "```fortran\nprogram CircularBuffer\n    implicit none\n\n    ! Parameters for buffer size\n    integer, parameter :: buffer_size = 5\n    integer, dimension(buffer_size) :: buffer = (/1, 2, 3, 4, 5/)\n    integer :: index = 1\n    integer :: element\n\n    call read_element(buffer, index, element)\n    print *, 'Element read:', element\n    print *, 'Updated buffer index:', index\n\ncontains\n\n    subroutine read_element(buf, idx, elem)\n        integer, dimension(:), intent(inout) :: buf\n        integer, intent(inout) :: idx\n        integer, intent(out) :: elem\n\n        elem = buf(idx)\n        idx = idx + 1\n        if (idx > size(buf)) then\n            idx = 1\n        end if\n    end subroutine read_element\n\nend program CircularBuffer\n```"
  },
  {
    "task": "Design a program where a function receives a record and updates a field. Show how pass-by-reference affects the original record.",
    "code": "```fortran\nMODULE RecordModule\n  TYPE :: MyRecord\n    INTEGER :: field\n  END TYPE MyRecord\nCONTAINS\n  SUBROUTINE updateField(rec)\n    TYPE(MyRecord), INTENT(INOUT) :: rec\n    rec%field = rec%field + 10\n  END SUBROUTINE updateField\nEND MODULE RecordModule\n\nPROGRAM MainProgram\n  USE RecordModule\n  TYPE(MyRecord) :: myRec\n\n  myRec%field = 5\n  CALL updateField(myRec)\n  PRINT *, \"Updated field value: \", myRec%field\nEND PROGRAM MainProgram\n```"
  },
  {
    "task": "Write a function that takes a frequency list and normalizes it. Describe how pass-by-value ensures the original list remains unchanged.",
    "code": "```fortran\nprogram normalize_frequency\n  implicit none\n  real, dimension(:), allocatable :: freq_list, normalized_list\n  integer :: n\n  \n  ! Sample frequency list\n  freq_list = [1.0, 2.0, 3.0, 4.0, 5.0]\n  \n  n = size(freq_list)\n  allocate(normalized_list(n))\n  \n  normalized_list = normalize(freq_list)\n  \n  print*, \"Original list:\", freq_list\n  print*, \"Normalized list:\", normalized_list\n\ncontains\n\n  function normalize(freq) result(norm_freq)\n    real, dimension(:), intent(in) :: freq\n    real, dimension(size(freq)) :: norm_freq\n    real :: total\n    integer :: i\n    \n    total = sum(freq)\n    \n    do i = 1, size(freq)\n      norm_freq(i) = freq(i) / total\n    end do\n  end function normalize\n\nend program normalize_frequency\n```"
  },
  {
    "task": "Create a function that accepts a chessboard and makes a move. Discuss how pass-by-reference alters the original board setup.",
    "code": "```fortran\nprogram ChessMove\n    implicit none\n    integer, parameter :: n = 8\n    character(len=1) :: chessboard(n, n)\n    integer :: fromRow, fromCol, toRow, toCol\n\n    call initializeBoard(chessboard)\n    print *, 'Initial Chessboard:'\n    call printBoard(chessboard)\n\n    ! Example move: piece from position (2, 1) to (3, 1)\n    fromRow = 2\n    fromCol = 1\n    toRow = 3\n    toCol = 1\n\n    call makeMove(chessboard, fromRow, fromCol, toRow, toCol)\n    print *, 'Chessboard after move:'\n    call printBoard(chessboard)\n\ncontains\n\n    subroutine initializeBoard(board)\n        character(len=1), intent(out) :: board(n, n)\n        integer :: i, j\n\n        do i = 1, n\n            do j = 1, n\n                if (i == 2) then\n                    board(i, j) = 'P'  ! Initialize pawns\n                elseif (i == 7) then\n                    board(i, j) = 'p'  ! Initialize pawns\n                else\n                    board(i, j) = '.'  ! Empty squares\n                end if\n            end do\n        end do\n        board(1,1) = 'R'; board(1,8) = 'R'  ! Rooks\n        board(8,1) = 'r'; board(8,8) = 'r'  ! Rooks\n        ! Add other pieces as needed for a full board\n    end subroutine initializeBoard\n\n    subroutine makeMove(board, fromRow, fromCol, toRow, toCol)\n        character(len=1), intent(inout) :: board(n, n)\n        integer, intent(in) :: fromRow, fromCol, toRow, toCol\n\n        board(toRow, toCol) = board(fromRow, fromCol)\n        board(fromRow, fromCol) = '.'\n    end subroutine makeMove\n\n    subroutine printBoard(board)\n        character(len=1), intent(in) :: board(n, n)\n        integer :: i, j\n\n        do i = 1, n\n            do j = 1, n\n                write(*, '(A)', advance='no'), board(i, j)\n            end do\n            print *\n        end do\n    end subroutine printBoard\n\nend program ChessMove\n```"
  },
  {
    "task": "Implement a function that takes a decimal number and converts it to binary. Explain the effects of pass-by-value on the original number.",
    "code": "```fortran\nprogram DecimalToBinary\n    implicit none\n    integer :: decimalNumber\n    character(len=32) :: binaryResult\n\n    print *, 'Enter a decimal number:'\n    read *, decimalNumber\n\n    call DecimalToBinaryFunc(decimalNumber, binaryResult)\n    print *, 'Binary: ', trim(binaryResult)\n    print *, 'Original decimal number after function call: ', decimalNumber\n\ncontains\n\n    subroutine DecimalToBinaryFunc(num, binary)\n        integer, intent(in) :: num\n        character(len=32), intent(out) :: binary\n        integer :: n, i\n\n        n = num\n        binary = ''\n        i = 0\n\n        do while (n > 0)\n            if (mod(n, 2) == 0) then\n                binary = '0' // binary\n            else\n                binary = '1' // binary\n            end if\n            n = n / 2\n            i = i + 1\n        end do\n\n        if (len_trim(binary) == 0) then\n            binary = '0'\n        end if\n    end subroutine DecimalToBinaryFunc\n\nend program DecimalToBinary\n```"
  },
  {
    "task": "Develop a function that receives a DNA sequence and counts nucleotides. Illustrate how pass-by-value ensures the original sequence remains intact.",
    "code": "```fortran\nPROGRAM DNA_Count\n  IMPLICIT NONE\n  CHARACTER(LEN=*), PARAMETER :: dna_sequence = \"AGCTTAGCTAAGCTA\"\n  INTEGER :: num_A, num_C, num_G, num_T\n\n  CALL count_nucleotides(dna_sequence, num_A, num_C, num_G, num_T)\n\n  PRINT *, \"A:\", num_A, \" C:\", num_C, \" G:\", num_G, \" T:\", num_T\n\nCONTAINS\n\n  SUBROUTINE count_nucleotides(dna, A, C, G, T)\n    CHARACTER(LEN=*), INTENT(IN) :: dna\n    INTEGER, INTENT(OUT) :: A, C, G, T\n    INTEGER :: i\n\n    A = 0\n    C = 0\n    G = 0\n    T = 0\n\n    DO i = 1, LEN(dna)\n      SELECT CASE (dna(i:i))\n      CASE ('A')\n        A = A + 1\n      CASE ('C')\n        C = C + 1\n      CASE ('G')\n        G = G + 1\n      CASE ('T')\n        T = T + 1\n      END SELECT\n    END DO\n  END SUBROUTINE count_nucleotides\n\nEND PROGRAM DNA_Count\n```"
  },
  {
    "task": "Design a function that accepts a shopping cart object and applies a discount. Show the changes with pass-by-reference.",
    "code": "```fortran\nmodule shopping_module\n    implicit none\n    type :: ShoppingCart\n        real :: totalPrice\n    end type ShoppingCart\ncontains\n    subroutine applyDiscount(cart, discountRate)\n        type(ShoppingCart), intent(inout) :: cart\n        real, intent(in) :: discountRate\n        cart%totalPrice = cart%totalPrice * (1.0 - discountRate)\n    end subroutine applyDiscount\nend module shopping_module\n\nprogram shopping_discount\n    use shopping_module\n    implicit none\n    type(ShoppingCart) :: cart\n    real :: discountRate\n\n    cart%totalPrice = 100.0\n    discountRate = 0.1 ! 10% discount\n\n    call applyDiscount(cart, discountRate)\n\n    print *, \"Discounted total price: \", cart%totalPrice\nend program shopping_discount\n```"
  },
  {
    "task": "Write a program where a function receives a playlist and adds a song. Discuss how pass-by-reference affects the original playlist.",
    "code": "```fortran\nprogram PlaylistManager\n  implicit none\n  integer, parameter :: max_songs = 100\n  integer :: num_songs\n  character(len=50) :: playlist(max_songs)\n  character(len=50) :: new_song\n\n  num_songs = 3\n  playlist(1) = 'Song A'\n  playlist(2) = 'Song B'\n  playlist(3) = 'Song C'\n  new_song = 'Song D'\n\n  call add_song(playlist, num_songs, new_song)\n\n  print *, 'Updated Playlist:'\n  call print_playlist(playlist, num_songs)\n\ncontains\n\n  subroutine add_song(playlist, num_songs, new_song)\n    character(len=50), intent(inout) :: playlist(max_songs)\n    integer, intent(inout) :: num_songs\n    character(len=50), intent(in) :: new_song\n\n    if (num_songs < max_songs) then\n      num_songs = num_songs + 1\n      playlist(num_songs) = new_song\n    end if\n  end subroutine add_song\n\n  subroutine print_playlist(playlist, num_songs)\n    character(len=50), intent(in) :: playlist(max_songs)\n    integer, intent(in) :: num_songs\n    integer :: i\n\n    do i = 1, num_songs\n      print *, playlist(i)\n    end do\n  end subroutine print_playlist\n\nend program PlaylistManager\n```"
  },
  {
    "task": "Create a function that takes a sprite in a game and moves it. Demonstrate the result when the sprite is passed by reference.",
    "code": "```fortran\nmodule sprite_module\n  implicit none\n  type :: Sprite\n    real :: x, y\n  end type Sprite\ncontains\n  subroutine move_sprite(sprite, dx, dy)\n    type(Sprite), intent(inout) :: sprite\n    real, intent(in) :: dx, dy\n    sprite%x = sprite%x + dx\n    sprite%y = sprite%y + dy\n  end subroutine move_sprite\nend module sprite_module\n\nprogram main\n  use sprite_module\n  implicit none\n  type(Sprite) :: my_sprite\n  \n  my_sprite%x = 5.0\n  my_sprite%y = 10.0\n\n  call move_sprite(my_sprite, 2.0, 3.0)\n\n  print *, \"Sprite position:\", my_sprite%x, my_sprite%y\nend program main\n```"
  },
  {
    "task": "Implement a function that accepts a book object and updates the title. Illustrate the impact of pass-by-reference on the original object.",
    "code": "```fortran\nmodule book_module\n  type :: Book\n    character(len=100) :: title\n  end type Book\ncontains\n  subroutine update_title(b, new_title)\n    type(Book), intent(inout) :: b\n    character(len=100), intent(in) :: new_title\n    b%title = new_title\n  end subroutine update_title\nend module book_module\n\nprogram main\n  use book_module\n  type(Book) :: myBook\n\n  myBook%title = \"Original Title\"\n  print *, \"Before update: \", myBook%title\n\n  call update_title(myBook, \"Updated Title\")\n  print *, \"After update: \", myBook%title\nend program main\n```"
  },
  {
    "task": "Develop a function that receives a sound wave and normalizes it. Explain how pass-by-value affects the original sound wave.",
    "code": "```fortran\nmodule sound_module\n  implicit none\ncontains\n  function normalize_wave(sound_wave) result(normalized_wave)\n    real, intent(in) :: sound_wave(:)\n    real :: normalized_wave(size(sound_wave))\n    real :: max_value\n\n    max_value = maxval(abs(sound_wave))\n    if (max_value /= 0.0) then\n      normalized_wave = sound_wave / max_value\n    else\n      normalized_wave = sound_wave\n    end if\n  end function normalize_wave\nend module sound_module\n\nprogram main\n  use sound_module\n  implicit none\n  real :: original_wave(5) = [0.2, -0.4, 0.6, -0.8, 1.0]\n  real :: result_wave(5)\n\n  result_wave = normalize_wave(original_wave)\n\n  print *, 'Original Wave:', original_wave\n  print *, 'Normalized Wave:', result_wave\nend program main\n```"
  },
  {
    "task": "Design a program where a function receives a bank account object and credits an amount. Discuss the effects of pass-by-reference.",
    "code": "```fortran\nmodule bank_module\n    type :: bank_account\n        real :: balance\n    end type bank_account\ncontains\n    subroutine credit_account(account, amount)\n        type(bank_account), intent(inout) :: account\n        real, intent(in) :: amount\n        account%balance = account%balance + amount\n    end subroutine credit_account\nend module bank_module\n\nprogram bank_program\n    use bank_module\n    type(bank_account) :: my_account\n    real :: deposit_amount\n\n    my_account%balance = 100.0\n    deposit_amount = 50.0\n\n    call credit_account(my_account, deposit_amount)\n    print *, \"Updated Balance:\", my_account%balance\nend program bank_program\n```"
  },
  {
    "task": "Write a function that takes an email list and filters out invalid addresses. Show the difference in the list when using pass-by-value.",
    "code": "```fortran\nprogram FilterEmails\n    implicit none\n\n    character(len=100), dimension(5) :: emailList\n    character(len=100), dimension(:), allocatable :: filteredEmails\n    integer :: i\n\n    emailList = [\"valid@example.com\", \"invalid-email\", \"another_valid@example.com\", &\n                 \"bad@.com\", \"good@domain.com\"]\n\n    call filterEmailAddresses(emailList, filteredEmails)\n\n    print *, \"Original Email List:\"\n    do i = 1, size(emailList)\n        print *, trim(emailList(i))\n    end do\n\n    print *, \"Filtered Email List:\"\n    do i = 1, size(filteredEmails)\n        print *, trim(filteredEmails(i))\n    end do\n\ncontains\n\n    subroutine filterEmailAddresses(emails, validEmails)\n        character(len=100), dimension(:), intent(in) :: emails\n        character(len=100), dimension(:), allocatable, intent(out) :: validEmails\n        integer :: i, validCount\n\n        validCount = 0\n        allocate(validEmails(size(emails)))\n\n        do i = 1, size(emails)\n            if (index(emails(i), \"@\") > 1 .and. index(emails(i), \".com\") > 0) then\n                validCount = validCount + 1\n                validEmails(validCount) = emails(i)\n            end if\n        end do\n\n        if (validCount < size(validEmails)) then\n            validEmails = validEmails(:validCount)\n        end if\n    end subroutine filterEmailAddresses\n\nend program FilterEmails\n```"
  },
  {
    "task": "Create a function that accepts a 3D model and scales it. Demonstrate how pass-by-reference affects the original model.",
    "code": "```fortran\nmodule model_scaler\n    implicit none\n    type :: Model3D\n        real, allocatable :: vertices(:,:)\n    end type Model3D\ncontains\n    subroutine scale_model(model, scale_factor)\n        type(Model3D), intent(inout) :: model\n        real, intent(in) :: scale_factor\n        model%vertices = model%vertices * scale_factor\n    end subroutine scale_model\nend module model_scaler\n\nprogram main\n    use model_scaler\n    implicit none\n    type(Model3D) :: my_model\n    real :: scale_factor\n    allocate(my_model%vertices(3, 4))\n    \n    ! Initialize the model's vertices\n    my_model%vertices = reshape([1.0, 2.0, 3.0, &\n                                 4.0, 5.0, 6.0, &\n                                 7.0, 8.0, 9.0, &\n                                 1.0, 1.0, 1.0], [3, 4])\n    \n    ! Set the scale factor\n    scale_factor = 2.0\n\n    ! Scale the model\n    call scale_model(my_model, scale_factor)\n\n    ! Output the scaled model vertices\n    print *, \"Scaled Model Vertices:\"\n    print *, my_model%vertices\nend program main\n```"
  },
  {
    "task": "Implement a function that receives a text document and redacts sensitive information. Explain the impact of pass-by-reference.",
    "code": "```fortran\nPROGRAM RedactSensitiveInfo\n  CHARACTER(LEN=1000) :: document\n  CHARACTER(LEN=1000) :: redactedDocument\n\n  document = \"This is a sample document with sensitive information: SSN 123-45-6789.\"\n\n  CALL RedactDocument(document, redactedDocument)\n  PRINT *, \"Original Document: \", document\n  PRINT *, \"Redacted Document: \", redactedDocument\nEND PROGRAM RedactSensitiveInfo\n\nSUBROUTINE RedactDocument(doc, redactedDoc)\n  CHARACTER(LEN=1000), INTENT(IN) :: doc\n  CHARACTER(LEN=1000), INTENT(OUT) :: redactedDoc\n  INTEGER :: i\n\n  redactedDoc = doc\n  DO i = 1, LEN(doc)\n    IF (i <= LEN(doc) - 10) THEN\n      IF (doc(i:i+2) == 'SSN') THEN\n        redactedDoc(i+4:i+13) = 'XXX-XX-XXXX'\n      END IF\n    END IF\n  END DO\nEND SUBROUTINE RedactDocument\n```"
  },
  {
    "task": "Develop a function that takes a temperature reading and adjusts for calibration. Discuss how pass-by-value ensures the original reading is unchanged.",
    "code": "```fortran\nmodule calibration_module\n    implicit none\ncontains\n    real function adjust_temperature(reading) result(adjusted_reading)\n        real, intent(in) :: reading\n        real :: calibration_offset\n        calibration_offset = 0.5\n        adjusted_reading = reading + calibration_offset\n    end function adjust_temperature\nend module calibration_module\n\nprogram main\n    use calibration_module\n    implicit none\n    real :: temperature, adjusted_temperature\n\n    temperature = 37.0\n    adjusted_temperature = adjust_temperature(temperature)\n    print *, 'Original Temperature:', temperature\n    print *, 'Adjusted Temperature:', adjusted_temperature\nend program main\n```"
  },
  {
    "task": "Design a function that accepts a bug report and updates its status. Show the changes with pass-by-reference.",
    "code": "```fortran\nprogram BugReportUpdater\n  implicit none\n\n  type :: BugReport\n    character(len=100) :: description\n    character(len=20) :: status\n  end type BugReport\n\n  type(BugReport) :: myBug\n\n  myBug%description = \"Application crashes on startup\"\n  myBug%status = \"Open\"\n  \n  call updateBugStatus(myBug)\n\n  print *, \"Bug Description: \", myBug%description\n  print *, \"Bug Status: \", myBug%status\n\ncontains\n\n  subroutine updateBugStatus(bug)\n    type(BugReport), intent(inout) :: bug\n    bug%status = \"Resolved\"\n  end subroutine updateBugStatus\n\nend program BugReportUpdater\n```"
  },
  {
    "task": "Write a program where a function receives a sensor array and calibrates it. Demonstrate the effect of pass-by-reference on the array.",
    "code": "```fortran\nprogram sensor_calibration\n    implicit none\n    real, dimension(5) :: sensor_data = (/ 1.5, 2.5, 3.5, 4.5, 5.5 /)\n    integer :: i\n\n    call calibrate(sensor_data)\n\n    print *, \"Calibrated Sensor Data:\"\n    do i = 1, size(sensor_data)\n        print *, sensor_data(i)\n    end do\n\ncontains\n\n    subroutine calibrate(data)\n        real, dimension(:), intent(inout) :: data\n        integer :: i\n\n        do i = 1, size(data)\n            data(i) = data(i) * 1.1\n        end do\n    end subroutine calibrate\n\nend program sensor_calibration\n```"
  },
  {
    "task": "Create a function that takes a vector and rotates it. Explain how pass-by-value ensures the original vector remains unchanged.",
    "code": "```fortran\nprogram rotate_vector_example\n    implicit none\n    real, dimension(3) :: original_vector = [1.0, 2.0, 3.0]\n    real, dimension(3) :: rotated_vector\n\n    rotated_vector = rotate_vector(original_vector)\n\n    print *, 'Original Vector:', original_vector\n    print *, 'Rotated Vector:', rotated_vector\n\ncontains\n\n    function rotate_vector(vec) result(rotated)\n        real, dimension(3), intent(in) :: vec\n        real, dimension(3) :: rotated\n\n        ! Perform rotation by shifting elements\n        rotated(1) = vec(3)\n        rotated(2) = vec(1)\n        rotated(3) = vec(2)\n    end function rotate_vector\n\nend program rotate_vector_example\n```"
  },
  {
    "task": "Implement a function that accepts an operation log and compresses it. Discuss the impact of pass-by-reference on the log.",
    "code": "```fortran\nmodule log_operations\n  implicit none\ncontains\n\n  subroutine compress_log(log)\n    character(len=*), intent(inout) :: log(:)\n    integer :: i, j, n\n\n    n = size(log)\n    j = 1\n\n    do i = 2, n\n       if (log(i) /= log(j)) then\n          j = j + 1\n          log(j) = log(i)\n       end if\n    end do\n\n    log = log(:j)\n  end subroutine compress_log\n\nend module log_operations\n\nprogram main\n  use log_operations\n  implicit none\n\n  character(len=100) :: operation_log(5) = ['add', 'add', 'delete', 'add', 'delete']\n  integer :: i\n\n  call compress_log(operation_log)\n\n  print *, 'Compressed Log:'\n  do i = 1, size(operation_log)\n     if (trim(operation_log(i)) /= '') then\n        print *, trim(operation_log(i))\n     end if\n  end do\n\nend program main\n```"
  },
  {
    "task": "Develop a function that receives a neural network model and updates its weights. Illustrate the effects of pass-by-reference.",
    "code": "```fortran\nmodule neural_network_module\n    implicit none\n    type :: neural_network\n        real, allocatable :: weights(:)\n    end type neural_network\ncontains\n    subroutine update_weights(model)\n        type(neural_network), intent(inout) :: model\n        integer :: i\n\n        do i = 1, size(model%weights)\n            model%weights(i) = model%weights(i) + 0.1\n        end do\n    end subroutine update_weights\nend module neural_network_module\n\nprogram main\n    use neural_network_module\n    implicit none\n    type(neural_network) :: nn\n    integer :: i\n\n    allocate(nn%weights(5))\n    nn%weights = [0.0, 0.0, 0.0, 0.0, 0.0]\n\n    print *, \"Weights before update:\"\n    print *, nn%weights\n\n    call update_weights(nn)\n\n    print *, \"Weights after update:\"\n    print *, nn%weights\n\nend program main\n```"
  },
  {
    "task": "Design a function that accepts a command history and reverts the last command. Show the changes with pass-by-reference.",
    "code": "```fortran\nmodule command_module\n  implicit none\ncontains\n\n  subroutine revert_last_command(command_history, num_commands)\n    character(len=*), dimension(:), intent(inout) :: command_history\n    integer, intent(inout) :: num_commands\n\n    if (num_commands > 0) then\n      num_commands = num_commands - 1\n      command_history(num_commands + 1) = \"\"\n    end if\n\n  end subroutine revert_last_command\n\nend module command_module\n\nprogram main\n  use command_module\n  implicit none\n  character(len=100), dimension(10) :: command_history\n  integer :: num_commands\n\n  ! Initialize command history\n  command_history = [ \"Command1\", \"Command2\", \"Command3\", \"Command4\", \"Command5\", &\n                      \"Command6\", \"Command7\", \"Command8\", \"Command9\", \"Command10\" ]\n  num_commands = 10\n\n  ! Revert the last command\n  call revert_last_command(command_history, num_commands)\n\n  ! Output the modified command history\n  print *, command_history(1:num_commands)\n\nend program main\n```"
  },
  {
    "task": "Write a function that takes a user profile and anonymizes it. Discuss how pass-by-reference affects the original profile.",
    "code": "```fortran\nmodule user_module\n  implicit none\n  type :: UserProfile\n     character(len=100) :: name\n     character(len=100) :: email\n     integer :: age\n  end type UserProfile\ncontains\n  subroutine anonymize_profile(profile)\n    type(UserProfile), intent(inout) :: profile\n    profile%name = \"Anonymous\"\n    profile%email = \"anon@example.com\"\n    profile%age = -1\n  end subroutine anonymize_profile\nend module user_module\n\nprogram main\n  use user_module\n  implicit none\n  type(UserProfile) :: user\n  ! Initialize user profile\n  user%name = \"John Doe\"\n  user%email = \"johndoe@example.com\"\n  user%age = 30\n  ! Anonymize user profile\n  call anonymize_profile(user)\n  ! Output anonymized profile\n  print *, \"Name: \", user%name\n  print *, \"Email: \", user%email\n  print *, \"Age: \", user%age\nend program main\n```"
  },
  {
    "task": "Create a function that accepts a polynomial and evaluates it at a given point. Explain how pass-by-value ensures the polynomial remains unchanged.",
    "code": "```fortran\nprogram evaluate_polynomial\n  implicit none\n  real :: result\n  real :: coefficients(0:2) = (/ 2.0, -3.0, 1.0 /) ! Example polynomial: 2 - 3x + x^2\n  real :: x_value = 5.0\n\n  result = eval_poly(coefficients, x_value)\n  print *, 'The polynomial evaluated at ', x_value, ' is ', result\n\ncontains\n\n  function eval_poly(coeffs, x) result(value)\n    real, intent(in) :: coeffs(:)\n    real, intent(in) :: x\n    real :: value\n    integer :: i\n    value = 0.0\n    do i = 0, size(coeffs) - 1\n       value = value + coeffs(i) * x**i\n    end do\n  end function eval_poly\n\nend program evaluate_polynomial\n```"
  },
  {
    "task": "Implement a function that receives a video stream and applies a filter. Demonstrate the effects of pass-by-reference on the stream.",
    "code": "```fortran\nmodule video_processing\n  implicit none\ncontains\n  subroutine apply_filter(stream)\n    integer, dimension(:,:), intent(inout) :: stream\n    integer :: i, j\n\n    ! Apply a simple filter to the video stream\n    do i = 1, size(stream, 1)\n      do j = 1, size(stream, 2)\n        stream(i, j) = stream(i, j) + 10\n      end do\n    end do\n  end subroutine apply_filter\nend module video_processing\n\nprogram main\n  use video_processing\n  implicit none\n  integer, dimension(3,3) :: video_stream\n\n  ! Initialize a sample video stream\n  video_stream = reshape((/1, 2, 3, 4, 5, 6, 7, 8, 9/), shape(video_stream))\n\n  print *, 'Original Video Stream:'\n  call print_stream(video_stream)\n\n  ! Apply filter by reference\n  call apply_filter(video_stream)\n\n  print *, 'Filtered Video Stream:'\n  call print_stream(video_stream)\n\ncontains\n  subroutine print_stream(stream)\n    integer, dimension(:,:), intent(in) :: stream\n    integer :: i, j\n\n    do i = 1, size(stream, 1)\n      write(*, '(3I5)') (stream(i, j), j=1, size(stream, 2))\n    end do\n  end subroutine print_stream\nend program main\n```"
  },
  {
    "task": "Develop a function that takes a task queue and reorders tasks based on priority. Illustrate the impact of pass-by-reference.",
    "code": "```fortran\nmodule task_module\n  implicit none\n  type :: Task\n    integer :: priority\n    character(len=50) :: description\n  end type Task\n\ncontains\n\n  subroutine reorder_tasks(task_queue)\n    type(Task), intent(inout) :: task_queue(:)\n    integer :: i, j\n    type(Task) :: temp\n\n    do i = 1, size(task_queue) - 1\n      do j = i + 1, size(task_queue)\n        if (task_queue(j)%priority > task_queue(i)%priority) then\n          temp = task_queue(i)\n          task_queue(i) = task_queue(j)\n          task_queue(j) = temp\n        end if\n      end do\n    end do\n  end subroutine reorder_tasks\n\nend module task_module\n\nprogram main\n  use task_module\n  implicit none\n  type(Task), dimension(3) :: task_queue\n  integer :: i\n\n  task_queue(1) = Task(2, \"Task 2\")\n  task_queue(2) = Task(1, \"Task 1\")\n  task_queue(3) = Task(3, \"Task 3\")\n\n  call reorder_tasks(task_queue)\n\n  do i = 1, size(task_queue)\n    print *, \"Priority:\", task_queue(i)%priority, \"Description:\", task_queue(i)%description\n  end do\n\nend program main\n```"
  },
  {
    "task": "Design a program where a function receives a blockchain and verifies a transaction. Discuss how pass-by-reference affects the blockchain.",
    "code": "```fortran\nmodule blockchain_module\n  implicit none\n  type :: Transaction\n    integer :: sender\n    integer :: receiver\n    real :: amount\n  end type Transaction\n\n  type :: Blockchain\n    type(Transaction), allocatable :: transactions(:)\n    integer :: num_transactions\n  end type Blockchain\ncontains\n\n  subroutine verify_transaction(bc, tx, is_valid)\n    type(Blockchain), intent(inout) :: bc\n    type(Transaction), intent(in) :: tx\n    logical, intent(out) :: is_valid\n    integer :: i\n\n    is_valid = .false.\n    do i = 1, bc%num_transactions\n      if (bc%transactions(i)%sender == tx%sender .and. &\n          bc%transactions(i)%receiver == tx%receiver .and. &\n          bc%transactions(i)%amount == tx%amount) then\n        is_valid = .true.\n        return\n      end if\n    end do\n  end subroutine verify_transaction\n\nend module blockchain_module\n\nprogram main\n  use blockchain_module\n  implicit none\n  type(Blockchain) :: bc\n  type(Transaction) :: tx\n  logical :: is_valid\n\n  ! Initialize blockchain\n  bc%num_transactions = 2\n  allocate(bc%transactions(bc%num_transactions))\n  bc%transactions(1) = Transaction(sender=1, receiver=2, amount=50.0)\n  bc%transactions(2) = Transaction(sender=3, receiver=4, amount=75.0)\n\n  ! Transaction to verify\n  tx = Transaction(sender=1, receiver=2, amount=50.0)\n\n  ! Verify transaction\n  call verify_transaction(bc, tx, is_valid)\n\n  ! Output result\n  if (is_valid) then\n    print *, 'Transaction is valid.'\n  else\n    print *, 'Transaction is invalid.'\n  end if\n\nend program main\n```"
  },
  {
    "task": "Write a function that takes a game leaderboard and updates scores. Show the changes with pass-by-reference.",
    "code": "```fortran\nmodule leaderboard_module\n  implicit none\ncontains\n  subroutine update_scores(leaderboard, new_scores, num_players)\n    integer, intent(inout) :: leaderboard(:)\n    integer, intent(in) :: new_scores(:)\n    integer, intent(in) :: num_players\n    integer :: i\n\n    do i = 1, num_players\n      leaderboard(i) = leaderboard(i) + new_scores(i)\n    end do\n  end subroutine update_scores\nend module leaderboard_module\n\nprogram main\n  use leaderboard_module\n  implicit none\n\n  integer, parameter :: num_players = 3\n  integer :: leaderboard(num_players) = [100, 200, 150]\n  integer :: new_scores(num_players) = [10, 15, -5]\n\n  call update_scores(leaderboard, new_scores, num_players)\n\n  print *, 'Updated Leaderboard:', leaderboard\nend program main\n```"
  },
  {
    "task": "Create a function that accepts a project timeline and adjusts for delays. Explain how pass-by-reference influences the timeline.",
    "code": "```fortran\nprogram project_timeline\n    implicit none\n\n    integer :: timeline, delay\n\n    ! Initialize timeline and delay\n    timeline = 100\n    delay = 20\n\n    ! Call the function to adjust the timeline\n    call adjust_for_delay(timeline, delay)\n\n    ! Output the adjusted timeline\n    print *, \"Adjusted Project Timeline: \", timeline\n\ncontains\n\n    subroutine adjust_for_delay(tl, dl)\n        integer, intent(inout) :: tl\n        integer, intent(in) :: dl\n\n        ! Adjust the timeline by adding the delay\n        tl = tl + dl\n    end subroutine adjust_for_delay\n\nend program project_timeline\n```"
  },
  {
    "task": "Implement a function that receives a to-do list and completes a task. Demonstrate the effect of pass-by-reference on the list.",
    "code": "```fortran\nprogram TodoListDemo\n    implicit none\n    integer, parameter :: max_tasks = 10\n    character(len=50) :: todo_list(max_tasks)\n    integer :: num_tasks, task_to_complete\n\n    num_tasks = 3\n    todo_list(1) = 'Buy groceries'\n    todo_list(2) = 'Prepare presentation'\n    todo_list(3) = 'Call the plumber'\n\n    print *, 'Before completing a task:'\n    call print_list(todo_list, num_tasks)\n\n    task_to_complete = 2\n    call complete_task(todo_list, num_tasks, task_to_complete)\n\n    print *, 'After completing a task:'\n    call print_list(todo_list, num_tasks)\n\ncontains\n\n    subroutine complete_task(list, num, task_index)\n        character(len=50), intent(inout) :: list(max_tasks)\n        integer, intent(inout) :: num\n        integer, intent(in) :: task_index\n        integer :: i\n\n        if (task_index <= num .and. task_index > 0) then\n            do i = task_index, num-1\n                list(i) = list(i+1)\n            end do\n            list(num) = ''\n            num = num - 1\n        end if\n    end subroutine complete_task\n\n    subroutine print_list(list, num)\n        character(len=50), intent(in) :: list(max_tasks)\n        integer, intent(in) :: num\n        integer :: i\n\n        do i = 1, num\n            print *, trim(list(i))\n        end do\n    end subroutine print_list\n\nend program TodoListDemo\n```"
  },
  {
    "task": "Develop a function that takes a paint canvas and adds a layer. Discuss the impact of pass-by-reference on the canvas.",
    "code": "```fortran\nMODULE PaintModule\n  IMPLICIT NONE\nCONTAINS\n\n  SUBROUTINE AddLayer(canvas)\n    ! This subroutine adds a layer to the canvas\n    INTEGER, INTENT(INOUT) :: canvas(:,:)\n    INTEGER :: i, j\n\n    ! Assume adding a layer increases each element by 1\n    DO i = 1, SIZE(canvas, 1)\n      DO j = 1, SIZE(canvas, 2)\n        canvas(i, j) = canvas(i, j) + 1\n      ENDDO\n    ENDDO\n  END SUBROUTINE AddLayer\n\nEND MODULE PaintModule\n\nPROGRAM PaintApp\n  USE PaintModule\n  IMPLICIT NONE\n  INTEGER, ALLOCATABLE :: canvas(:,:)\n  INTEGER :: n, m\n\n  ! Initialize the canvas\n  n = 5\n  m = 5\n  ALLOCATE(canvas(n, m))\n  canvas = 0\n\n  ! Add a layer to the canvas\n  CALL AddLayer(canvas)\n\n  ! Output the modified canvas\n  PRINT *, canvas\n\n  DEALLOCATE(canvas)\n\nEND PROGRAM PaintApp\n```"
  },
  {
    "task": "Design a function that accepts a URL list and fetches content. Show the difference in the list when using pass-by-value.",
    "code": "```fortran\nprogram fetch_content\n    implicit none\n    character(len=256), dimension(:), allocatable :: url_list\n    character(len=256), dimension(:), allocatable :: original_list\n    integer :: i\n\n    allocate(url_list(3))\n    url_list = (/'http://example.com', 'http://example.org', 'http://example.net'/)\n    original_list = url_list\n\n    print *, \"Original List:\"\n    do i = 1, size(url_list)\n        print *, trim(url_list(i))\n    end do\n\n    call fetch_urls(url_list)\n\n    print *, \"After attempting to fetch:\"\n    do i = 1, size(url_list)\n        print *, trim(url_list(i))\n    end do\n\n    print *, \"Original List remains unchanged:\"\n    do i = 1, size(original_list)\n        print *, trim(original_list(i))\n    end do\n\ncontains\n\n    subroutine fetch_urls(list)\n        ! Pass-by-value simulation by using a local copy\n        character(len=256), dimension(:), intent(in) :: list\n        character(len=256), dimension(size(list)) :: local_list\n        integer :: i\n\n        local_list = list\n        do i = 1, size(local_list)\n            local_list(i) = 'Fetched content from '//trim(local_list(i))\n        end do\n\n        print *, \"Inside fetch_urls:\"\n        do i = 1, size(local_list)\n            print *, trim(local_list(i))\n        end do\n    end subroutine fetch_urls\n\nend program fetch_content\n```"
  },
  {
    "task": "Write a program where a function receives a game board and resets it. Illustrate the effects of pass-by-reference.",
    "code": "```fortran\nprogram game_board_reset\n  implicit none\n  integer, parameter :: n = 3\n  integer :: board(n, n)\n  \n  call initialize_board(board)\n  print *, 'Original Board:'\n  call print_board(board)\n  \n  call reset_board(board)\n  print *, 'Reset Board:'\n  call print_board(board)\n\ncontains\n\n  subroutine initialize_board(b)\n    integer, intent(out) :: b(n, n)\n    integer :: i, j\n    do i = 1, n\n      do j = 1, n\n        b(i, j) = i + j\n      end do\n    end do\n  end subroutine initialize_board\n\n  subroutine reset_board(b)\n    integer, intent(inout) :: b(n, n)\n    integer :: i, j\n    do i = 1, n\n      do j = 1, n\n        b(i, j) = 0\n      end do\n    end do\n  end subroutine reset_board\n\n  subroutine print_board(b)\n    integer, intent(in) :: b(n, n)\n    integer :: i, j\n    do i = 1, n\n      write(*, '(3I5)') (b(i, j), j = 1, n)\n    end do\n  end subroutine print_board\n\nend program game_board_reset\n```"
  },
  {
    "task": "Create a function that takes a sound effect and increases its volume. Explain how pass-by-reference affects the original sound.",
    "code": "```fortran\nprogram VolumeIncrease\n  implicit none\n\n  real :: soundEffect(5) = [0.1, 0.2, 0.3, 0.4, 0.5]\n  call IncreaseVolume(soundEffect)\n\ncontains\n\n  subroutine IncreaseVolume(effect)\n    real, intent(inout) :: effect(:)\n    integer :: i\n\n    do i = 1, size(effect)\n      effect(i) = effect(i) * 2.0\n    end do\n\n  end subroutine IncreaseVolume\n\nend program VolumeIncrease\n```"
  },
  {
    "task": "Implement a function that accepts a weather forecast and updates temperature predictions. Discuss the impact of pass-by-reference.",
    "code": "```fortran\nmodule WeatherModule\n  implicit none\ncontains\n\n  subroutine updateTemperature(forecast, temperature)\n    real, intent(inout) :: forecast(:)\n    real, intent(in) :: temperature\n    integer :: i\n\n    do i = 1, size(forecast)\n      forecast(i) = forecast(i) + temperature\n    end do\n  end subroutine updateTemperature\n\nend module WeatherModule\n\nprogram WeatherUpdate\n  use WeatherModule\n  implicit none\n\n  real :: forecastPredictions(5) = [15.0, 17.0, 19.0, 21.0, 23.0]\n  real :: temperatureAdjustment\n\n  temperatureAdjustment = 2.5\n  call updateTemperature(forecastPredictions, temperatureAdjustment)\n\nend program WeatherUpdate\n```"
  },
  {
    "task": "Develop a function that receives a system log and extracts error messages. Show how pass-by-value ensures the original log remains unchanged.",
    "code": "```fortran\nprogram extract_errors\n    implicit none\n\n    character(len=100), dimension(5) :: system_log\n    character(len=100), dimension(:), allocatable :: error_messages\n    integer :: i\n\n    ! Example system log\n    system_log = [ &\n        \"INFO: System started\", &\n        \"ERROR: Disk not found\", &\n        \"INFO: User logged in\", &\n        \"ERROR: Memory overflow\", &\n        \"INFO: Shutdown initiated\" &\n    ]\n\n    ! Extract error messages\n    call get_error_messages(system_log, error_messages)\n\n    ! Output extracted error messages\n    do i = 1, size(error_messages)\n        print *, trim(error_messages(i))\n    end do\n\ncontains\n\n    subroutine get_error_messages(log, errors)\n        character(len=100), dimension(:), intent(in) :: log\n        character(len=100), dimension(:), allocatable :: errors\n        integer :: i, j, count\n        \n        count = 0\n        ! Count error messages\n        do i = 1, size(log)\n            if (index(log(i), \"ERROR:\") /= 0) then\n                count = count + 1\n            end if\n        end do\n\n        allocate(errors(count))\n        j = 0\n\n        ! Extract error messages\n        do i = 1, size(log)\n            if (index(log(i), \"ERROR:\") /= 0) then\n                j = j + 1\n                errors(j) = log(i)\n            end if\n        end do\n    end subroutine get_error_messages\n\nend program extract_errors\n```"
  },
  {
    "task": "Design a function that accepts a data packet and encrypts it. Demonstrate the effect of pass-by-value on the packet.",
    "code": "```fortran\nprogram encrypt_packet_demo\n  implicit none\n\n  character(len=100) :: packet\n  character(len=100) :: encrypted_packet\n\n  packet = 'This is a data packet that needs to be encrypted.'\n\n  print *, 'Original packet:', packet\n\n  encrypted_packet = encrypt_packet(packet)\n\n  print *, 'Encrypted packet:', encrypted_packet\n  print *, 'Packet after function call (pass-by-value):', packet\n\ncontains\n\n  function encrypt_packet(packet) result(encrypted)\n    character(len=100), value :: packet\n    character(len=100) :: encrypted\n    integer :: i\n\n    encrypted = packet\n\n    do i = 1, len_trim(packet)\n      encrypted(i:i) = achar(ichar(packet(i:i)) + 1)\n    end do\n  end function encrypt_packet\n\nend program encrypt_packet_demo\n```"
  },
  {
    "task": "Write a function that takes a website theme and applies a color change. Explain how pass-by-reference affects the original theme.",
    "code": "```fortran\nmodule ThemeModule\n    implicit none\ncontains\n    subroutine ApplyColorChange(theme, newColor)\n        type(Theme), intent(inout) :: theme\n        character(len=*) :: newColor\n\n        theme%color = newColor\n    end subroutine ApplyColorChange\nend module ThemeModule\n\nprogram Main\n    use ThemeModule\n    implicit none\n\n    type Theme\n        character(len=100) :: name\n        character(len=20) :: color\n    end type Theme\n\n    type(Theme) :: myTheme\n\n    ! Initialize the theme\n    myTheme%name = \"Default\"\n    myTheme%color = \"Blue\"\n\n    print *, \"Original theme color:\", myTheme%color\n\n    ! Apply color change\n    call ApplyColorChange(myTheme, \"Red\")\n\n    print *, \"Updated theme color:\", myTheme%color\nend program Main\n```"
  },
  {
    "task": "Create a function that accepts a digital signature and verifies it. Discuss the implications of pass-by-value on the signature.",
    "code": "```fortran\nprogram SignatureVerification\n  implicit none\n  character(len=100) :: signature\n  logical :: isValid\n\n  ! Example signature\n  signature = 'ExampleSignatureValue'\n\n  ! Call the verification function\n  isValid = verifySignature(signature)\n\n  print *, 'Signature is valid: ', isValid\n\ncontains\n\n  logical function verifySignature(sig)\n    character(len=100), intent(in) :: sig\n    ! Dummy implementation for verification\n    if (sig == 'ExampleSignatureValue') then\n      verifySignature = .true.\n    else\n      verifySignature = .false.\n    end if\n  end function verifySignature\n\nend program SignatureVerification\n```"
  },
  {
    "task": "Implement a function that receives a robot's path and optimizes it. Illustrate the effects of pass-by-reference on the path.",
    "code": "```fortran\nmodule robot_module\n  implicit none\ncontains\n  subroutine optimize_path(path)\n    integer, dimension(:), intent(inout) :: path\n    integer :: i\n\n    do i = 2, size(path)\n      if (path(i) == path(i - 1)) then\n        path(i) = 0\n      end if\n    end do\n  end subroutine optimize_path\n\n  subroutine print_path(path)\n    integer, dimension(:), intent(in) :: path\n    integer :: i\n\n    do i = 1, size(path)\n      if (path(i) /= 0) then\n        print *, path(i)\n      end if\n    end do\n  end subroutine print_path\nend module robot_module\n\nprogram main\n  use robot_module\n  implicit none\n\n  integer, dimension(10) :: robot_path = [1, 1, 2, 2, 3, 4, 4, 5, 5, 5]\n\n  print *, \"Original path:\"\n  call print_path(robot_path)\n\n  call optimize_path(robot_path)\n\n  print *, \"Optimized path:\"\n  call print_path(robot_path)\nend program main\n```"
  },
  {
    "task": "Develop a function that takes a music playlist and shuffles it. Demonstrate the impact of pass-by-reference on the playlist.",
    "code": "```fortran\nprogram ShufflePlaylist\n  implicit none\n  integer, parameter :: n = 5\n  character(len=20) :: playlist(n)\n  integer :: i\n\n  playlist = ['SongA', 'SongB', 'SongC', 'SongD', 'SongE']\n  \n  print *, 'Original Playlist:'\n  do i = 1, n\n     print *, playlist(i)\n  end do\n\n  call shuffle(playlist)\n\n  print *, 'Shuffled Playlist:'\n  do i = 1, n\n     print *, playlist(i)\n  end do\n\ncontains\n\n  subroutine shuffle(p)\n    character(len=20), intent(inout) :: p(n)\n    integer :: i, j\n    character(len=20) :: temp\n\n    call random_seed()\n    do i = 1, n\n       call random_number(temp)\n       j = int(temp * n) + 1\n       temp = p(i)\n       p(i) = p(j)\n       p(j) = temp\n    end do\n  end subroutine shuffle\n\nend program ShufflePlaylist\n```"
  },
  {
    "task": "Design a program where a function receives a social media feed and removes duplicates. Show the changes with pass-by-reference.",
    "code": "```fortran\nprogram remove_duplicates\n    implicit none\n    character(len=100), dimension(:), allocatable :: feed\n    integer :: n\n\n    ! Example feed\n    n = 6\n    allocate(feed(n))\n    feed = ['Post1', 'Post2', 'Post1', 'Post3', 'Post2', 'Post4']\n\n    call remove_duplicates_sub(feed)\n\n    print *, 'Feed with duplicates removed: ', feed\n\ncontains\n\n    subroutine remove_duplicates_sub(feed)\n        implicit none\n        character(len=100), dimension(:), allocatable, intent(inout) :: feed\n        character(len=100), dimension(:), allocatable :: unique_feed\n        integer :: i, j, count\n\n        allocate(unique_feed(size(feed)))\n        count = 0\n\n        do i = 1, size(feed)\n            if (.not. any(feed(i) == unique_feed(1:count))) then\n                count = count + 1\n                unique_feed(count) = feed(i)\n            end if\n        end do\n\n        call move_alloc(from=unique_feed(1:count), to=feed)\n    end subroutine remove_duplicates_sub\n\nend program remove_duplicates\n```"
  },
  {
    "task": "Write a function that takes a coding challenge and adds test cases. Discuss the effects of pass-by-reference on the challenge.",
    "code": "```fortran\nmodule challenge_module\n  implicit none\ncontains\n\n  subroutine add_test_cases(challenge)\n    character(len=*), intent(inout) :: challenge\n    character(len=100) :: test_cases\n\n    test_cases = \"Test case 1: Basic test\" // new_line('a') // &\n                 \"Test case 2: Edge test\" // new_line('a')\n\n    challenge = challenge // new_line('a') // test_cases\n  end subroutine add_test_cases\n\nend module challenge_module\n\nprogram main\n  use challenge_module\n  implicit none\n\n  character(len=200) :: coding_challenge\n\n  coding_challenge = \"Solve the equation x + y = 10\"\n\n  call add_test_cases(coding_challenge)\n\n  print *, \"Updated challenge with test cases:\"\n  print *, coding_challenge\n\nend program main\n```"
  },
  {
    "task": "Create a function that accepts an animation sequence and reverses it. Explain how pass-by-value ensures the sequence remains unchanged.",
    "code": "```fortran\nprogram reverse_animation\n    implicit none\n    character(len=100) :: sequence\n    character(len=100) :: reversed_sequence\n\n    sequence = \"ABCDEF\"\n    print *, \"Original sequence: \", sequence\n    reversed_sequence = reverse_sequence(sequence)\n    print *, \"Reversed sequence: \", reversed_sequence\n    print *, \"Sequence after function call: \", sequence\n\ncontains\n\n    function reverse_sequence(seq) result(reversed)\n        character(len=100), intent(in) :: seq\n        character(len=100) :: reversed\n        integer :: i, len\n\n        len = len_trim(seq)\n        do i = 1, len\n            reversed(i:i) = seq(len-i+1:len-i+1)\n        end do\n        if (len < len(reversed)) then\n            reversed(len+1:) = ' '\n        end if\n    end function reverse_sequence\n\nend program reverse_animation\n```"
  },
  {
    "task": "Implement a function that receives a GPS route and recalculates it. Illustrate the impact of pass-by-reference on the route.",
    "code": "```fortran\nMODULE RouteModule\n  IMPLICIT NONE\nCONTAINS\n\n  SUBROUTINE RecalculateRoute(route)\n    DOUBLE PRECISION, DIMENSION(:,:), INTENT(INOUT) :: route\n    INTEGER :: i, numPoints\n\n    numPoints = SIZE(route, 1)\n    DO i = 1, numPoints\n      route(i, 1) = route(i, 1) + 0.1\n      route(i, 2) = route(i, 2) + 0.1\n    END DO\n  END SUBROUTINE RecalculateRoute\n\nEND MODULE RouteModule\n\nPROGRAM TestRoute\n  USE RouteModule\n  IMPLICIT NONE\n  DOUBLE PRECISION, DIMENSION(3,2) :: gpsRoute\n  INTEGER :: i\n\n  gpsRoute = RESHAPE((/40.7128, -74.0060, 34.0522, -118.2437, 37.7749, -122.4194/), (/3,2/))\n\n  CALL RecalculateRoute(gpsRoute)\n\n  DO i = 1, SIZE(gpsRoute, 1)\n    PRINT *, \"Point \", i, \": Lat = \", gpsRoute(i, 1), \", Lon = \", gpsRoute(i, 2)\n  END DO\nEND PROGRAM TestRoute\n```"
  },
  {
    "task": "Develop a function that takes a chat history and censors inappropriate language. Show the effect of pass-by-reference on the history.",
    "code": "```fortran\nmodule chat_module\n  implicit none\n  character(len=32), parameter :: bad_word = 'inappropriate'\n  character(len=32), parameter :: censor_word = '*************'\ncontains\n  subroutine censor_chat(history)\n    character(len=32), dimension(:), intent(inout) :: history\n    integer :: i\n    do i = 1, size(history)\n      if (index(history(i), bad_word) /= 0) then\n        history(i) = adjustl(censor_word)\n      end if\n    end do\n  end subroutine censor_chat\nend module chat_module\n\nprogram main\n  use chat_module\n  implicit none\n  character(len=32), dimension(3) :: chat_history\n\n  chat_history = (/ 'Hello there!', 'This is inappropriate', 'Have a nice day!' /)\n\n  print *, 'Before censorship:'\n  call print_chat(chat_history)\n\n  call censor_chat(chat_history)\n\n  print *, 'After censorship:'\n  call print_chat(chat_history)\n\ncontains\n  subroutine print_chat(chat)\n    character(len=32), dimension(:), intent(in) :: chat\n    integer :: i\n    do i = 1, size(chat)\n      print *, trim(chat(i))\n    end do\n  end subroutine print_chat\nend program main\n```"
  },
  {
    "task": "Design a function that accepts a lighting setup and adjusts brightness. Discuss the changes when the setup is passed by reference.",
    "code": "```fortran\nprogram LightingControl\n  implicit none\n  real :: brightness\n  type :: LightingSetup\n    real :: brightness_level\n  end type LightingSetup\n\n  type(LightingSetup) :: mySetup\n\n  ! Initialize lighting setup\n  mySetup%brightness_level = 50.0\n\n  ! Adjust brightness by reference\n  call adjustBrightness(mySetup, 20.0)\n\n  ! Output the adjusted brightness level\n  print *, \"Adjusted Brightness Level:\", mySetup%brightness_level\n\ncontains\n\n  subroutine adjustBrightness(setup, adjustment)\n    type(LightingSetup), intent(inout) :: setup\n    real, intent(in) :: adjustment\n\n    ! Adjust the brightness level\n    setup%brightness_level = setup%brightness_level + adjustment\n\n  end subroutine adjustBrightness\n\nend program LightingControl\n```"
  },
  {
    "task": "Write a program where a function receives a VR environment and changes the scenery. Demonstrate the effects of pass-by-reference.",
    "code": "```fortran\nPROGRAM VRSceneryChange\n  IMPLICIT NONE\n  TYPE VR_Environment\n    CHARACTER(LEN=100) :: scenery\n  END TYPE VR_Environment\n\n  TYPE(VR_Environment) :: environment\n\n  environment%scenery = \"Beach\"\n\n  PRINT *, \"Initial Scenery: \", environment%scenery\n  CALL ChangeScenery(environment)\n  PRINT *, \"Updated Scenery: \", environment%scenery\n\nCONTAINS\n\n  SUBROUTINE ChangeScenery(env)\n    TYPE(VR_Environment), INTENT(INOUT) :: env\n    env%scenery = \"Mountain\"\n  END SUBROUTINE ChangeScenery\n\nEND PROGRAM VRSceneryChange\n```"
  },
  {
    "task": "Create a function that takes a blockchain ledger and adds a block. Explain how pass-by-reference affects the ledger.",
    "code": "```fortran\nmodule blockchain_module\n  implicit none\n  type :: Block\n    integer :: index\n    character(len=100) :: data\n  end type Block\n\n  type :: Ledger\n    type(Block), allocatable :: blocks(:)\n  end type Ledger\n\ncontains\n\n  subroutine add_block(ledger, new_block)\n    type(Ledger), intent(inout) :: ledger\n    type(Block), intent(in) :: new_block\n    integer :: n\n\n    n = size(ledger%blocks)\n    if (n == 0) then\n      allocate(ledger%blocks(1))\n      ledger%blocks(1) = new_block\n    else\n      allocate(ledger%blocks(n+1))\n      ledger%blocks(1:n) = ledger%blocks\n      ledger%blocks(n+1) = new_block\n    end if\n  end subroutine add_block\n\nend module blockchain_module\n```"
  },
  {
    "task": "Implement a function that accepts a network packet and alters its headers. Discuss the implications of pass-by-value on the packet.",
    "code": "```fortran\nprogram packetModifier\n    implicit none\n\n    type :: Packet\n        character(len=100) :: header\n        character(len=500) :: data\n    end type Packet\n\n    type(Packet) :: netPacket\n\n    ! Initialize the packet\n    netPacket%header = 'Initial Header'\n    netPacket%data = 'Some data'\n\n    print *, 'Before modification: ', netPacket%header\n\n    call modifyPacket(netPacket)\n\n    print *, 'After modification: ', netPacket%header\n\ncontains\n\n    subroutine modifyPacket(p)\n        type(Packet), intent(inout) :: p\n        p%header = 'Modified Header'\n    end subroutine modifyPacket\n\nend program packetModifier\n```"
  }
]