[
  {
    "task": "Convert a list of temperatures from Celsius to Fahrenheit using a map function.",
    "code": "```fortran\nprogram temperature_conversion\n    implicit none\n    real, dimension(:), allocatable :: celsius, fahrenheit\n\n    celsius = [0.0, 20.0, 37.0, 100.0]\n    allocate(fahrenheit(size(celsius)))\n    fahrenheit = map(celsius, c_to_f)\n\n    print *, fahrenheit\n\ncontains\n\n    real function c_to_f(c)\n        real, intent(in) :: c\n        c_to_f = c * 9.0 / 5.0 + 32.0\n    end function c_to_f\n\n    elemental function map(array, func)\n        real, dimension(:), intent(in) :: array\n        interface\n            real function func(x)\n                real, intent(in) :: x\n            end function func\n        end interface\n        real, dimension(size(array)) :: map\n        integer :: i\n\n        do i = 1, size(array)\n            map(i) = func(array(i))\n        end do\n    end function map\n\nend program temperature_conversion\n```"
  },
  {
    "task": "Use map to convert a list of lowercase words to uppercase.",
    "code": "```fortran\nprogram map_to_uppercase\n    implicit none\n    character(len=*), dimension(:), allocatable :: words, uppercase_words\n    integer :: i\n\n    words = [ \"hello\", \"world\", \"fortran\", \"map\", \"example\" ]\n    allocate(uppercase_words(size(words)))\n\n    call map_to_upper(words, uppercase_words)\n\n    do i = 1, size(uppercase_words)\n        print *, uppercase_words(i)\n    end do\n\ncontains\n\n    subroutine map_to_upper(input, output)\n        character(len=*), dimension(:), intent(in) :: input\n        character(len=*), dimension(:), intent(out) :: output\n        integer :: i\n\n        do i = 1, size(input)\n            output(i) = adjustl(adjustl(input(i)))  ! Convert to uppercase\n        end do\n    end subroutine map_to_upper\n\nend program map_to_uppercase\n```"
  },
  {
    "task": "Apply map to add a prefix to each string in a list of filenames.",
    "code": "```fortran\nprogram prefix_filenames\n    implicit none\n    character(len=:), allocatable :: filenames(:)\n    character(len=:), allocatable :: new_filenames(:)\n    character(len=20) :: prefix\n    integer :: i\n\n    ! Example filenames\n    filenames = [character(len=20) :: 'file1.txt', 'file2.txt', 'file3.txt']\n    prefix = 'prefix_'\n\n    call map_prefix(filenames, prefix, new_filenames)\n\n    do i = 1, size(new_filenames)\n        print *, new_filenames(i)\n    end do\n\ncontains\n\n    subroutine map_prefix(filenames, prefix, new_filenames)\n        character(len=*), intent(in) :: filenames(:)\n        character(len=*), intent(in) :: prefix\n        character(len=:), allocatable, intent(out) :: new_filenames(:)\n        integer :: i\n\n        allocate(character(len=len(prefix) + len(filenames(1))) :: new_filenames(size(filenames)))\n\n        do i = 1, size(filenames)\n            new_filenames(i) = prefix // filenames(i)\n        end do\n\n    end subroutine map_prefix\n\nend program prefix_filenames\n```"
  },
  {
    "task": "Transform a list of numbers by squaring each element with a map function.",
    "code": "```fortran\nprogram square_map\n    implicit none\n    integer, parameter :: n = 5\n    integer :: i\n    integer, dimension(n) :: numbers = [1, 2, 3, 4, 5]\n    integer, dimension(n) :: squared_numbers\n\n    squared_numbers = [(numbers(i)**2, i = 1, n)]\n\n    print *, \"Squared numbers: \", squared_numbers\nend program square_map\n```"
  },
  {
    "task": "Convert a list of integers to their string representations using map.",
    "code": "```fortran\nprogram convert_integers_to_strings\n    implicit none\n    integer, dimension(5) :: int_list = [1, 2, 3, 4, 5]\n    character(len=10), dimension(5) :: str_list\n    integer :: i\n\n    interface map_to_string\n        module procedure int_to_string\n    end interface\n\n    call map_to_string(int_list, str_list)\n\n    print *, str_list\n\ncontains\n\n    subroutine int_to_string(input, output)\n        integer, dimension(:), intent(in) :: input\n        character(len=10), dimension(:), intent(out) :: output\n        integer :: i\n\n        do i = 1, size(input)\n            write(output(i), '(I0)') input(i)\n        end do\n    end subroutine\n\nend program\n```"
  },
  {
    "task": "Use map to compute the length of each string in a list of sentences.",
    "code": "```fortran\nprogram map_string_lengths\n    implicit none\n    character(len=:), allocatable :: sentences(:)\n    integer, allocatable :: lengths(:)\n    \n    sentences = [ \"The quick brown fox\", \"jumps over\", \"the lazy dog\" ]\n    call map_string_lengths(sentences, lengths)\n    \n    print *, lengths\ncontains\n    subroutine map_string_lengths(strs, lens)\n        character(len=*), intent(in) :: strs(:)\n        integer, allocatable, intent(out) :: lens(:)\n        integer :: i\n\n        allocate(lens(size(strs)))\n        do i = 1, size(strs)\n            lens(i) = len(trim(strs(i)))\n        end do\n    end subroutine map_string_lengths\nend program map_string_lengths\n```"
  },
  {
    "task": "Apply a discount to a list of prices using a map function.",
    "code": "```fortran\nprogram discount_prices\n    implicit none\n    real, dimension(:), allocatable :: prices, discounted_prices\n    real :: discount\n    integer :: i\n\n    prices = [100.0, 250.0, 75.0, 50.0, 200.0]\n    discount = 0.1\n\n    allocate(discounted_prices(size(prices)))\n\n    discounted_prices = [(price * (1.0 - discount), price) :: price in prices]\n\n    do i = 1, size(discounted_prices)\n        print *, discounted_prices(i)\n    end do\n\nend program discount_prices\n```"
  },
  {
    "task": "Extract the first element from each tuple in a list of tuples with map.",
    "code": "```fortran\nprogram map_example\n    implicit none\n    integer, parameter :: n = 5\n    integer :: i\n    integer :: first_elements(n)\n    type :: tuple\n        integer :: first\n        integer :: second\n    end type tuple\n    type(tuple) :: tuples(n)\n\n    ! Initialize the list of tuples\n    do i = 1, n\n        tuples(i)%first = i\n        tuples(i)%second = i * 10\n    end do\n\n    ! Apply the map-like operation to extract first elements\n    first_elements = [(tuples(i)%first, i = 1, n)]\n\n    ! Print the result\n    print *, first_elements\nend program map_example\n```"
  },
  {
    "task": "Use map to round a list of floating-point numbers to two decimal places.",
    "code": "```fortran\nprogram functional_map\n    implicit none\n    real, dimension(:), allocatable :: numbers, rounded_numbers\n    integer :: i\n\n    numbers = [1.12345, 3.14159, 2.71828, 9.87654]\n    allocate(rounded_numbers(size(numbers)))\n\n    rounded_numbers = [(round(numbers(i), 2), i = 1, size(numbers))]\n\n    print *, rounded_numbers\nend program functional_map\n```"
  },
  {
    "task": "Capitalize the first letter of each word in a list of names using map.",
    "code": "```fortran\nprogram capitalize_names\n    implicit none\n    character(len=100), dimension(:), allocatable :: names, capitalized_names\n    integer :: i\n\n    names = [ \"john doe\", \"jane smith\", \"alice johnson\" ]\n    allocate(capitalized_names(size(names)))\n    capitalized_names = map(names, capitalize)\n\n    do i = 1, size(capitalized_names)\n        print *, trim(capitalized_names(i))\n    end do\n\ncontains\n\n    pure function capitalize(name) result(capitalized_name)\n        character(len=100), intent(in) :: name\n        character(len=100) :: capitalized_name\n        integer :: j, len_name\n\n        capitalized_name = name\n        len_name = len_trim(name)\n\n        do j = 1, len_name\n            if (j == 1 .or. (j > 1 .and. name(j-1:j-1) == ' ')) then\n                if (capitalized_name(j:j) >= 'a' .and. capitalized_name(j:j) <= 'z') then\n                    capitalized_name(j:j) = char(iachar(capitalized_name(j:j)) - 32)\n                end if\n            end if\n        end do\n    end function capitalize\n\n    pure function map(input_array, func) result(output_array)\n        character(len=100), dimension(:), intent(in) :: input_array\n        interface\n            pure function func(name) result(output)\n                character(len=100), intent(in) :: name\n                character(len=100) :: output\n            end function func\n        end interface\n        character(len=100), dimension(size(input_array)) :: output_array\n        integer :: i\n\n        do i = 1, size(input_array)\n            output_array(i) = func(input_array(i))\n        end do\n    end function map\n\nend program capitalize_names\n```"
  },
  {
    "task": "Convert a list of JSON strings to corresponding dictionary objects with map.",
    "code": "```fortran\nprogram json_map\n    use iso_fortran_env\n    implicit none\n    character(len=:), allocatable :: json_strings(:), json_string\n    type(json_value), allocatable :: json_objects(:)\n    integer :: i\n\n    ! Example list of JSON strings\n    allocate(json_strings(3))\n    json_strings = [ &\n        '{\"name\": \"Alice\", \"age\": 30}', &\n        '{\"name\": \"Bob\", \"age\": 25}', &\n        '{\"name\": \"Charlie\", \"age\": 35}' &\n    ]\n\n    ! Allocate json_objects array\n    allocate(json_objects(size(json_strings)))\n\n    ! Map the json strings to json objects\n    json_objects = [ (json_parse(json_strings(i)), i=1, size(json_strings)) ]\n\n    ! Output json_objects\n    do i = 1, size(json_objects)\n        call json_print(json_objects(i))\n    end do\n\ncontains\n\n    function json_parse(json_string) result(json_object)\n        character(len=*), intent(in) :: json_string\n        type(json_value) :: json_object\n        ! Dummy implementation of JSON parsing\n        ! Actual implementation would parse json_string to json_object\n    end function json_parse\n\n    subroutine json_print(json_object)\n        type(json_value), intent(in) :: json_object\n        ! Dummy implementation of JSON printing\n        ! Actual implementation would output json_object\n    end subroutine json_print\n\nend program json_map\n\ntype json_value\n    ! This is a placeholder for a more complex type that would represent a JSON object\nend type json_value\n```"
  },
  {
    "task": "Use map to double the value of each number in a list.",
    "code": "```fortran\nprogram double_values\n  implicit none\n  integer, dimension(:), allocatable :: numbers, doubled_numbers\n  integer :: n, i\n\n  ! Sample list of numbers\n  numbers = [1, 2, 3, 4, 5]\n  n = size(numbers)\n  allocate(doubled_numbers(n))\n\n  ! Use a functional approach to double each value\n  doubled_numbers = [(2 * numbers(i), i = 1, n)]\n\n  ! Output the doubled numbers\n  print *, doubled_numbers\n\nend program double_values\n```"
  },
  {
    "task": "Transform a list of RGB tuples to hexadecimal color codes using map.",
    "code": "```fortran\nprogram rgb_to_hex\n  implicit none\n  integer, dimension(:,:), allocatable :: rgb_list\n  character(len=7), dimension(:), allocatable :: hex_list\n\n  allocate(rgb_list(3, 3))\n  allocate(hex_list(3))\n\n  rgb_list(:, 1) = [255, 0, 0]\n  rgb_list(:, 2) = [0, 255, 0]\n  rgb_list(:, 3) = [0, 0, 255]\n\n  call map_rgb_to_hex(rgb_list, hex_list)\n\n  print *, hex_list\n\ncontains\n\n  subroutine map_rgb_to_hex(rgb, hex)\n    integer, dimension(:, :), intent(in) :: rgb\n    character(len=7), dimension(:), intent(out) :: hex\n    integer :: i\n\n    do i = 1, size(rgb, 2)\n      write(hex(i), '(A)') '#' // adjustl(to_hex(rgb(1, i))) // &\n                             adjustl(to_hex(rgb(2, i))) // &\n                             adjustl(to_hex(rgb(3, i)))\n    end do\n  end subroutine map_rgb_to_hex\n\n  function to_hex(value) result(hex)\n    integer, intent(in) :: value\n    character(len=2) :: hex\n\n    write(hex, '(Z2.2)') value\n  end function to_hex\n\nend program rgb_to_hex\n```"
  },
  {
    "task": "Use map to compute the factorial of each number in a list.",
    "code": "```fortran\nprogram factorial_map\n    implicit none\n    integer, parameter :: n = 5\n    integer :: i\n    integer :: numbers(n) = [1, 2, 3, 4, 5]\n    integer :: results(n)\n\n    results = [(factorial(num), num= numbers)]\n\n    do i = 1, n\n        print *, \"Factorial of \", numbers(i), \" is \", results(i)\n    end do\n\ncontains\n\n    recursive function factorial(x) result(fact)\n        integer, intent(in) :: x\n        integer :: fact\n        if (x <= 1) then\n            fact = 1\n        else\n            fact = x * factorial(x - 1)\n        end if\n    end function factorial\n\nend program factorial_map\n```"
  },
  {
    "task": "Translate a list of English words to Spanish using a map function.",
    "code": "```fortran\nmodule translation_module\n    implicit none\n    private\n    public :: translate_words\n\ncontains\n\n    function translate_word(word) result(translated)\n        character(len=*), intent(in) :: word\n        character(len=15) :: translated\n        select case (trim(adjustl(word)))\n        case ('hello')\n            translated = 'hola'\n        case ('world')\n            translated = 'mundo'\n        case ('good')\n            translated = 'bueno'\n        case ('morning')\n            translated = 'ma\u00f1ana'\n        case ('night')\n            translated = 'noche'\n        case default\n            translated = 'unknown'\n        end select\n    end function translate_word\n\n    function map_translate(words) result(translations)\n        character(len=*), dimension(:), intent(in) :: words\n        character(len=15), dimension(size(words)) :: translations\n        integer :: i\n        do i = 1, size(words)\n            translations(i) = translate_word(words(i))\n        end do\n    end function map_translate\n\n    function translate_words(words) result(translations)\n        character(len=*), dimension(:), intent(in) :: words\n        character(len=15), dimension(size(words)) :: translations\n        translations = map_translate(words)\n    end function translate_words\n\nend module translation_module\n\nprogram main\n    use translation_module\n    implicit none\n    character(len=20), dimension(5) :: english_words = (/ 'hello', 'world', 'good', 'morning', 'night' /)\n    character(len=15), dimension(5) :: spanish_words\n\n    spanish_words = translate_words(english_words)\n\n    print *, 'English Words:', english_words\n    print *, 'Spanish Translations:', spanish_words\nend program main\n```"
  },
  {
    "task": "Apply a map function to format a list of dates from one format to another.",
    "code": "```fortran\nprogram format_dates\n  implicit none\n  character(len=10), dimension(:), allocatable :: dates, formatted_dates\n  integer :: i\n\n  dates = [ \"2023-10-05\", \"2023-11-15\", \"2023-12-25\" ]\n  allocate(formatted_dates(size(dates)))\n\n  call map_format_dates(dates, formatted_dates)\n\n  do i = 1, size(formatted_dates)\n     print *, formatted_dates(i)\n  end do\n\ncontains\n\n  subroutine map_format_dates(input_dates, output_dates)\n    character(len=10), dimension(:), intent(in) :: input_dates\n    character(len=10), dimension(:), intent(out) :: output_dates\n    integer :: i\n    do i = 1, size(input_dates)\n       output_dates(i) = format_date(input_dates(i))\n    end do\n  end subroutine map_format_dates\n\n  function format_date(date_str) result(formatted_date)\n    character(len=10), intent(in) :: date_str\n    character(len=10) :: formatted_date\n    integer :: year, month, day\n    read(date_str, '(I4,1X,I2,1X,I2)') year, month, day\n    write(formatted_date, '(I2.2,1X,I2.2,1X,I4)') day, month, year\n  end function format_date\n\nend program format_dates\n```"
  },
  {
    "task": "Use map to check if each number in a list is even, returning a list of booleans.",
    "code": "```fortran\nprogram check_even\n    implicit none\n    integer, parameter :: n = 5\n    integer :: numbers(n) = [1, 2, 3, 4, 5]\n    logical :: is_even(n)\n\n    is_even = [(mod(numbers(i), 2) == 0, i = 1, n)]\n    \n    print *, is_even\nend program check_even\n```"
  },
  {
    "task": "Convert a list of binary strings to decimal numbers using map.",
    "code": "```fortran\nprogram convertBinaryStrings\n    implicit none\n    character(len=:), allocatable :: binaryStrings(:)\n    integer :: i\n    integer, allocatable :: decimalNumbers(:)\n\n    binaryStrings = [ \"101\", \"110\", \"111\", \"1001\" ]\n    allocate(decimalNumbers(size(binaryStrings)))\n\n    call map(binaryStrings, decimalNumbers, binaryToDecimal)\n\n    print *, decimalNumbers\n\ncontains\n\n    subroutine map(arrIn, arrOut, func)\n        character(len=*), intent(in) :: arrIn(:)\n        integer, intent(out) :: arrOut(:)\n        interface\n            function func(str) result(out)\n                character(len=*), intent(in) :: str\n                integer :: out\n            end function func\n        end interface\n        integer :: i\n\n        do i = 1, size(arrIn)\n            arrOut(i) = func(trim(arrIn(i)))\n        end do\n    end subroutine map\n\n    function binaryToDecimal(binaryStr) result(decimal)\n        character(len=*), intent(in) :: binaryStr\n        integer :: decimal, i, lenStr\n\n        lenStr = len_trim(binaryStr)\n        decimal = 0\n\n        do i = 1, lenStr\n            decimal = decimal * 2 + ichar(binaryStr(i:i)) - ichar('0')\n        end do\n    end function binaryToDecimal\n\nend program convertBinaryStrings\n```"
  },
  {
    "task": "Use map to append a domain name to a list of user names to create email addresses.",
    "code": "```fortran\nprogram create_email_addresses\n  implicit none\n  character(len=20), dimension(:), allocatable :: usernames, emails\n  character(len=25) :: domain\n  integer :: i\n\n  usernames = [ 'alice', 'bob', 'charlie' ]\n  domain = '@example.com'\n  allocate(emails(size(usernames)))\n\n  ! Apply the transformation using a map-like approach\n  do i = 1, size(usernames)\n    call map_email(usernames(i), domain, emails(i))\n  end do\n\n  ! Output the resulting emails\n  do i = 1, size(emails)\n    print *, emails(i)\n  end do\n\ncontains\n\n  subroutine map_email(username, domain, email)\n    character(len=*), intent(in) :: username, domain\n    character(len=25), intent(out) :: email\n    email = trim(username) // trim(domain)\n  end subroutine map_email\n\nend program create_email_addresses\n```"
  },
  {
    "task": "Calculate the area of each circle in a list of radii using a map function.",
    "code": "```fortran\nprogram calculate_circle_areas\n  implicit none\n  real, dimension(:), allocatable :: radii, areas\n  integer :: i, n\n\n  n = 5\n  allocate(radii(n))\n  radii = [1.0, 2.0, 3.0, 4.0, 5.0]\n\n  allocate(areas(n))\n  areas = map_circle_areas(radii)\n\n  print *, areas\n\ncontains\n\n  function map_circle_areas(radii) result(areas)\n    real, dimension(:), intent(in) :: radii\n    real, dimension(size(radii)) :: areas\n    integer :: i\n\n    do i = 1, size(radii)\n      areas(i) = circle_area(radii(i))\n    end do\n  end function map_circle_areas\n\n  function circle_area(radius) result(area)\n    real, intent(in) :: radius\n    real :: area\n    real, parameter :: pi = 3.141592653589793\n\n    area = pi * radius * radius\n  end function circle_area\n\nend program calculate_circle_areas\n```"
  },
  {
    "task": "Use map to strip whitespace from the start and end of each string in a list.",
    "code": "```fortran\nprogram trim_strings\n    implicit none\n    character(len=:), allocatable :: strings(:)\n    character(len=:), allocatable :: trimmed_strings(:)\n    integer :: i\n\n    strings = [ &\n        \"  Hello  \", &\n        \"  Fortran  \", &\n        \"  World  \" &\n    ]\n\n    allocate(trimmed_strings(size(strings)))\n    trimmed_strings = map(trim, strings)\n\n    do i = 1, size(trimmed_strings)\n        print *, trimmed_strings(i)\n    end do\nend program trim_strings\n\npure function map(func, array) result(mapped_array)\n    implicit none\n    character(len=:), allocatable, intent(in) :: array(:)\n    character(len=:), allocatable :: mapped_array(:)\n    character(len=*), external :: func\n    integer :: i\n\n    allocate(mapped_array(size(array)))\n    do i = 1, size(array)\n        mapped_array(i) = func(trim(array(i)))\n    end do\nend function map\n```"
  },
  {
    "task": "Apply map to replace spaces with underscores in a list of file paths.",
    "code": "```fortran\nprogram replace_spaces_with_underscores\n    implicit none\n    character(len=256), dimension(5) :: file_paths = [ &\n        \"file one.txt\", \"second file.doc\", \"another file.pdf\", &\n        \"my file.csv\", \"final file.xls\" ]\n    integer :: i\n\n    file_paths = map(file_paths, replace_spaces)\n\n    do i = 1, size(file_paths)\n        print *, trim(file_paths(i))\n    end do\n\ncontains\n\n    pure function replace_spaces(path) result(new_path)\n        character(len=256), intent(in) :: path\n        character(len=256) :: new_path\n        integer :: j\n\n        new_path = path\n        do j = 1, len_trim(path)\n            if (new_path(j:j) == ' ') new_path(j:j) = '_'\n        end do\n    end function replace_spaces\n\n    elemental function map(paths, func) result(mapped_array)\n        character(len=256), dimension(:), intent(in) :: paths\n        character(len=256), dimension(size(paths)) :: mapped_array\n        interface\n            pure function func(arg) result(res)\n                character(len=256), intent(in) :: arg\n                character(len=256) :: res\n            end function func\n        end interface\n        integer :: i\n\n        do i = 1, size(paths)\n            mapped_array(i) = func(paths(i))\n        end do\n    end function map\n\nend program replace_spaces_with_underscores\n```"
  },
  {
    "task": "Convert a list of mixed-case strings to title case using map.",
    "code": "```fortran\nprogram title_case_map\n    implicit none\n    character(len=100), dimension(:), allocatable :: strings, title_cased\n    integer :: i\n\n    strings = [ \"hello world\", \"FORTRAN programming\", \"mixed CASE strings\" ]\n    title_cased = map(strings, title_case)\n\n    do i = 1, size(title_cased)\n        print *, trim(title_cased(i))\n    end do\n\ncontains\n\n    pure function title_case(s) result(res)\n        character(len=*), intent(in) :: s\n        character(len=len(s)) :: res\n        integer :: i\n        logical :: capitalize\n\n        res = s\n        capitalize = .true.\n\n        do i = 1, len(s)\n            if (capitalize .and. res(i:i) >= 'a' .and. res(i:i) <= 'z') then\n                res(i:i) = char(iachar(res(i:i)) - iachar('a') + iachar('A'))\n                capitalize = .false.\n            else if (.not.capitalize .and. res(i:i) >= 'A' .and. res(i:i) <= 'Z') then\n                res(i:i) = char(iachar(res(i:i)) - iachar('A') + iachar('a'))\n            end if\n\n            if (res(i:i) == ' ') capitalize = .true.\n        end do\n    end function title_case\n\n    pure function map(arr, func) result(res_arr)\n        character(len=*), dimension(:), intent(in) :: arr\n        character(len=len(arr)), dimension(size(arr)) :: res_arr\n        interface\n            pure function func(s) result(res)\n                character(len=*), intent(in) :: s\n                character(len=len(s)) :: res\n            end function func\n        end interface\n\n        integer :: i\n\n        do i = 1, size(arr)\n            res_arr(i) = func(trim(arr(i)))\n        end do\n    end function map\n\nend program title_case_map\n```"
  },
  {
    "task": "Use map to filter out only the digits from a list of mixed alphanumeric strings.",
    "code": "```fortran\nprogram filter_digits\n  implicit none\n  character(len=100) :: mixed_strings(5) = [ &\n    'abc123', 'def456', '789ghi', 'jkl0', 'mnop' &\n  ]\n  character(len=100) :: result(5)\n  integer :: i\n\n  result = [ (pack(mixed_strings(i), isdigit(mixed_strings(i:i))), i=1, 5) ]\n\n  print *, trim(result)\ncontains\n  logical function isdigit(c)\n    character, intent(in) :: c\n    isdigit = (c >= '0' .and. c <= '9')\n  end function isdigit\nend program filter_digits\n```"
  },
  {
    "task": "Apply map to convert a list of Unix timestamps to readable date strings.",
    "code": "```fortran\nprogram convert_timestamps\n    implicit none\n    integer, parameter :: n = 5\n    integer :: i\n    integer, dimension(n) :: unix_timestamps = [1609459200, 1612137600, 1614556800, 1617235200, 1619827200]\n    character(20) :: date_strings(n)\n\n    interface\n        function unix_to_date(unix_timestamp) result(date_string)\n            integer, intent(in) :: unix_timestamp\n            character(20) :: date_string\n        end function unix_to_date\n    end interface\n\n    date_strings = [(unix_to_date(unix_timestamps(i)), i = 1, n)]\n\n    do i = 1, n\n        print *, 'Unix:', unix_timestamps(i), ' -> Date:', date_strings(i)\n    end do\ncontains\n    function unix_to_date(unix_timestamp) result(date_string)\n        integer, intent(in) :: unix_timestamp\n        character(20) :: date_string\n        character(len=20) :: cmd, output\n        integer :: ios\n\n        write(cmd, '(A,I0)') 'date -d @', unix_timestamp\n        call execute_command_line(trim(adjustl(cmd)), wait=.true., exitstat=ios, &\n                                  output_variable=output)\n        if (ios == 0) then\n            date_string = adjustl(trim(output))\n        else\n            date_string = 'Invalid Date'\n        end if\n    end function unix_to_date\nend program convert_timestamps\n```"
  },
  {
    "task": "Transform a list of dictionary objects by extracting a specific key's value using map.",
    "code": "```fortran\nprogram transform_dict_list\n    implicit none\n    type :: Dict\n        character(len=:), allocatable :: key\n        character(len=:), allocatable :: value\n    end type Dict\n\n    type(Dict), allocatable :: dictList(:)\n    character(len=:), allocatable :: values(:)\n    integer :: i\n\n    ! Example input\n    allocate(dictList(3))\n    dictList(1) = Dict('name', 'Alice')\n    dictList(2) = Dict('name', 'Bob')\n    dictList(3) = Dict('name', 'Charlie')\n\n    ! Extract 'name' values using map-like operation\n    allocate(values(size(dictList)))\n    do i = 1, size(dictList)\n        values(i) = dictList(i)%value\n    end do\n\n    ! Output the transformed list\n    do i = 1, size(values)\n        print *, values(i)\n    end do\nend program transform_dict_list\n```"
  },
  {
    "task": "Use map to compute the cube of each number in a list.",
    "code": "```fortran\nprogram cube_numbers\n  implicit none\n  integer, dimension(:), allocatable :: numbers, cubes\n  integer :: i\n\n  numbers = [1, 2, 3, 4, 5]\n  allocate(cubes(size(numbers)))\n\n  cubes = [(n**3, n = numbers)]\n\n  print *, cubes\nend program cube_numbers\n```"
  },
  {
    "task": "Translate a list of URLs to their respective domain names using a map function.",
    "code": "```fortran\nprogram url_to_domain\n  implicit none\n  character(len=100), dimension(:), allocatable :: urls, domains\n  integer :: i\n\n  urls = [ &\n      'http://example.com/path', &\n      'https://subdomain.domain.org', &\n      'http://another-example.net' &\n  ]\n\n  allocate(domains(size(urls)))\n  \n  domains = map(urls, domain_name)\n\n  do i = 1, size(domains)\n    print *, domains(i)\n  end do\n\ncontains\n\n  pure function domain_name(url) result(domain)\n    character(len=*), intent(in) :: url\n    character(len=100) :: domain\n    integer :: pos1, pos2\n\n    pos1 = index(url, '//')\n    if (pos1 > 0) then\n      pos2 = index(url(pos1+3:), '/')\n      if (pos2 > 0) then\n        domain = url(pos1+3:pos1+2+pos2)\n      else\n        domain = url(pos1+3:)\n      end if\n    else\n      domain = ''\n    end if\n  end function domain_name\n\n  pure function map(arr, f) result(mapped)\n    character(len=*), dimension(:), intent(in) :: arr\n    character(len=100), dimension(size(arr)) :: mapped\n    integer :: i\n\n    do i = 1, size(arr)\n      mapped(i) = f(arr(i))\n    end do\n  end function map\n\nend program url_to_domain\n```"
  },
  {
    "task": "Use map to generate HTML list items from a list of text strings.",
    "code": "```fortran\nprogram generate_html_list\n    implicit none\n    character(len=*), dimension(:), allocatable :: texts\n    character(len=100), dimension(:), allocatable :: html_list_items\n    integer :: i\n\n    texts = [ \"Home\", \"About\", \"Contact\" ]\n    allocate(html_list_items(size(texts)))\n\n    call map_to_html_list(texts, html_list_items)\n\n    do i = 1, size(html_list_items)\n        print *, trim(html_list_items(i))\n    end do\ncontains\n    subroutine map_to_html_list(input_texts, output_html)\n        character(len=*), dimension(:), intent(in) :: input_texts\n        character(len=100), dimension(:), intent(out) :: output_html\n        integer :: i\n\n        do i = 1, size(input_texts)\n            write(output_html(i), \"(A, A, A)\") \"<li>\", trim(input_texts(i)), \"</li>\"\n        end do\n    end subroutine map_to_html_list\nend program generate_html_list\n```"
  },
  {
    "task": "Convert a list of polar coordinates to Cartesian coordinates using map.",
    "code": "```fortran\nmodule polar_to_cartesian\n  implicit none\n  private\n  public :: polar_to_cartesian_map\n\ncontains\n\n  function polar_to_cartesian_map(polar_coords) result(cartesian_coords)\n    real, dimension(:,:), intent(in) :: polar_coords\n    real, dimension(size(polar_coords, 1), 2) :: cartesian_coords\n\n    cartesian_coords = reshape([(polar_to_cartesian_func(polar_coords(i, :)), i = 1, size(polar_coords, 1))], &\n                               shape(cartesian_coords), order=[2, 1])\n\n  end function polar_to_cartesian_map\n\n  pure function polar_to_cartesian_func(polar_coord) result(cartesian_coord)\n    real, dimension(2), intent(in) :: polar_coord\n    real, dimension(2) :: cartesian_coord\n    real :: r, theta\n\n    r = polar_coord(1)\n    theta = polar_coord(2)\n    cartesian_coord(1) = r * cos(theta)\n    cartesian_coord(2) = r * sin(theta)\n\n  end function polar_to_cartesian_func\n\nend module polar_to_cartesian\n```"
  },
  {
    "task": "Use map to decode a list of Base64 encoded strings.",
    "code": "```fortran\nprogram base64_decode\n  implicit none\n  character(len=:), allocatable :: encoded(:), decoded(:)\n  integer :: i\n\n  encoded = [ &\n    'SGVsbG8gd29ybGQ=', &\n    'Rm9ydHJhbiBjb2Rpbmc=', &\n    'QmFzZTY0IGVuY29kaW5n' &\n  ]\n\n  decoded = map(encoded, base64_decoder)\n\n  do i = 1, size(decoded)\n     print *, decoded(i)\n  end do\n\ncontains\n\n  pure function base64_decoder(s) result(decoded_string)\n    character(len=*), intent(in) :: s\n    character(len=:), allocatable :: decoded_string\n    ! Assume a function base64_decode_string exists to decode a single string\n    decoded_string = base64_decode_string(s)\n  end function base64_decoder\n\nend program base64_decode\n```"
  },
  {
    "task": "Convert a list of English sentences to Pig Latin using a map function.",
    "code": "```fortran\nmodule pig_latin\n    implicit none\ncontains\n    function to_pig_latin(sentence) result(pig_sentence)\n        character(len=*), intent(in) :: sentence\n        character(len=200) :: pig_sentence\n        character(len=:), allocatable :: words(:), pig_words(:)\n        integer :: i\n\n        words = split(sentence, ' ')\n        allocate(character(len=200) :: pig_words(size(words)))\n        do i = 1, size(words)\n            pig_words(i) = convert_to_pig_latin(words(i))\n        end do\n        pig_sentence = trim(adjustl(join(pig_words, ' ')))\n    end function to_pig_latin\n\n    function convert_to_pig_latin(word) result(pig_word)\n        character(len=*), intent(in) :: word\n        character(len=200) :: pig_word\n        character(len=1) :: first_letter\n\n        first_letter = word(1:1)\n        pig_word = trim(adjustl(word(2:))) // first_letter // 'ay'\n    end function convert_to_pig_latin\n\n    function split(string, delimiter) result(parts)\n        character(len=*), intent(in) :: string\n        character(len=1), intent(in) :: delimiter\n        character(len=:), allocatable :: parts(:)\n        integer :: i, n, start, count\n\n        n = len(string)\n        count = 0\n        start = 1\n        do i = 1, n\n            if (string(i:i) == delimiter) then\n                count = count + 1\n            end if\n        end do\n        allocate(character(len=n) :: parts(count + 1))\n        count = 0\n        start = 1\n        do i = 1, n\n            if (i == n .or. string(i:i) == delimiter) then\n                parts(count + 1) = trim(adjustl(string(start:i-1)))\n                start = i + 1\n                count = count + 1\n            end if\n        end do\n    end function split\n\n    function join(strings, delimiter) result(joined_string)\n        character(len=:), allocatable :: strings(:)\n        character(len=1), intent(in) :: delimiter\n        character(len=1000) :: joined_string\n        integer :: i\n\n        joined_string = ''\n        do i = 1, size(strings)\n            joined_string = trim(joined_string) // strings(i)\n            if (i < size(strings)) then\n                joined_string = trim(joined_string) // delimiter\n            end if\n        end do\n    end function join\nend module pig_latin\n\nprogram main\n    use pig_latin\n    implicit none\n    character(len=200) :: sentences(2), pig_sentences(2)\n    integer :: i\n\n    sentences = [ &\n        \"Hello world\", &\n        \"Fortran is fun\" &\n    ]\n\n    do i = 1, size(sentences)\n        pig_sentences(i) = to_pig_latin(sentences(i))\n    end do\n\n    do i = 1, size(pig_sentences)\n        print *, trim(pig_sentences(i))\n    end do\nend program main\n```"
  },
  {
    "task": "Use map to anonymize a list of email addresses by masking them.",
    "code": "```fortran\nprogram anonymize_emails\n    implicit none\n    character(len=100), dimension(:), allocatable :: emails\n    character(len=100), dimension(:), allocatable :: anonymized_emails\n    integer :: i\n\n    ! Sample email addresses\n    emails = [ \"example1@example.com\", \"user.name@domain.com\", \"sample123@provider.org\" ]\n\n    allocate(anonymized_emails(size(emails)))\n\n    call map(emails, anonymized_emails, mask_email)\n\n    do i = 1, size(anonymized_emails)\n        print *, anonymized_emails(i)\n    end do\n\ncontains\n\n    subroutine map(input_list, output_list, func)\n        character(len=*), dimension(:), intent(in) :: input_list\n        character(len=*), dimension(:), intent(out) :: output_list\n        interface\n            pure function func(item) result(mapped_item)\n                character(len=*), intent(in) :: item\n                character(len=*), allocatable :: mapped_item\n            end function func\n        end interface\n\n        integer :: i\n\n        do i = 1, size(input_list)\n            output_list(i) = func(trim(adjustl(input_list(i))))\n        end do\n    end subroutine map\n\n    pure function mask_email(email) result(anon_email)\n        character(len=*), intent(in) :: email\n        character(len=100) :: anon_email\n        integer :: at_pos\n\n        at_pos = index(email, '@')\n        if (at_pos > 1) then\n            anon_email = repeat('*', at_pos - 1) // email(at_pos:)\n        else\n            anon_email = email\n        end if\n    end function mask_email\n\nend program anonymize_emails\n```"
  },
  {
    "task": "Apply map to reverse each string in a list of words.",
    "code": "```fortran\nprogram reverse_strings\n    implicit none\n    character(len=*), dimension(:), allocatable :: words, reversed_words\n    character(len=100) :: temp\n    integer :: i, j\n\n    words = [ \"hello\", \"world\", \"fortran\", \"functional\", \"map\" ]\n    allocate(character(len=100) :: reversed_words(size(words)))\n\n    reversed_words = [ reverse_string(trim(word)) : word in words ]\n\n    do i = 1, size(reversed_words)\n        print *, trim(reversed_words(i))\n    end do\n\ncontains\n\n    pure function reverse_string(s) result(reversed)\n        character(len=*), intent(in) :: s\n        character(len=len(s)) :: reversed\n        integer :: k\n\n        do k = 1, len(s)\n            reversed(k:k) = s(len(s)-k+1:len(s)-k+1)\n        end do\n    end function reverse_string\n\nend program reverse_strings\n```"
  },
  {
    "task": "Convert a list of hexadecimal color codes to RGB tuples using map.",
    "code": "```fortran\nprogram hex_to_rgb\n  implicit none\n  character(len=7), dimension(:), allocatable :: hex_colors\n  integer, dimension(:,:), allocatable :: rgb_colors\n  integer :: i\n\n  hex_colors = [ '#FF5733', '#33FF57', '#3357FF' ]\n  allocate(rgb_colors(3, size(hex_colors)))\n\n  call convert_hex_to_rgb(hex_colors, rgb_colors)\n\n  do i = 1, size(rgb_colors, 2)\n     print *, 'RGB: (', rgb_colors(:, i), ')'\n  end do\n\ncontains\n\n  subroutine convert_hex_to_rgb(hex, rgb)\n    character(len=7), dimension(:), intent(in) :: hex\n    integer, dimension(3, size(hex)), intent(out) :: rgb\n    integer :: color_index\n\n    do color_index = 1, size(hex)\n       rgb(:, color_index) = map_hex_to_rgb(hex(color_index))\n    end do\n\n  end subroutine convert_hex_to_rgb\n\n  function map_hex_to_rgb(hex_code) result(rgb_tuple)\n    character(len=7), intent(in) :: hex_code\n    integer, dimension(3) :: rgb_tuple\n    integer :: i\n\n    do i = 1, 3\n       read(hex_code(2*i:2*i+1), '(Z2)') rgb_tuple(i)\n    end do\n\n  end function map_hex_to_rgb\n\nend program hex_to_rgb\n```"
  },
  {
    "task": "Use map to increment each integer in a list by a constant value.",
    "code": "```fortran\nprogram map_increment\n    implicit none\n    integer, parameter :: n = 5\n    integer :: i\n    integer, dimension(n) :: list = [1, 2, 3, 4, 5]\n    integer, dimension(n) :: incremented_list\n\n    incremented_list = map_increment(list, 1)\n\n    print *, incremented_list\n\ncontains\n\n    function map_increment(arr, inc)\n        integer, intent(in) :: arr(:)\n        integer, intent(in) :: inc\n        integer, dimension(size(arr)) :: map_increment\n        map_increment = [(arr(i) + inc, i=1, size(arr))]\n    end function map_increment\n\nend program map_increment\n```"
  },
  {
    "task": "Calculate the square root of each number in a list using a map function.",
    "code": "```fortran\nprogram sqrt_map\n  implicit none\n  real, dimension(:), allocatable :: list, sqrt_list\n  integer :: i\n\n  list = [1.0, 4.0, 9.0, 16.0, 25.0]\n  allocate(sqrt_list(size(list)))\n\n  sqrt_list = [(sqrt(list(i)), i=1, size(list))]\n\n  print *, sqrt_list\n\nend program sqrt_map\n```"
  },
  {
    "task": "Use map to convert a list of currency amounts from dollars to euros.",
    "code": "```fortran\nmodule currency_conversion\n  implicit none\ncontains\n  pure function dollar_to_euro(dollars) result(euros)\n    real, intent(in) :: dollars\n    real :: euros\n    real, parameter :: conversion_rate = 0.85\n    euros = dollars * conversion_rate\n  end function dollar_to_euro\n\n  pure function map_dollars_to_euros(dollar_amounts) result(euro_amounts)\n    real, dimension(:), intent(in) :: dollar_amounts\n    real, dimension(size(dollar_amounts)) :: euro_amounts\n    integer :: i\n    do i = 1, size(dollar_amounts)\n      euro_amounts(i) = dollar_to_euro(dollar_amounts(i))\n    end do\n  end function map_dollars_to_euros\nend module currency_conversion\n\nprogram convert_currency\n  use currency_conversion\n  implicit none\n  real, dimension(5) :: dollars = [100.0, 150.0, 200.0, 250.0, 300.0]\n  real, dimension(5) :: euros\n  euros = map_dollars_to_euros(dollars)\n  print *, 'Dollars:', dollars\n  print *, 'Euros:', euros\nend program convert_currency\n```"
  },
  {
    "task": "Extract the domain from each email address in a list using map.",
    "code": "```fortran\nprogram extract_domains\n  implicit none\n  character(len=100), dimension(:), allocatable :: emails\n  character(len=100), dimension(:), allocatable :: domains\n  integer :: i\n\n  emails = [ 'user1@example.com', 'user2@domain.org', 'person3@anotherdomain.net' ]\n\n  domains = map(extract_domain, emails)\n\n  do i = 1, size(domains)\n    print *, trim(domains(i))\n  end do\n\ncontains\n\n  function extract_domain(email) result(domain)\n    character(len=*), intent(in) :: email\n    character(len=len(email)) :: domain\n    integer :: at_pos\n\n    at_pos = index(email, '@')\n    if (at_pos > 0) then\n      domain = email(at_pos+1:)\n    else\n      domain = ''\n    end if\n  end function extract_domain\n\n  function map(func, list) result(mapped)\n    character(len=*), dimension(:), intent(in) :: list\n    character(len=100), dimension(size(list)) :: mapped\n    integer :: i\n\n    do i = 1, size(list)\n      mapped(i) = func(trim(list(i)))\n    end do\n  end function map\n\nend program extract_domains\n```"
  },
  {
    "task": "Use map to serialize a list of objects into JSON strings.",
    "code": "```fortran\nprogram serialize_to_json\n  use iso_c_binding\n  implicit none\n  type :: MyType\n    character(len=50) :: name\n    integer :: value\n  end type MyType\n\n  type(MyType), dimension(2) :: my_objects\n  character(len=100), dimension(2) :: json_strings\n\n  interface\n    function to_json(object) bind(c)\n      import :: MyType\n      character(len=100) :: to_json\n      type(MyType), intent(in) :: object\n    end function to_json\n  end interface\n\n  my_objects(1) = MyType('Object1', 10)\n  my_objects(2) = MyType('Object2', 20)\n\n  json_strings = map(my_objects, to_json)\n  print *, json_strings\n\ncontains\n\n  function to_json(object) result(json_string)\n    type(MyType), intent(in) :: object\n    character(len=100) :: json_string\n    write(json_string, '(A, A, I0, A)', advance='no') &\n      '{\"name\":\"', trim(object%name), '\",\"value\":', object%value, '}'\n  end function to_json\n\n  function map(objects, func) result(results)\n    type(MyType), dimension(:), intent(in) :: objects\n    character(len=100), dimension(size(objects)) :: results\n    interface\n      function func(object) result(res)\n        import :: MyType\n        character(len=100) :: res\n        type(MyType), intent(in) :: object\n      end function func\n    end interface\n    integer :: i\n\n    do i = 1, size(objects)\n      results(i) = func(objects(i))\n    end do\n  end function map\n\nend program serialize_to_json\n```"
  },
  {
    "task": "Transform a list of file sizes from bytes to kilobytes using map.",
    "code": "```fortran\nprogram transform_sizes\n  implicit none\n  integer, parameter :: n = 5\n  integer :: i\n  real :: bytes(n), kilobytes(n)\n\n  bytes = [1024, 2048, 3072, 4096, 5120]\n\n  kilobytes = map(bytes, size(bytes), 1024.0)\n\n  print *, kilobytes\n\ncontains\n\n  pure function map(a, n, factor) result(b)\n    integer, intent(in) :: n\n    real, intent(in) :: a(n), factor\n    real :: b(n)\n    integer :: i\n\n    do i = 1, n\n      b(i) = a(i) / factor\n    end do\n  end function map\n\nend program transform_sizes\n```"
  },
  {
    "task": "Use map to append a suffix to each string in a list of identifiers.",
    "code": "```fortran\nprogram append_suffix\n    implicit none\n    character(len=20), dimension(:), allocatable :: identifiers\n    character(len=20), dimension(:), allocatable :: modified_identifiers\n    integer :: i\n\n    ! Sample data\n    allocate(identifiers(3))\n    identifiers = [\"id1\", \"id2\", \"id3\"]\n\n    ! Append suffix\n    allocate(modified_identifiers(size(identifiers)))\n    modified_identifiers = [trim(identifiers(i)) // \"_suffix\" & \n                            do i = 1, size(identifiers)]\n\n    ! Output result\n    do i = 1, size(modified_identifiers)\n        print *, modified_identifiers(i)\n    end do\n\n    ! Clean up\n    deallocate(identifiers, modified_identifiers)\nend program append_suffix\n```"
  },
  {
    "task": "Apply map to convert measurements from inches to centimeters in a list.",
    "code": "```fortran\nprogram convert_inches_to_cm\n    implicit none\n    real, dimension(:), allocatable :: inches, centimeters\n    integer :: i\n\n    inches = [1.0, 2.5, 4.0, 5.75]  ! Example list of measurements in inches\n    allocate(centimeters(size(inches)))\n\n    centimeters = map(inches, inches_to_cm)\n\n    print *, centimeters\n\ncontains\n    function inches_to_cm(inch) result(cm)\n        real, intent(in) :: inch\n        real :: cm\n        cm = inch * 2.54\n    end function inches_to_cm\n\n    elemental function map(array, func) result(output)\n        real, dimension(:), intent(in) :: array\n        real, dimension(size(array)) :: output\n        interface\n            function func(x) result(res)\n                real, intent(in) :: x\n                real :: res\n            end function func\n        end interface\n        integer :: i\n        do i = 1, size(array)\n            output(i) = func(array(i))\n        end do\n    end function map\n\nend program convert_inches_to_cm\n```"
  },
  {
    "task": "Use map to encrypt a list of plaintext messages using a simple cipher.",
    "code": "```fortran\nprogram encrypt_messages\n    implicit none\n    character(len=100), dimension(:), allocatable :: plaintext_messages\n    character(len=100), dimension(:), allocatable :: encrypted_messages\n    integer :: i\n\n    allocate(plaintext_messages(3))\n    allocate(encrypted_messages(3))\n\n    plaintext_messages = [ \"HELLO\", \"WORLD\", \"FORTRAN\" ]\n\n    encrypted_messages = map(plaintext_messages, encrypt)\n\n    do i = 1, size(encrypted_messages)\n        print *, trim(encrypted_messages(i))\n    end do\n\ncontains\n\n    pure function encrypt(message) result(encrypted)\n        character(len=100), intent(in) :: message\n        character(len=100) :: encrypted\n        integer :: i\n\n        encrypted = message\n\n        do i = 1, len_trim(message)\n            encrypted(i:i) = char(mod(iachar(message(i:i)) + 3 - iachar('A'), 26) + iachar('A'))\n        end do\n    end function encrypt\n\n    pure function map(messages, func) result(results)\n        character(len=100), dimension(:), intent(in) :: messages\n        character(len=100), dimension(size(messages)) :: results\n        interface\n            pure function func(message) result(output)\n                character(len=100), intent(in) :: message\n                character(len=100) :: output\n            end function func\n        end interface\n        integer :: i\n\n        do i = 1, size(messages)\n            results(i) = func(messages(i))\n        end do\n    end function map\n\nend program encrypt_messages\n```"
  },
  {
    "task": "Transform a list of date strings to day of the week names using a map function.",
    "code": "```fortran\nprogram map_dates_to_weekdays\n    use iso_c_binding, only: c_int, c_char\n    implicit none\n\n    character(len=10), dimension(:), allocatable :: date_strings, weekdays\n    integer :: i\n\n    date_strings = [ \"2023-10-01\", \"2023-10-02\", \"2023-10-03\" ]\n    allocate(weekdays(size(date_strings)))\n\n    call transform_dates(date_strings, weekdays)\n\n    do i = 1, size(weekdays)\n        print *, weekdays(i)\n    end do\n\ncontains\n\n    subroutine transform_dates(dates, result)\n        character(len=10), dimension(:), intent(in) :: dates\n        character(len=20), dimension(:), intent(out) :: result\n        integer :: i\n\n        do i = 1, size(dates)\n            result(i) = date_to_weekday(dates(i))\n        end do\n    end subroutine transform_dates\n\n    function date_to_weekday(date) result(day)\n        character(len=10), intent(in) :: date\n        character(len=20) :: day\n        integer :: year, month, day_of_month, day_number\n\n        read(date, \"(i4,1x,i2,1x,i2)\") year, month, day_of_month\n        call date_to_day_number(year, month, day_of_month, day_number)\n\n        select case (mod(day_number, 7))\n        case (0)\n            day = \"Sunday\"\n        case (1)\n            day = \"Monday\"\n        case (2)\n            day = \"Tuesday\"\n        case (3)\n            day = \"Wednesday\"\n        case (4)\n            day = \"Thursday\"\n        case (5)\n            day = \"Friday\"\n        case (6)\n            day = \"Saturday\"\n        end select\n    end function date_to_weekday\n\n    subroutine date_to_day_number(year, month, day, day_number)\n        integer, intent(in) :: year, month, day\n        integer, intent(out) :: day_number\n\n        ! Zeller's Congruence Algorithm\n        integer :: Y, m, D, C\n\n        if (month <= 2) then\n            Y = year - 1\n            m = month + 12\n        else\n            Y = year\n            m = month\n        end if\n\n        D = mod(Y, 100)\n        C = Y / 100\n\n        day_number = day + (13 * (m + 1)) / 5 + D + D / 4 + C / 4 - 2 * C\n    end subroutine date_to_day_number\n\nend program map_dates_to_weekdays\n```"
  },
  {
    "task": "Use map to derive the absolute value of each number in a list.",
    "code": "```fortran\nprogram map_absolute\n    implicit none\n    integer, allocatable :: numbers(:), abs_numbers(:)\n    integer :: i\n\n    numbers = [-3, -1, 0, 2, -5]\n    allocate(abs_numbers(size(numbers)))\n\n    abs_numbers = [(abs(numbers(i)), i = 1, size(numbers))]\n\n    print *, abs_numbers\nend program map_absolute\n```"
  },
  {
    "task": "Convert a list of lowercase hexadecimal strings to uppercase using map.",
    "code": "```fortran\nprogram hex_to_upper\n  implicit none\n  character(len=100), dimension(5) :: hex_in, hex_out\n  integer :: i\n\n  ! Example initialization\n  hex_in = ['1a2b', '3c4d', '5e6f', '7a8b', '9c0d']\n\n  ! Convert each element using map\n  call map(hex_in, hex_out, to_upper)\n\n  ! Print result\n  do i = 1, size(hex_out)\n     print *, hex_out(i)\n  end do\n\ncontains\n\n  subroutine map(input, output, func)\n    character(len=*), dimension(:), intent(in) :: input\n    character(len=*), dimension(:), intent(out) :: output\n    interface\n       function func(s) result(r)\n         character(len=*), intent(in) :: s\n         character(len=len(s)) :: r\n       end function func\n    end interface\n    integer :: i\n    do i = 1, size(input)\n       output(i) = func(trim(input(i)))\n    end do\n  end subroutine map\n\n  function to_upper(s) result(r)\n    character(len=*), intent(in) :: s\n    character(len=len(s)) :: r\n    integer :: i\n    do i = 1, len(s)\n       r(i:i) = adjustl(achar(iachar(s(i:i)) + 32 * merge(1, 0, iachar(s(i:i)) >= iachar('a') .and. iachar(s(i:i)) <= iachar('z'))))\n    end do\n  end function to_upper\n\nend program hex_to_upper\n```"
  },
  {
    "task": "Use map to find the maximum value in a list of lists of numbers.",
    "code": "```fortran\nprogram find_max_value\n    implicit none\n    integer, parameter :: n = 3, m = 4\n    integer :: i, j\n    integer, dimension(n, m) :: lists = reshape([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], [n, m])\n    integer :: max_value\n\n    max_value = maxval([maxval(lists(i, :)) do i = 1, n])\n\n    print *, 'Maximum value is:', max_value\nend program find_max_value\n```"
  },
  {
    "task": "Apply map to extract the year from each date in a list of date objects.",
    "code": "```fortran\nmodule date_utils\n  use iso_fortran_env, only: date_and_time\n  implicit none\n  private\n  public :: extract_years\n\ncontains\n\n  function extract_year(date) result(year)\n    type(date_and_time), intent(in) :: date\n    integer :: year\n    year = date%year\n  end function extract_year\n\n  function extract_years(dates) result(years)\n    type(date_and_time), dimension(:), intent(in) :: dates\n    integer, allocatable :: years(:)\n    integer :: i\n\n    allocate(years(size(dates)))\n    do i = 1, size(dates)\n      years(i) = extract_year(dates(i))\n    end do\n  end function extract_years\n\nend module date_utils\n\nprogram main\n  use date_utils\n  use iso_fortran_env, only: date_and_time\n  implicit none\n\n  type(date_and_time), dimension(3) :: dates\n  integer, dimension(:), allocatable :: years\n\n  ! Example date initialization (assuming a date_and_time type with year, month, day)\n  dates(1) = date_and_time(2023, 1, 1)\n  dates(2) = date_and_time(2022, 12, 31)\n  dates(3) = date_and_time(2021, 6, 15)\n\n  years = extract_years(dates)\n\n  print *, years\n\nend program main\n```"
  },
  {
    "task": "Use map to prepend a country code to each phone number in a list.",
    "code": "```fortran\nprogram prepend_country_code\n    implicit none\n    character(len=15), dimension(:), allocatable :: phone_numbers\n    character(len=15), dimension(:), allocatable :: updated_numbers\n    character(len=5) :: country_code\n    integer :: i\n\n    phone_numbers = [ \"+1-555-1234\", \"+1-555-5678\", \"+1-555-8765\" ]\n    country_code = \"+44\"\n\n    allocate(updated_numbers(size(phone_numbers)))\n\n    updated_numbers = [(country_code // phone_numbers(i), i = 1, size(phone_numbers))]\n\n    do i = 1, size(updated_numbers)\n        print *, updated_numbers(i)\n    end do\nend program prepend_country_code\n```"
  },
  {
    "task": "Capitalize the last letter of each word in a list using a map function.",
    "code": "```fortran\nmodule string_utils\n  implicit none\ncontains\n  function capitalize_last(word) result(new_word)\n    character(len=*), intent(in) :: word\n    character(len=len(word)) :: new_word\n    integer :: len_word\n\n    len_word = len_trim(word)\n    if (len_word > 0) then\n      new_word = word\n      new_word(len_word:len_word) = adjustl(merge(new_word(len_word:len_word), &\n                                  toUpper(new_word(len_word:len_word)), &\n                                  is_lower(new_word(len_word:len_word))))\n    else\n      new_word = word\n    end if\n  end function capitalize_last\n\n  function toUpper(c) result(uc)\n    character(len=1), intent(in) :: c\n    character(len=1) :: uc\n    uc = char(iachar(c) - 32)\n  end function toUpper\n\n  function is_lower(c) result(is_l)\n    character(len=1), intent(in) :: c\n    logical :: is_l\n    is_l = (iachar(c) >= iachar('a') .and. iachar(c) <= iachar('z'))\n  end function is_lower\nend module string_utils\n\nprogram capitalize_last_letters\n  use string_utils\n  implicit none\n  character(len=100), dimension(5) :: words = ['hello', 'world', 'fortran', 'programming', 'language']\n  character(len=100), dimension(5) :: result\n  integer :: i\n\n  result = [ (capitalize_last(trim(words(i))), i=1,5) ]\n\n  do i = 1, 5\n    print *, trim(result(i))\n  end do\nend program capitalize_last_letters\n```"
  },
  {
    "task": "Use map to transform a list of strings by removing all vowels.",
    "code": "```fortran\nprogram remove_vowels\n    implicit none\n    character(len=*), dimension(:), allocatable :: input_list, output_list\n    character(len=:), allocatable :: result\n    integer :: i\n\n    input_list = [ 'example', 'functional', 'programming', 'fortran' ]\n    allocate(output_list(size(input_list)))\n\n    do i = 1, size(input_list)\n        call remove_vowels_from_string(input_list(i), result)\n        output_list(i) = result\n    end do\n\n    print *, output_list\n\ncontains\n\n    subroutine remove_vowels_from_string(input_string, output_string)\n        character(len=*), intent(in) :: input_string\n        character(len=:), allocatable, intent(out) :: output_string\n        character(len=1) :: current_char\n        integer :: j\n        output_string = ''\n\n        do j = 1, len(input_string)\n            current_char = input_string(j:j)\n            if (index('aeiouAEIOU', current_char) == 0) then\n                output_string = output_string // current_char\n            end if\n        end do\n    end subroutine remove_vowels_from_string\n\nend program remove_vowels\n```"
  },
  {
    "task": "Convert a list of music notes to their corresponding frequencies using map.",
    "code": "```fortran\nprogram map_notes_to_frequencies\n  implicit none\n  integer, parameter :: n = 7\n  character(len=2), dimension(n) :: notes = [character(len=2) :: \"C4\", \"D4\", \"E4\", \"F4\", \"G4\", \"A4\", \"B4\"]\n  real, dimension(n) :: frequencies\n  \n  interface\n     function note_to_frequency(note)\n       character(len=*), intent(in) :: note\n       real :: note_to_frequency\n     end function note_to_frequency\n  end interface\n\n  frequencies = map(notes, note_to_frequency)\n\n  print *, \"Frequencies: \", frequencies\n\ncontains\n\n  pure function note_to_frequency(note) result(freq)\n    character(len=*), intent(in) :: note\n    real :: freq\n    \n    select case(note)\n    case (\"C4\")\n       freq = 261.63\n    case (\"D4\")\n       freq = 293.66\n    case (\"E4\")\n       freq = 329.63\n    case (\"F4\")\n       freq = 349.23\n    case (\"G4\")\n       freq = 392.00\n    case (\"A4\")\n       freq = 440.00\n    case (\"B4\")\n       freq = 493.88\n    case default\n       freq = -1.0\n    end select\n  end function note_to_frequency\n\n  pure function map(notes, f) result(mapped)\n    character(len=*), dimension(:), intent(in) :: notes\n    real, dimension(size(notes)) :: mapped\n    real :: f\n    integer :: i\n\n    do i = 1, size(notes)\n       mapped(i) = f(notes(i))\n    end do\n  end function map\n\nend program map_notes_to_frequencies\n```"
  },
  {
    "task": "Use map to find the reciprocal of each number in a list.",
    "code": "```fortran\nprogram reciprocal_map\n    implicit none\n    real, dimension(:), allocatable :: numbers, reciprocals\n\n    numbers = [1.0, 2.0, 4.0, 8.0, 16.0]\n\n    reciprocals = [reciprocal(x) for x in numbers]\n\ncontains\n\n    pure function reciprocal(x) result(r)\n        real, intent(in) :: x\n        real :: r\n        r = 1.0 / x\n    end function reciprocal\n\nend program reciprocal_map\n```"
  },
  {
    "task": "Transform a list of URLs to their shortened versions using a map function.",
    "code": "```fortran\nmodule url_shortener\n  implicit none\ncontains\n  function shorten_url(url) result(short_url)\n    character(len=*), intent(in) :: url\n    character(len=20) :: short_url\n    ! Dummy shortening logic for example purposes\n    short_url = url(1:min(20, len(url))) // repeat(\"x\", max(0, 20 - len(url)))\n  end function shorten_url\n\n  subroutine map_urls(urls, shortened_urls)\n    character(len=*), dimension(:), intent(in) :: urls\n    character(len=20), dimension(size(urls)), intent(out) :: shortened_urls\n    integer :: i\n\n    do i = 1, size(urls)\n      shortened_urls(i) = shorten_url(urls(i))\n    end do\n  end subroutine map_urls\nend module url_shortener\n\nprogram main\n  use url_shortener\n  implicit none\n  character(len=100), dimension(3) :: urls = [ &\n    \"http://example.com/1\", &\n    \"http://example.com/2\", &\n    \"http://example.com/3\" &\n  ]\n  character(len=20), dimension(3) :: shortened_urls\n\n  call map_urls(urls, shortened_urls)\n\n  print *, \"Shortened URLs:\"\n  print *, shortened_urls\nend program main\n```"
  },
  {
    "task": "Use map to generate a list of initials from a list of full names.",
    "code": "```fortran\nprogram map_initials\n    implicit none\n    character(len=100), dimension(:), allocatable :: full_names\n    character(len=1), dimension(:), allocatable :: initials\n    integer :: i\n\n    full_names = [ &\n        \"John Doe\", &\n        \"Jane Smith\", &\n        \"Albert Johnson\", &\n        \"Emily Davis\" &\n    ]\n\n    allocate(initials(size(full_names)))\n\n    call map_initials(full_names, initials)\n\n    do i = 1, size(initials)\n        print *, initials(i)\n    end do\n\ncontains\n\n    subroutine map_initials(full_names, initials)\n        character(len=100), dimension(:), intent(in) :: full_names\n        character(len=1), dimension(:), intent(out) :: initials\n        integer :: i\n\n        do i = 1, size(full_names)\n            initials(i) = full_names(i)(1:1)\n        end do\n    end subroutine map_initials\n\nend program map_initials\n```"
  },
  {
    "task": "Convert a list of decimal numbers to their binary string representations using map.",
    "code": "```fortran\nprogram decimal_to_binary_map\n    implicit none\n    integer, parameter :: n = 5\n    integer :: i\n    real, dimension(n) :: decimals = [3.0, 5.0, 7.0, 10.0, 15.0]\n    character(len=10), dimension(n) :: binaries\n\n    interface\n        function to_binary_string(x)\n            real, intent(in) :: x\n            character(len=10) :: to_binary_string\n        end function to_binary_string\n    end interface\n\n    ! Apply the map function\n    binaries = map(decimals, to_binary_string)\n\n    ! Output the results\n    do i = 1, n\n        print *, 'Decimal:', decimals(i), 'Binary:', adjustl(binaries(i))\n    end do\n\ncontains\n\n    ! Convert a decimal number to a binary string\n    function to_binary_string(x)\n        real, intent(in) :: x\n        character(len=10) :: to_binary_string\n        integer :: ix, i\n\n        ix = int(x)\n        to_binary_string = \"\"\n\n        do i = 1, 10\n            if (ix <= 0) exit\n            if (mod(ix, 2) == 0) then\n                to_binary_string(i:i) = '0'\n            else\n                to_binary_string(i:i) = '1'\n            end if\n            ix = ix / 2\n        end do\n\n        to_binary_string = adjustl(to_binary_string)\n    end function to_binary_string\n\nend program decimal_to_binary_map\n```"
  },
  {
    "task": "Use map to adjust the brightness of each color in a list of RGB tuples.",
    "code": "```fortran\nprogram adjust_brightness\n  implicit none\n  integer, parameter :: n = 3\n  integer, dimension(n, 3) :: colors\n  real :: brightness_factor\n  integer :: i, j\n\n  colors = reshape([100, 150, 200, &\n                    50,  75,  100, &\n                    200, 200, 200], shape(colors))\n\n  brightness_factor = 1.2\n\n  colors = map(colors, brightness_factor)\n\n  contains\n\n  function map(colors, factor) result(adjusted_colors)\n    integer, dimension(:,:), intent(in) :: colors\n    real, intent(in) :: factor\n    integer, dimension(size(colors,1), size(colors,2)) :: adjusted_colors\n    integer :: i, j\n\n    do i = 1, size(colors,1)\n      do j = 1, size(colors,2)\n        adjusted_colors(i,j) = int(colors(i,j) * factor)\n        if (adjusted_colors(i,j) > 255) adjusted_colors(i,j) = 255\n      end do\n    end do\n  end function map\n\nend program adjust_brightness\n```"
  },
  {
    "task": "Apply map to filter out only alphabetic characters from a list of strings.",
    "code": "```fortran\nprogram functional_map_filter\n  implicit none\n  character(len=:), allocatable :: strings(:)\n  character(len=:), allocatable :: filtered_strings(:)\n  integer :: i\n\n  strings = [ \"Hello123\", \"World!\", \"Fortran90\", \"Functional#Map\" ]\n\n  allocate(filtered_strings(size(strings)))\n\n  filtered_strings = [(trim(adjustl(apply_filter(strings(i)))), i = 1, size(strings))]\n\n  do i = 1, size(filtered_strings)\n     write(*,*) filtered_strings(i)\n  end do\n\ncontains\n\n  function apply_filter(s) result(filtered)\n    character(len=*), intent(in) :: s\n    character(len=len(s)) :: filtered\n    integer :: j, k\n\n    filtered = \"\"\n    k = 1\n    do j = 1, len(s)\n       if (iachar(s(j:j)) >= iachar('A') .and. iachar(s(j:j)) <= iachar('Z') .or. &\n           iachar(s(j:j)) >= iachar('a') .and. iachar(s(j:j)) <= iachar('z')) then\n          filtered(k:k) = s(j:j)\n          k = k + 1\n       end if\n    end do\n    filtered = filtered(:k-1)\n  end function apply_filter\n\nend program functional_map_filter\n```"
  },
  {
    "task": "Use map to compute the prime factorization of each number in a list.",
    "code": "```fortran\nprogram prime_factorization\n    implicit none\n    integer, allocatable :: numbers(:)\n    integer, allocatable :: factorizations(:,:)\n    integer :: i\n\n    numbers = [12, 18, 20, 25, 30]\n    allocate(factorizations(size(numbers), 10))  ! Assumes a max of 10 factors per number\n    factorizations = 0\n\n    call map_prime_factorization(numbers, factorizations)\n\n    do i = 1, size(numbers)\n        print *, \"Factors of \", numbers(i), \": \", factorizations(i,:)\n    end do\ncontains\n    subroutine map_prime_factorization(nums, factors)\n        integer, intent(in) :: nums(:)\n        integer, intent(out) :: factors(:, :)\n        integer :: i, j, n, count\n\n        do i = 1, size(nums)\n            n = nums(i)\n            count = 1\n            do j = 2, n\n                if (n <= 1) exit\n                do while (mod(n, j) == 0)\n                    factors(i, count) = j\n                    n = n / j\n                    count = count + 1\n                end do\n            end do\n        end do\n    end subroutine map_prime_factorization\nend program prime_factorization\n```"
  },
  {
    "task": "Calculate the exponential of each number in a list using a map function.",
    "code": "```fortran\nprogram map_exponential\n    implicit none\n    real, dimension(:), allocatable :: numbers, results\n    interface\n        function map(func, arr)\n            real, external :: func\n            real, dimension(:), intent(in) :: arr\n            real, dimension(size(arr)) :: map\n        end function map\n    end interface\n\n    numbers = [1.0, 2.0, 3.0, 4.0, 5.0]\n    results = map(exp, numbers)\n\n    print *, results\n\ncontains\n\n    function map(func, arr) result(res)\n        real, external :: func\n        real, dimension(:), intent(in) :: arr\n        real, dimension(size(arr)) :: res\n        integer :: i\n\n        do i = 1, size(arr)\n            res(i) = func(arr(i))\n        end do\n    end function map\n\nend program map_exponential\n```"
  },
  {
    "task": "Use map to convert a list of text messages to morse code.",
    "code": "```fortran\nmodule morse_code_module\n  implicit none\n  character(len=*), parameter :: alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"\n  character(len=*), parameter :: morse(36) = [ &\n       \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", &\n       \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", &\n       \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\", \"-----\", \".----\", \"..---\", &\n       \"...--\", \"....-\", \".....\", \"-....\", \"--...\", \"---..\", \"----.\" ]\n\ncontains\n\n  character(len=100) function text_to_morse(text) result(morse_code)\n    character(len=*), intent(in) :: text\n    integer :: i, index\n    morse_code = \"\"\n    do i = 1, len_trim(text)\n      index = index(text(i:i), alphabet)\n      if (index > 0) then\n        morse_code = trim(morse_code) // trim(morse(index)) // \" \"\n      end if\n    end do\n  end function text_to_morse\n\n  subroutine map_text_to_morse(text_messages, morse_messages)\n    character(len=*), dimension(:), intent(in) :: text_messages\n    character(len=100), dimension(:), intent(out) :: morse_messages\n    integer :: i\n    do i = 1, size(text_messages)\n      morse_messages(i) = text_to_morse(trim(adjustl(text_messages(i))))\n    end do\n  end subroutine map_text_to_morse\n\nend module morse_code_module\n\nprogram convert_to_morse\n  use morse_code_module\n  implicit none\n  character(len=100), dimension(3) :: text_messages = [ \"HELLO WORLD\", \"SOS\", \"FORTRAN\" ]\n  character(len=100), dimension(3) :: morse_messages\n\n  call map_text_to_morse(text_messages, morse_messages)\n\n  print *, trim(morse_messages)\nend program convert_to_morse\n```"
  },
  {
    "task": "Transform a list of JSON objects to XML strings using a map function.",
    "code": "```fortran\nprogram json_to_xml\n  use iso_c_binding\n  implicit none\n  type :: json_object\n    character(len=:), allocatable :: json_string\n  end type json_object\n\n  type(json_object), allocatable :: json_list(:)\n  character(len=:), allocatable :: xml_list(:)\n  integer :: i\n\n  ! Assume json_list is already populated with JSON strings.\n  ! Allocate xml_list to the same size as json_list\n  allocate(xml_list(size(json_list)))\n\n  ! Map each JSON object to an XML string\n  xml_list = [(convert_to_xml(json_list(i)%json_string), i=1, size(json_list))]\n\ncontains\n\n  function convert_to_xml(json_str) result(xml_str)\n    character(len=*), intent(in) :: json_str\n    character(len=:), allocatable :: xml_str\n    ! Dummy conversion for illustration. A real implementation is needed.\n    xml_str = \"<xml>\" // json_str // \"</xml>\"\n  end function convert_to_xml\n\nend program json_to_xml\n```"
  },
  {
    "task": "Use map to extract the extension from each filename in a list.",
    "code": "```fortran\nprogram extract_extensions\n    implicit none\n    character(len=100), dimension(:), allocatable :: filenames, extensions\n    integer :: i\n\n    ! Sample list of filenames\n    filenames = [ &\n        'document.pdf', &\n        'presentation.pptx', &\n        'image.jpeg', &\n        'archive.zip' &\n    ]\n\n    ! Allocate the extensions array\n    allocate(extensions(size(filenames)))\n\n    ! Use a map-like approach to extract extensions\n    call extract_map(filenames, extensions)\n\n    ! Output the extracted extensions\n    do i = 1, size(extensions)\n        print *, trim(extensions(i))\n    end do\n\ncontains\n\n    subroutine extract_map(fnames, extns)\n        character(len=*), dimension(:), intent(in) :: fnames\n        character(len=*), dimension(:), intent(out) :: extns\n        integer :: i, pos\n\n        do concurrent(i = 1:size(fnames))\n            pos = index(fnames(i), '.', back=.true.)\n            if (pos > 0) then\n                extns(i) = fnames(i)(pos+1:)\n            else\n                extns(i) = ''\n            end if\n        end do\n    end subroutine extract_map\n\nend program extract_extensions\n```"
  },
  {
    "task": "Convert a list of temperatures from Fahrenheit to Kelvin using map.",
    "code": "```fortran\nprogram tempConversion\n    implicit none\n    real, dimension(:), allocatable :: fahrenheitTemps, kelvinTemps\n    integer :: i, numTemps\n\n    ! Example list of Fahrenheit temperatures\n    fahrenheitTemps = [32.0, 68.0, 100.0, 212.0]\n    numTemps = size(fahrenheitTemps)\n    \n    allocate(kelvinTemps(numTemps))\n    \n    kelvinTemps = [(fahrenheitToKelvin(fahrenheitTemps(i)), i=1,numTemps)]\n    \n    print *, kelvinTemps\n\ncontains\n\n    real function fahrenheitToKelvin(f)\n        real, intent(in) :: f\n        fahrenheitToKelvin = (f - 32.0) * 5.0 / 9.0 + 273.15\n    end function fahrenheitToKelvin\n\nend program tempConversion\n```"
  },
  {
    "task": "Use map to calculate the perimeter of each rectangle in a list of dimensions.",
    "code": "```fortran\nmodule geometry\n  implicit none\ncontains\n  real function perimeter(length, width)\n    real, intent(in) :: length, width\n    perimeter = 2.0 * (length + width)\n  end function perimeter\nend module geometry\n\nprogram calculate_perimeters\n  use geometry\n  implicit none\n\n  real, dimension(2) :: dimensions_list(5)\n  real, dimension(5) :: perimeters\n  integer :: i\n\n  dimensions_list = reshape([3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0], &\n                            shape(dimensions_list))\n\n  perimeters = [(perimeter(dimensions_list(i,1), dimensions_list(i,2)), i=1, 5)]\n\n  print *, \"Perimeters: \", perimeters\nend program calculate_perimeters\n```"
  },
  {
    "task": "Apply map to format a list of phone numbers into a standard format.",
    "code": "```fortran\nprogram format_phone_numbers\n    implicit none\n    character(len=20) :: phone_numbers(5) = [ &\n        \"(123) 456-7890\", &\n        \"123-456-7890\", &\n        \"123.456.7890\", &\n        \"123 456 7890\", &\n        \"1234567890\" &\n    ]\n    character(len=14) :: formatted_numbers(5)\n    integer :: i\n\n    interface\n        pure function format_number(phone) result(formatted)\n            character(len=*), intent(in) :: phone\n            character(len=14) :: formatted\n        end function format_number\n    end interface\n\n    formatted_numbers = map(format_number, phone_numbers)\n\n    contains\n\n    pure function format_number(phone) result(formatted)\n        character(len=*), intent(in) :: phone\n        character(len=14) :: formatted\n        character(len=20) :: cleaned\n        integer :: j, k\n\n        cleaned = \"\"\n        k = 1\n        do j = 1, len(trim(phone))\n            if (phone(j:j) >= '0' .and. phone(j:j) <= '9') then\n                cleaned(k:k) = phone(j:j)\n                k = k + 1\n            end if\n        end do\n\n        if (len(trim(cleaned)) == 10) then\n            write(formatted, '(A3, A1, A3, A1, A4)') '(', cleaned(1:3), ') ', cleaned(4:6), '-', cleaned(7:10)\n        else\n            formatted = \"Invalid Number\"\n        end if\n    end function format_number\n\nend program format_phone_numbers\n```"
  },
  {
    "task": "Use map to generate a hashed version of passwords from a list.",
    "code": "```fortran\nprogram hash_passwords\n  implicit none\n  character(len=20), dimension(:), allocatable :: passwords, hashed_passwords\n  integer :: i, n\n\n  n = 3\n  allocate(passwords(n))\n  allocate(hashed_passwords(n))\n  \n  passwords = [ \"password123\", \"helloWorld\", \"fortranRocks\" ]\n\n  call map_hash(passwords, hashed_passwords)\n\n  do i = 1, n\n     print *, \"Hashed Password: \", hashed_passwords(i)\n  end do\n\ncontains\n\n  subroutine map_hash(input, output)\n    character(len=*), dimension(:), intent(in) :: input\n    character(len=20), dimension(:), intent(out) :: output\n    integer :: i\n\n    do i = 1, size(input)\n       output(i) = hash_function(input(i))\n    end do\n  end subroutine map_hash\n\n  function hash_function(password) result(hashed)\n    character(len=*), intent(in) :: password\n    character(len=20) :: hashed\n    integer :: j\n\n    hashed = \"********************\"\n    do j = 1, min(len(trim(password)), len(hashed))\n       hashed(j:j) = achar(mod(iachar(password(j:j)) + 3, 126) + 32)\n    end do\n  end function hash_function\n\nend program hash_passwords\n```"
  },
  {
    "task": "Convert a list of text paragraphs to a word count using map.",
    "code": "```fortran\nprogram WordCount\n    implicit none\n    character(len=:), allocatable :: paragraphs(:)\n    integer, allocatable :: wordCounts(:)\n    integer :: i\n\n    paragraphs = [ \"This is the first paragraph.\",\n                   \"Here is another one with more words.\",\n                   \"Short one.\" ]\n\n    allocate(wordCounts(size(paragraphs)))\n\n    wordCounts = [(countWords(paragraphs(i)), i = 1, size(paragraphs))]\n\n    print *, \"Word counts: \", wordCounts\n\ncontains\n\n    function countWords(paragraph) result(count)\n        implicit none\n        character(len=*), intent(in) :: paragraph\n        integer :: count, i\n        logical :: inWord\n\n        count = 0\n        inWord = .false.\n\n        do i = 1, len(paragraph)\n            if (.not. inWord .and. paragraph(i:i) /= ' ') then\n                count = count + 1\n                inWord = .true.\n            else if (paragraph(i:i) == ' ') then\n                inWord = .false.\n            end if\n        end do\n    end function countWords\n\nend program WordCount\n```"
  },
  {
    "task": "Use map to remove punctuation from each string in a list of sentences.",
    "code": "```fortran\nprogram remove_punctuation\n  implicit none\n  character(len=*), parameter :: sentences(3) = [ &\n    \"Hello, World!\", &\n    \"This is a test.\", &\n    \"Fortran is fun!\" &\n  ]\n  character(len=100) :: output(3)\n  integer :: i\n\n  call map_remove_punctuation(sentences, output)\n\n  do i = 1, size(output)\n    print *, trim(output(i))\n  end do\n\ncontains\n\n  subroutine map_remove_punctuation(in_sentences, out_sentences)\n    character(len=*), intent(in) :: in_sentences(:)\n    character(len=*), intent(out) :: out_sentences(:)\n    integer :: i\n\n    do i = 1, size(in_sentences)\n      out_sentences(i) = remove_punctuation(in_sentences(i))\n    end do\n  end subroutine map_remove_punctuation\n\n  function remove_punctuation(sentence) result(clean_sentence)\n    character(len=*), intent(in) :: sentence\n    character(len=len(sentence)) :: clean_sentence\n    integer :: i, j\n\n    clean_sentence = \"\"\n    j = 1\n    do i = 1, len(sentence)\n      if (index('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ', sentence(i:i)) > 0) then\n        clean_sentence(j:j) = sentence(i:i)\n        j = j + 1\n      end if\n    end do\n    clean_sentence = clean_sentence(1:j-1)\n  end function remove_punctuation\n\nend program remove_punctuation\n```"
  },
  {
    "task": "Transform a list of URLs to their base domain using a map function.",
    "code": "```fortran\nprogram map_urls_to_domains\n    implicit none\n    character(len=100), dimension(:), allocatable :: urls\n    character(len=100), dimension(:), allocatable :: domains\n    integer :: i\n    \n    urls = [ &\n        'https://example.com/path', &\n        'http://subdomain.example.org/another/path', &\n        'https://www.test.edu/somepage', &\n        'http://site.co.uk' &\n    ]\n\n    domains = map(urls, get_base_domain)\n\n    do i = 1, size(domains)\n        print *, domains(i)\n    end do\n\ncontains\n\n    pure function get_base_domain(url) result(domain)\n        character(len=*), intent(in) :: url\n        character(len=100) :: domain\n        integer :: start, finish\n\n        start = index(url, '//') + 2\n        finish = index(url(start:), '/') + start - 2\n        if (finish < start) then\n            finish = len(url)\n        end if\n        domain = url(start:finish)\n    end function get_base_domain\n\n    pure function map(urls, f) result(results)\n        character(len=*), dimension(:), intent(in) :: urls\n        character(len=100), dimension(size(urls)) :: results\n        character(len=100) :: f\n        integer :: i\n\n        do i = 1, size(urls)\n            results(i) = f(urls(i))\n        end do\n    end function map\nend program map_urls_to_domains\n```"
  },
  {
    "task": "Use map to translate a list of expressions to their symbolic algebraic forms.",
    "code": "```fortran\nprogram symbolic_map\n  implicit none\n  character(len=:), allocatable :: expressions(:)\n  character(len=:), allocatable :: symbolic_forms(:)\n  integer :: i\n\n  expressions = [ \"x+1\", \"y-2\", \"z*3\" ]\n  allocate(character(len=100) :: symbolic_forms(size(expressions)))\n\n  call map(expressions, symbolic_forms)\n\n  do i = 1, size(symbolic_forms)\n     print *, trim(symbolic_forms(i))\n  end do\n\ncontains\n\n  subroutine map(input, output)\n    character(len=*), intent(in) :: input(:)\n    character(len=100), intent(out) :: output(:)\n    integer :: i\n\n    do i = 1, size(input)\n       select case (trim(input(i)))\n       case (\"x+1\")\n          output(i) = \"x plus one\"\n       case (\"y-2\")\n          output(i) = \"y minus two\"\n       case (\"z*3\")\n          output(i) = \"z times three\"\n       case default\n          output(i) = \"unknown expression\"\n       end select\n    end do\n  end subroutine map\n\nend program symbolic_map\n```"
  },
  {
    "task": "Apply map to convert a list of ASCII codes to corresponding characters.",
    "code": "```fortran\nprogram ascii_to_char\n    implicit none\n    integer, dimension(:), allocatable :: ascii_codes\n    character(len=1), dimension(:), allocatable :: characters\n    integer :: i\n\n    ascii_codes = [72, 101, 108, 108, 111]  ! Example ASCII codes\n    allocate(characters(size(ascii_codes)))\n\n    characters = [(achar(ascii_codes(i)), i = 1, size(ascii_codes))]\n\n    print *, characters\nend program ascii_to_char\n```"
  },
  {
    "task": "Use map to transform a list of text strings to their lemmatized forms.",
    "code": "```fortran\nprogram lemmatize_strings\n    implicit none\n    character(len=:), allocatable :: strings(:)\n    character(len=:), allocatable :: lemmatized_strings(:)\n    integer :: i\n\n    strings = [ \"running\", \"eaten\", \"better\", \"children\" ]\n    allocate(character(len=20) :: lemmatized_strings(size(strings)))\n\n    call map(strings, lemmatized_strings, lemmatize)\n\n    do i = 1, size(lemmatized_strings)\n        print *, lemmatized_strings(i)\n    end do\n\ncontains\n\n    subroutine map(input, output, func)\n        character(len=*), intent(in) :: input(:)\n        character(len=*), intent(out) :: output(:)\n        interface\n            function func(elem) result(lemmatized)\n                character(len=*), intent(in) :: elem\n                character(len=20) :: lemmatized\n            end function func\n        end interface\n        integer :: i\n\n        do i = 1, size(input)\n            output(i) = func(input(i))\n        end do\n    end subroutine map\n\n    function lemmatize(word) result(lemmatized)\n        character(len=*), intent(in) :: word\n        character(len=20) :: lemmatized\n\n        select case (trim(word))\n        case ('running')\n            lemmatized = 'run'\n        case ('eaten')\n            lemmatized = 'eat'\n        case ('better')\n            lemmatized = 'good'\n        case ('children')\n            lemmatized = 'child'\n        case default\n            lemmatized = word\n        end select\n    end function lemmatize\n\nend program lemmatize_strings\n```"
  },
  {
    "task": "Convert a list of HTML strings to plain text using map.",
    "code": "```fortran\nprogram convert_html_to_plain_text\n  implicit none\n  character(len=:), allocatable :: html_list(:), plain_text_list(:)\n  integer :: i\n\n  html_list = [ &\n    \"<p>Hello, World!</p>\", &\n    \"<div>Fortran is fun!</div>\", &\n    \"<h1>Welcome</h1>\" &\n  ]\n\n  allocate(character(len=:), source=trim(html_list), plain_text_list(size(html_list)))\n\n  call map_html_to_plain_text(html_list, plain_text_list)\n\n  do i = 1, size(plain_text_list)\n    print *, plain_text_list(i)\n  end do\n\ncontains\n\n  pure subroutine map_html_to_plain_text(html, plain_text)\n    character(len=*), intent(in) :: html(:)\n    character(len=:), allocatable, intent(out) :: plain_text(:)\n    integer :: i\n\n    allocate(character(len=:), source=html, plain_text(size(html)))\n\n    do i = 1, size(html)\n      plain_text(i) = remove_html_tags(html(i))\n    end do\n  end subroutine map_html_to_plain_text\n\n  pure function remove_html_tags(s) result(res)\n    character(len=*), intent(in) :: s\n    character(len=len(s)) :: res\n    integer :: start, end\n\n    res = \"\"\n    start = 1\n    do\n      end = index(s(start:), '<')\n      if (end == 0) exit\n      res = res // s(start:start+end-2)\n      start = start + end\n      end = index(s(start:), '>')\n      if (end == 0) exit\n      start = start + end\n    end do\n    res = res // s(start:)\n  end function remove_html_tags\n\nend program convert_html_to_plain_text\n```"
  },
  {
    "task": "Use map to create a summary of each article in a list of texts.",
    "code": "```fortran\nprogram map_summary\n  implicit none\n  character(len=:), allocatable :: texts(:)\n  character(len=:), allocatable :: summaries(:)\n  integer :: i\n\n  ! Sample data\n  allocate(texts(3))\n  texts(1) = \"Fortran is a powerful language for numerical computing.\"\n  texts(2) = \"It excels in array manipulations and performance.\"\n  texts(3) = \"Used extensively in scientific and engineering domains.\"\n\n  ! Map function to create summaries\n  allocate(summaries(size(texts)))\n  do i = 1, size(texts)\n     summaries(i) = summarize(texts(i))\n  end do\n\n  ! Output the summaries\n  do i = 1, size(summaries)\n     print *, \"Summary \", i, \": \", summaries(i)\n  end do\ncontains\n  ! Function to create a summary\n  function summarize(text) result(summary)\n    character(len=*), intent(in) :: text\n    character(len=:), allocatable :: summary\n    ! Simple summarization: take the first sentence\n    integer :: pos\n\n    pos = index(text, '.')\n    if (pos > 0) then\n       summary = text(:pos)\n    else\n       summary = text\n    end if\n  end function summarize\nend program map_summary\n```"
  },
  {
    "task": "Transform a list of paths to their absolute paths using a map function.",
    "code": "```fortran\nprogram transform_paths\n  implicit none\n  interface system\n    function system(cmd) bind(C)\n      use, intrinsic :: iso_c_binding, only: c_int\n      integer(c_int) :: system\n      character(kind=c_char), dimension(*) :: cmd\n    end function system\n  end interface\n  character(len=1024), dimension(:), allocatable :: paths, abs_paths\n  integer :: i, num_paths\n\n  ! Example input\n  num_paths = 3\n  allocate(paths(num_paths))\n  paths = [\"/some/relative/path\", \"/another/path\", \"./yet/another\"]\n\n  allocate(abs_paths(num_paths))\n  abs_paths = map_to_absolute(paths)\n\n  do i = 1, num_paths\n     print *, trim(abs_paths(i))\n  end do\n\ncontains\n\n  pure function map_to_absolute(input_paths) result(output_paths)\n    character(len=1024), dimension(:), intent(in) :: input_paths\n    character(len=1024), dimension(size(input_paths)) :: output_paths\n    integer :: i\n\n    do i = 1, size(input_paths)\n      output_paths(i) = get_absolute_path(trim(input_paths(i)))\n    end do\n  end function map_to_absolute\n\n  function get_absolute_path(rel_path) result(abs_path)\n    character(len=1024), intent(in) :: rel_path\n    character(len=1024) :: abs_path\n    character(len=1024) :: command, temp_path\n    integer :: stat\n\n    write(command, '(A, A)') 'realpath ', rel_path\n    call execute_command_line(trim(command), wait=.true., exitstat=stat)\n    if (stat == 0) then\n      open(unit=10, file=\"abs_path.txt\", status=\"old\", action=\"read\", iostat=stat)\n      if (stat == 0) then\n        read(10, '(A)') temp_path\n        close(10)\n        abs_path = temp_path\n        call system('rm abs_path.txt')\n      else\n        abs_path = rel_path\n      end if\n    else\n      abs_path = rel_path\n    end if\n  end function get_absolute_path\n\nend program transform_paths\n```"
  },
  {
    "task": "Use map to generate QR codes from a list of URLs.",
    "code": "```fortran\nprogram generate_qr_codes\n    implicit none\n    character(len=*), dimension(3) :: urls = [ &\n        'https://example.com', &\n        'https://anotherexample.com', &\n        'https://yetanotherexample.com' &\n    ]\n    character(len=100), dimension(3) :: qr_codes\n    integer :: i\n\n    qr_codes = map(qr_code_func, urls)\n\n    do i = 1, size(qr_codes)\n        print *, 'QR Code for ', urls(i), ': ', qr_codes(i)\n    end do\n\ncontains\n\n    function qr_code_func(url)\n        character(len=*), intent(in) :: url\n        character(len=100) :: qr_code_func\n        ! Placeholder for actual QR code generation logic\n        qr_code_func = 'QR(' // trim(url) // ')'\n    end function qr_code_func\n\n    elemental function map(f, array)\n        character(len=100), dimension(size(array)) :: map\n        interface\n            function f(x)\n                character(len=*), intent(in) :: x\n                character(len=100)\n            end function\n        end interface\n        integer :: i\n\n        do i = 1, size(array)\n            map(i) = f(array(i))\n        end do\n    end function map\n\nend program generate_qr_codes\n```"
  },
  {
    "task": "Convert a list of angles from degrees to radians using map.",
    "code": "```fortran\nmodule angle_conversion\n  implicit none\ncontains\n  real function to_radians(degrees)\n    real, intent(in) :: degrees\n    to_radians = degrees * 3.14159265358979323846 / 180.0\n  end function to_radians\n\n  subroutine convert_angles(degrees, radians)\n    real, dimension(:), intent(in) :: degrees\n    real, dimension(:), intent(out) :: radians\n    integer :: i\n    do concurrent(i = 1:size(degrees))\n      radians(i) = to_radians(degrees(i))\n    end do\n  end subroutine convert_angles\nend module angle_conversion\n\nprogram main\n  use angle_conversion\n  implicit none\n  real, dimension(5) :: degrees = [30.0, 45.0, 60.0, 90.0, 120.0]\n  real, dimension(size(degrees)) :: radians\n\n  call convert_angles(degrees, radians)\n\n  print *, 'Radians:', radians\nend program main\n```"
  },
  {
    "task": "Use map to anonymize a list of IP addresses by masking parts of them.",
    "code": "```fortran\nprogram anonymize_ips\n    implicit none\n    character(len=15), dimension(:), allocatable :: ip_addresses, masked_ips\n    integer :: i\n\n    ip_addresses = [ \"192.168.1.1\", \"10.0.0.1\", \"172.16.0.1\" ]\n\n    masked_ips = map(ip_addresses, mask_ip)\n\n    do i = 1, size(masked_ips)\n        print *, masked_ips(i)\n    end do\n\ncontains\n    pure function mask_ip(ip) result(masked_ip)\n        character(len=15), intent(in) :: ip\n        character(len=15) :: masked_ip\n        integer :: pos\n\n        pos = index(ip, \".\")\n        masked_ip = \"XXX\" // ip(pos:)\n    end function\n\n    function map(array, func) result(mapped_array)\n        character(len=15), dimension(:), intent(in) :: array\n        character(len=15), dimension(size(array)) :: mapped_array\n        interface\n            pure function func(arg) result(res)\n                character(len=15), intent(in) :: arg\n                character(len=15) :: res\n            end function\n        end interface\n        integer :: i\n\n        do i = 1, size(array)\n            mapped_array(i) = func(array(i))\n        end do\n    end function\nend program anonymize_ips\n```"
  },
  {
    "task": "Transform a list of tuples by swapping their elements using a map function.",
    "code": "```fortran\nprogram swap_tuples\n  implicit none\n  integer, parameter :: n = 5\n  integer :: i\n  integer, dimension(n, 2) :: input_list = reshape([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [n, 2])\n  integer, dimension(n, 2) :: output_list\n\n  call swap_elements(input_list, output_list)\n\n  print *, output_list\n\ncontains\n\n  subroutine swap_elements(in_list, out_list)\n    integer, dimension(:,:), intent(in) :: in_list\n    integer, dimension(:,:), intent(out) :: out_list\n    integer :: i\n\n    out_list = reshape([(in_list(i,2), in_list(i,1), i=1, size(in_list,1))], shape(out_list))\n  end subroutine swap_elements\n\nend program swap_tuples\n```"
  },
  {
    "task": "Use map to compute the greatest common divisor of pairs in a list of number pairs.",
    "code": "```fortran\nmodule gcd_util\n    implicit none\ncontains\n    recursive function gcd(a, b) result(g)\n        integer, intent(in) :: a, b\n        integer :: g\n        if (b == 0) then\n            g = abs(a)\n        else\n            g = gcd(b, mod(a, b))\n        endif\n    end function gcd\n\n    function map_gcd(pairs) result(gcd_values)\n        integer, dimension(:,:), intent(in) :: pairs\n        integer, dimension(size(pairs, 1)) :: gcd_values\n        integer :: i\n        do i = 1, size(pairs, 1)\n            gcd_values(i) = gcd(pairs(i, 1), pairs(i, 2))\n        end do\n    end function map_gcd\nend module gcd_util\n\nprogram main\n    use gcd_util\n    implicit none\n    integer, dimension(3, 2) :: number_pairs = reshape([12, 8, 36, 48, 101, 103], [3, 2])\n    integer, dimension(:), allocatable :: results\n\n    results = map_gcd(number_pairs)\n    print *, results\nend program main\n```"
  },
  {
    "task": "Convert a list of file paths to their directory names using map.",
    "code": "```fortran\nmodule file_utils\n  implicit none\ncontains\n  function get_directory_name(filepath) result(dirname)\n    character(len=*), intent(in) :: filepath\n    character(len=len(filepath)) :: dirname\n    integer :: i\n    i = len(filepath)\n    do while (i > 0 .and. filepath(i:i) /= '/')\n      i = i - 1\n    end do\n    if (i > 0) then\n      dirname = filepath(:i-1)\n    else\n      dirname = ''\n    end if\n  end function get_directory_name\n\n  function map_directories(filepaths) result(dirnames)\n    character(len=*), dimension(:), intent(in) :: filepaths\n    character(len=:), dimension(size(filepaths)) :: dirnames\n    integer :: i\n\n    dirnames = [(get_directory_name(filepaths(i)), i = 1, size(filepaths))]\n  end function map_directories\n\nend module file_utils\n\nprogram convert_to_directories\n  use file_utils\n  implicit none\n  character(len=100), dimension(3) :: filepaths\n  character(len=:), allocatable, dimension(:) :: dirnames\n\n  filepaths = [ &\n    '/home/user/documents/file1.txt', &\n    '/home/user/photos/image.jpg', &\n    '/home/user/music/song.mp3' &\n  ]\n\n  dirnames = map_directories(filepaths)\n\n  print *, 'Directory names:'\n  print *, dirnames\n\nend program convert_to_directories\n```"
  },
  {
    "task": "Use map to replace each vowel in a list of strings with a specific character.",
    "code": "```fortran\nprogram replace_vowels\n    implicit none\n    character(len=*), parameter :: vowels = 'aeiouAEIOU'\n    character(len=1), parameter :: replacement = '*'\n    character(len=100) :: str_array(3)\n    integer :: i\n\n    ! Example list of strings\n    str_array = [character(len=100) :: \"hello\", \"world\", \"fortran\"]\n\n    call map(str_array, replacement)\n\n    contains\n\n    subroutine map(strings, repl)\n        character(len=100), intent(inout) :: strings(:)\n        character(len=1), intent(in) :: repl\n        integer :: i, j\n\n        do i = 1, size(strings)\n            do j = 1, len_trim(strings(i))\n                if (index(vowels, strings(i)(j:j)) > 0) then\n                    strings(i)(j:j) = repl\n                end if\n            end do\n        end do\n    end subroutine map\n\nend program replace_vowels\n```"
  },
  {
    "task": "Transform a list of integers to their hexadecimal representations using map.",
    "code": "```fortran\nprogram transform_to_hex\n    implicit none\n    integer, parameter :: n = 5\n    integer :: i\n    integer, dimension(n) :: numbers = [10, 15, 255, 1024, 4096]\n    character(len=8), dimension(n) :: hex_numbers\n\n    interface\n        function to_hex_str(number)\n            integer, intent(in) :: number\n            character(len=8) :: to_hex_str\n        end function to_hex_str\n    end interface\n\n    hex_numbers = map(to_hex_str, numbers)\n\n    do i = 1, n\n        print '(A)', trim(hex_numbers(i))\n    end do\ncontains\n    function to_hex_str(number)\n        integer, intent(in) :: number\n        character(len=8) :: to_hex_str\n        write(to_hex_str, '(Z8.8)') number\n    end function to_hex_str\n\n    pure function map(func, array) result(mapped_array)\n        procedure(func), pointer :: func\n        integer, dimension(:), intent(in) :: array\n        character(len=8), dimension(size(array)) :: mapped_array\n        integer :: i\n        do i = 1, size(array)\n            mapped_array(i) = func(array(i))\n        end do\n    end function map\nend program transform_to_hex\n```"
  },
  {
    "task": "Use map to apply a transformation matrix to a list of 2D vectors.",
    "code": "```fortran\nprogram transform_vectors\n  implicit none\n  real :: transformation_matrix(2, 2)\n  real :: vectors(2, :) = reshape([1.0, 2.0, 3.0, 4.0, 5.0, 6.0], [2, 3])\n  real :: transformed_vectors(2, size(vectors, 2))\n  integer :: i\n\n  transformation_matrix = reshape([1.5, 0.5, -0.5, 1.0], [2, 2])\n\n  call apply_transformation(transformation_matrix, vectors, transformed_vectors)\n\n  print *, transformed_vectors\n\ncontains\n\n  subroutine apply_transformation(matrix, vectors, result)\n    real, intent(in) :: matrix(2, 2)\n    real, intent(in) :: vectors(2, :)\n    real, intent(out) :: result(2, size(vectors, 2))\n    integer :: i\n\n    do i = 1, size(vectors, 2)\n      result(:, i) = matmul(matrix, vectors(:, i))\n    end do\n\n  end subroutine apply_transformation\n\nend program transform_vectors\n```"
  },
  {
    "task": "Convert a list of text strings to their phonetic alphabet equivalents using map.",
    "code": "```fortran\nprogram phonetic_map\n    implicit none\n    character(len=:), allocatable :: text_strings(:)\n    character(len=26), parameter :: phonetic_alphabet(26) = &\n        ['Alpha', 'Bravo', 'Charlie', 'Delta', 'Echo', 'Foxtrot', 'Golf', 'Hotel', 'India', &\n         'Juliett', 'Kilo', 'Lima', 'Mike', 'November', 'Oscar', 'Papa', 'Quebec', 'Romeo', &\n         'Sierra', 'Tango', 'Uniform', 'Victor', 'Whiskey', 'X-ray', 'Yankee', 'Zulu']\n    character(len=:), allocatable :: phonetic_strings(:)\n    integer :: i\n    \n    text_strings = ['hello', 'world']\n    allocate(character(len=60) :: phonetic_strings(size(text_strings)))\n    \n    phonetic_strings = map_phonetic(text_strings)\n    \n    do i = 1, size(text_strings)\n        print *, text_strings(i), ' -> ', phonetic_strings(i)\n    end do\n\ncontains\n\n    function map_phonetic(strings) result(phonetics)\n        character(len=:), allocatable :: strings(:)\n        character(len=:), allocatable :: phonetics(size(strings))\n        integer :: i, j\n        character(len=1) :: ch\n        phonetics = ''\n        do i = 1, size(strings)\n            do j = 1, len(strings(i))\n                ch = strings(i)(j:j)\n                if (iachar(ch) >= iachar('a') .and. iachar(ch) <= iachar('z')) then\n                    phonetics(i) = trim(phonetics(i)) // ' ' // phonetic_alphabet(iachar(ch) - iachar('a') + 1)\n                else if (iachar(ch) >= iachar('A') .and. iachar(ch) <= iachar('Z')) then\n                    phonetics(i) = trim(phonetics(i)) // ' ' // phonetic_alphabet(iachar(ch) - iachar('A') + 1)\n                end if\n            end do\n            phonetics(i) = adjustl(phonetics(i))\n        end do\n    end function map_phonetic\n\nend program phonetic_map\n```"
  },
  {
    "task": "Use map to determine if each word in a list is a palindrome, returning booleans.",
    "code": "```fortran\nprogram check_palindromes\n    implicit none\n    character(len=:), allocatable :: words(:)\n    logical, allocatable :: is_palindrome(:)\n    integer :: i\n\n    words = [ \"radar\", \"hello\", \"level\", \"world\", \"deified\" ]\n    allocate(is_palindrome(size(words)))\n\n    is_palindrome = map(words, is_palindrome_word)\n\n    do i = 1, size(words)\n        print *, words(i), \":\", is_palindrome(i)\n    end do\n\ncontains\n\n    logical function is_palindrome_word(word)\n        character(len=*), intent(in) :: word\n        integer :: len, j\n        len = len_trim(word)\n        is_palindrome_word = .true.\n        do j = 1, len / 2\n            if (word(j:j) /= word(len-j+1:len-j+1)) then\n                is_palindrome_word = .false.\n                exit\n            end if\n        end do\n    end function is_palindrome_word\n\n    logical function map(words, func)\n        character(len=*), dimension(:), intent(in) :: words\n        logical, dimension(size(words)) :: map\n        logical, external :: func\n        integer :: i\n\n        do i = 1, size(words)\n            map(i) = func(trim(words(i)))\n        end do\n    end function map\n\nend program check_palindromes\n```"
  },
  {
    "task": "Transform a list of dictionaries by renaming a specified key using a map function.",
    "code": "```fortran\nprogram transform_dictionaries\n    implicit none\n    type :: dictionary\n        character(len=32) :: key\n        character(len=32) :: value\n    end type dictionary\n\n    type(dictionary), allocatable :: dicts(:)\n    type(dictionary), allocatable :: new_dicts(:)\n    integer :: i\n\n    allocate(dicts(2))\n    dicts(1)%key = \"old_key\"\n    dicts(1)%value = \"value1\"\n    dicts(2)%key = \"old_key\"\n    dicts(2)%value = \"value2\"\n\n    new_dicts = map(dicts, \"old_key\", \"new_key\")\n\ncontains\n\n    elemental function map(dict, old_key, new_key) result(new_dict)\n        type(dictionary), intent(in) :: dict\n        character(len=*), intent(in) :: old_key, new_key\n        type(dictionary) :: new_dict\n\n        new_dict = dict\n        if (trim(dict%key) == trim(old_key)) then\n            new_dict%key = new_key\n        end if\n    end function map\n\nend program transform_dictionaries\n```"
  },
  {
    "task": "Use map to compute the logarithm of each number in a list.",
    "code": "```fortran\nprogram map_logarithm\n  implicit none\n  real, dimension(:), allocatable :: numbers, logarithms\n  integer :: i\n\n  numbers = [1.0, 2.0, 3.0, 4.0, 5.0]\n  allocate(logarithms(size(numbers)))\n\n  logarithms = [log(numbers(i)) for i = 1, size(numbers)]\n\n  print *, \"Logarithms: \", logarithms\n\nend program map_logarithm\n```"
  },
  {
    "task": "Convert a list of image file paths to grayscale versions using map.",
    "code": "```fortran\nprogram convert_to_grayscale\n    implicit none\n    character(len=100), dimension(:), allocatable :: image_paths, gray_paths\n    integer :: i, n\n\n    ! Sample list of image file paths\n    allocate(image_paths(3))\n    image_paths = [ \"image1.jpg\", \"image2.png\", \"image3.bmp\" ]\n\n    ! Convert to grayscale paths using map functionality\n    n = size(image_paths)\n    allocate(gray_paths(n))\n    \n    call map_to_grayscale(image_paths, gray_paths)\n    \n    do i = 1, n\n        print *, \"Original:\", trim(image_paths(i))\n        print *, \"Grayscale:\", trim(gray_paths(i))\n    end do\n\ncontains\n\n    subroutine map_to_grayscale(input_paths, output_paths)\n        character(len=100), dimension(:), intent(in) :: input_paths\n        character(len=100), dimension(:), intent(out) :: output_paths\n        integer :: i\n\n        do i = 1, size(input_paths)\n            output_paths(i) = trim(adjustl(input_paths(i))) // \"_gray\"\n        end do\n    end subroutine map_to_grayscale\n\nend program convert_to_grayscale\n```"
  },
  {
    "task": "Use map to flatten a list of lists of strings into a single list of strings.",
    "code": "```fortran\nprogram flatten_list\n    implicit none\n    character(len=:), allocatable :: flat_list(:)\n    character(len=:), allocatable :: list_of_lists(:,:)\n    integer :: i, n, m, k\n\n    ! Initialize a list of lists\n    list_of_lists = reshape([\"hello\", \"world\", \"foo\", \"bar\", &\n                             \"baz\", \"qux\"], [3, 2])\n\n    ! Calculate the total number of strings\n    n = size(list_of_lists, dim=1)\n    m = size(list_of_lists, dim=2)\n    allocate(flat_list(n * m))\n\n    ! Flatten the list of lists into a single list\n    k = 0\n    flat_list = [(list_of_lists(i, j), i = 1, n, j = 1, m)]\n\n    ! Print the flattened list\n    do i = 1, size(flat_list)\n        print *, trim(flat_list(i))\n    end do\nend program flatten_list\n```"
  },
  {
    "task": "Transform a list of temperature readings to temperature anomalies using a map function.",
    "code": "```fortran\nprogram temperature_anomalies\n  implicit none\n  real, dimension(:), allocatable :: temperatures, anomalies\n  real :: average_temp\n  integer :: i\n\n  ! Initialize the temperatures array\n  temperatures = [15.3, 17.8, 20.1, 15.9, 19.5]\n\n  ! Calculate the average temperature\n  average_temp = sum(temperatures) / size(temperatures)\n\n  ! Allocate the anomalies array\n  allocate(anomalies(size(temperatures)))\n\n  ! Map function to calculate anomalies\n  anomalies = [(temperatures(i) - average_temp, i = 1, size(temperatures))]\n\n  ! Output the anomalies\n  print *, anomalies\n\nend program temperature_anomalies\n```"
  }
]