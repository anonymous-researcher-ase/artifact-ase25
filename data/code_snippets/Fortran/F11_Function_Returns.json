[
  {
    "task": "Create a function that calculates the sum of two numbers and returns the result.",
    "code": "```fortran\nprogram sum_program\n    implicit none\n    real :: num1, num2, result\n\n    num1 = 5.0\n    num2 = 3.0\n    result = sum_two_numbers(num1, num2)\n    print *, 'The sum is:', result\n\ncontains\n\n    real function sum_two_numbers(a, b)\n        real, intent(in) :: a, b\n        sum_two_numbers = a + b\n    end function sum_two_numbers\n\nend program sum_program\n```"
  },
  {
    "task": "Design a function that takes a string and returns its length.",
    "code": "```fortran\nprogram string_length\n    implicit none\n    character(len=100) :: input_string\n    integer :: result\n\n    ! Example input\n    input_string = \"Hello, World!\"\n    result = string_length_func(trim(input_string))\n    print *, \"Length of the string:\", result\n\ncontains\n\n    function string_length_func(s) result(len)\n        character(len=*), intent(in) :: s\n        integer :: len\n\n        len = len_trim(s)\n    end function string_length_func\n\nend program string_length\n```"
  },
  {
    "task": "Write a function that checks if a number is prime and returns a boolean value.",
    "code": "```fortran\nmodule PrimeCheck\ncontains\n    logical function is_prime(n)\n        integer, intent(in) :: n\n        integer :: i\n        \n        if (n <= 1) then\n            is_prime = .false.\n            return\n        end if\n\n        if (n == 2) then\n            is_prime = .true.\n            return\n        end if\n\n        if (mod(n, 2) == 0) then\n            is_prime = .false.\n            return\n        end if\n\n        do i = 3, int(sqrt(real(n))), 2\n            if (mod(n, i) == 0) then\n                is_prime = .false.\n                return\n            end if\n        end do\n        \n        is_prime = .true.\n    end function is_prime\nend module PrimeCheck\n```"
  },
  {
    "task": "Implement a function that returns the highest value in a list of integers.",
    "code": "```fortran\nprogram max_value_program\n    implicit none\n    integer, parameter :: n = 5\n    integer :: values(n) = [3, 1, 4, 1, 5]\n    integer :: max_value\n\n    max_value = find_max(values, n)\n    print *, \"The highest value is:\", max_value\n\ncontains\n\n    function find_max(arr, size) result(max_val)\n        integer, intent(in) :: arr(:)\n        integer, intent(in) :: size\n        integer :: max_val\n        integer :: i\n\n        max_val = arr(1)\n        do i = 2, size\n            if (arr(i) > max_val) then\n                max_val = arr(i)\n            end if\n        end do\n    end function find_max\n\nend program max_value_program\n```"
  },
  {
    "task": "Create a function that accepts a list of words and returns the longest word.",
    "code": "```fortran\nprogram longest_word\n    implicit none\n    character(len=100) :: words(5)\n    character(len=100) :: result\n\n    words = ['apple', 'banana', 'cherry', 'date', 'elderberry']\n    result = longestWord(words)\n    print *, 'Longest word:', trim(result)\ncontains\n    function longestWord(wordList) result(longest)\n        character(len=100), dimension(:), intent(in) :: wordList\n        character(len=100) :: longest\n        integer :: i\n\n        longest = ''\n        do i = 1, size(wordList)\n            if (len_trim(wordList(i)) > len_trim(longest)) then\n                longest = wordList(i)\n            end if\n        end do\n    end function longestWord\nend program longest_word\n```"
  },
  {
    "task": "Write a function that takes a temperature in Celsius and returns the equivalent in Fahrenheit.",
    "code": "```fortran\nprogram temperature_conversion\n    implicit none\n    real :: celsius, fahrenheit\n\n    print *, \"Enter temperature in Celsius:\"\n    read *, celsius\n    fahrenheit = celsius_to_fahrenheit(celsius)\n    print *, \"Equivalent temperature in Fahrenheit:\", fahrenheit\n\ncontains\n\n    real function celsius_to_fahrenheit(celsius)\n        real, intent(in) :: celsius\n        celsius_to_fahrenheit = celsius * 9.0 / 5.0 + 32.0\n    end function celsius_to_fahrenheit\n\nend program temperature_conversion\n```"
  },
  {
    "task": "Develop a function that returns the factorial of a given number.",
    "code": "```fortran\nprogram factorial_program\n    implicit none\n    integer :: num\n    integer :: result\n\n    print *, \"Enter a number:\"\n    read *, num\n    result = factorial(num)\n    print *, \"Factorial of\", num, \"is\", result\n\ncontains\n\n    recursive function factorial(n) result(fact)\n        integer, intent(in) :: n\n        integer :: fact\n        if (n <= 1) then\n            fact = 1\n        else\n            fact = n * factorial(n - 1)\n        end if\n    end function factorial\n\nend program factorial_program\n```"
  },
  {
    "task": "Implement a function that receives a date and returns the day of the week.",
    "code": "```fortran\nmodule date_module\n  implicit none\ncontains\n\n  function day_of_week(year, month, day) result(weekday)\n    integer, intent(in) :: year, month, day\n    character(len=9) :: weekday\n    integer :: h, q, m, k, j\n\n    ! Zeller's Congruence algorithm\n    q = day\n    if (month == 1 .or. month == 2) then\n      m = month + 12\n      k = mod(year - 1, 100)\n      j = (year - 1) / 100\n    else\n      m = month\n      k = mod(year, 100)\n      j = year / 100\n    end if\n\n    h = mod(q + int((13 * (m + 1)) / 5) + k + int(k / 4) + int(j / 4) - 2 * j, 7)\n\n    select case(h)\n    case(0)\n        weekday = \"Saturday\"\n    case(1)\n        weekday = \"Sunday\"\n    case(2)\n        weekday = \"Monday\"\n    case(3)\n        weekday = \"Tuesday\"\n    case(4)\n        weekday = \"Wednesday\"\n    case(5)\n        weekday = \"Thursday\"\n    case(6)\n        weekday = \"Friday\"\n    end select\n\n  end function day_of_week\n\nend module date_module\n```"
  },
  {
    "task": "Write a function that calculates the area of a circle given its radius and returns the value.",
    "code": "```fortran\nmodule circle_module\n  implicit none\ncontains\n  function area_of_circle(radius) result(area)\n    real, intent(in) :: radius\n    real :: area\n\n    area = 3.141592653589793 * radius**2\n  end function area_of_circle\nend module circle_module\n```"
  },
  {
    "task": "Create a function that converts a string to uppercase and returns the modified string.",
    "code": "```fortran\nprogram string_to_uppercase\n    implicit none\n    character(len=100) :: input_string, result_string\n\n    ! Example input\n    input_string = 'Hello, World!'\n\n    result_string = to_uppercase(input_string)\n    print *, result_string\n\ncontains\n\n    function to_uppercase(str) result(upper_str)\n        character(len=*), intent(in) :: str\n        character(len=len(str)) :: upper_str\n        integer :: i\n\n        upper_str = str\n        do i = 1, len(str)\n            if (iachar(str(i:i)) >= iachar('a') .and. iachar(str(i:i)) <= iachar('z')) then\n                upper_str(i:i) = achar(iachar(str(i:i)) - iachar('a') + iachar('A'))\n            end if\n        end do\n    end function to_uppercase\n\nend program string_to_uppercase\n```"
  },
  {
    "task": "Design a function that returns the reverse of a given list.",
    "code": "```fortran\nprogram reverse_list_program\n    implicit none\n    integer, allocatable :: input_list(:), reversed_list(:)\n    integer :: n\n\n    ! Example input\n    input_list = [1, 2, 3, 4, 5]\n    n = size(input_list)\n    \n    allocate(reversed_list(n))\n    reversed_list = reverse_list(input_list)\n\n    print *, \"Reversed list: \", reversed_list\nend program reverse_list_program\n\nfunction reverse_list(arr) result(reversed)\n    integer, intent(in) :: arr(:)\n    integer :: reversed(size(arr))\n    integer :: i\n\n    do i = 1, size(arr)\n        reversed(i) = arr(size(arr) - i + 1)\n    end do\nend function reverse_list\n```"
  },
  {
    "task": "Implement a function that accepts a string and returns a dictionary with character frequencies.",
    "code": "```fortran\nmodule char_frequency_module\n  implicit none\ncontains\n  function char_frequency(input_string) result(freq)\n    character(len=*), intent(in) :: input_string\n    integer :: freq(256)\n    integer :: i, char_code\n    \n    freq = 0\n    do i = 1, len(input_string)\n      char_code = iachar(input_string(i:i))\n      if (char_code >= 1 .and. char_code <= 255) then\n        freq(char_code) = freq(char_code) + 1\n      end if\n    end do\n  end function char_frequency\nend module char_frequency_module\n```"
  },
  {
    "task": "Write a function that returns the first non-repeating character in a string.",
    "code": "```fortran\nprogram first_non_repeating\n    implicit none\n    character(len=1) :: result\n    result = firstNonRepeatingCharacter(\"example\")\n    print *, \"First non-repeating character: \", result\ncontains\n    function firstNonRepeatingCharacter(str) result(ch)\n        character(len=*), intent(in) :: str\n        character(len=1) :: ch\n        integer :: n, i, j\n        logical :: is_repeating\n\n        n = len_trim(str)\n        ch = ' '\n        do i = 1, n\n            is_repeating = .false.\n            do j = 1, n\n                if (i /= j .and. str(i:i) == str(j:j)) then\n                    is_repeating = .true.\n                    exit\n                end if\n            end do\n            if (.not. is_repeating) then\n                ch = str(i:i)\n                return\n            end if\n        end do\n    end function firstNonRepeatingCharacter\nend program first_non_repeating\n```"
  },
  {
    "task": "Create a function that takes a list of numbers and returns a new list with only even numbers.",
    "code": "```fortran\nmodule even_numbers_module\n    implicit none\ncontains\n    function filter_even_numbers(numbers) result(even_numbers)\n        integer, intent(in) :: numbers(:)\n        integer, allocatable :: even_numbers(:)\n        integer :: i, count\n\n        count = 0\n        do i = 1, size(numbers)\n            if (mod(numbers(i), 2) == 0) then\n                count = count + 1\n            end if\n        end do\n\n        allocate(even_numbers(count))\n        count = 0\n        do i = 1, size(numbers)\n            if (mod(numbers(i), 2) == 0) then\n                count = count + 1\n                even_numbers(count) = numbers(i)\n            end if\n        end do\n    end function filter_even_numbers\nend module even_numbers_module\n```"
  },
  {
    "task": "Develop a function that receives a sentence and returns the word count.",
    "code": "```fortran\nprogram word_count_program\n    implicit none\n    character(len=100) :: sentence\n    integer :: count\n\n    print *, 'Enter a sentence:'\n    read(*, '(A)') sentence\n\n    count = word_count(sentence)\n    print *, 'Word count:', count\n\ncontains\n\n    function word_count(sentence) result(count)\n        character(len=*), intent(in) :: sentence\n        integer :: count\n        integer :: i, len_sentence\n        logical :: in_word\n\n        count = 0\n        len_sentence = len_trim(sentence)\n        in_word = .false.\n\n        do i = 1, len_sentence\n            if (sentence(i:i) /= ' ') then\n                if (.not. in_word) then\n                    count = count + 1\n                    in_word = .true.\n                end if\n            else\n                in_word = .false.\n            end if\n        end do\n    end function word_count\n\nend program word_count_program\n```"
  },
  {
    "task": "Implement a function that returns the smallest element in an array.",
    "code": "```fortran\nprogram smallest_element\n    implicit none\n    integer, parameter :: n = 5\n    integer :: array(n) = [4, 2, 5, 1, 3]\n    integer :: result\n\n    result = find_smallest(array, n)\n    print *, \"The smallest element is:\", result\n\ncontains\n\n    integer function find_smallest(arr, size)\n        integer, intent(in) :: arr(:)\n        integer, intent(in) :: size\n        integer :: i\n\n        find_smallest = arr(1)\n        do i = 2, size\n            if (arr(i) < find_smallest) then\n                find_smallest = arr(i)\n            end if\n        end do\n    end function find_smallest\n\nend program smallest_element\n```"
  },
  {
    "task": "Write a function that takes two strings and returns true if they are anagrams.",
    "code": "```fortran\nmodule anagram_module\n  implicit none\ncontains\n  logical function are_anagrams(s1, s2)\n    character(len=*), intent(in) :: s1, s2\n    character(len=:), allocatable :: sorted_s1, sorted_s2\n    integer :: i\n\n    if (len(s1) /= len(s2)) then\n      are_anagrams = .false.\n      return\n    end if\n\n    sorted_s1 = s1\n    sorted_s2 = s2\n\n    do i = 1, len(s1)\n      call sort_string(sorted_s1)\n      call sort_string(sorted_s2)\n    end do\n\n    if (sorted_s1 == sorted_s2) then\n      are_anagrams = .true.\n    else\n      are_anagrams = .false.\n    end if\n  end function are_anagrams\n\n  subroutine sort_string(s)\n    character(len=*), intent(inout) :: s\n    character :: temp\n    integer :: i, j\n\n    do i = 1, len(s)-1\n      do j = i+1, len(s)\n        if (s(i:i) > s(j:j)) then\n          temp = s(i:i)\n          s(i:i) = s(j:j)\n          s(j:j) = temp\n        end if\n      end do\n    end do\n  end subroutine sort_string\nend module anagram_module\n```"
  },
  {
    "task": "Create a function that accepts an integer and returns a list of its divisors.",
    "code": "```fortran\nmodule divisors_module\n    implicit none\ncontains\n    function find_divisors(n) result(divisors)\n        integer, intent(in) :: n\n        integer, allocatable :: divisors(:)\n        integer :: i, count\n        \n        count = 0\n        do i = 1, n\n            if (mod(n, i) == 0) then\n                count = count + 1\n            end if\n        end do\n        \n        allocate(divisors(count))\n        count = 0\n        do i = 1, n\n            if (mod(n, i) == 0) then\n                count = count + 1\n                divisors(count) = i\n            end if\n        end do\n    end function find_divisors\nend module divisors_module\n```"
  },
  {
    "task": "Design a function that returns the square root of a given number.",
    "code": "```fortran\nprogram main\n    implicit none\n    real :: number, result\n\n    print *, \"Enter a number:\"\n    read(*,*) number\n\n    result = sqrt_function(number)\n    print *, \"The square root is:\", result\n\ncontains\n\n    real function sqrt_function(x)\n        real, intent(in) :: x\n        sqrt_function = sqrt(x)\n    end function sqrt_function\n\nend program main\n```"
  },
  {
    "task": "Implement a function that accepts a list and returns it sorted in ascending order.",
    "code": "```fortran\nmodule sort_module\n  implicit none\ncontains\n  function sort_list(arr) result(sorted_arr)\n    integer, dimension(:), intent(in) :: arr\n    integer, dimension(size(arr)) :: sorted_arr\n    integer :: i, j, temp\n\n    sorted_arr = arr\n    do i = 1, size(sorted_arr) - 1\n       do j = i + 1, size(sorted_arr)\n          if (sorted_arr(i) > sorted_arr(j)) then\n             temp = sorted_arr(i)\n             sorted_arr(i) = sorted_arr(j)\n             sorted_arr(j) = temp\n          end if\n       end do\n    end do\n  end function sort_list\nend module sort_module\n```"
  },
  {
    "task": "Write a function that checks whether a given year is a leap year and returns a boolean.",
    "code": "```fortran\nlogical function is_leap_year(year)\n  integer, intent(in) :: year\n  is_leap_year = (mod(year, 4) == 0 .and. (mod(year, 100) /= 0 .or. mod(year, 400) == 0))\nend function is_leap_year\n```"
  },
  {
    "task": "Create a function that receives a list of numbers and returns their average.",
    "code": "```fortran\nprogram average_calculation\n  implicit none\n  real :: avg\n  real, dimension(:), allocatable :: numbers\n  \n  allocate(numbers(5))\n  numbers = [1.0, 2.0, 3.0, 4.0, 5.0]\n  \n  avg = calculate_average(numbers)\n  print *, \"Average: \", avg\n\ncontains\n\n  function calculate_average(arr) result(average)\n    real, dimension(:), intent(in) :: arr\n    real :: average\n    average = sum(arr) / size(arr)\n  end function calculate_average\n\nend program average_calculation\n```"
  },
  {
    "task": "Develop a function that returns the nth Fibonacci number.",
    "code": "```fortran\nprogram fibonacci_program\n  implicit none\n  integer :: n, result\n\n  print *, \"Enter the value of n:\"\n  read *, n\n\n  result = fibonacci(n)\n\n  print *, \"The\", n, \"th Fibonacci number is\", result\ncontains\n  recursive function fibonacci(n) result(fib)\n    integer, intent(in) :: n\n    integer :: fib\n\n    if (n <= 0) then\n      fib = 0\n    else if (n == 1) then\n      fib = 1\n    else\n      fib = fibonacci(n - 1) + fibonacci(n - 2)\n    end if\n  end function fibonacci\nend program fibonacci_program\n```"
  },
  {
    "task": "Implement a function that accepts a string and returns it with vowels removed.",
    "code": "```fortran\nprogram remove_vowels\n    implicit none\n    character(len=100) :: input_string, result_string\n\n    print *, \"Enter a string:\"\n    read(*,'(A)') input_string\n\n    result_string = removeVowels(input_string)\n\n    print *, \"String without vowels: \", result_string\n\ncontains\n\n    function removeVowels(str) result(no_vowels)\n        character(len=*), intent(in) :: str\n        character(len=len(str)) :: no_vowels\n        integer :: i, j\n        character(len=1) :: c\n\n        no_vowels = \"\"\n        j = 0\n\n        do i = 1, len(str)\n            c = str(i:i)\n            if (index(\"aeiouAEIOU\", c) == 0) then\n                j = j + 1\n                no_vowels(j:j) = c\n            end if\n        end do\n\n        no_vowels = no_vowels(:j)\n    end function removeVowels\n\nend program remove_vowels\n```"
  },
  {
    "task": "Write a function that takes two dates and returns the number of days between them.",
    "code": "```fortran\nmodule date_utils\n  implicit none\ncontains\n\n  function days_between(date1, date2) result(days)\n    integer, dimension(3), intent(in) :: date1, date2\n    integer :: days\n    integer :: y1, m1, d1, y2, m2, d2\n\n    ! Extract year, month, day from the input arrays\n    y1 = date1(1)\n    m1 = date1(2)\n    d1 = date1(3)\n    y2 = date2(1)\n    m2 = date2(2)\n    d2 = date2(3)\n\n    ! Calculate the number of days using Fortran's intrinsic functions\n    days = abs(julian_date(y2, m2, d2) - julian_date(y1, m1, d1))\n  end function days_between\n\n  function julian_date(year, month, day) result(jdate)\n    integer, intent(in) :: year, month, day\n    integer :: jdate\n\n    jdate = day - 32075 + 1461*(year + 4800 + (month - 14)/12)/4 &\n            + 367*(month - 2 - (month - 14)/12*12)/12 &\n            - 3*((year + 4900 + (month - 14)/12)/100)/4\n  end function julian_date\n\nend module date_utils\n```"
  },
  {
    "task": "Create a function that returns the last element of a list.",
    "code": "```fortran\nprogram last_element_example\n    implicit none\n    integer, dimension(:), allocatable :: my_list\n    integer :: last_elem\n\n    ! Example list\n    allocate(my_list(5))\n    my_list = [1, 2, 3, 4, 5]\n\n    ! Get the last element\n    last_elem = last_element(my_list)\n\n    print *, \"The last element is: \", last_elem\n\ncontains\n\n    function last_element(list) result(last)\n        integer, dimension(:), intent(in) :: list\n        integer :: last\n\n        last = list(size(list))\n    end function last_element\n\nend program last_element_example\n```"
  },
  {
    "task": "Design a function that calculates the GCD of two numbers and returns it.",
    "code": "```fortran\nprogram gcd_program\n  implicit none\n  integer :: result\n\n  result = gcd(48, 18)\n  print *, 'GCD is ', result\n\ncontains\n\n  recursive function gcd(a, b) result(g)\n    integer, intent(in) :: a, b\n    integer :: g\n    if (b == 0) then\n      g = a\n    else\n      g = gcd(b, mod(a, b))\n    end if\n  end function gcd\n\nend program gcd_program\n```"
  },
  {
    "task": "Implement a function that takes a list and returns a tuple with the min and max values.",
    "code": "```fortran\nmodule MinMaxModule\ncontains\n    function min_max(values) result(minmax)\n        implicit none\n        real, intent(in) :: values(:)\n        real :: minmax(2)\n        \n        minmax(1) = minval(values)\n        minmax(2) = maxval(values)\n    end function min_max\nend module MinMaxModule\n```"
  },
  {
    "task": "Write a function that converts a binary string to its decimal representation and returns it.",
    "code": "```fortran\nfunction binaryToDecimal(binaryString) result(decimalValue)\n    implicit none\n    character(len=*), intent(in) :: binaryString\n    integer :: decimalValue\n    integer :: i, length\n\n    length = len_trim(binaryString)\n    decimalValue = 0\n\n    do i = 1, length\n        if (binaryString(i:i) == '1') then\n            decimalValue = decimalValue * 2 + 1\n        else\n            decimalValue = decimalValue * 2\n        end if\n    end do\nend function binaryToDecimal\n```"
  },
  {
    "task": "Create a function that accepts a dictionary and returns a list of its keys.",
    "code": "```fortran\nmodule dictionary_module\n  implicit none\n\ncontains\n\n  function get_keys(dict) result(keys)\n    type(dict_type), intent(in) :: dict\n    character(len=:), allocatable :: keys(:)\n    integer :: i, n\n\n    n = size(dict%entries)\n    allocate(keys(n))\n\n    do i = 1, n\n      keys(i) = dict%entries(i)%key\n    end do\n\n  end function get_keys\n\nend module dictionary_module\n\ntype :: entry_type\n  character(len=:), allocatable :: key\n  integer :: value\nend type entry_type\n\ntype :: dict_type\n  type(entry_type), allocatable :: entries(:)\nend type dict_type\n```"
  },
  {
    "task": "Develop a function that returns the concatenation of two strings.",
    "code": "```fortran\nprogram concatenate_strings\n    implicit none\n    character(len=100) :: str1, str2, result\n\n    str1 = 'Hello, '\n    str2 = 'World!'\n    result = concat_strings(str1, str2)\n    print *, result\n\ncontains\n\n    function concat_strings(s1, s2) result(concatenated)\n        character(len=*), intent(in) :: s1, s2\n        character(len=len(s1)+len(s2)) :: concatenated\n\n        concatenated = s1 // s2\n    end function concat_strings\n\nend program concatenate_strings\n```"
  },
  {
    "task": "Implement a function that receives a list and returns a new list with duplicates removed.",
    "code": "```fortran\nmodule list_utils\ncontains\n    function remove_duplicates(list) result(unique_list)\n        integer, dimension(:), intent(in) :: list\n        integer, dimension(:), allocatable :: unique_list\n        integer :: i, j, count, n\n\n        n = size(list)\n        allocate(unique_list(n))\n        count = 0\n\n        do i = 1, n\n            do j = 1, count\n                if (unique_list(j) == list(i)) exit\n            end do\n            if (j > count) then\n                count = count + 1\n                unique_list(count) = list(i)\n            end if\n        end do\n\n        if (count < n) then\n            unique_list = unique_list(:count)\n        end if\n    end function remove_duplicates\nend module list_utils\n```"
  },
  {
    "task": "Write a function that returns the intersection of two lists.",
    "code": "```fortran\nmodule list_operations\n  implicit none\ncontains\n  function intersection(list1, list2) result(intersect)\n    integer, dimension(:), intent(in) :: list1, list2\n    integer, allocatable, dimension(:) :: intersect\n    integer :: i, j, n\n\n    allocate(intersect(0))\n    n = 0\n    do i = 1, size(list1)\n      do j = 1, size(list2)\n        if (list1(i) == list2(j)) then\n          if (.not. any(intersect == list1(i))) then\n            n = n + 1\n            if (allocated(intersect)) then\n              intersect = [intersect, list1(i)]\n            else\n              allocate(intersect(n))\n              intersect(n) = list1(i)\n            end if\n          end if\n        end if\n      end do\n    end do\n  end function intersection\nend module list_operations\n```"
  },
  {
    "task": "Create a function that takes an integer and returns whether it is even or odd as a string.",
    "code": "```fortran\nprogram even_odd_check\n    implicit none\n    integer :: num\n    character(len=4) :: result\n\n    print *, \"Enter an integer:\"\n    read(*, *) num\n\n    result = even_or_odd(num)\n    print *, \"The number is \", trim(result)\n\ncontains\n\n    function even_or_odd(n) result(status)\n        integer, intent(in) :: n\n        character(len=4) :: status\n\n        if (mod(n, 2) == 0) then\n            status = 'even'\n        else\n            status = 'odd'\n        end if\n    end function even_or_odd\n\nend program even_odd_check\n```"
  },
  {
    "task": "Design a function that returns the number of vowels in a given string.",
    "code": "```fortran\nprogram count_vowels\n    implicit none\n    character(len=100) :: input_string\n    integer :: num_vowels\n\n    print *, 'Enter a string:'\n    read(*, '(A)') input_string\n\n    num_vowels = countVowels(input_string)\n    print *, 'Number of vowels:', num_vowels\nend program count_vowels\n\nfunction countVowels(s) result(num_vowels)\n    implicit none\n    character(len=*), intent(in) :: s\n    integer :: num_vowels\n    integer :: i\n    character(len=1) :: c\n\n    num_vowels = 0\n    do i = 1, len_trim(s)\n        c = s(i:i)\n        select case (c)\n        case ('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')\n            num_vowels = num_vowels + 1\n        end select\n    end do\nend function countVowels\n```"
  },
  {
    "task": "Implement a function that counts the occurrences of a substring within a string and returns it.",
    "code": "```fortran\nprogram substring_count\n    implicit none\n    character(len=:), allocatable :: main_string, sub_string\n    integer :: count\n\n    main_string = \"abcabcabc\"\n    sub_string = \"abc\"\n    count = count_substring(main_string, sub_string)\n    print *, \"Occurrences:\", count\n\ncontains\n\n    function count_substring(string, substr) result(count)\n        character(len=*), intent(in) :: string, substr\n        integer :: count\n        integer :: pos\n\n        count = 0\n        pos = index(string, substr)\n\n        do while (pos > 0)\n            count = count + 1\n            pos = index(string(pos+len(substr):), substr)\n            if (pos > 0) pos = pos + len(substr)\n        end do\n\n    end function count_substring\n\nend program substring_count\n```"
  },
  {
    "task": "Write a function that accepts a list of numbers and returns them sorted in descending order.",
    "code": "```fortran\nprogram sort_descending\n    implicit none\n    real :: numbers(5) = [3.2, 5.1, 4.8, 1.9, 2.5]\n    real :: sorted_numbers(5)\n    \n    sorted_numbers = sort_desc(numbers)\n    print *, sorted_numbers\n\ncontains\n\n    pure function sort_desc(arr) result(sorted)\n        real, intent(in) :: arr(:)\n        real :: sorted(size(arr))\n        integer :: i, j\n        real :: temp\n\n        sorted = arr\n        do i = 1, size(sorted) - 1\n            do j = i + 1, size(sorted)\n                if (sorted(i) < sorted(j)) then\n                    temp = sorted(i)\n                    sorted(i) = sorted(j)\n                    sorted(j) = temp\n                end if\n            end do\n        end do\n    end function sort_desc\n\nend program sort_descending\n```"
  },
  {
    "task": "Create a function that returns the median of a list of numbers.",
    "code": "```fortran\nprogram median_program\n    implicit none\n    real :: result\n    real, dimension(:), allocatable :: numbers\n\n    ! Example usage\n    allocate(numbers(5))\n    numbers = [1.0, 3.0, 4.0, 2.0, 5.0]\n    result = median(numbers)\n    print *, \"Median is:\", result\n\ncontains\n\n    real function median(data)\n        real, dimension(:), intent(in) :: data\n        real, dimension(:), allocatable :: sorted_data\n        integer :: n\n\n        n = size(data)\n        allocate(sorted_data(n))\n        sorted_data = data\n        call sort(sorted_data)\n        \n        if (mod(n, 2) == 0) then\n            median = (sorted_data(n/2) + sorted_data(n/2 + 1)) / 2.0\n        else\n            median = sorted_data((n+1)/2)\n        end if\n    end function median\n\n    subroutine sort(array)\n        real, dimension(:), intent(inout) :: array\n        integer :: i, j\n        real :: temp\n        do i = 1, size(array) - 1\n            do j = i + 1, size(array)\n                if (array(i) > array(j)) then\n                    temp = array(i)\n                    array(i) = array(j)\n                    array(j) = temp\n                end if\n            end do\n        end do\n    end subroutine sort\n\nend program median_program\n```"
  },
  {
    "task": "Develop a function that receives a sentence and returns it with words in reverse order.",
    "code": "```fortran\nprogram reverse_words\n    implicit none\n    character(len=100) :: sentence\n    character(len=100) :: reversed_sentence\n\n    print *, 'Enter a sentence:'\n    read(*,'(A)') sentence\n\n    reversed_sentence = reverse_words_in_sentence(sentence)\n    print *, 'Reversed sentence:', trimmed(reversed_sentence)\n\ncontains\n\n    function reverse_words_in_sentence(sentence) result(reversed)\n        character(len=*), intent(in) :: sentence\n        character(len=100) :: reversed\n        character(len=100) :: temp\n        integer :: i, j, start, word_count\n\n        reversed = ''\n        temp = ''\n        start = 1\n        word_count = 0\n\n        do i = len(sentence), 1, -1\n            if (sentence(i:i) == ' ' .or. i == 1) then\n                if (i == 1) then\n                    j = 1\n                else\n                    j = i + 1\n                end if\n                if (start > 1) reversed = reversed // ' '\n                reversed = reversed // sentence(j:start)\n                start = i - 1\n            end if\n        end do\n    end function reverse_words_in_sentence\n\nend program reverse_words\n```"
  },
  {
    "task": "Implement a function that returns the sum of all elements in a matrix.",
    "code": "```fortran\nfunction sum_matrix(matrix) result(total)\n    real, dimension(:,:), intent(in) :: matrix\n    real :: total\n    integer :: i, j\n\n    total = 0.0\n    do i = 1, size(matrix, 1)\n        do j = 1, size(matrix, 2)\n            total = total + matrix(i, j)\n        end do\n    end do\nend function sum_matrix\n```"
  },
  {
    "task": "Write a function that accepts a string and returns true if it is a palindrome.",
    "code": "```fortran\nprogram check_palindrome\n  implicit none\n  character(len=*), parameter :: test_string = \"radar\"\n  logical :: result\n\n  result = is_palindrome(test_string)\n  print *, \"Is the string a palindrome? \", result\n\ncontains\n\n  logical function is_palindrome(s)\n    character(len=*), intent(in) :: s\n    integer :: i, n\n\n    n = len_trim(s)\n    do i = 1, n/2\n      if (s(i:i) /= s(n-i+1:n-i+1)) then\n        is_palindrome = .false.\n        return\n      end if\n    end do\n    is_palindrome = .true.\n  end function is_palindrome\n\nend program check_palindrome\n```"
  },
  {
    "task": "Create a function that takes a number and returns its binary representation as a string.",
    "code": "```fortran\nprogram binaryRepresentation\n  implicit none\n  integer :: num\n  character(len=32) :: binString\n\n  write(*,*) \"Enter a number:\"\n  read(*,*) num\n  binString = intToBinary(num)\n  write(*,*) \"Binary representation:\", trim(binString)\n\ncontains\n\n  function intToBinary(n) result(binaryString)\n    integer, intent(in) :: n\n    character(len=32) :: binaryString\n    integer :: num, i\n\n    num = n\n    binaryString = \"\"\n    do i = 32, 1, -1\n      if (btest(num, i-1)) then\n        binaryString(33-i:33-i) = '1'\n      else\n        binaryString(33-i:33-i) = '0'\n      end if\n    end do\n\n  end function intToBinary\n\nend program binaryRepresentation\n```"
  },
  {
    "task": "Design a function that returns the number of words in a paragraph.",
    "code": "```fortran\nprogram count_words_program\n    implicit none\n    character(len=1000) :: paragraph\n    integer :: num_words\n\n    paragraph = \"This is an example paragraph to count the number of words.\"\n\n    num_words = count_words(paragraph)\n    print *, \"Number of words:\", num_words\nend program count_words_program\n\nfunction count_words(text) result(word_count)\n    implicit none\n    character(len=*), intent(in) :: text\n    integer :: word_count\n    integer :: i, len_text, in_word\n\n    len_text = len(trim(text))\n    word_count = 0\n    in_word = 0\n\n    do i = 1, len_text\n        if (text(i:i) /= ' ') then\n            if (.not. in_word) then\n                word_count = word_count + 1\n                in_word = 1\n            end if\n        else\n            in_word = 0\n        end if\n    end do\nend function count_words\n```"
  },
  {
    "task": "Implement a function that accepts a list and returns the index of its maximum element.",
    "code": "```fortran\nprogram find_max_index\n  implicit none\n  integer :: index\n  integer, allocatable :: list(:)\n  \n  list = [5, 3, 9, 1, 7]\n  index = max_index(list)\n  print *, 'The index of the maximum element is:', index\n\ncontains\n\n  integer function max_index(arr)\n    integer, intent(in) :: arr(:)\n    integer :: i\n\n    max_index = 1\n    do i = 2, size(arr)\n      if (arr(i) > arr(max_index)) then\n        max_index = i\n      end if\n    end do\n  end function max_index\n\nend program find_max_index\n```"
  },
  {
    "task": "Write a function that takes a list of grades and returns the highest grade.",
    "code": "```fortran\nprogram find_max_grade\n    implicit none\n    integer, parameter :: n = 5\n    integer :: grades(n) = [88, 92, 76, 81, 95]\n    integer :: max_grade\n\n    max_grade = get_highest_grade(grades, n)\n    print *, \"The highest grade is: \", max_grade\nend program find_max_grade\n\nfunction get_highest_grade(grades, size) result(max_grade)\n    integer, intent(in) :: grades(:)\n    integer, intent(in) :: size\n    integer :: max_grade\n    integer :: i\n\n    max_grade = grades(1)\n    do i = 2, size\n        if (grades(i) > max_grade) then\n            max_grade = grades(i)\n        end if\n    end do\nend function get_highest_grade\n```"
  },
  {
    "task": "Create a function that returns the product of all positive integers up to a given number.",
    "code": "```fortran\nmodule factorial_module\ncontains\n    recursive function factorial(n) result(prod)\n        integer, intent(in) :: n\n        integer :: prod\n        if (n <= 1) then\n            prod = 1\n        else\n            prod = n * factorial(n - 1)\n        end if\n    end function factorial\nend module factorial_module\n```"
  },
  {
    "task": "Develop a function that receives a string and returns a new string with spaces replaced by hyphens.",
    "code": "```fortran\nprogram replace_spaces\n    implicit none\n    character(len=100) :: inputString, outputString\n\n    inputString = \"Hello World From Fortran\"\n    outputString = replace_spaces_with_hyphens(inputString)\n    print *, trim(outputString)\n\ncontains\n\n    function replace_spaces_with_hyphens(str) result(newStr)\n        character(len=*), intent(in) :: str\n        character(len=len(str)) :: newStr\n        integer :: i\n\n        newStr = str\n        do i = 1, len(str)\n            if (str(i:i) == ' ') newStr(i:i) = '-'\n        end do\n    end function replace_spaces_with_hyphens\n\nend program replace_spaces\n```"
  },
  {
    "task": "Implement a function that takes a list of integers and returns their sum.",
    "code": "```fortran\nprogram sum_function\n  implicit none\n  integer :: result\n  integer, dimension(5) :: numbers = [1, 2, 3, 4, 5]\n\n  result = sum_of_numbers(numbers)\n  print *, \"The sum is: \", result\n\ncontains\n\n  function sum_of_numbers(arr) result(sum)\n    integer, dimension(:), intent(in) :: arr\n    integer :: sum\n    integer :: i\n\n    sum = 0\n    do i = 1, size(arr)\n      sum = sum + arr(i)\n    end do\n  end function sum_of_numbers\n\nend program sum_function\n```"
  },
  {
    "task": "Write a function that checks if a string is a valid email address and returns a boolean.",
    "code": "```fortran\nmodule email_validation\n  implicit none\ncontains\n\n  logical function is_valid_email(email)\n    character(len=*), intent(in) :: email\n    integer :: at_pos, dot_pos\n\n    at_pos = index(email, '@')\n    dot_pos = index(email, '.', at_pos+1)\n\n    if (at_pos > 1 .and. dot_pos > at_pos + 1 .and. dot_pos < len_trim(email)) then\n      is_valid_email = .true.\n    else\n      is_valid_email = .false.\n    end if\n  end function is_valid_email\n\nend module email_validation\n```"
  },
  {
    "task": "Create a function that returns the decimal equivalent of a hexadecimal string.",
    "code": "```fortran\nprogram hex_to_decimal\n    implicit none\n    character(len=*) :: hex_string\n    integer :: decimal_value\n\n    print *, 'Enter a hexadecimal string:'\n    read *, hex_string\n    decimal_value = hex_to_decimal(hex_string)\n    print *, 'Decimal equivalent:', decimal_value\n\ncontains\n\n    integer function hex_to_decimal(hex_str)\n        character(len=*), intent(in) :: hex_str\n        integer :: i, len_hex, value\n        character :: c\n\n        hex_to_decimal = 0\n        len_hex = len(trim(hex_str))\n\n        do i = 1, len_hex\n            c = hex_str(i:i)\n            select case (c)\n                case ('0':'9')\n                    value = ichar(c) - ichar('0')\n                case ('A':'F')\n                    value = ichar(c) - ichar('A') + 10\n                case ('a':'f')\n                    value = ichar(c) - ichar('a') + 10\n                case default\n                    print *, 'Invalid hexadecimal character:', c\n                    stop\n            end select\n            hex_to_decimal = hex_to_decimal * 16 + value\n        end do\n    end function hex_to_decimal\n\nend program hex_to_decimal\n```"
  },
  {
    "task": "Design a function that calculates and returns the body mass index based on height and weight.",
    "code": "```fortran\nprogram bmi_calculator\n  implicit none\n  real :: height, weight, bmi\n\n  print *, \"Enter height in meters:\"\n  read *, height\n  print *, \"Enter weight in kilograms:\"\n  read *, weight\n\n  bmi = calculate_bmi(height, weight)\n  print *, \"The Body Mass Index (BMI) is: \", bmi\n\ncontains\n\n  function calculate_bmi(h, w) result(bmi)\n    real :: h, w\n    real :: bmi\n\n    bmi = w / (h * h)\n  end function calculate_bmi\n\nend program bmi_calculator\n```"
  },
  {
    "task": "Implement a function that returns the initials of a person's name given a full name.",
    "code": "```fortran\nprogram initials_program\n    implicit none\n    character(len=100) :: full_name\n    character(len=10) :: person_initials\n\n    print *, 'Enter full name:'\n    read(*,'(A)') full_name\n\n    person_initials = get_initials(full_name)\n\n    print *, 'Initials:', trim(person_initials)\ncontains\n    function get_initials(name) result(initials)\n        character(len=*), intent(in) :: name\n        character(len=10) :: initials\n        integer :: i, j\n        \n        initials = ''\n        j = 1\n        do i = 1, len(name)\n            if (i == 1 .or. name(i-1:i-1) == ' ') then\n                if (name(i:i) /= ' ') then\n                    initials(j:j) = name(i:i)\n                    j = j + 1\n                end if\n            end if\n        end do\n    end function get_initials\nend program initials_program\n```"
  },
  {
    "task": "Write a function that accepts a list of names and returns them sorted alphabetically.",
    "code": "```fortran\nmodule sort_module\ncontains\n    function sort_names(names) result(sorted_names)\n        character(len=100), dimension(:), intent(in) :: names\n        character(len=100), dimension(size(names)) :: sorted_names\n        sorted_names = names\n        call sort(sorted_names)\n    end function sort_names\n\n    subroutine sort(array)\n        character(len=100), dimension(:), intent(inout) :: array\n        integer :: i, j\n        character(len=100) :: temp\n        do i = 1, size(array)-1\n            do j = i+1, size(array)\n                if (array(i) > array(j)) then\n                    temp = array(i)\n                    array(i) = array(j)\n                    array(j) = temp\n                end if\n            end do\n        end do\n    end subroutine sort\nend module sort_module\n```"
  },
  {
    "task": "Create a function that takes a list of integers and returns a list of their squares.",
    "code": "```fortran\nmodule square_module\ncontains\n    function square_list(integers) result(squares)\n        integer, dimension(:), intent(in) :: integers\n        integer, dimension(size(integers)) :: squares\n        integer :: i\n\n        do i = 1, size(integers)\n            squares(i) = integers(i) * integers(i)\n        end do\n    end function square_list\nend module square_module\n```"
  },
  {
    "task": "Develop a function that returns the common elements between two sets.",
    "code": "```fortran\nmodule set_operations\n  implicit none\ncontains\n  function common_elements(set1, set2) result(common_set)\n    integer, intent(in) :: set1(:), set2(:)\n    integer, allocatable :: common_set(:)\n    integer :: i, j, count\n\n    count = 0\n    allocate(common_set(min(size(set1), size(set2))))\n\n    do i = 1, size(set1)\n      do j = 1, size(set2)\n        if (set1(i) == set2(j)) then\n          count = count + 1\n          common_set(count) = set1(i)\n          exit\n        end if\n      end do\n    end do\n\n    if (count > 0) then\n      common_set = common_set(:count)\n    else\n      deallocate(common_set)\n      allocate(common_set(0))\n    end if\n  end function common_elements\nend module set_operations\n```"
  },
  {
    "task": "Implement a function that receives a list of strings and returns the shortest string.",
    "code": "```fortran\nmodule string_utils\n  implicit none\ncontains\n  function shortest_string(strings) result(shortest)\n    character(len=*), dimension(:), intent(in) :: strings\n    character(len=:), allocatable :: shortest\n    integer :: i\n\n    if (size(strings) == 0) then\n      shortest = ''\n      return\n    end if\n\n    shortest = strings(1)\n    do i = 2, size(strings)\n      if (len_trim(strings(i)) < len_trim(shortest)) then\n        shortest = strings(i)\n      end if\n    end do\n  end function shortest_string\nend module string_utils\n```"
  },
  {
    "task": "Write a function that returns the sum of digits of a given integer.",
    "code": "```fortran\nprogram sum_of_digits\n    implicit none\n    integer :: number, result\n\n    print *, \"Enter an integer:\"\n    read *, number\n\n    result = sumDigits(number)\n    print *, \"The sum of the digits is:\", result\nend program sum_of_digits\n\ninteger function sumDigits(n)\n    implicit none\n    integer, intent(in) :: n\n    integer :: temp, digit\n\n    temp = abs(n)\n    sumDigits = 0\n\n    do while (temp /= 0)\n        digit = mod(temp, 10)\n        sumDigits = sumDigits + digit\n        temp = temp / 10\n    end do\nend function sumDigits\n```"
  },
  {
    "task": "Create a function that takes a matrix and returns its transpose.",
    "code": "```fortran\nfunction transposeMatrix(matrix) result(transposed)\n  real, dimension(:,:), intent(in) :: matrix\n  real, dimension(size(matrix, 2), size(matrix, 1)) :: transposed\n  integer :: i, j\n\n  do i = 1, size(matrix, 1)\n     do j = 1, size(matrix, 2)\n        transposed(j, i) = matrix(i, j)\n     end do\n  end do\nend function transposeMatrix\n```"
  },
  {
    "task": "Design a function that returns the percentage of uppercase letters in a string.",
    "code": "```fortran\nmodule string_utils\n  implicit none\ncontains\n  function percentage_uppercase(s) result(percent)\n    character(len=*), intent(in) :: s\n    real :: percent\n    integer :: i, n_upper, len_s\n\n    len_s = len(s)\n    n_upper = 0\n\n    do i = 1, len_s\n      if (iachar(s(i:i)) >= iachar('A') .and. iachar(s(i:i)) <= iachar('Z')) then\n        n_upper = n_upper + 1\n      end if\n    end do\n\n    if (len_s > 0) then\n      percent = 100.0 * n_upper / len_s\n    else\n      percent = 0.0\n    end if\n  end function percentage_uppercase\nend module string_utils\n```"
  },
  {
    "task": "Implement a function that accepts a string and returns it with each word capitalized.",
    "code": "```fortran\nmodule string_utils\n  implicit none\ncontains\n  function capitalize_words(input_string) result(output_string)\n    character(len=*), intent(in) :: input_string\n    character(len=len(input_string)) :: output_string\n    integer :: i, n, start\n    logical :: capitalize\n\n    output_string = input_string\n    n = len_trim(input_string)\n    capitalize = .true.\n    do i = 1, n\n      if (capitalize .and. output_string(i:i) /= ' ') then\n        output_string(i:i) = char(iachar(output_string(i:i)) - 32 * &\n                                  merge(1, 0, iachar(output_string(i:i)) >= 97 .and. &\n                                        iachar(output_string(i:i)) <= 122))\n        capitalize = .false.\n      else if (output_string(i:i) == ' ') then\n        capitalize = .true.\n      end if\n    end do\n  end function capitalize_words\nend module string_utils\n```"
  },
  {
    "task": "Write a function that takes a list and returns the difference between the max and min values.",
    "code": "```fortran\nprogram main\n    implicit none\n    real :: result\n    real, dimension(5) :: numbers = [3.5, 6.2, 9.8, 1.4, 7.1]\n\n    result = max_min_difference(numbers)\n    print *, \"Difference between max and min:\", result\n\ncontains\n\n    real function max_min_difference(arr)\n        real, dimension(:), intent(in) :: arr\n        real :: max_val, min_val\n\n        max_val = maxval(arr)\n        min_val = minval(arr)\n        max_min_difference = max_val - min_val\n    end function max_min_difference\n\nend program main\n```"
  },
  {
    "task": "Create a function that returns a list containing the first n prime numbers.",
    "code": "```fortran\nmodule prime_module\n  implicit none\ncontains\n  logical function is_prime(num)\n    integer, intent(in) :: num\n    integer :: i\n    if (num <= 1) then\n      is_prime = .false.\n      return\n    end if\n    do i = 2, int(sqrt(real(num)))\n      if (mod(num, i) == 0) then\n        is_prime = .false.\n        return\n      end if\n    end do\n    is_prime = .true.\n  end function is_prime\n\n  function first_n_primes(n) result(primes)\n    integer, intent(in) :: n\n    integer :: primes(n)\n    integer :: count, num\n    count = 0\n    num = 2\n    do while (count < n)\n      if (is_prime(num)) then\n        count = count + 1\n        primes(count) = num\n      end if\n      num = num + 1\n    end do\n  end function first_n_primes\nend module prime_module\n```"
  },
  {
    "task": "Develop a function that receives a dictionary and returns a new dictionary with keys and values swapped.",
    "code": "```fortran\nmodule dictionary_utils\n    implicit none\ncontains\n    function swap_keys_values(dict) result(swapped_dict)\n        integer, parameter :: max_size = 100\n        character(len=100), dimension(:), allocatable :: dict_keys, dict_values\n        character(len=100), dimension(max_size) :: swapped_keys, swapped_values\n        integer :: i, num_elements\n        type :: dictionary\n            character(len=100), dimension(max_size) :: keys\n            character(len=100), dimension(max_size) :: values\n            integer :: count\n        end type dictionary\n        type(dictionary), intent(in) :: dict\n        type(dictionary) :: swapped_dict\n\n        allocate(dict_keys(dict%count))\n        allocate(dict_values(dict%count))\n\n        dict_keys = dict%keys(1:dict%count)\n        dict_values = dict%values(1:dict%count)\n\n        num_elements = min(size(dict_keys), size(dict_values))\n\n        do i = 1, num_elements\n            swapped_keys(i) = dict_values(i)\n            swapped_values(i) = dict_keys(i)\n        end do\n\n        swapped_dict%keys = swapped_keys\n        swapped_dict%values = swapped_values\n        swapped_dict%count = num_elements\n    end function swap_keys_values\nend module dictionary_utils\n```"
  },
  {
    "task": "Implement a function that accepts a string and returns the frequency of each word.",
    "code": "```fortran\nmodule word_frequency_module\n  implicit none\ncontains\n\n  function word_frequency(text) result(freq)\n    character(len=*), intent(in) :: text\n    type(word_freq), allocatable :: freq(:)\n    character(len=32) :: words(:)\n    integer :: i, j, count, num_words\n    type(word_freq)\n      character(len=32) :: word\n      integer :: frequency\n    end type word_freq\n\n    call split_text(text, words, num_words)\n    allocate(freq(num_words))\n    freq(:) = word_freq(\"\", 0)\n\n    do i = 1, num_words\n      if (freq(i)%frequency == 0) then\n        count = 0\n        do j = i, num_words\n          if (trim(words(i)) == trim(words(j))) then\n            count = count + 1\n          end if\n        end do\n        freq(i)%word = trim(words(i))\n        freq(i)%frequency = count\n      end if\n    end do\n\n    freq = [freq(j), j=1, num_words, freq(j)%frequency > 0]\n  end function word_frequency\n\n  subroutine split_text(text, words, num_words)\n    character(len=*), intent(in) :: text\n    character(len=32), allocatable :: words(:)\n    integer, intent(out) :: num_words\n    character(len=len(text)) :: temp_text\n    integer :: i, n\n\n    temp_text = adjustl(text)\n    num_words = 0\n\n    do\n      i = index(temp_text, ' ')\n      if (i == 0) exit\n      num_words = num_words + 1\n      allocate(words(num_words))\n      words(num_words) = trim(adjustl(temp_text(1:i-1)))\n      temp_text = adjustl(temp_text(i+1:))\n    end do\n\n    if (len(trim(temp_text)) > 0) then\n      num_words = num_words + 1\n      allocate(words(num_words))\n      words(num_words) = trim(temp_text)\n    end if\n  end subroutine split_text\n\nend module word_frequency_module\n```"
  },
  {
    "task": "Write a function that takes two numbers and returns their greatest common divisor.",
    "code": "```fortran\nFUNCTION gcd(a, b) RESULT(g)\n    INTEGER, INTENT(IN) :: a, b\n    INTEGER :: g\n    INTEGER :: x, y, temp\n\n    x = a\n    y = b\n\n    DO WHILE (y /= 0)\n        temp = x\n        x = y\n        y = MOD(temp, y)\n    END DO\n\n    g = x\nEND FUNCTION gcd\n```"
  },
  {
    "task": "Create a function that returns the number of consonants in a given string.",
    "code": "```fortran\nprogram count_consonants\n    implicit none\n    character(len=100) :: input_string\n    integer :: num_consonants\n\n    print *, \"Enter a string:\"\n    read(*, '(A)') input_string\n\n    num_consonants = countConsonants(input_string)\n    print *, \"Number of consonants:\", num_consonants\n\ncontains\n\n    function countConsonants(s) result(count)\n        character(len=*), intent(in) :: s\n        integer :: count\n        integer :: i\n        character(len=1) :: c\n        count = 0\n        do i = 1, len_trim(s)\n            c = s(i:i)\n            if (index('bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ', c) > 0) then\n                count = count + 1\n            end if\n        end do\n    end function countConsonants\n\nend program count_consonants\n```"
  },
  {
    "task": "Design a function that checks if a number is a perfect square and returns a boolean.",
    "code": "```fortran\nmodule math_utils\n  implicit none\ncontains\n  logical function is_perfect_square(n)\n    integer, intent(in) :: n\n    integer :: sqrt_n\n    sqrt_n = int(sqrt(real(n)))\n    is_perfect_square = (sqrt_n * sqrt_n == n)\n  end function is_perfect_square\nend module math_utils\n```"
  },
  {
    "task": "Implement a function that takes a list of numbers and returns the mode.",
    "code": "```fortran\nmodule statistics\n  implicit none\ncontains\n  function mode(numbers) result(mode_value)\n    integer, dimension(:), intent(in) :: numbers\n    integer :: mode_value\n    integer :: i, max_freq, freq, num\n\n    max_freq = 0\n    mode_value = numbers(1)\n    \n    do i = 1, size(numbers)\n      num = numbers(i)\n      freq = count(numbers == num)\n      if (freq > max_freq) then\n        max_freq = freq\n        mode_value = num\n      end if\n    end do\n  end function mode\nend module statistics\n```"
  },
  {
    "task": "Write a function that accepts a string and returns a new string with characters in reverse order.",
    "code": "```fortran\nprogram reverse_string\n    implicit none\n    character(len=:), allocatable :: inputStr, reversedStr\n\n    ! Example usage\n    inputStr = \"Hello, World!\"\n    reversedStr = reverse(inputStr)\n    print *, reversedStr\n\ncontains\n\n    function reverse(str) result(reversed)\n        character(len=*), intent(in) :: str\n        character(len=len(str)) :: reversed\n        integer :: i\n\n        do i = 1, len(str)\n            reversed(i:i) = str(len(str)-i+1:len(str)-i+1)\n        end do\n    end function reverse\n\nend program reverse_string\n```"
  },
  {
    "task": "Create a function that returns the sum of all even numbers in a list.",
    "code": "```fortran\nfunction sum_even_numbers(arr) result(sum_even)\n    integer, intent(in) :: arr(:)\n    integer :: sum_even\n    integer :: i\n\n    sum_even = 0\n    do i = 1, size(arr)\n        if (mod(arr(i), 2) == 0) then\n            sum_even = sum_even + arr(i)\n        end if\n    end do\nend function\n```"
  },
  {
    "task": "Develop a function that receives two lists and returns their union.",
    "code": "```fortran\nmodule list_operations\n  implicit none\ncontains\n  function union_lists(list1, list2) result(union_list)\n    integer, dimension(:), intent(in) :: list1, list2\n    integer, dimension(:), allocatable :: union_list\n    integer, dimension(:), allocatable :: temp_list\n    integer :: i, j, n, m, union_size\n\n    n = size(list1)\n    m = size(list2)\n    allocate(temp_list(n + m))\n    union_size = 0\n\n    do i = 1, n\n      if (.not. any(temp_list(1:union_size) == list1(i))) then\n        union_size = union_size + 1\n        temp_list(union_size) = list1(i)\n      end if\n    end do\n\n    do j = 1, m\n      if (.not. any(temp_list(1:union_size) == list2(j))) then\n        union_size = union_size + 1\n        temp_list(union_size) = list2(j)\n      end if\n    end do\n\n    allocate(union_list(union_size))\n    union_list = temp_list(1:union_size)\n\n    deallocate(temp_list)\n  end function union_lists\nend module list_operations\n```"
  },
  {
    "task": "Implement a function that takes a string and returns the number of unique characters.",
    "code": "```fortran\nmodule unique_char_module\n  implicit none\ncontains\n  integer function count_unique_characters(input_string) result(unique_count)\n    character(len=*), intent(in) :: input_string\n    character(len=1) :: char\n    integer :: i\n    logical :: char_seen(256)\n    \n    unique_count = 0\n    char_seen = .false.\n\n    do i = 1, len_trim(input_string)\n      char = input_string(i:i)\n      if (.not. char_seen(iachar(char))) then\n        char_seen(iachar(char)) = .true.\n        unique_count = unique_count + 1\n      end if\n    end do\n  end function count_unique_characters\nend module unique_char_module\n```"
  },
  {
    "task": "Write a function that returns the cube of a given number.",
    "code": "```fortran\nprogram cube_program\n    implicit none\n    real :: number, result\n\n    number = 3.0\n    result = cube(number)\n    print *, \"The cube of\", number, \"is\", result\n\ncontains\n\n    real function cube(x)\n        real, intent(in) :: x\n        cube = x**3\n    end function cube\n\nend program cube_program\n```"
  },
  {
    "task": "Create a function that calculates the power of a number given a base and exponent and returns the result.",
    "code": "```fortran\nmodule math_operations\ncontains\n    real function power(base, exponent)\n        real, intent(in) :: base\n        integer, intent(in) :: exponent\n        integer :: i\n\n        power = 1.0\n        do i = 1, exponent\n            power = power * base\n        end do\n    end function power\nend module math_operations\n```"
  },
  {
    "task": "Design a function that accepts a URL and returns its domain name.",
    "code": "```fortran\nmodule domain_module\ncontains\n    function get_domain(url) result(domain)\n        implicit none\n        character(len=*), intent(in) :: url\n        character(len=128) :: domain\n        integer :: start, finish\n\n        start = index(url, \"//\") + 2\n        if (start == 2) start = 1\n        finish = index(url(start:), \"/\") \n        if (finish == 0) then\n            domain = url(start:)\n        else\n            domain = url(start:start + finish - 2)\n        end if\n    end function get_domain\nend module domain_module\n```"
  },
  {
    "task": "Implement a function that takes a sentence and returns it with each letter shifted by one in the alphabet.",
    "code": "```fortran\nmodule string_utils\ncontains\n    function shift_sentence(sentence) result(shifted_sentence)\n        character(len=*), intent(in) :: sentence\n        character(len=len(sentence)) :: shifted_sentence\n        integer :: i\n\n        do i = 1, len(sentence)\n            select case (sentence(i:i))\n            case ('A':'Y', 'a':'y')\n                shifted_sentence(i:i) = char(iachar(sentence(i:i)) + 1)\n            case ('Z')\n                shifted_sentence(i:i) = 'A'\n            case ('z')\n                shifted_sentence(i:i) = 'a'\n            case default\n                shifted_sentence(i:i) = sentence(i:i)\n            end select\n        end do\n    end function shift_sentence\nend module string_utils\n```"
  },
  {
    "task": "Write a function that checks if a list is sorted and returns a boolean.",
    "code": "```fortran\nmodule sorting_module\n  implicit none\ncontains\n  logical function is_sorted(arr)\n    integer, dimension(:), intent(in) :: arr\n    integer :: i\n    is_sorted = .true.\n    do i = 1, size(arr) - 1\n      if (arr(i) > arr(i+1)) then\n        is_sorted = .false.\n        return\n      end if\n    end do\n  end function is_sorted\nend module sorting_module\n```"
  },
  {
    "task": "Create a function that returns the longest increasing subsequence in a list of numbers.",
    "code": "```fortran\nmodule lis_module\ncontains\n    integer function lis(arr, n, result)\n        integer, intent(in) :: n\n        integer, dimension(n), intent(in) :: arr\n        integer, dimension(:), allocatable, intent(out) :: result\n        integer, allocatable :: lis_lengths(:), prev_indices(:)\n        integer :: i, j, max_len, max_index\n\n        allocate(lis_lengths(n))\n        allocate(prev_indices(n))\n        \n        lis_lengths = 1\n        prev_indices = -1\n\n        do i = 2, n\n            do j = 1, i - 1\n                if (arr(i) > arr(j) .and. lis_lengths(i) < lis_lengths(j) + 1) then\n                    lis_lengths(i) = lis_lengths(j) + 1\n                    prev_indices(i) = j\n                end if\n            end do\n        end do\n\n        max_len = maxval(lis_lengths)\n        max_index = maxloc(lis_lengths, kind=kind(max_len))(1)\n        \n        allocate(result(max_len))\n        \n        do i = max_len, 1, -1\n            result(i) = arr(max_index)\n            max_index = prev_indices(max_index)\n        end do\n\n        lis = max_len\n    end function lis\nend module lis_module\n```"
  },
  {
    "task": "Develop a function that calculates and returns the compound interest for given principal, rate, and time.",
    "code": "```fortran\nmodule interest_module\ncontains\n    real function calculate_compound_interest(principal, rate, time)\n        real, intent(in) :: principal, rate, time\n        calculate_compound_interest = principal * (1.0 + rate)**time\n    end function calculate_compound_interest\nend module interest_module\n\nprogram main\n    use interest_module\n    real :: principal, rate, time, interest\n\n    ! Example values\n    principal = 1000.0\n    rate = 0.05\n    time = 10.0\n\n    interest = calculate_compound_interest(principal, rate, time)\n    print *, 'The compound interest is: ', interest\nend program main\n```"
  },
  {
    "task": "Implement a function that accepts two strings and returns their longest common substring.",
    "code": "```fortran\nprogram longest_common_substring\n    implicit none\n    character(len=*), parameter :: str1 = \"FortranCode\"\n    character(len=*), parameter :: str2 = \"CodeFortran\"\n    character(len=:), allocatable :: result\n\n    result = longest_common_substring(str1, str2)\n    print *, \"Longest common substring: \", result\n\ncontains\n\n    function longest_common_substring(s1, s2) result(longest_substring)\n        character(len=*), intent(in) :: s1, s2\n        character(len=:), allocatable :: longest_substring\n        integer :: len1, len2, i, j, k, max_len = 0, start = 0\n        integer, allocatable :: lcs(:,:)\n\n        len1 = len(s1)\n        len2 = len(s2)\n        allocate(lcs(len1+1, len2+1))\n        lcs = 0\n\n        do i = 1, len1\n            do j = 1, len2\n                if (s1(i:i) == s2(j:j)) then\n                    lcs(i, j) = lcs(i-1, j-1) + 1\n                    if (lcs(i, j) > max_len) then\n                        max_len = lcs(i, j)\n                        start = i - max_len + 1\n                    end if\n                end if\n            end do\n        end do\n\n        if (max_len > 0) then\n            allocate(character(len=max_len) :: longest_substring)\n            longest_substring = s1(start:start+max_len-1)\n        else\n            allocate(character(len=0) :: longest_substring)\n        end if\n\n        deallocate(lcs)\n    end function longest_common_substring\n\nend program longest_common_substring\n```"
  },
  {
    "task": "Write a function that takes a number and returns true if it is a palindrome.",
    "code": "```fortran\nprogram palindrome_check\n  implicit none\n  integer :: n\n  logical :: result\n\n  n = 12321\n  result = is_palindrome(n)\n  print *, \"Is the number a palindrome? \", result\n\ncontains\n\n  logical function is_palindrome(num)\n    integer, intent(in) :: num\n    integer :: reverse, original, remainder\n\n    original = num\n    reverse = 0\n\n    do while (num /= 0)\n      remainder = mod(num, 10)\n      reverse = reverse * 10 + remainder\n      num = num / 10\n    end do\n\n    is_palindrome = (original == reverse)\n  end function is_palindrome\n\nend program palindrome_check\n```"
  },
  {
    "task": "Create a function that returns the average length of words in a given sentence.",
    "code": "```fortran\nprogram average_word_length\n    implicit none\n    character(len=100) :: sentence\n    real :: avg_length\n\n    print *, \"Enter a sentence:\"\n    read(*,'(A)') sentence\n\n    avg_length = average_length(sentence)\n    print *, \"Average word length:\", avg_length\n\ncontains\n\n    function average_length(sentence) result(avg)\n        character(len=*), intent(in) :: sentence\n        real :: avg\n        integer :: i, num_words, total_length\n        integer :: word_length\n        logical :: in_word\n\n        num_words = 0\n        total_length = 0\n        word_length = 0\n        in_word = .false.\n\n        do i = 1, len_trim(sentence)\n            if (sentence(i:i) /= ' ') then\n                word_length = word_length + 1\n                if (.not. in_word) then\n                    num_words = num_words + 1\n                    in_word = .true.\n                end if\n            else if (in_word) then\n                total_length = total_length + word_length\n                word_length = 0\n                in_word = .false.\n            end if\n        end do\n\n        if (in_word) then\n            total_length = total_length + word_length\n        end if\n\n        if (num_words > 0) then\n            avg = real(total_length) / num_words\n        else\n            avg = 0.0\n        end if\n\n    end function average_length\n\nend program average_word_length\n```"
  },
  {
    "task": "Design a function that checks if a string contains only digits and returns a boolean.",
    "code": "```fortran\nprogram Main\n    implicit none\n    logical :: result\n    result = is_digits(\"12345\")\n    print *, result\n    result = is_digits(\"123a5\")\n    print *, result\ncontains\n    logical function is_digits(s)\n        character(len=*), intent(in) :: s\n        integer :: i\n        do i = 1, len(s)\n            if (.not. (s(i:i) >= '0' .and. s(i:i) <= '9')) then\n                is_digits = .false.\n                return\n            end if\n        end do\n        is_digits = .true.\n    end function is_digits\nend program Main\n```"
  },
  {
    "task": "Implement a function that receives a list of tuples and returns a list of the first elements.",
    "code": "```fortran\nmodule tuple_module\n  implicit none\ncontains\n\n  function get_first_elements(tuples) result(first_elements)\n    integer, parameter :: tuple_size = 2\n    integer, dimension(:,:), intent(in) :: tuples\n    integer, dimension(size(tuples, 1)) :: first_elements\n    integer :: i\n\n    do i = 1, size(tuples, 1)\n      first_elements(i) = tuples(i, 1)\n    end do\n  end function get_first_elements\n\nend module tuple_module\n```"
  },
  {
    "task": "Write a function that takes a year and returns the Chinese zodiac sign for that year.",
    "code": "```fortran\nmodule zodiac_module\n  implicit none\ncontains\n  function chinese_zodiac(year) result(zodiac_sign)\n    integer, intent(in) :: year\n    character(len=10) :: zodiac_sign\n    character(len=10), dimension(12) :: zodiac_signs\n    integer :: index\n\n    zodiac_signs = (/ \"Monkey\", \"Rooster\", \"Dog\", \"Pig\", \"Rat\", \"Ox\", &\n                      \"Tiger\", \"Rabbit\", \"Dragon\", \"Snake\", \"Horse\", &\n                      \"Goat\" /)\n\n    index = mod(year - 4, 12) + 1\n    zodiac_sign = zodiac_signs(index)\n  end function chinese_zodiac\nend module zodiac_module\n```"
  },
  {
    "task": "Create a function that returns the number of trailing zeros in a factorial of a given number.",
    "code": "```fortran\nprogram trailing_zeros\n    implicit none\n    integer :: n, result\n\n    print *, \"Enter a number:\"\n    read *, n\n    result = count_trailing_zeros(n)\n    print *, \"Number of trailing zeros in factorial:\", result\n\ncontains\n\n    integer function count_trailing_zeros(n)\n        integer, intent(in) :: n\n        integer :: count, temp\n\n        count = 0\n        temp = n\n        do while (temp >= 5)\n            temp = temp / 5\n            count = count + temp\n        end do\n        count_trailing_zeros = count\n    end function count_trailing_zeros\n\nend program trailing_zeros\n```"
  },
  {
    "task": "Develop a function that accepts a list and returns a new list with elements multiplied by their index.",
    "code": "```fortran\nprogram main\n    implicit none\n    integer, allocatable :: input_list(:), output_list(:)\n    integer :: i, n\n\n    ! Example input\n    n = 5\n    allocate(input_list(n))\n    input_list = [1, 2, 3, 4, 5]\n\n    output_list = multiply_by_index(input_list)\n\n    print *, 'Output List: ', output_list\n\ncontains\n\n    function multiply_by_index(list) result(new_list)\n        integer, intent(in) :: list(:)\n        integer, allocatable :: new_list(:)\n        integer :: i, n\n\n        n = size(list)\n        allocate(new_list(n))\n        do i = 1, n\n            new_list(i) = list(i) * (i - 1)\n        end do\n    end function multiply_by_index\n\nend program main\n```"
  },
  {
    "task": "Implement a function that receives a string and returns a dictionary of word lengths.",
    "code": "```fortran\nmodule string_utils\n    implicit none\ncontains\n\n    function word_lengths(text) result(dictionary)\n        character(len=*), intent(in) :: text\n        type(dictionary_type) :: dictionary\n        integer :: i, word_len\n        character(len=256) :: word\n        character(len=:), allocatable :: word_list(:)\n        integer, allocatable :: lengths(:)\n        \n        dictionary%words = \"\"\n        dictionary%lengths = 0\n\n        call split_string(text, word_list)\n\n        allocate(lengths(size(word_list)))\n        \n        do i = 1, size(word_list)\n            word = word_list(i)\n            word_len = len(trim(adjustl(word)))\n            lengths(i) = word_len\n        end do\n\n        dictionary%words = word_list\n        dictionary%lengths = lengths\n\n    end function word_lengths\n\n    subroutine split_string(text, word_list)\n        character(len=*), intent(in) :: text\n        character(len=:), allocatable :: word_list(:)\n        character(len=256) :: word\n        integer :: i, j, start, num_words\n\n        num_words = 0\n        start = 1\n        do i = 1, len(text)\n            if (text(i:i) == ' ' .or. i == len(text)) then\n                if (i == len(text) .and. text(i:i) /= ' ') then\n                    word = text(start:i)\n                else\n                    word = text(start:i-1)\n                end if\n                if (len(trim(word)) > 0) then\n                    num_words = num_words + 1\n                end if\n                start = i + 1\n            end if\n        end do\n\n        allocate(word_list(num_words))\n        start = 1\n        j = 1\n        do i = 1, len(text)\n            if (text(i:i) == ' ' .or. i == len(text)) then\n                if (i == len(text) .and. text(i:i) /= ' ') then\n                    word = text(start:i)\n                else\n                    word = text(start:i-1)\n                end if\n                if (len(trim(word)) > 0) then\n                    word_list(j) = trim(adjustl(word))\n                    j = j + 1\n                end if\n                start = i + 1\n            end if\n        end do\n\n    end subroutine split_string\n\n    type dictionary_type\n        character(len=:), allocatable :: words(:)\n        integer, allocatable :: lengths(:)\n    end type dictionary_type\n\nend module string_utils\n```"
  },
  {
    "task": "Write a function that takes a list of integers and returns a list of numbers that are divisible by 3.",
    "code": "```fortran\nmodule divisible_by_three\n  implicit none\ncontains\n  function filter_divisible_by_three(numbers) result(divisible_numbers)\n    integer, intent(in) :: numbers(:)\n    integer, allocatable :: divisible_numbers(:)\n    integer :: i, count\n\n    count = 0\n    do i = 1, size(numbers)\n      if (mod(numbers(i), 3) == 0) then\n        count = count + 1\n      end if\n    end do\n\n    allocate(divisible_numbers(count))\n    count = 0\n    do i = 1, size(numbers)\n      if (mod(numbers(i), 3) == 0) then\n        count = count + 1\n        divisible_numbers(count) = numbers(i)\n      end if\n    end do\n  end function filter_divisible_by_three\nend module divisible_by_three\n```"
  },
  {
    "task": "Create a function that returns the result of a quadratic equation given its coefficients.",
    "code": "```fortran\nmodule quadratic_module\n  implicit none\ncontains\n  function quadratic_result(a, b, c, x) result(y)\n    real, intent(in) :: a, b, c, x\n    real :: y\n    y = a * x**2 + b * x + c\n  end function quadratic_result\nend module quadratic_module\n```"
  },
  {
    "task": "Design a function that checks if two lists have any elements in common and returns a boolean.",
    "code": "```fortran\nprogram check_common_elements\n    implicit none\n    logical :: result\n    integer, dimension(:), allocatable :: list1, list2\n\n    allocate(list1(3))\n    allocate(list2(3))\n    list1 = [1, 2, 3]\n    list2 = [4, 5, 6]\n\n    result = has_common_elements(list1, list2)\n    print *, result\nend program check_common_elements\n\nlogical function has_common_elements(list1, list2)\n    implicit none\n    integer, dimension(:), intent(in) :: list1, list2\n    integer :: i, j\n\n    has_common_elements = .false.\n    do i = 1, size(list1)\n        do j = 1, size(list2)\n            if (list1(i) == list2(j)) then\n                has_common_elements = .true.\n                return\n            end if\n        end do\n    end do\nend function has_common_elements\n```"
  },
  {
    "task": "Implement a function that accepts a list and returns the sum of its elements using recursion.",
    "code": "```fortran\nprogram sum_recursive\n    implicit none\n    integer :: n\n    integer, allocatable :: list(:)\n    integer :: sum\n\n    n = 5\n    allocate(list(n))\n    list = [1, 2, 3, 4, 5]\n\n    sum = recursive_sum(list, n)\n    print *, \"Sum of elements:\", sum\n\ncontains\n\n    recursive function recursive_sum(arr, size) result(res)\n        integer, intent(in) :: arr(:)\n        integer, intent(in) :: size\n        integer :: res\n\n        if (size == 0) then\n            res = 0\n        else\n            res = arr(size) + recursive_sum(arr, size - 1)\n        end if\n    end function recursive_sum\n\nend program sum_recursive\n```"
  },
  {
    "task": "Write a function that takes a list of numbers and returns the variance.",
    "code": "```fortran\nprogram variance_program\n    implicit none\n    real :: result\n    real, dimension(5) :: numbers = [1.0, 2.0, 3.0, 4.0, 5.0]\n    \n    result = calculate_variance(numbers)\n    print *, \"Variance:\", result\ncontains\n    real function calculate_variance(data)\n        real, dimension(:), intent(in) :: data\n        integer :: n, i\n        real :: mean, sum\n        \n        n = size(data)\n        mean = sum(data) / n\n        sum = 0.0\n        \n        do i = 1, n\n            sum = sum + (data(i) - mean)**2\n        end do\n        \n        calculate_variance = sum / n\n    end function calculate_variance\nend program variance_program\n```"
  },
  {
    "task": "Create a function that returns the ASCII value of a given character.",
    "code": "```fortran\nprogram ascii_value_program\n  implicit none\n  character(len=1) :: character_input\n  integer :: ascii_value\n\n  print *, \"Enter a character: \"\n  read *, character_input\n  ascii_value = get_ascii_value(character_input)\n  print *, \"The ASCII value is: \", ascii_value\n\ncontains\n\n  integer function get_ascii_value(char)\n    character(len=1), intent(in) :: char\n    get_ascii_value = ichar(char)\n  end function get_ascii_value\n\nend program ascii_value_program\n```"
  },
  {
    "task": "Develop a function that takes a number and returns the number of bits required for its binary representation.",
    "code": "```fortran\nprogram bit_count_program\n    implicit none\n    integer :: number, result\n\n    ! Example usage\n    number = 10\n    result = bits_required(number)\n    print *, \"Number of bits required for\", number, \"is\", result\n\ncontains\n\n    integer function bits_required(n)\n        integer, intent(in) :: n\n        integer :: count, x\n\n        if (n == 0) then\n            bits_required = 1\n            return\n        end if\n\n        x = n\n        count = 0\n        do while (x > 0)\n            x = x / 2\n            count = count + 1\n        end do\n\n        bits_required = count\n    end function bits_required\n\nend program bit_count_program\n```"
  }
]