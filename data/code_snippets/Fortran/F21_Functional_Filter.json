[
  {
    "task": "Filter out all even numbers from a list of integers.",
    "code": "```fortran\nprogram filter_even_numbers\n  implicit none\n  integer, allocatable :: numbers(:)\n  integer, allocatable :: filtered_numbers(:)\n  integer :: i, count\n\n  numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n  count = 0\n\n  filtered_numbers = pack(numbers, mod(numbers, 2) /= 0)\n\n  do i = 1, size(filtered_numbers)\n    print *, filtered_numbers(i)\n  end do\n\nend program filter_even_numbers\n```"
  },
  {
    "task": "Select all words from a list that start with the letter 'a'.",
    "code": "```fortran\nprogram filter_words\n    implicit none\n    character(len=100), dimension(:), allocatable :: words, filtered_words\n    integer :: i, n\n\n    ! Sample list of words\n    allocate(words(5))\n    words = ['apple', 'banana', 'apricot', 'cherry', 'avocado']\n    n = size(words)\n\n    allocate(filtered_words(n))\n    filtered_words = [words(i), i = 1, n, words(i)(1:1) == 'a']\n\n    ! Print filtered words\n    do i = 1, size(filtered_words)\n        if (len_trim(filtered_words(i)) > 0) then\n            print *, trim(filtered_words(i))\n        end if\n    end do\n\nend program filter_words\n```"
  },
  {
    "task": "Find all positive numbers in a collection of integers.",
    "code": "```fortran\nprogram filter_positive_numbers\n    implicit none\n    integer, dimension(:), allocatable :: numbers, positive_numbers\n    integer :: i, count\n\n    numbers = [5, -3, 8, -1, 0, 7, -6]\n    count = count(numbers > 0)\n    allocate(positive_numbers(count))\n\n    positive_numbers = pack(numbers, numbers > 0)\n\n    print *, \"Positive numbers:\", positive_numbers\nend program filter_positive_numbers\n```"
  },
  {
    "task": "Extract all employees who are older than 30 from an employee directory.",
    "code": "```fortran\nmodule employee_module\n    implicit none\n    type :: Employee\n        character(len=50) :: name\n        integer :: age\n    end type Employee\ncontains\n    function filter_employees(employees, num_employees) result(filtered_employees)\n        type(Employee), intent(in) :: employees(:)\n        integer, intent(in) :: num_employees\n        type(Employee), allocatable :: filtered_employees(:)\n        integer :: i, count\n\n        count = 0\n        do i = 1, num_employees\n            if (employees(i)%age > 30) then\n                count = count + 1\n            end if\n        end do\n\n        allocate(filtered_employees(count))\n        count = 0\n        do i = 1, num_employees\n            if (employees(i)%age > 30) then\n                count = count + 1\n                filtered_employees(count) = employees(i)\n            end if\n        end do\n    end function filter_employees\nend module employee_module\n```"
  },
  {
    "task": "List all cities with a population greater than one million from a dataset.",
    "code": "```fortran\nprogram filter_cities\n  implicit none\n  type :: City\n     character(len=50) :: name\n     integer :: population\n  end type City\n\n  type(City), dimension(:), allocatable :: cities, large_cities\n  integer :: i, num_large_cities\n\n  ! Sample data\n  allocate(cities(5))\n  cities(1) = City(\"CityA\", 500000)\n  cities(2) = City(\"CityB\", 1500000)\n  cities(3) = City(\"CityC\", 2000000)\n  cities(4) = City(\"CityD\", 800000)\n  cities(5) = City(\"CityE\", 1200000)\n\n  num_large_cities = count([(cities(i)%population, i=1, size(cities)) > 1000000])\n  allocate(large_cities(num_large_cities))\n  \n  large_cities = pack(cities, [(cities(i)%population, i=1, size(cities)) > 1000000])\n\n  do i=1, size(large_cities)\n     print*, trim(large_cities(i)%name)\n  end do\nend program filter_cities\n```"
  },
  {
    "task": "Filter out products that are out of stock from a product list.",
    "code": "```fortran\nmodule product_module\n    implicit none\n    type :: product\n        character(len=100) :: name\n        integer :: stock\n    end type product\ncontains\n    logical function is_in_stock(p)\n        type(product), intent(in) :: p\n        is_in_stock = p%stock > 0\n    end function is_in_stock\nend module product_module\n\nprogram filter_products\n    use product_module\n    implicit none\n    type(product), allocatable :: products(:)\n    type(product), allocatable :: in_stock_products(:)\n    integer :: i, count_in_stock\n\n    ! Sample product list\n    allocate(products(3))\n    products(1) = product('Product A', 0)\n    products(2) = product('Product B', 5)\n    products(3) = product('Product C', 0)\n\n    ! Count in-stock products\n    count_in_stock = count([is_in_stock(p) for p in products])\n\n    ! Filter in-stock products\n    allocate(in_stock_products(count_in_stock))\n    count_in_stock = 0\n    do i = 1, size(products)\n        if (is_in_stock(products(i))) then\n            count_in_stock = count_in_stock + 1\n            in_stock_products(count_in_stock) = products(i)\n        end if\n    end do\n\n    ! Output in-stock products (for demonstration purposes)\n    do i = 1, size(in_stock_products)\n        print *, 'In-stock product:', trim(in_stock_products(i)%name)\n    end do\nend program filter_products\n```"
  },
  {
    "task": "Select all students who have passed with a grade above 70 from a list of student scores.",
    "code": "```fortran\nprogram filter_students\n  implicit none\n  integer, parameter :: n = 10\n  integer :: i\n  real :: scores(n) = [85.0, 67.5, 90.0, 55.0, 75.0, 88.0, 45.0, 92.0, 60.0, 72.5]\n  real, allocatable :: passed_scores(:)\n\n  passed_scores = [scores(i), i = 1, n, scores(i) > 70.0]\n\n  print*, \"Students with grades above 70:\"\n  print*, passed_scores\nend program filter_students\n```"
  },
  {
    "task": "Identify all strings in an array that contain the substring 'cat'.",
    "code": "```fortran\nprogram filter_strings\n    implicit none\n    character(len=100), dimension(:), allocatable :: words, result\n    integer :: i, count, len\n    allocate(words(5))\n    words = [ \"concatenation\", \"dog\", \"catalog\", \"category\", \"rat\" ]\n    \n    count = 0\n    len = size(words)\n    allocate(result(len))\n    \n    do i = 1, len\n        if (index(words(i), \"cat\") /= 0) then\n            count = count + 1\n            result(count) = words(i)\n        end if\n    end do\n    \n    if (count > 0) then\n        print *, result(:count)\n    else\n        print *, \"No matches\"\n    end if\n    \n    deallocate(words, result)\nend program filter_strings\n```"
  },
  {
    "task": "Extract all transactions above $1000 from a financial record.",
    "code": "```fortran\nprogram filter_transactions\n    implicit none\n    real, dimension(:), allocatable :: transactions, filtered_transactions\n    integer :: i, n, count\n\n    ! Example transactions data\n    transactions = [450.0, 1250.0, 3000.0, 750.0, 1800.0, 500.0]\n    n = size(transactions)\n    count = 0\n\n    ! Count the number of transactions above $1000\n    do i = 1, n\n        if (transactions(i) > 1000.0) then\n            count = count + 1\n        end if\n    end do\n\n    ! Allocate memory for the filtered transactions\n    allocate(filtered_transactions(count))\n    count = 0\n\n    ! Store transactions above $1000 in the filtered array\n    do i = 1, n\n        if (transactions(i) > 1000.0) then\n            count = count + 1\n            filtered_transactions(count) = transactions(i)\n        end if\n    end do\n\n    ! Output the filtered transactions\n    do i = 1, count\n        print *, filtered_transactions(i)\n    end do\n\n    deallocate(filtered_transactions)\n\nend program filter_transactions\n```"
  },
  {
    "task": "Filter out all non-prime numbers from a list of numbers.",
    "code": "```fortran\nmodule prime_module\n  implicit none\ncontains\n  logical function is_prime(n)\n    integer, intent(in) :: n\n    integer :: i\n    if (n <= 1) then\n      is_prime = .false.\n      return\n    end if\n    do i = 2, int(sqrt(real(n)))\n      if (mod(n, i) == 0) then\n        is_prime = .false.\n        return\n      end if\n    end do\n    is_prime = .true.\n  end function is_prime\n\n  subroutine filter_primes(numbers, primes)\n    integer, intent(in) :: numbers(:)\n    integer, allocatable, intent(out) :: primes(:)\n    integer :: i, count\n\n    count = 0\n    do i = 1, size(numbers)\n      if (is_prime(numbers(i))) count = count + 1\n    end do\n\n    allocate(primes(count))\n    count = 0\n    do i = 1, size(numbers)\n      if (is_prime(numbers(i))) then\n        count = count + 1\n        primes(count) = numbers(i)\n      end if\n    end do\n  end subroutine filter_primes\nend module prime_module\n\nprogram main\n  use prime_module\n  implicit none\n  integer :: numbers(10) = [8, 9, 10, 11, 12, 13, 14, 15, 16, 17]\n  integer, allocatable :: primes(:)\n  integer :: i\n\n  call filter_primes(numbers, primes)\n  \n  print *, \"Primes are:\"\n  do i = 1, size(primes)\n    print *, primes(i)\n  end do\nend program main\n```"
  },
  {
    "task": "Select all books with more than 300 pages from a library catalog.",
    "code": "```fortran\nmodule library_module\n  implicit none\n  type :: Book\n     integer :: pages\n     character(len=100) :: title\n  end type Book\ncontains\n  logical function has_more_than_300_pages(book)\n    type(Book), intent(in) :: book\n    has_more_than_300_pages = book%pages > 300\n  end function has_more_than_300_pages\n\n  subroutine filter_books(library, filtered_books, num_filtered)\n    type(Book), intent(in) :: library(:)\n    type(Book), allocatable, intent(out) :: filtered_books(:)\n    integer, intent(out) :: num_filtered\n    integer :: i, count\n\n    count = count([has_more_than_300_pages(book) .and. allocated(library(i)) & \n                  , i = 1, size(library)])\n    allocate(filtered_books(count))\n    num_filtered = 0\n    do i = 1, size(library)\n       if (has_more_than_300_pages(library(i))) then\n          num_filtered = num_filtered + 1\n          filtered_books(num_filtered) = library(i)\n       end if\n    end do\n  end subroutine filter_books\nend module library_module\n```"
  },
  {
    "task": "Identify all users who have logged in within the past week from a user database.",
    "code": "```fortran\nmodule user_mod\n  implicit none\n  private\n  public :: user, filter_recent_logins\n\n  type :: user\n     character(len=50) :: username\n     character(len=10) :: last_login_date  ! Format: YYYY-MM-DD\n  end type user\n\ncontains\n\n  logical function is_recent_login(user)\n    type(user), intent(in) :: user\n    character(len=10) :: current_date\n    integer :: days_diff\n    call date_and_time(values=current_date)\n    days_diff = calculate_date_difference(trim(user%last_login_date), trim(current_date))\n    is_recent_login = (days_diff <= 7)\n  end function is_recent_login\n\n  integer function calculate_date_difference(date1, date2)\n    character(len=10), intent(in) :: date1, date2\n    integer :: y1, m1, d1, y2, m2, d2\n    y1 = read(date1(1:4))\n    m1 = read(date1(6:7))\n    d1 = read(date1(9:10))\n    y2 = read(date2(1:4))\n    m2 = read(date2(6:7))\n    d2 = read(date2(9:10))\n    calculate_date_difference = abs((y2 - y1) * 365 + (m2 - m1) * 30 + (d2 - d1))\n  end function calculate_date_difference\n\n  function filter_recent_logins(users) result(filtered_users)\n    type(user), intent(in) :: users(:)\n    type(user), allocatable :: filtered_users(:)\n    integer :: i, count\n    count = 0\n    do i = 1, size(users)\n      if (is_recent_login(users(i))) then\n        count = count + 1\n      end if\n    end do\n    allocate(filtered_users(count))\n    count = 0\n    do i = 1, size(users)\n      if (is_recent_login(users(i))) then\n        count = count + 1\n        filtered_users(count) = users(i)\n      end if\n    end do\n  end function filter_recent_logins\n\nend module user_mod\n\nprogram filter_users\n  use user_mod\n  implicit none\n  type(user), allocatable :: users(:), recent_users(:)\n  integer :: n\n\n  ! Initialize the user database\n  n = 5\n  allocate(users(n))\n  users(1) = user(\"Alice\", \"2023-10-01\")\n  users(2) = user(\"Bob\", \"2023-09-28\")\n  users(3) = user(\"Charlie\", \"2023-10-04\")\n  users(4) = user(\"David\", \"2023-09-25\")\n  users(5) = user(\"Eve\", \"2023-10-03\")\n\n  ! Filter users who have logged in within the past week\n  recent_users = filter_recent_logins(users)\n\n  ! Output the recent users\n  print *, \"Recent users:\"\n  do n = 1, size(recent_users)\n    print *, recent_users(n)%username\n  end do\n\nend program filter_users\n```"
  },
  {
    "task": "Extract all URLs that contain 'https' from a list of web addresses.",
    "code": "```fortran\nprogram filter_https_urls\n    implicit none\n    character(len=:), allocatable :: urls(:), https_urls(:)\n    integer :: i, count\n\n    urls = [ &\n        \"http://example.com\", &\n        \"https://secure.com\", &\n        \"ftp://ftp.example.com\", &\n        \"https://anothersecure.com\", &\n        \"http://insecure.com\" &\n    ]\n\n    https_urls = pack(urls, [index(url, \"https\") == 1 for url in urls])\n\n    count = size(https_urls)\n    do i = 1, count\n        print*, trim(https_urls(i))\n    end do\nend program filter_https_urls\n```"
  },
  {
    "task": "Find all movies released after the year 2000 from a movie database.",
    "code": "```fortran\nprogram filter_movies\n    implicit none\n    type :: Movie\n        character(len=100) :: title\n        integer :: release_year\n    end type Movie\n\n    type(Movie), allocatable :: movies(:)\n    type(Movie), allocatable :: filtered_movies(:)\n    integer :: i, count\n\n    ! Example initialization of movies array\n    allocate(movies(5))\n    movies(1) = Movie('Movie1', 1999)\n    movies(2) = Movie('Movie2', 2001)\n    movies(3) = Movie('Movie3', 2005)\n    movies(4) = Movie('Movie4', 1998)\n    movies(5) = Movie('Movie5', 2010)\n\n    call filter_movies_func(movies, filtered_movies, 2000)\n\n    ! Output filtered movies\n    do i = 1, size(filtered_movies)\n        print *, filtered_movies(i)%title\n    end do\n\ncontains\n\n    subroutine filter_movies_func(movies, result, year_threshold)\n        type(Movie), allocatable, intent(in) :: movies(:)\n        type(Movie), allocatable, intent(out) :: result(:)\n        integer, intent(in) :: year_threshold\n        integer :: i, count\n\n        count = 0\n        do i = 1, size(movies)\n            if (movies(i)%release_year > year_threshold) then\n                count = count + 1\n            end if\n        end do\n\n        allocate(result(count))\n        count = 0\n        do i = 1, size(movies)\n            if (movies(i)%release_year > year_threshold) then\n                count = count + 1\n                result(count) = movies(i)\n            end if\n        end do\n    end subroutine filter_movies_func\n\nend program filter_movies\n```"
  },
  {
    "task": "Select all tasks with a priority level of 'high' from a task management system.",
    "code": "```fortran\nprogram filter_high_priority_tasks\n  implicit none\n  type :: Task\n     character(len=100) :: name\n     character(len=10) :: priority\n  end type Task\n\n  type(Task), allocatable :: tasks(:), highPriorityTasks(:)\n  integer :: i, count\n\n  ! Assume tasks are initialized here\n  ! Example:\n  allocate(tasks(3))\n  tasks(1)%name = \"Task 1\"\n  tasks(1)%priority = \"high\"\n  tasks(2)%name = \"Task 2\"\n  tasks(2)%priority = \"medium\"\n  tasks(3)%name = \"Task 3\"\n  tasks(3)%priority = \"high\"\n\n  count = count([ (tasks(i)%priority == \"high\", i=1, size(tasks)) ])\n  allocate(highPriorityTasks(count))\n  count = 0\n\n  do i = 1, size(tasks)\n     if (tasks(i)%priority == \"high\") then\n        count = count + 1\n        highPriorityTasks(count) = tasks(i)\n     end if\n  end do\n\n  ! Print high priority tasks\n  do i = 1, size(highPriorityTasks)\n     print *, trim(highPriorityTasks(i)%name)\n  end do\n\nend program filter_high_priority_tasks\n```"
  },
  {
    "task": "Filter out all words longer than five characters from a text document.",
    "code": "```fortran\nprogram filter_words\n  implicit none\n  character(len=100), dimension(:), allocatable :: words, filtered_words\n  character(len=100) :: line\n  integer :: i, count\n\n  open(unit=10, file=\"input.txt\", status=\"old\")\n  open(unit=20, file=\"output.txt\", status=\"replace\")\n\n  count = 0\n  do\n    read(10, '(A)', iostat=i) line\n    if (i /= 0) exit\n    call split_line(line, words)\n    call filter_long_words(words, filtered_words)\n    call write_filtered_words(filtered_words, 20)\n  end do\n\n  close(10)\n  close(20)\ncontains\n\n  subroutine split_line(line, words)\n    character(len=100), intent(in) :: line\n    character(len=100), dimension(:), allocatable :: words\n    integer :: n, i\n\n    n = 0\n    allocate(words(100))\n    words = ''\n    do i = 1, len_trim(line)\n      if (line(i:i) == ' ') then\n        n = n + 1\n      else\n        words(n+1)(i:i) = line(i:i)\n      end if\n    end do\n    n = n + 1\n    allocate(words(n))\n    words = words(1:n)\n  end subroutine\n\n  subroutine filter_long_words(words, filtered_words)\n    character(len=100), dimension(:), intent(in) :: words\n    character(len=100), dimension(:), allocatable :: filtered_words\n    integer :: i, j\n\n    allocate(filtered_words(size(words)))\n    j = 0\n    do i = 1, size(words)\n      if (len_trim(words(i)) <= 5) then\n        j = j + 1\n        filtered_words(j) = words(i)\n      end if\n    end do\n    allocate(filtered_words(j))\n    filtered_words = filtered_words(1:j)\n  end subroutine\n\n  subroutine write_filtered_words(filtered_words, unit)\n    character(len=100), dimension(:), intent(in) :: filtered_words\n    integer, intent(in) :: unit\n    integer :: i\n\n    do i = 1, size(filtered_words)\n      write(unit, '(A)', advance='no') trim(filtered_words(i))\n      if (i < size(filtered_words)) write(unit, '(A)', advance='no') ' '\n    end do\n    write(unit, *)\n  end subroutine\n\nend program\n```"
  },
  {
    "task": "Extract all odd numbers from a sequence of integers.",
    "code": "```fortran\nprogram filter_odd_numbers\n    implicit none\n    integer, allocatable :: seq(:), odd_seq(:)\n    integer :: n, i, count\n\n    ! Example sequence, replace with any sequence of integers\n    seq = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n    n = size(seq)\n    count = count(mod(seq, 2) /= 0)\n\n    allocate(odd_seq(count))\n    odd_seq = pack(seq, mod(seq, 2) /= 0)\n\n    print *, odd_seq\nend program filter_odd_numbers\n```"
  },
  {
    "task": "Select all files larger than 10MB from a list of files.",
    "code": "```fortran\nprogram filter_large_files\n    implicit none\n    integer, parameter :: num_files = 5\n    character(len=100) :: file_names(num_files)\n    real :: file_sizes(num_files)\n    integer :: i\n\n    ! Example file names and sizes in MB\n    file_names = [character(len=100) :: 'file1.txt', 'file2.txt', 'file3.txt', 'file4.txt', 'file5.txt']\n    file_sizes = [5.0, 15.0, 8.0, 20.0, 12.0]\n\n    print *, \"Files larger than 10MB:\"\n    do i = 1, num_files\n        if (file_sizes(i) > 10.0) then\n            print *, file_names(i)\n        end if\n    end do\n\nend program filter_large_files\n```"
  },
  {
    "task": "Identify all events occurring on weekends from an event schedule.",
    "code": "```fortran\nprogram weekend_events\n    implicit none\n    integer, parameter :: num_events = 10\n    integer :: i\n    character(len=20) :: event_dates(num_events)\n    character(len=20) :: weekend_events(num_events)\n    integer :: count = 0\n\n    event_dates = ['2023-10-06', '2023-10-07', '2023-10-08', &\n                   '2023-10-09', '2023-10-14', '2023-10-15', &\n                   '2023-10-20', '2023-10-21', '2023-10-22', &\n                   '2023-10-27']\n\n    do i = 1, num_events\n        if (is_weekend(event_dates(i))) then\n            count = count + 1\n            weekend_events(count) = event_dates(i)\n        end if\n    end do\n\n    print *, \"Weekend Events:\"\n    do i = 1, count\n        print *, weekend_events(i)\n    end do\n\ncontains\n\n    logical function is_weekend(date)\n        character(len=*), intent(in) :: date\n        integer :: year, month, day\n        integer :: jd, wd\n\n        read(date, '(i4,1x,i2,1x,i2)') year, month, day\n        call julian_day(year, month, day, jd)\n        wd = mod(jd + 1, 7)\n        is_weekend = (wd == 6 .or. wd == 0)\n    end function is_weekend\n\n    subroutine julian_day(year, month, day, jd)\n        integer, intent(in) :: year, month, day\n        integer, intent(out) :: jd\n        integer :: a, y, m\n\n        a = (14 - month) / 12\n        y = year + 4800 - a\n        m = month + 12*a - 3\n        jd = day + (153*m + 2)/5 + 365*y + y/4 - y/100 + y/400 - 32045\n    end subroutine julian_day\n\nend program weekend_events\n```"
  },
  {
    "task": "Find all emails from a specific domain in an email list.",
    "code": "```fortran\nprogram filter_emails\n    implicit none\n    character(len=*), parameter :: target_domain = 'example.com'\n    character(len=100), dimension(:), allocatable :: emails\n    character(len=100), dimension(:), allocatable :: filtered_emails\n    integer :: i, count\n\n    emails = [ &\n        'user1@example.com', &\n        'user2@another.com', &\n        'user3@example.com', &\n        'user4@different.com' &\n    ]\n\n    filtered_emails = pack(emails, index(emails, '@' // target_domain) > 0)\n\n    ! Print the filtered emails\n    count = size(filtered_emails)\n    do i = 1, count\n        print *, filtered_emails(i)\n    end do\nend program filter_emails\n```"
  },
  {
    "task": "Filter out all people not living in a specific city from a contact list.",
    "code": "```fortran\nprogram filter_contacts\n    implicit none\n    type :: Person\n        character(len=50) :: name\n        character(len=50) :: city\n    end type Person\n\n    type(Person), allocatable :: contacts(:), filtered_contacts(:)\n    integer :: i, count\n    character(len=50) :: target_city\n\n    ! Example data\n    allocate(contacts(3))\n    contacts(1) = Person('Alice', 'New York')\n    contacts(2) = Person('Bob', 'Los Angeles')\n    contacts(3) = Person('Charlie', 'New York')\n\n    target_city = 'New York'\n\n    ! Count number of people in the target city\n    count = 0\n    do i = 1, size(contacts)\n        if (contacts(i)%city == target_city) then\n            count = count + 1\n        end if\n    end do\n\n    ! Allocate filtered contacts array\n    allocate(filtered_contacts(count))\n\n    ! Fill filtered contacts array with people in the target city\n    count = 0\n    do i = 1, size(contacts)\n        if (contacts(i)%city == target_city) then\n            count = count + 1\n            filtered_contacts(count) = contacts(i)\n        end if\n    end do\n\n    ! Output filtered contacts\n    do i = 1, size(filtered_contacts)\n        print *, 'Name:', filtered_contacts(i)%name, 'City:', filtered_contacts(i)%city\n    end do\n\n    ! Clean up\n    deallocate(contacts, filtered_contacts)\nend program filter_contacts\n```"
  },
  {
    "task": "Select all rectangles with an area greater than 50 from a list of rectangles.",
    "code": "```fortran\nmodule rectangle_module\n  implicit none\n  type :: Rectangle\n    real :: length\n    real :: width\n  contains\n    procedure :: area\n  end type Rectangle\n\n  interface Rectangle\n    module procedure newRectangle\n  end interface Rectangle\n\ncontains\n\n  function newRectangle(length, width) result(r)\n    real, intent(in) :: length, width\n    type(Rectangle) :: r\n    r%length = length\n    r%width = width\n  end function newRectangle\n\n  function area(this) result(a)\n    class(Rectangle), intent(in) :: this\n    real :: a\n    a = this%length * this%width\n  end function area\n\nend module rectangle_module\n\nprogram filter_rectangles\n  use rectangle_module\n  implicit none\n\n  type(Rectangle), allocatable :: rectangles(:)\n  type(Rectangle), allocatable :: filtered(:)\n  integer :: i, count\n\n  rectangles = [Rectangle(5.0, 11.0), Rectangle(4.0, 12.0), Rectangle(3.0, 13.0), &\n                Rectangle(6.0, 8.0), Rectangle(7.0, 7.0)]\n\n  count = count([rectangles(i)%area() > 50.0, i = 1, size(rectangles)])\n\n  allocate(filtered(count))\n  count = 0\n  do i = 1, size(rectangles)\n    if (rectangles(i)%area() > 50.0) then\n      count = count + 1\n      filtered(count) = rectangles(i)\n    end if\n  end do\n\nend program filter_rectangles\n```"
  },
  {
    "task": "Extract all elements that are not null from a collection.",
    "code": "```fortran\nprogram functional_filter\n  implicit none\n  integer, allocatable :: collection(:)\n  integer, allocatable :: filtered_collection(:)\n  integer :: i, count\n\n  collection = [1, 0, 3, 0, 5]  ! Example collection with null represented by 0\n  count = 0\n\n  ! Count non-null elements\n  do i = 1, size(collection)\n    if (collection(i) /= 0) then\n      count = count + 1\n    end if\n  end do\n\n  ! Allocate filtered collection\n  allocate(filtered_collection(count))\n\n  ! Populate filtered collection with non-null elements\n  count = 0\n  do i = 1, size(collection)\n    if (collection(i) /= 0) then\n      count = count + 1\n      filtered_collection(count) = collection(i)\n    end if\n  end do\n\n  ! Output filtered collection\n  print *, filtered_collection\nend program functional_filter\n```"
  },
  {
    "task": "Identify all registered voters over the age of 18 from a voter registration list.",
    "code": "```fortran\nprogram filter_voters\n    implicit none\n    integer, parameter :: num_voters = 5\n    integer :: i\n    type :: Voter\n        character(len=20) :: name\n        integer :: age\n    end type Voter\n    type(Voter), dimension(num_voters) :: voters = [ &\n        Voter(\"Alice\", 17), &\n        Voter(\"Bob\", 19), &\n        Voter(\"Charlie\", 22), &\n        Voter(\"Diana\", 16), &\n        Voter(\"Edward\", 25) &\n    ]\n    integer, allocatable :: eligible_voters(:)\n    \n    eligible_voters = pack([(i, i=1, num_voters)], [voters(i)%age > 18, i=1, num_voters])\n\n    print *, \"Eligible voters over the age of 18:\"\n    do i = 1, size(eligible_voters)\n        print *, voters(eligible_voters(i))%name\n    end do\nend program filter_voters\n```"
  },
  {
    "task": "Select all cars manufactured after 2015 from a vehicle registry.",
    "code": "```fortran\nprogram filter_cars\n    implicit none\n    type :: Car\n        character(len=20) :: model\n        integer :: year\n    end type Car\n\n    type(Car), allocatable :: registry(:)\n    type(Car), allocatable :: selected_cars(:)\n    integer :: i, count\n\n    ! Example registry\n    allocate(registry(3))\n    registry(1) = Car('Model A', 2014)\n    registry(2) = Car('Model B', 2016)\n    registry(3) = Car('Model C', 2018)\n\n    ! Filter cars manufactured after 2015\n    count = count([car%year > 2015 for car in registry])\n    allocate(selected_cars(count))\n    count = 0\n    do i = 1, size(registry)\n        if (registry(i)%year > 2015) then\n            count = count + 1\n            selected_cars(count) = registry(i)\n        end if\n    end do\nend program filter_cars\n```"
  },
  {
    "task": "Filter out all negative numbers from a dataset of integers.",
    "code": "```fortran\nprogram filter_negatives\n    implicit none\n    integer, allocatable :: data(:), filtered_data(:)\n    integer :: i, count\n\n    ! Example dataset\n    data = [3, -1, 4, -5, 9, 0, -2, 7]\n\n    ! Count non-negative numbers\n    count = count(data >= 0)\n\n    ! Allocate space for filtered data\n    allocate(filtered_data(count))\n\n    ! Fill filtered_data with non-negative numbers\n    count = 1\n    do i = 1, size(data)\n        if (data(i) >= 0) then\n            filtered_data(count) = data(i)\n            count = count + 1\n        end if\n    end do\n\n    ! Output the filtered data\n    print *, filtered_data\nend program filter_negatives\n```"
  },
  {
    "task": "Extract all characters from a string that are uppercase.",
    "code": "```fortran\nprogram extract_uppercase\n    implicit none\n    character(len=*), parameter :: input_string = \"HeLLo WoRLd!\"\n    character(len=len(input_string)) :: result\n    integer :: i, j\n\n    j = 1\n    do i = 1, len(input_string)\n        if (iachar(input_string(i:i)) >= iachar('A') .and. iachar(input_string(i:i)) <= iachar('Z')) then\n            result(j:j) = input_string(i:i)\n            j = j + 1\n        end if\n    end do\n\n    print *, trim(adjustl(result(1:j-1)))\nend program extract_uppercase\n```"
  },
  {
    "task": "Identify all projects with a deadline within the next month from a project database.",
    "code": "```fortran\nprogram FilterProjects\n  implicit none\n  integer, parameter :: maxProjects = 100\n  integer :: i, count\n  type :: Project\n    character(len=50) :: name\n    integer :: deadlineDaysFromNow\n  end type Project\n  type(Project) :: projects(maxProjects), filteredProjects(maxProjects)\n  integer :: currentDate, nextMonthDate\n\n  ! Example initialization (would normally come from a database)\n  projects(1) = Project('Project A', 10)\n  projects(2) = Project('Project B', 40)\n  projects(3) = Project('Project C', 25)\n  \n  currentDate = 0\n  nextMonthDate = 30\n  count = 0\n\n  filteredProjects = [Project('', 0)]  ! Reset filtered list\n\n  do i = 1, maxProjects\n    if (projects(i)%deadlineDaysFromNow <= nextMonthDate) then\n      count = count + 1\n      filteredProjects(count) = projects(i)\n    end if\n  end do\n\n  ! Output results (for demonstration purposes)\n  do i = 1, count\n    print *, 'Project:', filteredProjects(i)%name, &\n             'Deadline in days:', filteredProjects(i)%deadlineDaysFromNow\n  end do\nend program FilterProjects\n```"
  },
  {
    "task": "Select all athletes with a score higher than 90 from a competition result list.",
    "code": "```fortran\nprogram filter_athletes\n  implicit none\n  integer, parameter :: n = 10\n  integer :: i\n  real :: scores(n) = [95.0, 88.0, 91.5, 89.0, 92.0, 85.5, 93.5, 78.0, 96.0, 90.5]\n  character(len=20) :: athletes(n) = ['John', 'Paul', 'George', 'Ringo', 'Mick', 'Keith', 'Roger', 'Pete', 'David', 'Freddie']\n  character(len=20) :: selected_athletes(n)\n  integer :: count\n\n  count = 0\n  do i = 1, n\n    if (scores(i) > 90.0) then\n      count = count + 1\n      selected_athletes(count) = athletes(i)\n    end if\n  end do\n\n  print *, 'Athletes with score higher than 90:'\n  do i = 1, count\n    print *, selected_athletes(i)\n  end do\nend program filter_athletes\n```"
  },
  {
    "task": "Filter out all strings that do not contain vowels from a list of words.",
    "code": "```fortran\nprogram filter_vowels\n  implicit none\n  character(len=100), dimension(:), allocatable :: words\n  character(len=100), dimension(:), allocatable :: filtered_words\n  integer :: i, n, count\n\n  words = [ \"sky\", \"apple\", \"dry\", \"umbrella\", \"fly\", \"orange\" ]\n  n = size(words)\n  allocate(filtered_words(n))\n  count = 0\n\n  do i = 1, n\n    if (contains_vowel(words(i))) then\n      count = count + 1\n      filtered_words(count) = words(i)\n    end if\n  end do\n\n  if (count > 0) then\n    filtered_words = filtered_words(:count)\n  else\n    deallocate(filtered_words)\n  end if\n\ncontains\n\n  logical function contains_vowel(word)\n    character(len=*), intent(in) :: word\n    character(len=1), dimension(5) :: vowels\n    integer :: j\n\n    vowels = (/\"a\", \"e\", \"i\", \"o\", \"u\"/)\n    contains_vowel = .false.\n    \n    do j = 1, len(word)\n      if (any(word(j:j) == vowels)) then\n        contains_vowel = .true.\n        return\n      end if\n    end do\n\n  end function contains_vowel\n\nend program filter_vowels\n```"
  },
  {
    "task": "Extract all dates that fall on a weekday from a calendar.",
    "code": "```fortran\nprogram filter_weekdays\n    implicit none\n    integer, parameter :: n = 10\n    integer :: i, weekdays(n), dates(n)\n    integer :: day_of_week\n    external :: is_weekday\n\n    ! Example dates represented as day of week (1=Monday, ..., 7=Sunday)\n    dates = (/ 1, 2, 3, 4, 5, 6, 7, 1, 3, 5 /)\n    \n    weekdays = pack(dates, is_weekday(dates))\n    \n    print *, \"Weekdays: \", weekdays\n    \ncontains\n\n    logical function is_weekday(day)\n        integer, intent(in) :: day\n        is_weekday = .not. (day == 6 .or. day == 7)\n    end function is_weekday\n\nend program filter_weekdays\n```"
  },
  {
    "task": "Find all software versions that are stable releases from a list of software versions.",
    "code": "```fortran\nprogram filter_stable_versions\n  implicit none\n  character(len=256), dimension(:), allocatable :: versions, stable_versions\n  integer :: i, count\n\n  versions = [ \"1.0-beta\", \"1.0\", \"2.0-alpha\", \"2.0\", \"3.0-rc\", \"3.0\" ]\n  count = 0\n  \n  allocate(stable_versions(size(versions)))\n  \n  do i = 1, size(versions)\n    if (is_stable_release(versions(i))) then\n      count = count + 1\n      stable_versions(count) = versions(i)\n    end if\n  end do\n\n  if (count > 0) then\n    write(*,*) stable_versions(:count)\n  else\n    write(*,*) \"No stable versions found.\"\n  end if\n\ncontains\n\n  logical function is_stable_release(version)\n    character(len=*), intent(in) :: version\n    integer :: pos\n\n    pos = index(version, '-')\n    is_stable_release = (pos == 0)\n  end function is_stable_release\n\nend program filter_stable_versions\n```"
  },
  {
    "task": "Select all temperatures above freezing from a weather report.",
    "code": "```fortran\nprogram filter_temperatures\n  implicit none\n  real, dimension(:), allocatable :: temperatures, filtered_temperatures\n  integer :: i, count\n\n  ! Example data: temperatures in degrees Celsius\n  temperatures = [15.0, -3.0, 7.5, -1.0, 20.0, 0.0, 5.0]\n\n  ! Count how many temperatures are above freezing\n  count = count(temperatures > 0.0)\n\n  ! Allocate array for filtered temperatures\n  allocate(filtered_temperatures(count))\n\n  ! Filter temperatures above freezing\n  filtered_temperatures = pack(temperatures, temperatures > 0.0)\n\n  ! Print the filtered temperatures\n  print *, \"Temperatures above freezing:\", filtered_temperatures\n\nend program filter_temperatures\n```"
  },
  {
    "task": "Identify all countries with a GDP per capita above $40,000 from a country dataset.",
    "code": "```fortran\nprogram filter_gdp\n    implicit none\n    integer, parameter :: n = 5\n    character(len=20), dimension(n) :: countries = (/ 'USA', 'Norway', 'Germany', 'Brazil', 'India' /)\n    real, dimension(n) :: gdp_per_capita = (/ 63000.0, 75000.0, 45000.0, 9000.0, 2000.0 /)\n    character(len=20), allocatable :: filtered_countries(:)\n    integer :: i, count\n\n    count = count(gdp_per_capita > 40000.0)\n    allocate(filtered_countries(count))\n\n    count = 0\n    do i = 1, n\n        if (gdp_per_capita(i) > 40000.0) then\n            count = count + 1\n            filtered_countries(count) = countries(i)\n        end if\n    end do\n\n    print *, 'Countries with GDP per capita above $40,000:'\n    do i = 1, count\n        print *, filtered_countries(i)\n    end do\n\n    deallocate(filtered_countries)\nend program filter_gdp\n```"
  },
  {
    "task": "Filter out all names shorter than four letters from a roster.",
    "code": "```fortran\nprogram filter_names\n    implicit none\n    character(len=100), dimension(:), allocatable :: roster\n    character(len=100), dimension(:), allocatable :: filtered_roster\n    integer :: i, count\n\n    ! Initialize the roster with names\n    roster = [character(len=100) :: 'Amy', 'Brian', 'Tom', 'Jessica', 'Leo']\n\n    ! Count names with length >= 4\n    count = count([(len_trim(roster(i)) >= 4) for i = 1, size(roster)])\n\n    ! Allocate filtered_roster array\n    allocate(filtered_roster(count))\n\n    ! Filter names\n    count = 0\n    do i = 1, size(roster)\n        if (len_trim(roster(i)) >= 4) then\n            count = count + 1\n            filtered_roster(count) = roster(i)\n        end if\n    end do\n\n    ! Output the filtered names\n    do i = 1, size(filtered_roster)\n        print *, trim(filtered_roster(i))\n    end do\n\n    ! Deallocate arrays\n    deallocate(roster, filtered_roster)\nend program filter_names\n```"
  },
  {
    "task": "Extract all numbers divisible by five from a sequence.",
    "code": "```fortran\nprogram filter_divisible_by_five\n  implicit none\n  integer, allocatable :: numbers(:)\n  integer, allocatable :: result(:)\n  integer :: i, count\n\n  numbers = [1, 5, 10, 12, 15, 20, 23, 25, 30, 33]\n  allocate(result(size(numbers)))\n  count = 0\n\n  do i = 1, size(numbers)\n     if (mod(numbers(i), 5) == 0) then\n        count = count + 1\n        result(count) = numbers(i)\n     end if\n  end do\n\n  if (count > 0) then\n     result = result(:count)\n     print *, 'Numbers divisible by five:', result\n  else\n     print *, 'No numbers divisible by five found.'\n  end if\n\n  deallocate(result)\nend program filter_divisible_by_five\n```"
  },
  {
    "task": "Select all movies with a rating above 4 stars from a film review site.",
    "code": "```fortran\nmodule movie_filter\n  implicit none\ncontains\n  logical function is_high_rating(rating)\n    real, intent(in) :: rating\n    is_high_rating = (rating > 4.0)\n  end function is_high_rating\nend module movie_filter\n\nprogram filter_movies\n  use movie_filter\n  implicit none\n  real, dimension(:), allocatable :: ratings\n  integer :: i\n\n  ! Example data\n  allocate(ratings(5))\n  ratings = [3.5, 4.1, 4.5, 5.0, 2.8]\n\n  print *, \"Movies with rating above 4 stars:\"\n  do i = 1, size(ratings)\n    if (is_high_rating(ratings(i))) then\n      print *, \"Movie\", i, \"Rating:\", ratings(i)\n    end if\n  end do\n\n  deallocate(ratings)\nend program filter_movies\n```"
  },
  {
    "task": "Find all jobs with a salary above $50,000 from a job listing.",
    "code": "```fortran\nprogram filter_jobs\n    implicit none\n    type :: Job\n        character(len=100) :: title\n        real :: salary\n    end type Job\n\n    type(Job), dimension(:), allocatable :: jobs, high_salary_jobs\n    integer :: i, count\n\n    ! Sample data\n    allocate(jobs(4))\n    jobs(1) = Job('Engineer', 60000.0)\n    jobs(2) = Job('Teacher', 40000.0)\n    jobs(3) = Job('Developer', 75000.0)\n    jobs(4) = Job('Clerk', 30000.0)\n\n    count = 0\n    do i = 1, size(jobs)\n        if (jobs(i)%salary > 50000.0) then\n            count = count + 1\n        end if\n    end do\n\n    allocate(high_salary_jobs(count))\n    count = 0\n    do i = 1, size(jobs)\n        if (jobs(i)%salary > 50000.0) then\n            count = count + 1\n            high_salary_jobs(count) = jobs(i)\n        end if\n    end do\n\n    do i = 1, size(high_salary_jobs)\n        print *, 'Job Title:', trim(high_salary_jobs(i)%title), &\n                 ', Salary:', high_salary_jobs(i)%salary\n    end do\n\nend program filter_jobs\n```"
  },
  {
    "task": "Filter out all entries without an email address from a contact form submission list.",
    "code": "```fortran\nprogram filter_contacts\n    implicit none\n    type :: Contact\n        character(len=100) :: name\n        character(len=100) :: email\n    end type Contact\n\n    type(Contact), allocatable :: contacts(:)\n    type(Contact), allocatable :: filtered_contacts(:)\n    integer :: i, count\n\n    ! Example data\n    allocate(contacts(3))\n    contacts(1) = Contact('John Doe', 'john@example.com')\n    contacts(2) = Contact('Jane Smith', '')\n    contacts(3) = Contact('Alice Johnson', 'alice@example.com')\n\n    count = 0\n    do i = 1, size(contacts)\n        if (trim(contacts(i)%email) /= '') count = count + 1\n    end do\n\n    allocate(filtered_contacts(count))\n    count = 0\n    do i = 1, size(contacts)\n        if (trim(contacts(i)%email) /= '') then\n            count = count + 1\n            filtered_contacts(count) = contacts(i)\n        end if\n    end do\n\n    ! Output filtered contacts\n    do i = 1, size(filtered_contacts)\n        print *, 'Name:', filtered_contacts(i)%name, 'Email:', filtered_contacts(i)%email\n    end do\n\nend program filter_contacts\n```"
  },
  {
    "task": "Identify all animals weighing more than 50kg from a zoo inventory.",
    "code": "```fortran\nprogram zoo_filter\n  implicit none\n  type :: Animal\n     character(len=50) :: name\n     real :: weight\n  end type Animal\n\n  type(Animal), allocatable :: zoo(:)\n  type(Animal), allocatable :: heavyAnimals(:)\n  integer :: i, count\n\n  ! Example zoo inventory\n  zoo = [ &\n    Animal('Elephant', 500.0), &\n    Animal('Giraffe', 800.0), &\n    Animal('Monkey', 40.0), &\n    Animal('Zebra', 300.0), &\n    Animal('Penguin', 25.0) &\n  ]\n\n  count = count([ (zoo(i)%weight > 50.0, i = 1, size(zoo)) ])\n  allocate(heavyAnimals(count))\n\n  count = 0\n  do i = 1, size(zoo)\n    if (zoo(i)%weight > 50.0) then\n      count = count + 1\n      heavyAnimals(count) = zoo(i)\n    end if\n  end do\n\n  do i = 1, size(heavyAnimals)\n    print *, 'Heavy Animal:', trim(heavyAnimals(i)%name), 'Weight:', heavyAnimals(i)%weight\n  end do\nend program zoo_filter\n```"
  },
  {
    "task": "Select all songs with a duration longer than three minutes from a playlist.",
    "code": "```fortran\nprogram filter_songs\n    implicit none\n    type :: Song\n        character(len=100) :: title\n        integer :: duration  ! duration in seconds\n    end type Song\n\n    type(Song), allocatable :: playlist(:)\n    type(Song), allocatable :: filtered_playlist(:)\n    integer :: i, count\n\n    ! Example playlist (populate with real data as needed)\n    allocate(playlist(5))\n    playlist(1) = Song('Song A', 240)\n    playlist(2) = Song('Song B', 180)\n    playlist(3) = Song('Song C', 220)\n    playlist(4) = Song('Song D', 190)\n    playlist(5) = Song('Song E', 300)\n\n    count = count([ (song%duration, song=playlist) ] > 180)\n    allocate(filtered_playlist(count))\n\n    count = 0\n    do i = 1, size(playlist)\n        if (playlist(i)%duration > 180) then\n            count = count + 1\n            filtered_playlist(count) = playlist(i)\n        end if\n    end do\n\n    ! filtered_playlist now contains the songs with duration longer than three minutes\nend program filter_songs\n```"
  },
  {
    "task": "Extract all accounts with a balance below zero from a bank statement.",
    "code": "```fortran\nprogram filter_negative_balances\n    implicit none\n    type :: Account\n        character(len=30) :: name\n        real :: balance\n    end type Account\n\n    type(Account), dimension(5) :: accounts\n    type(Account), allocatable, dimension(:) :: negative_accounts\n    integer :: i, count\n\n    ! Sample data for accounts\n    accounts(1) = Account('Alice', 150.0)\n    accounts(2) = Account('Bob', -50.0)\n    accounts(3) = Account('Charlie', 0.0)\n    accounts(4) = Account('David', -100.0)\n    accounts(5) = Account('Eve', 200.0)\n\n    ! Functional filter: extract accounts with balance < 0\n    count = count([ (accounts(i)%balance < 0, i = 1, size(accounts)) ])\n    allocate(negative_accounts(count))\n    count = 0\n    do i = 1, size(accounts)\n        if (accounts(i)%balance < 0) then\n            count = count + 1\n            negative_accounts(count) = accounts(i)\n        end if\n    end do\n\n    ! Output negative balance accounts\n    do i = 1, size(negative_accounts)\n        print *, 'Account Name:', trim(negative_accounts(i)%name)\n        print *, 'Balance:', negative_accounts(i)%balance\n    end do\nend program filter_negative_balances\n```"
  },
  {
    "task": "Filter out all non-alphabetic characters from a string of text.",
    "code": "```fortran\nprogram filter_non_alphabetic\n    implicit none\n    character(len=:), allocatable :: input, output\n    integer :: i, len\n    character(len=1) :: c\n\n    input = \"Hello, World! 123\"\n    len = len(input)\n    output = \"\"\n\n    do i = 1, len\n        c = input(i:i)\n        if ((iachar(c) >= iachar('A') .and. iachar(c) <= iachar('Z')) .or. &\n            (iachar(c) >= iachar('a') .and. iachar(c) <= iachar('z'))) then\n            output = output // c\n        end if\n    end do\n\n    print *, output\nend program filter_non_alphabetic\n```"
  },
  {
    "task": "Select all participants who scored above average in a competition.",
    "code": "```fortran\nprogram filter_above_average\n  implicit none\n  integer, parameter :: n = 10\n  real, dimension(n) :: scores\n  character(len=20), dimension(n) :: participants\n  real :: average_score\n  integer :: i\n  real :: sum_scores\n\n  ! Sample data\n  scores = [85.0, 72.5, 90.0, 60.0, 95.0, 88.0, 77.0, 82.0, 94.0, 69.0]\n  participants = ['Alice', 'Bob', 'Charlie', 'David', 'Eva', 'Frank', &\n                  'Grace', 'Hannah', 'Isaac', 'Jack']\n\n  ! Calculate average score\n  sum_scores = sum(scores)\n  average_score = sum_scores / n\n\n  ! Filter participants who scored above average\n  print *, 'Participants scoring above average:'\n  do i = 1, n\n     if (scores(i) > average_score) then\n        print *, participants(i)\n     end if\n  end do\nend program filter_above_average\n```"
  },
  {
    "task": "Find all houses priced under $300,000 from a real estate database.",
    "code": "```fortran\nprogram filter_houses\n    implicit none\n    type :: House\n        real :: price\n    end type House\n\n    type(House), allocatable :: houses(:), filtered_houses(:)\n    integer :: i, count\n\n    ! Example initialization of the houses array\n    allocate(houses(5))\n    houses(1)%price = 250000.0\n    houses(2)%price = 320000.0\n    houses(3)%price = 275000.0\n    houses(4)%price = 180000.0\n    houses(5)%price = 310000.0\n\n    count = count_prices_under(houses, 300000.0)\n    allocate(filtered_houses(count))\n    call filter_prices_under(houses, 300000.0, filtered_houses)\n\ncontains\n\n    pure integer function count_prices_under(houses, max_price) result(count)\n        type(House), intent(in) :: houses(:)\n        real, intent(in) :: max_price\n        integer :: i\n\n        count = 0\n        do i = 1, size(houses)\n            if (houses(i)%price < max_price) then\n                count = count + 1\n            end if\n        end do\n    end function count_prices_under\n\n    pure subroutine filter_prices_under(houses, max_price, result)\n        type(House), intent(in) :: houses(:)\n        real, intent(in) :: max_price\n        type(House), intent(out) :: result(:)\n        integer :: i, j\n\n        j = 0\n        do i = 1, size(houses)\n            if (houses(i)%price < max_price) then\n                j = j + 1\n                result(j) = houses(i)\n            end if\n        end do\n    end subroutine filter_prices_under\n\nend program filter_houses\n```"
  },
  {
    "task": "Identify all plants that bloom in spring from a botanical catalog.",
    "code": "```fortran\nmodule plant_module\n  implicit none\n  type :: Plant\n    character(len=50) :: name\n    logical :: spring_bloom\n  end type Plant\ncontains\n  function filter_spring_bloom(plants) result(filtered_plants)\n    type(Plant), intent(in) :: plants(:)\n    type(Plant), allocatable :: filtered_plants(:)\n    integer :: i, count\n\n    count = 0\n    do i = 1, size(plants)\n      if (plants(i)%spring_bloom) count = count + 1\n    end do\n\n    allocate(filtered_plants(count))\n    count = 0\n    do i = 1, size(plants)\n      if (plants(i)%spring_bloom) then\n        count = count + 1\n        filtered_plants(count) = plants(i)\n      end if\n    end do\n  end function filter_spring_bloom\nend module plant_module\n\nprogram botanical_catalog\n  use plant_module\n  implicit none\n  type(Plant), allocatable :: catalog(:)\n  type(Plant), allocatable :: spring_plants(:)\n\n  allocate(catalog(3))\n  catalog(1) = Plant('Rose', .true.)\n  catalog(2) = Plant('Tulip', .true.)\n  catalog(3) = Plant('Orchid', .false.)\n\n  spring_plants = filter_spring_bloom(catalog)\n\n  ! The filtered spring plants are now in spring_plants\nend program botanical_catalog\n```"
  },
  {
    "task": "Extract all passwords that are longer than eight characters from a user database.",
    "code": "```fortran\nprogram filter_passwords\n    implicit none\n    character(len=20), dimension(:), allocatable :: passwords\n    character(len=20), dimension(:), allocatable :: long_passwords\n    integer :: i, count\n\n    ! Example user database\n    passwords = [ \"short\", \"averylongpassword\", \"medium12\", \"pass1234\", \"longenough\" ]\n\n    ! Count passwords longer than 8 characters\n    count = count([ len_trim(passwords(i)) > 8 for i = 1, size(passwords) ])\n\n    ! Allocate array for long passwords\n    allocate(long_passwords(count))\n\n    ! Extract passwords longer than 8 characters\n    long_passwords = pack(passwords, [ len_trim(passwords(i)) > 8 for i = 1, size(passwords) ])\n\n    ! Output the long passwords\n    do i = 1, size(long_passwords)\n        write(*,*) trim(long_passwords(i))\n    end do\nend program filter_passwords\n```"
  },
  {
    "task": "Filter out all projects that are not yet started from a project management tool.",
    "code": "```fortran\nprogram filter_projects\n    implicit none\n    type :: Project\n        character(len=50) :: name\n        logical :: started\n    end type Project\n\n    type(Project), allocatable :: projects(:), started_projects(:)\n    integer :: i, count\n\n    ! Example projects\n    allocate(projects(3))\n    projects(1) = Project('Project A', .true.)\n    projects(2) = Project('Project B', .false.)\n    projects(3) = Project('Project C', .true.)\n\n    ! Filter out projects that are not started\n    count = 0\n    allocate(started_projects(size(projects)))\n    do i = 1, size(projects)\n        if (projects(i)%started) then\n            count = count + 1\n            started_projects(count) = projects(i)\n        end if\n    end do\n\n    ! Resize array to only include started projects\n    if (count > 0) then\n        call move_alloc(started_projects, started_projects(:count))\n    else\n        deallocate(started_projects)\n    end if\n\n    ! Output started projects\n    do i = 1, size(started_projects)\n        print *, 'Started Project:', started_projects(i)%name\n    end do\nend program filter_projects\n```"
  },
  {
    "task": "Select all days with temperatures exceeding 25\u00b0C from a climate report.",
    "code": "```fortran\nprogram filter_temperatures\n  implicit none\n  real, dimension(:), allocatable :: temperatures, hot_days\n  integer :: i, count\n\n  ! Example temperature data\n  temperatures = [20.5, 22.3, 25.1, 27.8, 30.0, 19.0, 26.5]\n\n  ! Count how many days are above 25\u00b0C\n  count = count(temperatures > 25.0)\n\n  ! Allocate array for hot days\n  allocate(hot_days(count))\n\n  ! Filter and collect hot days\n  hot_days = pack(temperatures, temperatures > 25.0)\n\n  ! Output the result\n  print *, \"Days with temperatures exceeding 25\u00b0C: \", hot_days\nend program filter_temperatures\n```"
  },
  {
    "task": "Find all recipes that are vegetarian from a cookbook.",
    "code": "```fortran\nmodule cookbook\n  implicit none\n  type :: Recipe\n    character(len=100) :: name\n    logical :: isVegetarian\n  end type Recipe\ncontains\n  logical function isVegetarianFilter(recipe)\n    type(Recipe), intent(in) :: recipe\n    isVegetarianFilter = recipe%isVegetarian\n  end function isVegetarianFilter\nend module cookbook\n\nprogram findVegetarianRecipes\n  use cookbook\n  implicit none\n  type(Recipe), allocatable :: recipes(:), vegetarianRecipes(:)\n  integer :: i, count\n\n  ! Example data\n  allocate(recipes(3))\n  recipes(1) = Recipe('Salad', .true.)\n  recipes(2) = Recipe('Chicken Curry', .false.)\n  recipes(3) = Recipe('Vegetable Stir Fry', .true.)\n\n  ! Count the number of vegetarian recipes\n  count = count([ (isVegetarianFilter(recipes(i)), i=1, size(recipes)) ])\n\n  ! Allocate and filter vegetarian recipes\n  allocate(vegetarianRecipes(count))\n  vegetarianRecipes = pack(recipes, [ (isVegetarianFilter(recipes(i)), i=1, size(recipes)) ])\n\n  ! Output vegetarian recipes\n  do i = 1, size(vegetarianRecipes)\n    print *, vegetarianRecipes(i)%name\n  end do\nend program findVegetarianRecipes\n```"
  },
  {
    "task": "Identify all articles that mention a specific keyword from a news feed.",
    "code": "```fortran\nprogram filter_articles\n  implicit none\n  character(len=100), dimension(:), allocatable :: articles\n  character(len=100) :: keyword\n  integer :: i\n\n  ! Sample data\n  allocate(articles(3))\n  articles = (/'Breaking news: Storm approaching', &\n              'Sports update: Local team wins', &\n              'Economy news: Market sees rise'/)\n\n  keyword = 'news'\n\n  print *, 'Articles mentioning \"', trim(keyword), '\":'\n  \n  call filter(articles, keyword, print_article)\n\ncontains\n\n  subroutine filter(articles, keyword, action)\n    character(len=*), dimension(:) :: articles\n    character(len=*), intent(in) :: keyword\n    interface\n      subroutine action(article)\n        character(len=*), intent(in) :: article\n      end subroutine action\n    end interface\n    integer :: i\n\n    do i = 1, size(articles)\n      if (index(articles(i), keyword) > 0) then\n        call action(articles(i))\n      end if\n    end do\n  end subroutine filter\n\n  subroutine print_article(article)\n    character(len=*), intent(in) :: article\n    print *, trim(article)\n  end subroutine print_article\n\nend program filter_articles\n```"
  },
  {
    "task": "Extract all files with the '.jpg' extension from a directory.",
    "code": "```fortran\nprogram filter_jpg_files\n    implicit none\n    character(len=256) :: command, path\n    character(len=256), allocatable :: files(:)\n    integer :: i, num_files\n\n    path = './'  ! Specify the directory path\n    command = 'ls ' // trim(path) // ' | grep \\.jpg$'\n\n    call execute_command_line(command, wait=.true., exitstat=num_files)\n    if (num_files == 0) then\n        print *, \"No .jpg files found.\"\n    else\n        allocate(files(num_files))\n        open(unit=10, file='temp.txt', status='replace')\n        call execute_command_line(command // ' > temp.txt')\n        read(10, fmt='(A)', iostat=i) files\n        close(10)\n\n        print *, \"Extracted .jpg files:\"\n        do i = 1, num_files\n            print *, trim(files(i))\n        end do\n\n        deallocate(files)\n    end if\nend program filter_jpg_files\n```"
  },
  {
    "task": "Filter out all transactions that are not categorized from a financial statement.",
    "code": "```fortran\nprogram filter_transactions\n    implicit none\n    type :: Transaction\n        character(len=50) :: category\n        real :: amount\n    end type Transaction\n\n    type(Transaction), dimension(:), allocatable :: transactions, filtered_transactions\n    integer :: i, count\n\n    ! Example data\n    transactions = [Transaction('Food', 100.0), Transaction('', 200.0), Transaction('Utilities', 150.0), Transaction('', 50.0)]\n\n    count = count([t%category /= '' .and. len_trim(t%category) > 0, t=transactions])\n    allocate(filtered_transactions(count))\n\n    count = 0\n    do i = 1, size(transactions)\n        if (transactions(i)%category /= '' .and. len_trim(transactions(i)%category) > 0) then\n            count = count + 1\n            filtered_transactions(count) = transactions(i)\n        end if\n    end do\n\n    ! Output filtered transactions\n    do i = 1, size(filtered_transactions)\n        print *, 'Category:', trim(filtered_transactions(i)%category), 'Amount:', filtered_transactions(i)%amount\n    end do\nend program filter_transactions\n```"
  },
  {
    "task": "Select all paintings created before 1900 from an art gallery collection.",
    "code": "```fortran\nprogram filter_paintings\n  implicit none\n  type Painting\n     character(len=50) :: title\n     integer :: year\n  end type Painting\n\n  type(Painting), dimension(:), allocatable :: gallery\n  type(Painting), dimension(:), allocatable :: filtered_paintings\n  integer :: i, num_paintings\n\n  ! Example gallery initialization\n  num_paintings = 5\n  allocate(gallery(num_paintings))\n  gallery(1) = Painting('Mona Lisa', 1503)\n  gallery(2) = Painting('The Starry Night', 1889)\n  gallery(3) = Painting('The Persistence of Memory', 1931)\n  gallery(4) = Painting('The Scream', 1893)\n  gallery(5) = Painting('Girl with a Pearl Earring', 1665)\n\n  ! Filter paintings created before 1900\n  filtered_paintings = pack(gallery, gallery%year < 1900)\n\n  ! Output results\n  do i = 1, size(filtered_paintings)\n     print *, 'Title:', trim(filtered_paintings(i)%title), &\n              ', Year:', filtered_paintings(i)%year\n  end do\n\nend program filter_paintings\n```"
  },
  {
    "task": "Find all students with perfect attendance from a school record.",
    "code": "```fortran\nprogram perfect_attendance\n    implicit none\n    type :: Student\n        character(len=50) :: name\n        integer :: attendance\n    end type Student\n\n    type(Student), dimension(:), allocatable :: students\n    type(Student), dimension(:), allocatable :: perfect_students\n    integer :: i, n, count\n\n    ! Sample data\n    n = 5\n    allocate(students(n))\n    students(1) = Student('Alice', 100)\n    students(2) = Student('Bob', 95)\n    students(3) = Student('Charlie', 100)\n    students(4) = Student('David', 85)\n    students(5) = Student('Eve', 100)\n\n    ! Filter students with perfect attendance\n    count = 0\n    do i = 1, n\n        if (students(i)%attendance == 100) then\n            count = count + 1\n        end if\n    end do\n\n    allocate(perfect_students(count))\n    count = 0\n    do i = 1, n\n        if (students(i)%attendance == 100) then\n            count = count + 1\n            perfect_students(count) = students(i)\n        end if\n    end do\n\n    ! Output perfect attendance students\n    do i = 1, count\n        print *, 'Perfect Attendance:', perfect_students(i)%name\n    end do\n\nend program perfect_attendance\n```"
  },
  {
    "task": "Identify all messages sent by a specific user from a chat application.",
    "code": "```fortran\nmodule filter_module\n  implicit none\ncontains\n  function filter_messages_by_user(messages, user) result(filtered_messages)\n    type(message), dimension(:), intent(in) :: messages\n    character(len=*), intent(in) :: user\n    type(message), allocatable, dimension(:) :: filtered_messages\n    integer :: i, count\n\n    count = count_user_messages(messages, user)\n    allocate(filtered_messages(count))\n    count = 0\n\n    do i = 1, size(messages)\n      if (messages(i)%user == user) then\n        count = count + 1\n        filtered_messages(count) = messages(i)\n      end if\n    end do\n  end function filter_messages_by_user\n\n  function count_user_messages(messages, user) result(count)\n    type(message), dimension(:), intent(in) :: messages\n    character(len=*), intent(in) :: user\n    integer :: count, i\n\n    count = 0\n    do i = 1, size(messages)\n      if (messages(i)%user == user) then\n        count = count + 1\n      end if\n    end do\n  end function count_user_messages\n\nend module filter_module\n\nprogram main\n  use filter_module\n  implicit none\n\n  type message\n    character(len=100) :: user\n    character(len=256) :: content\n  end type message\n\n  type(message), allocatable, dimension(:) :: messages, result\n  integer :: i\n\n  ! Example initialization of messages\n  allocate(messages(3))\n  messages(1) = message('Alice', 'Hello world!')\n  messages(2) = message('Bob', 'Good morning!')\n  messages(3) = message('Alice', 'How are you today?')\n\n  ! Filter messages by user\n  result = filter_messages_by_user(messages, 'Alice')\n\n  ! Output filtered messages\n  do i = 1, size(result)\n    print *, 'User:', result(i)%user, 'Message:', result(i)%content\n  end do\n\nend program main\n```"
  },
  {
    "task": "Extract all elements greater than 100 from an array of numbers.",
    "code": "```fortran\nprogram filter_greater_than_100\n  implicit none\n  integer, parameter :: n = 10\n  integer :: arr(n) = [50, 150, 200, 30, 110, 95, 180, 220, 10, 105]\n  integer :: result(n)\n  integer :: i, count\n  \n  count = 0\n  do i = 1, n\n    if (arr(i) > 100) then\n      count = count + 1\n      result(count) = arr(i)\n    end if\n  end do\n  \n  print *, 'Elements greater than 100: ', result(1:count)\nend program filter_greater_than_100\n```"
  },
  {
    "task": "Filter out all words that do not end in 'ed' from a paragraph.",
    "code": "```fortran\nprogram filter_words\n    implicit none\n    character(len=*), parameter :: paragraph = 'The cat jumped and landed on the bed. It then purred and looked satisfied.'\n    character(len=100) :: words(20)\n    character(len=100) :: result(20)\n    integer :: i, n, count\n\n    n = 0\n    count = 0\n\n    ! Split the paragraph into words\n    call split(paragraph, ' ', words, n)\n\n    ! Filter words ending with 'ed'\n    do i = 1, n\n        if (ends_with_ed(trim(words(i)))) then\n            count = count + 1\n            result(count) = words(i)\n        end if\n    end do\n\n    ! Print the filtered words\n    do i = 1, count\n        print *, trim(result(i))\n    end do\ncontains\n\n    subroutine split(string, delimiter, words, n)\n        character(len=*), intent(in) :: string\n        character(len=1), intent(in) :: delimiter\n        character(len=100), intent(out) :: words(20)\n        integer, intent(out) :: n\n        integer :: start, finish\n\n        n = 0\n        start = 1\n        do\n            finish = index(string(start:), delimiter)\n            if (finish == 0) then\n                n = n + 1\n                words(n) = string(start:)\n                exit\n            else\n                n = n + 1\n                words(n) = string(start:start+finish-2)\n                start = start + finish\n            end if\n        end do\n    end subroutine split\n\n    logical function ends_with_ed(word)\n        character(len=*), intent(in) :: word\n        integer :: len_word\n\n        len_word = len_trim(word)\n        if (len_word >= 2 .and. &\n            word(len_word-1:len_word) == 'ed') then\n            ends_with_ed = .true.\n        else\n            ends_with_ed = .false.\n        end if\n    end function ends_with_ed\n\nend program filter_words\n```"
  },
  {
    "task": "Select all flights departing before noon from a flight schedule.",
    "code": "```fortran\nprogram filter_flights\n    implicit none\n    type :: Flight\n        character(len=50) :: destination\n        real :: departure_time\n    end type Flight\n\n    type(Flight), allocatable :: flights(:), morning_flights(:)\n    integer :: i, count\n\n    ! Example data\n    allocate(flights(5))\n    flights(1) = Flight(\"New York\", 8.30)\n    flights(2) = Flight(\"Los Angeles\", 14.00)\n    flights(3) = Flight(\"Chicago\", 11.45)\n    flights(4) = Flight(\"Miami\", 9.15)\n    flights(5) = Flight(\"Boston\", 13.50)\n\n    ! Filter flights departing before noon\n    count = 0\n    do i = 1, size(flights)\n        if (flights(i)%departure_time < 12.00) then\n            count = count + 1\n        end if\n    end do\n\n    allocate(morning_flights(count))\n    count = 0\n    do i = 1, size(flights)\n        if (flights(i)%departure_time < 12.00) then\n            count = count + 1\n            morning_flights(count) = flights(i)\n        end if\n    end do\n\n    ! Output the filtered flights\n    do i = 1, size(morning_flights)\n        print *, \"Destination:\", trim(morning_flights(i)%destination), \"Departure Time:\", morning_flights(i)%departure_time\n    end do\nend program filter_flights\n```"
  },
  {
    "task": "Find all products priced above $20 from an online store inventory.",
    "code": "```fortran\nmodule product_module\n    implicit none\n    type :: Product\n        real :: price\n    end type Product\ncontains\n    function filter_expensive_products(products, threshold) result(expensive_products)\n        type(Product), intent(in) :: products(:)\n        real, intent(in) :: threshold\n        type(Product), allocatable :: expensive_products(:)\n        integer :: i, count\n\n        count = 0\n        do i = 1, size(products)\n            if (products(i)%price > threshold) then\n                count = count + 1\n            end if\n        end do\n\n        allocate(expensive_products(count))\n        count = 0\n        do i = 1, size(products)\n            if (products(i)%price > threshold) then\n                count = count + 1\n                expensive_products(count) = products(i)\n            end if\n        end do\n    end function filter_expensive_products\nend module product_module\n\nprogram main\n    use product_module\n    implicit none\n    type(Product) :: inventory(5)\n    type(Product), allocatable :: expensive_products(:)\n    integer :: i\n\n    inventory(1)%price = 10.0\n    inventory(2)%price = 25.0\n    inventory(3)%price = 5.0\n    inventory(4)%price = 30.0\n    inventory(5)%price = 15.0\n\n    expensive_products = filter_expensive_products(inventory, 20.0)\n\n    do i = 1, size(expensive_products)\n        print *, \"Product priced at:\", expensive_products(i)%price\n    end do\nend program main\n```"
  },
  {
    "task": "Identify all sessions longer than one hour from a webinar series.",
    "code": "```fortran\nprogram filter_sessions\n  implicit none\n  integer, parameter :: n = 5\n  real :: session_durations(n) = [0.5, 1.5, 2.0, 0.75, 1.25]\n  real :: long_sessions(n)\n  integer :: i, count\n\n  count = 0\n  do i = 1, n\n    if (session_durations(i) > 1.0) then\n      count = count + 1\n      long_sessions(count) = session_durations(i)\n    end if\n  end do\n\n  print *, 'Sessions longer than one hour:'\n  do i = 1, count\n    print *, long_sessions(i)\n  end do\nend program filter_sessions\n```"
  },
  {
    "task": "Extract all images with a resolution higher than 1080p from a photo library.",
    "code": "```fortran\nprogram filter_images\n  implicit none\n  type :: image\n     integer :: width\n     integer :: height\n     character(len=256) :: filename\n  end type image\n\n  type(image), allocatable :: photo_library(:)\n  type(image), allocatable :: filtered_images(:)\n  integer :: i, count\n\n  ! Sample data for demonstration\n  allocate(photo_library(5))\n  photo_library(1) = image(1920, 1080, 'img1.jpg')\n  photo_library(2) = image(2560, 1440, 'img2.jpg')\n  photo_library(3) = image(1280, 720, 'img3.jpg')\n  photo_library(4) = image(3840, 2160, 'img4.jpg')\n  photo_library(5) = image(1920, 1080, 'img5.jpg')\n\n  count = 0\n  do i = 1, size(photo_library)\n     if (photo_library(i)%width * photo_library(i)%height > 1920 * 1080) then\n        count = count + 1\n     end if\n  end do\n\n  allocate(filtered_images(count))\n  count = 0\n  do i = 1, size(photo_library)\n     if (photo_library(i)%width * photo_library(i)%height > 1920 * 1080) then\n        count = count + 1\n        filtered_images(count) = photo_library(i)\n     end if\n  end do\n\n  ! Output filtered images\n  do i = 1, size(filtered_images)\n     print *, 'Filtered image:', filtered_images(i)%filename\n  end do\n\nend program filter_images\n```"
  },
  {
    "task": "Filter out all responses that are not 'yes' or 'no' from a survey result.",
    "code": "```fortran\nprogram filter_responses\n  implicit none\n  character(len=100), dimension(10) :: responses = &\n    ['yes', 'no', 'maybe', 'yes', 'no', 'uncertain', 'yes', 'no', 'yes', 'no']\n  integer :: i\n\n  print *, 'Filtered responses:'\n  do i = 1, size(responses)\n     if (responses(i) == 'yes' .or. responses(i) == 'no') then\n        print *, responses(i)\n     end if\n  end do\nend program filter_responses\n```"
  },
  {
    "task": "Select all tweets with more than 100 likes from a Twitter feed.",
    "code": "```fortran\nprogram filter_tweets\n  implicit none\n  type :: Tweet\n     character(len=:), allocatable :: content\n     integer :: likes\n  end type Tweet\n\n  type(Tweet), allocatable :: tweets(:), filtered_tweets(:)\n  integer :: i, count\n\n  ! Example tweets (in reality, these would be fetched from a Twitter API)\n  allocate(tweets(3))\n  tweets(1) = Tweet(\"Tweet 1\", 50)\n  tweets(2) = Tweet(\"Tweet 2\", 150)\n  tweets(3) = Tweet(\"Tweet 3\", 200)\n\n  count = 0\n  do i = 1, size(tweets)\n     if (tweets(i)%likes > 100) then\n        count = count + 1\n     end if\n  end do\n\n  allocate(filtered_tweets(count))\n  count = 0\n  do i = 1, size(tweets)\n     if (tweets(i)%likes > 100) then\n        count = count + 1\n        filtered_tweets(count) = tweets(i)\n     end if\n  end do\n\n  ! Output filtered tweets\n  do i = 1, size(filtered_tweets)\n     print *, filtered_tweets(i)%content\n  end do\n\n  deallocate(tweets, filtered_tweets)\nend program filter_tweets\n```"
  },
  {
    "task": "Find all links that are broken from a webpage.",
    "code": "```fortran\nprogram find_broken_links\n  use, intrinsic :: iso_fortran_env, only: error_unit\n  implicit none\n  character(len=:), allocatable :: webpage, links(:)\n  integer :: i\n\n  webpage = fetch_webpage(\"http://example.com\")\n  links = extract_links(webpage)\n\n  do i = 1, size(links)\n     if (.not. is_link_working(links(i))) then\n        write(error_unit, '(A)') trim(links(i))\n     end if\n  end do\n\ncontains\n\n  function fetch_webpage(url) result(page)\n    character(len=*), intent(in) :: url\n    character(len=:), allocatable :: page\n    ! Implementation to fetch the webpage content\n  end function fetch_webpage\n\n  function extract_links(page) result(links)\n    character(len=*), intent(in) :: page\n    character(len=:), allocatable :: links(:)\n    ! Implementation to extract links from the webpage content\n  end function extract_links\n\n  function is_link_working(link) result(is_working)\n    character(len=*), intent(in) :: link\n    logical :: is_working\n    ! Implementation to check if the link is working\n  end function is_link_working\n\nend program find_broken_links\n```"
  },
  {
    "task": "Identify all machines that are currently offline from a network monitoring tool.",
    "code": "```fortran\nprogram identify_offline_machines\n    implicit none\n    integer, parameter :: n = 10\n    logical, dimension(n) :: machine_status\n    integer :: i\n\n    ! Example data: 1 indicates online, 0 indicates offline\n    machine_status = [ .true., .false., .true., .false., .true., &\n                       .true., .false., .true., .false., .true. ]\n\n    print *, \"Machines that are currently offline:\"\n    call filter_offline_machines(machine_status)\n\ncontains\n\n    subroutine filter_offline_machines(status)\n        logical, dimension(:), intent(in) :: status\n        integer :: i\n\n        do i = 1, size(status)\n            if (.not. status(i)) then\n                print *, \"Machine\", i\n            end if\n        end do\n    end subroutine filter_offline_machines\n\nend program identify_offline_machines\n```"
  },
  {
    "task": "Extract all invoices with a due date in the current month from an accounting system.",
    "code": "```fortran\nprogram filter_invoices\n  implicit none\n  integer, parameter :: max_invoices = 100\n  type :: Invoice\n    integer :: id\n    integer :: due_year\n    integer :: due_month\n  end type Invoice\n  type(Invoice), dimension(max_invoices) :: invoices\n  type(Invoice), dimension(:), allocatable :: current_month_invoices\n  integer :: n_invoices, i, n_current_invoices\n  integer :: current_year, current_month\n\n  ! Sample initialization\n  n_invoices = 0\n  call date_and_time(values=[current_year, current_month])\n\n  ! Filter function\n  contains\n    logical function is_due_this_month(invoice)\n      type(Invoice), intent(in) :: invoice\n      is_due_this_month = (invoice%due_year == current_year .and. invoice%due_month == current_month)\n    end function is_due_this_month\n  end contains\n\n  ! Filter process\n  n_current_invoices = count([(is_due_this_month(invoices(i)), i=1, n_invoices)])\n  allocate(current_month_invoices(n_current_invoices))\n  current_month_invoices = pack(invoices(:n_invoices), [(is_due_this_month(invoices(i)), i=1, n_invoices)])\n\nend program filter_invoices\n```"
  },
  {
    "task": "Filter out all lines in a file that start with a '#' from a configuration file.",
    "code": "```fortran\nprogram filter_config\n    implicit none\n    character(len=256) :: line\n    integer :: unit_in, unit_out\n\n    open(newunit=unit_in, file='config.txt', status='old', action='read')\n    open(newunit=unit_out, file='filtered_config.txt', status='replace', action='write')\n\n    do\n        read(unit_in, '(A)', end=10) line\n        if (line(1:1) /= '#') then\n            write(unit_out, '(A)') trim(line)\n        end if\n    end do\n\n10  continue\n\n    close(unit_in)\n    close(unit_out)\nend program filter_config\n```"
  },
  {
    "task": "Select all posts with a comment count higher than 50 from a blog.",
    "code": "```fortran\nprogram functional_filter\n    implicit none\n    type :: Post\n        integer :: comment_count\n    end type Post\n\n    type(Post), allocatable :: posts(:)\n    type(Post), allocatable :: selected_posts(:)\n    integer :: i, count\n\n    ! Sample data initialization\n    allocate(posts(5))\n    posts(1)%comment_count = 10\n    posts(2)%comment_count = 60\n    posts(3)%comment_count = 45\n    posts(4)%comment_count = 80\n    posts(5)%comment_count = 55\n\n    ! Filter posts with comment count higher than 50\n    count = 0\n    do i = 1, size(posts)\n        if (posts(i)%comment_count > 50) then\n            count = count + 1\n        end if\n    end do\n\n    allocate(selected_posts(count))\n    count = 0\n    do i = 1, size(posts)\n        if (posts(i)%comment_count > 50) then\n            count = count + 1\n            selected_posts(count) = posts(i)\n        end if\n    end do\n\n    ! Output selected posts for verification\n    do i = 1, size(selected_posts)\n        print *, \"Post with comment count:\", selected_posts(i)%comment_count\n    end do\n\nend program functional_filter\n```"
  },
  {
    "task": "Find all offers that expire within the next week from a promotional database.",
    "code": "```fortran\nprogram filter_offers\n    implicit none\n    integer, parameter :: n = 10\n    type :: Offer\n        character(len=20) :: name\n        integer :: expiry\n    end type Offer\n    type(Offer), dimension(n) :: offers\n    type(Offer), allocatable, dimension(:) :: filtered_offers\n    integer :: i, count\n    integer :: current_day, next_week\n\n    ! Sample data\n    offers(1) = Offer('Offer1', 3)\n    offers(2) = Offer('Offer2', 10)\n    offers(3) = Offer('Offer3', 5)\n    offers(4) = Offer('Offer4', 14)\n    offers(5) = Offer('Offer5', 2)\n    offers(6) = Offer('Offer6', 8)\n    offers(7) = Offer('Offer7', 1)\n    offers(8) = Offer('Offer8', 7)\n    offers(9) = Offer('Offer9', 9)\n    offers(10) = Offer('Offer10', 4)\n\n    current_day = 0\n    next_week = current_day + 7\n\n    count = count([offer%expiry <= next_week .and. offer%expiry > current_day, offer=offers])\n    allocate(filtered_offers(count))\n\n    count = 0\n    do i = 1, n\n        if (offers(i)%expiry <= next_week .and. offers(i)%expiry > current_day) then\n            count = count + 1\n            filtered_offers(count) = offers(i)\n        end if\n    end do\n\n    print *, \"Filtered Offers:\"\n    do i = 1, count\n        print *, filtered_offers(i)%name\n    end do\n\n    deallocate(filtered_offers)\nend program filter_offers\n```"
  },
  {
    "task": "Identify all items that are on sale from a shopping catalog.",
    "code": "```fortran\nmodule shopping_catalog\n  implicit none\n  type :: Item\n    character(len=50) :: name\n    logical :: on_sale\n  end type Item\ncontains\n  function filter_on_sale(items) result(on_sale_items)\n    type(Item), intent(in) :: items(:)\n    type(Item), allocatable :: on_sale_items(:)\n    integer :: i, count\n\n    count = 0\n    do i = 1, size(items)\n      if (items(i)%on_sale) then\n        count = count + 1\n      end if\n    end do\n\n    allocate(on_sale_items(count))\n    count = 0\n    do i = 1, size(items)\n      if (items(i)%on_sale) then\n        count = count + 1\n        on_sale_items(count) = items(i)\n      end if\n    end do\n  end function filter_on_sale\nend module shopping_catalog\n```"
  },
  {
    "task": "Extract all notes that mention 'urgent' from a meeting record.",
    "code": "```fortran\nprogram filter_notes\n    implicit none\n    character(len=100), dimension(10) :: notes\n    character(len=100), dimension(:), allocatable :: urgent_notes\n    integer :: i, count\n\n    ! Example notes\n    notes = (/ &\n        \"Meeting at 10am\", &\n        \"Urgent: budget review\", &\n        \"Lunch break\", &\n        \"Urgent: client call\", &\n        \"Weekly report\", &\n        \"Urgent: project deadline\", &\n        \"Team building\", &\n        \"Urgent: staff meeting\", &\n        \"Quarterly results\", &\n        \"Urgent: policy update\" /)\n\n    count = 0\n    allocate(urgent_notes(size(notes)))\n\n    do i = 1, size(notes)\n        if (index(notes(i), \"Urgent\") > 0) then\n            count = count + 1\n            urgent_notes(count) = notes(i)\n        end if\n    end do\n\n    if (count > 0) then\n        urgent_notes = urgent_notes(1:count)\n        do i = 1, count\n            print *, trim(urgent_notes(i))\n        end do\n    else\n        print *, \"No urgent notes found.\"\n    end if\n\nend program filter_notes\n```"
  },
  {
    "task": "Filter out all numbers that do not have a remainder when divided by two from a list.",
    "code": "```fortran\nprogram functional_filter\n    implicit none\n    integer, allocatable :: numbers(:), filtered_numbers(:)\n    integer :: i, count\n\n    numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n    count = count(mod(numbers, 2) == 1)\n    allocate(filtered_numbers(count))\n\n    count = 0\n    do i = 1, size(numbers)\n        if (mod(numbers(i), 2) == 1) then\n            count = count + 1\n            filtered_numbers(count) = numbers(i)\n        end if\n    end do\n\n    print *, filtered_numbers\nend program functional_filter\n```"
  },
  {
    "task": "Select all concerts happening in the summer from an event calendar.",
    "code": "```fortran\nprogram filter_summer_concerts\n    implicit none\n    type :: Event\n        character(len=100) :: name\n        character(len=10) :: date    ! Format: YYYY-MM-DD\n        character(len=20) :: type\n    end type Event\n\n    type(Event), dimension(:), allocatable :: events, summer_concerts\n    integer :: i, n, count\n\n    ! Sample data\n    n = 5\n    allocate(events(n))\n    events(1) = Event('Rock Fest', '2023-06-21', 'Concert')\n    events(2) = Event('Jazz Night', '2023-07-10', 'Concert')\n    events(3) = Event('Art Expo', '2023-06-15', 'Exhibition')\n    events(4) = Event('Pop Gala', '2023-08-05', 'Concert')\n    events(5) = Event('Tech Conference', '2023-09-01', 'Conference')\n\n    count = count_summer_concerts(events)\n    allocate(summer_concerts(count))\n    call get_summer_concerts(events, summer_concerts)\n\n    do i = 1, count\n        print *, 'Summer Concert:', summer_concerts(i)%name, summer_concerts(i)%date\n    end do\n\ncontains\n\n    pure integer function count_summer_concerts(events) result(count)\n        type(Event), dimension(:), intent(in) :: events\n        integer :: i\n        count = 0\n        do i = 1, size(events)\n            if (is_summer_concert(events(i))) count = count + 1\n        end do\n    end function count_summer_concerts\n\n    subroutine get_summer_concerts(events, summer_concerts)\n        type(Event), dimension(:), intent(in) :: events\n        type(Event), dimension(:), intent(out) :: summer_concerts\n        integer :: i, j\n        j = 0\n        do i = 1, size(events)\n            if (is_summer_concert(events(i))) then\n                j = j + 1\n                summer_concerts(j) = events(i)\n            end if\n        end do\n    end subroutine get_summer_concerts\n\n    pure logical function is_summer_concert(event) result(is_summer)\n        type(Event), intent(in) :: event\n        integer :: month\n        character(len=4) :: year\n        character(len=2) :: month_str, day\n        read(event%date, '(A4,A1,A2,A1,A2)') year, ignore, month_str, ignore, day\n        read(month_str, '(I2)') month\n        is_summer = (event%type == 'Concert') .and. (month >= 6 .and. month <= 8)\n    end function is_summer_concert\n\nend program filter_summer_concerts\n```"
  },
  {
    "task": "Find all users with more than 1000 followers from a social media platform.",
    "code": "```fortran\nprogram filter_users\n    implicit none\n    integer, parameter :: max_users = 100\n    integer :: i\n    integer, dimension(max_users) :: followers\n    character(len=50), dimension(max_users) :: usernames\n    character(len=50), dimension(:), allocatable :: filtered_users\n\n    ! Example data initialization\n    followers = [1100, 500, 2000, 1500, 750]\n    usernames = ['user1', 'user2', 'user3', 'user4', 'user5']\n\n    ! Filter users\n    call filter_users_with_followers(followers, usernames, 1000, filtered_users)\n\n    ! Output filtered usernames\n    print *, 'Users with more than 1000 followers:'\n    do i = 1, size(filtered_users)\n        print *, filtered_users(i)\n    end do\n\ncontains\n\n    subroutine filter_users_with_followers(followers, usernames, threshold, result)\n        integer, intent(in) :: followers(:)\n        character(len=*), intent(in) :: usernames(:)\n        integer, intent(in) :: threshold\n        character(len=*), allocatable, intent(out) :: result(:)\n        integer :: count, i\n\n        allocate(result(size(followers)))\n        count = 0\n\n        do i = 1, size(followers)\n            if (followers(i) > threshold) then\n                count = count + 1\n                result(count) = usernames(i)\n            end if\n        end do\n\n        if (count > 0) then\n            call move_alloc(result(1:count), result)\n        else\n            deallocate(result)\n        end if\n    end subroutine filter_users_with_followers\n\nend program filter_users\n```"
  },
  {
    "task": "Identify all stocks with a growth rate above 10% from a financial portfolio.",
    "code": "```fortran\nprogram filter_stocks\n  implicit none\n  type :: Stock\n    character(len=100) :: name\n    real :: growth_rate\n  end type Stock\n\n  type(Stock), allocatable :: portfolio(:)\n  type(Stock), allocatable :: filtered_portfolio(:)\n  integer :: i, count\n\n  ! Example data\n  allocate(portfolio(5))\n  portfolio(1) = Stock('StockA', 15.0)\n  portfolio(2) = Stock('StockB', 8.0)\n  portfolio(3) = Stock('StockC', 12.5)\n  portfolio(4) = Stock('StockD', 7.5)\n  portfolio(5) = Stock('StockE', 20.0)\n\n  ! Filter stocks\n  count = 0\n  do i = 1, size(portfolio)\n    if (portfolio(i)%growth_rate > 10.0) then\n      count = count + 1\n    end if\n  end do\n\n  allocate(filtered_portfolio(count))\n  count = 0\n  do i = 1, size(portfolio)\n    if (portfolio(i)%growth_rate > 10.0) then\n      count = count + 1\n      filtered_portfolio(count) = portfolio(i)\n    end if\n  end do\n\n  ! Output filtered stocks\n  do i = 1, size(filtered_portfolio)\n    print *, 'Stock:', trimmed(filtered_portfolio(i)%name), &\n             'Growth Rate:', filtered_portfolio(i)%growth_rate\n  end do\n\nend program filter_stocks\n```"
  },
  {
    "task": "Extract all reviews that have a five-star rating from a product review site.",
    "code": "```fortran\nprogram filter_reviews\n    implicit none\n    integer, parameter :: n = 5\n    integer :: i\n    integer, dimension(n) :: ratings\n    character(len=100), dimension(n) :: reviews\n    character(len=100), dimension(:), allocatable :: five_star_reviews\n    \n    ! Sample data\n    ratings = [5, 4, 5, 3, 5]\n    reviews = [\"Excellent product!\", \"Good, but could improve.\", \"Loved it!\", \"Not bad.\", \"Best purchase ever!\"]\n\n    ! Allocate space for maximum potential five-star reviews\n    allocate(five_star_reviews(count(ratings == 5)))\n\n    ! Filter five-star reviews\n    five_star_reviews = pack(reviews, ratings == 5)\n\n    ! Output the five-star reviews\n    do i = 1, size(five_star_reviews)\n        print *, five_star_reviews(i)\n    end do\n\nend program filter_reviews\n```"
  },
  {
    "task": "Filter out all emails that are not flagged from an inbox.",
    "code": "```fortran\nprogram filter_emails\n  implicit none\n  type :: email\n     logical :: flagged\n     character(len=100) :: address\n  end type email\n\n  type(email), dimension(:), allocatable :: inbox, flagged_emails\n  integer :: i, count\n\n  ! Example inbox initialization\n  allocate(inbox(3))\n  inbox(1) = email(.true., 'flagged@example.com')\n  inbox(2) = email(.false., 'unflagged@example.com')\n  inbox(3) = email(.true., 'anotherflagged@example.com')\n\n  count = count([inbox(:)%flagged])\n  allocate(flagged_emails(count))\n  \n  flagged_emails = pack(inbox, inbox(:)%flagged)\n\n  do i = 1, count\n     print *, flagged_emails(i)%address\n  end do\nend program filter_emails\n```"
  },
  {
    "task": "Select all entries with a timestamp from the past 24 hours from a log file.",
    "code": "```fortran\nprogram filter_log\n    implicit none\n    integer, parameter :: max_entries = 1000\n    character(len=100) :: log_entries(max_entries)\n    character(len=100) :: filtered_entries(max_entries)\n    character(len=19) :: timestamp\n    integer :: i, num_entries, num_filtered\n    real :: current_time, entry_time\n\n    ! Simulate reading the log entries from a file\n    call read_log_entries(log_entries, num_entries)\n\n    current_time = get_current_time()\n    num_filtered = 0\n\n    do i = 1, num_entries\n        timestamp = log_entries(i)(1:19)\n        entry_time = parse_time(timestamp)\n        if (current_time - entry_time <= 24.0) then\n            num_filtered = num_filtered + 1\n            filtered_entries(num_filtered) = log_entries(i)\n        end if\n    end do\n\n    ! Output filtered entries\n    call output_entries(filtered_entries, num_filtered)\n\ncontains\n\n    subroutine read_log_entries(entries, num_entries)\n        character(len=100), dimension(max_entries) :: entries\n        integer :: num_entries\n        ! Dummy implementation\n        num_entries = 10\n        entries(1) = '2023-10-15 12:00:00 Log entry 1'\n        entries(2) = '2023-10-16 15:00:00 Log entry 2'\n        entries(3) = '2023-10-17 18:00:00 Log entry 3'\n        entries(4) = '2023-10-17 23:59:59 Log entry 4'\n        entries(5) = '2023-10-18 00:01:00 Log entry 5'\n        entries(6) = '2023-10-18 01:00:00 Log entry 6'\n        entries(7) = '2023-10-18 02:00:00 Log entry 7'\n        entries(8) = '2023-10-18 03:00:00 Log entry 8'\n        entries(9) = '2023-10-18 04:00:00 Log entry 9'\n        entries(10) = '2023-10-18 05:00:00 Log entry 10'\n    end subroutine read_log_entries\n\n    function get_current_time() result(time)\n        real :: time\n        ! Dummy implementation\n        time = 48.0  ! For example, 48.0 hours since a reference point\n    end function get_current_time\n\n    function parse_time(timestamp) result(time)\n        character(len=19) :: timestamp\n        real :: time\n        ! Dummy implementation to parse timestamp\n        ! Assume time is hours since a reference point\n        if (timestamp(1:4) == '2023') then\n            time = 24.0  ! Adjust this for actual time parsing\n        else\n            time = 0.0\n        end if\n    end function parse_time\n\n    subroutine output_entries(entries, num_entries)\n        character(len=100), dimension(max_entries) :: entries\n        integer :: num_entries\n        integer :: i\n        do i = 1, num_entries\n            print *, entries(i)\n        end do\n    end subroutine output_entries\n\nend program filter_log\n```"
  },
  {
    "task": "Find all books by a specific author from a library database.",
    "code": "```fortran\nmodule library_module\n  implicit none\n  type :: Book\n    character(len=:), allocatable :: title\n    character(len=:), allocatable :: author\n  end type Book\ncontains\n  function filter_books_by_author(books, author_name) result(filtered_books)\n    type(Book), intent(in) :: books(:)\n    character(len=*), intent(in) :: author_name\n    type(Book), allocatable :: filtered_books(:)\n    integer :: i, count\n\n    count = count_books_by_author(books, author_name)\n    allocate(filtered_books(count))\n\n    count = 0\n    do i = 1, size(books)\n      if (books(i)%author == author_name) then\n        count = count + 1\n        filtered_books(count) = books(i)\n      end if\n    end do\n  end function filter_books_by_author\n\n  function count_books_by_author(books, author_name) result(count)\n    type(Book), intent(in) :: books(:)\n    character(len=*), intent(in) :: author_name\n    integer :: count, i\n\n    count = 0\n    do i = 1, size(books)\n      if (books(i)%author == author_name) then\n        count = count + 1\n      end if\n    end do\n  end function count_books_by_author\nend module library_module\n```"
  },
  {
    "task": "Identify all donations above $500 from a charity fundraiser report.",
    "code": "```fortran\nprogram filter_donations\n  implicit none\n  real, dimension(:), allocatable :: donations\n  real, dimension(:), allocatable :: large_donations\n  integer :: i, count\n\n  ! Example donations array\n  donations = [100.0, 750.0, 250.0, 600.0, 50.0, 800.0]\n\n  count = 0\n\n  do i = 1, size(donations)\n     if (donations(i) > 500.0) then\n        count = count + 1\n     end if\n  end do\n\n  allocate(large_donations(count))\n  count = 0\n\n  do i = 1, size(donations)\n     if (donations(i) > 500.0) then\n        count = count + 1\n        large_donations(count) = donations(i)\n     end if\n  end do\n\n  print *, 'Donations above $500: ', large_donations\n\nend program filter_donations\n```"
  },
  {
    "task": "Extract all assignments due in the next week from a course syllabus.",
    "code": "```fortran\nprogram filter_assignments\n    implicit none\n    type :: Assignment\n        character(len=100) :: title\n        integer :: due_date\n    end type Assignment\n\n    type(Assignment), dimension(:), allocatable :: syllabus, upcoming\n    integer :: i, num_assignments\n\n    ! Example data\n    num_assignments = 5\n    allocate(syllabus(num_assignments))\n    syllabus(1) = Assignment('Assignment 1', 20231020)\n    syllabus(2) = Assignment('Assignment 2', 20231022)\n    syllabus(3) = Assignment('Assignment 3', 20231027)\n    syllabus(4) = Assignment('Assignment 4', 20231101)\n    syllabus(5) = Assignment('Assignment 5', 20231105)\n\n    ! Filter function\n    upcoming = pack(syllabus, (syllabus%due_date >= 20231020 .and. syllabus%due_date <= 20231027))\n\n    ! Output\n    do i = 1, size(upcoming)\n        print *, 'Title:', trim(upcoming(i)%title), 'Due Date:', upcoming(i)%due_date\n    end do\nend program filter_assignments\n```"
  },
  {
    "task": "Filter out all movies that are not in English from a streaming service.",
    "code": "```fortran\nprogram filter_movies\n    implicit none\n    type :: Movie\n        character(len=100) :: title\n        character(len=50) :: language\n    end type Movie\n\n    integer, parameter :: num_movies = 5\n    type(Movie), dimension(num_movies) :: movies\n    type(Movie), allocatable, dimension(:) :: filtered_movies\n    integer :: i, count\n\n    ! Example data\n    movies(1) = Movie('Movie 1', 'English')\n    movies(2) = Movie('Movie 2', 'Spanish')\n    movies(3) = Movie('Movie 3', 'English')\n    movies(4) = Movie('Movie 4', 'French')\n    movies(5) = Movie('Movie 5', 'English')\n\n    count = count_movies_in_english(movies)\n    allocate(filtered_movies(count))\n    call filter_english_movies(movies, filtered_movies)\n\n    print *, 'Filtered Movies:'\n    do i = 1, size(filtered_movies)\n        print *, trimmed(filtered_movies(i)%title)\n    end do\n\ncontains\n\n    function count_movies_in_english(movies) result(count)\n        type(Movie), dimension(:), intent(in) :: movies\n        integer :: count, i\n\n        count = 0\n        do i = 1, size(movies)\n            if (trim(movies(i)%language) == 'English') then\n                count = count + 1\n            end if\n        end do\n    end function count_movies_in_english\n\n    subroutine filter_english_movies(movies, filtered_movies)\n        type(Movie), dimension(:), intent(in) :: movies\n        type(Movie), dimension(:), intent(out) :: filtered_movies\n        integer :: i, j\n\n        j = 1\n        do i = 1, size(movies)\n            if (trim(movies(i)%language) == 'English') then\n                filtered_movies(j) = movies(i)\n                j = j + 1\n            end if\n        end do\n    end subroutine filter_english_movies\n\nend program filter_movies\n```"
  },
  {
    "task": "Select all landmarks located in Europe from a travel guide.",
    "code": "```fortran\nprogram filter_landmarks\n    implicit none\n    character(len=30), dimension(:), allocatable :: landmarks, europe_landmarks\n    integer :: i, count\n    \n    landmarks = [ &\n        'Eiffel Tower, France', &\n        'Statue of Liberty, USA', &\n        'Colosseum, Italy', &\n        'Great Wall, China', &\n        'Big Ben, UK' &\n    ]\n    \n    europe_landmarks = pack(landmarks, [ &\n        index(landmarks, 'France') > 0, & \n        index(landmarks, 'Italy') > 0, & \n        index(landmarks, 'UK') > 0 & \n    ])\n    \n    count = size(europe_landmarks)\n    \n    do i = 1, count\n        print *, trim(europe_landmarks(i))\n    end do\nend program filter_landmarks\n```"
  },
  {
    "task": "Find all contracts that are set to renew next month from a contract management system.",
    "code": "```fortran\nprogram contract_filter\n  implicit none\n  type :: Contract\n    integer :: id\n    integer :: renewal_month\n  end type Contract\n\n  type(Contract), dimension(:), allocatable :: contracts, renewing_contracts\n  integer :: i, count, current_month\n\n  ! Sample data for contracts\n  allocate(contracts(5))\n  contracts(1) = Contract(1, 10)\n  contracts(2) = Contract(2, 11)\n  contracts(3) = Contract(3, 11)\n  contracts(4) = Contract(4, 12)\n  contracts(5) = Contract(5, 1)\n\n  ! Assuming current month is October\n  current_month = 10\n\n  ! Functional filter\n  count = count([ (contracts(i)%renewal_month == mod(current_month + 1, 12), i = 1, size(contracts)) ])\n  allocate(renewing_contracts(count))\n  count = 0\n\n  do i = 1, size(contracts)\n    if (contracts(i)%renewal_month == mod(current_month + 1, 12)) then\n      count = count + 1\n      renewing_contracts(count) = contracts(i)\n    end if\n  end do\nend program contract_filter\n```"
  },
  {
    "task": "Identify all volunteer hours logged in the past year from a non-profit organization database.",
    "code": "```fortran\nmodule volunteer_filter\n  implicit none\ncontains\n  function filter_volunteer_hours(logged_hours, year) result(filtered_hours)\n    integer, intent(in) :: logged_hours(:,:)\n    integer, intent(in) :: year\n    integer, allocatable :: filtered_hours(:,:)\n    integer :: i, count\n\n    count = 0\n    do i = 1, size(logged_hours, 1)\n      if (logged_hours(i, 2) == year) then\n        count = count + 1\n      end if\n    end do\n\n    allocate(filtered_hours(count, 2))\n    count = 0\n    do i = 1, size(logged_hours, 1)\n      if (logged_hours(i, 2) == year) then\n        count = count + 1\n        filtered_hours(count, :) = logged_hours(i, :)\n      end if\n    end do\n  end function filter_volunteer_hours\nend module volunteer_filter\n\nprogram main\n  use volunteer_filter\n  implicit none\n  integer, allocatable :: hours(:,:)\n  integer, allocatable :: filtered(:,:)\n  integer :: i, n\n\n  ! Example input\n  allocate(hours(5, 2))\n  hours = reshape([8, 2023, 10, 2022, 5, 2023, 7, 2023, 4, 2021], &\n                  shape(hours))\n\n  filtered = filter_volunteer_hours(hours, 2023)\n\n  ! Output result\n  do i = 1, size(filtered, 1)\n    print *, filtered(i, 1), filtered(i, 2)\n  end do\n\nend program main\n```"
  },
  {
    "task": "Extract all elements that are not strings from a mixed-type list.",
    "code": "```fortran\nprogram filter_non_strings\n    implicit none\n    type :: variant_union\n        union\n            map\n                character(len=100) :: str\n                integer :: int\n                real :: dbl\n                logical :: lgl\n            end map\n        end union\n    end type variant_union\n\n    type(variant_union), dimension(:), allocatable :: mixed_list\n    integer :: i\n    logical :: is_string\n    integer, dimension(:), allocatable :: filtered_indices\n    type(variant_union), dimension(:), allocatable :: filtered_list\n\n    allocate(mixed_list(5))\n    mixed_list(1)%int = 42\n    mixed_list(2)%str = \"hello\"\n    mixed_list(3)%dbl = 3.14\n    mixed_list(4)%lgl = .true.\n    mixed_list(5)%str = \"world\"\n\n    filtered_indices = pack([(i, i = 1, size(mixed_list))], [(associated(mixed_list(i)%str), i = 1, size(mixed_list))], .false.)\n    allocate(filtered_list(size(filtered_indices)))\n    filtered_list = mixed_list(filtered_indices)\n\n    do i = 1, size(filtered_list)\n        select type (filtered_list(i))\n        type is (variant_union)\n            if (associated(filtered_list(i)%str)) cycle\n            if (associated(filtered_list(i)%int)) print *, \"Integer: \", filtered_list(i)%int\n            if (associated(filtered_list(i)%dbl)) print *, \"Real: \", filtered_list(i)%dbl\n            if (associated(filtered_list(i)%lgl)) print *, \"Logical: \", filtered_list(i)%lgl\n        end select\n    end do\nend program filter_non_strings\n```"
  },
  {
    "task": "Filter out all orders that are not yet shipped from an e-commerce system.",
    "code": "```fortran\nprogram filter_orders\n    implicit none\n    type :: Order\n        character(len=50) :: status\n        ! Additional fields can be added as needed\n    end type Order\n\n    type(Order), allocatable :: orders(:), shipped_orders(:)\n    integer :: i, count\n    \n    allocate(orders(5))  ! Example with 5 orders\n    orders(1)%status = 'Shipped'\n    orders(2)%status = 'Pending'\n    orders(3)%status = 'Shipped'\n    orders(4)%status = 'Processing'\n    orders(5)%status = 'Shipped'\n    \n    count = 0\n    do i = 1, size(orders)\n        if (orders(i)%status == 'Shipped') then\n            count = count + 1\n        end if\n    end do\n    \n    allocate(shipped_orders(count))\n    count = 0\n    do i = 1, size(orders)\n        if (orders(i)%status == 'Shipped') then\n            count = count + 1\n            shipped_orders(count) = orders(i)\n        end if\n    end do\n\n    ! Shipped orders are now stored in shipped_orders array\n\nend program filter_orders\n```"
  },
  {
    "task": "Select all emails sent from a specific address in an email server.",
    "code": "```fortran\nprogram filter_emails\n    implicit none\n\n    ! Sample data\n    character(len=100), dimension(5) :: emails\n    character(len=100) :: specific_sender\n    integer :: i\n\n    ! Initialize sample emails and specific sender\n    emails(1) = \"from:example1@example.com;subject:hello\"\n    emails(2) = \"from:example2@example.com;subject:hi\"\n    emails(3) = \"from:specific@example.com;subject:greetings\"\n    emails(4) = \"from:specific@example.com;subject:meeting\"\n    emails(5) = \"from:example1@example.com;subject:urgent\"\n\n    specific_sender = \"specific@example.com\"\n\n    ! Filter emails\n    do i = 1, size(emails)\n        if (index(emails(i), \"from:\" // specific_sender) /= 0) then\n            print *, trim(adjustl(emails(i)))\n        end if\n    end do\nend program filter_emails\n```"
  },
  {
    "task": "Find all passwords with at least one special character from a security database.",
    "code": "```fortran\nprogram filter_passwords\n  implicit none\n  character(len=100), dimension(10) :: passwords\n  character(len=100), dimension(:), allocatable :: filtered_passwords\n  integer :: i, count\n\n  passwords = [\"Passw0rd!\", \"123456\", \"Qwerty\", \"HelloWorld#\", \"Secure*Pass\", &\n               \"NoSpecial\", \"Special@Char\", \"Fortran123\", \"Code^123\", \"Test&Only\"]\n\n  count = 0\n  allocate(filtered_passwords(size(passwords)))\n\n  do i = 1, size(passwords)\n    if (has_special(passwords(i))) then\n      count = count + 1\n      filtered_passwords(count) = passwords(i)\n    end if\n  end do\n\n  if (count > 0) then\n    print *, 'Passwords with special characters:'\n    print *, filtered_passwords(1:count)\n  else\n    print *, 'No passwords with special characters found.'\n  end if\n\ncontains\n\n  logical function has_special(password)\n    character(len=*), intent(in) :: password\n    integer :: j\n    character(len=1), parameter :: special_chars = \"!@#$%^&*()-_=+[]{};:'\\\",.<>/?\\|`~\"\n\n    has_special = .false.\n    do j = 1, len(password)\n      if (index(special_chars, password(j:j)) > 0) then\n        has_special = .true.\n        return\n      end if\n    end do\n  end function has_special\n\nend program filter_passwords\n```"
  },
  {
    "task": "Identify all courses with a prerequisite from a university catalog.",
    "code": "```fortran\nprogram filter_courses\n  implicit none\n  type :: Course\n     character(len=100) :: name\n     character(len=100) :: prerequisite\n  end type Course\n\n  type(Course), dimension(:), allocatable :: catalog, filtered_courses\n  integer :: i, count\n\n  ! Sample data for demonstration\n  allocate(catalog(5))\n  catalog(1) = Course('Math 101', '')\n  catalog(2) = Course('Physics 101', 'Math 101')\n  catalog(3) = Course('Chemistry 101', '')\n  catalog(4) = Course('Biology 101', 'Chemistry 101')\n  catalog(5) = Course('English 101', '')\n\n  count = 0\n  do i = 1, size(catalog)\n     if (catalog(i)%prerequisite /= '') then\n        count = count + 1\n     end if\n  end do\n\n  allocate(filtered_courses(count))\n  count = 0\n  do i = 1, size(catalog)\n     if (catalog(i)%prerequisite /= '') then\n        count = count + 1\n        filtered_courses(count) = catalog(i)\n     end if\n  end do\n\n  do i = 1, size(filtered_courses)\n     print *, filtered_courses(i)%name\n  end do\n\nend program filter_courses\n```"
  },
  {
    "task": "Extract all genes associated with a specific trait from a genetic database.",
    "code": "```fortran\nmodule genetic_module\n  implicit none\n  private\n  public :: filter_genes\n\ncontains\n\n  function filter_genes(trait, genes, associated_traits) result(filtered_genes)\n    character(len=*), intent(in) :: trait\n    character(len=*), dimension(:), intent(in) :: genes\n    character(len=*), dimension(:), intent(in) :: associated_traits\n    character(len=:), allocatable :: filtered_genes(:)\n    integer :: i, count\n\n    count = 0\n    do i = 1, size(genes)\n      if (associated_traits(i) == trait) then\n        count = count + 1\n      end if\n    end do\n\n    allocate(character(len=32) :: filtered_genes(count))\n    count = 0\n    do i = 1, size(genes)\n      if (associated_traits(i) == trait) then\n        count = count + 1\n        filtered_genes(count) = genes(i)\n      end if\n    end do\n\n  end function filter_genes\n\nend module genetic_module\n```"
  },
  {
    "task": "Filter out all investments with a risk level below medium from a portfolio.",
    "code": "```fortran\nprogram filter_investments\n    implicit none\n    type :: Investment\n        character(len=20) :: name\n        character(len=10) :: risk_level\n    end type Investment\n\n    type(Investment), allocatable :: portfolio(:)\n    type(Investment), allocatable :: filtered_portfolio(:)\n    integer :: i, count\n\n    ! Sample portfolio\n    allocate(portfolio(5))\n    portfolio(1) = Investment(\"InvestmentA\", \"low\")\n    portfolio(2) = Investment(\"InvestmentB\", \"medium\")\n    portfolio(3) = Investment(\"InvestmentC\", \"high\")\n    portfolio(4) = Investment(\"InvestmentD\", \"medium\")\n    portfolio(5) = Investment(\"InvestmentE\", \"low\")\n\n    ! Functional filter\n    count = count_risky(portfolio)\n    allocate(filtered_portfolio(count))\n    call filter_risky(portfolio, filtered_portfolio)\n\ncontains\n\n    integer function count_risky(portfolio) result(count)\n        type(Investment), intent(in) :: portfolio(:)\n        integer :: i\n        count = 0\n        do i = 1, size(portfolio)\n            if (portfolio(i)%risk_level == 'medium' .or. portfolio(i)%risk_level == 'high') then\n                count = count + 1\n            end if\n        end do\n    end function count_risky\n\n    subroutine filter_risky(portfolio, filtered_portfolio)\n        type(Investment), intent(in) :: portfolio(:)\n        type(Investment), intent(out) :: filtered_portfolio(:)\n        integer :: i, j\n        j = 0\n        do i = 1, size(portfolio)\n            if (portfolio(i)%risk_level == 'medium' .or. portfolio(i)%risk_level == 'high') then\n                j = j + 1\n                filtered_portfolio(j) = portfolio(i)\n            end if\n        end do\n    end subroutine filter_risky\n\nend program filter_investments\n```"
  },
  {
    "task": "Select all calls longer than five minutes from a call log.",
    "code": "```fortran\nprogram filter_calls\n    implicit none\n    type :: CallRecord\n        real :: duration\n    end type CallRecord\n\n    type(CallRecord), allocatable :: callLog(:)\n    type(CallRecord), allocatable :: longCalls(:)\n    integer :: i, count\n\n    ! Example call log data\n    call allocate_call_log(callLog)\n\n    ! Filter calls longer than five minutes\n    count = 0\n    allocate(longCalls(size(callLog)))\n    do i = 1, size(callLog)\n        if (callLog(i)%duration > 5.0) then\n            count = count + 1\n            longCalls(count) = callLog(i)\n        end if\n    end do\n    if (count > 0) then\n        call move_alloc(longCalls, longCalls(1:count))\n    else\n        deallocate(longCalls)\n    end if\n\ncontains\n\n    subroutine allocate_call_log(log)\n        type(CallRecord), allocatable, intent(out) :: log(:)\n        allocate(log(5))\n        log(1)%duration = 3.0\n        log(2)%duration = 6.5\n        log(3)%duration = 4.0\n        log(4)%duration = 10.0\n        log(5)%duration = 7.2\n    end subroutine allocate_call_log\n\nend program filter_calls\n```"
  }
]