[
  {
    "task": "Create a function that initializes an array with the first ten prime numbers.",
    "code": "```fortran\nprogram primeArray\n    implicit none\n    integer, dimension(10) :: primes\n\n    call initializePrimes(primes)\n\ncontains\n\n    subroutine initializePrimes(primeArray)\n        integer, dimension(10), intent(out) :: primeArray\n        primeArray = (/ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29 /)\n    end subroutine initializePrimes\n\nend program primeArray\n```"
  },
  {
    "task": "Write a program to reverse the elements of a given array.",
    "code": "```fortran\nprogram reverse_array\n    implicit none\n    integer, parameter :: n = 5\n    integer :: arr(n) = [1, 2, 3, 4, 5]\n    integer :: i, temp\n\n    do i = 1, n / 2\n        temp = arr(i)\n        arr(i) = arr(n - i + 1)\n        arr(n - i + 1) = temp\n    end do\n\n    print *, \"Reversed array: \", arr\nend program reverse_array\n```"
  },
  {
    "task": "Implement an algorithm that finds the maximum value in an array of integers.",
    "code": "```fortran\nprogram find_max\n    implicit none\n    integer, parameter :: n = 10\n    integer :: array(n)\n    integer :: i, max_val\n\n    ! Example array\n    array = (/3, 1, 4, 1, 5, 9, 2, 6, 5, 3/)\n\n    ! Initialize max_val with the first element of the array\n    max_val = array(1)\n\n    ! Iterate over the array to find the maximum value\n    do i = 2, n\n        if (array(i) > max_val) then\n            max_val = array(i)\n        end if\n    end do\n\n    print *, \"The maximum value is:\", max_val\nend program find_max\n```"
  },
  {
    "task": "Design a routine to rotate an array to the right by a given number of steps.",
    "code": "```fortran\nprogram rotate_array\n  implicit none\n  integer, parameter :: n = 10\n  integer :: arr(n), rotated(n)\n  integer :: steps, i\n\n  ! Example array\n  arr = (/ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 /)\n  steps = 3  ! Number of steps to rotate\n\n  call rotate_right(arr, steps, rotated, n)\n\n  print *, 'Original array:', arr\n  print *, 'Rotated array:', rotated\n\ncontains\n\n  subroutine rotate_right(arr, steps, rotated, size)\n    integer, intent(in) :: arr(:)\n    integer, intent(in) :: steps, size\n    integer, intent(out) :: rotated(size)\n    integer :: i, shift\n\n    shift = mod(steps, size)\n\n    do i = 1, size\n      rotated(mod(i-1+shift, size) + 1) = arr(i)\n    end do\n  end subroutine rotate_right\n\nend program rotate_array\n```"
  },
  {
    "task": "Develop a function to merge two sorted arrays into one sorted array.",
    "code": "```fortran\nprogram merge_arrays\n  implicit none\n  integer, dimension(:), allocatable :: array1, array2, merged_array\n  integer :: n1, n2\n\n  ! Example input (can be replaced with other test data)\n  n1 = 5\n  n2 = 4\n  allocate(array1(n1))\n  allocate(array2(n2))\n  array1 = [1, 3, 5, 7, 9]\n  array2 = [2, 4, 6, 8]\n\n  merged_array = merge_sorted_arrays(array1, array2)\n  print *, merged_array\n\ncontains\n\n  function merge_sorted_arrays(arr1, arr2) result(merged)\n    integer, dimension(:), intent(in) :: arr1, arr2\n    integer, dimension(:), allocatable :: merged\n    integer :: i, j, k, n1, n2\n\n    n1 = size(arr1)\n    n2 = size(arr2)\n    allocate(merged(n1+n2))\n\n    i = 1\n    j = 1\n    k = 1\n\n    do while (i <= n1 .and. j <= n2)\n      if (arr1(i) <= arr2(j)) then\n        merged(k) = arr1(i)\n        i = i + 1\n      else\n        merged(k) = arr2(j)\n        j = j + 1\n      end if\n      k = k + 1\n    end do\n\n    if (i <= n1) then\n      merged(k:) = arr1(i:)\n    else if (j <= n2) then\n      merged(k:) = arr2(j:)\n    end if\n\n  end function merge_sorted_arrays\n\nend program merge_arrays\n```"
  },
  {
    "task": "Create a method to remove duplicate values from an array.",
    "code": "```fortran\nprogram remove_duplicates\n  implicit none\n  integer, parameter :: n = 10\n  integer :: original(n) = [1, 2, 2, 3, 4, 4, 5, 6, 6, 7]\n  integer :: unique(n)\n  integer :: i, j, k, count\n\n  call remove_duplicates_from_array(original, n, unique, count)\n\n  print *, 'Unique values: ', unique(1:count)\n\ncontains\n\n  subroutine remove_duplicates_from_array(arr, size, unique_arr, unique_count)\n    integer, intent(in) :: arr(size)\n    integer, intent(out) :: unique_arr(size)\n    integer, intent(out) :: unique_count\n    integer :: i, j, flag\n\n    unique_count = 0\n\n    do i = 1, size\n      flag = 0\n      do j = 1, unique_count\n        if (arr(i) == unique_arr(j)) then\n          flag = 1\n          exit\n        end if\n      end do\n      if (flag == 0) then\n        unique_count = unique_count + 1\n        unique_arr(unique_count) = arr(i)\n      end if\n    end do\n  end subroutine remove_duplicates_from_array\n\nend program remove_duplicates\n```"
  },
  {
    "task": "Write a script to calculate the sum of all elements in an array.",
    "code": "```fortran\nprogram sum_array\n    implicit none\n    integer, parameter :: n = 5\n    integer :: i\n    integer, dimension(n) :: array\n    integer :: total_sum\n\n    ! Example array initialization\n    array = (/ 1, 2, 3, 4, 5 /)\n\n    total_sum = 0\n    do i = 1, n\n        total_sum = total_sum + array(i)\n    end do\n\n    print *, 'The sum of the array elements is:', total_sum\nend program sum_array\n```"
  },
  {
    "task": "Construct a function that finds the second largest element in an array.",
    "code": "```fortran\nfunction second_largest(arr, n) result(second_max)\n    integer, intent(in) :: arr(:)\n    integer, intent(in) :: n\n    integer :: second_max\n    integer :: i, max1, max2\n\n    if (n < 2) then\n        second_max = -1\n        return\n    end if\n\n    max1 = max(arr(1), arr(2))\n    max2 = min(arr(1), arr(2))\n\n    do i = 3, n\n        if (arr(i) > max1) then\n            max2 = max1\n            max1 = arr(i)\n        else if (arr(i) > max2 .and. arr(i) /= max1) then\n            max2 = arr(i)\n        end if\n    end do\n\n    if (max1 == max2) then\n        second_max = -1\n    else\n        second_max = max2\n    end if\nend function second_largest\n```"
  },
  {
    "task": "Design a program to check if an array contains a specific value.",
    "code": "```fortran\nprogram check_array_value\n  implicit none\n  integer, parameter :: n = 10\n  integer :: arr(n) = (/ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 /)\n  integer :: i, value\n  logical :: found\n\n  value = 5\n  found = .false.\n\n  do i = 1, n\n    if (arr(i) == value) then\n      found = .true.\n      exit\n    end if\n  end do\n\n  if (found) then\n    print *, \"Value found in array.\"\n  else\n    print *, \"Value not found in array.\"\n  end if\nend program check_array_value\n```"
  },
  {
    "task": "Implement a function to sort an array of strings alphabetically.",
    "code": "```fortran\nmodule string_sort_module\ncontains\n    subroutine sort_strings(arr, n)\n        implicit none\n        character(len=*), dimension(:), intent(inout) :: arr\n        integer, intent(in) :: n\n        integer :: i, j\n        character(len=100) :: temp\n\n        do i = 1, n-1\n            do j = i+1, n\n                if (arr(i) > arr(j)) then\n                    temp = arr(i)\n                    arr(i) = arr(j)\n                    arr(j) = temp\n                end if\n            end do\n        end do\n    end subroutine sort_strings\nend module string_sort_module\n```"
  },
  {
    "task": "Create a method to search for a value in an array using binary search.",
    "code": "```fortran\nmodule binary_search_module\n  implicit none\ncontains\n  function binary_search(arr, target) result(index)\n    integer, intent(in) :: arr(:)\n    integer, intent(in) :: target\n    integer :: index\n    integer :: left, right, mid\n\n    left = 1\n    right = size(arr)\n    index = -1\n\n    do while (left <= right)\n      mid = left + (right - left) / 2\n      if (arr(mid) == target) then\n        index = mid\n        return\n      else if (arr(mid) < target) then\n        left = mid + 1\n      else\n        right = mid - 1\n      end if\n    end do\n  end function binary_search\nend module binary_search_module\n```"
  },
  {
    "task": "Write a routine to calculate the average of numbers in an array.",
    "code": "```fortran\nprogram average_calculation\n    implicit none\n    real, dimension(:), allocatable :: numbers\n    real :: avg\n    integer :: n, i\n\n    ! Example array size\n    n = 5\n    allocate(numbers(n))\n\n    ! Example array initialization\n    numbers = (/ 10.0, 20.0, 30.0, 40.0, 50.0 /)\n\n    avg = calculate_average(numbers)\n    print *, \"The average is:\", avg\n\ncontains\n\n    function calculate_average(arr) result(avg)\n        real, dimension(:), intent(in) :: arr\n        real :: avg\n        integer :: i, size_arr\n\n        size_arr = size(arr)\n        avg = sum(arr) / size_arr\n    end function calculate_average\n\nend program average_calculation\n```"
  },
  {
    "task": "Develop a function to find the intersection of two arrays.",
    "code": "```fortran\nprogram array_intersection\n  implicit none\n  integer, parameter :: n = 5\n  integer :: array1(n) = [1, 2, 3, 4, 5]\n  integer :: array2(n) = [3, 4, 5, 6, 7]\n  integer :: result(n)\n  integer :: i, count\n\n  count = 0\n  call find_intersection(array1, array2, result, count)\n\n  print *, \"Intersection:\"\n  do i = 1, count\n     print *, result(i)\n  end do\n\ncontains\n\n  subroutine find_intersection(arr1, arr2, result, count)\n    integer, intent(in) :: arr1(:), arr2(:)\n    integer, intent(out) :: result(size(arr1))\n    integer, intent(out) :: count\n    integer :: i, j\n\n    count = 0\n    do i = 1, size(arr1)\n       do j = 1, size(arr2)\n          if (arr1(i) == arr2(j)) then\n             count = count + 1\n             result(count) = arr1(i)\n             exit\n          end if\n       end do\n    end do\n  end subroutine find_intersection\n\nend program array_intersection\n```"
  },
  {
    "task": "Implement a method to find the union of two arrays without duplicates.",
    "code": "```fortran\nprogram array_union\n  implicit none\n  integer, allocatable :: array1(:), array2(:), union_array(:)\n  integer :: i, j, n1, n2, count, found\n\n  ! Sample input arrays\n  array1 = [1, 2, 3, 4]\n  array2 = [3, 4, 5, 6]\n\n  n1 = size(array1)\n  n2 = size(array2)\n\n  allocate(union_array(n1 + n2))\n  count = 0\n\n  ! Add elements of the first array to the union\n  do i = 1, n1\n     union_array(count + 1) = array1(i)\n     count = count + 1\n  end do\n\n  ! Add elements of the second array to the union if not already present\n  do i = 1, n2\n     found = 0\n     do j = 1, count\n        if (array2(i) == union_array(j)) then\n           found = 1\n           exit\n        end if\n     end do\n     if (found == 0) then\n        union_array(count + 1) = array2(i)\n        count = count + 1\n     end if\n  end do\n\n  ! Resize the array to the actual number of unique elements\n  call move_alloc(union_array, union_array(1:count))\n\n  ! Output the union array\n  print *, union_array\n\nend program array_union\n```"
  },
  {
    "task": "Create a program that shifts all zeroes in an array to the end.",
    "code": "```fortran\nprogram shift_zeroes\n    implicit none\n    integer, parameter :: n = 10\n    integer :: arr(n) = [1, 0, 2, 0, 3, 4, 0, 5, 6, 0]\n    integer :: temp(n)\n    integer :: i, j\n\n    j = 1\n    do i = 1, n\n        if (arr(i) /= 0) then\n            temp(j) = arr(i)\n            j = j + 1\n        end if\n    end do\n\n    do i = j, n\n        temp(i) = 0\n    end do\n\n    arr = temp\n\n    print *, \"Array after shifting zeroes to the end:\"\n    print *, arr\nend program shift_zeroes\n```"
  },
  {
    "task": "Write a function to split an array into two parts at a given index.",
    "code": "```fortran\nmodule array_splitter\ncontains\n    subroutine split_array(arr, index, part1, part2)\n        integer, dimension(:), intent(in) :: arr\n        integer, intent(in) :: index\n        integer, dimension(:), allocatable, intent(out) :: part1, part2\n        \n        allocate(part1(index))\n        allocate(part2(size(arr) - index))\n        \n        part1 = arr(1:index)\n        part2 = arr(index+1:size(arr))\n    end subroutine split_array\nend module array_splitter\n```"
  },
  {
    "task": "Design a script to find all pairs in an array that sum up to a specific target.",
    "code": "```fortran\nprogram find_pairs\n  implicit none\n  integer, parameter :: n = 10\n  integer :: arr(n) = [2, 4, 3, 5, 7, 8, 9, 1, 6, 0]\n  integer :: target, i, j\n\n  target = 10\n\n  do i = 1, n-1\n     do j = i+1, n\n        if (arr(i) + arr(j) == target) then\n           print *, \"Pair found: \", arr(i), arr(j)\n        end if\n     end do\n  end do\nend program find_pairs\n```"
  },
  {
    "task": "Construct a method to remove all occurrences of a specific value from an array.",
    "code": "```fortran\nprogram remove_value\n  implicit none\n  real, dimension(:), allocatable :: array, new_array\n  real :: value\n  integer :: i, j, n, count\n\n  ! Sample data\n  array = [1.0, 2.0, 3.0, 2.0, 4.0, 2.0]\n  value = 2.0\n\n  n = size(array)\n  count = count(array /= value)\n\n  allocate(new_array(count))\n  j = 1\n  do i = 1, n\n    if (array(i) /= value) then\n      new_array(j) = array(i)\n      j = j + 1\n    end if\n  end do\n\n  print *, \"Original array: \", array\n  print *, \"New array after removal: \", new_array\n\n  deallocate(array)\n  deallocate(new_array)\nend program remove_value\n```"
  },
  {
    "task": "Write a function to find the longest increasing subsequence in an array.",
    "code": "```fortran\nprogram longest_increasing_subsequence\n  implicit none\n  integer, parameter :: n = 10\n  integer :: input_array(n) = [10, 22, 9, 33, 21, 50, 41, 60, 80, 7]\n  integer :: lis_length\n\n  lis_length = find_lis(input_array, n)\n  print *, \"Length of LIS is: \", lis_length\n\ncontains\n\n  integer function find_lis(arr, size)\n    integer, intent(in) :: arr(:)\n    integer, intent(in) :: size\n    integer :: lis(size), i, j\n\n    lis = 1\n    do i = 2, size\n      do j = 1, i - 1\n        if (arr(i) > arr(j) .and. lis(i) < lis(j) + 1) then\n          lis(i) = lis(j) + 1\n        end if\n      end do\n    end do\n\n    find_lis = maxval(lis)\n  end function find_lis\n\nend program longest_increasing_subsequence\n```"
  },
  {
    "task": "Develop an algorithm to find the missing number in a sequential array.",
    "code": "```fortran\nprogram find_missing_number\n  implicit none\n  integer, parameter :: n = 10\n  integer :: array(n-1)\n  integer :: total, sum, missing, i\n\n  ! Assume array is a sequential array from 1 to 10 with one missing number\n  array = (/ 1, 2, 3, 4, 6, 7, 8, 9, 10 /)\n\n  total = n * (n + 1) / 2\n  sum = 0\n\n  do i = 1, n-1\n     sum = sum + array(i)\n  end do\n\n  missing = total - sum\n  print *, 'The missing number is:', missing\n\nend program find_missing_number\n```"
  },
  {
    "task": "Create a program to find the common elements between two arrays.",
    "code": "```fortran\nprogram find_common_elements\n    implicit none\n    integer, parameter :: n = 5\n    integer :: i, j\n    integer :: array1(n) = [1, 2, 3, 4, 5]\n    integer :: array2(n) = [3, 4, 5, 6, 7]\n    logical :: found\n\n    print *, \"Common elements are:\"\n    do i = 1, n\n        found = .false.\n        do j = 1, n\n            if (array1(i) == array2(j)) then\n                found = .true.\n                exit\n            end if\n        end do\n        if (found) then\n            print *, array1(i)\n        end if\n    end do\nend program find_common_elements\n```"
  },
  {
    "task": "Implement a function to move all negative numbers to the beginning of an array.",
    "code": "```fortran\nprogram move_negatives\n    implicit none\n    integer, parameter :: n = 10\n    integer :: arr(n) = [3, -7, 2, -5, 11, 0, -1, 4, -9, 6]\n    integer :: result(n)\n\n    call move_negatives_to_front(arr, result, n)\n    print *, result\ncontains\n    subroutine move_negatives_to_front(arr, result, n)\n        integer, intent(in) :: arr(:)\n        integer, intent(out) :: result(:)\n        integer, intent(in) :: n\n        integer :: i, neg_index, pos_index\n\n        neg_index = 1\n        pos_index = 1\n        \n        ! Move negative numbers to the front\n        do i = 1, n\n            if (arr(i) < 0) then\n                result(neg_index) = arr(i)\n                neg_index = neg_index + 1\n            end if\n        end do\n\n        ! Append non-negative numbers after negative numbers\n        do i = 1, n\n            if (arr(i) >= 0) then\n                result(neg_index) = arr(i)\n                neg_index = neg_index + 1\n            end if\n        end do\n    end subroutine move_negatives_to_front\nend program move_negatives\n```"
  },
  {
    "task": "Write a method to check if an array is a palindrome.",
    "code": "```fortran\nprogram check_palindrome\n    implicit none\n    integer, parameter :: n = 5\n    integer :: arr(n) = [1, 2, 3, 2, 1]\n    logical :: is_palindrome\n\n    is_palindrome = check_if_palindrome(arr, n)\n    print *, 'Is palindrome:', is_palindrome\ncontains\n    logical function check_if_palindrome(array, size)\n        integer, intent(in) :: array(:)\n        integer, intent(in) :: size\n        integer :: i\n\n        check_if_palindrome = .true.\n        do i = 1, size / 2\n            if (array(i) /= array(size - i + 1)) then\n                check_if_palindrome = .false.\n                exit\n            end if\n        end do\n    end function check_if_palindrome\nend program check_palindrome\n```"
  },
  {
    "task": "Design a routine to create a new array that is the element-wise sum of two input arrays.",
    "code": "```fortran\nprogram ArraySum\n    implicit none\n    integer, parameter :: n = 10\n    integer :: i\n    integer :: array1(n), array2(n), sumArray(n)\n\n    ! Initialize arrays\n    array1 = (/ (i, i = 1, n) /)\n    array2 = (/ (i, i = 1, n) /)\n\n    call elementWiseSum(array1, array2, sumArray, n)\n\n    print *, \"Sum of arrays:\", sumArray\n\ncontains\n\n    subroutine elementWiseSum(arr1, arr2, result, size)\n        integer, intent(in) :: arr1(size), arr2(size)\n        integer, intent(out) :: result(size)\n        integer, intent(in) :: size\n        integer :: i\n\n        do i = 1, size\n            result(i) = arr1(i) + arr2(i)\n        end do\n    end subroutine elementWiseSum\n\nend program ArraySum\n```"
  },
  {
    "task": "Create a function to find the product of all elements in an array, excluding the current element.",
    "code": "```fortran\nprogram ArrayProductExcludingCurrent\n    implicit none\n    real, dimension(:), allocatable :: inputArray, resultArray\n    integer :: n, i\n\n    print *, 'Enter the size of the array:'\n    read *, n\n    allocate(inputArray(n), resultArray(n))\n\n    print *, 'Enter the elements of the array:'\n    read *, inputArray\n\n    call computeProductExcludingCurrent(inputArray, resultArray, n)\n\n    print *, 'Product of all elements excluding the current element:'\n    print *, resultArray\n\ncontains\n\n    subroutine computeProductExcludingCurrent(arr, result, size)\n        real, dimension(size), intent(in) :: arr\n        real, dimension(size), intent(out) :: result\n        integer, intent(in) :: size\n        real :: totalProduct\n        integer :: i\n\n        totalProduct = 1.0\n        do i = 1, size\n            totalProduct = totalProduct * arr(i)\n        end do\n\n        do i = 1, size\n            if (arr(i) /= 0.0) then\n                result(i) = totalProduct / arr(i)\n            else\n                result(i) = 1.0\n                do j = 1, size\n                    if (i /= j) result(i) = result(i) * arr(j)\n                end do\n            end if\n        end do\n    end subroutine computeProductExcludingCurrent\n\nend program ArrayProductExcludingCurrent\n```"
  },
  {
    "task": "Develop a script to remove elements from an array that are smaller than a given threshold.",
    "code": "```fortran\nprogram remove_below_threshold\n    implicit none\n    integer, parameter :: n = 10\n    real :: array(n) = [1.5, 3.2, 5.1, 2.5, 0.9, 4.4, 6.7, 1.0, 8.3, 3.3]\n    real :: threshold\n    integer :: i, count\n    real, allocatable :: new_array(:)\n\n    threshold = 3.0\n    count = 0\n\n    do i = 1, n\n        if (array(i) >= threshold) then\n            count = count + 1\n        end if\n    end do\n\n    allocate(new_array(count))\n    count = 0\n\n    do i = 1, n\n        if (array(i) >= threshold) then\n            count = count + 1\n            new_array(count) = array(i)\n        end if\n    end do\n\n    print *, \"Filtered array:\"\n    print *, new_array\n\n    deallocate(new_array)\nend program remove_below_threshold\n```"
  },
  {
    "task": "Implement a method to clone an array without using built-in functions.",
    "code": "```fortran\nprogram clone_array\n    implicit none\n    integer, parameter :: n = 5\n    integer :: original(n) = (/ 1, 2, 3, 4, 5 /)\n    integer :: cloned(n)\n    integer :: i\n\n    call cloneArray(original, cloned, n)\n\n    print *, 'Original Array: ', original\n    print *, 'Cloned Array: ', cloned\n\ncontains\n\n    subroutine cloneArray(source, destination, size)\n        integer, intent(in) :: source(:)\n        integer, intent(out) :: destination(:)\n        integer, intent(in) :: size\n        integer :: i\n\n        do i = 1, size\n            destination(i) = source(i)\n        end do\n    end subroutine cloneArray\n\nend program clone_array\n```"
  },
  {
    "task": "Create a program that rotates a 2D array (matrix) 90 degrees clockwise.",
    "code": "```fortran\nprogram rotate_matrix\n    implicit none\n    integer, parameter :: n = 3\n    integer :: i, j\n    integer :: matrix(n, n), rotated_matrix(n, n)\n\n    ! Sample 3x3 matrix initialization\n    matrix = reshape([1, 2, 3, 4, 5, 6, 7, 8, 9], shape(matrix))\n\n    ! Rotate 90 degrees clockwise\n    do i = 1, n\n        do j = 1, n\n            rotated_matrix(j, n-i+1) = matrix(i, j)\n        end do\n    end do\n\n    ! Output the original and rotated matrices\n    print *, \"Original Matrix:\"\n    do i = 1, n\n        print *, (matrix(i, j), j = 1, n)\n    end do\n\n    print *, \"Rotated Matrix:\"\n    do i = 1, n\n        print *, (rotated_matrix(i, j), j = 1, n)\n    end do\n\nend program rotate_matrix\n```"
  },
  {
    "task": "Write a function to find the kth smallest element in an unsorted array.",
    "code": "```fortran\nmodule array_utils\ncontains\n    function kth_smallest(arr, n, k) result(smallest)\n        integer, intent(in) :: arr(:)\n        integer, intent(in) :: n, k\n        integer :: smallest, sorted_arr(n)\n        integer :: i, j, temp\n\n        sorted_arr = arr\n\n        ! Sort the array using a simple bubble sort\n        do i = 1, n - 1\n            do j = 1, n - i\n                if (sorted_arr(j) > sorted_arr(j + 1)) then\n                    temp = sorted_arr(j)\n                    sorted_arr(j) = sorted_arr(j + 1)\n                    sorted_arr(j + 1) = temp\n                end if\n            end do\n        end do\n\n        ! Return the k-th smallest element\n        smallest = sorted_arr(k)\n    end function kth_smallest\nend module array_utils\n```"
  },
  {
    "task": "Design a routine to partition an array into even and odd numbers.",
    "code": "```fortran\nprogram partition_array\n    implicit none\n    integer, allocatable :: array(:)\n    integer, allocatable :: evens(:), odds(:)\n    integer :: i, n, neven, nodd\n\n    ! Initialize the array with some values\n    n = 10\n    allocate(array(n))\n    array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n    ! Determine counts for even and odd numbers\n    neven = count(mod(array, 2) == 0)\n    nodd = count(mod(array, 2) /= 0)\n\n    ! Allocate arrays for even and odd numbers\n    allocate(evens(neven), odds(nodd))\n\n    ! Partition the array into evens and odds\n    evens = pack(array, mod(array, 2) == 0)\n    odds = pack(array, mod(array, 2) /= 0)\n\n    ! Output results\n    print *, 'Original Array: ', array\n    print *, 'Even Numbers: ', evens\n    print *, 'Odd Numbers: ', odds\n\n    ! Deallocate arrays\n    deallocate(array, evens, odds)\nend program partition_array\n```"
  },
  {
    "task": "Create a method to merge overlapping intervals in an array.",
    "code": "```fortran\nprogram merge_intervals\n    implicit none\n    integer, parameter :: n = 5, m = 2\n    integer :: i, j, k, temp\n    integer, dimension(n, m) :: intervals = reshape([1, 3, 2, 4, 5, 7, 6, 8, 9, 10], [n, m])\n    integer, dimension(n, m) :: merged_intervals\n    logical :: overlap\n\n    ! Sort intervals based on the start time\n    do i = 1, n - 1\n        do j = i + 1, n\n            if (intervals(i, 1) > intervals(j, 1)) then\n                do k = 1, m\n                    temp = intervals(i, k)\n                    intervals(i, k) = intervals(j, k)\n                    intervals(j, k) = temp\n                end do\n            end if\n        end do\n    end do\n\n    ! Merge overlapping intervals\n    k = 1\n    merged_intervals(k, :) = intervals(1, :)\n    do i = 2, n\n        overlap = merged_intervals(k, 2) >= intervals(i, 1)\n        if (overlap) then\n            merged_intervals(k, 2) = max(merged_intervals(k, 2), intervals(i, 2))\n        else\n            k = k + 1\n            merged_intervals(k, :) = intervals(i, :)\n        end if\n    end do\n\n    ! Output merged intervals\n    do i = 1, k\n        print *, merged_intervals(i, 1), merged_intervals(i, 2)\n    end do\nend program merge_intervals\n```"
  },
  {
    "task": "Develop a function to count the frequency of each unique element in an array.",
    "code": "```fortran\nmodule array_utils\n  implicit none\ncontains\n  subroutine count_frequencies(arr, unique_elements, frequencies, n_unique)\n    integer, intent(in) :: arr(:)\n    integer, intent(out) :: unique_elements(:)\n    integer, intent(out) :: frequencies(:)\n    integer, intent(out) :: n_unique\n    integer :: i, j, n, count\n    logical :: is_unique\n    \n    n = size(arr)\n    n_unique = 0\n\n    do i = 1, n\n      is_unique = .true.\n      do j = 1, n_unique\n        if (arr(i) == unique_elements(j)) then\n          frequencies(j) = frequencies(j) + 1\n          is_unique = .false.\n          exit\n        end if\n      end do\n      if (is_unique) then\n        n_unique = n_unique + 1\n        unique_elements(n_unique) = arr(i)\n        frequencies(n_unique) = 1\n      end if\n    end do\n  end subroutine count_frequencies\nend module array_utils\n```"
  },
  {
    "task": "Write a program to generate all possible subsets of an array.",
    "code": "```fortran\nprogram generate_subsets\n  implicit none\n  integer, parameter :: n = 3\n  integer :: arr(n) = [1, 2, 3]\n  integer :: num_subsets, subset_mask, i\n\n  num_subsets = 2**n\n\n  do subset_mask = 0, num_subsets - 1\n    write(*, \"(A)\", advance=\"no\") \"Subset: {\"\n    do i = 0, n - 1\n      if (iand(subset_mask, 2**i) /= 0) then\n        write(*, \"(I0)\", advance=\"no\") arr(i + 1)\n        if (i < n - 1 .and. iand(subset_mask, 2**(i+1)) /= 0) write(*, \"(A)\", advance=\"no\") \", \"\n      end if\n    end do\n    write(*, \"(A)\") \"}\"\n  end do\nend program generate_subsets\n```"
  },
  {
    "task": "Implement a routine to cyclically permute the elements of an array.",
    "code": "```fortran\nsubroutine cyclic_permute(arr, n)\n    integer, intent(inout) :: arr(:)\n    integer, intent(in) :: n\n    integer :: i, temp\n\n    if (n > 1) then\n        temp = arr(n)\n        do i = n, 2, -1\n            arr(i) = arr(i-1)\n        end do\n        arr(1) = temp\n    end if\nend subroutine cyclic_permute\n```"
  },
  {
    "task": "Create a function that checks if two arrays are equal regardless of element order.",
    "code": "```fortran\nprogram check_arrays_equal\n  implicit none\n\n  logical :: arraysEqual\n  integer, allocatable :: arr1(:), arr2(:)\n\n  ! Example arrays\n  allocate(arr1(3), arr2(3))\n  arr1 = [3, 1, 2]\n  arr2 = [2, 3, 1]\n\n  arraysEqual = are_arrays_equal(arr1, arr2)\n\n  print *, \"Arrays equal:\", arraysEqual\n\ncontains\n\n  logical function are_arrays_equal(a, b)\n    integer, intent(in) :: a(:), b(:)\n    integer :: sizeA, sizeB\n\n    sizeA = size(a)\n    sizeB = size(b)\n\n    if (sizeA /= sizeB) then\n      are_arrays_equal = .false.\n      return\n    end if\n\n    ! Sort both arrays\n    call sort_array(a)\n    call sort_array(b)\n\n    ! Compare sorted arrays\n    are_arrays_equal = all(a == b)\n  end function are_arrays_equal\n\n  subroutine sort_array(array)\n    integer, intent(inout) :: array(:)\n    integer :: i, j, temp, n\n\n    n = size(array)\n\n    do i = 1, n-1\n      do j = i+1, n\n        if (array(i) > array(j)) then\n          temp = array(i)\n          array(i) = array(j)\n          array(j) = temp\n        end if\n      end do\n    end do\n  end subroutine sort_array\n\nend program check_arrays_equal\n```"
  },
  {
    "task": "Design a script to initialize an array with random integers within a specified range.",
    "code": "```fortran\nprogram initialize_random_array\n  implicit none\n  integer, parameter :: n = 10\n  integer :: i, lower, upper\n  integer, dimension(n) :: array\n  call random_seed()\n  lower = 1\n  upper = 100\n\n  do i = 1, n\n     call random_number(array(i))\n     array(i) = int(array(i) * (upper - lower + 1)) + lower\n  end do\n\n  print *, array\nend program initialize_random_array\n```"
  },
  {
    "task": "Write a method to convert an array of integers to a single concatenated number.",
    "code": "```fortran\nprogram concatenate_array\n    implicit none\n    integer, dimension(:), allocatable :: num_array\n    integer :: i, n\n    character(len=200) :: result\n\n    ! Initialize array\n    print *, \"Enter the number of elements:\"\n    read *, n\n    allocate(num_array(n))\n    \n    print *, \"Enter the elements:\"\n    do i = 1, n\n        read *, num_array(i)\n    end do\n    \n    ! Convert array to concatenated number\n    result = ''\n    do i = 1, n\n        write(result(len_trim(result)+1:), '(I0)') num_array(i)\n    end do\n    \n    print *, \"Concatenated number is:\", result\n\nend program concatenate_array\n```"
  },
  {
    "task": "Develop a function to find the median value of an unsorted array.",
    "code": "```fortran\nmodule median_module\ncontains\n    real function find_median(arr, n)\n        real, intent(in) :: arr(:)\n        integer, intent(in) :: n\n        real :: sorted_arr(n)\n        integer :: i, j\n        real :: temp\n\n        sorted_arr = arr\n\n        ! Sort the array using a simple bubble sort\n        do i = 1, n-1\n            do j = 1, n-i\n                if (sorted_arr(j) > sorted_arr(j+1)) then\n                    temp = sorted_arr(j)\n                    sorted_arr(j) = sorted_arr(j+1)\n                    sorted_arr(j+1) = temp\n                end if\n            end do\n        end do\n\n        ! Calculate median\n        if (mod(n, 2) == 0) then\n            find_median = (sorted_arr(n/2) + sorted_arr(n/2 + 1)) / 2.0\n        else\n            find_median = sorted_arr((n+1)/2)\n        end if\n    end function find_median\nend module median_module\n```"
  },
  {
    "task": "Create a routine to determine if an array is sorted in ascending order.",
    "code": "```fortran\nlogical function is_sorted(arr, n)\n    integer, intent(in) :: n\n    real, intent(in) :: arr(n)\n    integer :: i\n\n    is_sorted = .true.\n    do i = 1, n - 1\n        if (arr(i) > arr(i + 1)) then\n            is_sorted = .false.\n            return\n        end if\n    end do\nend function is_sorted\n```"
  },
  {
    "task": "Implement a method to find the longest contiguous subarray with equal number of 0s and 1s.",
    "code": "```fortran\nprogram longest_subarray\n    implicit none\n    integer, parameter :: n = 1000\n    integer :: a(n), prefix_sum(n+1)\n    integer :: i, max_length, sum, start_index, end_index\n\n    ! Initialize the array with some values of 0s and 1s\n    call random_seed()\n    call random_number(a)\n    a = merge(0, 1, a < 0.5)\n\n    ! Initialize prefix_sum\n    prefix_sum(1) = 0\n    do i = 1, n\n        prefix_sum(i+1) = prefix_sum(i) + merge(-1, 1, a(i) == 1)\n    end do\n\n    ! Find the longest subarray with equal 0s and 1s\n    max_length = 0\n    do i = 1, n\n        do j = i, n\n            if (prefix_sum(j+1) - prefix_sum(i) == 0) then\n                if (j-i+1 > max_length) then\n                    max_length = j-i+1\n                    start_index = i\n                    end_index = j\n                end if\n            end if\n        end do\n    end do\n\n    print *, \"Longest subarray with equal 0s and 1s:\"\n    print *, \"Start Index:\", start_index, \"End Index:\", end_index\n    print *, \"Length:\", max_length\n\nend program longest_subarray\n```"
  },
  {
    "task": "Write a function to interleave two arrays of equal length.",
    "code": "```fortran\nmodule array_interleave\ncontains\n    subroutine interleave_arrays(arr1, arr2, result)\n        implicit none\n        integer, allocatable, intent(in) :: arr1(:), arr2(:)\n        integer, allocatable, intent(out) :: result(:)\n        integer :: i, n\n        \n        n = size(arr1)\n        allocate(result(2*n))\n        \n        do i = 1, n\n            result(2*i - 1) = arr1(i)\n            result(2*i) = arr2(i)\n        end do\n    end subroutine interleave_arrays\nend module array_interleave\n```"
  },
  {
    "task": "Design a program to replace each element in an array with the next greatest element.",
    "code": "```fortran\nprogram replace_with_next_greatest\n    implicit none\n    integer, parameter :: n = 5\n    integer :: arr(n) = [16, 17, 4, 3, 5]\n    integer :: i, max_from_right\n\n    max_from_right = -1\n    do i = n, 1, -1\n        if (arr(i) > max_from_right) then\n            max_from_right = arr(i)\n        endif\n        arr(i) = max_from_right\n    end do\n\n    ! Output the modified array\n    do i = 1, n\n        print *, arr(i)\n    end do\nend program replace_with_next_greatest\n```"
  },
  {
    "task": "Create a function to calculate the dot product of two numeric arrays.",
    "code": "```fortran\nfunction dot_product(n, array1, array2) result(dot)\n    integer, intent(in) :: n\n    real, dimension(n), intent(in) :: array1, array2\n    real :: dot\n    integer :: i\n\n    dot = 0.0\n    do i = 1, n\n        dot = dot + array1(i) * array2(i)\n    end do\nend function dot_product\n```"
  },
  {
    "task": "Develop a script to find the first recurring element in an array.",
    "code": "```fortran\nprogram first_recurring_element\n    implicit none\n    integer, parameter :: n = 10\n    integer :: arr(n) = [3, 5, 1, 2, 3, 4, 5, 6, 7, 8]\n    integer :: seen(n)\n    integer :: i, j, found\n    \n    seen = -1\n    found = -1\n\n    do i = 1, n\n        do j = 1, i-1\n            if (arr(i) == seen(j)) then\n                found = arr(i)\n                exit\n            end if\n        end do\n        if (found /= -1) exit\n        seen(i) = arr(i)\n    end do\n\n    if (found /= -1) then\n        print *, \"First recurring element:\", found\n    else\n        print *, \"No recurring elements found\"\n    end if\nend program first_recurring_element\n```"
  },
  {
    "task": "Write a method to check if an array is a subset of another array.",
    "code": "```fortran\nprogram check_subset\n  implicit none\n  integer, dimension(:), allocatable :: array1, array2\n  logical :: is_subset\n\n  ! Example arrays\n  allocate(array1(5))\n  array1 = [2, 3, 5, 7, 11]\n  \n  allocate(array2(3))\n  array2 = [3, 7, 11]\n\n  is_subset = isArraySubset(array1, array2)\n  print *, 'Array2 is subset of Array1:', is_subset\n\ncontains\n\n  logical function isArraySubset(a, b)\n    integer, dimension(:), intent(in) :: a, b\n    integer :: i, j\n    logical :: found\n\n    do i = 1, size(b)\n      found = .false.\n      do j = 1, size(a)\n        if (b(i) == a(j)) then\n          found = .true.\n          exit\n        end if\n      end do\n      if (.not. found) then\n        isArraySubset = .false.\n        return\n      end if\n    end do\n    isArraySubset = .true.\n  end function isArraySubset\n\nend program check_subset\n```"
  },
  {
    "task": "Implement a function to add a specific value to each element in an array.",
    "code": "```fortran\nprogram add_value_to_array\n  implicit none\n  integer, parameter :: n = 5\n  real :: array(n)\n  real :: value\n  integer :: i\n\n  ! Initialize array and value\n  array = (/ 1.0, 2.0, 3.0, 4.0, 5.0 /)\n  value = 2.5\n\n  call add_value(array, value)\n\n  print *, array\n\ncontains\n\n  subroutine add_value(arr, val)\n    real, intent(inout) :: arr(:)\n    real, intent(in) :: val\n    integer :: i\n\n    do i = 1, size(arr)\n      arr(i) = arr(i) + val\n    end do\n  end subroutine add_value\n\nend program add_value_to_array\n```"
  },
  {
    "task": "Create a program that finds the largest product of three numbers in an array.",
    "code": "```fortran\nprogram largest_product\n    implicit none\n    integer, parameter :: n = 10\n    integer :: arr(n) = [3, 5, -2, 9, 1, -6, 7, 8, 4, -5]\n    integer :: i, j, k\n    integer :: max_product\n\n    max_product = arr(1) * arr(2) * arr(3)\n\n    do i = 1, n-2\n        do j = i+1, n-1\n            do k = j+1, n\n                max_product = max(max_product, arr(i) * arr(j) * arr(k))\n            end do\n        end do\n    end do\n\n    print *, \"The largest product of three numbers is:\", max_product\nend program largest_product\n```"
  },
  {
    "task": "Design a routine to find all unique permutations of an array.",
    "code": "```fortran\nmodule permutations_module\n  implicit none\ncontains\n  subroutine find_unique_permutations(arr, n, perm, used, depth)\n    integer, intent(in) :: n\n    integer, dimension(n), intent(in) :: arr\n    integer, dimension(n), intent(inout) :: perm\n    logical, dimension(n), intent(inout) :: used\n    integer, intent(in) :: depth\n    integer :: i\n\n    if (depth == n) then\n      print *, perm\n    else\n      do i = 1, n\n        if (.not. used(i)) then\n          used(i) = .true.\n          perm(depth + 1) = arr(i)\n          call find_unique_permutations(arr, n, perm, used, depth + 1)\n          used(i) = .false.\n        end if\n      end do\n    end if\n  end subroutine find_unique_permutations\n\nend module permutations_module\n\nprogram main\n  use permutations_module\n  implicit none\n  integer, parameter :: n = 3\n  integer :: arr(n) = [1, 2, 3]\n  integer :: perm(n)\n  logical :: used(n)\n\n  used = .false.\n  call find_unique_permutations(arr, n, perm, used, 0)\nend program main\n```"
  },
  {
    "task": "Write a function to transpose a square matrix represented as a 2D array.",
    "code": "```fortran\nfunction transpose_matrix(matrix, n) result(transposed)\n    integer, intent(in) :: n\n    real, dimension(n,n), intent(in) :: matrix\n    real, dimension(n,n) :: transposed\n    integer :: i, j\n\n    do i = 1, n\n        do j = 1, n\n            transposed(j, i) = matrix(i, j)\n        end do\n    end do\n\nend function transpose_matrix\n```"
  },
  {
    "task": "Develop a method to find the longest common prefix in an array of strings.",
    "code": "```fortran\nprogram longest_common_prefix\n    implicit none\n    character(len=100), dimension(:), allocatable :: strArray\n    character(len=100) :: prefix\n    integer :: numStrings, i, j, minLen\n\n    ! Sample input\n    numStrings = 3\n    allocate(strArray(numStrings))\n    strArray(1) = 'flower'\n    strArray(2) = 'flow'\n    strArray(3) = 'flight'\n\n    if (numStrings == 0) then\n        prefix = ''\n    else\n        minLen = len_trim(strArray(1))\n        do i = 1, numStrings\n            if (len_trim(strArray(i)) < minLen) then\n                minLen = len_trim(strArray(i))\n            end if\n        end do\n\n        prefix = ''\n        do j = 1, minLen\n            call find_prefix(strArray, numStrings, j, prefix)\n            if (len(prefix) /= j) exit\n        end do\n    end if\n\n    print *, 'Longest common prefix:', trim(prefix)\n\ncontains\n\n    subroutine find_prefix(strArray, numStrings, position, prefix)\n        character(len=100), dimension(:), intent(in) :: strArray\n        integer, intent(in) :: numStrings, position\n        character(len=100), intent(inout) :: prefix\n        character :: currentChar\n        integer :: i\n\n        currentChar = strArray(1)(position:position)\n        do i = 2, numStrings\n            if (strArray(i)(position:position) /= currentChar) then\n                return\n            end if\n        end do\n        prefix = prefix // currentChar\n    end subroutine find_prefix\n\nend program longest_common_prefix\n```"
  },
  {
    "task": "Implement a function to flatten a multi-dimensional array into a single array.",
    "code": "```fortran\nmodule array_utils\ncontains\n    function flatten_array(multi_array) result(flat_array)\n        real, dimension(:, :, :), intent(in) :: multi_array\n        real, allocatable, dimension(:) :: flat_array\n        integer :: total_size, i, j, k, index\n\n        total_size = size(multi_array, 1) * size(multi_array, 2) * size(multi_array, 3)\n        allocate(flat_array(total_size))\n\n        index = 1\n        do i = 1, size(multi_array, 1)\n            do j = 1, size(multi_array, 2)\n                do k = 1, size(multi_array, 3)\n                    flat_array(index) = multi_array(i, j, k)\n                    index = index + 1\n                end do\n            end do\n        end do\n    end function flatten_array\nend module array_utils\n```"
  },
  {
    "task": "Create a script to shift elements of an array to the left by a given number of positions.",
    "code": "```fortran\nprogram shift_array\n    implicit none\n    integer, parameter :: n = 5\n    integer :: array(n) = [1, 2, 3, 4, 5]\n    integer :: shifted_array(n)\n    integer :: shift, i\n\n    shift = 2  ! number of positions to shift\n\n    do i = 1, n\n        shifted_array(i) = array(mod(i - 1 + shift, n) + 1)\n    end do\n\n    print *, 'Shifted array: ', shifted_array\nend program shift_array\n```"
  },
  {
    "task": "Write a routine to sort an array of objects based on a specific property.",
    "code": "```fortran\nmodule object_sorter\n  implicit none\n  type :: Object\n    real :: property\n  end type Object\n\ncontains\n\n  subroutine sort_objects(obj_array)\n    type(Object), intent(inout) :: obj_array(:)\n    integer :: i, j\n    type(Object) :: temp\n\n    do i = 1, size(obj_array) - 1\n      do j = i + 1, size(obj_array)\n        if (obj_array(i)%property > obj_array(j)%property) then\n          temp = obj_array(i)\n          obj_array(i) = obj_array(j)\n          obj_array(j) = temp\n        end if\n      end do\n    end do\n  end subroutine sort_objects\n\nend module object_sorter\n```"
  },
  {
    "task": "Design a program to find the smallest missing positive integer in an array.",
    "code": "```fortran\nprogram smallest_missing_positive\n    implicit none\n    integer, allocatable :: arr(:)\n    integer :: n, i, pos, smallest_missing\n\n    ! Sample input\n    n = 6\n    allocate(arr(n))\n    arr = [3, 4, -1, 1, 6, 2]\n\n    ! Find smallest missing positive integer\n    call find_smallest_missing(arr, n, smallest_missing)\n\n    ! Output result\n    print *, \"Smallest missing positive integer is:\", smallest_missing\n\ncontains\n\n    subroutine find_smallest_missing(arr, n, smallest_missing)\n        integer, intent(in) :: arr(:)\n        integer, intent(in) :: n\n        integer, intent(out) :: smallest_missing\n        integer :: i, j, temp\n\n        ! Reorder positive integers in the range 1 to n\n        i = 1\n        do while (i <= n)\n            if (arr(i) > 0 .and. arr(i) <= n .and. arr(arr(i)) /= arr(i)) then\n                temp = arr(i)\n                arr(i) = arr(temp)\n                arr(temp) = temp\n            else\n                i = i + 1\n            end if\n        end do\n\n        ! Determine the smallest missing positive integer\n        do i = 1, n\n            if (arr(i) /= i) then\n                smallest_missing = i\n                return\n            end if\n        end do\n        smallest_missing = n + 1\n    end subroutine find_smallest_missing\n\nend program smallest_missing_positive\n```"
  },
  {
    "task": "Create a function to calculate the cumulative sum of an array.",
    "code": "```fortran\nfunction cumulative_sum(arr, n) result(cumsum)\n    implicit none\n    integer, intent(in) :: n\n    real, intent(in) :: arr(n)\n    real :: cumsum(n)\n    integer :: i\n\n    cumsum(1) = arr(1)\n    do i = 2, n\n        cumsum(i) = cumsum(i-1) + arr(i)\n    end do\nend function\n```"
  },
  {
    "task": "Develop a function to remove consecutive duplicate elements in an array.",
    "code": "```fortran\nmodule array_utilities\n  implicit none\ncontains\n  function remove_consecutive_duplicates(arr, n) result(new_arr)\n    integer, intent(in) :: n\n    integer, intent(in) :: arr(n)\n    integer, allocatable :: new_arr(:)\n    integer :: i, j, unique_count\n\n    allocate(new_arr(n))\n    new_arr(1) = arr(1)\n    unique_count = 1\n\n    do i = 2, n\n      if (arr(i) /= arr(i - 1)) then\n        unique_count = unique_count + 1\n        new_arr(unique_count) = arr(i)\n      end if\n    end do\n\n    if (unique_count < n) then\n      call move_alloc(new_arr, new_arr(1:unique_count))\n    end if\n  end function remove_consecutive_duplicates\nend module array_utilities\n```"
  },
  {
    "task": "Implement a method to find the majority element in an array, if any.",
    "code": "```fortran\nprogram majority_element\n    implicit none\n    integer, parameter :: n = 10\n    integer :: arr(n) = [1, 3, 3, 1, 2, 3, 3, 4, 3, 3]\n    integer :: candidate, count, i\n\n    candidate = find_candidate(arr, n)\n    count = 0\n    do i = 1, n\n        if (arr(i) == candidate) then\n            count = count + 1\n        end if\n    end do\n\n    if (count > n/2) then\n        print *, \"Majority element is \", candidate\n    else\n        print *, \"No majority element\"\n    end if\ncontains\n    function find_candidate(arr, n) result(candidate)\n        integer, intent(in) :: arr(n)\n        integer :: candidate, count, i\n\n        candidate = arr(1)\n        count = 1\n\n        do i = 2, n\n            if (arr(i) == candidate) then\n                count = count + 1\n            else\n                count = count - 1\n                if (count == 0) then\n                    candidate = arr(i)\n                    count = 1\n                end if\n            end if\n        end do\n    end function find_candidate\nend program majority_element\n```"
  },
  {
    "task": "Write a script to split an array into chunks of a given size.",
    "code": "```fortran\nprogram split_array_into_chunks\n    implicit none\n    integer, parameter :: n = 10, chunk_size = 3\n    integer :: i, num_chunks\n    integer, dimension(n) :: array\n    integer, dimension(:), allocatable :: chunk\n\n    array = (/ (i, i = 1, n) /)\n    num_chunks = (n + chunk_size - 1) / chunk_size\n\n    do i = 1, num_chunks\n        if (i * chunk_size <= n) then\n            chunk = array((i - 1) * chunk_size + 1 : i * chunk_size)\n        else\n            chunk = array((i - 1) * chunk_size + 1 : n)\n        end if\n        call print_chunk(chunk)\n    end do\ncontains\n    subroutine print_chunk(chunk)\n        integer, dimension(:), intent(in) :: chunk\n        integer :: j\n        write(*, '( *(i4) )') (chunk(j), j = 1, size(chunk))\n    end subroutine print_chunk\nend program split_array_into_chunks\n```"
  },
  {
    "task": "Create a program to calculate the difference between the largest and smallest values in an array.",
    "code": "```fortran\nprogram array_difference\n    implicit none\n    integer, parameter :: n = 10\n    integer :: i\n    real :: values(n) = [3.5, 6.2, 1.8, 9.4, 2.3, 5.1, 8.7, 4.6, 7.0, 0.9]\n    real :: max_value, min_value, difference\n\n    max_value = values(1)\n    min_value = values(1)\n\n    do i = 2, n\n        if (values(i) > max_value) max_value = values(i)\n        if (values(i) < min_value) min_value = values(i)\n    end do\n\n    difference = max_value - min_value\n    print *, \"Difference between largest and smallest values: \", difference\nend program array_difference\n```"
  },
  {
    "task": "Design a routine to find the starting index of a target subarray in a larger array.",
    "code": "```fortran\nprogram find_subarray_start\n    implicit none\n    integer, parameter :: n = 10, m = 3\n    integer :: array(n) = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    integer :: subarray(m) = [4, 5, 6]\n    integer :: start_idx\n\n    start_idx = find_subarray(array, subarray, n, m)\n    print *, 'Starting index of subarray:', start_idx\ncontains\n    function find_subarray(arr, subarr, arr_size, sub_size) result(start_idx)\n        integer, intent(in) :: arr(:), subarr(:)\n        integer, intent(in) :: arr_size, sub_size\n        integer :: start_idx, i, j\n        logical :: match\n\n        start_idx = -1\n        do i = 1, arr_size - sub_size + 1\n            match = .true.\n            do j = 1, sub_size\n                if (arr(i + j - 1) /= subarr(j)) then\n                    match = .false.\n                    exit\n                end if\n            end do\n            if (match) then\n                start_idx = i\n                return\n            end if\n        end do\n    end function find_subarray\nend program find_subarray_start\n```"
  },
  {
    "task": "Write a function to compress an array by eliminating zero values.",
    "code": "```fortran\nfunction compress_array(input_array) result(compressed_array)\n    integer, dimension(:), intent(in) :: input_array\n    integer, allocatable, dimension(:) :: compressed_array\n    integer :: i, count\n\n    count = count(input_array /= 0)\n    allocate(compressed_array(count))\n    \n    count = 0\n    do i = 1, size(input_array)\n        if (input_array(i) /= 0) then\n            count = count + 1\n            compressed_array(count) = input_array(i)\n        end if\n    end do\nend function compress_array\n```"
  },
  {
    "task": "Develop a method to determine if an array can be split into two parts with equal sums.",
    "code": "```fortran\nprogram array_split_equal_sum\n  implicit none\n  integer, parameter :: n = 6\n  integer :: arr(n) = [1, 5, 11, 5, 2, 10]\n  integer :: total, i, j\n  logical :: can_split\n\n  total = sum(arr)\n  if (mod(total, 2) /= 0) then\n    print *, \"Cannot split array into two parts with equal sums.\"\n    stop\n  end if\n\n  can_split = .false.\n  call subset_sum(arr, n, total / 2, can_split)\n  \n  if (can_split) then\n    print *, \"Array can be split into two parts with equal sums.\"\n  else\n    print *, \"Cannot split array into two parts with equal sums.\"\n  end if\nend program array_split_equal_sum\n\nsubroutine subset_sum(arr, n, target, can_split)\n  integer, intent(in) :: arr(:), n, target\n  logical, intent(out) :: can_split\n  logical, dimension(0:target) :: dp\n  integer :: i, j\n\n  dp = .false.\n  dp(0) = .true.\n\n  do i = 1, n\n    do j = target, arr(i), -1\n      dp(j) = dp(j) .or. dp(j - arr(i))\n    end do\n  end do\n\n  can_split = dp(target)\nend subroutine subset_sum\n```"
  },
  {
    "task": "Implement a function to round each element in an array to the nearest integer.",
    "code": "```fortran\nprogram round_array\n    implicit none\n    real, dimension(:), allocatable :: arr\n    integer, dimension(:), allocatable :: rounded_arr\n    integer :: n, i\n\n    ! Example array size\n    n = 5\n\n    ! Allocate and initialize the example array\n    allocate(arr(n))\n    arr = [1.2, 2.7, 3.5, 4.4, 5.9]\n\n    ! Allocate the array for rounded values\n    allocate(rounded_arr(n))\n\n    ! Call the rounding function\n    call round_elements(arr, rounded_arr, n)\n\n    ! Print the rounded array\n    print *, rounded_arr\n\n    ! Deallocate the arrays\n    deallocate(arr, rounded_arr)\n\ncontains\n\n    subroutine round_elements(input_array, output_array, size)\n        real, dimension(:), intent(in) :: input_array\n        integer, dimension(:), intent(out) :: output_array\n        integer, intent(in) :: size\n        integer :: i\n\n        do i = 1, size\n            output_array(i) = nint(input_array(i))\n        end do\n    end subroutine round_elements\n\nend program round_array\n```"
  },
  {
    "task": "Create a routine to generate an array of the Fibonacci sequence up to a given number.",
    "code": "```fortran\nprogram fibonacci_sequence\n    implicit none\n    integer, parameter :: max_size = 100\n    integer :: n, i\n    integer, dimension(max_size) :: fib\n\n    print *, 'Enter the number of Fibonacci terms:'\n    read *, n\n\n    call generate_fibonacci(fib, n)\n\n    print *, 'Fibonacci sequence:'\n    do i = 1, n\n        print *, fib(i)\n    end do\n\ncontains\n\n    subroutine generate_fibonacci(fib, n)\n        integer, dimension(:), intent(out) :: fib\n        integer, intent(in) :: n\n        integer :: i\n\n        if (n < 1) return\n\n        fib(1) = 0\n        if (n > 1) fib(2) = 1\n\n        do i = 3, n\n            fib(i) = fib(i-1) + fib(i-2)\n        end do\n    end subroutine generate_fibonacci\n\nend program fibonacci_sequence\n```"
  },
  {
    "task": "Write a program to find the longest repeating sequence in an array.",
    "code": "```fortran\nprogram longest_repeating_sequence\n    implicit none\n    integer, parameter :: n = 10\n    integer :: array(n) = [1, 2, 2, 3, 3, 3, 4, 4, 5, 5]\n    integer :: i, current_count, max_count, current_value, longest_value\n\n    current_count = 1\n    max_count = 1\n    current_value = array(1)\n    longest_value = array(1)\n\n    do i = 2, n\n        if (array(i) == array(i-1)) then\n            current_count = current_count + 1\n        else\n            current_count = 1\n        end if\n\n        if (current_count > max_count) then\n            max_count = current_count\n            longest_value = array(i)\n        end if\n    end do\n\n    print *, \"Longest repeating sequence value:\", longest_value\n    print *, \"Length of longest repeating sequence:\", max_count\nend program longest_repeating_sequence\n```"
  },
  {
    "task": "Design a function to multiply each element of an array by its index.",
    "code": "```fortran\nprogram array_multiplication\n    implicit none\n    integer, parameter :: n = 5\n    integer :: i\n    integer :: arr(n)\n    \n    arr = (/1, 2, 3, 4, 5/)\n    call multiply_by_index(arr, n)\n    \n    print *, arr\ncontains\n    subroutine multiply_by_index(array, size)\n        integer, intent(inout) :: array(size)\n        integer, intent(in) :: size\n        integer :: i\n        \n        do i = 1, size\n            array(i) = array(i) * i\n        end do\n    end subroutine multiply_by_index\nend program array_multiplication\n```"
  },
  {
    "task": "Create a method to convert an array of characters into a single string.",
    "code": "```fortran\nprogram array_to_string\n    implicit none\n    character(len=100) :: result\n    character(len=1), dimension(:), allocatable :: char_array\n    integer :: i\n\n    allocate(char_array(5))\n    char_array = ['H', 'e', 'l', 'l', 'o']\n\n    result = array_to_string(char_array)\n    print *, result\n\ncontains\n\n    function array_to_string(arr) result(str)\n        character(len=1), dimension(:), intent(in) :: arr\n        character(len=100) :: str\n        integer :: i\n\n        str = ''\n        do i = 1, size(arr)\n            str = trim(str) // arr(i)\n        end do\n    end function array_to_string\n\nend program array_to_string\n```"
  },
  {
    "task": "Develop a function to fill an array with a specified value.",
    "code": "```fortran\nprogram fill_array_program\n    implicit none\n    integer, parameter :: n = 10\n    real :: arr(n)\n    call fill_array(arr, 5.0)\n    print *, arr\ncontains\n    subroutine fill_array(a, value)\n        real, intent(out) :: a(:)\n        real, intent(in) :: value\n        integer :: i\n        do i = 1, size(a)\n            a(i) = value\n        end do\n    end subroutine fill_array\nend program fill_array_program\n```"
  },
  {
    "task": "Implement a routine to determine if an array has any duplicate elements.",
    "code": "```fortran\nprogram check_duplicates\n    implicit none\n    integer, parameter :: n = 10\n    integer :: arr(n) = [1, 2, 3, 4, 5, 6, 7, 8, 9, 1]\n    logical :: has_duplicates\n\n    has_duplicates = any_duplicates(arr, n)\n\n    if (has_duplicates) then\n        print *, \"The array has duplicates.\"\n    else\n        print *, \"The array has no duplicates.\"\n    end if\ncontains\n    logical function any_duplicates(array, size)\n        integer, intent(in) :: array(:)\n        integer, intent(in) :: size\n        integer :: i, j\n\n        any_duplicates = .false.\n        do i = 1, size-1\n            do j = i+1, size\n                if (array(i) == array(j)) then\n                    any_duplicates = .true.\n                    return\n                end if\n            end do\n        end do\n    end function any_duplicates\nend program check_duplicates\n```"
  },
  {
    "task": "Write a script to reverse the order of words in an array of strings.",
    "code": "```fortran\nprogram reverse_array\n    implicit none\n    character(len=100) :: sentence(5) = ['Hello', 'world', 'this', 'is', 'Fortran']\n    character(len=100) :: reversed(5)\n    integer :: i, n\n\n    n = size(sentence)\n    do i = 1, n\n        reversed(i) = sentence(n-i+1)\n    end do\n\n    do i = 1, n\n        print *, trim(reversed(i))\n    end do\nend program reverse_array\n```"
  },
  {
    "task": "Create a function to calculate the total number of distinct elements in an array.",
    "code": "```fortran\nmodule array_utils\ncontains\n    function count_distinct_elements(arr) result(count)\n        integer, intent(in) :: arr(:)\n        integer :: i, j, n\n        logical :: is_distinct\n        integer :: count\n\n        n = size(arr)\n        count = 0\n\n        do i = 1, n\n            is_distinct = .true.\n            do j = 1, i-1\n                if (arr(i) == arr(j)) then\n                    is_distinct = .false.\n                    exit\n                end if\n            end do\n            if (is_distinct) count = count + 1\n        end do\n    end function count_distinct_elements\nend module array_utils\n```"
  },
  {
    "task": "Design a program to find the largest gap between consecutive elements in a sorted array.",
    "code": "```fortran\nprogram find_largest_gap\n    implicit none\n    integer, parameter :: n = 10\n    integer :: i\n    integer :: sorted_array(n) = (/ 1, 3, 6, 10, 15, 21, 28, 36, 45, 55 /)\n    integer :: largest_gap, current_gap\n\n    largest_gap = 0\n    do i = 1, n-1\n        current_gap = sorted_array(i+1) - sorted_array(i)\n        if (current_gap > largest_gap) then\n            largest_gap = current_gap\n        end if\n    end do\n\n    print *, \"The largest gap is: \", largest_gap\nend program find_largest_gap\n```"
  },
  {
    "task": "Write a routine to perform element-wise multiplication of two arrays.",
    "code": "```fortran\nsubroutine elementwise_multiply(array1, array2, result, n)\n    implicit none\n    integer, intent(in) :: n\n    real, intent(in) :: array1(n), array2(n)\n    real, intent(out) :: result(n)\n    integer :: i\n\n    do i = 1, n\n        result(i) = array1(i) * array2(i)\n    end do\nend subroutine elementwise_multiply\n```"
  },
  {
    "task": "Develop a method to split a string into an array of words.",
    "code": "```fortran\nprogram split_string\n    implicit none\n    character(len=100) :: input_string\n    character(len=20), dimension(10) :: words\n    integer :: i, j, word_count\n\n    input_string = \"Develop a method to split a string into an array of words\"\n    word_count = 0\n    i = 1\n    j = 1\n\n    do while (i <= len_trim(input_string))\n        if (input_string(i:i) /= ' ') then\n            words(word_count+1)(j:j) = input_string(i:i)\n            j = j + 1\n        else\n            if (j /= 1) then\n                word_count = word_count + 1\n                j = 1\n            end if\n        end if\n        i = i + 1\n    end do\n\n    if (j /= 1) then\n        word_count = word_count + 1\n    end if\n\n    ! Example output of words\n    do i = 1, word_count\n        print *, trim(words(i))\n    end do\nend program split_string\n```"
  },
  {
    "task": "Implement a function to find the longest contiguous subarray with a sum less than a target.",
    "code": "```fortran\nprogram longest_subarray\n  implicit none\n  integer, parameter :: n = 10\n  integer :: array(n) = [2, 1, 5, 1, 3, 2, 1, 1, 1, 1]\n  integer :: target = 7\n  integer :: result\n\n  result = find_longest_subarray(array, n, target)\n  print *, 'Length of longest subarray:', result\n\ncontains\n\n  integer function find_longest_subarray(arr, size, target)\n    integer, intent(in) :: arr(:)\n    integer, intent(in) :: size, target\n    integer :: start, end, sum, max_length\n\n    max_length = 0\n    start = 1\n    sum = 0\n\n    do end = 1, size\n      sum = sum + arr(end)\n      do while (sum >= target)\n        sum = sum - arr(start)\n        start = start + 1\n      end do\n      max_length = max(max_length, end - start + 1)\n    end do\n\n    find_longest_subarray = max_length\n  end function find_longest_subarray\n\nend program longest_subarray\n```"
  },
  {
    "task": "Create a script to rotate a 2D array (matrix) 180 degrees.",
    "code": "```fortran\nprogram rotate_matrix_180\n  implicit none\n  integer, parameter :: n = 3, m = 3\n  integer :: i, j\n  integer :: matrix(n, m), rotated_matrix(n, m)\n\n  ! Example matrix\n  matrix = reshape([1, 2, 3, 4, 5, 6, 7, 8, 9], shape(matrix))\n\n  ! Rotate 180 degrees\n  do i = 1, n\n     do j = 1, m\n        rotated_matrix(i,j) = matrix(n-i+1, m-j+1)\n     end do\n  end do\n\n  print *, \"Original Matrix:\"\n  do i = 1, n\n     print *, (matrix(i,j), j = 1, m)\n  end do\n\n  print *, \"Rotated Matrix:\"\n  do i = 1, n\n     print *, (rotated_matrix(i,j), j = 1, m)\n  end do\n\nend program rotate_matrix_180\n```"
  },
  {
    "task": "Write a program to convert an array of binary digits to its decimal equivalent.",
    "code": "```fortran\nprogram binary_to_decimal\n    implicit none\n    integer, parameter :: n = 8\n    integer :: binary_array(n)\n    integer :: i, decimal_value\n\n    ! Example binary array\n    binary_array = (/1, 0, 1, 1, 0, 1, 0, 1/)\n\n    decimal_value = 0\n    do i = 1, n\n        decimal_value = decimal_value * 2 + binary_array(i)\n    end do\n\n    print *, \"Decimal equivalent:\", decimal_value\nend program binary_to_decimal\n```"
  },
  {
    "task": "Design a function to return a new array with elements squared from the input array.",
    "code": "```fortran\nfunction square_array(input_array) result(output_array)\n    implicit none\n    real, intent(in) :: input_array(:)\n    real :: output_array(size(input_array))\n    integer :: i\n\n    do i = 1, size(input_array)\n        output_array(i) = input_array(i) ** 2\n    end do\nend function square_array\n```"
  },
  {
    "task": "Create a method to check if all elements in an array are unique.",
    "code": "```fortran\nmodule array_utils\n  implicit none\ncontains\n  logical function are_elements_unique(arr)\n    integer, intent(in) :: arr(:)\n    integer :: i, j\n    integer :: n\n    logical :: unique\n\n    n = size(arr)\n    unique = .true.\n\n    do i = 1, n-1\n      do j = i+1, n\n        if (arr(i) == arr(j)) then\n          unique = .false.\n          exit\n        end if\n      end do\n      if (.not. unique) exit\n    end do\n\n    are_elements_unique = unique\n  end function are_elements_unique\nend module array_utils\n```"
  },
  {
    "task": "Develop a routine to find the indices of all occurrences of a specific element in an array.",
    "code": "```fortran\nprogram find_indices\n    implicit none\n    integer, parameter :: n = 10\n    integer :: array(n) = [1, 2, 3, 4, 2, 5, 2, 6, 7, 8]\n    integer :: element, indices(n), i, count\n\n    element = 2\n    indices = 0\n    count = 0\n\n    do i = 1, n\n        if (array(i) == element) then\n            count = count + 1\n            indices(count) = i\n        end if\n    end do\n\n    if (count > 0) then\n        print *, 'Indices of element ', element, ': ', indices(1:count)\n    else\n        print *, 'Element not found in array.'\n    end if\nend program find_indices\n```"
  },
  {
    "task": "Implement a function to merge multiple arrays into one.",
    "code": "```fortran\nprogram merge_arrays\n  implicit none\n  integer, parameter :: n1 = 5, n2 = 4, n3 = 3\n  integer :: array1(n1) = [1, 2, 3, 4, 5]\n  integer :: array2(n2) = [6, 7, 8, 9]\n  integer :: array3(n3) = [10, 11, 12]\n  integer, allocatable :: merged_array(:)\n  \n  call merge(array1, array2, array3, merged_array)\n  print *, merged_array\n\ncontains\n\n  subroutine merge(arr1, arr2, arr3, result)\n    integer, intent(in) :: arr1(:), arr2(:), arr3(:)\n    integer, allocatable, intent(out) :: result(:)\n    integer :: total_size\n\n    total_size = size(arr1) + size(arr2) + size(arr3)\n    allocate(result(total_size))\n    result = [arr1, arr2, arr3]\n  end subroutine merge\n\nend program merge_arrays\n```"
  },
  {
    "task": "Write a script to convert an array of integers into a formatted string.",
    "code": "```fortran\nprogram array_to_string\n    implicit none\n    integer, parameter :: n = 5\n    integer :: i\n    integer :: intArray(n) = [1, 2, 3, 4, 5]\n    character(len=50) :: result\n    character(len=10) :: temp\n\n    result = \"(\"\n    do i = 1, n\n        write(temp, '(I0)') intArray(i)\n        result = trim(result) // temp\n        if (i < n) then\n            result = trim(result) // \", \"\n        end if\n    end do\n    result = trim(result) // \")\"\n\n    print *, result\nend program array_to_string\n```"
  },
  {
    "task": "Create a program to find the largest sum of any contiguous subarray.",
    "code": "```fortran\nprogram largest_contiguous_subarray_sum\n  implicit none\n  integer, parameter :: n = 10\n  integer :: i\n  integer :: array(n) = [3, -2, 5, -1, 4, -3, 2, 7, -5, 2]\n  integer :: max_sum, current_sum\n\n  max_sum = array(1)\n  current_sum = array(1)\n\n  do i = 2, n\n     current_sum = max(array(i), current_sum + array(i))\n     max_sum = max(max_sum, current_sum)\n  end do\n\n  print *, \"Largest sum of contiguous subarray is: \", max_sum\nend program largest_contiguous_subarray_sum\n```"
  },
  {
    "task": "Design a function to compare two arrays and return the differences.",
    "code": "```fortran\nprogram compare_arrays\n  implicit none\n  integer, parameter :: n = 5\n  integer :: arr1(n) = [1, 2, 3, 4, 5]\n  integer :: arr2(n) = [1, 3, 2, 5, 4]\n  integer :: differences(n)\n  integer :: i, count\n\n  call find_differences(arr1, arr2, differences, count, n)\n\n  print *, 'Differences:'\n  if (count > 0) then\n    print *, differences(1:count)\n  else\n    print *, 'No differences found.'\n  end if\n\ncontains\n\n  subroutine find_differences(a1, a2, diffs, num_diffs, size)\n    integer, intent(in) :: a1(:), a2(:)\n    integer, intent(out) :: diffs(:)\n    integer, intent(out) :: num_diffs\n    integer, intent(in) :: size\n    integer :: i\n    num_diffs = 0\n\n    do i = 1, size\n      if (a1(i) /= a2(i)) then\n        num_diffs = num_diffs + 1\n        diffs(num_diffs) = i\n      end if\n    end do\n  end subroutine find_differences\n\nend program compare_arrays\n```"
  },
  {
    "task": "Write a method to find the longest subarray with elements in arithmetic progression.",
    "code": "```fortran\nprogram longest_arithmetic_subarray\n    implicit none\n    integer, allocatable :: arr(:)\n    integer :: n, i, current_length, max_length, diff\n\n    ! Sample input array\n    arr = [3, 6, 9, 12, 15, 18, 1, 2, 3, 4, 5, 6]\n\n    n = size(arr)\n    if (n < 2) then\n        print *, \"Array too short\"\n        stop\n    end if\n\n    max_length = 1\n    current_length = 1\n    diff = arr(2) - arr(1)\n\n    do i = 2, n\n        if (arr(i) - arr(i-1) == diff) then\n            current_length = current_length + 1\n        else\n            diff = arr(i) - arr(i-1)\n            current_length = 2\n        end if\n        if (current_length > max_length) then\n            max_length = current_length\n        end if\n    end do\n\n    print *, \"Longest arithmetic subarray length: \", max_length\nend program longest_arithmetic_subarray\n```"
  },
  {
    "task": "Develop a routine to remove elements from an array based on a predicate function.",
    "code": "```fortran\nmodule array_utils\n  implicit none\ncontains\n  logical function predicate(x)\n    real, intent(in) :: x\n    ! Example predicate: remove if x < 0\n    predicate = (x >= 0.0)\n  end function predicate\n\n  subroutine filter_array(input_array, output_array, size)\n    real, intent(in) :: input_array(:)\n    real, allocatable, intent(out) :: output_array(:)\n    integer, intent(out) :: size\n    integer :: i, count\n    real, allocatable :: temp_array(:)\n\n    allocate(temp_array(size(input_array)))\n    count = 0\n\n    do i = 1, size(input_array)\n      if (predicate(input_array(i))) then\n        count = count + 1\n        temp_array(count) = input_array(i)\n      end if\n    end do\n\n    size = count\n    allocate(output_array(size))\n    if (size > 0) output_array = temp_array(1:size)\n\n    deallocate(temp_array)\n  end subroutine filter_array\nend module array_utils\n```"
  },
  {
    "task": "Implement a function to determine if two arrays have any common elements.",
    "code": "```fortran\nprogram common_elements\n  implicit none\n  integer, parameter :: n = 5\n  integer :: array1(n) = [1, 2, 3, 4, 5]\n  integer :: array2(n) = [6, 7, 3, 9, 10]\n  logical :: result\n\n  result = has_common_elements(array1, array2, n)\n  print *, \"Do the arrays have common elements? \", result\ncontains\n\n  logical function has_common_elements(arr1, arr2, size)\n    integer, intent(in) :: arr1(size), arr2(size)\n    integer, intent(in) :: size\n    integer :: i, j\n\n    has_common_elements = .false.\n    do i = 1, size\n      do j = 1, size\n        if (arr1(i) == arr2(j)) then\n          has_common_elements = .true.\n          return\n        end if\n      end do\n    end do\n  end function has_common_elements\nend program common_elements\n```"
  },
  {
    "task": "Create a script to initialize an empty array and populate it with user input.",
    "code": "```fortran\nprogram array_input\n    implicit none\n    integer, parameter :: n = 5\n    integer :: i\n    real :: user_array(n)\n\n    print *, 'Enter ', n, ' numbers:'\n    do i = 1, n\n        read *, user_array(i)\n    end do\n\n    print *, 'The array contains:'\n    do i = 1, n\n        print *, user_array(i)\n    end do\nend program array_input\n```"
  },
  {
    "task": "Write a program to find the maximum sum of non-adjacent elements in an array.",
    "code": "```fortran\nprogram max_non_adjacent_sum\n    implicit none\n    integer, parameter :: n = 10\n    integer :: arr(n) = [3, 2, 7, 10, 12, 15, 17, 20, 25, 30]\n    integer :: incl, excl, new_excl, i\n\n    incl = arr(1)\n    excl = 0\n\n    do i = 2, n\n        new_excl = max(incl, excl)\n        incl = excl + arr(i)\n        excl = new_excl\n    end do\n\n    print *, \"Maximum sum of non-adjacent elements:\", max(incl, excl)\nend program max_non_adjacent_sum\n```"
  },
  {
    "task": "Design a function to shuffle an array randomly.",
    "code": "```fortran\nmodule shuffle_mod\n  implicit none\ncontains\n\n  subroutine shuffle_array(arr)\n    real, intent(inout) :: arr(:)\n    integer :: i, j, n\n    real :: temp\n\n    call random_seed()\n    n = size(arr)\n\n    do i = 1, n\n      call random_number(temp)\n      j = int(temp * n) + 1\n      temp = arr(i)\n      arr(i) = arr(j)\n      arr(j) = temp\n    end do\n  end subroutine shuffle_array\n\nend module shuffle_mod\n```"
  },
  {
    "task": "Create a method to generate a new array where each element is the cumulative product of the input array.",
    "code": "```fortran\nprogram cumulative_product\n    implicit none\n    real, dimension(:), allocatable :: input_array, result_array\n    integer :: i, n\n\n    ! Example input\n    input_array = [1.0, 2.0, 3.0, 4.0]\n    n = size(input_array)\n    allocate(result_array(n))\n\n    call cumulative_product(input_array, result_array)\n\n    print *, 'Cumulative product: ', result_array\n\ncontains\n\n    subroutine cumulative_product(arr, result)\n        real, dimension(:), intent(in) :: arr\n        real, dimension(:), intent(out) :: result\n        integer :: i\n\n        result(1) = arr(1)\n        do i = 2, size(arr)\n            result(i) = result(i-1) * arr(i)\n        end do\n    end subroutine cumulative_product\n\nend program cumulative_product\n```"
  },
  {
    "task": "Develop a routine to find the largest element in each row of a 2D array.",
    "code": "```fortran\nprogram find_largest_in_rows\n    implicit none\n    integer, parameter :: n = 3, m = 4\n    integer :: array(n, m)\n    integer :: i, j\n    integer :: largest_in_row(n)\n\n    ! Sample 2D array initialization\n    array = reshape([1, 4, 3, 2, &\n                     10, 8, 6, 7, &\n                     5, 9, 12, 11], shape(array))\n\n    do i = 1, n\n        largest_in_row(i) = array(i, 1)\n        do j = 2, m\n            if (array(i, j) > largest_in_row(i)) then\n                largest_in_row(i) = array(i, j)\n            end if\n        end do\n    end do\n\n    print *, 'Largest elements in each row: ', largest_in_row\nend program find_largest_in_rows\n```"
  },
  {
    "task": "Implement a function to count the number of negative numbers in an array.",
    "code": "```fortran\nprogram count_negatives\n    implicit none\n    integer, parameter :: n = 10\n    integer :: arr(n) = [3, -1, 4, -1, 5, -9, 2, 6, 5, -3]\n    integer :: num_negatives\n\n    num_negatives = count_negative_numbers(arr, n)\n    print *, \"Number of negative numbers:\", num_negatives\nend program count_negatives\n\nfunction count_negative_numbers(arr, size) result(neg_count)\n    integer, intent(in) :: arr(:)\n    integer, intent(in) :: size\n    integer :: neg_count\n    integer :: i\n\n    neg_count = 0\n    do i = 1, size\n        if (arr(i) < 0) then\n            neg_count = neg_count + 1\n        end if\n    end do\nend function count_negative_numbers\n```"
  },
  {
    "task": "Write a script to find the longest subarray with all distinct elements.",
    "code": "```fortran\nprogram longest_distinct_subarray\n    implicit none\n    integer, parameter :: maxn = 1000\n    integer :: n, i, j, start, maxlen, len\n    integer :: arr(maxn), last_seen(1000)\n    logical :: visited(1000)\n    \n    ! Initialize\n    n = 10  ! Example array size\n    arr = (/ 5, 1, 3, 5, 2, 3, 4, 1, 5, 2 /)  ! Example array\n    maxlen = 0\n    start = 1\n\n    ! Initialize last_seen and visited arrays\n    last_seen = -1\n    visited = .false.\n\n    ! Find the longest subarray with all distinct elements\n    do i = 1, n\n        if (visited(arr(i))) then\n            start = max(start, last_seen(arr(i)) + 1)\n        end if\n        visited(arr(i)) = .true.\n        last_seen(arr(i)) = i\n        len = i - start + 1\n        if (len > maxlen) then\n            maxlen = len\n        end if\n    end do\n\n    print *, 'Length of longest subarray with all distinct elements:', maxlen\nend program longest_distinct_subarray\n```"
  }
]