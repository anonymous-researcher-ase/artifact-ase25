[
  {
    "task": "Create a function that takes two boolean inputs and returns true if both are true using logical AND.",
    "code": "```fortran\nlogical function both_true(x, y)\n    logical, intent(in) :: x, y\n    both_true = x .and. y\nend function both_true\n```"
  },
  {
    "task": "Write a script to check if either of two given conditions are met using logical OR.",
    "code": "```fortran\nprogram logical_operations\n  implicit none\n  logical :: condition1, condition2, result\n\n  ! Initialize conditions\n  condition1 = .true.\n  condition2 = .false.\n\n  ! Perform logical OR operation\n  result = condition1 .or. condition2\n\n  ! Output the result\n  print *, \"Result of logical OR operation: \", result\nend program logical_operations\n```"
  },
  {
    "task": "Develop a program that negates a boolean variable using logical NOT.",
    "code": "```fortran\nprogram negate_boolean\n    implicit none\n    logical :: flag, negated_flag\n\n    flag = .true.\n    negated_flag = .not. flag\n\n    print *, \"Original flag: \", flag\n    print *, \"Negated flag: \", negated_flag\nend program negate_boolean\n```"
  },
  {
    "task": "Implement a feature that determines if a number is within a specific range using logical operators.",
    "code": "```fortran\nprogram check_range\n    implicit none\n    integer :: number\n    logical :: in_range\n\n    ! Assign a value to the variable 'number'\n    number = 15\n\n    ! Determine if the number is within the range 10 to 20 using logical operators\n    in_range = (number >= 10) .and. (number <= 20)\n\n    ! Output the result\n    if (in_range) then\n        print *, \"The number is within the range.\"\n    else\n        print *, \"The number is not within the range.\"\n    end if\nend program check_range\n```"
  },
  {
    "task": "Design a system that checks if a user has both read and write permissions using logical AND.",
    "code": "```fortran\nprogram permissions_check\n  implicit none\n  logical :: has_read_permission, has_write_permission, has_full_permissions\n\n  ! Sample values for permissions\n  has_read_permission = .true.\n  has_write_permission = .true.\n\n  ! Check if user has both read and write permissions\n  has_full_permissions = has_read_permission .and. has_write_permission\n\n  if (has_full_permissions) then\n     print *, \"User has both read and write permissions.\"\n  else\n     print *, \"User does not have full permissions.\"\n  end if\nend program permissions_check\n```"
  },
  {
    "task": "Write a function to verify if a string is neither empty nor null using logical NOT.",
    "code": "```fortran\nprogram string_check\n  implicit none\n  character(len=100) :: str\n  logical :: result\n\n  str = \"Hello, World!\"\n  result = is_neither_empty_nor_null(str)\n  print *, \"The string is neither empty nor null:\", result\n\ncontains\n\n  logical function is_neither_empty_nor_null(s)\n    character(len=*), intent(in) :: s\n    is_neither_empty_nor_null = .not. (len_trim(s) == 0)\n  end function is_neither_empty_nor_null\n\nend program string_check\n```"
  },
  {
    "task": "Create a conditional statement that executes a block of code if either of two expressions are true using logical OR.",
    "code": "```fortran\nprogram logical_operations\n  implicit none\n\n  logical :: expr1, expr2\n\n  expr1 = .true.\n  expr2 = .false.\n\n  if (expr1 .or. expr2) then\n    print *, \"At least one of the expressions is true.\"\n  end if\n\nend program logical_operations\n```"
  },
  {
    "task": "Build a program that inverts the truth value of a given condition using logical NOT.",
    "code": "```fortran\nprogram logical_not_example\n    implicit none\n    logical :: condition\n    logical :: inverted_condition\n\n    ! Assign a value to the condition (TRUE or FALSE)\n    condition = .true.\n\n    ! Invert the truth value using logical NOT\n    inverted_condition = .not. condition\n\n    ! Output the original and inverted conditions\n    print *, \"Original condition: \", condition\n    print *, \"Inverted condition: \", inverted_condition\nend program logical_not_example\n```"
  },
  {
    "task": "Compose a function to return true if a list is not empty using logical NOT.",
    "code": "```fortran\nlogical function is_not_empty(list)\n    integer, dimension(:), intent(in) :: list\n    is_not_empty = .not. (size(list) == 0)\nend function is_not_empty\n```"
  },
  {
    "task": "Develop a filter that selects items from a collection only if they meet multiple criteria using logical AND.",
    "code": "```fortran\nprogram logical_filter\n    implicit none\n    integer, parameter :: n = 10\n    integer :: i\n    integer :: collection(n) = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    logical :: selected(n)\n    \n    ! Filtering criteria: select numbers greater than 3 and less than 8\n    do i = 1, n\n        selected(i) = collection(i) > 3 .and. collection(i) < 8\n    end do\n\n    ! Output selected items\n    print *, \"Selected items:\"\n    do i = 1, n\n        if (selected(i)) then\n            print *, collection(i)\n        end if\n    end do\nend program logical_filter\n```"
  },
  {
    "task": "Write a script that checks if a value is outside a given range using logical OR.",
    "code": "```fortran\nprogram CheckValueOutsideRange\n    implicit none\n    integer :: value, lowerLimit, upperLimit\n    logical :: isOutsideRange\n\n    ! Example values\n    value = 15\n    lowerLimit = 10\n    upperLimit = 20\n\n    ! Logical OR to check if value is outside the range\n    isOutsideRange = (value < lowerLimit) .or. (value > upperLimit)\n\n    if (isOutsideRange) then\n        print *, \"The value is outside the range.\"\n    else\n        print *, \"The value is within the range.\"\n    end if\nend program CheckValueOutsideRange\n```"
  },
  {
    "task": "Create a small program to toggle a boolean flag using logical NOT.",
    "code": "```fortran\nprogram toggle_flag\n  implicit none\n  logical :: flag\n\n  flag = .true.\n  print *, 'Initial flag:', flag\n\n  flag = .not. flag\n  print *, 'Toggled flag:', flag\n\n  flag = .not. flag\n  print *, 'Toggled flag again:', flag\nend program toggle_flag\n```"
  },
  {
    "task": "Implement a feature that evaluates if a username is both unique and valid using logical AND.",
    "code": "```fortran\nprogram username_check\n  implicit none\n  character(len=20) :: username\n  logical :: is_unique, is_valid, is_username_accepted\n\n  ! Sample input for the username\n  username = 'sampleUser'\n\n  ! Conditions for uniqueness and validity\n  is_unique = .true.  ! Replace with actual uniqueness check\n  is_valid = .true.   ! Replace with actual validity check\n\n  ! Logical AND operation to evaluate both conditions\n  is_username_accepted = is_unique .and. is_valid\n\n  print *, 'Is the username accepted? ', is_username_accepted\nend program username_check\n```"
  },
  {
    "task": "Design a conditional to perform an action if neither of two flags are set using logical NOT.",
    "code": "```fortran\nprogram logical_operations\n  implicit none\n  logical :: flag1, flag2\n\n  flag1 = .false.\n  flag2 = .false.\n\n  if (.not. flag1 .and. .not. flag2) then\n    print *, 'Neither flag is set.'\n  end if\n\nend program logical_operations\n```"
  },
  {
    "task": "Write a function that returns true if at least one of multiple boolean inputs is true using logical OR.",
    "code": "```fortran\nprogram logical_or_example\n  implicit none\n  logical :: result\n  result = any_true(.true., .false., .false.)\n  print *, \"Result is: \", result\ncontains\n  logical function any_true(varargin) result(is_true)\n    logical, intent(in) :: varargin(:)\n    integer :: i\n    is_true = .false.\n    do i = 1, size(varargin)\n      if (varargin(i)) then\n        is_true = .true.\n        return\n      end if\n    end do\n  end function any_true\nend program logical_or_example\n```"
  },
  {
    "task": "Create a loop that continues executing as long as two conditions are both false using logical NOT and AND.",
    "code": "```fortran\nprogram logical_operations\n  implicit none\n  logical :: condition1, condition2\n\n  condition1 = .false.\n  condition2 = .false.\n\n  do while (.not. condition1 .and. .not. condition2)\n    ! Your code here\n    \n    ! Example: change conditions to exit loop\n    condition1 = .true.  ! or condition2 = .true.\n  end do\nend program logical_operations\n```"
  },
  {
    "task": "Develop a sequence that checks if a character is either a vowel or a consonant using logical OR.",
    "code": "```fortran\nprogram checkCharacter\n    implicit none\n    character :: ch\n    logical :: isVowel\n\n    print *, 'Enter a character:'\n    read *, ch\n\n    ch = tolower(ch)  ! Convert to lower case for consistency\n\n    isVowel = (ch == 'a' .or. ch == 'e' .or. ch == 'i' .or. &\n               ch == 'o' .or. ch == 'u')\n\n    if (isVowel) then\n        print *, 'The character is a vowel.'\n    else if (ch >= 'a' .and. ch <= 'z') then\n        print *, 'The character is a consonant.'\n    else\n        print *, 'The character is not a valid alphabet letter.'\n    end if\nend program checkCharacter\n```"
  },
  {
    "task": "Implement a validation that ensures a password is both of minimum length and contains numbers using logical AND.",
    "code": "```fortran\nprogram password_validation\n    implicit none\n    character(len=100) :: password\n    logical :: is_valid\n\n    print *, 'Enter password:'\n    read(*, '(A)') password\n\n    is_valid = len_trim(password) >= 8 .and. any([(ichar(password(i:i)) >= ichar('0') .and. ichar(password(i:i)) <= ichar('9'), i = 1, len_trim(password))])\n\n    if (is_valid) then\n        print *, 'Password is valid.'\n    else\n        print *, 'Password is invalid.'\n    endif\nend program password_validation\n```"
  },
  {
    "task": "Compose a test to determine if a point is not within a circle using logical NOT.",
    "code": "```fortran\nprogram point_not_in_circle\n  implicit none\n  real :: x, y, circle_x, circle_y, radius\n  logical :: is_not_in_circle\n\n  ! Input the point coordinates\n  print *, 'Enter the point coordinates (x, y):'\n  read *, x, y\n\n  ! Input the circle center and radius\n  print *, 'Enter the circle center coordinates (circle_x, circle_y):'\n  read *, circle_x, circle_y\n  print *, 'Enter the circle radius:'\n  read *, radius\n\n  ! Determine if the point is not within the circle\n  is_not_in_circle = .not. ((x - circle_x)**2 + (y - circle_y)**2 <= radius**2)\n\n  ! Output the result\n  if (is_not_in_circle) then\n    print *, 'The point is NOT within the circle.'\n  else\n    print *, 'The point is within the circle.'\n  end if\n\nend program point_not_in_circle\n```"
  },
  {
    "task": "Write a function to decide if a user is either an admin or an editor using logical OR.",
    "code": "```fortran\nprogram UserStatus\n  implicit none\n\n  logical :: isAdmin, isEditor\n\n  ! Example usage\n  isAdmin = .false.\n  isEditor = .true.\n  \n  if (isUserAdminOrEditor(isAdmin, isEditor)) then\n     print *, \"User has admin or editor privileges.\"\n  else\n     print *, \"User does not have admin or editor privileges.\"\n  endif\n\ncontains\n\n  logical function isUserAdminOrEditor(admin, editor)\n    logical, intent(in) :: admin, editor\n\n    isUserAdminOrEditor = admin .or. editor\n  end function isUserAdminOrEditor\n\nend program UserStatus\n```"
  },
  {
    "task": "Create a conditional statement to trigger an alert if two sensors both detect motion using logical AND.",
    "code": "```fortran\nprogram motion_alert\n  logical :: sensor1, sensor2, alert\n\n  ! Simulate sensor detection\n  sensor1 = .true.  ! Sensor 1 detects motion\n  sensor2 = .true.  ! Sensor 2 detects motion\n\n  ! Check if both sensors detect motion\n  alert = sensor1 .and. sensor2\n\n  ! Trigger alert if both sensors detect motion\n  if (alert) then\n    print *, \"Alert: Both sensors detect motion!\"\n  else\n    print *, \"No alert: Motion not detected by both sensors.\"\n  end if\n\nend program motion_alert\n```"
  },
  {
    "task": "Design a program to validate an email format and ensure it contains a domain using logical AND.",
    "code": "```fortran\nprogram validate_email\n    implicit none\n    character(len=100) :: email\n    logical :: has_at, has_domain\n\n    print *, 'Enter the email address to validate:'\n    read(*, '(A)') email\n\n    has_at = index(email, '@') > 1\n    has_domain = index(email, '.') > index(email, '@') + 1\n\n    if (has_at .and. has_domain) then\n        print *, 'The email address is valid.'\n    else\n        print *, 'The email address is invalid.'\n    end if\nend program validate_email\n```"
  },
  {
    "task": "Develop a method to confirm that a transaction is neither fraudulent nor unauthorized using logical NOT.",
    "code": "```fortran\nmodule TransactionChecker\n  implicit none\ncontains\n  logical function isTransactionValid(isFraudulent, isUnauthorized)\n    logical, intent(in) :: isFraudulent, isUnauthorized\n\n    isTransactionValid = .not. (isFraudulent .or. isUnauthorized)\n  end function isTransactionValid\nend module TransactionChecker\n```"
  },
  {
    "task": "Write a function that outputs true if a file is either missing or empty using logical OR.",
    "code": "```fortran\nFUNCTION isMissingOrEmpty(filename) RESULT(isTrue)\n  CHARACTER(LEN=*), INTENT(IN) :: filename\n  LOGICAL :: isTrue\n  INQUIRE(FILE=filename, EXIST=isTrue)\n  isTrue = .NOT.isTrue .OR. (isTrue .AND. SIZE(filename) == 0)\nEND FUNCTION isMissingOrEmpty\n```"
  },
  {
    "task": "Implement a system to check if a student's grade is neither failing nor incomplete using logical NOT.",
    "code": "```fortran\nPROGRAM CheckGrade\n  IMPLICIT NONE\n  INTEGER :: grade\n  LOGICAL :: isFailing, isIncomplete, isOk\n\n  WRITE(*,*) \"Enter the student's grade: \"\n  READ(*,*) grade\n\n  isFailing = (grade < 50)\n  isIncomplete = (grade == -1)\n  \n  isOk = .NOT. (isFailing .OR. isIncomplete)\n\n  IF (isOk) THEN\n    WRITE(*,*) \"The grade is neither failing nor incomplete.\"\n  ELSE\n    WRITE(*,*) \"The grade is either failing or incomplete.\"\n  END IF\nEND PROGRAM CheckGrade\n```"
  },
  {
    "task": "Create a script that executes a command if a file is both readable and writable using logical AND.",
    "code": "```fortran\nprogram file_check\n    implicit none\n    logical :: is_readable, is_writable\n    character(len=255) :: filename\n\n    ! Set the filename to check\n    filename = 'yourfile.txt'\n\n    ! Check if the file is readable\n    inquire (file=filename, exist=is_readable, opened=.false., read=.true.)\n    ! Check if the file is writable\n    inquire (file=filename, exist=is_writable, opened=.false., write=.true.)\n\n    ! Execute command if the file is both readable and writable\n    if (is_readable .and. is_writable) then\n        call execute_command_line('echo \"File is readable and writable\"')\n    end if\n\nend program file_check\n```"
  },
  {
    "task": "Compose a function to determine if a temperature is not within a safe operating range using logical NOT.",
    "code": "```fortran\nMODULE TemperatureCheck\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION isTemperatureUnsafe(temperature) RESULT(unsafe)\n    REAL, INTENT(IN) :: temperature\n    LOGICAL :: unsafe\n    REAL, PARAMETER :: LOWER_LIMIT = 0.0\n    REAL, PARAMETER :: UPPER_LIMIT = 100.0\n\n    unsafe = .NOT. (temperature >= LOWER_LIMIT .AND. temperature <= UPPER_LIMIT)\n  END FUNCTION isTemperatureUnsafe\nEND MODULE TemperatureCheck\n```"
  },
  {
    "task": "Design a check to see if a car is either out of fuel or needs maintenance using logical OR.",
    "code": "```fortran\nprogram car_status\n  implicit none\n\n  logical :: out_of_fuel, needs_maintenance, car_needs_attention\n\n  ! Example logical values for the state of the car\n  out_of_fuel = .true.\n  needs_maintenance = .false.\n\n  ! Check if the car is either out of fuel or needs maintenance\n  car_needs_attention = out_of_fuel .or. needs_maintenance\n\n  print *, \"Car needs attention: \", car_needs_attention\n\nend program car_status\n```"
  },
  {
    "task": "Develop a routine that ensures a network connection is both stable and secure using logical AND.",
    "code": "```fortran\nPROGRAM NetworkCheck\n  LOGICAL :: isStable, isSecure, isConnected\n\n  ! Sample values for the sake of demonstration\n  isStable = .TRUE.\n  isSecure = .TRUE.\n\n  isConnected = isStable .AND. isSecure\n\n  IF (isConnected) THEN\n    PRINT *, \"Network connection is stable and secure.\"\n  ELSE\n    PRINT *, \"Network connection is not stable or not secure.\"\n  END IF\nEND PROGRAM NetworkCheck\n```"
  },
  {
    "task": "Write a conditional to print a message if a user is not logged in using logical NOT.",
    "code": "```fortran\nprogram check_login\n  implicit none\n  logical :: is_logged_in\n\n  is_logged_in = .false.\n\n  if (.not. is_logged_in) then\n    print *, \"User is not logged in.\"\n  end if\nend program check_login\n```"
  },
  {
    "task": "Create a function that checks if a number is both even and positive using logical AND.",
    "code": "```fortran\nprogram checkNumber\n    implicit none\n    integer :: num\n    logical :: result\n\n    print *, \"Enter a number:\"\n    read *, num\n\n    result = isEvenAndPositive(num)\n\n    if (result) then\n        print *, \"The number is both even and positive.\"\n    else\n        print *, \"The number is not both even and positive.\"\n    end if\nend program checkNumber\n\nlogical function isEvenAndPositive(n)\n    implicit none\n    integer, intent(in) :: n\n\n    isEvenAndPositive = (mod(n, 2) == 0) .and. (n > 0)\nend function isEvenAndPositive\n```"
  },
  {
    "task": "Implement a feature that turns off a device if neither of two switches are on using logical NOT.",
    "code": "```fortran\nprogram device_control\n  implicit none\n  logical :: switch1, switch2, device_on\n\n  ! Initialize the switches\n  switch1 = .false.\n  switch2 = .false.\n\n  ! Determine if the device should be on or off\n  device_on = .not. (switch1 .or. switch2)\n\n  ! Output the device status\n  if (device_on) then\n    print *, \"Device is off.\"\n  else\n    print *, \"Device is on.\"\n  end if\nend program device_control\n```"
  },
  {
    "task": "Compose a script to alert if a server is either down or running slow using logical OR.",
    "code": "```fortran\nprogram server_status\n  implicit none\n  logical :: server_down, server_slow\n  logical :: alert\n\n  ! Example values for server status\n  server_down = .false.\n  server_slow = .true.\n\n  ! Check if the server is down or slow\n  alert = server_down .or. server_slow\n\n  if (alert) then\n     print *, \"Alert: Server is either down or running slow.\"\n  else\n     print *, \"Server is running normally.\"\n  end if\nend program server_status\n```"
  },
  {
    "task": "Design a validation method to ensure a form field is not empty using logical NOT.",
    "code": "```fortran\nprogram validate_form_field\n    implicit none\n    character(len=100) :: field_input\n    logical :: is_empty\n\n    ! Example input\n    field_input = \"\"\n\n    is_empty = .not. (len_trim(field_input) > 0)\n\n    if (is_empty) then\n        print *, \"The form field is empty.\"\n    else\n        print *, \"The form field is not empty.\"\n    end if\nend program validate_form_field\n```"
  },
  {
    "task": "Write a program to determine if two strings are both non-empty using logical AND.",
    "code": "```fortran\nprogram check_non_empty_strings\n  implicit none\n  character(len=100) :: string1, string2\n  logical :: are_both_non_empty\n\n  ! Initialize strings\n  string1 = \"Hello\"\n  string2 = \"World\"\n\n  ! Check if both strings are non-empty\n  are_both_non_empty = (len_trim(string1) > 0) .and. (len_trim(string2) > 0)\n\n  ! Output the result\n  if (are_both_non_empty) then\n    print *, \"Both strings are non-empty.\"\n  else\n    print *, \"At least one of the strings is empty.\"\n  end if\n\nend program check_non_empty_strings\n```"
  },
  {
    "task": "Create a function that checks if a number is either prime or a perfect square using logical OR.",
    "code": "```fortran\nmodule number_check\n  implicit none\ncontains\n  logical function is_prime_or_perfect_square(n)\n    integer, intent(in) :: n\n    integer :: i\n    logical :: is_prime, is_perfect_square\n\n    is_prime = .true.\n    is_perfect_square = .false.\n\n    if (n <= 1) then\n      is_prime = .false.\n    else if (n == 2) then\n      is_prime = .true.\n    else\n      do i = 2, int(sqrt(real(n)))\n        if (mod(n, i) == 0) then\n          is_prime = .false.\n          exit\n        end if\n      end do\n    end if\n\n    if (int(sqrt(real(n)))**2 == n) then\n      is_perfect_square = .true.\n    end if\n\n    is_prime_or_perfect_square = is_prime .or. is_perfect_square\n  end function is_prime_or_perfect_square\nend module number_check\n```"
  },
  {
    "task": "Develop a script to ensure a user is either an adult or has parental consent using logical OR.",
    "code": "```fortran\nPROGRAM CheckPermission\n  IMPLICIT NONE\n  LOGICAL :: isAdult, hasParentalConsent, hasPermission\n\n  ! Sample data: Change these values to test different scenarios\n  isAdult = .FALSE.\n  hasParentalConsent = .TRUE.\n\n  ! Check permission using logical OR\n  hasPermission = isAdult .OR. hasParentalConsent\n\n  ! Output the result\n  IF (hasPermission) THEN\n    PRINT *, \"User has permission.\"\n  ELSE\n    PRINT *, \"User does not have permission.\"\n  END IF\n\nEND PROGRAM CheckPermission\n```"
  },
  {
    "task": "Implement a condition to execute a task if a variable is neither zero nor negative using logical NOT.",
    "code": "```fortran\nprogram LogicalOperation\n    implicit none\n    integer :: variable\n\n    ! Initialize the variable with a value\n    variable = 5\n\n    ! Check if the variable is neither zero nor negative using logical NOT\n    if (.not. (variable <= 0)) then\n        print *, \"The variable is positive.\"\n    else\n        print *, \"The variable is zero or negative.\"\n    end if\nend program LogicalOperation\n```"
  },
  {
    "task": "Compose a method to verify if a system is both up-to-date and functioning using logical AND.",
    "code": "```fortran\nprogram SystemCheck\n    implicit none\n    logical :: isUpToDate\n    logical :: isFunctioning\n    logical :: isSystemOK\n\n    ! Example values for system status\n    isUpToDate = .true.\n    isFunctioning = .true.\n\n    isSystemOK = checkSystem(isUpToDate, isFunctioning)\n\n    print *, \"Is the system OK? \", isSystemOK\n\ncontains\n\n    logical function checkSystem(upToDate, functioning)\n        logical, intent(in) :: upToDate\n        logical, intent(in) :: functioning\n\n        checkSystem = upToDate .and. functioning\n    end function checkSystem\n\nend program SystemCheck\n```"
  },
  {
    "task": "Write a function that returns true if a list contains neither duplicates nor null values using logical NOT.",
    "code": "```fortran\nmodule list_operations\n  implicit none\ncontains\n  logical function has_no_duplicates_or_nulls(list)\n    integer, intent(in) :: list(:)\n    integer :: i, j\n    logical :: is_null\n\n    has_no_duplicates_or_nulls = .true.\n    do i = 1, size(list)\n      is_null = list(i) == 0\n      if (.not. is_null) then\n        do j = i + 1, size(list)\n          if (list(i) == list(j)) then\n            has_no_duplicates_or_nulls = .false.\n            return\n          end if\n        end do\n      else\n        has_no_duplicates_or_nulls = .false.\n        return\n      end if\n    end do\n  end function has_no_duplicates_or_nulls\nend module list_operations\n```"
  },
  {
    "task": "Create a script to perform an action if a temperature is either too high or too low using logical OR.",
    "code": "```fortran\nprogram temperature_check\n  implicit none\n  real :: temperature\n  logical :: too_high, too_low\n\n  ! Assign a value to temperature\n  temperature = 25.0\n\n  ! Define the conditions\n  too_high = temperature > 30.0\n  too_low = temperature < 10.0\n\n  ! Perform action if temperature is either too high or too low\n  if (too_high .or. too_low) then\n    print *, \"Temperature is out of the acceptable range.\"\n  end if\nend program temperature_check\n```"
  },
  {
    "task": "Design a feature to toggle an option if a setting is not enabled using logical NOT.",
    "code": "```fortran\nprogram toggle_option\n  logical :: option, setting\n\n  ! Initialize the option and setting\n  option = .true.\n  setting = .false.\n\n  ! Toggle the option if the setting is not enabled\n  if (.not. setting) then\n     option = .not. option\n  end if\n\n  ! Output the result\n  print *, \"Option is now:\", option\nend program toggle_option\n```"
  },
  {
    "task": "Develop a check to ensure a username is both available and meets length requirements using logical AND.",
    "code": "```fortran\nprogram check_username\n    implicit none\n\n    character(len=100) :: username\n    logical :: is_available, length_ok, is_valid\n\n    write(*,*) 'Enter the username:'\n    read(*,*) username\n\n    is_available = .true. ! Assume the username is available for demonstration\n    length_ok = len_trim(username) >= 5 .and. len_trim(username) <= 15\n\n    is_valid = is_available .and. length_ok\n\n    if (is_valid) then\n        write(*,*) 'Username is valid.'\n    else\n        write(*,*) 'Username is invalid.'\n    end if\n\nend program check_username\n```"
  },
  {
    "task": "Implement a function that returns true if a number is neither too large nor too small using logical NOT.",
    "code": "```fortran\nprogram LogicalOperations\n  implicit none\n  logical :: isWithinRange\n  integer :: number\n\n  number = 50\n  print *, isWithinRange(number)\n\ncontains\n\n  logical function isWithinRange(n)\n    integer, intent(in) :: n\n    isWithinRange = .not. (n < 10 .or. n > 100)\n  end function isWithinRange\n\nend program LogicalOperations\n```"
  },
  {
    "task": "Write a conditional to print a warning if a disk is either full or nearly full using logical OR.",
    "code": "```fortran\nprogram DiskCheck\n  implicit none\n  \n  logical :: isFull, isNearlyFull\n\n  ! Example conditions (these would be determined by some logic in real use)\n  isFull = .false.\n  isNearlyFull = .true.\n\n  if (isFull .or. isNearlyFull) then\n    print *, \"Warning: Disk is full or nearly full.\"\n  end if\n\nend program DiskCheck\n```"
  },
  {
    "task": "Create a routine to validate that two dates are both within a valid range using logical AND.",
    "code": "```fortran\nprogram validate_dates\n  implicit none\n  logical :: are_dates_valid\n  character(len=10) :: date1, date2\n  \n  date1 = \"2023-10-15\"\n  date2 = \"2023-11-05\"\n  \n  are_dates_valid = validate_date(date1) .and. validate_date(date2)\n  \n  if (are_dates_valid) then\n    print *, \"Both dates are valid.\"\n  else\n    print *, \"One or both dates are invalid.\"\n  end if\nend program validate_dates\n\nlogical function validate_date(date)\n  implicit none\n  character(len=10), intent(in) :: date\n  integer :: year, month, day\n  logical :: is_valid\n\n  read(date, '(I4,1X,I2,1X,I2)') year, month, day\n  \n  is_valid = (year >= 1900 .and. year <= 2100) .and. &\n             (month >= 1 .and. month <= 12) .and. &\n             (day >= 1 .and. day <= 31)\n  \n  validate_date = is_valid\nend function validate_date\n```"
  },
  {
    "task": "Compose a function to decide if a person is either a minor or a senior using logical OR.",
    "code": "```fortran\nprogram AgeCheck\n    implicit none\n    integer :: age\n    logical :: isMinorOrSenior\n\n    print *, \"Enter age:\"\n    read *, age\n\n    isMinorOrSenior = checkAge(age)\n    if (isMinorOrSenior) then\n        print *, \"The person is either a minor or a senior.\"\n    else\n        print *, \"The person is neither a minor nor a senior.\"\n    end if\n\ncontains\n\n    logical function checkAge(age)\n        integer, intent(in) :: age\n        checkAge = (age < 18) .or. (age >= 65)\n    end function checkAge\n\nend program AgeCheck\n```"
  },
  {
    "task": "Design a script to execute a task if a condition is not met using logical NOT.",
    "code": "```fortran\nprogram logical_operations\n  implicit none\n  logical :: condition\n\n  ! Initialize the condition\n  condition = .false.\n\n  ! Execute the task if the condition is not met\n  if (.not. condition) then\n     print *, \"Executing the task because the condition is not met.\"\n  end if\nend program logical_operations\n```"
  },
  {
    "task": "Develop a program to verify if a process is neither running nor scheduled using logical NOT.",
    "code": "```fortran\nprogram process_check\n  implicit none\n  logical :: is_running, is_scheduled, is_neither\n\n  ! Example values for is_running and is_scheduled\n  is_running = .false.\n  is_scheduled = .false.\n\n  ! Check if the process is neither running nor scheduled\n  is_neither = .not. (is_running .or. is_scheduled)\n\n  ! Output the result\n  if (is_neither) then\n     print *, \"The process is neither running nor scheduled.\"\n  else\n     print *, \"The process is either running or scheduled.\"\n  end if\n\nend program process_check\n```"
  },
  {
    "task": "Implement a feature that confirms a file is both accessible and not locked using logical AND.",
    "code": "```fortran\nprogram file_check\n    implicit none\n    logical :: is_accessible, is_not_locked, file_ok\n    character(len=100) :: filename\n\n    ! Example filename\n    filename = 'example.txt'\n\n    ! Simulate file accessibility and lock status\n    is_accessible = .true.  ! Assume the file is accessible\n    is_not_locked = .true.  ! Assume the file is not locked\n\n    ! Check if the file is both accessible and not locked\n    file_ok = is_accessible .and. is_not_locked\n\n    if (file_ok) then\n        print *, \"The file is accessible and not locked.\"\n    else\n        print *, \"The file is either not accessible or locked.\"\n    end if\nend program file_check\n```"
  },
  {
    "task": "Write a script to check if a device is either offline or in maintenance mode using logical OR.",
    "code": "```fortran\nprogram DeviceStatusCheck\n    implicit none\n    logical :: isOffline, isInMaintenanceMode, isDeviceUnavailable\n\n    ! Initialize the device status\n    isOffline = .true.  ! Example status, can be .true. or .false.\n    isInMaintenanceMode = .false.  ! Example status, can be .true. or .false.\n\n    ! Check if the device is either offline or in maintenance mode\n    isDeviceUnavailable = isOffline .or. isInMaintenanceMode\n\n    ! Output the result\n    if (isDeviceUnavailable) then\n        print *, \"The device is unavailable.\"\n    else\n        print *, \"The device is available.\"\n    end if\nend program DeviceStatusCheck\n```"
  },
  {
    "task": "Create a function to ensure a password is both complex and unique using logical AND.",
    "code": "```fortran\nprogram PasswordCheck\n  implicit none\n  character(len=100) :: password\n  logical :: isComplex, isUnique\n\n  password = \"ExamplePassword1!\"\n\n  isComplex = checkComplexity(password)\n  isUnique = checkUniqueness(password)\n\n  if (isComplex .and. isUnique) then\n     print *, \"Password is both complex and unique.\"\n  else\n     print *, \"Password is not suitable.\"\n  end if\n\ncontains\n\n  logical function checkComplexity(pwd)\n    character(len=*), intent(in) :: pwd\n    logical :: hasUpper, hasLower, hasDigit, hasSpecial\n    integer :: i\n\n    hasUpper = .false.\n    hasLower = .false.\n    hasDigit = .false.\n    hasSpecial = .false.\n\n    do i = 1, len_trim(pwd)\n      select case(pwd(i:i))\n      case ('A':'Z')\n        hasUpper = .true.\n      case ('a':'z')\n        hasLower = .true.\n      case ('0':'9')\n        hasDigit = .true.\n      case ('!', '@', '#', '$', '%', '^', '&', '*', '(', ')', '-', '_', '=', '+')\n        hasSpecial = .true.\n      end select\n    end do\n\n    checkComplexity = hasUpper .and. hasLower .and. hasDigit .and. hasSpecial\n  end function checkComplexity\n\n  logical function checkUniqueness(pwd)\n    character(len=*), intent(in) :: pwd\n    ! This is a stub for uniqueness check; replace with actual logic\n    checkUniqueness = .true.  ! Assume the password is unique\n  end function checkUniqueness\n\nend program PasswordCheck\n```"
  },
  {
    "task": "Design a validation that ensures a value is not negative using logical NOT.",
    "code": "```fortran\nprogram validate_non_negative\n  implicit none\n  integer :: value\n  logical :: is_non_negative\n\n  ! Example input\n  value = -5\n\n  ! Validate if value is not negative\n  is_non_negative = .not. (value < 0)\n\n  if (is_non_negative) then\n     print *, \"The value is non-negative.\"\n  else\n     print *, \"The value is negative.\"\n  end if\nend program validate_non_negative\n```"
  },
  {
    "task": "Develop a check to see if a user has either exceeded their quota or is nearing it using logical OR.",
    "code": "```fortran\nPROGRAM QuotaCheck\n  IMPLICIT NONE\n  INTEGER :: usage, quota, threshold\n  LOGICAL :: exceeded, nearing, alert\n\n  ! Example values\n  quota = 100\n  threshold = 90\n  usage = 95\n\n  exceeded = (usage > quota)\n  nearing = (usage >= threshold)\n  alert = exceeded .OR. nearing\n\n  IF (alert) THEN\n    PRINT *, \"User has either exceeded their quota or is nearing it.\"\n  ELSE\n    PRINT *, \"User is within safe limits.\"\n  END IF\nEND PROGRAM QuotaCheck\n```"
  },
  {
    "task": "Implement a routine to confirm that a user is both authenticated and authorized using logical AND.",
    "code": "```fortran\nprogram auth_check\n  implicit none\n  logical :: is_authenticated\n  logical :: is_authorized\n  logical :: is_access_granted\n\n  ! Example values for demonstration\n  is_authenticated = .true.\n  is_authorized = .true.\n\n  ! Logical AND operation to check both conditions\n  is_access_granted = is_authenticated .and. is_authorized\n\n  if (is_access_granted) then\n    print *, \"Access granted.\"\n  else\n    print *, \"Access denied.\"\n  end if\nend program auth_check\n```"
  },
  {
    "task": "Compose a function to determine if a light is either on or blinking using logical OR.",
    "code": "```fortran\nprogram LightStatus\n  implicit none\n  logical :: isOn, isBlinking\n  isOn = .true.\n  isBlinking = .false.\n  print *, isLightOnOrBlinking(isOn, isBlinking)\ncontains\n  logical function isLightOnOrBlinking(on, blinking)\n    implicit none\n    logical, intent(in) :: on, blinking\n    isLightOnOrBlinking = on .or. blinking\n  end function isLightOnOrBlinking\nend program LightStatus\n```"
  },
  {
    "task": "Write a script that executes a command if a network connection is neither weak nor unstable using logical NOT.",
    "code": "```fortran\nprogram check_connection\n    implicit none\n    logical :: weak, unstable, execute_command\n\n    ! Assume some logic to determine the status of the network connection\n    weak = .false.\n    unstable = .false.\n\n    execute_command = .not. (weak .or. unstable)\n\n    if (execute_command) then\n        print *, \"Executing command as the network connection is strong and stable.\"\n        ! Call the function or command here\n    else\n        print *, \"Network connection is weak or unstable. Command execution aborted.\"\n    end if\nend program check_connection\n```"
  },
  {
    "task": "Create a program to verify that a sensor is both calibrated and active using logical AND.",
    "code": "```fortran\nprogram sensor_verification\n    implicit none\n    logical :: calibrated, active, sensor_ok\n\n    ! Assign sensor states\n    calibrated = .true.\n    active = .true.\n\n    ! Verify sensor status\n    sensor_ok = calibrated .and. active\n\n    ! Output the result\n    if (sensor_ok) then\n        print *, \"The sensor is both calibrated and active.\"\n    else\n        print *, \"The sensor is not properly calibrated or not active.\"\n    end if\nend program sensor_verification\n```"
  },
  {
    "task": "Design a feature to alert if a process is either overdue or incomplete using logical OR.",
    "code": "```fortran\nprogram process_alert\n  implicit none\n  logical :: is_overdue, is_incomplete, alert\n\n  ! Example values for demonstration\n  is_overdue = .true.\n  is_incomplete = .false.\n\n  alert = is_overdue .or. is_incomplete\n\n  if (alert) then\n    print *, \"Alert: The process is either overdue or incomplete.\"\n  else\n    print *, \"The process is on track.\"\n  end if\nend program process_alert\n```"
  },
  {
    "task": "Develop a script to check if a person is neither a guest nor a temporary user using logical NOT.",
    "code": "```fortran\nprogram check_user_status\n  implicit none\n\n  logical :: is_guest, is_temp_user, is_neither\n\n  ! Example values for the user's status\n  is_guest = .false.\n  is_temp_user = .false.\n\n  ! Check if the person is neither a guest nor a temporary user\n  is_neither = .not.(is_guest .or. is_temp_user)\n\n  if (is_neither) then\n    print *, \"The person is neither a guest nor a temporary user.\"\n  else\n    print *, \"The person is either a guest or a temporary user.\"\n  end if\n\nend program check_user_status\n```"
  },
  {
    "task": "Implement a function to toggle a light if a switch is not pressed using logical NOT.",
    "code": "```fortran\nprogram ToggleLight\n  implicit none\n\n  logical :: light_on, switch_pressed\n\n  ! Initialize the state\n  light_on = .false.\n  switch_pressed = .false.\n\n  ! Call the function to toggle the light\n  call toggle_light(light_on, switch_pressed)\n\n  ! Print the result\n  print *, 'Light is', light_on\n\ncontains\n\n  subroutine toggle_light(light, switch)\n    logical, intent(inout) :: light\n    logical, intent(in) :: switch\n\n    if (.not. switch) then\n      light = .not. light\n    end if\n  end subroutine toggle_light\n\nend program ToggleLight\n```"
  },
  {
    "task": "Write a conditional to trigger an event if a file is either corrupted or missing using logical OR.",
    "code": "```fortran\nPROGRAM FileCheck\n  LOGICAL :: isCorrupted, isMissing\n\n  ! Assuming isCorrupted and isMissing are set based on some condition checks\n  isCorrupted = .FALSE.\n  isMissing = .TRUE.\n\n  IF (isCorrupted .OR. isMissing) THEN\n    PRINT *, \"Triggering event: File is either corrupted or missing.\"\n  END IF\nEND PROGRAM FileCheck\n```"
  },
  {
    "task": "Create a routine that verifies if a vehicle is both insured and registered using logical AND.",
    "code": "```fortran\nprogram VehicleVerification\n  implicit none\n\n  logical :: isInsured\n  logical :: isRegistered\n  logical :: isVerified\n\n  ! Example values\n  isInsured = .true.\n  isRegistered = .true.\n\n  isVerified = isInsured .and. isRegistered\n\n  if (isVerified) then\n    print *, \"The vehicle is both insured and registered.\"\n  else\n    print *, \"The vehicle is not both insured and registered.\"\n  end if\n\nend program VehicleVerification\n```"
  },
  {
    "task": "Compose a method to check if an account is either overdrawn or flagged using logical OR.",
    "code": "```fortran\nMODULE AccountModule\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION IsAccountOverdrawnOrFlagged(balance, isFlagged) RESULT(isOverdrawnOrFlagged)\n    LOGICAL :: isOverdrawnOrFlagged\n    REAL, INTENT(IN) :: balance\n    LOGICAL, INTENT(IN) :: isFlagged\n\n    isOverdrawnOrFlagged = (balance < 0.0) .OR. isFlagged\n  END FUNCTION IsAccountOverdrawnOrFlagged\nEND MODULE AccountModule\n```"
  },
  {
    "task": "Design a program to ensure an application is both installed and updated using logical AND.",
    "code": "```fortran\nprogram ApplicationStatus\n  implicit none\n  logical :: isInstalled, isUpdated, isReady\n\n  ! Example status values\n  isInstalled = .true.\n  isUpdated = .true.\n\n  ! Check if the application is both installed and updated\n  isReady = isInstalled .and. isUpdated\n\n  if (isReady) then\n    print *, \"The application is both installed and updated.\"\n  else\n    print *, \"The application is not ready.\"\n  end if\nend program ApplicationStatus\n```"
  },
  {
    "task": "Develop a function that returns true if a number is neither divisible by 3 nor 5 using logical NOT.",
    "code": "```fortran\nprogram logical_operations\n  implicit none\n  print *, is_neither_divisible(7)  ! Example call\ncontains\n  logical function is_neither_divisible(n)\n    integer, intent(in) :: n\n    is_neither_divisible = .not. ((mod(n, 3) == 0) .or. (mod(n, 5) == 0))\n  end function is_neither_divisible\nend program logical_operations\n```"
  },
  {
    "task": "Implement a script that alerts if a device is either overheating or underperforming using logical OR.",
    "code": "```fortran\nprogram device_status\n  implicit none\n  logical :: overheating, underperforming, alert\n\n  ! Sample conditions\n  overheating = .true.\n  underperforming = .false.\n\n  ! Logical OR operation\n  alert = overheating .or. underperforming\n\n  if (alert) then\n    print *, \"Alert: Device status requires attention.\"\n  else\n    print *, \"Device is operating normally.\"\n  end if\n\nend program device_status\n```"
  },
  {
    "task": "Write a function to validate that a directory is both writable and not full using logical AND.",
    "code": "```fortran\nmodule directory_module\n    implicit none\ncontains\n    function validate_directory(directory_path) result(is_valid)\n        implicit none\n        character(len=*), intent(in) :: directory_path\n        logical :: is_valid\n        logical :: is_writable, is_not_full\n        \n        ! Dummy logic for illustration purposes\n        is_writable = .true.  ! Assume the directory is writable\n        is_not_full = .true.  ! Assume the directory is not full\n\n        ! Validate using logical AND\n        is_valid = is_writable .and. is_not_full\n    end function validate_directory\nend module directory_module\n```"
  },
  {
    "task": "Create a conditional statement that executes if a button is not clicked using logical NOT.",
    "code": "```fortran\nprogram button_check\n  implicit none\n  logical :: button_clicked\n\n  ! Assume button_clicked is set somewhere in the program\n  button_clicked = .false.\n\n  if (.not. button_clicked) then\n    print *, \"The button has not been clicked.\"\n  end if\n\nend program button_check\n```"
  },
  {
    "task": "Design a check to ensure a transaction is both verified and complete using logical AND.",
    "code": "```fortran\nprogram transaction_check\n  logical :: verified, complete, isTransactionValid\n\n  ! Assume the values for verified and complete are set elsewhere in the program\n  verified = .true.\n  complete = .true.\n\n  isTransactionValid = verified .and. complete\n\n  if (isTransactionValid) then\n    print *, \"Transaction is valid.\"\n  else\n    print *, \"Transaction is not valid.\"\n  end if\nend program transaction_check\n```"
  },
  {
    "task": "Develop a routine to determine if a string is either uppercase or lowercase using logical OR.",
    "code": "```fortran\nprogram determine_case\n    implicit none\n    character(len=100) :: inputString\n    logical :: isUpperCase, isLowerCase\n\n    print *, \"Enter a string:\"\n    read *, inputString\n\n    isUpperCase = .true.\n    isLowerCase = .true.\n\n    call check_case(inputString, isUpperCase, isLowerCase)\n\n    if (isUpperCase .or. isLowerCase) then\n        if (isUpperCase) then\n            print *, \"The string is uppercase.\"\n        else\n            print *, \"The string is lowercase.\"\n        end if\n    else\n        print *, \"The string is mixed case.\"\n    end if\n\ncontains\n\n    subroutine check_case(str, isUpper, isLower)\n        character(len=*), intent(in) :: str\n        logical, intent(out) :: isUpper, isLower\n        integer :: i, length\n\n        length = len_trim(str)\n        isUpper = .true.\n        isLower = .true.\n\n        do i = 1, length\n            if (iachar(str(i:i)) >= iachar('a') .and. iachar(str(i:i)) <= iachar('z')) then\n                isUpper = .false.\n            else if (iachar(str(i:i)) >= iachar('A') .and. iachar(str(i:i)) <= iachar('Z')) then\n                isLower = .false.\n            end if\n        end do\n    end subroutine check_case\n\nend program determine_case\n```"
  },
  {
    "task": "Implement a feature to execute a task if a variable is neither null nor undefined using logical NOT.",
    "code": "```fortran\nprogram LogicalOperations\n  implicit none\n  logical :: isNotNull, isNotUndefined, executeTask\n\n  ! Initialize the logical variables\n  isNotNull = .true.\n  isNotUndefined = .true.\n\n  ! Execute the task if the variable is neither null nor undefined\n  executeTask = .not. (.not. isNotNull .or. .not. isNotUndefined)\n\n  if (executeTask) then\n    print *, \"Executing task as the variable is neither null nor undefined.\"\n  else\n    print *, \"Task will not be executed.\"\n  end if\n\nend program LogicalOperations\n```"
  },
  {
    "task": "Compose a function to return true if a date is either today or tomorrow using logical OR.",
    "code": "```fortran\nprogram DateCheck\n  implicit none\n  logical :: isTodayOrTomorrow\n  integer :: today(3), date(3)\n\n  ! Example date to check\n  date = (/2023, 10, 5/)\n\n  ! Suppose today is October 4, 2023\n  today = (/2023, 10, 4/)\n\n  if (isTodayOrTomorrow(date, today)) then\n    print *, \"The date is today or tomorrow.\"\n  else\n    print *, \"The date is neither today nor tomorrow.\"\n  end if\n\ncontains\n\n  logical function isTodayOrTomorrow(date, today)\n    integer, intent(in) :: date(3), today(3)\n    logical :: isToday, isTomorrow\n\n    isToday = all(date == today)\n    isTomorrow = (date(1) == today(1)) .and. (date(2) == today(2)) .and. (date(3) == today(3) + 1)\n\n    isTodayOrTomorrow = isToday .or. isTomorrow\n  end function isTodayOrTomorrow\n\nend program DateCheck\n```"
  },
  {
    "task": "Write a script to confirm that a system is both running and not in maintenance mode using logical AND.",
    "code": "```fortran\nprogram check_system_status\n  logical :: is_running, is_in_maintenance, is_operational\n\n  ! Assume these values are obtained from the system\n  is_running = .true.\n  is_in_maintenance = .false.\n\n  is_operational = is_running .and. .not. is_in_maintenance\n\n  if (is_operational) then\n    print *, \"The system is operational.\"\n  else\n    print *, \"The system is not operational.\"\n  end if\nend program check_system_status\n```"
  },
  {
    "task": "Create a program to verify if a text field is neither empty nor exceeds character limit using logical NOT.",
    "code": "```fortran\nprogram verifyTextField\n    implicit none\n    character(len=100) :: textField\n    integer :: charLimit\n    logical :: isValid\n\n    ! Example input\n    textField = \"Example text\"\n    charLimit = 50\n\n    ! Verify if text field is neither empty nor exceeds the character limit\n    isValid = .not. ((len_trim(textField) == 0) .or. (len_trim(textField) > charLimit))\n\n    if (isValid) then\n        print *, \"Text field is valid.\"\n    else\n        print *, \"Text field is not valid.\"\n    end if\nend program verifyTextField\n```"
  },
  {
    "task": "Design a feature that checks if a user has either admin privileges or editor rights using logical OR.",
    "code": "```fortran\nprogram check_privileges\n    implicit none\n    logical :: isAdmin, isEditor, hasPrivileges\n\n    ! Sample input\n    isAdmin = .false.\n    isEditor = .true.\n\n    ! Check privileges\n    hasPrivileges = isAdmin .or. isEditor\n\n    ! Output result\n    if (hasPrivileges) then\n        print *, \"User has sufficient privileges.\"\n    else\n        print *, \"User does not have sufficient privileges.\"\n    end if\nend program check_privileges\n```"
  },
  {
    "task": "Develop a script to ensure a file is both present and not empty using logical AND.",
    "code": "```fortran\nprogram check_file\n    implicit none\n    logical :: file_exists, file_not_empty\n    character(len=256) :: filename\n\n    ! Set the filename to check\n    filename = 'example.txt'\n\n    ! Check if the file exists\n    inquire(file=filename, exist=file_exists)\n\n    ! Check if the file size is greater than zero\n    inquire(file=filename, size=file_not_empty)\n\n    ! Ensure the file is both present and not empty\n    if (file_exists .and. file_not_empty) then\n        print *, \"The file is present and not empty.\"\n    else\n        print *, \"The file is either missing or empty.\"\n    endif\nend program check_file\n```"
  },
  {
    "task": "Implement a condition to execute a command if a setting is not active using logical NOT.",
    "code": "```fortran\nprogram logical_not_example\n  implicit none\n  logical :: setting_active\n\n  setting_active = .false.\n\n  if (.not. setting_active) then\n     print *, 'The setting is not active, executing command.'\n  end if\n\nend program logical_not_example\n```"
  },
  {
    "task": "Compose a method to decide if a person is either eligible or exempt using logical OR.",
    "code": "```fortran\nPROGRAM EligibilityCheck\n  IMPLICIT NONE\n  LOGICAL :: isEligible, isExempt\n\n  ! Example values for eligibility and exemption\n  isEligible = .TRUE.\n  isExempt = .FALSE.\n\n  CALL CheckEligibility(isEligible, isExempt)\n  \nCONTAINS\n\n  SUBROUTINE CheckEligibility(eligible, exempt)\n    LOGICAL, INTENT(IN) :: eligible, exempt\n    LOGICAL :: result\n\n    result = eligible .OR. exempt\n\n    IF (result) THEN\n      PRINT *, 'The person is either eligible or exempt.'\n    ELSE\n      PRINT *, 'The person is neither eligible nor exempt.'\n    END IF\n  END SUBROUTINE CheckEligibility\n\nEND PROGRAM EligibilityCheck\n```"
  },
  {
    "task": "Write a function that returns true if a number is both greater than zero and less than ten using logical AND.",
    "code": "```fortran\nlogical function is_greater_than_zero_and_less_than_ten(number)\n    implicit none\n    integer, intent(in) :: number\n    is_greater_than_zero_and_less_than_ten = (number > 0 .and. number < 10)\nend function is_greater_than_zero_and_less_than_ten\n```"
  },
  {
    "task": "Create a loop to continue as long as a condition is either true or false using logical OR.",
    "code": "```fortran\nprogram logical_operations\n  implicit none\n  logical :: condition1, condition2\n  integer :: counter\n\n  condition1 = .false.\n  condition2 = .true.\n  counter = 0\n\n  do while (condition1 .or. condition2)\n    print *, \"Loop iteration: \", counter\n    counter = counter + 1\n\n    ! Logic to potentially change the conditions\n    if (counter == 5) then\n      condition1 = .true.\n    end if\n\n    if (counter == 10) then\n      condition2 = .false.\n    end if\n  end do\nend program logical_operations\n```"
  },
  {
    "task": "Design a program to verify if an account is neither inactive nor suspended using logical NOT.",
    "code": "```fortran\nprogram account_status\n  implicit none\n  logical :: is_inactive, is_suspended, is_active\n\n  ! Initialize account status\n  is_inactive = .false.\n  is_suspended = .false.\n\n  ! Verify if the account is neither inactive nor suspended\n  is_active = .not. (is_inactive .or. is_suspended)\n\n  ! Output the result\n  if (is_active) then\n    print *, 'The account is active.'\n  else\n    print *, 'The account is not active.'\n  end if\n\nend program account_status\n```"
  },
  {
    "task": "Develop a feature to confirm that a document is both signed and verified using logical AND.",
    "code": "```fortran\nPROGRAM DocumentCheck\n  LOGICAL :: isSigned, isVerified, isConfirmed\n\n  ! Sample values, these would be set based on actual document status\n  isSigned = .TRUE.\n  isVerified = .TRUE.\n\n  ! Confirm the document is both signed and verified\n  isConfirmed = isSigned .AND. isVerified\n\n  PRINT *, \"Document confirmed: \", isConfirmed\nEND PROGRAM DocumentCheck\n```"
  },
  {
    "task": "Implement a script to alert if a network is either congested or down using logical OR.",
    "code": "```fortran\nprogram networkAlert\n  implicit none\n\n  logical :: isCongested, isDown, alert\n\n  ! Assume these variables are set based on network status\n  isCongested = .true.  ! Example value for illustrating\n  isDown = .false.      ! Example value for illustrating\n\n  alert = isCongested .or. isDown\n\n  if (alert) then\n     print *, \"Alert: Network is either congested or down.\"\n  else\n     print *, \"Network is operating normally.\"\n  end if\n\nend program networkAlert\n```"
  },
  {
    "task": "Write a function to ensure a list is both sorted and unique using logical AND.",
    "code": "```fortran\nprogram Main\n  implicit none\n  integer, allocatable :: arr(:)\n  integer :: n, i\n  logical :: isSortedAndUnique\n\n  ! Example array\n  n = 5\n  allocate(arr(n))\n  arr = [1, 2, 3, 4, 5]\n\n  ! Check if the array is sorted and unique\n  isSortedAndUnique = checkSortedAndUnique(arr)\n  print *, \"Array is sorted and unique: \", isSortedAndUnique\n\ncontains\n\n  logical function checkSortedAndUnique(arr)\n    implicit none\n    integer, intent(in) :: arr(:)\n    integer :: i\n    logical :: isSorted, isUnique\n\n    isSorted = .true.\n    isUnique = .true.\n\n    do i = 1, size(arr) - 1\n      if (arr(i) >= arr(i + 1)) then\n        isSorted = .false.\n      end if\n      if (arr(i) == arr(i + 1)) then\n        isUnique = .false.\n      end if\n    end do\n\n    checkSortedAndUnique = isSorted .and. isUnique\n\n  end function checkSortedAndUnique\n\nend program Main\n```"
  },
  {
    "task": "Create a conditional statement to execute if a task is not completed using logical NOT.",
    "code": "```fortran\nprogram check_task\n  implicit none\n  logical :: task_completed\n\n  task_completed = .false.\n\n  if (.not. task_completed) then\n    print *, 'Task is not completed.'\n  end if\n\nend program check_task\n```"
  },
  {
    "task": "Design a check to determine if a component is either faulty or missing using logical OR.",
    "code": "```fortran\nprogram component_check\n    implicit none\n    logical :: isFaulty, isMissing, needCheck\n\n    ! Set the status of the component\n    isFaulty = .true.\n    isMissing = .false.\n\n    ! Determine if the component is either faulty or missing\n    needCheck = isFaulty .or. isMissing\n\n    ! Output the result\n    if (needCheck) then\n        print *, \"Component needs attention: it is either faulty or missing.\"\n    else\n        print *, \"Component is functioning correctly.\"\n    end if\nend program component_check\n```"
  },
  {
    "task": "Develop a routine to verify if a user is both online and available using logical AND.",
    "code": "```fortran\nPROGRAM CheckUserStatus\n  LOGICAL :: isOnline, isAvailable, isUserActive\n\n  ! Simulate user status\n  isOnline = .TRUE.         ! User is online\n  isAvailable = .TRUE.      ! User is available\n\n  ! Check if the user is both online and available\n  isUserActive = isOnline .AND. isAvailable\n\n  PRINT *, \"Is the user active? \", isUserActive\nEND PROGRAM CheckUserStatus\n```"
  },
  {
    "task": "Implement a feature to toggle an alert if a condition is not satisfied using logical NOT.",
    "code": "```fortran\nprogram toggle_alert\n  implicit none\n  logical :: condition, alert\n\n  ! Initialize condition and alert\n  condition = .true.\n  alert = .false.\n\n  ! Toggle alert if condition is not satisfied\n  if (.not. condition) then\n    alert = .not. alert\n  end if\n\n  print *, \"Alert status: \", alert\nend program toggle_alert\n```"
  },
  {
    "task": "Compose a function to return true if a transaction is either pending or failed using logical OR.",
    "code": "```fortran\nmodule transaction_module\n  implicit none\ncontains\n  logical function is_pending_or_failed(pending, failed)\n    logical, intent(in) :: pending, failed\n    is_pending_or_failed = pending .or. failed\n  end function is_pending_or_failed\nend module transaction_module\n```"
  },
  {
    "task": "Write a script to ensure a configuration is both correct and active using logical AND.",
    "code": "```fortran\nprogram configuration_check\n  logical :: is_correct, is_active, is_valid\n\n  ! Example values, these would typically be determined by some logic\n  is_correct = .true.\n  is_active = .true.\n\n  ! Check if configuration is both correct and active\n  is_valid = is_correct .and. is_active\n\n  if (is_valid) then\n      print *, \"Configuration is valid.\"\n  else\n      print *, \"Configuration is invalid.\"\n  end if\nend program configuration_check\n```"
  }
]