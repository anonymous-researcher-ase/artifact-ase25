[
  {
    "task": "Create a map to store student names as keys and their grades as values, then calculate the average grade.",
    "code": "```fortran\nprogram student_grades\n    implicit none\n    character(len=30), parameter :: students(*) = ['Alice', 'Bob', 'Charlie']\n    real :: grades(size(students))\n    real :: total, average\n    integer :: i\n\n    ! Initialize grades\n    grades = [85.0, 92.5, 78.0]\n\n    ! Calculate total\n    total = 0.0\n    do i = 1, size(grades)\n        total = total + grades(i)\n    end do\n\n    ! Calculate average\n    average = total / size(grades)\n\n    ! Output average\n    print *, 'Average grade:', average\n\nend program student_grades\n```"
  },
  {
    "task": "Develop a function that takes a dictionary of product names and prices, and returns the total cost of all products.",
    "code": "```fortran\nmodule product_cost_module\n    implicit none\ncontains\n    function total_cost(products) result(cost)\n        implicit none\n        real :: cost\n        character(len=*), dimension(:), intent(in) :: products(:)\n        real :: price\n        integer :: i\n        cost = 0.0\n        do i = 1, size(products)\n            read(products(i), *) price\n            cost = cost + price\n        end do\n    end function total_cost\nend module product_cost_module\n```"
  },
  {
    "task": "Implement a program that counts the frequency of each word in a given text using a dictionary.",
    "code": "```fortran\nprogram word_count\n    implicit none\n    character(len=100) :: text\n    type :: dict_entry\n        character(len=100) :: word\n        integer :: count\n    end type dict_entry\n    type(dict_entry), allocatable :: dictionary(:)\n    integer :: i, j, total_words, found\n    character(len=100) :: word\n    logical :: is_word\n    character(len=100), allocatable :: words(:)\n\n    text = \"this is a sample text with sample words and sample text\"\n\n    call split_text(text, words, total_words)\n\n    allocate(dictionary(0))\n    \n    do i = 1, total_words\n        word = words(i)\n        is_word = .false.\n        do j = 1, size(dictionary)\n            if (dictionary(j)%word == word) then\n                dictionary(j)%count = dictionary(j)%count + 1\n                is_word = .true.\n                exit\n            end if\n        end do\n        if (.not. is_word) then\n            allocate(dictionary(size(dictionary) + 1))\n            dictionary(size(dictionary))%word = word\n            dictionary(size(dictionary))%count = 1\n        end if\n    end do\n\n    do i = 1, size(dictionary)\n        print *, trim(dictionary(i)%word), ':', dictionary(i)%count\n    end do\n\n    contains\n\n    subroutine split_text(text, words, total_words)\n        character(len=*), intent(in) :: text\n        character(len=100), allocatable, intent(out) :: words(:)\n        integer, intent(out) :: total_words\n        character(len=100) :: temp_word\n        integer :: len_text, i, start, word_count\n\n        len_text = len_trim(text)\n        word_count = 0\n        start = 1\n\n        do i = 1, len_text\n            if (text(i:i) == ' ' .or. i == len_text) then\n                if (i == len_text .and. text(i:i) /= ' ') i = i + 1\n                if (i > start) then\n                    word_count = word_count + 1\n                    allocate(character(len=100) :: temp_word)\n                    temp_word = text(start:i-1)\n                    if (word_count == 1) then\n                        allocate(words(1))\n                    else\n                        allocate(words(word_count))\n                    end if\n                    words(word_count) = trim(adjustl(temp_word))\n                    start = i + 1\n                end if\n            end if\n        end do\n        total_words = word_count\n    end subroutine split_text\n\nend program word_count\n```"
  },
  {
    "task": "Write a function that takes a dictionary of employee IDs and their work hours, and returns the ID of the employee with the most hours.",
    "code": "```fortran\nmodule employee_module\n  implicit none\ncontains\n  function max_hours_employee(employee_hours) result(employee_id)\n    integer, dimension(:), intent(in) :: employee_hours(:)\n    integer :: employee_id\n    integer :: max_hours, id\n\n    max_hours = -1\n    employee_id = -1\n    do id = 1, size(employee_hours)\n      if (employee_hours(id) > max_hours) then\n        max_hours = employee_hours(id)\n        employee_id = id\n      end if\n    end do\n  end function max_hours_employee\nend module employee_module\n```"
  },
  {
    "task": "Design a system that uses a map to store users' login attempts and timestamps, then locks the account after three failed attempts.",
    "code": "```fortran\nmodule user_login\n  implicit none\n  type :: user_info\n     integer :: failed_attempts\n     character(len=30) :: last_timestamp\n  end type user_info\n\n  type(user_info), allocatable :: user_map(:)\n  character(len=30), allocatable :: usernames(:)\n  integer :: n_users = 0\n\ncontains\n\n  subroutine initialize_user_map()\n    allocate(user_map(0))\n    allocate(usernames(0))\n  end subroutine initialize_user_map\n\n  subroutine add_user(username)\n    character(len=*), intent(in) :: username\n    if (.not. is_user_in_map(username)) then\n      n_users = n_users + 1\n      call add_user_to_map(username)\n    end if\n  end subroutine add_user\n\n  logical function is_user_in_map(username)\n    character(len=*), intent(in) :: username\n    integer :: i\n    is_user_in_map = .false.\n    do i = 1, n_users\n      if (trim(usernames(i)) == trim(username)) then\n        is_user_in_map = .true.\n        exit\n      end if\n    end do\n  end function is_user_in_map\n\n  subroutine add_user_to_map(username)\n    character(len=*), intent(in) :: username\n    allocate(usernames(n_users))\n    allocate(user_map(n_users))\n    usernames(n_users) = trim(username)\n    user_map(n_users)%failed_attempts = 0\n    user_map(n_users)%last_timestamp = ''\n  end subroutine add_user_to_map\n\n  subroutine record_failed_attempt(username, timestamp)\n    character(len=*), intent(in) :: username, timestamp\n    integer :: i\n    do i = 1, n_users\n      if (trim(usernames(i)) == trim(username)) then\n        user_map(i)%failed_attempts = user_map(i)%failed_attempts + 1\n        user_map(i)%last_timestamp = trim(timestamp)\n        if (user_map(i)%failed_attempts >= 3) call lock_account(username)\n        exit\n      end if\n    end do\n  end subroutine record_failed_attempt\n\n  subroutine lock_account(username)\n    character(len=*), intent(in) :: username\n    print *, 'Account locked for user: ', trim(username)\n  end subroutine lock_account\n\nend module user_login\n```"
  },
  {
    "task": "Create a dictionary to represent a phonebook, allowing users to add, remove, and look up contacts by name.",
    "code": "```fortran\nprogram phonebook\n    implicit none\n    integer, parameter :: max_contacts = 100\n    character(len=50) :: names(max_contacts)\n    character(len=15) :: numbers(max_contacts)\n    integer :: num_contacts, choice, i\n    character(len=50) :: name\n    character(len=15) :: number\n\n    num_contacts = 0\n\n    do\n        print *, \"1. Add contact\"\n        print *, \"2. Remove contact\"\n        print *, \"3. Look up contact\"\n        print *, \"4. Exit\"\n        print *, \"Choose an option: \"\n        read *, choice\n\n        select case (choice)\n        case (1)\n            if (num_contacts < max_contacts) then\n                print *, \"Enter name: \"\n                read *, name\n                print *, \"Enter number: \"\n                read *, number\n                num_contacts = num_contacts + 1\n                names(num_contacts) = name\n                numbers(num_contacts) = number\n            else\n                print *, \"Phonebook is full.\"\n            end if\n\n        case (2)\n            print *, \"Enter name to remove: \"\n            read *, name\n            do i = 1, num_contacts\n                if (names(i) == name) then\n                    names(i) = names(num_contacts)\n                    numbers(i) = numbers(num_contacts)\n                    num_contacts = num_contacts - 1\n                    print *, \"Contact removed.\"\n                    exit\n                end if\n            end do\n            print *, \"Contact not found.\"\n\n        case (3)\n            print *, \"Enter name to look up: \"\n            read *, name\n            do i = 1, num_contacts\n                if (names(i) == name) then\n                    print *, \"Number: \", numbers(i)\n                    exit\n                end if\n            end do\n            print *, \"Contact not found.\"\n\n        case (4)\n            exit\n\n        case default\n            print *, \"Invalid option. Please try again.\"\n        end select\n    end do\nend program phonebook\n```"
  },
  {
    "task": "Build a map that associates city names with their population, then find the city with the highest population.",
    "code": "```fortran\nprogram city_population\n    implicit none\n    integer, parameter :: max_cities = 100\n    character(len=100), dimension(max_cities) :: cities\n    integer, dimension(max_cities) :: populations\n    integer :: num_cities, i, max_population, max_index\n    \n    num_cities = 5\n    cities(1:num_cities) = (/\"New York\", \"Los Angeles\", \"Chicago\", \"Houston\", \"Phoenix\"/)\n    populations(1:num_cities) = (/8175133, 3792621, 2695598, 2325502, 1660272/)\n\n    max_population = -1\n    max_index = -1\n\n    do i = 1, num_cities\n        if (populations(i) > max_population) then\n            max_population = populations(i)\n            max_index = i\n        end if\n    end do\n\n    print *, \"City with highest population:\", cities(max_index)\n    print *, \"Population:\", max_population\nend program city_population\n```"
  },
  {
    "task": "Write a program that translates English words to another language using a provided dictionary, and translates a given sentence.",
    "code": "```fortran\nprogram translate_sentence\n    implicit none\n    character(len=100), allocatable :: sentence(:)\n    character(len=50) :: word\n    integer :: i, n\n    type :: dictionary\n        character(len=50) :: english\n        character(len=50) :: translation\n    end type dictionary\n    type(dictionary), allocatable :: dict(:)\n\n    ! Example dictionary: English to Spanish\n    allocate(dict(3))\n    dict(1) = dictionary(\"hello\", \"hola\")\n    dict(2) = dictionary(\"world\", \"mundo\")\n    dict(3) = dictionary(\"programming\", \"programaci\u00f3n\")\n    \n    ! Example sentence\n    allocate(sentence(3))\n    sentence(1) = \"hello\"\n    sentence(2) = \"world\"\n    sentence(3) = \"programming\"\n\n    n = size(sentence)\n    do i = 1, n\n        word = sentence(i)\n        call translate_word(word, dict)\n        print *, trim(word)\n    end do\n\ncontains\n\n    subroutine translate_word(word, dict)\n        character(len=50), intent(inout) :: word\n        type(dictionary), intent(in) :: dict(:)\n        integer :: j\n        do j = 1, size(dict)\n            if (trim(word) == trim(dict(j)%english)) then\n                word = dict(j)%translation\n                return\n            end if\n        end do\n    end subroutine translate_word\n\nend program translate_sentence\n```"
  },
  {
    "task": "Construct a dictionary to map book titles to their authors, and implement a search function to find all books by a given author.",
    "code": "```fortran\nmodule book_mapping\n    implicit none\n    type :: book_map\n        character(len=:), allocatable :: title\n        character(len=:), allocatable :: author\n    end type book_map\n    type(book_map), allocatable :: books(:)\ncontains\n    subroutine add_book(title, author)\n        character(len=*), intent(in) :: title, author\n        type(book_map) :: new_book\n        integer :: n\n\n        new_book%title = title\n        new_book%author = author\n\n        n = size(books)\n        if (n == 0) then\n            allocate(books(1))\n        else\n            allocate(books(n+1))\n            books(1:n) = books\n        end if\n        books(n+1) = new_book\n    end subroutine add_book\n\n    subroutine find_books_by_author(search_author)\n        character(len=*), intent(in) :: search_author\n        integer :: i\n\n        do i = 1, size(books)\n            if (trim(books(i)%author) == trim(search_author)) then\n                print *, 'Book: ', trim(books(i)%title)\n            end if\n        end do\n    end subroutine find_books_by_author\nend module book_mapping\n\nprogram main\n    use book_mapping\n    implicit none\n\n    call add_book('The Great Gatsby', 'F. Scott Fitzgerald')\n    call add_book('1984', 'George Orwell')\n    call add_book('Animal Farm', 'George Orwell')\n    call add_book('To Kill a Mockingbird', 'Harper Lee')\n\n    print *, 'Books by George Orwell:'\n    call find_books_by_author('George Orwell')\nend program main\n```"
  },
  {
    "task": "Create a map to store product IDs and their stock levels, then implement a function to update stock levels after a sale.",
    "code": "```fortran\nmodule product_inventory\n  implicit none\n  type :: ProductMap\n    integer, allocatable :: ids(:)\n    integer, allocatable :: stock_levels(:)\n  end type ProductMap\n\ncontains\n\n  subroutine initialize_map(pmap, n)\n    type(ProductMap), intent(out) :: pmap\n    integer, intent(in) :: n\n    allocate(pmap%ids(n))\n    allocate(pmap%stock_levels(n))\n    pmap%ids = 0\n    pmap%stock_levels = 0\n  end subroutine initialize_map\n\n  subroutine update_stock(pmap, product_id, sold_quantity)\n    type(ProductMap), intent(inout) :: pmap\n    integer, intent(in) :: product_id\n    integer, intent(in) :: sold_quantity\n    integer :: i\n\n    do i = 1, size(pmap%ids)\n      if (pmap%ids(i) == product_id) then\n        pmap%stock_levels(i) = pmap%stock_levels(i) - sold_quantity\n        return\n      end if\n    end do\n  end subroutine update_stock\n\nend module product_inventory\n\nprogram main\n  use product_inventory\n  implicit none\n\n  type(ProductMap) :: mymap\n  integer :: n, i\n\n  n = 3\n  call initialize_map(mymap, n)\n\n  ! Initialize with some data\n  mymap%ids = [101, 102, 103]\n  mymap%stock_levels = [50, 30, 20]\n\n  ! Update stock after a sale\n  call update_stock(mymap, 102, 5)\n\nend program main\n```"
  },
  {
    "task": "Write a script that uses a dictionary to convert country codes to country names and prints the full name for a given code.",
    "code": "```fortran\nprogram country_code_converter\n    implicit none\n    character(len=2), parameter :: code = \"US\"\n    character(len=20) :: country\n    type :: country_map\n        character(len=2) :: code\n        character(len=20) :: name\n    end type country_map\n    type(country_map), dimension(3), parameter :: countries = &\n        [country_map(\"US\", \"United States\"), &\n         country_map(\"CA\", \"Canada\"), &\n         country_map(\"MX\", \"Mexico\")]\n\n    integer :: i\n    logical :: found\n\n    found = .false.\n    do i = 1, size(countries)\n        if (countries(i)%code == code) then\n            country = countries(i)%name\n            found = .true.\n            exit\n        end if\n    end do\n\n    if (found) then\n        print *, \"Country name for code\", code, \"is\", country\n    else\n        print *, \"Country code not found\"\n    end if\nend program country_code_converter\n```"
  },
  {
    "task": "Design a program that stores student IDs and names in a dictionary, and allows retrieval of names by ID.",
    "code": "```fortran\nprogram student_map\n    implicit none\n    type :: student\n        character(len=:), allocatable :: name\n    end type student\n\n    type(student), allocatable :: students(:)\n    integer :: i, id\n    character(len=50) :: name\n    character(len=1) :: choice\n\n    allocate(students(0))\n\n    do\n        print *, \"Choose an option: (A)dd student, (R)etrieve name, (Q)uit\"\n        read(*, '(A)') choice\n        if (choice == 'Q' .or. choice == 'q') exit\n\n        select case (choice)\n        case ('A', 'a')\n            print *, \"Enter student ID (integer):\"\n            read(*, *) id\n            print *, \"Enter student name:\"\n            read(*, '(A)') name\n\n            call add_student(students, id, name)\n\n        case ('R', 'r')\n            print *, \"Enter student ID to retrieve:\"\n            read(*, *) id\n\n            name = get_name_by_id(students, id)\n            if (len(name) == 0) then\n                print *, \"Student ID not found.\"\n            else\n                print *, \"Student Name:\", trim(name)\n            end if\n\n        end select\n    end do\n\ncontains\n\n    subroutine add_student(students, id, name)\n        type(student), allocatable :: students(:)\n        integer :: id\n        character(len=50) :: name\n        integer :: i\n\n        ! Check if the student ID already exists\n        do i = 1, size(students)\n            if (allocated(students(i)%name) .and. i == id) then\n                students(i)%name = trim(name)\n                return\n            end if\n        end do\n\n        ! Allocate space for new student\n        if (size(students) < id) then\n            call move_alloc(students, students, source=merge(size(students), id, id > size(students)))\n        end if\n\n        if (.not. allocated(students(id)%name)) then\n            allocate(character(len=len(name)) :: students(id)%name)\n        end if\n\n        students(id)%name = trim(name)\n    end subroutine add_student\n\n    function get_name_by_id(students, id) result(name)\n        type(student), allocatable :: students(:)\n        integer :: id\n        character(len=50) :: name\n\n        name = ''\n        if (id > 0 .and. id <= size(students)) then\n            if (allocated(students(id)%name)) then\n                name = students(id)%name\n            end if\n        end if\n    end function get_name_by_id\n\nend program student_map\n```"
  },
  {
    "task": "Implement a dictionary to store configuration settings for a software application, allowing updates and retrieval of settings.",
    "code": "```fortran\nmodule config_module\n  implicit none\n  type :: config_setting\n    character(len=:), allocatable :: key\n    character(len=:), allocatable :: value\n  end type config_setting\n\n  type(config_setting), allocatable :: settings(:)\n\ncontains\n\n  subroutine initialize_settings(n)\n    integer, intent(in) :: n\n    allocate(settings(n))\n  end subroutine initialize_settings\n\n  subroutine set_setting(key, value)\n    character(len=*), intent(in) :: key, value\n    integer :: i\n    do i = 1, size(settings)\n      if (associated(settings(i)%key)) then\n        if (settings(i)%key == key) then\n          settings(i)%value = value\n          return\n        end if\n      else\n        allocate(character(len=len(key)) :: settings(i)%key)\n        allocate(character(len=len(value)) :: settings(i)%value)\n        settings(i)%key = key\n        settings(i)%value = value\n        return\n      end if\n    end do\n  end subroutine set_setting\n\n  function get_setting(key) result(value)\n    character(len=*), intent(in) :: key\n    character(len=:), allocatable :: value\n    integer :: i\n    do i = 1, size(settings)\n      if (associated(settings(i)%key)) then\n        if (settings(i)%key == key) then\n          value = settings(i)%value\n          return\n        end if\n      end if\n    end do\n    allocate(character(len=0) :: value)\n  end function get_setting\n\nend module config_module\n```"
  },
  {
    "task": "Create a map that stores words as keys and their definitions as values, and write a function to display all words starting with a given letter.",
    "code": "```fortran\nprogram word_definitions\n  implicit none\n  character(len=:), allocatable :: definition\n  type :: dictionary_entry\n     character(len=:), allocatable :: word\n     character(len=:), allocatable :: definition\n  end type dictionary_entry\n\n  type(dictionary_entry), allocatable :: dictionary(:)\n  integer :: i, n\n  character(len=1) :: start_letter\n\n  ! Initialize the dictionary with some words and definitions\n  n = 3\n  allocate(dictionary(n))\n  dictionary(1)%word = \"apple\"\n  dictionary(1)%definition = \"A fruit that is typically red, green, or yellow.\"\n  dictionary(2)%word = \"banana\"\n  dictionary(2)%definition = \"A long curved fruit that grows in clusters.\"\n  dictionary(3)%word = \"apricot\"\n  dictionary(3)%definition = \"A small, soft, orange fruit.\"\n\n  ! Function to display words starting with a given letter\n  call display_words_starting_with(dictionary, 'a')\n\ncontains\n\n  subroutine display_words_starting_with(dict, letter)\n    type(dictionary_entry), intent(in) :: dict(:)\n    character(len=1), intent(in) :: letter\n    integer :: i\n\n    print *, \"Words starting with\", letter // \":\"\n    do i = 1, size(dict)\n       if (index(dict(i)%word, letter) == 1) then\n          print *, dict(i)%word // \":\", dict(i)%definition\n       end if\n    end do\n  end subroutine display_words_starting_with\n\nend program word_definitions\n```"
  },
  {
    "task": "Write a program that uses a dictionary to store usernames and passwords, and verifies login attempts.",
    "code": "```fortran\nprogram login_verification\n    implicit none\n    character(len=100), dimension(:), allocatable :: usernames, passwords\n    character(len=100) :: input_username, input_password\n    logical :: login_success\n    integer :: i, n, index\n\n    n = 3  ! Number of users\n    allocate(usernames(n))\n    allocate(passwords(n))\n\n    ! Initialize usernames and passwords\n    usernames(1) = \"user1\"\n    passwords(1) = \"pass1\"\n    usernames(2) = \"user2\"\n    passwords(2) = \"pass2\"\n    usernames(3) = \"user3\"\n    passwords(3) = \"pass3\"\n\n    print *, \"Enter username:\"\n    read *, input_username\n    print *, \"Enter password:\"\n    read *, input_password\n\n    login_success = .false.\n    do i = 1, n\n        if (trim(usernames(i)) == trim(input_username)) then\n            if (trim(passwords(i)) == trim(input_password)) then\n                login_success = .true.\n                exit\n            end if\n        end if\n    end do\n\n    if (login_success) then\n        print *, \"Login successful!\"\n    else\n        print *, \"Login failed!\"\n    end if\n\n    deallocate(usernames)\n    deallocate(passwords)\nend program login_verification\n```"
  },
  {
    "task": "Design a map to track the number of times each item is purchased in a store, then find the most popular item.",
    "code": "```fortran\nprogram most_popular_item\n    implicit none\n    type ItemCount\n        character(len=100) :: itemName\n        integer :: count\n    end type ItemCount\n\n    type(ItemCount), allocatable :: itemCounts(:)\n    integer :: i, j, numItems, maxIndex\n    character(len=100) :: item\n    logical :: found\n\n    ! Example items purchased\n    character(len=100), dimension(10) :: itemsPurchased = (/ &\n        'apple', 'banana', 'apple', 'orange', 'banana', &\n        'apple', 'banana', 'banana', 'pear', 'orange' /)\n    \n    numItems = 0\n    do i = 1, size(itemsPurchased)\n        item = itemsPurchased(i)\n        found = .false.\n\n        ! Check if item is already in the list\n        do j = 1, numItems\n            if (itemCounts(j)%itemName == item) then\n                itemCounts(j)%count = itemCounts(j)%count + 1\n                found = .true.\n                exit\n            end if\n        end do\n\n        ! If item is not found, add it to the list\n        if (.not. found) then\n            numItems = numItems + 1\n            if (.not. allocated(itemCounts)) then\n                allocate(itemCounts(1))\n            else\n                allocate(itemCounts(numItems))\n                itemCounts(1:numItems-1) = itemCounts(1:numItems-1)\n            end if\n            itemCounts(numItems)%itemName = item\n            itemCounts(numItems)%count = 1\n        end if\n    end do\n\n    ! Find the most popular item\n    maxIndex = 1\n    do i = 2, numItems\n        if (itemCounts(i)%count > itemCounts(maxIndex)%count) then\n            maxIndex = i\n        end if\n    end do\n\n    write(*,*) 'Most popular item:', trim(itemCounts(maxIndex)%itemName), &\n                'with count:', itemCounts(maxIndex)%count\n\nend program most_popular_item\n```"
  },
  {
    "task": "Build a dictionary that associates file extensions with their corresponding application types and uses it to determine how to open a given file.",
    "code": "```fortran\nprogram file_opener\n    implicit none\n    character(len=100) :: file_name, extension, app_type\n    integer :: i, found\n    character(len=10), dimension(5) :: extensions = (/ \"txt\", \"jpg\", \"png\", \"pdf\", \"docx\" /)\n    character(len=20), dimension(5) :: app_types = (/ \"Text Editor\", \"Image Viewer\", \"Image Viewer\", \"PDF Reader\", \"Word Processor\" /)\n    character(len=10), dimension(5) :: file_split\n\n    ! Example file name\n    file_name = \"example.pdf\"\n    \n    ! Split the file name to get the extension\n    call split_filename(file_name, file_split)\n    extension = file_split(2)\n\n    ! Initialize found flag\n    found = 0\n\n    ! Search for the application type based on the extension\n    do i = 1, size(extensions)\n        if (trim(extension) == trim(extensions(i))) then\n            app_type = app_types(i)\n            found = 1\n            exit\n        end if\n    end do\n\n    if (found == 1) then\n        print *, \"Open with: \", app_type\n    else\n        print *, \"Unknown file type\"\n    end if\n\ncontains\n\n    subroutine split_filename(file_name, file_split)\n        character(len=100), intent(in) :: file_name\n        character(len=10), dimension(2), intent(out) :: file_split\n        integer :: pos\n\n        pos = index(file_name, '.', back=.true.)\n        if (pos > 0) then\n            file_split(1) = file_name(:pos-1)\n            file_split(2) = file_name(pos+1:)\n        else\n            file_split(1) = file_name\n            file_split(2) = ''\n        end if\n    end subroutine split_filename\n\nend program file_opener\n```"
  },
  {
    "task": "Create a program that uses a map to store menu items and their prices, and allows customers to calculate their total bill.",
    "code": "```fortran\nprogram menu_bill\n    implicit none\n    integer, parameter :: max_items = 100\n    character(len=20) :: item_names(max_items)\n    real :: item_prices(max_items)\n    integer :: num_items, i, qty\n    real :: total_bill\n    character(len=20) :: item\n    logical :: found\n\n    ! Initialize menu with items and prices\n    num_items = 3\n    item_names(1) = 'Burger'\n    item_prices(1) = 5.99\n    item_names(2) = 'Fries'\n    item_prices(2) = 2.99\n    item_names(3) = 'Soda'\n    item_prices(3) = 1.50\n\n    total_bill = 0.0\n\n    print *, 'Enter item name and quantity (type \"done\" to finish):'\n    do\n        read *, item\n        if (trim(adjustl(item)) == 'done') exit\n        read *, qty\n        \n        found = .false.\n        do i = 1, num_items\n            if (trim(adjustl(item)) == item_names(i)) then\n                total_bill = total_bill + item_prices(i) * qty\n                found = .true.\n                exit\n            end if\n        end do\n        \n        if (.not. found) then\n            print *, 'Item not found in menu.'\n        end if\n    end do\n\n    print *, 'Total bill is: $', total_bill\nend program menu_bill\n```"
  },
  {
    "task": "Implement a dictionary to track the inventory of a warehouse, allowing additions, removals, and inventory checks.",
    "code": "```fortran\nmodule warehouse_inventory\n  implicit none\n  type :: inventory_item\n     character(len=:), allocatable :: name\n     integer :: quantity\n  end type inventory_item\n\n  type(inventory_item), allocatable :: inventory(:)\ncontains\n  subroutine add_item(item_name, qty)\n    character(len=*), intent(in) :: item_name\n    integer, intent(in) :: qty\n    integer :: i\n\n    do i = 1, size(inventory)\n      if (inventory(i)%name == item_name) then\n        inventory(i)%quantity = inventory(i)%quantity + qty\n        return\n      end if\n    end do\n\n    inventory = [inventory, inventory_item(item_name, qty)]\n  end subroutine add_item\n\n  subroutine remove_item(item_name, qty)\n    character(len=*), intent(in) :: item_name\n    integer, intent(in) :: qty\n    integer :: i\n\n    do i = 1, size(inventory)\n      if (inventory(i)%name == item_name) then\n        inventory(i)%quantity = max(0, inventory(i)%quantity - qty)\n        return\n      end if\n    end do\n  end subroutine remove_item\n\n  function check_inventory(item_name) result(qty)\n    character(len=*), intent(in) :: item_name\n    integer :: qty\n    integer :: i\n\n    qty = 0\n    do i = 1, size(inventory)\n      if (inventory(i)%name == item_name) then\n        qty = inventory(i)%quantity\n        return\n      end if\n    end do\n  end function check_inventory\nend module warehouse_inventory\n```"
  },
  {
    "task": "Write a function that uses a map to convert Roman numerals to integers.",
    "code": "```fortran\nmodule roman_converter\n  implicit none\ncontains\n  function roman_to_integer(roman) result(num)\n    character(len=*), intent(in) :: roman\n    integer :: num\n    integer :: i, value, next_value\n    character(len=1) :: ch, next_ch\n    type :: roman_map\n      character(len=1) :: numeral\n      integer :: value\n    end type roman_map\n    type(roman_map), dimension(7) :: roman_values\n\n    roman_values = [roman_map('I', 1), roman_map('V', 5), roman_map('X', 10), &\n                    roman_map('L', 50), roman_map('C', 100), &\n                    roman_map('D', 500), roman_map('M', 1000)]\n\n    num = 0\n    do i = 1, len(roman)\n      ch = roman(i:i)\n      if (i < len(roman)) then\n        next_ch = roman(i+1:i+1)\n      else\n        next_ch = ' '\n      endif\n\n      value = 0\n      next_value = 0\n\n      do j = 1, size(roman_values)\n        if (ch == roman_values(j)%numeral) value = roman_values(j)%value\n        if (next_ch == roman_values(j)%numeral) next_value = roman_values(j)%value\n      end do\n\n      if (value < next_value) then\n        num = num - value\n      else\n        num = num + value\n      endif\n    end do\n  end function roman_to_integer\nend module roman_converter\n```"
  },
  {
    "task": "Develop a program that uses a dictionary to track the number of occurrences of each letter in a string.",
    "code": "```fortran\nprogram letter_count\n    implicit none\n    character(len=:), allocatable :: input_string\n    integer :: i, letter_index\n    integer, allocatable :: count(:)\n    character :: letter\n\n    print *, 'Enter a string:'\n    read *, input_string\n\n    allocate(count(26))\n    count = 0\n\n    do i = 1, len(input_string)\n        letter = input_string(i:i)\n        if (letter >= 'a' .and. letter <= 'z') then\n            letter_index = ichar(letter) - ichar('a') + 1\n            count(letter_index) = count(letter_index) + 1\n        else if (letter >= 'A' .and. letter <= 'Z') then\n            letter_index = ichar(letter) - ichar('A') + 1\n            count(letter_index) = count(letter_index) + 1\n        end if\n    end do\n\n    do i = 1, 26\n        if (count(i) > 0) then\n            print '(A, I0)', char(i + ichar('a') - 1), ': ', count(i)\n        end if\n    end do\n\n    deallocate(count)\nend program letter_count\n```"
  },
  {
    "task": "Create a map to store team names and their scores, then determine the team with the highest score.",
    "code": "```fortran\nprogram team_scores\n    implicit none\n    type :: team_map\n        character(len=:), allocatable :: name\n        integer :: score\n    end type team_map\n    type(team_map), allocatable :: teams(:)\n    integer :: n, i, max_score, max_index\n\n    ! Example input data\n    n = 3\n    allocate(teams(n))\n    teams(1)%name = \"Team A\"\n    teams(1)%score = 85\n    teams(2)%name = \"Team B\"\n    teams(2)%score = 92\n    teams(3)%name = \"Team C\"\n    teams(3)%score = 78\n\n    max_score = teams(1)%score\n    max_index = 1\n    do i = 2, n\n        if (teams(i)%score > max_score) then\n            max_score = teams(i)%score\n            max_index = i\n        end if\n    end do\n\n    print *, \"Team with the highest score: \", teams(max_index)%name\nend program team_scores\n```"
  },
  {
    "task": "Write a function that takes a dictionary of item weights and calculates the total weight of all items.",
    "code": "```fortran\nmodule DictionaryModule\n  implicit none\n  private\n  public :: total_weight\n\ncontains\n\n  function total_weight(weights) result(total)\n    implicit none\n    real :: total\n    real, dimension(:), allocatable :: weights\n    integer :: i\n\n    total = 0.0\n    do i = 1, size(weights)\n       total = total + weights(i)\n    end do\n\n  end function total_weight\n\nend module DictionaryModule\n```"
  },
  {
    "task": "Implement a map to store website URLs and their respective visit counts, then find the most visited website.",
    "code": "```fortran\nprogram most_visited_website\n    use, intrinsic :: iso_fortran_env, only: int32\n    implicit none\n    type :: website_data\n        character(len=:), allocatable :: url\n        integer(int32) :: count\n    end type website_data\n\n    type(website_data), allocatable :: website_map(:)\n    integer(int32) :: i, max_index, num_websites\n    logical :: found\n    character(len=256) :: input_url\n\n    num_websites = 0\n\n    do\n        write(*, '(A)', advance='no') 'Enter URL (or \"done\" to finish): '\n        read(*, '(A)') input_url\n        if (trim(input_url) == 'done') exit\n\n        found = .false.\n        do i = 1, num_websites\n            if (trim(website_map(i)%url) == trim(input_url)) then\n                website_map(i)%count = website_map(i)%count + 1\n                found = .true.\n                exit\n            end if\n        end do\n\n        if (.not. found) then\n            num_websites = num_websites + 1\n            if (.not. allocated(website_map)) then\n                allocate(website_map(num_websites))\n            else\n                call move_alloc(from=website_map, to=website_map, mold=website_map)\n                allocate(website_map(num_websites))\n            end if\n            website_map(num_websites)%url = trim(input_url)\n            website_map(num_websites)%count = 1\n        end if\n    end do\n\n    max_index = 1\n    do i = 2, num_websites\n        if (website_map(i)%count > website_map(max_index)%count) then\n            max_index = i\n        end if\n    end do\n\n    write(*, '(A, I0)') 'Most visited website: ', trim(website_map(max_index)%url), &\n        ' with ', website_map(max_index)%count, ' visits.'\nend program most_visited_website\n```"
  },
  {
    "task": "Create a script that uses a dictionary to map error codes to error messages, and prints the message for a given code.",
    "code": "```fortran\nprogram error_code_mapping\n    implicit none\n    character(len=20), parameter :: error_codes(3) = ['E001', 'E002', 'E003']\n    character(len=50), parameter :: error_messages(3) = ['File not found', 'Access denied', 'Disk full']\n    character(len=20) :: input_code\n    integer :: i\n\n    ! Simulate input code\n    input_code = 'E002'\n\n    do i = 1, size(error_codes)\n        if (trim(input_code) == error_codes(i)) then\n            print *, 'Error Message:', trim(error_messages(i))\n            exit\n        end if\n    end do\nend program error_code_mapping\n```"
  },
  {
    "task": "Design a dictionary to store contact information with names as keys and phone numbers as values, allowing updates and lookups.",
    "code": "```fortran\nprogram contact_dictionary\n    implicit none\n    integer, parameter :: max_contacts = 100\n    character(len=50), dimension(max_contacts) :: contact_names\n    character(len=15), dimension(max_contacts) :: contact_numbers\n    integer :: num_contacts\n    integer :: i\n    character(len=50) :: name\n    character(len=15) :: number\n    logical :: found\n\n    num_contacts = 0\n    \n    call add_contact(\"Alice\", \"123-456-7890\")\n    call add_contact(\"Bob\", \"987-654-3210\")\n\n    call lookup_contact(\"Alice\", number, found)\n    if (found) print *, \"Alice's number is\", number\n\n    call update_contact(\"Alice\", \"111-222-3333\")\n    call lookup_contact(\"Alice\", number, found)\n    if (found) print *, \"Alice's updated number is\", number\n\ncontains\n\n    subroutine add_contact(name, number)\n        character(len=*), intent(in) :: name\n        character(len=*), intent(in) :: number\n        integer :: index\n\n        index = find_contact(name)\n        if (index == 0 .and. num_contacts < max_contacts) then\n            num_contacts = num_contacts + 1\n            contact_names(num_contacts) = name\n            contact_numbers(num_contacts) = number\n        end if\n    end subroutine add_contact\n\n    subroutine update_contact(name, number)\n        character(len=*), intent(in) :: name\n        character(len=*), intent(in) :: number\n        integer :: index\n\n        index = find_contact(name)\n        if (index > 0) then\n            contact_numbers(index) = number\n        end if\n    end subroutine update_contact\n\n    subroutine lookup_contact(name, number, found)\n        character(len=*), intent(in) :: name\n        character(len=*), intent(out) :: number\n        logical, intent(out) :: found\n        integer :: index\n\n        index = find_contact(name)\n        if (index > 0) then\n            number = contact_numbers(index)\n            found = .true.\n        else\n            number = \"\"\n            found = .false.\n        end if\n    end subroutine lookup_contact\n\n    function find_contact(name) result(index)\n        character(len=*), intent(in) :: name\n        integer :: index\n        integer :: i\n\n        index = 0\n        do i = 1, num_contacts\n            if (trim(contact_names(i)) == trim(name)) then\n                index = i\n                exit\n            end if\n        end do\n    end function find_contact\n\nend program contact_dictionary\n```"
  },
  {
    "task": "Write a program that uses a map to assign tasks to employees based on their skill levels.",
    "code": "```fortran\nprogram TaskAssignment\n  implicit none\n  type :: EmployeeMap\n     character(len=:), allocatable :: name\n     character(len=:), allocatable :: task\n  end type EmployeeMap\n\n  type(EmployeeMap), allocatable :: employees(:)\n  integer :: i\n\n  allocate(employees(3))\n  \n  employees(1)%name = 'Alice'\n  employees(1)%task = 'Advanced Analysis'\n\n  employees(2)%name = 'Bob'\n  employees(2)%task = 'Data Entry'\n\n  employees(3)%name = 'Charlie'\n  employees(3)%task = 'Report Writing'\n\n  do i = 1, size(employees)\n     print *, 'Employee:', employees(i)%name\n     print *, 'Assigned Task:', employees(i)%task\n  end do\n\nend program TaskAssignment\n```"
  },
  {
    "task": "Create a dictionary that maps airport codes to their respective city names, and allows retrieval of city names by code.",
    "code": "```fortran\nprogram airport_dictionary\n    implicit none\n    type :: AirportMap\n        character(len=:), allocatable :: code\n        character(len=:), allocatable :: city\n    end type AirportMap\n\n    type(AirportMap), allocatable :: airports(:)\n    character(len=3) :: code_input\n    logical :: found\n    integer :: i\n\n    ! Initialize the dictionary with some airport codes and city names\n    airports = [AirportMap('JFK', 'New York'),\n                AirportMap('LAX', 'Los Angeles'),\n                AirportMap('ORD', 'Chicago'),\n                AirportMap('DFW', 'Dallas/Fort Worth'),\n                AirportMap('DEN', 'Denver')]\n\n    ! Example: Retrieve city name by airport code\n    print *, 'Enter airport code (e.g., JFK):'\n    read *, code_input\n\n    found = .false.\n    do i = 1, size(airports)\n        if (airports(i)%code == trim(adjustl(code_input))) then\n            print *, 'City:', airports(i)%city\n            found = .true.\n            exit\n        end if\n    end do\n\n    if (.not. found) then\n        print *, 'Airport code not found.'\n    end if\nend program airport_dictionary\n```"
  },
  {
    "task": "Build a map to store movie titles and their release years, then find all movies released in a given decade.",
    "code": "```fortran\nprogram movie_map\n  implicit none\n  integer, parameter :: map_size = 100\n  character(len=50) :: movie_titles(map_size)\n  integer :: release_years(map_size)\n  integer :: num_movies, i, decade, start_decade, end_decade\n\n  ! Sample data\n  num_movies = 5\n  movie_titles(1) = 'Star Wars'\n  release_years(1) = 1977\n  movie_titles(2) = 'The Matrix'\n  release_years(2) = 1999\n  movie_titles(3) = 'Inception'\n  release_years(3) = 2010\n  movie_titles(4) = 'Pulp Fiction'\n  release_years(4) = 1994\n  movie_titles(5) = 'The Godfather'\n  release_years(5) = 1972\n\n  ! Input the desired decade\n  print *, 'Enter the decade to find movies (e.g., 1990 for 1990s):'\n  read *, decade\n\n  start_decade = (decade / 10) * 10\n  end_decade = start_decade + 9\n\n  ! Find movies released in the given decade\n  print *, 'Movies released in the', decade, 's:'\n  do i = 1, num_movies\n    if (release_years(i) >= start_decade .and. release_years(i) <= end_decade) then\n      print *, movie_titles(i)\n    end if\n  end do\n\nend program movie_map\n```"
  },
  {
    "task": "Write a function that uses a dictionary to group students by their grades.",
    "code": "```fortran\nmodule student_grades\n  implicit none\ncontains\n\n  subroutine group_students_by_grades(students, grades, grouped_students)\n    character(len=*), dimension(:), intent(in) :: students\n    integer, dimension(:), intent(in) :: grades\n    type(grade_map), intent(out) :: grouped_students\n    integer :: i\n\n    call init_grade_map(grouped_students)\n\n    do i = 1, size(students)\n      call add_student_to_grade(&\n          grouped_students, grades(i), students(i))\n    end do\n  end subroutine group_students_by_grades\n\n  subroutine init_grade_map(grade_map)\n    type(grade_map), intent(out) :: grade_map\n    integer :: i\n\n    grade_map%count = 0\n    do i = 1, max_grades\n      grade_map%grades(i)%grade = i\n      grade_map%grades(i)%students => null()\n    end do\n  end subroutine init_grade_map\n\n  subroutine add_student_to_grade(grade_map, grade, student)\n    type(grade_map), intent(inout) :: grade_map\n    integer, intent(in) :: grade\n    character(len=*), intent(in) :: student\n\n    if (associated(grade_map%grades(grade)%students)) then\n      call extend_student_list(&\n          grade_map%grades(grade)%students, student)\n    else\n      allocate(grade_map%grades(grade)%students(1))\n      grade_map%grades(grade)%students(1) = student\n    end if\n  end subroutine add_student_to_grade\n\n  subroutine extend_student_list(student_list, new_student)\n    character(len=*), dimension(:), allocatable, intent(inout) :: student_list\n    character(len=*), intent(in) :: new_student\n    integer :: n\n\n    n = size(student_list)\n    call move_alloc(student_list, student_list)\n    allocate(student_list(n + 1))\n    student_list(1:n) = student_list(1:n)\n    student_list(n + 1) = new_student\n  end subroutine extend_student_list\n\n  type :: grade_map\n    type(grade_students), dimension(max_grades) :: grades\n    integer :: count\n  end type grade_map\n\n  type :: grade_students\n    integer :: grade\n    character(len=:), allocatable, dimension(:) :: students\n  end type grade_students\n\n  integer, parameter :: max_grades = 100\n\nend module student_grades\n```"
  },
  {
    "task": "Create a dictionary to store the number of visitors to different sections of a website, and determine the most visited section.",
    "code": "```fortran\nprogram website_visitors\n    implicit none\n    integer :: i, max_visitors, n\n    character(len=50), dimension(:), allocatable :: sections\n    integer, dimension(:), allocatable :: visitors\n    character(len=50) :: most_visited_section\n\n    ! Initialize data\n    n = 3\n    allocate(sections(n))\n    allocate(visitors(n))\n\n    sections = [\"home\", \"about\", \"contact\"]\n    visitors = [350, 120, 450]\n\n    ! Determine the most visited section\n    max_visitors = visitors(1)\n    most_visited_section = sections(1)\n\n    do i = 2, n\n        if (visitors(i) > max_visitors) then\n            max_visitors = visitors(i)\n            most_visited_section = sections(i)\n        end if\n    end do\n\n    print *, \"Most visited section:\", most_visited_section\n\nend program website_visitors\n```"
  },
  {
    "task": "Design a program that uses a map to assign project deadlines to team members, allowing for deadline extensions.",
    "code": "```fortran\nprogram project_deadlines\n    implicit none\n    integer, parameter :: max_members = 10\n    character(len=20), dimension(max_members) :: team_members\n    character(len=10), dimension(max_members) :: deadlines\n    integer :: num_members, i\n    character(len=20) :: member_name\n    character(len=10) :: new_deadline\n\n    num_members = 0\n\n    ! Adding some team members and deadlines\n    call add_deadline('Alice', '2023-11-01')\n    call add_deadline('Bob', '2023-11-15')\n    call add_deadline('Charlie', '2023-12-01')\n\n    ! Extend deadline for a member\n    call extend_deadline('Bob', '2023-12-01')\n\ncontains\n\n    subroutine add_deadline(member, deadline)\n        character(len=*), intent(in) :: member\n        character(len=*), intent(in) :: deadline\n        integer :: idx\n\n        idx = find_member(member)\n        if (idx == 0 .and. num_members < max_members) then\n            num_members = num_members + 1\n            team_members(num_members) = member\n            deadlines(num_members) = deadline\n        else if (idx /= 0) then\n            deadlines(idx) = deadline\n        endif\n    end subroutine add_deadline\n\n    subroutine extend_deadline(member, new_deadline)\n        character(len=*), intent(in) :: member\n        character(len=*), intent(in) :: new_deadline\n        integer :: idx\n\n        idx = find_member(member)\n        if (idx /= 0) then\n            deadlines(idx) = new_deadline\n        endif\n    end subroutine extend_deadline\n\n    integer function find_member(member)\n        character(len=*), intent(in) :: member\n        integer :: i\n\n        find_member = 0\n        do i = 1, num_members\n            if (trim(team_members(i)) == trim(member)) then\n                find_member = i\n                return\n            endif\n        end do\n    end function find_member\n\nend program project_deadlines\n```"
  },
  {
    "task": "Implement a dictionary that keeps track of borrowed books in a library, allowing users to check available books.",
    "code": "```fortran\nprogram library_system\n  implicit none\n  integer, parameter :: max_books = 100\n  type :: Book\n     character(len=100) :: title\n     logical :: is_borrowed\n  end type Book\n\n  type(Book), dimension(max_books) :: books\n  integer :: i, num_books\n  character(len=100) :: book_title\n\n  num_books = 0\n\n  call add_book(\"The Great Gatsby\")\n  call add_book(\"1984\")\n  call add_book(\"To Kill a Mockingbird\")\n\n  print *, \"Enter book title to check availability:\"\n  read(*, '(A)') book_title\n  call check_availability(book_title)\n\ncontains\n\n  subroutine add_book(title)\n    character(len=100), intent(in) :: title\n    if (num_books < max_books) then\n      num_books = num_books + 1\n      books(num_books)%title = title\n      books(num_books)%is_borrowed = .false.\n    end if\n  end subroutine add_book\n\n  subroutine check_availability(title)\n    character(len=100), intent(in) :: title\n    logical :: found\n    found = .false.\n    do i = 1, num_books\n      if (trim(books(i)%title) == trim(title)) then\n        found = .true.\n        if (.not. books(i)%is_borrowed) then\n          print *, \"The book is available.\"\n        else\n          print *, \"The book is borrowed.\"\n        end if\n      end if\n    end do\n    if (.not. found) then\n      print *, \"The book is not in the library.\"\n    end if\n  end subroutine check_availability\n\nend program library_system\n```"
  },
  {
    "task": "Create a map to store the names of planets and their distances from the sun, then find the closest planet to Earth.",
    "code": "```fortran\nprogram closest_planet\n    implicit none\n    integer, parameter :: dp = kind(1.0d0)\n    character(len=20), dimension(:), allocatable :: planet_names\n    real(dp), dimension(:), allocatable :: distances\n    integer :: i, closest_index\n    real(dp) :: min_distance\n\n    allocate(planet_names(8))\n    allocate(distances(8))\n\n    planet_names = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    distances = [57.9_dp, 108.2_dp, 149.6_dp, 227.9_dp, 778.3_dp, 1427.0_dp, 2871.0_dp, 4497.1_dp]\n\n    min_distance = distances(1)\n    closest_index = 1\n    do i = 2, size(distances)\n        if (distances(i) < min_distance .and. planet_names(i) /= 'Earth') then\n            min_distance = distances(i)\n            closest_index = i\n        end if\n    end do\n\n    print *, 'The closest planet to Earth is:', planet_names(closest_index)\n\nend program closest_planet\n```"
  },
  {
    "task": "Write a script that uses a dictionary to translate Morse code into plain text.",
    "code": "```fortran\nprogram MorseCodeTranslator\n  implicit none\n  character(len=*), parameter :: morse(26) = [ &\n    \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", &\n    \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", &\n    \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\" ]\n  character(len=*), parameter :: alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  character(len=5) :: code\n  character(len=1) :: letter\n  integer :: i\n\n  ! Morse code input\n  code = \".-\"\n\n  ! Find the corresponding letter\n  letter = \"\"\n  do i = 1, size(alphabet)\n    if (trim(morse(i)) == trim(code)) then\n      letter = alphabet(i:i)\n      exit\n    end if\n  end do\n\n  ! Output the letter\n  if (letter /= \"\") then\n    print *, \"The letter is: \", letter\n  else\n    print *, \"Morse code not recognized!\"\n  end if\nend program MorseCodeTranslator\n```"
  },
  {
    "task": "Develop a program that uses a map to store vehicle registration numbers and their corresponding owner's name.",
    "code": "```fortran\nprogram vehicle_registration\n    implicit none\n    type :: vehicle\n        character(len=20) :: registration\n        character(len=50) :: owner\n    end type vehicle\n\n    type(vehicle), allocatable :: vehicles(:)\n    integer :: i, n\n    character(len=20) :: reg_input\n    character(len=50) :: owner_input\n\n    print *, \"Enter number of vehicles:\"\n    read *, n\n    allocate(vehicles(n))\n\n    do i = 1, n\n        print *, \"Enter registration number for vehicle \", i, \":\"\n        read *, reg_input\n        print *, \"Enter owner's name for vehicle \", i, \":\"\n        read *, owner_input\n        vehicles(i)%registration = reg_input\n        vehicles(i)%owner = owner_input\n    end do\n\n    print *, \"Vehicle Registration Details:\"\n    do i = 1, n\n        print *, \"Registration: \", vehicles(i)%registration, \"Owner: \", vehicles(i)%owner\n    end do\n\n    deallocate(vehicles)\nend program vehicle_registration\n```"
  },
  {
    "task": "Create a dictionary that maps sports teams to their win-loss records, and find the team with the best record.",
    "code": "```fortran\nprogram best_team\n    implicit none\n    type :: TeamRecord\n        character(len=50) :: name\n        integer :: wins\n        integer :: losses\n    end type TeamRecord\n\n    type(TeamRecord), allocatable :: teams(:)\n    integer :: i, n, best_index\n    real :: best_ratio, current_ratio\n\n    ! Define number of teams\n    n = 3\n    allocate(teams(n))\n\n    ! Initialize teams and their records\n    teams(1)%name = 'Team A'\n    teams(1)%wins = 10\n    teams(1)%losses = 2\n\n    teams(2)%name = 'Team B'\n    teams(2)%wins = 8\n    teams(2)%losses = 4\n\n    teams(3)%name = 'Team C'\n    teams(3)%wins = 12\n    teams(3)%losses = 3\n\n    ! Find the team with the best win-loss record\n    best_ratio = -1.0\n    best_index = -1\n\n    do i = 1, n\n        current_ratio = real(teams(i)%wins) / (teams(i)%wins + teams(i)%losses)\n        if (current_ratio > best_ratio) then\n            best_ratio = current_ratio\n            best_index = i\n        end if\n    end do\n\n    ! Output the team with the best record\n    if (best_index /= -1) then\n        print *, 'Team with the best record:', teams(best_index)%name\n    else\n        print *, 'No teams available.'\n    end if\n\n    deallocate(teams)\nend program best_team\n```"
  },
  {
    "task": "Write a function that uses a map to convert currency codes to full currency names.",
    "code": "```fortran\nmodule currency_module\n    implicit none\n    type :: currency_map\n        character(len=:), allocatable :: code(:)\n        character(len=:), allocatable :: name(:)\n    end type currency_map\n\ncontains\n\n    function create_currency_map() result(map)\n        type(currency_map) :: map\n        allocate(character(len=3) :: map%code(3))\n        allocate(character(len=20) :: map%name(3))\n        map%code = ['USD', 'EUR', 'JPY']\n        map%name = ['United States Dollar', 'Euro', 'Japanese Yen']\n    end function create_currency_map\n\n    function get_currency_name(code) result(currency_name)\n        character(len=3), intent(in) :: code\n        character(len=20) :: currency_name\n        type(currency_map) :: map\n        integer :: i\n\n        map = create_currency_map()\n        currency_name = 'Unknown'\n        do i = 1, size(map%code)\n            if (map%code(i) == code) then\n                currency_name = map%name(i)\n                exit\n            end if\n        end do\n    end function get_currency_name\n\nend module currency_module\n```"
  },
  {
    "task": "Build a dictionary to store student names and their attendance counts, and determine the student with the highest attendance.",
    "code": "```fortran\nprogram attendance_tracker\n    implicit none\n    character(len=100), dimension(:), allocatable :: student_names\n    integer, dimension(:), allocatable :: attendance_counts\n    integer :: num_students, i, max_attendance, max_index\n\n    ! Example initialization\n    num_students = 4\n    allocate(student_names(num_students))\n    allocate(attendance_counts(num_students))\n\n    student_names = [ \"Alice\", \"Bob\", \"Charlie\", \"David\" ]\n    attendance_counts = [ 5, 3, 7, 6 ]\n\n    ! Find the student with the highest attendance\n    max_attendance = attendance_counts(1)\n    max_index = 1\n    do i = 2, num_students\n        if (attendance_counts(i) > max_attendance) then\n            max_attendance = attendance_counts(i)\n            max_index = i\n        end if\n    end do\n\n    print *, \"Student with highest attendance: \", student_names(max_index), \"with\", max_attendance, \"attendances\"\nend program attendance_tracker\n```"
  },
  {
    "task": "Implement a map to store the names of countries and their capitals, allowing lookups by country name.",
    "code": "```fortran\nprogram country_capitals\n    implicit none\n    type :: map_entry\n        character(len=100) :: country\n        character(len=100) :: capital\n    end type map_entry\n\n    type(map_entry), allocatable :: map(:)\n    integer :: i, n\n    character(len=100) :: input_country, result\n\n    n = 5\n    allocate(map(n))\n\n    map(1) = map_entry(\"USA\", \"Washington D.C.\")\n    map(2) = map_entry(\"France\", \"Paris\")\n    map(3) = map_entry(\"Japan\", \"Tokyo\")\n    map(4) = map_entry(\"Australia\", \"Canberra\")\n    map(5) = map_entry(\"India\", \"New Delhi\")\n\n    print *, \"Enter country name:\"\n    read *, input_country\n\n    result = \"Not found\"\n    do i = 1, n\n        if (trim(adjustl(map(i)%country)) == trim(adjustl(input_country))) then\n            result = trim(adjustl(map(i)%capital))\n            exit\n        end if\n    end do\n\n    print *, \"Capital:\", result\n\nend program country_capitals\n```"
  },
  {
    "task": "Create a program that uses a dictionary to keep track of recipe ingredients and their quantities.",
    "code": "```fortran\nprogram RecipeManager\n    implicit none\n    type :: Ingredient\n        character(len=:), allocatable :: name\n        real :: quantity\n    end type Ingredient\n\n    type(Ingredient), allocatable :: ingredients(:)\n    integer :: i, numIngredients\n    character(len=100) :: inputName\n    real :: inputQuantity\n\n    print *, \"Enter number of ingredients:\"\n    read *, numIngredients\n    allocate(ingredients(numIngredients))\n\n    do i = 1, numIngredients\n        print *, \"Enter ingredient name:\"\n        read *, inputName\n        print *, \"Enter quantity for \", trim(inputName), \":\"\n        read *, inputQuantity\n\n        ingredients(i)%name = inputName\n        ingredients(i)%quantity = inputQuantity\n    end do\n\n    print *, \"Recipe Ingredients:\"\n    do i = 1, numIngredients\n        print *, \"Ingredient: \", trim(ingredients(i)%name), \" Quantity: \", ingredients(i)%quantity\n    end do\nend program RecipeManager\n```"
  },
  {
    "task": "Design a system that uses a map to associate social media usernames with user profiles.",
    "code": "```fortran\nmodule UserProfileModule\n  implicit none\n  type :: UserProfile\n    character(len=50) :: name\n    integer :: age\n    character(len=100) :: email\n  end type UserProfile\nend module UserProfileModule\n\nprogram SocialMediaMap\n  use UserProfileModule\n  implicit none\n  type(UserProfile) :: profile\n  character(len=50), dimension(:), allocatable :: usernames\n  type(UserProfile), dimension(:), allocatable :: profiles\n  integer :: i, numUsers\n\n  numUsers = 3\n  allocate(usernames(numUsers))\n  allocate(profiles(numUsers))\n\n  ! Example user profiles\n  usernames(1) = 'user1'\n  profiles(1) = UserProfile('Alice', 30, 'alice@example.com')\n\n  usernames(2) = 'user2'\n  profiles(2) = UserProfile('Bob', 25, 'bob@example.com')\n\n  usernames(3) = 'user3'\n  profiles(3) = UserProfile('Charlie', 28, 'charlie@example.com')\n\n  ! Example of accessing a user profile by username\n  do i = 1, numUsers\n    if (usernames(i) == 'user2') then\n      profile = profiles(i)\n      exit\n    end if\n  end do\n\n  print *, 'Username: user2'\n  print *, 'Name:', profile%name\n  print *, 'Age:', profile%age\n  print *, 'Email:', profile%email\n\nend program SocialMediaMap\n```"
  },
  {
    "task": "Write a function that takes a dictionary of product categories and lists all products in a given category.",
    "code": "```fortran\nmodule product_module\n  implicit none\n  type :: ProductMap\n    character(len=:), allocatable :: category(:)\n    character(len=:), allocatable :: products(:,:)\n  end type ProductMap\n\ncontains\n\n  subroutine list_products_in_category(product_map, category_name)\n    type(ProductMap), intent(in) :: product_map\n    character(len=*), intent(in) :: category_name\n    integer :: i, index\n    logical :: found\n\n    found = .false.\n    index = -1\n    do i = 1, size(product_map%category)\n      if (trim(product_map%category(i)) == trim(category_name)) then\n        found = .true.\n        index = i\n        exit\n      end if\n    end do\n\n    if (found) then\n      print *, \"Products in category \", trim(category_name), \":\"\n      do i = 1, size(product_map%products, 2)\n        if (trim(product_map%products(index, i)) /= \"\") then\n          print *, trim(product_map%products(index, i))\n        end if\n      end do\n    else\n      print *, \"Category not found.\"\n    end if\n  end subroutine list_products_in_category\n\nend module product_module\n```"
  },
  {
    "task": "Create a dictionary to store shopping list items and their quantities, and implement a function to update quantities.",
    "code": "```fortran\nmodule shopping_list\n    implicit none\n    type :: Item\n        character(len=50) :: name\n        integer :: quantity\n    end type Item\n    type(Item), allocatable :: items(:)\ncontains\n    subroutine update_quantity(item_name, new_quantity)\n        character(len=*), intent(in) :: item_name\n        integer, intent(in) :: new_quantity\n        integer :: i, found\n        found = 0\n        do i = 1, size(items)\n            if (trim(items(i)%name) == trim(item_name)) then\n                items(i)%quantity = new_quantity\n                found = 1\n                exit\n            end if\n        end do\n        if (.not. found) then\n            call add_item(item_name, new_quantity)\n        end if\n    end subroutine update_quantity\n\n    subroutine add_item(item_name, quantity)\n        character(len=*), intent(in) :: item_name\n        integer, intent(in) :: quantity\n        integer :: n\n\n        n = size(items)\n        if (.not. allocated(items)) then\n            allocate(items(1))\n        else\n            call move_alloc(items, items, source=items)\n            allocate(items(n+1))\n            items(:n) = items\n        end if\n        items(n+1)%name = item_name\n        items(n+1)%quantity = quantity\n    end subroutine add_item\nend module shopping_list\n```"
  },
  {
    "task": "Build a program that uses a map to store historical events and their dates, and finds events that occurred in a given year.",
    "code": "```fortran\nprogram historical_events\n    implicit none\n    character(len=256) :: events(5)\n    integer :: dates(5)\n    integer :: year, i\n\n    ! Initialize the map with historical events and dates\n    events(1) = \"Moon Landing\"\n    dates(1) = 1969\n    events(2) = \"Fall of Berlin Wall\"\n    dates(2) = 1989\n    events(3) = \"Y2K Bug\"\n    dates(3) = 2000\n    events(4) = \"9/11 Attacks\"\n    dates(4) = 2001\n    events(5) = \"COVID-19 Pandemic\"\n    dates(5) = 2020\n\n    ! Ask the user for a year\n    print *, \"Enter a year to find historical events:\"\n    read *, year\n\n    ! Search for events that occurred in the given year\n    print *, \"Events that occurred in the year\", year, \":\"\n    do i = 1, size(dates)\n        if (dates(i) == year) then\n            print *, events(i)\n        end if\n    end do\nend program historical_events\n```"
  },
  {
    "task": "Implement a dictionary to manage user roles and permissions within an application.",
    "code": "```fortran\nmodule UserRoles\n\n  implicit none\n  private\n  public :: setRole, getPermissions, initializeRoles\n\n  type :: Role\n    character(len=20) :: name\n    character(len=50), allocatable :: permissions(:)\n  end type Role\n\n  type(Role), allocatable :: roleDict(:)\n  integer :: roleCount = 0\n\ncontains\n\n  subroutine initializeRoles()\n    allocate(roleDict(0))\n  end subroutine initializeRoles\n\n  subroutine setRole(roleName, permissionsList)\n    character(len=*), intent(in) :: roleName\n    character(len=*), allocatable, intent(in) :: permissionsList(:)\n    integer :: i\n\n    do i = 1, roleCount\n      if (roleDict(i)%name == roleName) then\n        roleDict(i)%permissions = permissionsList\n        return\n      end if\n    end do\n\n    roleCount = roleCount + 1\n    call extendRoleDict(roleCount)\n    roleDict(roleCount)%name = roleName\n    roleDict(roleCount)%permissions = permissionsList\n  end subroutine setRole\n\n  subroutine getPermissions(roleName, permissionsList)\n    character(len=*), intent(in) :: roleName\n    character(len=50), allocatable, intent(out) :: permissionsList(:)\n    integer :: i\n\n    permissionsList = [character(len=50) :: \"\"]\n\n    do i = 1, roleCount\n      if (roleDict(i)%name == roleName) then\n        permissionsList = roleDict(i)%permissions\n        return\n      end if\n    end do\n\n  end subroutine getPermissions\n\n  subroutine extendRoleDict(newSize)\n    integer, intent(in) :: newSize\n    type(Role), allocatable :: temp(:)\n\n    allocate(temp(newSize))\n    if (allocated(roleDict)) then\n      temp(1:roleCount) = roleDict\n    end if\n    deallocate(roleDict)\n    roleDict = temp\n  end subroutine extendRoleDict\n\nend module UserRoles\n```"
  },
  {
    "task": "Write a script that uses a map to convert numeric grades to letter grades.",
    "code": "```fortran\nprogram grade_converter\n    implicit none\n    integer, parameter :: n_grades = 5\n    integer :: i\n    real :: numeric_grades(n_grades) = (/ 95.0, 82.0, 75.0, 67.0, 59.0 /)\n    character(len=2) :: letter_grades(n_grades)\n    type map\n        character(len=2) :: letter\n        real :: min_grade\n    end type map\n    type(map), dimension(5) :: grade_map\n\n    ! Initialize the map\n    grade_map(1) = map('A', 90.0)\n    grade_map(2) = map('B', 80.0)\n    grade_map(3) = map('C', 70.0)\n    grade_map(4) = map('D', 60.0)\n    grade_map(5) = map('F', 0.0)\n\n    ! Convert numeric grades to letter grades\n    do i = 1, n_grades\n        letter_grades(i) = 'F' ! Default to 'F'\n        do j = 1, size(grade_map)\n            if (numeric_grades(i) >= grade_map(j)%min_grade) then\n                letter_grades(i) = grade_map(j)%letter\n                exit\n            end if\n        end do\n    end do\n\n    ! Output the results\n    do i = 1, n_grades\n        print *, 'Numeric Grade:', numeric_grades(i), ' -> Letter Grade:', letter_grades(i)\n    end do\nend program grade_converter\n```"
  },
  {
    "task": "Create a dictionary that maps holiday names to their corresponding dates, and allows lookup by holiday name.",
    "code": "```fortran\nprogram holiday_map\n    implicit none\n    character(len=:), allocatable :: holiday_name\n    character(len=10) :: holiday_date\n    integer :: i, n\n    type :: holiday\n        character(len=20) :: name\n        character(len=10) :: date\n    end type holiday\n    type(holiday), allocatable :: holidays(:)\n    \n    n = 3\n    allocate(holidays(n))\n    \n    holidays(1)%name = 'New Year'\n    holidays(1)%date = '2023-01-01'\n    holidays(2)%name = 'Independence Day'\n    holidays(2)%date = '2023-07-04'\n    holidays(3)%name = 'Christmas'\n    holidays(3)%date = '2023-12-25'\n    \n    write(*,*) 'Enter holiday name:'\n    read(*,*) holiday_name\n    call lookup_holiday(holiday_name, holiday_date, holidays)\n    if (holiday_date /= 'NOT FOUND') then\n        write(*,*) 'Date:', holiday_date\n    else\n        write(*,*) 'Holiday not found.'\n    end if\nend program holiday_map\n\nsubroutine lookup_holiday(name, date, holidays)\n    implicit none\n    character(len=*), intent(in) :: name\n    character(len=10), intent(out) :: date\n    type(holiday), intent(in) :: holidays(:)\n    integer :: i\n\n    date = 'NOT FOUND'\n    do i = 1, size(holidays)\n        if (trim(holidays(i)%name) == trim(name)) then\n            date = holidays(i)%date\n            return\n        end if\n    end do\nend subroutine lookup_holiday\n```"
  },
  {
    "task": "Design a system that uses a map to track the status of online orders, allowing updates to order status.",
    "code": "```fortran\nprogram OrderStatusTracker\n    implicit none\n    type :: Order\n        character(len=20) :: status\n    end type Order\n\n    type(Order), allocatable :: orders(:)\n    integer :: i, order_id\n\n    ! Initialize orders\n    allocate(orders(3))\n    orders(1)%status = \"Pending\"\n    orders(2)%status = \"Shipped\"\n    orders(3)%status = \"Delivered\"\n\n    ! Update order status\n    order_id = 2\n    call updateOrderStatus(order_id, \"Delivered\")\n\n    ! Print order statuses\n    do i = 1, size(orders)\n        print *, \"Order\", i, \"Status:\", orders(i)%status\n    end do\n\ncontains\n\n    subroutine updateOrderStatus(order_id, new_status)\n        integer, intent(in) :: order_id\n        character(len=*), intent(in) :: new_status\n        if (order_id > 0 .and. order_id <= size(orders)) then\n            orders(order_id)%status = new_status\n        end if\n    end subroutine updateOrderStatus\n\nend program OrderStatusTracker\n```"
  },
  {
    "task": "Develop a program that uses a dictionary to associate food items with their nutritional information.",
    "code": "```fortran\nprogram food_nutrition_map\n    implicit none\n    type :: nutrition\n        real :: calories\n        real :: protein\n        real :: fat\n        real :: carbs\n    end type nutrition\n\n    type(nutrition), allocatable :: food_map(:)\n    character(len=:), allocatable :: food_names(:)\n    integer :: i\n\n    allocate(food_map(3))\n    allocate(character(len=20) :: food_names(3))\n\n    food_names(1) = 'Apple'\n    food_map(1) = nutrition(52.0, 0.3, 0.2, 14.0)\n\n    food_names(2) = 'Banana'\n    food_map(2) = nutrition(89.0, 1.1, 0.3, 23.0)\n\n    food_names(3) = 'Carrot'\n    food_map(3) = nutrition(41.0, 0.9, 0.2, 10.0)\n\n    do i = 1, size(food_map)\n        print *, 'Food: ', trim(food_names(i))\n        print *, 'Calories: ', food_map(i)%calories\n        print *, 'Protein: ', food_map(i)%protein\n        print *, 'Fat: ', food_map(i)%fat\n        print *, 'Carbs: ', food_map(i)%carbs\n        print *, '--------------------------'\n    end do\nend program food_nutrition_map\n```"
  },
  {
    "task": "Create a map to store book genres and lists of book titles, allowing retrieval of all books in a given genre.",
    "code": "```fortran\nmodule book_map\n  implicit none\n  type :: book_genre_map\n    character(len=:), allocatable :: genre\n    character(len=:), allocatable :: titles(:)\n  end type book_genre_map\n\n  type(book_genre_map), allocatable :: library(:)\ncontains\n\n  subroutine add_genre(genre)\n    character(len=*), intent(in) :: genre\n    integer :: i\n\n    do i = 1, size(library)\n      if (library(i)%genre == genre) return\n    end do\n\n    if (.not. allocated(library)) then\n      allocate(library(1))\n    else\n      allocate(library(size(library) + 1))\n      library(1:size(library) - 1) = library\n    end if\n\n    library(size(library))%genre = genre\n    allocate(library(size(library))%titles(0))\n  end subroutine add_genre\n\n  subroutine add_book(genre, title)\n    character(len=*), intent(in) :: genre, title\n    integer :: i\n\n    do i = 1, size(library)\n      if (library(i)%genre == genre) then\n        allocate(library(i)%titles(size(library(i)%titles) + 1))\n        library(i)%titles(size(library(i)%titles)) = title\n        return\n      end if\n    end do\n\n    call add_genre(genre)\n    call add_book(genre, title)\n  end subroutine add_book\n\n  subroutine get_books(genre, titles)\n    character(len=*), intent(in) :: genre\n    character(len=:), allocatable, intent(out) :: titles(:)\n    integer :: i\n\n    titles = []\n\n    do i = 1, size(library)\n      if (library(i)%genre == genre) then\n        titles = library(i)%titles\n        return\n      end if\n    end do\n  end subroutine get_books\n\nend module book_map\n```"
  },
  {
    "task": "Write a function that uses a dictionary to convert state abbreviations to full state names.",
    "code": "```fortran\nmodule state_conversion\n  implicit none\n  private\n  public :: get_full_state_name\n\ncontains\n\n  function get_full_state_name(abbreviation) result(full_name)\n    implicit none\n    character(len=*), intent(in) :: abbreviation\n    character(len=50) :: full_name\n    character(len=2), parameter :: state_abbr(5) = (/ 'CA', 'TX', 'NY', 'FL', 'IL' /)\n    character(len=50), parameter :: state_names(5) = (/ &\n      'California', 'Texas', 'New York', 'Florida', 'Illinois' /)\n    integer :: i\n\n    full_name = 'Unknown'\n    do i = 1, size(state_abbr)\n      if (trim(adjustl(state_abbr(i))) == trim(adjustl(abbreviation))) then\n        full_name = state_names(i)\n        return\n      end if\n    end do\n  end function get_full_state_name\n\nend module state_conversion\n```"
  },
  {
    "task": "Build a dictionary to store customer names and their order histories.",
    "code": "```fortran\nprogram customer_orders\n    implicit none\n    type CustomerOrder\n        character(len=100) :: name\n        character(len=100), allocatable :: orders(:)\n    end type CustomerOrder\n\n    type(CustomerOrder), allocatable :: customers(:)\n    \n    call initialize_customers(customers)\n    call add_order(customers, \"Alice\", \"Order1\")\n    call add_order(customers, \"Alice\", \"Order2\")\n    call add_order(customers, \"Bob\", \"Order3\")\n    \n    call print_customers(customers)\n    \ncontains\n\n    subroutine initialize_customers(customers)\n        type(CustomerOrder), allocatable, intent(out) :: customers(:)\n        allocate(customers(0))\n    end subroutine initialize_customers\n\n    subroutine add_order(customers, name, order)\n        type(CustomerOrder), allocatable, intent(inout) :: customers(:)\n        character(len=*), intent(in) :: name, order\n        integer :: i, idx\n        logical :: found\n\n        found = .false.\n        idx = -1\n\n        do i = 1, size(customers)\n            if (trim(customers(i)%name) == trim(name)) then\n                found = .true.\n                idx = i\n                exit\n            end if\n        end do\n\n        if (.not. found) then\n            idx = size(customers) + 1\n            call add_customer(customers, name)\n        end if\n\n        call add_order_to_customer(customers(idx), order)\n    end subroutine add_order\n\n    subroutine add_customer(customers, name)\n        type(CustomerOrder), allocatable, intent(inout) :: customers(:)\n        character(len=*), intent(in) :: name\n        integer :: n\n\n        n = size(customers) + 1\n        call move_alloc(customers, customers, source=customers)\n        allocate(customers(n))\n        customers(n)%name = name\n        allocate(customers(n)%orders(0))\n    end subroutine add_customer\n\n    subroutine add_order_to_customer(customer, order)\n        type(CustomerOrder), intent(inout) :: customer\n        character(len=*), intent(in) :: order\n        integer :: n\n\n        n = size(customer%orders) + 1\n        call move_alloc(customer%orders, customer%orders, source=customer%orders)\n        allocate(customer%orders(n))\n        customer%orders(n) = order\n    end subroutine add_order_to_customer\n\n    subroutine print_customers(customers)\n        type(CustomerOrder), allocatable, intent(in) :: customers(:)\n        integer :: i, j\n\n        do i = 1, size(customers)\n            print *, 'Customer:', trim(customers(i)%name)\n            do j = 1, size(customers(i)%orders)\n                print *, ' Order:', trim(customers(i)%orders(j))\n            end do\n        end do\n    end subroutine print_customers\n\nend program customer_orders\n```"
  },
  {
    "task": "Implement a map to manage parking lot spaces, tracking which spaces are occupied.",
    "code": "```fortran\nmodule parking_lot\n  implicit none\n  private\n  integer, parameter :: max_spaces = 100\n  type :: parking_space\n    character(len=20) :: license_plate\n    logical :: occupied = .false.\n  end type parking_space\n\n  type(parking_space), dimension(max_spaces) :: spaces\n\ncontains\n\n  subroutine initialize_lot()\n    integer :: i\n    do i = 1, max_spaces\n      spaces(i)%occupied = .false.\n    end do\n  end subroutine initialize_lot\n\n  subroutine park_car(space_number, plate)\n    integer, intent(in) :: space_number\n    character(len=*), intent(in) :: plate\n    if (space_number >= 1 .and. space_number <= max_spaces) then\n      spaces(space_number)%license_plate = plate\n      spaces(space_number)%occupied = .true.\n    end if\n  end subroutine park_car\n\n  subroutine remove_car(space_number)\n    integer, intent(in) :: space_number\n    if (space_number >= 1 .and. space_number <= max_spaces) then\n      spaces(space_number)%occupied = .false.\n    end if\n  end subroutine remove_car\n\n  function is_space_occupied(space_number) result(occupied)\n    integer, intent(in) :: space_number\n    logical :: occupied\n    if (space_number >= 1 .and. space_number <= max_spaces) then\n      occupied = spaces(space_number)%occupied\n    else\n      occupied = .false.\n    end if\n  end function is_space_occupied\n\nend module parking_lot\n```"
  },
  {
    "task": "Create a program that uses a dictionary to track the scores of players in a game.",
    "code": "```fortran\nprogram player_scores\n    use, intrinsic :: iso_c_binding\n    implicit none\n\n    type :: player_score\n        character(len=50) :: name\n        integer :: score\n    end type player_score\n\n    type(player_score), allocatable :: players(:)\n    integer :: i, player_count\n\n    ! Initialize the player scores\n    player_count = 3\n    allocate(players(player_count))\n    \n    players(1)%name = 'Alice'\n    players(1)%score = 10\n    \n    players(2)%name = 'Bob'\n    players(2)%score = 15\n    \n    players(3)%name = 'Charlie'\n    players(3)%score = 20\n\n    ! Print the player scores\n    do i = 1, player_count\n        print *, 'Player: ', players(i)%name, ' Score: ', players(i)%score\n    end do\n\n    deallocate(players)\nend program player_scores\n```"
  },
  {
    "task": "Design a dictionary to store scientific terms and their definitions, allowing users to look up definitions.",
    "code": "```fortran\nprogram scientific_dictionary\n  implicit none\n  type :: dictionary\n    character(len=:), allocatable :: term\n    character(len=:), allocatable :: definition\n  end type dictionary\n\n  type(dictionary), allocatable :: dict(:)\n  integer :: i, n\n  character(len=100) :: search_term\n\n  ! Initialize the dictionary with some terms\n  n = 3\n  allocate(dict(n))\n  \n  dict(1)%term = 'Atom'\n  dict(1)%definition = 'The basic unit of a chemical element.'\n\n  dict(2)%term = 'Molecule'\n  dict(2)%definition = 'A group of atoms bonded together.'\n\n  dict(3)%term = 'Cell'\n  dict(3)%definition = 'The smallest structural and functional unit of an organism.'\n\n  ! Allow user to look up definitions\n  print *, 'Enter a scientific term to look up its definition:'\n  read *, search_term\n\n  do i = 1, n\n    if (trim(adjustl(dict(i)%term)) == trim(adjustl(search_term))) then\n      print *, 'Definition of ', dict(i)%term, ': ', dict(i)%definition\n      exit\n    end if\n  end do\n\n  if (i > n) print *, 'Term not found.'\n\nend program scientific_dictionary\n```"
  },
  {
    "task": "Write a function that uses a map to convert temperature scales (e.g., Celsius to Fahrenheit).",
    "code": "```fortran\nmodule temperature_conversion\n  implicit none\ncontains\n\n  function convert_temperature(value, from_scale, to_scale) result(converted_value)\n    real :: value\n    character(len=*), intent(in) :: from_scale, to_scale\n    real :: converted_value\n    integer :: i\n    character(len=10), dimension(4) :: scales = [ \"Celsius\", \"Fahrenheit\", \"Kelvin\", \"Rankine\" ]\n    integer :: from_index, to_index\n\n    ! Find indices of the scales\n    from_index = -1\n    to_index = -1\n    do i = 1, size(scales)\n      if (from_scale == scales(i)) from_index = i\n      if (to_scale == scales(i)) to_index = i\n    end do\n\n    ! Convert temperature\n    if (from_index == 1 .and. to_index == 2) then\n      ! Celsius to Fahrenheit\n      converted_value = value * 9.0 / 5.0 + 32.0\n    else if (from_index == 2 .and. to_index == 1) then\n      ! Fahrenheit to Celsius\n      converted_value = (value - 32.0) * 5.0 / 9.0\n    else if (from_index == 1 .and. to_index == 3) then\n      ! Celsius to Kelvin\n      converted_value = value + 273.15\n    else if (from_index == 3 .and. to_index == 1) then\n      ! Kelvin to Celsius\n      converted_value = value - 273.15\n    else if (from_index == 1 .and. to_index == 4) then\n      ! Celsius to Rankine\n      converted_value = (value + 273.15) * 9.0 / 5.0\n    else if (from_index == 4 .and. to_index == 1) then\n      ! Rankine to Celsius\n      converted_value = (value - 491.67) * 5.0 / 9.0\n    else if (from_index == 2 .and. to_index == 3) then\n      ! Fahrenheit to Kelvin\n      converted_value = (value + 459.67) * 5.0 / 9.0\n    else if (from_index == 3 .and. to_index == 2) then\n      ! Kelvin to Fahrenheit\n      converted_value = value * 9.0 / 5.0 - 459.67\n    else if (from_index == 2 .and. to_index == 4) then\n      ! Fahrenheit to Rankine\n      converted_value = value + 459.67\n    else if (from_index == 4 .and. to_index == 2) then\n      ! Rankine to Fahrenheit\n      converted_value = value - 459.67\n    else if (from_index == 3 .and. to_index == 4) then\n      ! Kelvin to Rankine\n      converted_value = value * 9.0 / 5.0\n    else if (from_index == 4 .and. to_index == 3) then\n      ! Rankine to Kelvin\n      converted_value = value * 5.0 / 9.0\n    else\n      converted_value = value\n    end if\n\n  end function convert_temperature\n\nend module temperature_conversion\n```"
  },
  {
    "task": "Create a dictionary to store employee names and their respective departments.",
    "code": "```fortran\nprogram employee_directory\n    implicit none\n    type :: Employee\n        character(len=50) :: name\n        character(len=50) :: department\n    end type Employee\n\n    type(Employee), allocatable :: employees(:)\n    integer :: i\n\n    integer, parameter :: num_employees = 3\n    character(len=50), dimension(num_employees) :: names = ['Alice', 'Bob', 'Charlie']\n    character(len=50), dimension(num_employees) :: departments = ['HR', 'Engineering', 'Marketing']\n\n    allocate(employees(num_employees))\n\n    do i = 1, num_employees\n        employees(i)%name = names(i)\n        employees(i)%department = departments(i)\n    end do\n\n    do i = 1, num_employees\n        print *, 'Name: ', employees(i)%name, ' Department: ', employees(i)%department\n    end do\n\nend program employee_directory\n```"
  },
  {
    "task": "Build a program that uses a map to store tourist attractions and their locations.",
    "code": "```fortran\nprogram tourist_attractions\n    implicit none\n    character(len=:), allocatable :: location\n    type :: attraction_map\n        character(len=50) :: attraction\n        character(len=50) :: location\n    end type attraction_map\n    type(attraction_map), dimension(:), allocatable :: attractions\n    integer :: i\n\n    allocate(attractions(3))\n    \n    attractions(1)%attraction = \"Eiffel Tower\"\n    attractions(1)%location = \"Paris\"\n    \n    attractions(2)%attraction = \"Colosseum\"\n    attractions(2)%location = \"Rome\"\n    \n    attractions(3)%attraction = \"Statue of Liberty\"\n    attractions(3)%location = \"New York\"\n\n    do i = 1, size(attractions)\n        print *, \"Attraction:\", attractions(i)%attraction\n        print *, \"Location:\", attractions(i)%location\n    end do\nend program tourist_attractions\n```"
  },
  {
    "task": "Implement a dictionary to manage a collection of music albums, allowing additions and removals.",
    "code": "```fortran\nmodule album_manager\n  implicit none\n  type :: album\n    character(len=100) :: title\n    character(len=100) :: artist\n    integer :: year\n  end type album\n\n  type(album), allocatable :: albums(:)\n  integer, allocatable :: keys(:)\n\ncontains\n\n  subroutine add_album(key, new_album)\n    integer, intent(in) :: key\n    type(album), intent(in) :: new_album\n    integer :: idx\n\n    if (.not.allocated(keys)) then\n      allocate(keys(1))\n      allocate(albums(1))\n      keys(1) = key\n      albums(1) = new_album\n    else\n      idx = find_key(key)\n      if (idx == 0) then\n        call extend_arrays(key, new_album)\n      else\n        albums(idx) = new_album\n      end if\n    end if\n  end subroutine add_album\n\n  subroutine remove_album(key)\n    integer, intent(in) :: key\n    integer :: idx, i\n\n    idx = find_key(key)\n    if (idx /= 0) then\n      do i = idx, size(keys) - 1\n        keys(i) = keys(i + 1)\n        albums(i) = albums(i + 1)\n      end do\n      call shrink_arrays()\n    end if\n  end subroutine remove_album\n\n  integer function find_key(key)\n    integer, intent(in) :: key\n    integer :: i\n\n    find_key = 0\n    do i = 1, size(keys)\n      if (keys(i) == key) then\n        find_key = i\n        exit\n      end if\n    end do\n  end function find_key\n\n  subroutine extend_arrays(key, new_album)\n    integer, intent(in) :: key\n    type(album), intent(in) :: new_album\n    integer :: n\n\n    n = size(keys) + 1\n    call move_alloc(keys, keys, source=[keys, key])\n    call move_alloc(albums, albums, source=[albums, new_album])\n  end subroutine extend_arrays\n\n  subroutine shrink_arrays()\n    integer :: n\n\n    n = size(keys) - 1\n    if (n > 0) then\n      call move_alloc(keys, keys, source=keys(:n))\n      call move_alloc(albums, albums, source=albums(:n))\n    else\n      deallocate(keys)\n      deallocate(albums)\n    end if\n  end subroutine shrink_arrays\n\nend module album_manager\n```"
  },
  {
    "task": "Write a script that uses a map to track the inventory of a small retail store.",
    "code": "```fortran\nprogram RetailInventory\n  implicit none\n  type :: InventoryItem\n    character(len=50) :: name\n    integer :: quantity\n  end type InventoryItem\n\n  type(InventoryItem), allocatable :: inventory(:)\n  character(len=50), allocatable :: itemNames(:)\n  integer :: i, numItems\n\n  ! Initialize the inventory\n  numItems = 3\n  allocate(inventory(numItems))\n  allocate(itemNames(numItems))\n  \n  itemNames = ['Apples', 'Bananas', 'Oranges']\n  inventory(1) = InventoryItem(itemNames(1), 100)\n  inventory(2) = InventoryItem(itemNames(2), 150)\n  inventory(3) = InventoryItem(itemNames(3), 200)\n\n  ! Print the inventory\n  do i = 1, numItems\n    print *, 'Item:', inventory(i)%name, 'Quantity:', inventory(i)%quantity\n  end do\n\nend program RetailInventory\n```"
  },
  {
    "task": "Create a dictionary to store the names of rivers and their lengths, allowing length lookups by river name.",
    "code": "```fortran\nmodule river_module\n  implicit none\n  type :: river\n     character(len=50) :: name\n     real :: length\n  end type river\n\n  type(river), dimension(:), allocatable :: river_list\n\ncontains\n\n  subroutine add_river(name, length)\n    character(len=*), intent(in) :: name\n    real, intent(in) :: length\n    integer :: n\n\n    n = size(river_list)\n    if (.not. allocated(river_list)) then\n      allocate(river_list(1))\n    else\n      call move_alloc(river_list, river_list, source=[river_list, river(name, length)])\n    end if\n  end subroutine add_river\n\n  function get_length(name) result(length)\n    character(len=*), intent(in) :: name\n    real :: length\n    integer :: i\n\n    length = -1.0\n    do i = 1, size(river_list)\n      if (trim(river_list(i)%name) == trim(name)) then\n        length = river_list(i)%length\n        return\n      end if\n    end do\n  end function get_length\n\nend module river_module\n\nprogram main\n  use river_module\n  implicit none\n\n  call add_river('Amazon', 6992.0)\n  call add_river('Nile', 6650.0)\n  call add_river('Yangtze', 6300.0)\n\n  print *, 'Length of the Nile:', get_length('Nile')\n  print *, 'Length of the Amazon:', get_length('Amazon')\n  print *, 'Length of the Yangtze:', get_length('Yangtze')\n\nend program main\n```"
  },
  {
    "task": "Design a system that uses a map to track the availability of conference rooms in an office building.",
    "code": "```fortran\nprogram ConferenceRoomTracker\n    implicit none\n    integer, parameter :: maxRooms = 100\n    type Room\n        character(len=100) :: name\n        logical :: isAvailable\n    end type Room\n    type(Room), dimension(:), allocatable :: rooms\n    integer :: i, numRooms\n    character(len=100) :: roomName\n    logical :: availability\n\n    ! Example data initialization\n    numRooms = 3\n    allocate(rooms(numRooms))\n    rooms(1) = Room('Room A', .true.)\n    rooms(2) = Room('Room B', .false.)\n    rooms(3) = Room('Room C', .true.)\n\n    ! Display the availability of all rooms\n    print *, \"Conference Room Availability:\"\n    do i = 1, numRooms\n        print *, rooms(i)%name, \"is\", &\n               merge(\"Available\", \"Occupied\", rooms(i)%isAvailable)\n    end do\n\n    ! Check availability of a specific room\n    roomName = 'Room B'\n    availability = .false.\n    do i = 1, numRooms\n        if (rooms(i)%name == roomName) then\n            availability = rooms(i)%isAvailable\n            exit\n        end if\n    end do\n    print *, \"Room B is\", merge(\"Available\", \"Occupied\", availability)\n\nend program ConferenceRoomTracker\n```"
  },
  {
    "task": "Develop a program that uses a dictionary to associate animal species with their habitats.",
    "code": "```fortran\nprogram animal_habitats\n    implicit none\n    type :: habitat_dict\n        character(len=:), allocatable :: species(:)\n        character(len=:), allocatable :: habitats(:)\n    end type habitat_dict\n\n    type(habitat_dict) :: animal_habitats\n    integer :: i\n\n    call assign_habitats(animal_habitats)\n\n    print *, \"Animal Habitats:\"\n    do i = 1, size(animal_habitats%species)\n        print *, animal_habitats%species(i), \" - \", animal_habitats%habitats(i)\n    end do\ncontains\n\n    subroutine assign_habitats(dict)\n        type(habitat_dict), intent(out) :: dict\n        character(len=*), parameter :: species_list(3) = [ &\n            \"Lion\", \"Penguin\", \"Eagle\" &\n        ]\n        character(len=*), parameter :: habitat_list(3) = [ &\n            \"Savannah\", \"Antarctica\", \"Mountains\" &\n        ]\n\n        dict%species = species_list\n        dict%habitats = habitat_list\n    end subroutine assign_habitats\n\nend program animal_habitats\n```"
  },
  {
    "task": "Create a map to store the names of mountains and their elevations, then find the tallest mountain.",
    "code": "```fortran\nprogram tallest_mountain\n    implicit none\n    integer, parameter :: max_mountains = 100\n    type :: mountain\n        character(len=50) :: name\n        real :: elevation\n    end type mountain\n    type(mountain), dimension(max_mountains) :: mountains\n    integer :: count, i\n    real :: max_elevation\n    character(len=50) :: tallest_mountain_name\n\n    ! Initialize the map of mountains and their elevations\n    mountains(1) = mountain('Mount Everest', 8848.86)\n    mountains(2) = mountain('K2', 8611.0)\n    mountains(3) = mountain('Kangchenjunga', 8586.0)\n    ! Add more mountains as needed...\n    count = 3  ! Update count with the number of mountains added\n\n    ! Find the tallest mountain\n    max_elevation = mountains(1)%elevation\n    tallest_mountain_name = mountains(1)%name\n\n    do i = 2, count\n        if (mountains(i)%elevation > max_elevation) then\n            max_elevation = mountains(i)%elevation\n            tallest_mountain_name = mountains(i)%name\n        end if\n    end do\n\n    print *, 'The tallest mountain is ', tallest_mountain_name, ' with an elevation of ', max_elevation, ' meters.'\nend program tallest_mountain\n```"
  },
  {
    "task": "Write a function that uses a dictionary to convert time zones to their respective UTC offsets.",
    "code": "```fortran\nmodule timezone_module\n  implicit none\n  private\n  public :: get_utc_offset\n\ncontains\n\n  function get_utc_offset(timezone) result(offset)\n    character(len=*), intent(in) :: timezone\n    character(len=6) :: offset\n    integer :: i\n    character(len=20), dimension(:), parameter :: timezones = [ &\n      'EST', 'CST', 'MST', 'PST', 'GMT', 'CET', 'IST', 'JST' &\n    ]\n    character(len=6), dimension(8) :: offsets\n    offsets = [ &\n      '-05:00', '-06:00', '-07:00', '-08:00', '00:00', '+01:00', '+05:30', '+09:00' &\n    ]\n    offset = 'UNKNOWN'\n    do i = 1, size(timezones)\n      if (timezone == timezones(i)) then\n        offset = offsets(i)\n        exit\n      end if\n    end do\n  end function get_utc_offset\n\nend module timezone_module\n```"
  },
  {
    "task": "Build a dictionary to store the names of programming languages and their creators.",
    "code": "```fortran\nprogram programming_languages\n    implicit none\n    type :: creator_map\n        character(len=:), allocatable :: language\n        character(len=:), allocatable :: creator\n    end type creator_map\n    \n    type(creator_map), allocatable :: languages(:)\n    \n    call add_language(\"Python\", \"Guido van Rossum\")\n    call add_language(\"Java\", \"James Gosling\")\n    call add_language(\"C\", \"Dennis Ritchie\")\n    call add_language(\"Ruby\", \"Yukihiro Matsumoto\")\n    call add_language(\"JavaScript\", \"Brendan Eich\")\n    \n    contains\n    \n    subroutine add_language(lang, creator)\n        character(len=*), intent(in) :: lang, creator\n        integer :: n\n        \n        n = size(languages)\n        if (.not.allocated(languages)) then\n            allocate(languages(1))\n        else\n            allocate(languages(n+1))\n        endif\n        languages(n+1)%language = lang\n        languages(n+1)%creator = creator\n    end subroutine add_language\n    \nend program programming_languages\n```"
  },
  {
    "task": "Implement a map to manage a list of subscribers to a newsletter, allowing subscriptions and cancellations.",
    "code": "```fortran\nmodule subscriber_manager\n  implicit none\n  type :: subscriber\n    character(len=:), allocatable :: email\n  end type subscriber\n\n  type, extends(subscriber) :: subscriber_map\n    type(subscriber), allocatable :: subscribers(:)\n  contains\n    procedure :: add => add_subscriber\n    procedure :: remove => remove_subscriber\n  end type subscriber_map\n\ncontains\n\n  subroutine add_subscriber(this, email)\n    class(subscriber_map), intent(inout) :: this\n    character(len=*), intent(in) :: email\n    integer :: n\n\n    n = size(this%subscribers)\n    allocate(this%subscribers(n+1))\n    this%subscribers(n+1)%email = email\n  end subroutine add_subscriber\n\n  subroutine remove_subscriber(this, email)\n    class(subscriber_map), intent(inout) :: this\n    character(len=*), intent(in) :: email\n    integer :: i, j, n\n\n    n = size(this%subscribers)\n    do i = 1, n\n      if (this%subscribers(i)%email == email) then\n        do j = i, n-1\n          this%subscribers(j) = this%subscribers(j+1)\n        end do\n        n = n - 1\n        if (n > 0) then\n          allocate(this%subscribers(n))\n        else\n          deallocate(this%subscribers)\n        end if\n        exit\n      end if\n    end do\n  end subroutine remove_subscriber\n\nend module subscriber_manager\n```"
  },
  {
    "task": "Create a program that uses a dictionary to track the number of likes for social media posts.",
    "code": "```fortran\nprogram track_likes\n    implicit none\n    type :: post\n        character(len=50) :: post_id\n        integer :: likes\n    end type post\n\n    type(post), allocatable :: posts(:)\n    integer :: i, num_posts, found\n    character(len=50) :: input_id\n\n    num_posts = 0\n\n    do\n        print *, \"Enter post ID to like or 'exit':\"\n        read *, input_id\n        if (trim(adjustl(input_id)) == 'exit') exit\n\n        found = -1\n        do i = 1, num_posts\n            if (trim(adjustl(input_id)) == posts(i)%post_id) then\n                found = i\n                exit\n            end if\n        end do\n\n        if (found == -1) then\n            num_posts = num_posts + 1\n            if (.not.allocated(posts)) then\n                allocate(posts(1))\n            else\n                call move_alloc(posts, posts)\n                allocate(posts(num_posts))\n                posts(1:num_posts-1) = posts(1:num_posts-1)\n            end if\n            posts(num_posts)%post_id = trim(adjustl(input_id))\n            posts(num_posts)%likes = 1\n        else\n            posts(found)%likes = posts(found)%likes + 1\n        end if\n\n        print *, \"Post ID:\", trim(adjustl(input_id)), \"has\", posts(found)%likes, \"likes.\"\n    end do\n\nend program track_likes\n```"
  },
  {
    "task": "Design a dictionary to store the names of elements and their atomic numbers, allowing lookups by element name.",
    "code": "```fortran\nprogram element_dictionary\n    implicit none\n    integer, parameter :: n = 5\n    character(len=20), dimension(n) :: elements\n    integer, dimension(n) :: atomic_numbers\n    character(len=20) :: search_name\n    integer :: i, found\n\n    elements = [ \"Hydrogen\", \"Helium\", \"Lithium\", \"Beryllium\", \"Boron\" ]\n    atomic_numbers = [ 1, 2, 3, 4, 5 ]\n\n    search_name = \"Lithium\"\n    found = 0\n\n    do i = 1, n\n        if (elements(i) == search_name) then\n            print *, \"Element:\", elements(i), \"Atomic Number:\", atomic_numbers(i)\n            found = 1\n            exit\n        end if\n    end do\n\n    if (found == 0) then\n        print *, \"Element not found\"\n    end if\nend program element_dictionary\n```"
  },
  {
    "task": "Write a function that uses a map to group movies by their directors.",
    "code": "```fortran\nmodule movie_module\n  implicit none\n  type :: movie\n    character(len=:), allocatable :: title\n    character(len=:), allocatable :: director\n  end type movie\ncontains\n  subroutine group_movies_by_director(movies, director_map)\n    type(movie), intent(in) :: movies(:)\n    type(movie), allocatable :: movies_array(:)\n    type(movie), allocatable :: director_map(:)\n    character(len=:), allocatable :: director_names(:)\n    integer :: i, count, num_directors\n    logical :: found\n\n    num_directors = 0\n    allocate(director_names(0))\n\n    do i = 1, size(movies)\n      found = .false.\n      do count = 1, num_directors\n        if (movies(i)%director == director_names(count)) then\n          found = .true.\n          exit\n        end if\n      end do\n      if (.not. found) then\n        num_directors = num_directors + 1\n        call add_director(director_names, movies(i)%director, num_directors)\n      end if\n    end do\n\n    allocate(director_map(num_directors))\n    do count = 1, num_directors\n      director_map(count)%director = director_names(count)\n      call collect_movies(director_map(count)%movies_array, movies, director_names(count))\n    end do\n  end subroutine group_movies_by_director\n\n  subroutine add_director(director_names, new_director, num_directors)\n    character(len=:), allocatable, intent(inout) :: director_names(:)\n    character(len=*), intent(in) :: new_director\n    integer, intent(in) :: num_directors\n    allocate(character(len=len(new_director)) :: director_names(num_directors))\n    director_names(num_directors) = new_director\n  end subroutine add_director\n\n  subroutine collect_movies(movies_array, movies, director_name)\n    type(movie), allocatable, intent(out) :: movies_array(:)\n    type(movie), intent(in) :: movies(:)\n    character(len=*), intent(in) :: director_name\n    integer :: i, count\n\n    count = 0\n    do i = 1, size(movies)\n      if (movies(i)%director == director_name) then\n        count = count + 1\n      end if\n    end do\n\n    allocate(movies_array(count))\n    count = 0\n    do i = 1, size(movies)\n      if (movies(i)%director == director_name) then\n        count = count + 1\n        movies_array(count) = movies(i)\n      end if\n    end do\n  end subroutine collect_movies\nend module movie_module\n```"
  },
  {
    "task": "Create a dictionary to store the names of historical figures and their birth years.",
    "code": "```fortran\nprogram HistoricalFigures\n    implicit none\n    \n    type :: Figure\n        character(len=50) :: name\n        integer :: birthYear\n    end type Figure\n\n    type(Figure), allocatable :: figures(:)\n    integer :: i\n\n    allocate(figures(3))\n\n    figures(1) = Figure('Albert Einstein', 1879)\n    figures(2) = Figure('Isaac Newton', 1643)\n    figures(3) = Figure('Galileo Galilei', 1564)\n\n    do i = 1, size(figures)\n        print *, 'Name:', trim(figures(i)%name), 'Birth Year:', figures(i)%birthYear\n    end do\n\nend program HistoricalFigures\n```"
  },
  {
    "task": "Build a program that uses a map to store the names of planets and their diameters.",
    "code": "```fortran\nprogram PlanetDiameters\n    implicit none\n    type :: Planet\n        character(len=:), allocatable :: name\n        real :: diameter\n    end type Planet\n\n    type(Planet), allocatable :: planets(:)\n    integer :: i\n\n    allocate(planets(8))\n\n    planets(1) = Planet('Mercury', 4879.0)\n    planets(2) = Planet('Venus', 12104.0)\n    planets(3) = Planet('Earth', 12742.0)\n    planets(4) = Planet('Mars', 6779.0)\n    planets(5) = Planet('Jupiter', 139820.0)\n    planets(6) = Planet('Saturn', 116460.0)\n    planets(7) = Planet('Uranus', 50724.0)\n    planets(8) = Planet('Neptune', 49244.0)\n\n    do i = 1, size(planets)\n        print *, planets(i)%name, 'Diameter:', planets(i)%diameter\n    end do\n\nend program PlanetDiameters\n```"
  },
  {
    "task": "Implement a dictionary to track the ratings of restaurants, allowing updates to ratings.",
    "code": "```fortran\nmodule restaurant_ratings\n    implicit none\n    private\n    public :: restaurant_ratings_type, init_ratings, update_rating, get_rating\n\n    type :: restaurant_ratings_type\n        type(dictionary), allocatable :: ratings\n    contains\n        procedure :: update => update_rating\n        procedure :: get => get_rating\n    end type restaurant_ratings_type\n\n    interface\n        subroutine init_ratings(this)\n            import :: restaurant_ratings_type\n            class(restaurant_ratings_type), intent(inout) :: this\n        end subroutine init_ratings\n    end interface\n\n    interface\n        subroutine update_rating(this, restaurant, rating)\n            import :: restaurant_ratings_type\n            class(restaurant_ratings_type), intent(inout) :: this\n            character(len=*), intent(in) :: restaurant\n            real, intent(in) :: rating\n        end subroutine update_rating\n    end interface\n\n    interface\n        subroutine get_rating(this, restaurant, rating)\n            import :: restaurant_ratings_type\n            class(restaurant_ratings_type), intent(in) :: this\n            character(len=*), intent(in) :: restaurant\n            real, intent(out) :: rating\n        end subroutine get_rating\n    end interface\n\nend module restaurant_ratings\n\nmodule dictionary_module\n    implicit none\n    private\n    public :: dictionary, add_or_update, get_value\n\n    type :: entry\n        character(len=:), allocatable :: key\n        real :: value\n    end type entry\n\n    type :: dictionary\n        type(entry), allocatable :: data(:)\n    contains\n        procedure :: add_or_update => add_or_update_entry\n        procedure :: get_value => get_value_entry\n    end type dictionary\n\n    interface\n        subroutine add_or_update_entry(this, key, value)\n            import :: dictionary\n            class(dictionary), intent(inout) :: this\n            character(len=*), intent(in) :: key\n            real, intent(in) :: value\n        end subroutine add_or_update_entry\n    end interface\n\n    interface\n        subroutine get_value_entry(this, key, value, found)\n            import :: dictionary\n            class(dictionary), intent(in) :: this\n            character(len=*), intent(in) :: key\n            real, intent(out) :: value\n            logical, intent(out) :: found\n        end subroutine get_value_entry\n    end interface\n\ncontains\n\n    subroutine add_or_update_entry(this, key, value)\n        class(dictionary), intent(inout) :: this\n        character(len=*), intent(in) :: key\n        real, intent(in) :: value\n        integer :: i\n        logical :: found\n\n        found = .false.\n        do i = 1, size(this%data)\n            if (this%data(i)%key == key) then\n                this%data(i)%value = value\n                found = .true.\n                exit\n            end if\n        end do\n\n        if (.not. found) then\n            if (.not. allocated(this%data)) then\n                allocate(this%data(1))\n            else\n                call move_alloc(this%data, this%data, source=[this%data, entry(key, value)])\n            end if\n            this%data(size(this%data)%key) = key\n            this%data(size(this%data)%value) = value\n        end if\n    end subroutine add_or_update_entry\n\n    subroutine get_value_entry(this, key, value, found)\n        class(dictionary), intent(in) :: this\n        character(len=*), intent(in) :: key\n        real, intent(out) :: value\n        logical, intent(out) :: found\n        integer :: i\n\n        found = .false.\n        do i = 1, size(this%data)\n            if (this%data(i)%key == key) then\n                value = this%data(i)%value\n                found = .true.\n                return\n            end if\n        end do\n    end subroutine get_value_entry\n\nend module dictionary_module\n\nprogram main\n    use restaurant_ratings\n    implicit none\n\n    type(restaurant_ratings_type) :: ratings\n    real :: rating\n\n    call init_ratings(ratings)\n    call ratings%update(\"Pasta Place\", 4.5)\n    call ratings%update(\"Sushi Spot\", 4.8)\n    call ratings%get(\"Pasta Place\", rating)\n    print *, \"Pasta Place rating:\", rating\n\nend program main\n\nsubroutine init_ratings(this)\n    class(restaurant_ratings_type), intent(inout) :: this\n    use dictionary_module, only: dictionary\n    allocate(this%ratings)\n    this%ratings = dictionary()\nend subroutine init_ratings\n\nsubroutine update_rating(this, restaurant, rating)\n    class(restaurant_ratings_type), intent(inout) :: this\n    character(len=*), intent(in) :: restaurant\n    real, intent(in) :: rating\n    call this%ratings%add_or_update(restaurant, rating)\nend subroutine update_rating\n\nsubroutine get_rating(this, restaurant, rating)\n    class(restaurant_ratings_type), intent(in) :: this\n    character(len=*), intent(in) :: restaurant\n    real, intent(out) :: rating\n    logical :: found\n    call this%ratings%get_value(restaurant, rating, found)\n    if (.not. found) rating = -1.0\nend subroutine get_rating\n```"
  },
  {
    "task": "Write a script that uses a map to translate binary numbers to decimal.",
    "code": "```fortran\nprogram binary_to_decimal\n    implicit none\n    integer :: i, decimal\n    character(len=8), dimension(5) :: binaries = [ &\n        \"00000001\", \"00000010\", \"00000100\", \"00001000\", \"00010000\"]\n    integer, dimension(5) :: decimals\n    type, public :: map\n        character(len=8) :: key\n        integer :: value\n    end type map\n    type(map), dimension(5) :: dict\n\n    ! Initialize the dictionary\n    do i = 1, 5\n        dict(i)%key = binaries(i)\n        read(binaries(i), \"(B8)\") dict(i)%value\n    end do\n\n    ! Translate binary numbers to decimal\n    do i = 1, 5\n        decimal = dict(i)%value\n        print *, \"Binary:\", dict(i)%key, \"Decimal:\", decimal\n    end do\n\nend program binary_to_decimal\n```"
  },
  {
    "task": "Create a dictionary to store the names of artists and their famous works.",
    "code": "```fortran\nprogram artist_works\n    implicit none\n    type :: artist_work\n        character(len=50) :: artist\n        character(len=100) :: work\n    end type artist_work\n\n    type(artist_work), dimension(:), allocatable :: artist_dict\n    integer :: i\n\n    allocate(artist_dict(3))\n\n    artist_dict(1)%artist = \"Leonardo da Vinci\"\n    artist_dict(1)%work = \"Mona Lisa\"\n\n    artist_dict(2)%artist = \"Vincent van Gogh\"\n    artist_dict(2)%work = \"Starry Night\"\n\n    artist_dict(3)%artist = \"Pablo Picasso\"\n    artist_dict(3)%work = \"Guernica\"\n\n    do i = 1, size(artist_dict)\n        print *, \"Artist: \", trim(artist_dict(i)%artist)\n        print *, \"Work: \", trim(artist_dict(i)%work)\n    end do\n\nend program artist_works\n```"
  },
  {
    "task": "Design a system that uses a map to track the maintenance schedules of vehicles.",
    "code": "```fortran\nprogram vehicle_maintenance\n    implicit none\n    integer, parameter :: map_size = 100\n    character(len=20), dimension(map_size) :: vehicle_ids\n    character(len=20), dimension(map_size) :: maintenance_dates\n    integer :: i, map_count\n    character(len=20) :: search_id\n    logical :: found\n\n    ! Initialize the map\n    map_count = 0\n\n    ! Add vehicles and their maintenance dates\n    call add_vehicle(\"ABC123\", \"2023-11-01\")\n    call add_vehicle(\"XYZ789\", \"2023-12-15\")\n    call add_vehicle(\"LMN456\", \"2024-01-10\")\n\n    ! Search for a vehicle's maintenance date\n    search_id = \"XYZ789\"\n    found = .false.\n    do i = 1, map_count\n        if (vehicle_ids(i) == search_id) then\n            print *, \"Maintenance date for \", search_id, \" is \", maintenance_dates(i)\n            found = .true.\n            exit\n        end if\n    end do\n    if (.not. found) then\n        print *, \"Vehicle ID not found.\"\n    end if\n\ncontains\n\n    subroutine add_vehicle(id, date)\n        character(len=*), intent(in) :: id, date\n        if (map_count < map_size) then\n            map_count = map_count + 1\n            vehicle_ids(map_count) = id\n            maintenance_dates(map_count) = date\n        else\n            print *, \"Map is full. Cannot add more vehicles.\"\n        end if\n    end subroutine add_vehicle\n\nend program vehicle_maintenance\n```"
  },
  {
    "task": "Develop a program that uses a dictionary to associate languages with their number of speakers worldwide.",
    "code": "```fortran\nprogram language_speakers\n    use iso_fortran_env\n    implicit none\n    type :: language\n        character(len=:), allocatable :: name\n        integer :: num_speakers\n    end type language\n\n    type(language), allocatable :: languages(:)\n    integer :: i\n\n    allocate(languages(3))\n\n    languages(1)%name = 'English'\n    languages(1)%num_speakers = 1500  ! in millions\n\n    languages(2)%name = 'Mandarin'\n    languages(2)%num_speakers = 1100  ! in millions\n\n    languages(3)%name = 'Spanish'\n    languages(3)%num_speakers = 500   ! in millions\n\n    do i = 1, size(languages)\n        print '(A, I0, A)', trim(languages(i)%name), ': ', languages(i)%num_speakers, ' million speakers'\n    end do\n\nend program language_speakers\n```"
  },
  {
    "task": "Create a map to store the names of cities and their average annual temperatures.",
    "code": "```fortran\nprogram city_temperature_map\n    implicit none\n    type :: CityTemperature\n        character(len=:), allocatable :: city\n        real :: temperature\n    end type CityTemperature\n\n    type(CityTemperature), allocatable :: cityMap(:)\n    integer :: i\n\n    allocate(cityMap(3))\n    \n    cityMap(1)%city = \"New York\"\n    cityMap(1)%temperature = 12.7\n\n    cityMap(2)%city = \"Los Angeles\"\n    cityMap(2)%temperature = 18.5\n\n    cityMap(3)%city = \"Chicago\"\n    cityMap(3)%temperature = 10.3\n\n    print *, \"City temperatures:\"\n    do i = 1, size(cityMap)\n        print *, cityMap(i)%city, \":\", cityMap(i)%temperature\n    end do\nend program city_temperature_map\n```"
  },
  {
    "task": "Write a function that uses a dictionary to convert metric units to imperial units.",
    "code": "```fortran\nmodule UnitConverter\n  implicit none\n  private\n  public :: convert_metric_to_imperial\n\n  interface convert_metric_to_imperial\n     module procedure convert_metric_to_imperial_real\n  end interface\n\ncontains\n\n  function convert_metric_to_imperial_real(value, unit) result(converted_value)\n    real, intent(in) :: value\n    character(len=*), intent(in) :: unit\n    real :: converted_value\n\n    select case (trim(unit))\n    case ('meter')\n       converted_value = value * 3.28084\n    case ('kilogram')\n       converted_value = value * 2.20462\n    case ('liter')\n       converted_value = value * 0.264172\n    case default\n       converted_value = -1.0 ! Error value for unknown unit\n    end select\n\n  end function convert_metric_to_imperial_real\n\nend module UnitConverter\n```"
  },
  {
    "task": "Build a dictionary to store the names of sports and their respective world records.",
    "code": "```fortran\nprogram sports_records\n    implicit none\n    type :: sport_record\n        character(len=50) :: name\n        real :: record\n    end type sport_record\n\n    type(sport_record), allocatable :: records(:)\n    integer :: i, n\n    character(len=50) :: sport_names(3)\n    real :: sport_records(3)\n\n    ! Example data\n    sport_names = [\"100m Sprint\", \"Marathon\", \"Long Jump\"]\n    sport_records = [9.58, 120.0, 8.95]  ! Example records\n\n    n = size(sport_names)\n    allocate(records(n))\n\n    do i = 1, n\n        records(i)%name = sport_names(i)\n        records(i)%record = sport_records(i)\n    end do\n\n    ! Output to verify\n    do i = 1, n\n        print *, \"Sport:\", trim(records(i)%name), \"Record:\", records(i)%record\n    end do\n\nend program sports_records\n```"
  },
  {
    "task": "Implement a map to manage a list of favorite movies, allowing additions and deletions.",
    "code": "```fortran\nprogram favorite_movies\n  implicit none\n  type :: MovieMap\n     character(len=:), allocatable :: keys(:)\n     character(len=:), allocatable :: values(:)\n  contains\n     procedure :: add => add_movie\n     procedure :: delete => delete_movie\n     procedure :: list => list_movies\n  end type MovieMap\n\n  type(MovieMap) :: movies\n\n  call movies%add(\"Inception\", \"Sci-Fi\")\n  call movies%add(\"The Matrix\", \"Action\")\n  call movies%list()\n  call movies%delete(\"Inception\")\n  call movies%list()\n\ncontains\n\n  subroutine add_movie(this, title, genre)\n    class(MovieMap), intent(inout) :: this\n    character(len=*), intent(in) :: title, genre\n    integer :: i\n\n    do i = 1, size(this%keys)\n      if (this%keys(i) == title) return\n    end do\n\n    if (.not. allocated(this%keys)) then\n       allocate(character(len=32) :: this%keys(1))\n       allocate(character(len=32) :: this%values(1))\n       this%keys(1) = title\n       this%values(1) = genre\n    else\n       call move_alloc(this%keys, this%keys, new_size=size(this%keys)+1)\n       call move_alloc(this%values, this%values, new_size=size(this%values)+1)\n       this%keys(size(this%keys)) = title\n       this%values(size(this%values)) = genre\n    end if\n  end subroutine add_movie\n\n  subroutine delete_movie(this, title)\n    class(MovieMap), intent(inout) :: this\n    character(len=*), intent(in) :: title\n    integer :: i, idx\n\n    idx = -1\n    do i = 1, size(this%keys)\n      if (this%keys(i) == title) then\n         idx = i\n         exit\n      end if\n    end do\n\n    if (idx /= -1) then\n       this%keys(idx:) = this%keys(idx+1:)\n       this%values(idx:) = this%values(idx+1:)\n       call move_alloc(this%keys, this%keys, new_size=size(this%keys)-1)\n       call move_alloc(this%values, this%values, new_size=size(this%values)-1)\n    end if\n  end subroutine delete_movie\n\n  subroutine list_movies(this)\n    class(MovieMap), intent(in) :: this\n    integer :: i\n\n    if (.not. allocated(this%keys)) return\n\n    do i = 1, size(this%keys)\n       print *, \"Title:\", trim(this%keys(i)), \"Genre:\", trim(this%values(i))\n    end do\n  end subroutine list_movies\n\nend program favorite_movies\n```"
  },
  {
    "task": "Create a program that uses a dictionary to track the distances between pairs of cities.",
    "code": "```fortran\nprogram city_distances\n    implicit none\n    type :: city_pair\n        character(len=50) :: city1\n        character(len=50) :: city2\n    end type city_pair\n\n    type(city_pair), dimension(:), allocatable :: city_pairs\n    real, dimension(:), allocatable :: distances\n    integer :: n, i\n\n    n = 3\n    allocate(city_pairs(n))\n    allocate(distances(n))\n\n    city_pairs(1) = city_pair('New York', 'Los Angeles')\n    distances(1) = 2451.0\n\n    city_pairs(2) = city_pair('Chicago', 'Houston')\n    distances(2) = 1087.0\n\n    city_pairs(3) = city_pair('San Francisco', 'Seattle')\n    distances(3) = 679.0\n\n    do i = 1, n\n        print *, 'Distance between ', city_pairs(i)%city1, ' and ', &\n                 city_pairs(i)%city2, ' is ', distances(i), ' miles.'\n    end do\nend program city_distances\n```"
  },
  {
    "task": "Design a dictionary to store the names of planets and their orbital periods.",
    "code": "```fortran\nprogram PlanetOrbitalPeriods\n    implicit none\n    type :: PlanetDictionary\n        character(len=:), allocatable :: name\n        real :: orbitalPeriod\n    end type PlanetDictionary\n\n    type(PlanetDictionary), allocatable :: planets(:)\n    integer :: i\n\n    allocate(planets(8))\n    \n    planets(1)%name = \"Mercury\"\n    planets(1)%orbitalPeriod = 88.0\n\n    planets(2)%name = \"Venus\"\n    planets(2)%orbitalPeriod = 224.7\n\n    planets(3)%name = \"Earth\"\n    planets(3)%orbitalPeriod = 365.2\n\n    planets(4)%name = \"Mars\"\n    planets(4)%orbitalPeriod = 687.0\n\n    planets(5)%name = \"Jupiter\"\n    planets(5)%orbitalPeriod = 4331.0\n\n    planets(6)%name = \"Saturn\"\n    planets(6)%orbitalPeriod = 10747.0\n\n    planets(7)%name = \"Uranus\"\n    planets(7)%orbitalPeriod = 30589.0\n\n    planets(8)%name = \"Neptune\"\n    planets(8)%orbitalPeriod = 59800.0\n\n    do i = 1, size(planets)\n        print *, \"Planet: \", planets(i)%name, \"Orbital Period: \", planets(i)%orbitalPeriod\n    end do\nend program PlanetOrbitalPeriods\n```"
  },
  {
    "task": "Write a function that uses a map to convert HTML color codes to their respective color names.",
    "code": "```fortran\nmodule color_map_module\n  implicit none\n  private\n  public :: html_color_to_name\n\ncontains\n\n  function html_color_to_name(color_code) result(color_name)\n    character(len=*), intent(in) :: color_code\n    character(len=20) :: color_name\n    character(len=7), parameter :: html_colors(5) = &\n         (/'#FFFFFF', '#000000', '#FF0000', '#00FF00', '#0000FF'/)\n    character(len=20), parameter :: color_names(5) = &\n         (/'White', 'Black', 'Red', 'Lime', 'Blue'/)\n    integer :: i\n\n    color_name = 'Unknown'\n    do i = 1, size(html_colors)\n       if (color_code == html_colors(i)) then\n          color_name = color_names(i)\n          exit\n       end if\n    end do\n  end function html_color_to_name\n\nend module color_map_module\n```"
  },
  {
    "task": "Create a dictionary to store the names of composers and their famous compositions.",
    "code": "```fortran\nprogram composers_dictionary\n    implicit none\n    type :: composer\n        character(len=:), allocatable :: composition\n    end type composer\n\n    type(composer), allocatable :: composers(:)\n    integer :: i\n\n    allocate(composers(3))\n\n    composers(1)%composition = \"Ludwig van Beethoven - Symphony No. 9\"\n    composers(2)%composition = \"Wolfgang Amadeus Mozart - The Magic Flute\"\n    composers(3)%composition = \"Johann Sebastian Bach - Brandenburg Concertos\"\n\n    do i = 1, size(composers)\n        print *, composers(i)%composition\n    end do\n\nend program composers_dictionary\n```"
  },
  {
    "task": "Build a program that uses a map to store the names of bridges and their lengths.",
    "code": "```fortran\nprogram bridge_lengths\n    implicit none\n    type :: bridge_map\n        character(len=:), allocatable :: name\n        real :: length\n    end type bridge_map\n\n    type(bridge_map), allocatable :: bridges(:)\n    integer :: i, num_bridges\n\n    ! Initialize the map with data\n    num_bridges = 3\n    allocate(bridges(num_bridges))\n\n    bridges(1)%name = 'Golden Gate'\n    bridges(1)%length = 2737.4\n\n    bridges(2)%name = 'Brooklyn Bridge'\n    bridges(2)%length = 1825.0\n\n    bridges(3)%name = 'London Bridge'\n    bridges(3)%length = 269.0\n\n    ! Output the map\n    do i = 1, num_bridges\n        print *, 'Bridge: ', bridges(i)%name, ', Length: ', bridges(i)%length\n    end do\n\nend program bridge_lengths\n```"
  },
  {
    "task": "Implement a dictionary to manage a list of personal goals, allowing updates to goals.",
    "code": "```fortran\nprogram PersonalGoals\n    implicit none\n    type :: Goal\n        character(len=50) :: description\n    end type Goal\n\n    type, public :: GoalMap\n        type(Goal), allocatable :: goals(:)\n        character(len=50), allocatable :: keys(:)\n    contains\n        procedure :: add_goal\n        procedure :: update_goal\n        procedure :: print_goals\n    end type GoalMap\n\n    type(GoalMap) :: myGoals\n    character(len=50) :: key, newDescription\n\n    call myGoals%add_goal(\"Health\", \"Run a marathon\")\n    call myGoals%add_goal(\"Career\", \"Get a promotion\")\n    call myGoals%update_goal(\"Health\", \"Run a half-marathon\")\n    call myGoals%print_goals()\n\ncontains\n\n    subroutine add_goal(this, key, description)\n        class(GoalMap), intent(inout) :: this\n        character(len=50), intent(in) :: key, description\n        integer :: n\n\n        n = size(this%keys) + 1\n        allocate(character(len=50) :: this%keys(n))\n        allocate(type(Goal) :: this%goals(n))\n\n        this%keys(n) = key\n        this%goals(n)%description = description\n    end subroutine add_goal\n\n    subroutine update_goal(this, key, newDescription)\n        class(GoalMap), intent(inout) :: this\n        character(len=50), intent(in) :: key, newDescription\n        integer :: i\n\n        do i = 1, size(this%keys)\n            if (this%keys(i) == key) then\n                this%goals(i)%description = newDescription\n                return\n            end if\n        end do\n    end subroutine update_goal\n\n    subroutine print_goals(this)\n        class(GoalMap), intent(in) :: this\n        integer :: i\n\n        do i = 1, size(this%keys)\n            print *, \"Goal: \", this%keys(i), \", Description: \", this%goals(i)%description\n        end do\n    end subroutine print_goals\n\nend program PersonalGoals\n```"
  },
  {
    "task": "Write a script that uses a map to convert hexadecimal numbers to binary.",
    "code": "```fortran\nprogram hex_to_binary\n    implicit none\n    character(len=1), dimension(16) :: hex_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F']\n    character(len=4), dimension(16) :: bin_values = ['0000', '0001', '0010', '0011', '0100', '0101', '0110', '0111', '1000', '1001', '1010', '1011', '1100', '1101', '1110', '1111']\n    character(len=1) :: hex_digit\n    character(len=4) :: binary\n    integer :: i\n\n    ! Example hexadecimal input\n    character(len=50) :: hex_input = \"1A3F\"\n    character(len=200) :: binary_output\n    integer :: len_hex, pos\n\n    len_hex = len_trim(hex_input)\n    binary_output = \"\"\n\n    do i = 1, len_hex\n        hex_digit = hex_input(i:i)\n        pos = 0\n        do while (pos < 16)\n            pos = pos + 1\n            if (hex_digit == hex_chars(pos)) exit\n        end do\n        binary = bin_values(pos)\n        binary_output = trim(binary_output) // binary\n    end do\n\n    print *, \"Hexadecimal: \", trim(hex_input)\n    print *, \"Binary:      \", trim(binary_output)\nend program hex_to_binary\n```"
  },
  {
    "task": "Create a dictionary to store the names of trees and their average heights.",
    "code": "```fortran\nprogram tree_heights\n    use, intrinsic :: iso_fortran_env, only: int32\n    implicit none\n    \n    type :: tree_info\n        character(len=:), allocatable :: name\n        real :: average_height\n    end type tree_info\n    \n    type(tree_info), allocatable :: tree_dict(:)\n    \n    integer :: i\n    \n    allocate(tree_dict(2))\n    \n    tree_dict(1)%name = 'Oak'\n    tree_dict(1)%average_height = 70.0\n    \n    tree_dict(2)%name = 'Pine'\n    tree_dict(2)%average_height = 80.0\n\n    do i = 1, size(tree_dict)\n        print *, 'Tree:', tree_dict(i)%name, 'Average Height:', tree_dict(i)%average_height\n    end do\nend program tree_heights\n```"
  }
]